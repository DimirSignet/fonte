{"sha": "ff32a690a2cc73d709ec7d079ee73d92eba99183", "log": "Merged from 1.9.0  --HG-- rename : src/org/mockito/internal/MockHandlerInterface.java => src/org/mockito/internal/InternalMockHandler.java rename : src/org/mockito/internal/MockHandler.java => src/org/mockito/internal/MockHandlerImpl.java rename : src/org/mockito/internal/debugging/Location.java => src/org/mockito/internal/debugging/LocationImpl.java rename : src/org/mockito/internal/invocation/StubInfo.java => src/org/mockito/internal/invocation/StubInfoImpl.java rename : src/org/mockito/exceptions/verification/junit/JUnitTool.java => src/org/mockito/internal/junit/JUnitTool.java rename : src/org/mockito/exceptions/Discrepancy.java => src/org/mockito/internal/reporting/Discrepancy.java rename : src/org/mockito/exceptions/Pluralizer.java => src/org/mockito/internal/reporting/Pluralizer.java rename : src/org/mockito/stubbing/answers/ReturnsElementsOf.java => src/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java rename : src/org/mockito/internal/util/MockName.java => src/org/mockito/internal/util/MockNameImpl.java rename : src/org/mockito/internal/util/ArrayUtils.java => src/org/mockito/internal/util/collections/ArrayUtils.java rename : src/org/mockito/internal/MockitoInvocationHandler.java => src/org/mockito/invocation/MockHandler.java rename : test/org/mockito/exceptions/PluralizerTest.java => test/org/mockito/internal/reporting/PluralizerTest.java rename : test/org/mockito/internal/util/MockNameTest.java => test/org/mockito/internal/util/MockNameImplTest.java rename : test/org/mockitousage/internal/debugging/LocationTest.java => test/org/mockitousage/internal/debugging/LocationImplTest.java", "commit": "\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.stubbing.answers.ReturnsElementsOf;\n--- a/src/org/mockito/Answers.java\n+++ b/src/org/mockito/Answers.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.stubbing.answers.CallsRealMethods;\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.matchers.CapturingMatcher;\n  * in your code. If you want specific types, then you should do that the captured values.\n  * This behavior might change (type checks could be added) in a\n  * future major release.\n- *\n  * <p>\n  * There is an <strong>annotation</strong> that you might find useful: &#64;{@link Captor}\n- *\n  * <p>\n  * See the full documentation on Mockito in javadoc for {@link Mockito} class.\n  *\n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.stubbing.Answer;\n--- a/src/org/mockito/Captor.java\n+++ b/src/org/mockito/Captor.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.*;\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.Documented;\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.hamcrest.Matcher;\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.Documented;\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.listeners.InvocationListener;\n--- a/src/org/mockito/MockingDetails.java\n+++ b/src/org/mockito/MockingDetails.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.util.DefaultMockingDetails;\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.MockitoCore;\n  *\n  * <h3 id=\"4\">4. <a class=\"meaningful_link\" href=\"#exact_verification\">Verifying exact number of invocations</a> /\n  * <a class=\"meaningful_link\" href=\"#at_least_verification\">at least x</a> / never</h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //using mock \n  * mockedList.add(\"once\");\n  *\n  *\n  * <h3 id=\"8\">8. <a class=\"meaningful_link\" href=\"#finding_redundant_invocations\">Finding redundant invocations</a></h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //using mocks\n  * mockedList.add(\"one\");\n  *\n  *\n  * <h3 id=\"9\">9. <a class=\"meaningful_link\" href=\"#mock_annotation\">Shorthand for mocks creation - <code>&#064;Mock</code> annotation</a></h3>\n- * \n+ *\n  * <ul>\n  * <li>Minimizes repetitive mock creation code.</li>\n  * <li>Makes the test class more readable.</li>\n  *\n  *\n  * <h3 id=\"11\">11. <a class=\"meaningful_link\" href=\"#answer_stubs\">Stubbing with callbacks</a></h3>\n- * \n+ *\n  * Allows stubbing with generic {@link Answer} interface.\n-*  <p>\n+ * <p>\n  * Yet another controversial feature which was not included in Mockito\n  * originally. We recommend using simple stubbing with <code>thenReturn()</code> or\n  * <code>thenThrow()</code> only. Those two should be <b>just enough</b> to test/test-drive\n  *\n  * <h3 id=\"12\">12. <a class=\"meaningful_link\" href=\"#do_family_methods_stubs\"><code>doReturn()</code>|<code>doThrow()</code>|\n  * <code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a></h3>\n- * \n+ *\n  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not\n  * like void methods inside brackets...\n  * <p>\n  *\n  *\n  * <h3 id=\"14\">14. Changing <a class=\"meaningful_link\" href=\"#defaultreturn\">default return values of unstubbed invocations</a> (Since 1.7)</h3>\n- * \n+ *\n  * You can create a mock with specified strategy for its return values.\n  * It's quite advanced feature and typically you don't need it to write decent tests.\n  * However, it can be helpful for working with <b>legacy systems</b>.\n  *\n  *\n  * <h3 id=\"18\">18. <a class=\"meaningful_link\" href=\"#framework_validation\">Troubleshooting & validating framework usage</a> (Since 1.8.0)</h3>\n- * \n+ *\n  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n  * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n  * <p>\n  *\n  *\n  * <h3 id=\"20\">20. <a class=\"meaningful_link\" href=\"#serializable_mocks\">Serializable mocks</a> (Since 1.8.1)</h3>\n- * \n+ *\n  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n  * <p>\n  * WARNING: This should be rarely used in unit testing. \n      *   assertEquals(\"deep\", mock.getBar().getName());\n      * </code></pre>\n      * </p>\n-     * \n+     *\n      * <p>\n      * <strong>WARNING: </strong>\n      * This feature should rarely be required for regular clean code! Leave it for legacy code.\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.*;\n--- a/src/org/mockito/exceptions/Discrepancy.java\n+++ b/src/org/mockito/exceptions/Discrepancy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.exceptions;\n \n @Deprecated\n--- a/src/org/mockito/exceptions/Pluralizer.java\n+++ b/src/org/mockito/exceptions/Pluralizer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.exceptions;\n \n @Deprecated\n--- a/src/org/mockito/exceptions/verification/junit/JUnitTool.java\n+++ b/src/org/mockito/exceptions/verification/junit/JUnitTool.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.exceptions.verification.junit;\n \n @Deprecated\n--- a/src/org/mockito/internal/InternalMockHandler.java\n+++ b/src/org/mockito/internal/InternalMockHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import java.util.List;\n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.exceptions.Reporter;\n--- a/src/org/mockito/internal/MockHandlerImpl.java\n+++ b/src/org/mockito/internal/MockHandlerImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.InOrder;\n--- a/src/org/mockito/internal/configuration/CaptorAnnotationProcessor.java\n+++ b/src/org/mockito/internal/configuration/CaptorAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.ArgumentCaptor;\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.configuration.IMockitoConfiguration;\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.Captor;\n--- a/src/org/mockito/internal/configuration/FieldAnnotationProcessor.java\n+++ b/src/org/mockito/internal/configuration/FieldAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import java.lang.annotation.Annotation;\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.*;\n--- a/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n+++ b/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.Mock;\n--- a/src/org/mockito/internal/configuration/MockitoAnnotationsMockAnnotationProcessor.java\n+++ b/src/org/mockito/internal/configuration/MockitoAnnotationsMockAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.Mockito;\n--- a/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration.injection.filter;\n \n import org.mockito.internal.util.MockUtil;\n--- a/src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java\n+++ b/src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration.injection.scanner;\n \n import org.mockito.Captor;\n--- a/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration.injection.scanner;\n \n import org.mockito.Mock;\n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n /*\n- * Copyright (c) 2012 Mockito contributors\n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.creation;\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import org.mockito.MockSettings;\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.jmock;\n \n import org.mockito.cglib.core.CodeGenerationException;\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.settings;\n \n import org.mockito.listeners.InvocationListener;\n--- a/src/org/mockito/internal/debugging/FindingsListener.java\n+++ b/src/org/mockito/internal/debugging/FindingsListener.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n--- a/src/org/mockito/internal/debugging/Localized.java\n+++ b/src/org/mockito/internal/debugging/Localized.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n \n--- a/src/org/mockito/internal/debugging/LocationImpl.java\n+++ b/src/org/mockito/internal/debugging/LocationImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import java.io.Serializable;\n--- a/src/org/mockito/internal/debugging/LoggingListener.java\n+++ b/src/org/mockito/internal/debugging/LoggingListener.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n--- a/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+++ b/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.MockitoDebugger;\n--- a/src/org/mockito/internal/debugging/WarningsCollector.java\n+++ b/src/org/mockito/internal/debugging/WarningsCollector.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n--- a/src/org/mockito/internal/debugging/WarningsFinder.java\n+++ b/src/org/mockito/internal/debugging/WarningsFinder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n--- a/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import java.util.List;\n--- a/src/org/mockito/internal/invocation/ArgumentsComparator.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsComparator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.hamcrest.Matcher;\n--- a/src/org/mockito/internal/invocation/ArgumentsProcessor.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.hamcrest.Matcher;\n--- a/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n+++ b/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n \n--- a/src/org/mockito/internal/invocation/InvocationMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationMarker.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import java.util.List;\n--- a/src/org/mockito/internal/invocation/StubInfoImpl.java\n+++ b/src/org/mockito/internal/invocation/StubInfoImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockito.invocation.DescribedInvocation;\n--- a/src/org/mockito/internal/junit/JUnitTool.java\n+++ b/src/org/mockito/internal/junit/JUnitTool.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.junit;\n \n import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n--- a/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n+++ b/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n import org.mockito.MockSettings;\n--- a/src/org/mockito/internal/listeners/MockingStartedListener.java\n+++ b/src/org/mockito/internal/listeners/MockingStartedListener.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n import org.mockito.MockSettings;\n--- a/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n+++ b/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n import org.mockito.invocation.DescribedInvocation;\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.matchers;\n \n import java.io.Serializable;\n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n import org.hamcrest.Matcher;\n--- a/src/org/mockito/internal/reporting/Discrepancy.java\n+++ b/src/org/mockito/internal/reporting/Discrepancy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.reporting;\n \n public class Discrepancy {\n--- a/src/org/mockito/internal/reporting/Pluralizer.java\n+++ b/src/org/mockito/internal/reporting/Pluralizer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.reporting;\n \n public class Pluralizer {\n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.reporting;\n \n import org.hamcrest.Matcher;\n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.reporting;\n \n \n--- a/src/org/mockito/internal/stubbing/InvocationContainer.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.mockito.invocation.Invocation;\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.mockito.exceptions.Reporter;\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import java.io.Serializable;\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.exceptions.Reporter;\n--- a/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+++ b/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.internal.util.Primitives;\n--- a/src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java\n+++ b/src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.exceptions.Reporter;\n--- a/src/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java\n+++ b/src/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.exceptions.base.MockitoException;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.mockito.Mockito;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import java.io.Serializable;\n--- a/src/org/mockito/internal/util/DefaultMockingDetails.java\n+++ b/src/org/mockito/internal/util/DefaultMockingDetails.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.MockingDetails;\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n--- a/src/org/mockito/internal/util/MockNameImpl.java\n+++ b/src/org/mockito/internal/util/MockNameImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.mock.MockName;\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n--- a/src/org/mockito/internal/util/MockitoSpy.java\n+++ b/src/org/mockito/internal/util/MockitoSpy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n /**\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import java.util.HashMap;\n--- a/src/org/mockito/internal/util/collections/ArrayUtils.java\n+++ b/src/org/mockito/internal/util/collections/ArrayUtils.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n @SuppressWarnings(\"unchecked\")\n--- a/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n import org.mockito.internal.util.MockUtil;\n--- a/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n import org.mockito.internal.util.Checks;\n--- a/src/org/mockito/internal/util/collections/IdentitySet.java\n+++ b/src/org/mockito/internal/util/collections/IdentitySet.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n import java.util.LinkedList;\n--- a/src/org/mockito/internal/util/collections/Sets.java\n+++ b/src/org/mockito/internal/util/collections/Sets.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n \n--- a/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n+++ b/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.Field;\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import org.mockito.exceptions.base.MockitoException;\n--- a/src/org/mockito/internal/util/reflection/Fields.java\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import org.mockito.Incubating;\n--- a/src/org/mockito/internal/util/reflection/InstanceField.java\n+++ b/src/org/mockito/internal/util/reflection/InstanceField.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import org.mockito.internal.util.Checks;\n--- a/src/org/mockito/internal/verification/InOrderContextImpl.java\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.mockito.internal.util.collections.IdentitySet;\n--- a/src/org/mockito/internal/verification/InOrderWrapper.java\n+++ b/src/org/mockito/internal/verification/InOrderWrapper.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.mockito.internal.InOrderImpl;\n--- a/src/org/mockito/internal/verification/Only.java\n+++ b/src/org/mockito/internal/verification/Only.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import java.util.List;\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import java.util.List;\n--- a/src/org/mockito/internal/verification/api/InOrderContext.java\n+++ b/src/org/mockito/internal/verification/api/InOrderContext.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import org.mockito.invocation.Invocation;\n--- a/src/org/mockito/internal/verification/api/VerificationData.java\n+++ b/src/org/mockito/internal/verification/api/VerificationData.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import java.util.List;\n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import java.util.List;\n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import java.util.List;\n--- a/src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.checkers;\n \n import org.mockito.internal.reporting.Discrepancy;\n--- a/src/org/mockito/invocation/DescribedInvocation.java\n+++ b/src/org/mockito/invocation/DescribedInvocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.invocation;\n \n import org.mockito.exceptions.PrintableInvocation;\n--- a/src/org/mockito/invocation/Invocation.java\n+++ b/src/org/mockito/invocation/Invocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.invocation;\n \n import org.mockito.Incubating;\n--- a/src/org/mockito/invocation/Location.java\n+++ b/src/org/mockito/invocation/Location.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.invocation;\n \n import org.mockito.Incubating;\n--- a/src/org/mockito/invocation/MockHandler.java\n+++ b/src/org/mockito/invocation/MockHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.invocation;\n \n import org.mockito.Incubating;\n--- a/src/org/mockito/invocation/StubInfo.java\n+++ b/src/org/mockito/invocation/StubInfo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.invocation;\n \n import org.mockito.Incubating;\n--- a/src/org/mockito/listeners/MethodInvocationReport.java\n+++ b/src/org/mockito/listeners/MethodInvocationReport.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.listeners;\n \n import org.mockito.exceptions.PrintableInvocation;\n--- a/src/org/mockito/mock/MockName.java\n+++ b/src/org/mockito/mock/MockName.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.mock;\n \n /**\n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n /*\n- * Copyright (c) 2012 Mockito contributors\n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.plugins;\n--- a/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.runners;\n \n import java.lang.reflect.InvocationTargetException;\n--- a/src/org/mockito/runners/MockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/MockitoJUnitRunner.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.runners;\n \n import org.junit.runner.Description;\n--- a/src/org/mockito/stubbing/Answer.java\n+++ b/src/org/mockito/stubbing/Answer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.stubbing;\n \n import org.mockito.invocation.InvocationOnMock;\n--- a/src/org/mockito/stubbing/DeprecatedOngoingStubbing.java\n+++ b/src/org/mockito/stubbing/DeprecatedOngoingStubbing.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.stubbing;\n \n import org.mockito.Mockito;\n--- a/src/org/mockito/stubbing/OngoingStubbing.java\n+++ b/src/org/mockito/stubbing/OngoingStubbing.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.stubbing;\n \n import org.mockito.Mockito;\n--- a/src/org/mockito/stubbing/Stubber.java\n+++ b/src/org/mockito/stubbing/Stubber.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.stubbing;\n \n import org.mockito.Mockito;\n--- a/src/org/mockito/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/stubbing/VoidMethodStubbable.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.stubbing;\n \n import org.mockito.Mockito;\n--- a/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n+++ b/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.stubbing.answers;\n \n import java.util.Collection;\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.concurrentmockito;\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n--- a/test/org/mockito/MockingDetailsTest.java\n+++ b/test/org/mockito/MockingDetailsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import static org.junit.Assert.assertFalse;\n--- a/test/org/mockito/internal/InOrderImplTest.java\n+++ b/test/org/mockito/internal/InOrderImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import static java.util.Arrays.*;\n--- a/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n+++ b/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.junit.Before;\n--- a/test/org/mockito/internal/configuration/ReadingConfigurationFromClasspathTest.java\n+++ b/test/org/mockito/internal/configuration/ReadingConfigurationFromClasspathTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import java.io.IOException;\n--- a/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import static org.hamcrest.core.IsInstanceOf.*;\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import org.fest.assertions.Assertions;\n--- a/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n+++ b/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n \n import static org.mockito.Mockito.mock;\n--- a/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n+++ b/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.junit.After;\n--- a/test/org/mockito/internal/debugging/WarningsFinderTest.java\n+++ b/test/org/mockito/internal/debugging/WarningsFinderTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import static java.util.Arrays.*;\n--- a/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n+++ b/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.exceptions.util;\n \n import static java.util.Arrays.*;\n--- a/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n+++ b/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockito.invocation.Invocation;\n--- a/test/org/mockito/internal/invocation/ExposedInvocation.java\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockito.internal.creation.MockitoMethodProxy;\n--- a/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import java.util.Arrays;\n--- a/test/org/mockito/internal/reporting/PluralizerTest.java\n+++ b/test/org/mockito/internal/reporting/PluralizerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.reporting;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import java.util.ArrayList;\n--- a/test/org/mockito/internal/util/MockNameImplTest.java\n+++ b/test/org/mockito/internal/util/MockNameImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java\n+++ b/test/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/collections/IdentitySetTest.java\n+++ b/test/org/mockito/internal/util/collections/IdentitySetTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.collections;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/reflection/BeanPropertySetterTest.java\n+++ b/test/org/mockito/internal/util/reflection/BeanPropertySetterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import org.fest.assertions.Assertions;\n--- a/test/org/mockito/internal/util/reflection/FieldsTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n+++ b/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import static org.mockito.Matchers.*;\n--- a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.*;\n--- a/test/org/mockito/internal/verification/OnlyTest.java\n+++ b/test/org/mockito/internal/verification/OnlyTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import static org.junit.Assert.*;\n--- a/test/org/mockito/internal/verification/SmartPrinterTest.java\n+++ b/test/org/mockito/internal/verification/SmartPrinterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.junit.Before;\n--- a/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.checkers;\n \n import static java.util.Arrays.asList;\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n import java.io.IOException;\n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n import java.io.IOException;\n--- a/test/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java\n+++ b/test/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/basicapi/ResetTest.java\n+++ b/test/org/mockitousage/basicapi/ResetTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.basicapi;\n \n import static org.mockito.Matchers.*;\n--- a/test/org/mockitousage/bugs/ChildWithSameParentFieldInjectionTest.java\n+++ b/test/org/mockitousage/bugs/ChildWithSameParentFieldInjectionTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.bugs;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n+++ b/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.bugs;\n \n import org.junit.Before;\n--- a/test/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java\n+++ b/test/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.bugs;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/bugs/ParentClassNotPublicVeryWeirdBugTest.java\n+++ b/test/org/mockitousage/bugs/ParentClassNotPublicVeryWeirdBugTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.bugs;\n \n import org.junit.Ignore;\n--- a/test/org/mockitousage/configuration/ClassToBeMocked.java\n+++ b/test/org/mockitousage/configuration/ClassToBeMocked.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.configuration;\n \n /**\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.debugging;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/internal/debugging/LocationImplTest.java\n+++ b/test/org/mockitousage/internal/debugging/LocationImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.internal.debugging;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.misuse;\n \n import org.junit.After;\n--- a/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.stubbing;\n \n import org.fest.assertions.Assertions;\n--- a/test/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.stubbing;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.stubbing;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/verification/VerificationInOrderWithCallsTest.java\n+++ b/test/org/mockitousage/verification/VerificationInOrderWithCallsTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.verification;\n \n import org.junit.Rule;\n--- /dev/null\n+++ b/src/org/mockito/AdditionalAnswers.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import org.mockito.internal.stubbing.answers.ReturnsElementsOf;\n+import org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.internal.stubbing.answers.ReturnsArgumentAt;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Additional answers provides factory methods for less common answers.\n+ *\n+ * <p>Currently offer answers that can return the parameter of an invocation at a certain position.\n+ *\n+ * <p>See factory methods for more information : {@link #returnsFirstArg}, {@link #returnsSecondArg},\n+ * {@link #returnsLastArg} and {@link #returnsArgAt}\n+ *\n+ * @since 1.9.5\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class AdditionalAnswers {\n+    private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);\n+    private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);\n+    private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);\n+\n+    /**\n+     * Returns the first parameter of an invocation.\n+     *\n+     * <p>\n+     *     This additional answer could be used at stub time using the\n+     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(carKeyFob.authenticate(carKey)).will(returnsFirstArg());\n+     * daAnswer(returnsFirstArg()).when(carKeyFob).authenticate(carKey)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the first argument of the invocation.\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> returnsFirstArg() {\n+        return (Answer<T>) RETURNS_FIRST_ARGUMENT;\n+    }\n+\n+    /**\n+     * Returns the second parameter of an invocation.\n+     *\n+     * <p>\n+     *     This additional answer could be used at stub time using the\n+     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(trader.apply(leesFormula, onCreditDefaultSwap)).will(returnsSecondArg());\n+     * daAnswer(returnsSecondArg()).when(trader).apply(leesFormula, onCreditDefaultSwap)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the second argument of the invocation.\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> returnsSecondArg() {\n+        return (Answer<T>) RETURNS_SECOND_ARGUMENT;\n+    }\n+\n+    /**\n+     * Returns the last parameter of an invocation.\n+     *\n+     * <p>\n+     *     This additional answer could be used at stub time using the\n+     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsLastArg());\n+     * daAnswer(returnsLastArg()).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the last argument of the invocation.\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> returnsLastArg() {\n+        return (Answer<T>) RETURNS_LAST_ARGUMENT;\n+    }\n+\n+    /**\n+     * Returns the parameter of an invocation at the given position.\n+     *\n+     * <p>\n+     * This additional answer could be used at stub time using the\n+     * <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsArgAt(3));\n+     * daAnswer(returnsArgAt(3)).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the second argument of the invocation.\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> returnsArgAt(int position) {\n+        return (Answer<T>) new ReturnsArgumentAt(position);\n+    }\n+\n+    /**\n+     * An answer that directly forwards the calls to the delegate.\n+     *\n+     * Makes sense only for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API.\n+     * Possible use cases:\n+     * <ul>\n+     *     <li>Final classes but with an interface</li>\n+     *     <li>Already custom proxied object</li>\n+     *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n+     *     <li>...</li>\n+     * </ul>\n+     * Sets the real implementation to be called when the method is called on a mock object.\n+     * <p>\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   final class DontMessTheCodeOfThisList implements list { ... }\n+     *\n+     *   DontMessTheCodeOfThisList awesomeList = new DontMessTheCodeOfThisList();\n+     *\n+     *   List listWithDelegate = mock(List.class, delegatesTo(awesomeList));\n+     * </code></pre>\n+     *\n+     * <p>\n+     * This features suffer from the same drawback as the spy.\n+     * The mock will call the delegate if you use regular when().then() stubbing style.\n+     * Since the real implementation is called this might have some side effects.\n+     * Therefore you should to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List listWithDelegate = mock(List.class, AdditionalAnswers.delegatesTo(awesomeList));\n+     *\n+     *   //Impossible: real method is called so listWithDelegate.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(listWithDelegate.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(listWithDelegate).get(0);\n+     * </code></pre>\n+     *\n+     * @param delegate The delegate to forward calls to.\n+     * @return the answer\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> delegatesTo(Object delegate) {\n+        return (Answer<T>) new ForwardsInvocations(delegate);\n+    }\n+\n+    /**\n+     * Returns elements of the collection. Keeps returning the last element forever.\n+     * Might be useful on occasion when you have a collection of elements to return.\n+     * <p>\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   //this:\n+     *   when(mock.foo()).thenReturn(1, 2, 3);\n+     *\n+     *   //is equivalent to:\n+     *   when(mock.foo()).thenReturn(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));\n+     * </code></pre>\n+     *\n+     * @param elements The collection of elements to return.\n+     * @return the answer\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> returnsElementsOf(Collection<?> elements) {\n+        return (Answer<T>) new ReturnsElementsOf(elements);\n+    }\n+}\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n  */\n package org.mockito;\n \n-import java.util.List;\n-\n import org.mockito.internal.matchers.CapturingMatcher;\n import org.mockito.internal.progress.HandyReturnValues;\n \n+import java.util.List;\n+\n /**\n  * Use it to capture argument values for further assertions.\n+ *\n  * <p>\n  * Mockito verifies argument values in natural java style: by using an equals() method.\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * </code></pre>\n  *\n  * <p>\n- * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n+ * <strong>Warning:</strong> it is recommended to use ArgumentCaptor with verification <strong>but not</strong> with stubbing.\n  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n+ *\n  * <p>\n  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n  * Both techniques can be used for making sure certain arguments where passed to mocks. \n  * <li>you just need it to assert on argument values to complete verification</li>\n  * </ul>\n  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n+ *\n  * <p>\n- * This utility class <b>*don't do any type checks*</b>, the generic signatures are only there to avoid casting\n+ * This utility class <strong>*don't do any type checks*</strong>, the generic signatures are only there to avoid casting\n  * in your code. If you want specific types, then you should do that the captured values.\n  * This behavior might change (type checks could be added) in a\n  * future major release.\n  * <p>\n- * There is an <b>annotation</b> that you might find useful: &#64;{@link Captor}\n+ * There is an <strong>annotation</strong> that you might find useful: &#64;{@link Captor}\n  * <p>\n- * See the full documentation on Mockito in javadoc for {@link Mockito} class.    \n+ * See the full documentation on Mockito in javadoc for {@link Mockito} class.\n+ *\n+ * @see Captor\n+ * @since 1.8.0\n  */\n public class ArgumentCaptor<T> {\n     \n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n  *   assertEquals(failure, result);\n  * </code></pre>\n  * <p>\n- * One of the purposes of BDDMockito is also to show how to tailor the mocking syntax to a different programming style. \n+ * One of the purposes of BDDMockito is also to show how to tailor the mocking syntax to a different programming style.\n+ *\n+ * @since 1.8.0\n  */\n @SuppressWarnings(\"unchecked\")\n public class BDDMockito extends Mockito {\n     \n     /**\n      * See original {@link OngoingStubbing}\n+     * @since 1.8.0\n      */\n     public static interface BDDMyOngoingStubbing<T> {\n         \n         /**\n          * See original {@link OngoingStubbing#thenAnswer(Answer)}\n+         * @since 1.8.0\n          */\n         BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer);\n \n         /**\n          * See original {@link OngoingStubbing#then(Answer)}\n+         * @since 1.9.0\n          */\n         BDDMyOngoingStubbing<T> will(Answer<?> answer);\n \n         /**\n          * See original {@link OngoingStubbing#thenReturn(Object)}\n+         * @since 1.8.0\n          */\n         BDDMyOngoingStubbing<T> willReturn(T value);\n \n         /**\n          * See original {@link OngoingStubbing#thenReturn(Object, Object[])}\n+         * @since 1.8.0\n          */\n         BDDMyOngoingStubbing<T> willReturn(T value, T... values);\n \n         /**\n          * See original {@link OngoingStubbing#thenThrow(Throwable...)}\n+         * @since 1.8.0\n          */\n         BDDMyOngoingStubbing<T> willThrow(Throwable... throwables);\n \n         /**\n          * See original {@link OngoingStubbing#thenThrow(Class[])}\n+         * @since 1.9.0\n          */\n         BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses);\n \n         /**\n          * See original {@link OngoingStubbing#thenCallRealMethod()}\n+         * @since 1.9.0\n          */\n         BDDMyOngoingStubbing<T> willCallRealMethod();\n \n         /**\n          * See original {@link OngoingStubbing#getMock()}\n+         * @since 1.9.0\n          */\n         <M> M getMock();\n     }\n     \n     /**\n      * see original {@link Mockito#when(Object)}\n+     * @since 1.8.0\n      */\n     public static <T> BDDMyOngoingStubbing<T> given(T methodCall) {\n         return new BDDOngoingStubbingImpl<T>(Mockito.when(methodCall));\n     \n     /**\n      * See original {@link Stubber}\n+     * @since 1.8.0\n      */\n     public static interface BDDStubber {\n         /**\n          * See original {@link Stubber#doAnswer(Answer)}\n+         * @since 1.8.0\n          */\n         BDDStubber willAnswer(Answer answer);\n         \n         /**\n          * See original {@link Stubber#doNothing()}\n+         * @since 1.8.0\n          */\n         BDDStubber willNothing();\n         \n         /**\n          * See original {@link Stubber#doReturn(Object)}\n+         * @since 1.8.0\n          */\n         BDDStubber willReturn(Object toBeReturned);\n         \n         /**\n          * See original {@link Stubber#doThrow(Throwable)}\n+         * @since 1.8.0\n          */\n         BDDStubber willThrow(Throwable toBeThrown);\n \n         /**\n          * See original {@link Stubber#doThrow(Class)}\n+         * @since 1.9.0\n          */\n         BDDStubber willThrow(Class<? extends Throwable> toBeThrown);\n \n         /**\n+         * See original {@link Stubber#doCallRealMethod()}\n+         * @since 1.9.0\n+         */\n+        BDDStubber willCallRealMethod();\n+\n+        /**\n          * See original {@link Stubber#when(Object)}\n+         * @since 1.8.0\n          */\n         <T> T given(T mock);\n     }\n         public BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {\n             return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));\n         }\n+\n+        /* (non-Javadoc)\n+         * @see BDDMockito.BDDStubber#willCallRealMethod()\n+         */\n+        public BDDStubber willCallRealMethod() {\n+            return new BDDStubberImpl(mockitoStubber.doCallRealMethod());\n+        }\n     }\n     \n     /**\n      * see original {@link Mockito#doThrow(Throwable)}\n+     * @since 1.8.0\n      */\n     public static BDDStubber willThrow(Throwable toBeThrown) {\n         return new BDDStubberImpl(Mockito.doThrow(toBeThrown));\n \n     /**\n      * see original {@link Mockito#doThrow(Throwable)}\n+     * @since 1.9.0\n      */\n     public static BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {\n         return new BDDStubberImpl(Mockito.doThrow(toBeThrown));\n     \n     /**\n      * see original {@link Mockito#doAnswer(Answer)}\n+     * @since 1.8.0\n      */\n     public static BDDStubber willAnswer(Answer answer) {\n         return new BDDStubberImpl(Mockito.doAnswer(answer));\n     \n     /**\n      * see original {@link Mockito#doNothing()}\n+     * @since 1.8.0\n      */\n     public static BDDStubber willDoNothing() {\n         return new BDDStubberImpl(Mockito.doNothing());\n     \n     /**\n      * see original {@link Mockito#doReturn(Object)}\n+     * @since 1.8.0\n      */\n     public static BDDStubber willReturn(Object toBeReturned) {\n         return new BDDStubberImpl(Mockito.doReturn(toBeReturned));\n \n     /**\n      * see original {@link Mockito#doCallRealMethod()}\n+     * @since 1.8.0\n      */\n     public static BDDStubber willCallRealMethod() {\n         return new BDDStubberImpl(Mockito.doCallRealMethod());\n--- a/src/org/mockito/Captor.java\n+++ b/src/org/mockito/Captor.java\n \n /**\n  * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n+ *\n  * <p>Example:\n  * <pre class=\"code\"><code class=\"java\">\n  * public class Test{\n  *    }\n  * }\n  * </code></pre>\n+ *\n  * <p>\n  * One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n+ *\n+ * @see ArgumentCaptor\n+ * @since 1.8.3\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.FIELD)\n--- /dev/null\n+++ b/src/org/mockito/Incubating.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+/**\n+ * The annotation conveys following information:\n+ * <ul>\n+ * <li>The API is fairly new and we would appreciate your feedback. For example, what are you missing from the API\n+ * to solve your use case (yes, please, real use cases).</li>\n+ * <li>For types or methods that are already released this annotation means that that the API might change.\n+ * The chance for that is small and we will always try to make any changes in a backwards compatible way.\n+ * The only reason we would want to change it is to provide better support for using and extending Mockito.\n+ * </li>\n+ * <li>\n+ * For types or methods that are not yet released it means the API is <strong>work in progress</strong>\n+ * and can change before release.\n+ * </li>\n+ * </ul>\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface Incubating {\n+}\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n \n import java.lang.annotation.Documented;\n import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n \n /**\n+ * Mark a field on which injection should be performed.\n+ *\n  * <ul>\n  * <li>Allows shorthand mock and spy injection.</li>\n  * <li>Minimizes repetitive mock and spy injection.</li>\n  *     In these cases, you will have to satisfy dependencies yourself.</p></li>\n  *\n  *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n- *     then (using name if there is several property of the same type).\n+ *     then, if there is several property of the same type, by the match of the property name and the mock name.\n  *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  *\n  *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n- *     then (using name if there is several property of the same type).\n+ *     then, if there is several property of the same type, by the match of the field name and the mock name.\n  *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  * </ol>\n  *   public class ArticleManagerTest extends SampleBaseTestCase {\n  *\n  *       &#064;Mock private ArticleCalculator calculator;\n- *       &#064;Mock private ArticleDatabase database;\n+ *       &#064;Mock(name = \"database\") private ArticleDatabase dbMock; // note the mock name attribute\n  *       &#064;Spy private UserProvider userProvider = new ConsumerUserProvider();\n  *\n  *       &#064;InjectMocks private ArticleManager manager;\n  * a parameterized constructor only or a no-arg constructor only, or both.\n  * All these constructors can be package protected, protected or private, however\n  * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n+ * <u>Beware of private nest static classes too.</u>\n  *\n  * <p>The same stands for setters or fields, they can be declared with private\n  * visibility, Mockito will see them through reflection.\n  * <p>Property setter injection will happen here :</p>\n  * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManager {\n- *       ArticleManager() {\n- *           // no-arg constructor\n- *       }\n+ *       // no-arg constructor\n+ *       ArticleManager() {  }\n  *\n- *       void setDatabase(ArticleDatabase database) {\n- *           // setter\n- *       }\n+ *       // setter\n+ *       void setDatabase(ArticleDatabase database) { }\n+ *\n+ *       // setter\n+ *       void setCalculator(ArticleCalculator calculator) { }\n  *   }\n  * </code></pre>\n  *\n  * </p>\n  *\n  * <p>\n- * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated objects.\n- * A <code>MockitoJUnitRunner</code> can also be used to initialize mocks instead of the &#64;Before approach.\n- * <p>\n- *\n- * <p>\n+ * <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.\n  * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n  * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.\n- * You can also put initMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link org.mockito.runners.MockitoJUnitRunner}\n+ * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in\n+ * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n+ *\n+ * @see Mock\n+ * @see Spy\n+ * @see MockitoAnnotations#initMocks(Object)\n+ * @see org.mockito.runners.MockitoJUnitRunner\n+ * @since 1.8.3\n  */\n @Documented\n-@Target( { FIELD })\n-@Retention(RetentionPolicy.RUNTIME)\n+@Target(FIELD)\n+@Retention(RUNTIME)\n public @interface InjectMocks {}\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n  */\n package org.mockito;\n \n-import org.mockito.runners.MockitoJUnitRunner;\n-\n import java.lang.annotation.Documented;\n import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n \n /**\n+ * Mark a field as a mock.\n+ *\n  * <ul>\n  * <li>Allows shorthand mock creation.</li>\n  * <li>Minimizes repetitive mock creation code.</li>\n  *   public class ArticleManagerTest extends SampleBaseTestCase {\n  *\n  *       &#064;Mock private ArticleCalculator calculator;\n- *       &#064;Mock(name = \"dbMock\") private ArticleDatabase database;\n+ *       &#064;Mock(name = \"database\") private ArticleDatabase dbMock;\n  *       &#064;Mock(answer = RETURNS_MOCKS) private UserProvider userProvider;\n  *       &#064;Mock(extraInterfaces = {Queue.class, Observer.class}) private  articleMonitor;\n  *\n  *   }\n  * </code></pre>\n  *\n- * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated mocks.\n  * <p>\n+ * <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.\n  * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n  * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.\n- * You can also put initMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link MockitoJUnitRunner}\n+ * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in\n+ * {@link org.mockito.runners.MockitoJUnitRunner}.\n+ * </p>\n+ *\n+ * @see Mockito#mock(Class)\n+ * @see Spy\n+ * @see InjectMocks\n+ * @see MockitoAnnotations#initMocks(Object)\n+ * @see org.mockito.runners.MockitoJUnitRunner\n  */\n-@Target( { FIELD })\n-@Retention(RetentionPolicy.RUNTIME)\n+@Target(FIELD)\n+@Retention(RUNTIME)\n @Documented\n public @interface Mock {\n \n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n package org.mockito;\n \n import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n \n /**\n- * Allows mock creation with additional mock settings. \n- * <p>\n- * Don't use it too often. \n- * Consider writing simple tests that use simple mocks. \n+ * Allows mock creation with additional mock settings.\n+ * <p/>\n+ * Don't use it too often.\n+ * Consider writing simple tests that use simple mocks.\n  * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n  * If you cannot write a test in a simple way - refactor the code under test.\n- * <p>\n+ * <p/>\n  * Examples of mock settings:\n  * <pre class=\"code\"><code class=\"java\">\n  *   //Creates mock with different default answer & name\n  *   Foo mock = mock(Foo.class, withSettings()\n- *       .defaultAnswer(RETURNS_SMART_NULLS)\n- *       .name(\"cool mockie\"));\n- *       \n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                );\n+ *\n  *   //Creates mock with different default answer, descriptive name and extra interfaces\n  *   Foo mock = mock(Foo.class, withSettings()\n- *       .defaultAnswer(RETURNS_SMART_NULLS)\n- *       .name(\"cool mockie\")\n- *       .extraInterfaces(Bar.class));    \n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                .extraInterfaces(Bar.class));\n  * </code></pre>\n- * {@link MockSettings} has been introduced for two reasons. \n+ * {@link MockSettings} has been introduced for two reasons.\n  * Firstly, to make it easy to add another mock setting when the demand comes.\n  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n  */\n public interface MockSettings extends Serializable {\n-    \n+\n     /**\n      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n-     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>  \n-     * <p>\n-     * This mysterious feature should be used very occasionally. \n+     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n+     * <p>\n+     * This mysterious feature should be used very occasionally.\n      * The object under test should know exactly its collaborators & dependencies.\n      * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n-     * <p>   \n+     * <p>\n      * Examples:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n-     *   \n+     *\n      *   //now, the mock implements extra interfaces, so following casting is possible:\n      *   Bar bar = (Bar) foo;\n      *   Baz baz = (Baz) foo;\n      * </code></pre>\n-     * \n+     *\n      * @param interfaces extra interfaces the should implement.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings extraInterfaces(Class<?>... interfaces);\n \n     /**\n-     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n+     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n      * <p>\n      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n      * Examples:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n-     *   \n+     *\n      *   //Below does exactly the same:\n      *   Foo foo = mock(Foo.class, \"foo\");\n      * </code></pre>\n \n     /**\n      * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n-     * Sets the real implementation to be called when the method is called on a mock object.\n+     *\n+     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n      * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * <p>\n-     * However, there are rare cases when partial mocks come handy: \n+     * However, there are rare cases when partial mocks come handy:\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Enough warnings about partial mocks, see an example how spiedInstance() works:\n      * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, spiedInstance(fooInstance));\n-     *   \n+     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n+     *\n      *   //Below does exactly the same:\n      *   Foo foo = spy(fooInstance);\n      * </code></pre>\n-     * \n+     *\n+     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n+     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *\n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </code>\n+     *\n      * @param instance to spy on\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings spiedInstance(Object instance);\n \n     /**\n-     * Specifies default answers to interactions. \n+     * Specifies default answers to interactions.\n      * It's quite advanced feature and typically you don't need it to write decent tests.\n      * However it can be helpful when working with legacy systems.\n      * <p>\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n      *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n-     *   \n+     *\n      *   //Below does exactly the same:\n      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n      * </code></pre>\n-     * \n+     *\n      * @param defaultAnswer default answer to be used by mock when not stubbed\n      * @return settings instance so that you can fluently specify other settings\n      */\n      * </code></pre>\n      *\n      * @return settings instance so that you can fluently specify other settings\n+     * @since 1.8.1\n      */\n     MockSettings serializable();\n-    \n+\n     /**\n      * Enables real-time logging of method invocations on this mock. Can be used\n      * during test debugging in order to find wrong interactions with this mock.\n      * <pre class=\"code\"><code class=\"java\">\n      * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n      * </code></pre>\n-     * \n+     *\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings verboseLogging();\n-    \n+\n     /**\n      * Registers a listener for method invocations on this mock. The listener is\n      * notified every time a method on this mock is called.\n      * <p>\n      * Multiple listeners may be added, but the same object is only added once.\n      * The order, in which the listeners are added, is not guaranteed to be the\n-     * order in which the listeners are notified. \n-     * \n+     * order in which the listeners are notified.\n+     *\n      * Example:\n      * <pre class=\"code\"><code class=\"java\">\n      *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n      * </code></pre>\n-     * \n+     *\n      * See the {@link InvocationListener listener interface} for more details.\n-     * \n+     *\n      * @param listeners The invocation listeners to add. May not be null.\n      * @return settings instance so that you can fluently specify other settings\n      */\n--- /dev/null\n+++ b/src/org/mockito/MockingDetails.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import org.mockito.internal.util.DefaultMockingDetails;\n+import org.mockito.internal.util.MockUtil;\n+\n+/**\n+ * Class to inspect any object, and identify whether a particular object is either a mock or a spy.\n+ *\n+ * @since 1.9.5\n+ */\n+public abstract class MockingDetails {\n+    \n+\n+    /**\n+     * Create a MockingDetails to inspect a particular Object.\n+     * @param toInspect the object to inspect\n+     * @return A {@link org.mockito.MockingDetails} instance.\n+     *\n+     * @since 1.9.5\n+     */\n+    public static MockingDetails of( Object toInspect ){\n+        return new DefaultMockingDetails( toInspect, new MockUtil());\n+    }\n+\n+    /**\n+     * Find out whether the object is a mock.\n+     * @return true if the object is a mock or a spy.\n+     *\n+     * @since 1.9.5\n+     */\n+    public abstract boolean isMock();\n+\n+    /**\n+     * Find out whether the object is a spy.\n+     * @return true if the object is a spy.\n+     *\n+     * @since 1.9.5\n+     */\n+    public abstract boolean isSpy();\n+}\n+\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *      <a href=\"#9\">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation </a><br/>\n  *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n  *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n- *      <a href=\"#12\">12. <code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doReturn()</code> family of methods mostly for stubbing voids </a><br/>\n+ *      <a href=\"#12\">12. <code>doReturn()</code>|<code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a><br/>\n  *      <a href=\"#13\">13. Spying on real objects </a><br/>\n  *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\n  *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\n  *      <a href=\"#19\">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>\n  *      <a href=\"#20\">20. Serializable mocks (Since 1.8.1) </a><br/>\n  *      <a href=\"#21\">21. New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </a><br/>\n- *      <a href=\"#22\">22. (New) Verification with timeout (Since 1.8.5) </a><br/>\n- *      <a href=\"#23\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9)</a><br/>\n- *      <a href=\"#24\">24. (**New**) One-liner stubs (Since 1.9)</a><br/>\n- *      <a href=\"#25\">25. (**New**) Verification ignoring stubs (Since 1.9)</a><br/>\n+ *      <a href=\"#22\">22. Verification with timeout (Since 1.8.5) </a><br/>\n+ *      <a href=\"#23\">23. (New) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9.0)</a><br/>\n+ *      <a href=\"#24\">24. (New) One-liner stubs (Since 1.9.0)</a><br/>\n+ *      <a href=\"#25\">25. (New) Verification ignoring stubs (Since 1.9.0)</a><br/>\n+ *      <a href=\"#26\">26. (**New**) Mocking details (Since 1.9.5)</a><br/>\n+ *      <a href=\"#27\">27. (**New**) Forward calls to real instance (Since 1.9.5)</a><br/>\n+ *      <a href=\"#28\">28. (**New**) Introduction of the internal <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n  * </b>\n  * \n  * <p>\n  * Following examples mock a List, because everyone knows its interface (methods\n  * like <code>add()</code>, <code>get()</code>, <code>clear()</code> will be used). <br>\n  * You probably wouldn't mock List class 'in real'.\n- * \n- * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"1\">1. <a class=\"meaningful_link\" href=\"#verification\">Let's verify some behaviour!</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //Let's import Mockito statically so that the code looks clearer\n  * <p>\n  * Once created, mock will remember all interactions. Then you can selectively\n  * verify whatever interaction you are interested in.\n- * \n- * <h3 id=\"2\">2. How about some stubbing?</h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"2\">2. <a class=\"meaningful_link\" href=\"#stubbing\">How about some stubbing?</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //You can mock concrete classes, not only interfaces\n  * e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.</li>\n  * \n  * </ul>\n- * \n- * <h3 id=\"3\">3. Argument matchers</h3>\n- * \n+ *\n+ *\n+ *\n+ * <h3 id=\"3\">3. <a class=\"meaningful_link\" href=\"#argument_matchers\">Argument matchers</a></h3>\n+ *\n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n  * Sometimes, when extra flexibility is required then you might use argument matchers:  \n  * \n  * Internally, they record a matcher on a stack and return a dummy value (usually null).\n  * This implementation is due static type safety imposed by java compiler.\n  * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.\n- * \n- * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n- * \n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"4\">4. <a class=\"meaningful_link\" href=\"#exact_verification\">Verifying exact number of invocations</a> /\n+ * <a class=\"meaningful_link\" href=\"#at_least_verification\">at least x</a> / never</h3>\n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //using mock \n  * mockedList.add(\"once\");\n  * <p>\n  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n  * omitted.\n- * \n- * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"5\">5. <a class=\"meaningful_link\" href=\"#stubbing_with_exceptions\">Stubbing void methods with exceptions</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n  * Currently <code>stubVoid()</code> is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n- * \n- * <h3 id=\"6\">6. Verification in order</h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"6\">6. <a class=\"meaningful_link\" href=\"#in_order_verification\">Verification in order</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * // A. Single mock whose methods must be invoked in a particular order\n  * <p>\n  * Also, you can create InOrder object passing only mocks that are relevant for\n  * in-order verification.\n- * \n- * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"7\">7. <a class=\"meaningful_link\" href=\"#never_verification\">Making sure interaction(s) never happened on mock</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //using mocks - only mockOne is interacted\n  * verifyZeroInteractions(mockTwo, mockThree);\n  * \n  * </code></pre>\n- * \n- * <h3 id=\"8\">8. Finding redundant invocations</h3>\n- * \n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"8\">8. <a class=\"meaningful_link\" href=\"#finding_redundant_invocations\">Finding redundant invocations</a></h3>\n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //using mocks\n  * mockedList.add(\"one\");\n  * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.\n  * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.\n  * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n- * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+ * Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests. You can find further reading\n  * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n  * \n  * <p>   \n  * See also {@link Mockito#never()} - it is more explicit and\n  * communicates the intent well.\n  * <p>\n- * \n- * <h3 id=\"9\">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation</h3>\n- * \n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"9\">9. <a class=\"meaningful_link\" href=\"#mock_annotation\">Shorthand for mocks creation - <code>&#064;Mock</code> annotation</a></h3>\n+ *\n  * <ul>\n  * <li>Minimizes repetitive mock creation code.</li>\n  * <li>Makes the test class more readable.</li>\n  * You can use built-in runner: {@link MockitoJUnitRunner}.\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n- * \n- * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"10\">10. <a class=\"meaningful_link\" href=\"#stubbing_consecutive_calls\">Stubbing consecutive calls</a> (iterator-style stubbing)</h3>\n  * \n  * Sometimes we need to stub with different return value/exception for the same\n  * method call. Typical use case could be mocking iterators. \n  * when(mock.someMethod(\"some arg\"))\n  *   .thenReturn(\"one\", \"two\", \"three\");\n  * </code></pre>\n- * \n- * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n- * \n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"11\">11. <a class=\"meaningful_link\" href=\"#answer_stubs\">Stubbing with callbacks</a></h3>\n+ *\n  * Allows stubbing with generic {@link Answer} interface.\n-*  <p>\n+ * <p>\n  * Yet another controversial feature which was not included in Mockito\n  * originally. We recommend using simple stubbing with <code>thenReturn()</code> or\n  * <code>thenThrow()</code> only. Those two should be <b>just enough</b> to test/test-drive\n  * //Following prints \"called with arguments: foo\"\n  * System.out.println(mock.someMethod(\"foo\"));\n  * </code></pre>\n- * \n- * <h3 id=\"12\"> 12. <code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doReturn()</code> family of methods for stubbing voids (mostly)</h3>\n- * \n- * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"12\">12. <a class=\"meaningful_link\" href=\"#do_family_methods_stubs\"><code>doReturn()</code>|<code>doThrow()</code>|\n+ * <code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a></h3>\n+ *\n+ * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not\n+ * like void methods inside brackets...\n  * <p>\n  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n  * The main reason is improved readability and consistency with the family of <code>doAnswer()</code> methods.\n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n  * </code></pre>\n- * \n- * Read more about other methods:\n+ *\n+ * <p>\n+ * You can use <code>doThrow()</code>, <code>doAnswer()</code>, <code>doNothing()</code>, <code>doReturn()</code>\n+ * and <code>doCallRealMethod()</code> in place of the corresponding call with <code>when()</code>, for any method.\n+ * It is necessary when you\n+ * <ul>\n+ *     <li>stub void methods</li>\n+ *     <li>stub methods on spy objects (see below)</li>\n+ *     <li>stub the same method more than once, to change the behaviour of a mock in the middle of a test.</li>\n+ * </ul>\n+ * but you may prefer to use these methods in place of the alternative with <code>when()</code>, for all of your stubbing calls.\n+ * <p>\n+ * Read more about these methods:\n+ * <p>\n+ * {@link Mockito#doReturn(Object)}\n  * <p>\n  * {@link Mockito#doThrow(Throwable)}\n  * <p>\n+ * {@link Mockito#doThrow(Class)}\n+ * <p>\n  * {@link Mockito#doAnswer(Answer)}\n  * <p>\n  * {@link Mockito#doNothing()}\n  * <p>\n- * {@link Mockito#doReturn(Object)}\n- * \n- * <h3 id=\"13\"> 13. Spying on real objects</h3>\n- * \n- * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n+ * {@link Mockito#doCallRealMethod()}\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"13\">13. <a class=\"meaningful_link\" href=\"#spy\">Spying on real objects</a></h3>\n+ * \n+ * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called\n+ * (unless a method was stubbed).\n  * <p>\n  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n  * \n  *   //optionally, you can stub out some methods:\n  *   when(spy.size()).thenReturn(100);\n  * \n- *   //using the spy calls <b>real</b> methods\n+ *   //using the spy calls <b>*real*</b> methods\n  *   spy.add(\"one\");\n  *   spy.add(\"two\");\n  * \n  * <h4>Important gotcha on spying real objects!</h4>\n  * <ol>\n  * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n- * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of methods for stubbing. Example:\n+ * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of\n+ * methods for stubbing. Example:\n  *\n  * <pre class=\"code\"><code class=\"java\">\n  *   List list = new LinkedList();\n  * </li>\n  * </ol>\n  *\n- * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n- * \n+ *\n+ *\n+ *\n+ * <h3 id=\"14\">14. Changing <a class=\"meaningful_link\" href=\"#defaultreturn\">default return values of unstubbed invocations</a> (Since 1.7)</h3>\n+ *\n  * You can create a mock with specified strategy for its return values.\n  * It's quite advanced feature and typically you don't need it to write decent tests.\n  * However, it can be helpful for working with <b>legacy systems</b>.\n  * \n  * <p>\n  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n- * \n- * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"15\">15. <a class=\"meaningful_link\" href=\"#captors\">Capturing arguments</a> for further assertions (Since 1.8.0)</h3>\n  * \n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * For example:\n  * <pre class=\"code\"><code class=\"java\">\n  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n- *   verify(mock).doSomething(argument.c<code>apture()</code>);\n- *   assertEquals(\"John\", argument.g<code>etValue()</code>.g<code>etName()</code>);\n+ *   verify(mock).doSomething(argument.capture());\n+ *   assertEquals(\"John\", argument.getValue().getName());\n  * </code></pre>\n  * \n  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n  * <li>you just need it to assert on argument values to complete verification</li>\n  * </ul>\n  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n- * \n- * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"16\">16. <a class=\"meaningful_link\" href=\"#partial_mocks\">Real partial mocks</a> (Since 1.8.0)</h3>\n  *  \n  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n  * However, there are rare cases when partial mocks come handy: \n  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n- *  \n- * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"17\">17. <a class=\"meaningful_link\" href=\"#resetting_mocks\">Resetting mocks</a> (Since 1.8.0)</h3>\n  *  \n  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n  * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n  *   reset(mock);\n  *   //at this point the mock forgot any interactions & stubbing\n  * </code></pre>\n- *  \n- * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n- * \n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"18\">18. <a class=\"meaningful_link\" href=\"#framework_validation\">Troubleshooting & validating framework usage</a> (Since 1.8.0)</h3>\n+ *\n  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n  * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n  * <p>\n  * <p>\n  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n- * \n- * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"19\">19. <a class=\"meaningful_link\" href=\"#bdd_mockito\">Aliases for behavior driven development</a> (Since 1.8.0)</h3>\n  * \n  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n  * This is exactly how we write our tests and we warmly encourage you to do so!\n  *   assertThat(goods, containBread());\n  * }  \n  * </code></pre>\n- * \n- * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n- * \n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"20\">20. <a class=\"meaningful_link\" href=\"#serializable_mocks\">Serializable mocks</a> (Since 1.8.1)</h3>\n+ *\n  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n  * <p>\n  * WARNING: This should be rarely used in unit testing. \n  *                 .defaultAnswer(CALLS_REAL_METHODS)\n  *                 .serializable());\n  * </code></pre>\n- * \n- * <h3 id=\"21\">21. (**New**) New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </h3>\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"21\">21. New annotations: <a class=\"meaningful_link\" href=\"#captor_annotation\"><code>&#064;Captor</code></a>,\n+ * <a class=\"meaningful_link\" href=\"#spy_annotation\"><code>&#064;Spy</code></a>,\n+ * <a class=\"meaningful_link\" href=\"#injectmocks_annotation\"><code>&#064;InjectMocks</code></a> (Since 1.8.3)</h3>\n+ *\n  * <p>\n  * Release 1.8.3 brings new annotations that may be helpful on occasion:\n  * \n  * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.\n  * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner}.\n  * <p>\n- * <h3 id=\"22\">22. (**New**) Verification with timeout (Since 1.8.5)  </h3>\n- * <p>\n- * Allows verifying with timeout. May be useful for testing in concurrent conditions.\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"22\">22. <a class=\"meaningful_link\" href=\"#verification_timeout\">Verification with timeout</a> (Since 1.8.5)</h3>\n+ * <p>\n+ * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n+ * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent\n+ * conditions.\n  * <p>\n  * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system.\n  * <p>\n  *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n  *   verify(mock, timeout(100).times(2)).someMethod();\n  *\n- *   //passes when someMethod() is called <b>*at lest*</b> 2 times within given time span\n+ *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n  *   verify(mock, timeout(100).atLeast(2)).someMethod();\n  *   \n  *   //verifies someMethod() within given time span using given verification mode\n  *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n  * </code></pre>\n  *\n- * <h3 id=\"23\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9)</h3>\n+ *\n+ *\n+ *\n+ * <h3 id=\"23\">23. (New) <a class=\"meaningful_link\" href=\"#automatic_instantiation\">Automatic instantiation of <code>&#064;Spies</code>,\n+ * <code>&#064;InjectMocks</code></a> and <a class=\"meaningful_link\" href=\"#constructor_injection\">constructor injection goodness</a> (Since 1.9.0)</h3>\n+ *\n  * <p>\n  * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields\n  * using <b>constructor</b> injection, <b>setter</b> injection, or <b>field</b> injection.\n  * &#064;InjectMocks LocalPub;\n  * </code></pre>\n  *\n- * <h3 id=\"24\">24. (**New**) One-liner stubs (Since 1.9)</h3>\n+ *\n+ *\n+ *\n+ * <h3 id=\"24\">24. (New) <a class=\"meaningful_link\" href=\"#one_liner_stub\">One-liner stubs</a> (Since 1.9.0)</h3>\n  * <p>\n  * Mockito will now allow you to create mocks when stubbing.\n  * Basically, it allows to create a stub in one line of code.\n  *   &#064;Test public void should... {}\n  * </code></pre>\n  *\n- * <h3 id=\"25\">25. Verification ignoring stubs (Since 1.9)</h3>\n+ *\n+ *\n+ *\n+ * <h3 id=\"25\">25. (New) <a class=\"meaningful_link\" href=\"#ignore_stubs_verification\">Verification ignoring stubs</a> (Since 1.9.0)</h3>\n  * <p>\n  * Mockito will now allow to ignore stubbing for the sake of verification.\n  * Sometimes useful when coupled with <code>verifyNoMoreInteractions()</code> or verification <code>inOrder()</code>.\n  * </code></pre>\n  * <p>\n  * Advanced examples and more details can be found in javadoc for {@link Mockito#ignoreStubs(Object...)}\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"26\">26. (**New**) <a class=\"meaningful_link\" href=\"#mocking_details\">Mocking details</a> (Since 1.9.5)</h3>\n+ * <p>\n+ * To identify whether a particular object is a mock or a spy, you can write\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     MockingDetails.of( someObject ).isMock();\n+ *     MockingDetails.of( someObject ).isSpy();\n+ * </code></pre>\n+ * Both the {@link MockingDetails#isMock} and {@link MockingDetails#isSpy()} methods return <code>boolean</code>.\n+ * As a spy is considered a special kind of mock, <code>isMock()</code> returns true if the object is a spy.\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"27\">27. (**New**) <a class=\"meaningful_link\" href=\"#delegating_call_to_real_instance\">Delegate calls to real instance</a> (Since 1.9.5)</h3>\n+ * <p>Now mockito offer a specific way to delegate calls to a concrete instance. This is different than the\n+ * spy because the regular spy contains all the state of the spied instance. TODO SF - add more information.\n+ *\n+ * <p>Note that this feature only makes sense only for spies or partial mocks of objects <strong>that are difficult to\n+ * mock or spy</strong> using the usual spy API.\n+ * Possible use cases:\n+ * <ul>\n+ *     <li>Final classes but with an interface</li>\n+ *     <li>Already custom proxied object</li>\n+ *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n+ *     <li>...</li>\n+ * </ul>\n+ *\n+ * Possible example with an object interacting with native objects and spy that would not work:\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   InteractingWithNativeStuff theSpy = spy(interactingWithNativeStuff);\n+ *\n+ *   // Some time after the GC collect interactingWithNativeStuff as it not anymore used,\n+ *   // the finalizer is executed, for example to call a C++ destructor.\n+ *\n+ *   // Later on, it's finally the spy to be garbage collected, finalize method is called again,\n+ *   // unfortunately the second interaction with the native objects will crash the JVM.\n+ * </code></pre>\n+ * Now with the forwarding feature in place :\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   InteractingWithNativeStuff native = mock(InteractingWithNativeStuff.class, AdditionalAnswers.delegateTo(interactingWithNativeStuff));\n+ *\n+ *   //TODO SF - I don't quite follow this example... spied instance is also something we hold in the MockSettings...\n+ *   // OK, the mock keeps a reference to the interactingWithNativeStuff, so the finalize method never kicks in.\n+ * </code></pre>\n+ *\n+ * <p>Friendly reminder that final Methods cannot be mocked, so if <code>finalize</code> is <code>final</code> the\n+ * real code will still be executed.\n+ *\n+ * <p>\n+ * See more information there {@link AdditionalAnswers#delegatesTo(Object)}.\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"28\">28. (**New**) <a class=\"meaningful_link\" href=\"#mock_maker_plugin\">Introduction of the internal <code>MockMaker</code> API</a> (Since 1.9.5)</h3>\n+ * <p>Thanks to Google Android guys, we now have a brand new extension that allows anyone to write his own mock maker engine.\n+ *\n+ * <p>How does that work ?\n+ * <ul>\n+ *     <li>For a Mockito user : Just put the alternate MockMaker plugin, say mockito-dex-maker.jar</li>\n+ *     <li>For a Mockito developer :\n+ *         <ol style=\"list-style-type: lower-alpha\">\n+ *             <li>Write the implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *             <li>Place a file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n+ *             <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n+ *             the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *         </ol>\n+ *     </li>\n+ * </ul>\n+ *\n+ * <p>Note that if several <code>mockito-extensions/org.mockito.plugins.MockMaker</code> files exists in the classpath\n+ * Mockito will only use the first returned by the standard {@link ClassLoader#getResource} mechanism.\n+ *\n+ * Take a look at the API : {@link org.mockito.plugins.MockMaker}\n+ *\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n      *   // note that we're chaining method calls: getBar().getName()\n      *   assertEquals(\"deep\", mock.getBar().getName());\n      * </code></pre>\n-     * \n-     * <strong>Verification API does not support 'chaining'</strong> so deep stub doesn't change how you do verification.\n+     * </p>\n+     *\n      * <p>\n      * <strong>WARNING: </strong>\n      * This feature should rarely be required for regular clean code! Leave it for legacy code.\n      * Mocking a mock to return a mock, to return a mock, (...), to return something meaningful\n      * hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).\n-     * <p>\n-     * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>. \n+     * </p>\n+     *\n+     * <p>\n+     * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>.\n+     * </p>\n+     *\n+     * <p>\n+     * Please note that this answer will return existing mocks that matches the stub. This\n+     * behavior is ok with deep stubs and allows verification to work on the last mock of the chain.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   when(mock.getBar(anyString()).getThingy().getName()).thenReturn(\"deep\");\n+     *\n+     *   mock.getBar(\"candy bar\").getThingy().getName();\n+     *\n+     *   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());\n+     *   verify(mock.getBar(\"candy bar\").getThingy()).getName();\n+     *   verify(mock.getBar(anyString()).getThingy()).getName();\n+     * </code></pre>\n+     * </p>\n+     *\n+     * <p>\n+     * Verification only works with the last mock in the chain. You can use verification modes.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+     *   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(\"deep\");\n+     *   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(\"deep\");\n+     *\n+     *   person.getAddress(\"the docks\").getStreet().getName();\n+     *   person.getAddress(\"the docks\").getStreet().getLongName();\n+     *   person.getAddress(\"the docks\").getStreet(Locale.ITALIAN).getName();\n+     *   person.getAddress(\"the docks\").getStreet(Locale.CHINESE).getName();\n+     *\n+     *   // note that we are actually referring to the very last mock in the stubbing chain.\n+     *   InOrder inOrder = inOrder(\n+     *       person.getAddress(\"the docks\").getStreet(),\n+     *       person.getAddress(\"the docks\").getStreet(Locale.CHINESE),\n+     *       person.getAddress(\"the docks\").getStreet(Locale.ITALIAN)\n+     *   );\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet(), times(1)).getName();\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet()).getLongName();\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.ITALIAN), atLeast(1)).getName();\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.CHINESE)).getName();\n+     * </code></pre>\n+     * </p>\n+     *\n      * <p>\n      * How deep stub work internally?\n      * <pre class=\"code\"><code class=\"java\">\n      *   when(foo.getBar()).thenReturn(bar);\n      *   when(bar.getName()).thenReturn(\"deep\");\n      * </code></pre>\n+     * </p>\n+     *\n      * <p>\n      * This feature will not work when any return type of methods included in the chain cannot be mocked\n-     * (for example: is a primitive or a final class). This is because of java type system.   \n+     * (for example: is a primitive or a final class). This is because of java type system.\n+     * </p>\n      */\n     public static final Answer<Object> RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS.get();\n \n     }\n     \n     /**\n-     * @deprecated\n-     * <b>Please use mock(Foo.class, defaultAnswer);</b>\n+     * <b>Deprecated : Please use mock(Foo.class, defaultAnswer);</b>\n      * <p>\n      * See {@link Mockito#mock(Class, Answer)}\n      * <p>\n      * @param returnValues default return values for unstubbed methods\n      *\n      * @return mock object\n+     *\n+     * @deprecated <b>Please use mock(Foo.class, defaultAnswer);</b>\n      */\n     @Deprecated\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n      * <h4>Important gotcha on spying real objects!</h4>\n      * <ol>\n      * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n-     * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of methods for stubbing. Example:\n+     * Therefore for spies it is recommended to always use <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>\n+     * family of methods for stubbing. Example:\n      *\n      * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * @param methodCall method to be stubbed\n+     * @return OngoingStubbing object used to stub fluently.\n+     *         <strong>Do not</strong> create a reference to this returned object.\n      */\n     public static <T> OngoingStubbing<T> when(T methodCall) {\n         return MOCKITO_CORE.when(methodCall);\n      *   //at this point the mock forgot any interactions & stubbing\n      * </code></pre>\n      *\n-     * @param <T>\n+     * @param <T> The Type of the mocks\n      * @param mocks to be reset\n      */\n     public static <T> void reset(T ... mocks) {\n      *\n      * @param toBeThrown to be thrown when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n+     * @since 1.9.0\n      */\n     public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {\n         return MOCKITO_CORE.doAnswer(new ThrowsExceptionClass(toBeThrown));\n      * See examples in javadoc for {@link Mockito} class\n      *\n      * @return stubber - to select a method for stubbing\n+     * @since 1.9.5\n      */\n     public static Stubber doCallRealMethod() {\n         return MOCKITO_CORE.doAnswer(new CallsRealMethods());\n      *  inOrder.verifyNoMoreInteractions();\n      * </code></pre>\n      *\n-     * @since 1.9\n+     * @since 1.9.0\n      * @param mocks input mocks that will be changed\n      * @return the same mocks that were passed in as parameters\n      */\n         return VerificationModeFactory.atMost(maxNumberOfInvocations);\n     }\n \n+    /**\n+     * Allows non-greedy verification in order.  For example\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   inOrder.verify( mock, calls( 2 )).someMethod( \"some arg\" );\n+     * </code></pre>\n+     * <ul>\n+     * <li>will not fail if the method is called 3 times, unlike times( 2 )</li>\n+     * <li>will not mark the third invocation as verified, unlike atLeast( 2 )</li>\n+     * </ul>\n+     * This verification mode can only be used with in order verification.\n+     * @param wantedNumberOfInvocations number of invocations to verify\n+     * @return  verification mode\n+     */\n+    public static VerificationMode calls( int wantedNumberOfInvocations ){\n+        return VerificationModeFactory.calls( wantedNumberOfInvocations );\n+    }\n+    \n     /**\n      * Allows checking if given method was the only one invoked. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n     }    \n     \n     /**\n-     * Allows verifying with timeout. May be useful for testing in concurrent conditions.\n+     * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n+     * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent\n+     * conditions.\n      * <p>\n      * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n      * <p>\n      *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n      *   verify(mock, timeout(100).times(2)).someMethod();\n      *\n-     *   //passes when someMethod() is called <b>*at lest*</b> 2 times within given time span\n+     *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n      *   verify(mock, timeout(100).atLeast(2)).someMethod();\n      *   \n      *   //verifies someMethod() within given time span using given verification mode\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n package org.mockito;\n \n import java.lang.annotation.*;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n \n /**\n  * Allows shorthand wrapping of field instances in an spy object.\n  * Bar spyOnFoo = Mockito.spy(new Bar());\n  * </code></pre>\n  *\n- * <b>The field annotated with &#064;Spy can be initialized by Mockito if a zero argument constructor\n+ * <p>\n+ * <strong>The field annotated with &#064;Spy can be initialized by Mockito if a zero argument constructor\n  * can be found in the type (even private). <u>But Mockito cannot instantiate inner classes, local classes,\n- * abstract classes and interfaces.</u></b>\n+ * abstract classes and interfaces.</u></strong>\n  *\n- * <b>The field annotated with &#064;Spy can be initiatialized explicitly at declaration point.\n- * Alternatively, if you don't provide the instance Mockito will try to find zero argument constructor (even private) and create an instance for you.\n- * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></b>\n+ * <strong>The field annotated with &#064;Spy can be initialized explicitly at declaration point.\n+ * Alternatively, if you don't provide the instance Mockito will try to find zero argument constructor (even private)\n+ * and create an instance for you.\n+ * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></strong>\n  *\n  * For example this class can be instantiated by Mockito :\n  * <pre class=\"code\"><code class=\"java\">public class Bar {\n  *    public Bar(String publicConstructorWithOneArg) {}\n  * }</code></pre>\n  * </p>\n- * \n+ *\n+ * <h4>Important gotcha on spying real objects!</h4>\n+ * <ol>\n+ * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n+ * Therefore for spies it is recommended to always use <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>\n+ * family of methods for stubbing. Example:\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   List list = new LinkedList();\n+ *   List spy = spy(list);\n+ *\n+ *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+ *   when(spy.get(0)).thenReturn(\"foo\");\n+ *\n+ *   //You have to use doReturn() for stubbing\n+ *   doReturn(\"foo\").when(spy).get(0);\n+ * </code></pre>\n+ * </li>\n+ *\n+ * <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n+ * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction\n+ * and their effect on real instance state.\n+ * The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,\n+ * you won't see any effects on the real instance.</li>\n+ *\n+ * <li>Watch out for final methods.\n+ * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n+ * Also you won't be able to verify those method as well.\n+ * </li>\n+ * </ol>\n+ *\n  * <p>\n- * <b>Warning</b> if you call <code>MockitoAnnotations.initMocks(this)</code> in a\n- * super class <b>constructor</b> then this will not work. It is because fields\n+ * <strong>One last warning :</strong> if you call <code>MockitoAnnotations.initMocks(this)</code> in a\n+ * super class <strong>constructor</strong> then this will not work. It is because fields\n  * in subclass are only instantiated after super class constructor has returned.\n  * It's better to use &#64;Before.\n+ * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in\n+ * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n+ *\n+ * @see Mockito#spy(Object)\n+ * @see Mock\n+ * @see InjectMocks\n+ * @see MockitoAnnotations#initMocks(Object)\n+ * @see org.mockito.runners.MockitoJUnitRunner\n+ * @since 1.8.3\n  */\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.FIELD)\n+@Retention(RUNTIME)\n+@Target(FIELD)\n @Documented\n-public @interface Spy {\n-}\n+public @interface Spy { }\n--- a/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n     public boolean cleansStackTrace() {\n         return true;\n     }\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.configuration.IMockitoConfiguration#enableClassCache()\n+     */\n+    public boolean enableClassCache() {\n+        return true;\n+    }\n+    \n+    \n }\n--- a/src/org/mockito/configuration/IMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/IMockitoConfiguration.java\n      * @return if Mockito should clean stack traces\n      */\n     boolean cleansStackTrace();\n+    \n+    /**\n+     * Allow objenesis to cache classes. If you're in an environment where classes \n+     * are dynamically reloaded, you can disable this to avoid classcast exceptions.\n+     */\n+    boolean enableClassCache();\n }\n--- a/src/org/mockito/exceptions/Discrepancy.java\n+++ b/src/org/mockito/exceptions/Discrepancy.java\n  */\n package org.mockito.exceptions;\n \n-public class Discrepancy {\n-\n-    private final int wantedCount;\n-    private final int actualCount;\n-\n+@Deprecated\n+/**\n+ * @Deprecated. This class has been moved to internal packages because it was never meant to be public.\n+ * If you need it for extending Mockito please let us know. You can still use {@link org.mockito.internal.reporting.Discrepancy}.\n+ * However, the package clearly states that the class in a part of a public API so it can change.\n+ */\n+public class Discrepancy extends org.mockito.internal.reporting.Discrepancy {\n     public Discrepancy(int wantedCount, int actualCount) {\n-        this.wantedCount = wantedCount;\n-        this.actualCount = actualCount;\n-    }\n-\n-    public int getWantedCount() {\n-        return wantedCount;\n-    }\n-    \n-    public String getPluralizedWantedCount() {\n-        return Pluralizer.pluralize(wantedCount);\n-    }\n-\n-    public int getActualCount() {\n-        return actualCount;\n-    }\n-\n-    public String getPluralizedActualCount() {\n-        return Pluralizer.pluralize(actualCount);\n+        super(wantedCount, actualCount);\n     }\n }\n--- a/src/org/mockito/exceptions/Pluralizer.java\n+++ b/src/org/mockito/exceptions/Pluralizer.java\n  */\n package org.mockito.exceptions;\n \n-public class Pluralizer {\n-\n-    public static String pluralize(int number) {\n-        return number == 1 ? \"1 time\" : number + \" times\";\n-    }\n-}\n+@Deprecated\n+/**\n+ * @Deprecated. This class has been moved to internal packages because it was never meant to be public.\n+ * If you need it for extending Mockito please let us know. You can still use {@link org.mockito.internal.reporting.Pluralizer}.\n+ * However, the package clearly states that the class in a part of a public API so it can change.\n+ */\n+public class Pluralizer extends org.mockito.internal.reporting.Pluralizer {}\n--- a/src/org/mockito/exceptions/PrintableInvocation.java\n+++ b/src/org/mockito/exceptions/PrintableInvocation.java\n \n package org.mockito.exceptions;\n \n-import org.mockito.internal.debugging.Location;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Location;\n \n+@Deprecated\n+/**\n+ * @Deprecated. We needed to move this class to a better place to keep consistency of the API.\n+ * Please use {@link DescribedInvocation} instead.\n+ */\n public interface PrintableInvocation {\n-    \n+\n     String toString();\n-    \n+\n     Location getLocation();\n-    \n+\n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.misusing.*;\n-import org.mockito.exceptions.verification.*;\n-import org.mockito.exceptions.verification.junit.JUnitTool;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.exceptions.misusing.FriendlyReminderException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.exceptions.misusing.NullInsteadOfMockException;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.SmartNullPointerException;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.junit.JUnitTool;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.invocation.Location;\n import org.mockito.listeners.InvocationListener;\n \n import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n \n-import static org.mockito.exceptions.Pluralizer.pluralize;\n+import static org.mockito.internal.reporting.Pluralizer.pluralize;\n import static org.mockito.internal.util.StringJoiner.join;\n \n /**\n     public void incorrectUseOfApi() {\n         throw new MockitoException(join(\n                 \"Incorrect use of API detected here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"\",\n                 \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                 \"Examples of correct usage:\",\n                 \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                 \"   Those methods *cannot* be stubbed/verified.\",\n                 \"2. inside when() you don't call method on mock but on some other object.\",\n+                \"3. the parent of the mocked class is not public.\",\n+                \"   It is a limitation of the mock engine.\",\n                 \"\"\n         ));\n     }\n                 ));\n     }\n \n-    public void invalidUseOfMatchers(int expectedMatchersCount, int recordedMatchersCount) {\n+    public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Invalid use of argument matchers!\",\n-                expectedMatchersCount + \" matchers expected, \" + recordedMatchersCount + \" recorded.\",\n+                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n+                locationsOf(recordedMatchers),\n+                \"\",\n                 \"This exception may occur if matchers are combined with raw values:\",\n                 \"    //incorrect:\",\n                 \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                 \"    //correct:\",\n                 \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                 \"\",\n-                \"For more info see javadoc for Matchers class.\"\n-        ));\n+                \"For more info see javadoc for Matchers class.\",\n+                \"\"\n+        ));\n+    }\n+\n+    public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {\n+        throw new InvalidUseOfMatchersException(join(\n+                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n+                new LocationImpl(),\n+                \"\",\n+                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n+                locationsOf(matcherStack),\n+                \"\",\n+                \"This exception may occur if matchers are combined with raw values:\",\n+                \"    //incorrect:\",\n+                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n+                \"When using matchers, all arguments have to be provided by matchers.\",\n+                \"For example:\",\n+                \"    //correct:\",\n+                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n+                \"\",\n+                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n+                \"\"\n+        ));\n+    }\n+\n+    public void reportNoSubMatchersFound(String additionalMatcherName) {\n+        throw new InvalidUseOfMatchersException(join(\n+                \"No matchers found for additional matcher \" + additionalMatcherName,\n+                new LocationImpl(),\n+                \"\"\n+        ));\n+    }\n+\n+\n+    private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n+        List<String> description = new ArrayList<String>();\n+        for (LocalizedMatcher matcher : matchers)\n+\t\t\tdescription.add(matcher.getLocation().toString());\n+        return join(description.toArray());\n     }\n \n     public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n         String message = join(\"Argument(s) are different! Wanted:\",\n                 wanted,\n-                new Location(),\n+                new LocationImpl(),\n                 \"Actual invocation has different arguments:\",\n                 actual,\n                 actualLocation,\n         }\n     }\n \n-    public void wantedButNotInvoked(PrintableInvocation wanted) {\n+    public void wantedButNotInvoked(DescribedInvocation wanted) {\n         throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n     }\n \n-    public void wantedButNotInvoked(PrintableInvocation wanted, List<? extends PrintableInvocation> invocations) {\n+    public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {\n         String allInvocations;\n         if (invocations.isEmpty()) {\n             allInvocations = \"Actually, there were zero interactions with this mock.\\n\";\n         } else {\n             StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n-            for (PrintableInvocation i : invocations) {\n+            for (DescribedInvocation i : invocations) {\n                  sb.append(i.getLocation());\n                  sb.append(\"\\n\");\n             }\n         throw new WantedButNotInvoked(message + allInvocations);\n     }\n \n-    private String createWantedButNotInvokedMessage(PrintableInvocation wanted) {\n+    private String createWantedButNotInvokedMessage(DescribedInvocation wanted) {\n         return join(\n                 \"Wanted but not invoked:\",\n                 wanted.toString(),\n-                new Location(),\n+                new LocationImpl(),\n                 \"\"\n         );\n     }\n \n-    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n+    public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n         throw new VerificationInOrderFailure(join(\n                     \"Verification in order failure\",\n                     \"Wanted but not invoked:\",\n                     wanted.toString(),\n-                    new Location(),\n+                    new LocationImpl(),\n                     \"Wanted anywhere AFTER following interaction:\",\n                     previous.toString(),\n                     previous.getLocation(),\n         ));\n     }\n \n-    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n+    public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new TooManyActualInvocations(message);\n     }\n \n-    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, PrintableInvocation wanted,\n+    private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n             Location firstUndesired) {\n         return join(\n                 wanted.toString(),\n-                \"Wanted \" + Pluralizer.pluralize(wantedCount) + \":\",\n-                new Location(),\n+                \"Wanted \" + pluralize(wantedCount) + \":\",\n+                new LocationImpl(),\n                 \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                 firstUndesired,\n                 \"\"\n         );\n     }\n \n-    public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n+    public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {\n         throw new NeverWantedButInvoked(join(\n                 wanted.toString(),\n                 \"Never wanted here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But invoked here:\",\n                 firstUndesired,\n                 \"\"\n         ));\n     }\n \n-    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n+    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n                 ));\n     }\n \n-    private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n+    private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n             Location lastActualInvocation) {\n         String ending =\n             (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n             String message = join(\n                     wanted.toString(),\n                     \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n-                    new Location(),\n+                    new LocationImpl(),\n                     \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                     ending\n             );\n             return message;\n     }\n \n-    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+    public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n \n         throw new TooLittleActualInvocations(message);\n     }\n \n-    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+    public void tooLittleActualInvocationsInOrder(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n \n         throw new VerificationInOrderFailure(join(\n \n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But found this interaction:\",\n                 undesired.getLocation(),\n                 scenario\n     public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But found this interaction:\",\n                 undesired.getLocation(),\n                 \"\"\n                 actualType + \" cannot be returned by \" + methodName + \"()\",\n                 methodName + \"() should return \" + expectedType,\n                 \"***\",\n-                \"This exception *might* occur in wrongly written multi-threaded tests.\",\n-                \"Please refer to Mockito FAQ on limitations of concurrency testing.\",\n+                \"If you're unsure why you're getting above error read on.\",\n+                \"Due to the nature of the syntax above problem might occur because:\",\n+                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n+                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n+                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n+                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                 \"\"\n                 ));\n     }\n         throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n     }\n \n-    public void misplacedArgumentMatcher(Location location) {\n+    public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Misplaced argument matcher detected here:\",\n-                location,\n+                locationsOf(lastMatchers),\n                 \"\",\n                 \"You cannot use argument matchers outside of verification or stubbing.\",\n                 \"Examples of correct usage of argument matchers:\",\n     public void smartNullPointerException(String invocation, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"because this method call was *not* stubbed correctly:\",\n                 location,\n                 invocation,\n                 \"\"\n         ), details);\n     }\n+\n+\tpublic void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n+\t\tthrow new MockitoException(join(\n+                \"Mocked type must be the same as the type of your delegated instance.\",\n+                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n+                \"  //correct delegate:\",\n+                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n+                \"  //incorrect - types don't match:\",\n+                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n+        ));\n+\t}\n+\n+\tpublic void spyAndDelegateAreMutuallyExclusive() {\n+\t\tthrow new MockitoException(join(\n+\t\t\t\t\"Settings should not define a spy instance and a delegated instance at the same time.\"\n+\t\t\t\t)) ;\n+\t}\n+\n+    public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n+        throw new MockitoException(join(\"Invalid argument index.\",\n+                                        \"The index need to be a positive number that indicates the position of the argument to return.\",\n+                                        \"However it is possible to use the -1 value to indicates that the last argument should be\",\n+                                        \"returned.\"));\n+    }\n+\n+    public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n+        throw new MockitoException(\n+                join(\"Invalid argument index for the current invocation of method : \",\n+                     \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n+                     \"\",\n+                     (willReturnLastParameter ?\n+                             \"Last parameter wanted\" :\n+                             \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n+                     \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n+                     \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n+                     \"\"));\n+    }\n+\n+    private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n+        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n+        if (parameterTypes.length == 0) {\n+            return new StringBuilder(\"the method has no arguments.\\n\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");\n+        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {\n+            stringBuilder.append(\"    [\").append(i);\n+\n+            if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1) {\n+                stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");\n+            } else {\n+                stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n+            }\n+        }\n+        return stringBuilder;\n+    }\n+\n+    public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {\n+        throw new WrongTypeOfReturnValue(join(\n+                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n+                \"method should return the type '\" + expectedType + \"'\",\n+                \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n+                \"\",\n+                \"The reason for this error can be :\",\n+                \"1. The wanted argument position is incorrect.\",\n+                \"2. The answer is used on the wrong interaction.\",\n+                \"\",\n+                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n+                \"***\",\n+                \"However if you're still unsure why you're getting above error read on.\",\n+                \"Due to the nature of the syntax above problem might occur because:\",\n+                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n+                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n+                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n+                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n+                \"\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/exceptions/verification/junit/JUnitTool.java\n+++ b/src/org/mockito/exceptions/verification/junit/JUnitTool.java\n  */\n package org.mockito.exceptions.verification.junit;\n \n-import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n-\n+@Deprecated\n+/**\n+ * @Deprecated. This class has been moved to internal packages because it was never meant to be public.\n+ * If you need it for extending Mockito please let us know. You can still use {@link org.mockito.internal.junit.JUnitTool}.\n+ * However, the package clearly states that the class in a part of a public API so it can change.\n+ */\n public class JUnitTool {\n-\n-    private static boolean hasJUnit;\n-\n-    static {\n-        try {\n-            Class.forName(\"junit.framework.ComparisonFailure\");\n-            hasJUnit = true;\n-        } catch (Throwable t) {\n-            hasJUnit = false;\n-        }\n-    }\n     \n     public static boolean hasJUnit() {\n-        return hasJUnit;\n+        return org.mockito.internal.junit.JUnitTool.hasJUnit();\n     }\n \n     public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {\n-        try {\n-            Class<?> clazz = Class.forName(\"org.mockito.exceptions.verification.junit.ArgumentsAreDifferent\");\n-            AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);\n-            return throwable;\n-        } catch (Throwable t) {\n-//            throw the default exception in case of problems\n-            return new ArgumentsAreDifferent(message);\n-        }\n+        return org.mockito.internal.junit.JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n     }\n }\n--- a/src/org/mockito/internal/InOrderImpl.java\n+++ b/src/org/mockito/internal/InOrderImpl.java\n import org.mockito.InOrder;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.InOrderWrapper;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n /**\n         return inOrderContext.isVerified(i);\n     }\n \n-    public void markVerified(Invocation i) {        \n+    public void markVerified(Invocation i) {\n         inOrderContext.markVerified(i);\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/InternalMockHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+\n+@SuppressWarnings(\"unchecked\")\n+public interface InternalMockHandler<T> extends MockHandler {\n+\n+    MockCreationSettings getMockSettings();\n+\n+    VoidMethodStubbable<T> voidMethodStubbable(T mock);\n+    \n+    void setAnswersForStubbing(List<Answer> answers);\n+\n+    InvocationContainer getInvocationContainer();\n+\n+}\n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n package org.mockito.internal;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.invocation.Invocation;\n import org.mockito.listeners.InvocationListener;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n  * Handler, that call all listeners wanted for this mock, before delegating it\n  * to the parameterized handler.\n  *\n- * Also imposterize MockHandler, delegate all call of MockHandlerInterface to the real mockHandler\n+ * Also imposterize MockHandlerImpl, delegate all call of InternalMockHandler to the real mockHandler\n  */\n-public class InvocationNotifierHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T>  {\n+public class InvocationNotifierHandler<T> implements MockHandler, InternalMockHandler<T> {\n \n     private List<InvocationListener> invocationListeners;\n-    private MockHandler<T> mockHandler;\n+    private MockHandlerImpl<T> mockHandler;\n \n-    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsImpl settings) {\n+    public InvocationNotifierHandler(MockHandlerImpl<T> mockHandler, MockCreationSettings settings) {\n         this.mockHandler = mockHandler;\n         this.invocationListeners = settings.getInvocationListeners();\n     }\n         }\n \t}\n \n-    public MockSettingsImpl getMockSettings() {\n+    public MockCreationSettings getMockSettings() {\n         return mockHandler.getMockSettings();\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/MockHandlerImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.verification.MockAwareVerificationMode;\n+import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n+ */\n+public class MockHandlerImpl<T> implements InternalMockHandler<T> {\n+\n+    private static final long serialVersionUID = -2917871070982574165L;\n+\n+    InvocationContainerImpl invocationContainerImpl;\n+    MatchersBinder matchersBinder = new MatchersBinder();\n+    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+\n+    private final MockCreationSettings mockSettings;\n+\n+    public MockHandlerImpl(MockCreationSettings mockSettings) {\n+        this.mockSettings = mockSettings;\n+        this.mockingProgress = new ThreadSafeMockingProgress();\n+        this.matchersBinder = new MatchersBinder();\n+        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n+            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+            return null;\n+        }\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n+\n+        mockingProgress.validateState();\n+\n+        // if verificationMode is not null then someone is doing verify()\n+        if (verificationMode != null) {\n+            // We need to check if verification was started on the correct mock\n+            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+            // TODO: can I avoid this cast here?\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+                verificationMode.verify(data);\n+                return null;\n+            } else {\n+                // this means there is an invocation on a different mock. Re-adding verification mode\n+                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+                mockingProgress.verificationStarted(verificationMode);\n+            }\n+        }\n+\n+        // prepare invocation for stubbing\n+        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+        // look for existing answer for this invocation\n+        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+        if (stubbedInvocation != null) {\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n+        } else {\n+            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n+        }\n+\t}\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n+    }\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        invocationContainerImpl.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return invocationContainerImpl;\n+    }\n+}\n+\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.progress.IOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.*;\n import org.mockito.verification.VerificationMode;\n \n     private final MockUtil mockUtil = new MockUtil();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n-        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n-        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n+    public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n+        if (!MockSettingsImpl.class.isInstance(settings)) {\n+            throw new IllegalArgumentException(\n+                    \"Unexpected implementation of '\" + settings.getClass().getCanonicalName() + \"'\\n\"\n+                    + \"At the moment, you cannot provide your own implementations that class.\");\n+        }\n+        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);\n+        MockCreationSettings<T> creationSettings = impl.confirm(typeToMock);\n+        T mock = mockUtil.createMock(creationSettings);\n+        mockingProgress.mockingStarted(mock, typeToMock);\n         return mock;\n     }\n     \n     }\n     \n     public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-        MockHandlerInterface<T> handler = mockUtil.getMockHandler(mock);\n+        InternalMockHandler<T> handler = mockUtil.getMockHandler(mock);\n         mockingProgress.stubbingStarted();\n         return handler.voidMethodStubbable(mock);\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/CaptorAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.GenericMaster;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Instantiate {@link ArgumentCaptor} a field annotated by &#64;Captor.\n+ */\n+public class CaptorAnnotationProcessor implements FieldAnnotationProcessor<Captor> {\n+    public Object process(Captor annotation, Field field) {\n+        Class<?> type = field.getType();\n+        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n+            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: '\"\n+               + field.getName() + \"' has wrong type\\n\"\n+               + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n+        }\n+        Class cls = new GenericMaster().getGenericType(field);\n+        return ArgumentCaptor.forClass(cls);\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n package org.mockito.internal.configuration;\n \n import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+import org.mockito.internal.creation.CglibMockMaker;\n+import org.mockito.plugins.MockMaker;\n \n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+\n+/**\n+ * Loads configuration or extension points available in the classpath.\n+ *\n+ * <p>\n+ * <ul>\n+ *     <li>\n+ *         Can load the mockito configuration. The user who want to provide his own mockito configuration\n+ *         should write the class <code>org.mockito.configuration.MockitoConfiguration</code> that implements\n+ *         {@link IMockitoConfiguration}. For example :\n+ *         <pre class=\"code\"><code class=\"java\">\n+ * package org.mockito.configuration;\n+ *\n+ * //...\n+ *\n+ * public class MockitoConfiguration implements IMockitoConfiguration {\n+ *     boolean enableClassCache() { return false; }\n+ *\n+ *     // ...\n+ * }\n+ *     </code></pre>\n+ *     </li>\n+ *     <li>\n+ *         Can load available mockito extensions. Currently Mockito only have one extension point the\n+ *         {@link MockMaker}. This extension point allows a user to provide his own bytecode engine to build mocks.\n+ *         <br>Suppose you wrote an extension to create mocks with some <em>Awesome</em> library, in order to tell\n+ *         Mockito to use it you need to put in your classpath\n+ *         <ol style=\"list-style-type: lower-alpha\">\n+ *             <li>The implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *             <li>A file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n+ *             <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n+ *             the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *         </ol>\n+ *     </li>\n+ * </ul>\n+ * </p>\n+ */\n public class ClassPathLoader {\n-    \n+    private static final MockMaker mockMaker = findPlatformMockMaker();\n+    public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n+\n     /**\n      * @return configuration loaded from classpath or null\n      */\n     @SuppressWarnings({\"unchecked\"})\n     public IMockitoConfiguration loadConfiguration() {\n         //Trying to get config from classpath\n-        Class configClass = null;\n+        Class configClass;\n         try {\n-            configClass = (Class) Class.forName(\"org.mockito.configuration.MockitoConfiguration\");\n+            configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n         } catch (ClassNotFoundException e) {\n-            //that's ok, it means there is no global config, using default one. \n+            //that's ok, it means there is no global config, using default one.\n             return null;\n         }\n-        \n+\n         try {\n             return (IMockitoConfiguration) configClass.newInstance();\n         } catch (ClassCastException e) {\n-            throw new MockitoConfigurationException(\"\\n\" +\n-                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n+            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n         } catch (Exception e) {\n-            throw new MockitoConfigurationException(\"\\n\" +\n-                    \"Unable to instantiate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n+            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation of the mock maker available for the current runtime.\n+     *\n+     * <p>Returns {@link CglibMockMaker} if no {@link MockMaker} extension exists\n+     * or is visible in the current classpath.</p>\n+     */\n+    public static MockMaker getMockMaker() {\n+        return mockMaker;\n+    }\n+\n+    /**\n+     * Scans the classpath to find a mock maker plugin if one is available,\n+     * allowing mockito to run on alternative platforms like Android.\n+     */\n+    static MockMaker findPlatformMockMaker() {\n+        for (MockMaker mockMaker : loadImplementations(MockMaker.class)) {\n+            return mockMaker; // return the first one service loader finds (if any)\n+        }\n+        return new CglibMockMaker(); // default implementation\n+    }\n+\n+    /**\n+     * Equivalent to {@link java.util.ServiceLoader#load} but without requiring\n+     * Java 6 / Android 2.3 (Gingerbread).\n+     */\n+    static <T> List<T> loadImplementations(Class<T> service) {\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        if (loader == null) {\n+            loader = ClassLoader.getSystemClassLoader();\n+        }\n+\n+        Enumeration<URL> resources;\n+        try {\n+            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n+        } catch (IOException e) {\n+            throw new MockitoException(\"Failed to load \" + service, e);\n+        }\n+\n+        List<T> result = new ArrayList<T>();\n+        for (URL resource : Collections.list(resources)) {\n+            InputStream in = null;\n+            try {\n+                in = resource.openStream();\n+                for (String line : readerToLines(new InputStreamReader(in, \"UTF-8\"))) {\n+                    String name = stripCommentAndWhitespace(line);\n+                    if (name.length() != 0) {\n+                        result.add(service.cast(loader.loadClass(name).newInstance()));\n+                    }\n+                }\n+            } catch (Exception e) {\n+                throw new MockitoConfigurationException(\n+                        \"Failed to load \" + service + \" using \" + resource, e);\n+            } finally {\n+                closeQuietly(in);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    static List<String> readerToLines(Reader reader) throws IOException {\n+        List<String> result = new ArrayList<String>();\n+        BufferedReader lineReader = new BufferedReader(reader);\n+        String line;\n+        while ((line = lineReader.readLine()) != null) {\n+            result.add(line);\n+        }\n+        return result;\n+    }\n+\n+    static String stripCommentAndWhitespace(String line) {\n+        int hash = line.indexOf('#');\n+        if (hash != -1) {\n+            line = line.substring(0, hash);\n+        }\n+        return line.trim();\n+    }\n+\n+    private static void closeQuietly(InputStream in) {\n+        if (in != null) {\n+            try {\n+                in.close();\n+            } catch (IOException ignored) {\n+            }\n         }\n     }\n }\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.*;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.reflection.FieldSetter;\n-import org.mockito.internal.util.reflection.GenericMaster;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n  * <p>\n  * The {@link #process(Class, Object)} method implementation <strong>does not</strong> process super classes!\n  *\n- * @see {@link MockitoAnnotations}\n+ * @see MockitoAnnotations\n  */\n @SuppressWarnings(\"unchecked\")\n public class DefaultAnnotationEngine implements AnnotationEngine {\n+    private final Map<Class<? extends Annotation>, FieldAnnotationProcessor<?>> annotationProcessorMap = new HashMap<Class<? extends Annotation>, FieldAnnotationProcessor<?>>();\n+\n+    public DefaultAnnotationEngine() {\n+        registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());\n+        registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());\n+        registerAnnotationProcessor(Captor.class, new CaptorAnnotationProcessor());\n+    }\n \n     /* (non-Javadoc)\n     * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n     */\n     @SuppressWarnings(\"deprecation\")\n     public Object createMockFor(Annotation annotation, Field field) {\n-        if (annotation instanceof Mock) {\n-            return processAnnotationOn((Mock) annotation, field);\n-        }\n-        if (annotation instanceof MockitoAnnotations.Mock) {\n-            return processAnnotationOn((MockitoAnnotations.Mock) annotation, field);\n-        }\n-        if (annotation instanceof Captor) {\n-            return processAnnotationOn((Captor) annotation, field);\n-        }        \n-\n-        return null;\n-    }\n-    \n-    private Object processAnnotationOn(Mock annotation, Field field) {\n-        MockSettings mockSettings = Mockito.withSettings();\n-        if (annotation.extraInterfaces().length > 0) { // never null\n-            mockSettings.extraInterfaces(annotation.extraInterfaces());\n-        }\n-        if (\"\".equals(annotation.name())) {\n-            mockSettings.name(field.getName());\n-        } else {\n-            mockSettings.name(annotation.name());\n-        }\n-\n-        // see @Mock answer default value\n-        mockSettings.defaultAnswer(annotation.answer().get());\n-        return Mockito.mock(field.getType(), mockSettings);\n+        return forAnnotation(annotation).process(annotation, field);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    private Object processAnnotationOn(org.mockito.MockitoAnnotations.Mock annotation, Field field) {\n-        return Mockito.mock(field.getType(), field.getName());\n+    private <A extends Annotation> FieldAnnotationProcessor<A> forAnnotation(A annotation) {\n+        if (annotationProcessorMap.containsKey(annotation.annotationType())) {\n+            return (FieldAnnotationProcessor<A>) annotationProcessorMap.get(annotation.annotationType());\n+        }\n+        return new FieldAnnotationProcessor<A>() {\n+            public Object process(A annotation, Field field) {\n+                return null;\n+            }\n+        };\n     }\n-    \n-    private Object processAnnotationOn(Captor annotation, Field field) {\n-        Class<?> type = field.getType();\n-        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n-            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: '\"\n-                    + field.getName() + \"' has wrong type\\n\"\n-                    + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n-        }\n-        Class cls = new GenericMaster().getGenericType(field);        \n-        return ArgumentCaptor.forClass(cls);    \n-    }           \n+\n+    private <A extends Annotation> void registerAnnotationProcessor(Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {\n+        annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);\n+    }\n \n     public void process(Class<?> clazz, Object testInstance) {\n         Field[] fields = clazz.getDeclaredFields();\n             new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n         }\n     }\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/FieldAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Simple annotation processor interface.\n+ */\n+public interface FieldAnnotationProcessor<A extends Annotation> {\n+    Object process(A annotation, Field field);\n+}\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n     public boolean cleansStackTrace() {\n         return globalConfiguration.get().cleansStackTrace();\n     }\n+    \n+    public boolean enableClassCache() {\n+        return globalConfiguration.get().enableClassCache();\n+    }\n \n     public Answer<Object> getDefaultAnswer() {\n         return globalConfiguration.get().getDefaultAnswer();\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n \n import org.mockito.*;\n import org.mockito.configuration.AnnotationEngine;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.configuration.injection.scanner.InjectMocksScanner;\n+import org.mockito.internal.configuration.injection.scanner.MockScanner;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n import java.util.HashSet;\n import java.util.Set;\n \n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n+\n /**\n  * See {@link MockitoAnnotations}\n  */\n @SuppressWarnings({\"deprecation\", \"unchecked\"})\n public class InjectingAnnotationEngine implements AnnotationEngine {\n-    \n-    AnnotationEngine delegate = new DefaultAnnotationEngine();\n-    AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n+    private AnnotationEngine delegate = new DefaultAnnotationEngine();\n+    private AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n \n     /***\n      * Create a mock using {@link DefaultAnnotationEngine}\n         }\n     }\n \n-    void assertNoAnnotations(final Field field, final Class ... annotations) {\n-        for (Class annotation : annotations) {\n-            if (field.isAnnotationPresent(annotation)) {\n-                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n-            }\n-        }        \n-    }\n \n     /**\n      * Initializes mock/spies dependencies for objects annotated with\n-     * &#064;InjectMocks for given testClass.\n+     * &#064;InjectMocks for given testClassInstance.\n      * <p>\n      * See examples in javadoc for {@link MockitoAnnotations} class.\n      * \n-     * @param testClass\n+     * @param testClassInstance\n      *            Test class, usually <code>this</code>\n      */\n-    public void injectMocks(final Object testClass) {\n-        Class<?> clazz = testClass.getClass();\n+    public void injectMocks(final Object testClassInstance) {\n+        Class<?> clazz = testClassInstance.getClass();\n         Set<Field> mockDependentFields = new HashSet<Field>();\n-        Set<Object> mocks = new HashSet<Object>();\n+        Set<Object> mocks = newMockSafeHashSet();\n         \n         while (clazz != Object.class) {\n-            mockDependentFields.addAll(scanForInjection(testClass, clazz));\n-            mocks.addAll(scanMocks(testClass, clazz));\n+            new InjectMocksScanner(clazz).addTo(mockDependentFields);\n+            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);\n             clazz = clazz.getSuperclass();\n         }\n         \n-        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClass);\n+        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n     }\n \n-    /**\n-     * Scan fields annotated by &#064;InjectMocks\n-     *\n-     * @param testClass\n-     * @param clazz\n-     * @return\n-     */\n-    private Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n-        Set<Field> mockDependentFields = new HashSet<Field>();\n-        Field[] fields = clazz.getDeclaredFields();\n-        for (Field field : fields) {\n-            if (null != field.getAnnotation(InjectMocks.class)) {\n-                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n-                mockDependentFields.add(field);\n-            }\n-        }\n-\n-        return mockDependentFields;\n-    }\n-\n-    private Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n-        Set<Object> mocks = new HashSet<Object>();\n-        for (Field field : clazz.getDeclaredFields()) {\n-            // mock or spies only\n-            if (null != field.getAnnotation(Spy.class) || null != field.getAnnotation(org.mockito.Mock.class)\n-                    || null != field.getAnnotation(org.mockito.MockitoAnnotations.Mock.class)) {\n-                Object fieldInstance = null;\n-                boolean wasAccessible = field.isAccessible();\n-                field.setAccessible(true);\n-                try {\n-                    fieldInstance = field.get(testClass);\n-                } catch (IllegalAccessException e) {\n-                    throw new MockitoException(\"Problems reading this field dependency \" + field.getName() + \" for injection\", e);\n-                } finally {\n-                    field.setAccessible(wasAccessible);\n-                }\n-                if (fieldInstance != null) {\n-                    mocks.add(fieldInstance);\n-                }\n-            }\n-        }\n-        return mocks;\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Instantiates a mock on a field annotated by {@link Mock}\n+ */\n+public class MockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {\n+    public Object process(Mock annotation, Field field) {\n+        MockSettings mockSettings = Mockito.withSettings();\n+        if (annotation.extraInterfaces().length > 0) { // never null\n+            mockSettings.extraInterfaces(annotation.extraInterfaces());\n+        }\n+        if (\"\".equals(annotation.name())) {\n+            mockSettings.name(field.getName());\n+        } else {\n+            mockSettings.name(annotation.name());\n+        }\n+\n+        // see @Mock answer default value\n+        mockSettings.defaultAnswer(annotation.answer().get());\n+        return Mockito.mock(field.getType(), mockSettings);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/MockitoAnnotationsMockAnnotationProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations.Mock;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Instantiates a mock on a field annotated by {@link Mock}\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public class MockitoAnnotationsMockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {\n+\n+    public Object process(Mock annotation, Field field) {\n+        return Mockito.mock(field.getType(), field.getName());\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n             SimpleArgumentResolver simpleArgumentResolver = new SimpleArgumentResolver(mockCandidates);\n             FieldInitializationReport report = new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();\n \n-            return report.fieldWasInitialized();\n+            return report.fieldWasInitializedUsingContructorArgs();\n         } catch (MockitoException e) {\n             if(e.getCause() instanceof InvocationTargetException) {\n                 Throwable realCause = e.getCause().getCause();\n                 new Reporter().fieldInitialisationThrewException(field, realCause);\n             }\n+            // other causes should be fine\n             return false;\n         }\n \n--- a/src/org/mockito/internal/configuration/injection/MockInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n \n import static org.mockito.internal.util.Checks.checkItemsNotNull;\n import static org.mockito.internal.util.Checks.checkNotNull;\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Internal injection configuration utility.\n      */\n     public static class OngoingMockInjection {\n         private Set<Field> fields = new HashSet<Field>();\n-        private Set<Object> mocks = new HashSet<Object>();\n+        private Set<Object> mocks = newMockSafeHashSet();\n         private Object fieldOwner;\n         private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n         private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.injection.filter.*;\n-import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n import java.util.*;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Inject mocks using first setters then fields, if no setters available.\n         Class<?> fieldClass = report.fieldClass();\n         Object fieldInstanceNeedingInjection = report.fieldInstance();\n         while (fieldClass != Object.class) {\n-            injectionOccurred |= injectMockCandidate(fieldClass, new HashSet<Object>(mockCandidates), fieldInstanceNeedingInjection);\n+            injectionOccurred |= injectMockCandidate(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n             fieldClass = fieldClass.getSuperclass();\n         }\n         return injectionOccurred;\n     }\n+\n \n \n     private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration.injection.scanner;\n+\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.Reporter;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Scan field for injection.\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public class InjectMocksScanner {\n+    private final Class<?> clazz;\n+\n+    /**\n+     * Create a new InjectMocksScanner for the given clazz on the given instance\n+     *\n+     * @param clazz    Current class in the hierarchy of the test\n+     */\n+    public InjectMocksScanner(Class<?> clazz) {\n+        this.clazz = clazz;\n+    }\n+\n+\n+    /**\n+     * Add the fields annotated by @{@link InjectMocks}\n+     *\n+     * @param mockDependentFields Set of fields annotated by  @{@link InjectMocks}\n+     */\n+    public void addTo(Set<Field> mockDependentFields) {\n+        mockDependentFields.addAll(scan());\n+    }\n+\n+    /**\n+     * Scan fields annotated by &#064;InjectMocks\n+     *\n+     * @return Fields that depends on Mock\n+     */\n+    private Set<Field> scan() {\n+        Set<Field> mockDependentFields = new HashSet<Field>();\n+        Field[] fields = clazz.getDeclaredFields();\n+        for (Field field : fields) {\n+            if (null != field.getAnnotation(InjectMocks.class)) {\n+                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n+                mockDependentFields.add(field);\n+            }\n+        }\n+\n+        return mockDependentFields;\n+    }\n+\n+    void assertNoAnnotations(final Field field, final Class... annotations) {\n+        for (Class annotation : annotations) {\n+            if (field.isAnnotationPresent(annotation)) {\n+                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration.injection.scanner;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldReader;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n+\n+/**\n+ * Scan mocks, and prepare them if needed.\n+ */\n+public class MockScanner {\n+    private MockUtil mockUtil = new MockUtil();\n+    private final Object instance;\n+    private final Class<?> clazz;\n+\n+    /**\n+     * Creates a MockScanner.\n+     *\n+     * @param instance The test instance\n+     * @param clazz    The class in the type hierarchy of this instance.\n+     */\n+    public MockScanner(Object instance, Class<?> clazz) {\n+        this.instance = instance;\n+        this.clazz = clazz;\n+    }\n+\n+    /**\n+     * Add the scanned and prepared mock instance to the given collection.\n+     *\n+     * <p>\n+     * The preparation of mocks consists only in defining a MockName if not already set.\n+     * </p>\n+     *\n+     * @param mocks Set of mocks\n+     */\n+    public void addPreparedMocks(Set<Object> mocks) {\n+        mocks.addAll(scan());\n+    }\n+\n+    /**\n+     * Scan and prepare mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.\n+     *\n+     * @return A prepared set of mock\n+     */\n+    private Set<Object> scan() {\n+        Set<Object> mocks = newMockSafeHashSet();\n+        for (Field field : clazz.getDeclaredFields()) {\n+            // mock or spies only\n+            FieldReader fieldReader = new FieldReader(instance, field);\n+\n+            Object mockInstance = preparedMock(fieldReader.read(), field);\n+            if (mockInstance != null) {\n+                mocks.add(mockInstance);\n+            }\n+        }\n+        return mocks;\n+    }\n+\n+    private Object preparedMock(Object instance, Field field) {\n+        if (isAnnotatedByMockOrSpy(field)) {\n+            return instance;\n+        } else if (isMockOrSpy(instance)) {\n+            mockUtil.maybeRedefineMockName(instance, field.getName());\n+            return instance;\n+        }\n+        return null;\n+    }\n+\n+    private boolean isAnnotatedByMockOrSpy(Field field) {\n+        return null != field.getAnnotation(Spy.class)\n+                || null != field.getAnnotation(Mock.class)\n+                || null != field.getAnnotation(MockitoAnnotations.Mock.class);\n+    }\n+\n+    private boolean isMockOrSpy(Object instance) {\n+        return mockUtil.isMock(instance)\n+                || mockUtil.isSpy(instance);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+\n+/**\n+ * A MockMaker that uses cglib to generate mocks on a JVM.\n+ */\n+public final class CglibMockMaker implements MockMaker {\n+\n+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n+        InternalMockHandler mockitoHandler = cast(handler);\n+        return ClassImposterizer.INSTANCE.imposterise(\n+                new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n+    }\n+\n+    private InternalMockHandler cast(MockHandler handler) {\n+        if (!(handler instanceof InternalMockHandler)) {\n+            throw new MockitoException(\"At the moment you cannot provide own implementations of MockHandler.\" +\n+                    \"\\nPlease see the javadocs for the MockMaker interface.\");\n+        }\n+        return (InternalMockHandler) handler;\n+    }\n+\n+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n+        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));\n+    }\n+\n+    public MockHandler getHandler(Object mock) {\n+        if (!(mock instanceof Factory)) {\n+            return null;\n+        }\n+        Factory factory = (Factory) mock;\n+        Callback callback = factory.getCallback(0);\n+        if (!(callback instanceof MethodInterceptorFilter)) {\n+            return null;\n+        }\n+        return ((MethodInterceptorFilter) callback).getHandler();\n+    }\n+}\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n \n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.MockitoInvocationHandler;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n import org.mockito.internal.invocation.*;\n import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.mock.MockCreationSettings;\n \n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private static final long serialVersionUID = 6182795666612683784L;\n-    private final MockitoInvocationHandler handler;\n+    private final InternalMockHandler handler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n-    private final MockSettingsImpl mockSettings;\n+    private final MockCreationSettings mockSettings;\n \n-    public MethodInterceptorFilter(MockitoInvocationHandler handler, MockSettingsImpl mockSettings) {\n+    public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {\n         this.handler = handler;\n         this.mockSettings = mockSettings;\n     }\n         MockitoMethod mockitoMethod = createMockitoMethod(method);\n         \n         FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n-        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n+        Invocation invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n         return handler.handle(invocation);\n     }\n    \n-    public MockitoInvocationHandler getHandler() {\n+    public MockHandler getHandler() {\n         return handler;\n     }\n \n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n-import org.mockito.internal.util.MockName;\n+import org.mockito.internal.util.MockCreationValidator;\n+import org.mockito.internal.util.MockNameImpl;\n+import org.mockito.internal.util.MockitoSpy;\n import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n import org.mockito.stubbing.Answer;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import java.io.Serializable;\n+import java.util.*;\n+\n+import static org.mockito.internal.util.collections.Sets.newSet;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockSettingsImpl implements MockSettings {\n+public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSettings, MockCreationSettings<T> {\n \n     private static final long serialVersionUID = 4475297236197939568L;\n-    private Class<?>[] extraInterfaces;\n-    private String name;\n-    private Object spiedInstance;\n-    private Answer<Object> defaultAnswer;\n-    private MockName mockName;\n-    private boolean serializable;\n-    private List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public MockSettings serializable() {\n         this.serializable = true;\n         return this;\n     }\n \n-    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n+    public MockSettings extraInterfaces(Class... extraInterfaces) {\n         if (extraInterfaces == null || extraInterfaces.length == 0) {\n             new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n         }\n-            \n-        for (Class<?> i : extraInterfaces) {\n+\n+        for (Class i : extraInterfaces) {\n             if (i == null) {\n                 new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n             } else if (!i.isInterface()) {\n                 new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n             }\n         }\n-        this.extraInterfaces = extraInterfaces;\n+        this.extraInterfaces = newSet(extraInterfaces);\n         return this;\n     }\n \n         return mockName;\n     }\n \n-    public Class<?>[] getExtraInterfaces() {\n+    public Set<Class> getExtraInterfaces() {\n         return extraInterfaces;\n     }\n \n \n     public boolean isSerializable() {\n         return serializable;\n-    }\n-    \n-    public void initiateMockName(Class classToMock) {\n-        mockName = new MockName(name, classToMock);\n     }\n \n \tpublic MockSettings verboseLogging() {\n         return this.invocationListeners;\n     }\n \n-    public boolean containsInvocationListener(InvocationListener invocationListener) {\n-        return invocationListeners.contains(invocationListener);\n-    }\n-\n     public boolean hasInvocationListeners() {\n         return !invocationListeners.isEmpty();\n     }\n+\n+    public Class<T> getTypeToMock() {\n+        return typeToMock;\n+    }\n+\n+    public MockCreationSettings<T> confirm(Class<T> typeToMock) {\n+        return validatedSettings(typeToMock, this);\n+    }\n+\n+    private static <T> CreationSettings<T> validatedSettings(Class<T> typeToMock, CreationSettings<T> source) {\n+        MockCreationValidator validator = new MockCreationValidator();\n+\n+        validator.validateType(typeToMock);\n+        validator.validateExtraInterfaces(typeToMock, source.getExtraInterfaces());\n+        validator.validateMockedType(typeToMock, source.getSpiedInstance());\n+\n+        //TODO SF - add this validation and also add missing coverage\n+//        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n+\n+        CreationSettings<T> settings = new CreationSettings<T>(source);\n+        settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n+        settings.setTypeToMock(typeToMock);\n+        settings.setExtraInterfaces(prepareExtraInterfaces(source));\n+        return settings;\n+    }\n+\n+    private static Set<Class> prepareExtraInterfaces(CreationSettings settings) {\n+        Set<Class> interfaces = new HashSet<Class>(settings.getExtraInterfaces());\n+        if(settings.isSerializable()) {\n+            interfaces.add(Serializable.class);\n+        }\n+        if (settings.getSpiedInstance() != null) {\n+            interfaces.add(MockitoSpy.class);\n+        }\n+        return interfaces;\n+    }\n }\n \n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n  */\n package org.mockito.internal.creation.jmock;\n \n-import java.lang.reflect.*;\n+import org.mockito.cglib.core.CodeGenerationException;\n+import org.mockito.cglib.core.NamingPolicy;\n+import org.mockito.cglib.core.Predicate;\n+import org.mockito.cglib.proxy.*;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.configuration.GlobalConfiguration;\n+import org.mockito.internal.creation.cglib.MockitoNamingPolicy;\n+import org.objenesis.ObjenesisStd;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n import java.util.List;\n \n-import org.mockito.cglib.core.*;\n-import org.mockito.cglib.proxy.*;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.creation.cglib.MockitoNamingPolicy;\n-import org.objenesis.ObjenesisStd;\n+import static org.mockito.internal.util.StringJoiner.join;\n \n /**\n  * Thanks to jMock guys for this handy class that wraps all the cglib magic. \n     //TODO: after 1.8, in order to provide decent exception message when objenesis is not found,\n     //have a constructor in this class that tries to instantiate ObjenesisStd and if it fails then show decent exception that dependency is missing\n     //TODO: after 1.8, for the same reason catch and give better feedback when hamcrest core is not found.\n-    private ObjenesisStd objenesis = new ObjenesisStd();\n+    private ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());\n     \n     private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {\n         @Override\n     public boolean canImposterise(Class<?> type) {\n         return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n     }\n+\n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n+        return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n+    }\n     \n     public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n         try {\n             setConstructorsAccessible(mockedType, true);\n             Class<?> proxyClass = createProxyClass(mockedType, ancillaryTypes);\n             return mockedType.cast(createProxy(proxyClass, interceptor));\n+        } catch (ClassCastException cce) {\n+            throw new MockitoException(join(\n+                \"ClassCastException occurred when creating the proxy.\",\n+                \"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)\"\n+            ), cce);\n         } finally {\n             setConstructorsAccessible(mockedType, false);\n         }\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.settings;\n+\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * by Szczepan Faber, created at: 4/9/12\n+ */\n+public class CreationSettings<T> implements MockCreationSettings<T>, Serializable {\n+\n+    protected Class<T> typeToMock;\n+    protected Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n+    protected String name;\n+    protected Object spiedInstance;\n+    protected Answer<Object> defaultAnswer;\n+    protected MockName mockName;\n+    protected boolean serializable;\n+    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n+\n+    public CreationSettings() {}\n+\n+    public CreationSettings(CreationSettings copy) {\n+        this.typeToMock = copy.typeToMock;\n+        this.extraInterfaces = copy.extraInterfaces;\n+        this.name = copy.name;\n+        this.spiedInstance = copy.spiedInstance;\n+        this.defaultAnswer = copy.defaultAnswer;\n+        this.mockName = copy.mockName;\n+        this.serializable = copy.serializable;\n+        this.invocationListeners = copy.invocationListeners;\n+    }\n+\n+    public Class<T> getTypeToMock() {\n+        return typeToMock;\n+    }\n+\n+    public CreationSettings<T> setTypeToMock(Class<T> typeToMock) {\n+        this.typeToMock = typeToMock;\n+        return this;\n+    }\n+\n+    public Set<Class> getExtraInterfaces() {\n+        return extraInterfaces;\n+    }\n+\n+    public CreationSettings<T> setExtraInterfaces(Set<Class> extraInterfaces) {\n+        this.extraInterfaces = extraInterfaces;\n+        return this;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Object getSpiedInstance() {\n+        return spiedInstance;\n+    }\n+\n+    public Answer<Object> getDefaultAnswer() {\n+        return defaultAnswer;\n+    }\n+\n+    public MockName getMockName() {\n+        return mockName;\n+    }\n+\n+    public CreationSettings<T> setMockName(MockName mockName) {\n+        this.mockName = mockName;\n+        return this;\n+    }\n+\n+    public boolean isSerializable() {\n+        return serializable;\n+    }\n+\n+    public List<InvocationListener> getInvocationListeners() {\n+        return invocationListeners;\n+    }\n+}\n--- a/src/org/mockito/internal/debugging/FindingsListener.java\n+++ b/src/org/mockito/internal/debugging/FindingsListener.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public interface FindingsListener {\n     void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed);\n--- a/src/org/mockito/internal/debugging/Localized.java\n+++ b/src/org/mockito/internal/debugging/Localized.java\n  */\n package org.mockito.internal.debugging;\n \n+\n+import org.mockito.invocation.Location;\n \n public class Localized<T> {\n \n \n     public Localized(T object) {\n         this.object = object;\n-        location = new Location();\n+        location = new LocationImpl();\n     }\n \n     public T getObject() {\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/LocationImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.debugging;\n+\n+import java.io.Serializable;\n+\n+import org.mockito.internal.exceptions.base.StackTraceFilter;\n+import org.mockito.invocation.Location;\n+\n+public class LocationImpl implements Location, Serializable {\n+\n+    private static final long serialVersionUID = -9054861157390980624L;\n+    private final Throwable stackTraceHolder;\n+    private final StackTraceFilter stackTraceFilter;\n+\n+    public LocationImpl() {\n+        this(new StackTraceFilter());\n+    }\n+\n+    public LocationImpl(StackTraceFilter stackTraceFilter) {\n+        this.stackTraceFilter = stackTraceFilter;\n+        stackTraceHolder = new Throwable();\n+    }\n+\t\n+    @Override\n+    public String toString() {\n+        StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);\n+        if (filtered.length == 0) {\n+            return \"-> at <<unknown line>>\";\n+        }\n+        return \"-> at \" + filtered[0].toString();\n+    }\n+}\n--- a/src/org/mockito/internal/debugging/LoggingListener.java\n+++ b/src/org/mockito/internal/debugging/LoggingListener.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.invocation.Invocation;\n \n import static org.mockito.internal.util.StringJoiner.join;\n \n--- a/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+++ b/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n package org.mockito.internal.debugging;\n \n import org.mockito.MockitoDebugger;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.UnusedStubsFinder;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n             out += line(i.toString());\n             out += line(\" invoked: \" + i.getLocation());\n             if (i.stubInfo() != null) {\n-                out += line(\" stubbed: \" + i.stubInfo().stubbedAt());\n+                out += line(\" stubbed: \" + i.stubInfo().stubbedAt().toString());\n             }\n         }\n \n--- a/src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java\n+++ b/src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java\n \n package org.mockito.internal.debugging;\n \n-import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.DescribedInvocation;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.listeners.MethodInvocationReport;\n \n \t\tprintStream.println(\"############ Logging method invocation #\" + mockInvocationsCounter + \" on mock/spy ########\");\n \t}\n \n-    private void printInvocation(PrintableInvocation invocation) {\n+    private void printInvocation(DescribedInvocation invocation) {\n \t\tprintStream.println(invocation.toString());\n //\t\tprintStream.println(\"Handling method call on a mock/spy.\");\n \t\tprintlnIndented(\"invoked: \" + invocation.getLocation().toString());\n--- a/src/org/mockito/internal/debugging/WarningsCollector.java\n+++ b/src/org/mockito/internal/debugging/WarningsCollector.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.UnusedStubsFinder;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n import org.mockito.internal.listeners.CollectCreatedMocks;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.invocation.Invocation;\n \n import java.util.LinkedList;\n import java.util.List;\n--- a/src/org/mockito/internal/debugging/WarningsFinder.java\n+++ b/src/org/mockito/internal/debugging/WarningsFinder.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n import java.util.Iterator;\n import java.util.LinkedList;\n--- a/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n import org.mockito.internal.util.SimpleMockitoLogger;\n+import org.mockito.invocation.Invocation;\n \n public class WarningsPrinterImpl {\n \n--- a/src/org/mockito/internal/exceptions/VerificationAwareInvocation.java\n+++ b/src/org/mockito/internal/exceptions/VerificationAwareInvocation.java\n \n package org.mockito.internal.exceptions;\n \n-import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.DescribedInvocation;\n \n-\n-public interface VerificationAwareInvocation extends PrintableInvocation {\n+public interface VerificationAwareInvocation extends DescribedInvocation {\n     \n     boolean isVerified();\n     \n--- a/src/org/mockito/internal/invocation/ArgumentsComparator.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsComparator.java\n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.MatcherDecorator;\n import org.mockito.internal.matchers.VarargMatcher;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/ArgumentsProcessor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import org.hamcrest.Matcher;\n+import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.util.collections.ArrayUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * by Szczepan Faber, created at: 3/31/12\n+ */\n+public class ArgumentsProcessor {\n+    // expands array varArgs that are given by runtime (1, [a, b]) into true\n+    // varArgs (1, a, b);\n+    public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n+        if (!isVarArgs || new ArrayUtils().isEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n+            return args == null ? new Object[0] : args;\n+        }\n+\n+        final int nonVarArgsCount = args.length - 1;\n+        Object[] varArgs;\n+        if (args[nonVarArgsCount] == null) {\n+            // in case someone deliberately passed null varArg array\n+            varArgs = new Object[] { null };\n+        } else {\n+            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n+        }\n+        final int varArgsCount = varArgs.length;\n+        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n+        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n+        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n+        return newArgs;\n+    }\n+\n+    public static List<Matcher> argumentsToMatchers(Object[] arguments) {\n+        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n+        for (Object arg : arguments) {\n+            if (arg != null && arg.getClass().isArray()) {\n+                matchers.add(new ArrayEquals(arg));\n+            } else {\n+                matchers.add(new Equals(arg));\n+            }\n+        }\n+        return matchers;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n+++ b/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n package org.mockito.internal.invocation;\n \n \n+import org.mockito.invocation.Invocation;\n+\n public interface CapturesArgumensFromInvocation {\n     \n     void captureArgumentsFrom(Invocation i);\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.invocation;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.internal.exceptions.VerificationAwareInvocation;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockito.internal.reporting.PrintSettings;\n+import org.mockito.invocation.*;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+/**\n+ * Method call on a mock object.\n+ * <p>\n+ * Contains sequence number which should be globally unique and is used for\n+ * verification in order.\n+ * <p>\n+ * Contains stack trace of invocation\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationImpl implements Invocation, VerificationAwareInvocation {\n+\n+    private static final long serialVersionUID = 8240069639250980199L;\n+    private final int sequenceNumber;\n+    private final Object mock;\n+    private final MockitoMethod method;\n+    private final Object[] arguments;\n+    private final Object[] rawArguments;\n+\n+    private final Location location;\n+    private boolean verified;\n+    private boolean isIgnoredForVerification;\n+\n+    final RealMethod realMethod;\n+    private StubInfo stubInfo;\n+\n+    public InvocationImpl(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n+        this.method = mockitoMethod;\n+        this.mock = mock;\n+        this.realMethod = realMethod;\n+        this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);\n+        this.rawArguments = args;\n+        this.sequenceNumber = sequenceNumber;\n+        this.location = new LocationImpl();\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public Method getMethod() {\n+        return method.getJavaMethod();\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public boolean isVerified() {\n+        return verified || isIgnoredForVerification;\n+    }\n+\n+    public int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !o.getClass().equals(this.getClass())) {\n+            return false;\n+        }\n+\n+        InvocationImpl other = (InvocationImpl) o;\n+\n+        return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);\n+    }\n+\n+    private boolean equalArguments(Object[] arguments) {\n+        return Arrays.equals(arguments, this.arguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 1;\n+    }\n+\n+    public String toString() {\n+        return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);\n+    }\n+\n+    public Location getLocation() {\n+        return location;\n+    }\n+\n+    public Object[] getRawArguments() {\n+        return this.rawArguments;\n+    }\n+\n+    public Object callRealMethod() throws Throwable {\n+        if (this.getMethod().getDeclaringClass().isInterface()) {\n+            new Reporter().cannotCallRealMethodOnInterface();\n+        }\n+        return realMethod.invoke(mock, rawArguments);\n+    }\n+\n+    public void markVerified() {\n+        this.verified = true;\n+    }\n+\n+    public StubInfo stubInfo() {\n+        return stubInfo;\n+    }\n+\n+    public void markStubbed(StubInfo stubInfo) {\n+        this.stubInfo = stubInfo;\n+    }\n+\n+    public boolean isIgnoredForVerification() {\n+        return isIgnoredForVerification;\n+    }\n+\n+    public void ignoreForVerification() {\n+        isIgnoredForVerification = true;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationMarker.java\n import java.util.List;\n \n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class InvocationMarker {\n \n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n import java.util.List;\n \n import org.hamcrest.Matcher;\n-import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.debugging.Location;\n import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.internal.reporting.PrintSettings;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n+public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n \n     private static final long serialVersionUID = -3047126096857467610L;\n     private final Invocation invocation;\n     public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n         this.invocation = invocation;\n         if (matchers.isEmpty()) {\n-            this.matchers = invocation.argumentsToMatchers();\n+            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n         } else {\n             this.matchers = matchers;\n         }\n     }\n     \n     public String toString() {\n-        return invocation.toString(matchers, new PrintSettings());\n+        return new PrintSettings().print(matchers, invocation);\n     }\n \n     public boolean matches(Invocation actual) {\n         return !overloadedButSameArgs;\n     }\n \n-    public boolean hasSameMethod(Invocation candidate) {        \n+    public boolean hasSameMethod(Invocation candidate) {\n         //not using method.equals() for 1 good reason:\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         return invocation.getLocation();\n     }\n \n-    public String toString(PrintSettings printSettings) {\n-        return invocation.toString(matchers, printSettings);\n-    }\n-\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.util.ListUtil;\n-import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class InvocationsFinder {\n \n             }\n         }\n         return firstChunk;\n+    }\n+    \n+    public Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){\n+        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){\n+            if( wanted.matches( invocation )){\n+                return invocation;\n+            }\n+        }\n+        return null;\n     }\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n      * @param context\n      * @param orderedInvocations\n      */\n-    public Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {        \n+    public Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {\n         Invocation candidate = null;\n         for(Invocation i : orderedInvocations) {\n             if (!context.isVerified(i)) {\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n \n package org.mockito.internal.invocation;\n \n+import org.hamcrest.Matcher;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n+import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.invocation.Invocation;\n+\n import java.io.Serializable;\n import java.util.List;\n-\n-import org.hamcrest.Matcher;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.progress.ArgumentMatcherStorage;\n \n @SuppressWarnings(\"unchecked\")\n public class MatchersBinder implements Serializable {\n     private static final long serialVersionUID = -311433939339443463L;\n \n     public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n-        List<Matcher> lastMatchers = argumentMatcherStorage.pullMatchers();\n+        List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n-        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);\n+        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, (List<Matcher>)(List) lastMatchers);\n         return invocationWithMatchers;\n     }\n \n-    private void validateMatchers(Invocation invocation, List<Matcher> matchers) {\n-        if (!matchers.isEmpty()) {\n-            int recordedMatchersSize = matchers.size();\n-            int expectedMatchersSize = invocation.getArgumentsCount();\n+    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {\n+        if (!lastMatchers.isEmpty()) {\n+            int recordedMatchersSize = lastMatchers.size();\n+            int expectedMatchersSize = invocation.getArguments().length;\n             if (expectedMatchersSize != recordedMatchersSize) {\n-                new Reporter().invalidUseOfMatchers(expectedMatchersSize, recordedMatchersSize);\n+                new Reporter().invalidUseOfMatchers(expectedMatchersSize, lastMatchers);\n             }\n         }\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/StubInfoImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Location;\n+import org.mockito.invocation.StubInfo;\n+\n+import java.io.Serializable;\n+\n+public class StubInfoImpl implements StubInfo, Serializable {\n+    private static final long serialVersionUID = 2125827349332068867L;\n+    private DescribedInvocation stubbedAt;\n+\n+    public StubInfoImpl(DescribedInvocation stubbedAt) {\n+        this.stubbedAt = stubbedAt;\n+    }\n+\n+    public Location stubbedAt() {\n+        return stubbedAt.getLocation();\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/UnusedStubsFinder.java\n+++ b/src/org/mockito/internal/invocation/UnusedStubsFinder.java\n \n package org.mockito.internal.invocation;\n \n-import org.mockito.internal.MockHandlerInterface;\n+import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.*;\n \n     public List<Invocation> find(List<?> mocks) {\n         List<Invocation> unused = new LinkedList<Invocation>();\n         for (Object mock : mocks) {\n-            MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(mock);\n+            InternalMockHandler<Object> handler = new MockUtil().getMockHandler(mock);\n             List<StubbedInvocationMatcher> fromSingleMock = handler.getInvocationContainer().getStubbedInvocations();\n             for(StubbedInvocationMatcher s : fromSingleMock) {\n                 if (!s.wasUsed()) {\n--- a/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n \n package org.mockito.internal.invocation.finder;\n \n-import org.mockito.internal.MockHandlerInterface;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.*;\n \n     public List<Invocation> find(List<?> mocks) {\n         Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n         for (Object mock : mocks) {\n-            MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(mock);\n+            InternalMockHandler<Object> handler = new MockUtil().getMockHandler(mock);\n             List<Invocation> fromSingleMock = handler.getInvocationContainer().getInvocations();\n             invocationsInOrder.addAll(fromSingleMock);\n         }\n \n     private final class SequenceNumberComparator implements Comparator<Invocation> {\n         public int compare(Invocation o1, Invocation o2) {\n-            return o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n+            return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());\n         }\n     }\n }\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n \n package org.mockito.internal.invocation.finder;\n \n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n--- /dev/null\n+++ b/src/org/mockito/internal/junit/JUnitTool.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.junit;\n+\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+\n+public class JUnitTool {\n+\n+    private static boolean hasJUnit;\n+\n+    static {\n+        try {\n+            Class.forName(\"junit.framework.ComparisonFailure\");\n+            hasJUnit = true;\n+        } catch (Throwable t) {\n+            hasJUnit = false;\n+        }\n+    }\n+    \n+    public static boolean hasJUnit() {\n+        return hasJUnit;\n+    }\n+\n+    public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {\n+        try {\n+            Class<?> clazz = Class.forName(\"org.mockito.exceptions.verification.junit.ArgumentsAreDifferent\");\n+            AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);\n+            return throwable;\n+        } catch (Throwable t) {\n+//            throw the default exception in case of problems\n+            return new ArgumentsAreDifferent(message);\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n+++ b/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n         this.toBeFilled = toBeFilled;\n     }\n \n-    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n+    public void mockingStarted(Object mock, Class classToMock) {\n         toBeFilled.add(mock);\n     }\n }\n--- a/src/org/mockito/internal/listeners/MockingStartedListener.java\n+++ b/src/org/mockito/internal/listeners/MockingStartedListener.java\n @SuppressWarnings(\"unchecked\")\n public interface MockingStartedListener extends MockingProgressListener {\n     \n-    void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings);\n+    void mockingStarted(Object mock, Class classToMock);\n }\n--- a/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n+++ b/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n  */\n package org.mockito.internal.listeners;\n \n-import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n import org.mockito.listeners.MethodInvocationReport;\n \n /**\n  * Report on a method call\n  */\n public class NotifiedMethodInvocationReport implements MethodInvocationReport {\n-        private final Invocation invocation;\n-        private Object returnedValue;\n-        private Throwable throwable;\n+    private final Invocation invocation;\n+    private Object returnedValue;\n+    private Throwable throwable;\n \n \n-        /**\n-         * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n-         *\n-         *\n-         * @param invocation Information on the method call\n-         * @param returnedValue The value returned by the method invocation\n-         */\n-        public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n-            this.invocation = invocation;\n-            this.returnedValue = returnedValue;\n-        }\n+    /**\n+     * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n+     *\n+     *\n+     * @param invocation Information on the method call\n+     * @param returnedValue The value returned by the method invocation\n+     */\n+    public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n+        this.invocation = invocation;\n+        this.returnedValue = returnedValue;\n+    }\n \n-        /**\n-         * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n-         *\n-         *\n-         * @param invocation Information on the method call\n-         * @param throwable Tha throwable raised by the method invocation\n-         */\n-        public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n-            this.invocation = invocation;\n-            this.throwable = throwable;\n-        }\n+    /**\n+     * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n+     *\n+     *\n+     * @param invocation Information on the method call\n+     * @param throwable Tha throwable raised by the method invocation\n+     */\n+    public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n+        this.invocation = invocation;\n+        this.throwable = throwable;\n+    }\n \n-        public PrintableInvocation getInvocation() {\n-            return invocation;\n-        }\n+    public DescribedInvocation getInvocation() {\n+        return invocation;\n+    }\n \n-        public Object getReturnedValue() {\n-            return returnedValue;\n-        }\n+    public Object getReturnedValue() {\n+        return returnedValue;\n+    }\n \n-        public Throwable getThrowable() {\n-            return throwable;\n-        }\n+    public Throwable getThrowable() {\n+        return throwable;\n+    }\n \n-        public boolean threwException() {\n-            return throwable != null;\n-        }\n+    public boolean threwException() {\n+        return throwable != null;\n+    }\n \n-        public String getLocationOfStubbing() {\n-            return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt();\n-        }\n+    public String getLocationOfStubbing() {\n+        return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt().toString();\n+    }\n \n \n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n \n-            NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;\n+        NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;\n \n-            if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;\n-            if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)\n-                return false;\n-            if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;\n+        if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;\n+        if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)\n+            return false;\n+        if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;\n \n-            return true;\n-        }\n+        return true;\n+    }\n \n-        public int hashCode() {\n-            int result = invocation != null ? invocation.hashCode() : 0;\n-            result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);\n-            result = 31 * result + (throwable != null ? throwable.hashCode() : 0);\n-            return result;\n-        }\n+    public int hashCode() {\n+        int result = invocation != null ? invocation.hashCode() : 0;\n+        result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);\n+        result = 31 * result + (throwable != null ? throwable.hashCode() : 0);\n+        return result;\n     }\n+}\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n import java.io.Serializable;\n \n import org.hamcrest.*;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.invocation.Location;\n \n @SuppressWarnings(\"unchecked\")\n public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator, Serializable {\n \n     public LocalizedMatcher(Matcher actualMatcher) {\n         this.actualMatcher = actualMatcher;\n-        this.location = new Location();\n+        this.location = new LocationImpl();\n     }\n \n     public void _dont_implement_Matcher___instead_extend_BaseMatcher_() {\n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n  */\n package org.mockito.internal.progress;\n \n+import org.hamcrest.Matcher;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n+\n import java.util.List;\n-\n-import org.hamcrest.Matcher;\n \n @SuppressWarnings(\"unchecked\")\n public interface ArgumentMatcherStorage {\n \n     HandyReturnValues reportMatcher(Matcher matcher);\n \n-    List<Matcher> pullMatchers();\n+    List<LocalizedMatcher> pullLocalizedMatchers();\n \n     HandyReturnValues reportAnd();\n \n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n \n package org.mockito.internal.progress;\n \n+import org.hamcrest.Matcher;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.matchers.And;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n+import org.mockito.internal.matchers.Not;\n+import org.mockito.internal.matchers.Or;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Stack;\n \n-import org.hamcrest.Matcher;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.internal.matchers.And;\n-import org.mockito.internal.matchers.LocalizedMatcher;\n-import org.mockito.internal.matchers.Not;\n-import org.mockito.internal.matchers.Or;\n-\n @SuppressWarnings(\"unchecked\")\n public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {\n-    \n+\n+    public static final int TWO_SUB_MATCHERS = 2;\n+    public static final int ONE_SUB_MATCHER = 1;\n     private Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();\n     \n     /* (non-Javadoc)\n     }\n \n     /* (non-Javadoc)\n-     * @see org.mockito.internal.progress.ArgumentMatcherStorage#pullMatchers()\n+     * @see org.mockito.internal.progress.ArgumentMatcherStorage#pullLocalizedMatchers()\n      */\n-    public List<Matcher> pullMatchers() {\n+    public List<LocalizedMatcher> pullLocalizedMatchers() {\n         if (matcherStack.isEmpty()) {\n             return Collections.emptyList();\n         }\n     }\n \n     /* (non-Javadoc)\n-     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportAnd()\n+    * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportAnd()\n+    */\n+    public HandyReturnValues reportAnd() {\n+        assertStateFor(\"And(?)\", TWO_SUB_MATCHERS);\n+        And and = new And(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n+        matcherStack.push(new LocalizedMatcher(and));\n+        return new HandyReturnValues();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportOr()\n      */\n-    public HandyReturnValues reportAnd() {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found for And(?).\");\n-        And and = new And(popLastArgumentMatchers(2));\n-        matcherStack.push(new LocalizedMatcher(and));\n+    public HandyReturnValues reportOr() {\n+        assertStateFor(\"Or(?)\", TWO_SUB_MATCHERS);\n+        Or or = new Or(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n+        matcherStack.push(new LocalizedMatcher(or));\n         return new HandyReturnValues();\n     }\n \n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportNot()\n      */\n     public HandyReturnValues reportNot() {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found for Not(?).\");\n-        Not not = new Not(popLastArgumentMatchers(1).get(0));\n+        assertStateFor(\"Not(?)\", ONE_SUB_MATCHER);\n+        Not not = new Not(popLastArgumentMatchers(ONE_SUB_MATCHER).get(0));\n         matcherStack.push(new LocalizedMatcher(not));\n         return new HandyReturnValues();\n     }\n \n+    private void assertStateFor(String additionalMatcherName, int subMatchersCount) {\n+        assertMatchersFoundFor(additionalMatcherName);\n+        assertIncorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount);\n+    }\n+\n     private List<Matcher> popLastArgumentMatchers(int count) {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n-        assertState(matcherStack.size() >= count,\n-                \"\" + count + \" matchers expected, \" + matcherStack.size() + \" recorded.\");\n         List<Matcher> result = new LinkedList<Matcher>();\n         result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));\n         for (int i = 0; i < count; i++) {\n         return result;\n     }\n \n-    private void assertState(boolean toAssert, String message) {\n-        if (!toAssert) {\n+    private void assertMatchersFoundFor(String additionalMatcherName) {\n+        if (matcherStack.isEmpty()) {\n             matcherStack.clear();\n-            throw new InvalidUseOfMatchersException(message);\n+            new Reporter().reportNoSubMatchersFound(additionalMatcherName);\n         }\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportOr()\n-     */\n-    public HandyReturnValues reportOr() {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n-        Or or = new Or(popLastArgumentMatchers(2));\n-        matcherStack.push(new LocalizedMatcher(or));\n-        return new HandyReturnValues();\n+    private void assertIncorrectUseOfAdditionalMatchers(String additionalMatcherName, int count) {\n+        if(matcherStack.size() < count) {\n+            ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n+            matcherStack.clear();\n+            new Reporter().incorrectUseOfAdditionalMatchers(additionalMatcherName, count, lastMatchers);\n+        }\n     }\n \n     /* (non-Javadoc)\n      */\n     public void validateState() {\n         if (!matcherStack.isEmpty()) {\n-            LocalizedMatcher lastMatcher = matcherStack.lastElement();\n+            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n             matcherStack.clear();\n-            new Reporter().misplacedArgumentMatcher(lastMatcher.getLocation());\n+            new Reporter().misplacedArgumentMatcher(lastMatchers);\n         }\n     }\n \n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n package org.mockito.internal.progress;\n \n import org.mockito.MockSettings;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.listeners.MockingProgressListener;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n \n     ArgumentMatcherStorage getArgumentMatcherStorage();\n     \n-    void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings);\n+    void mockingStarted(Object mock, Class classToMock);\n \n     void setListener(MockingProgressListener listener);\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.Localized;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.internal.listeners.MockingStartedListener;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n \n     public void stubbingStarted() {\n         validateState();\n-        stubbingInProgress = new Location();\n+        stubbingInProgress = new LocationImpl();\n     }\n \n     public void validateState() {\n         return argumentMatcherStorage;\n     }\n \n-    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n+    public void mockingStarted(Object mock, Class classToMock) {\n         if (listener != null && listener instanceof MockingStartedListener) {\n-            ((MockingStartedListener) listener).mockingStarted(mock, classToMock, mockSettings);\n+            ((MockingStartedListener) listener).mockingStarted(mock, classToMock);\n         }\n         validateMostStuff();\n     }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n import java.io.Serializable;\n \n import org.mockito.MockSettings;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.listeners.MockingProgressListener;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n         return threadSafely().getArgumentMatcherStorage();\n     }\n     \n-    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n-        threadSafely().mockingStarted(mock, classToMock, mockSettings);\n+    public void mockingStarted(Object mock, Class classToMock) {\n+        threadSafely().mockingStarted(mock, classToMock);\n     }\n \n     public void setListener(MockingProgressListener listener) {\n--- /dev/null\n+++ b/src/org/mockito/internal/reporting/Discrepancy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.reporting;\n+\n+public class Discrepancy {\n+\n+    private final int wantedCount;\n+    private final int actualCount;\n+\n+    public Discrepancy(int wantedCount, int actualCount) {\n+        this.wantedCount = wantedCount;\n+        this.actualCount = actualCount;\n+    }\n+\n+    public int getWantedCount() {\n+        return wantedCount;\n+    }\n+    \n+    public String getPluralizedWantedCount() {\n+        return Pluralizer.pluralize(wantedCount);\n+    }\n+\n+    public int getActualCount() {\n+        return actualCount;\n+    }\n+\n+    public String getPluralizedActualCount() {\n+        return Pluralizer.pluralize(actualCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/reporting/Pluralizer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.reporting;\n+\n+public class Pluralizer {\n+\n+    public static String pluralize(int number) {\n+        return number == 1 ? \"1 time\" : number + \" times\";\n+    }\n+}\n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.reporting;\n+\n+import org.hamcrest.Matcher;\n+import org.mockito.internal.invocation.ArgumentsProcessor;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.matchers.MatchersPrinter;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.Arrays;\n import java.util.LinkedList;\n \n public class PrintSettings {\n \n+    public static final int MAX_LINE_LENGTH = 45;\n     private boolean multiline;\n     private List<Integer> withTypeInfo = new LinkedList<Integer>();\n \n     public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {\n         this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n     }\n+\n+    public String print(List<Matcher> matchers, Invocation invocation) {\n+        MatchersPrinter matchersPrinter = new MatchersPrinter();\n+        String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName();\n+        String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);\n+        if (isMultiline() || (!matchers.isEmpty() && invocationString.length() > MAX_LINE_LENGTH)) {\n+            return qualifiedName + matchersPrinter.getArgumentsBlock(matchers, this);\n+        } else {\n+            return invocationString;\n+        }\n+    }\n+\n+    public String print(Invocation invocation) {\n+        return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);\n+    }\n+\n+    public String print(InvocationMatcher invocationMatcher) {\n+        return print(invocationMatcher.getMatchers(), invocationMatcher.getInvocation());\n+    }\n }\n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n  */\n package org.mockito.internal.reporting;\n \n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n /**\n  * Makes sure both wanted and actual are printed consistently (single line or multiline)\n     private final String wanted;\n     private final String actual;\n \n-    public SmartPrinter(PrintingFriendlyInvocation wanted, PrintingFriendlyInvocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n+    public SmartPrinter(InvocationMatcher wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n         PrintSettings printSettings = new PrintSettings();\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n         printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n         \n-        this.wanted = wanted.toString(printSettings);\n-        this.actual = actual.toString(printSettings);\n+        this.wanted = printSettings.print(wanted);\n+        this.actual = printSettings.print(actual);\n     }\n \n     public String getWanted() {\n--- a/src/org/mockito/internal/stubbing/InvocationContainer.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainer.java\n  */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n  */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.StubInfo;\n+import org.mockito.internal.invocation.StubInfoImpl;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.answers.AnswersValidator;\n import org.mockito.internal.verification.RegisteredInvocations;\n+import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n             for (StubbedInvocationMatcher s : stubbed) {\n                 if (s.matches(invocation)) {\n                     s.markStubUsed(invocation);\n-                    invocation.markStubbed(new StubInfo(s));\n+                    invocation.markStubbed(new StubInfoImpl(s));\n                     return s;\n                 }\n             }\n     public Object invokedMock() {\n         return invocationForStubbing.getInvocation().getMock();\n     }\n+    \n+    public InvocationMatcher getInvocationForStubbing() {\n+    \treturn invocationForStubbing;\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n package org.mockito.internal.stubbing;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.DeprecatedOngoingStubbing;\n import org.mockito.stubbing.OngoingStubbing;\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n \n-import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.DescribedInvocation;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n \n     private static final long serialVersionUID = 4919105134123672727L;\n     private final Queue<Answer> answers = new ConcurrentLinkedQueue<Answer>();\n-    private PrintableInvocation usedAt;\n+    private DescribedInvocation usedAt;\n \n     public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n         super(invocation.getInvocation(), invocation.getMatchers());\n         answers.add(answer);\n     }\n \n-    public void markStubUsed(PrintableInvocation usedAt) {\n+    public void markStubUsed(DescribedInvocation usedAt) {\n         this.usedAt = usedAt;\n     }\n \n--- a/src/org/mockito/internal/stubbing/StubberImpl.java\n+++ b/src/org/mockito/internal/stubbing/StubberImpl.java\n package org.mockito.internal.stubbing;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.stubbing.answers.DoesNothing;\n-import org.mockito.internal.stubbing.answers.Returns;\n-import org.mockito.internal.stubbing.answers.ThrowsException;\n-import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;\n+import org.mockito.internal.stubbing.answers.*;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.Stubber;\n         answers.add(answer);\n         return this;\n     }\n+\n+    public Stubber doCallRealMethod() {\n+        answers.add(new CallsRealMethods());\n+        return this;\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n \n public class AnswersValidator {\n     private Reporter reporter = new Reporter();\n     \n     public void validate(Answer<?> answer, Invocation invocation) {\n+        MethodInfo methodInfo = new MethodInfo(invocation);\n         if (answer instanceof ThrowsException) {\n-            validateException((ThrowsException) answer, invocation);\n+            validateException((ThrowsException) answer, methodInfo);\n         }\n         \n         if (answer instanceof Returns) {\n-            validateReturnValue((Returns) answer, invocation);\n+            validateReturnValue((Returns) answer, methodInfo);\n         }\n         \n         if (answer instanceof DoesNothing) {\n-            validateDoNothing((DoesNothing) answer, invocation);\n+            validateDoNothing((DoesNothing) answer, methodInfo);\n         }\n         \n         if (answer instanceof CallsRealMethods) {\n-            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\n+            validateMockingConcreteClass((CallsRealMethods) answer, methodInfo);\n+        }\n+\n+        if (answer instanceof ReturnsArgumentAt) {\n+            ReturnsArgumentAt returnsArgumentAt = (ReturnsArgumentAt) answer;\n+            validateReturnArgIdentity(returnsArgumentAt, invocation);\n         }\n     }\n \n-    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\n-        if (invocation.isDeclaredOnInterface()) {\n+    private void validateReturnArgIdentity(ReturnsArgumentAt returnsArgumentAt, Invocation invocation) {\n+        returnsArgumentAt.validateIndexWithinInvocationRange(invocation);\n+\n+        MethodInfo methodInfo = new MethodInfo(invocation);\n+        if (!methodInfo.isValidReturnType(returnsArgumentAt.returnedTypeOnSignature(invocation))) {\n+            new Reporter().wrongTypeOfArgumentToReturn(invocation, methodInfo.printMethodReturnType(),\n+                                                       returnsArgumentAt.returnedTypeOnSignature(invocation),\n+                                                       returnsArgumentAt.wantedArgumentPosition());\n+        }\n+\n+    }\n+\n+    private void validateMockingConcreteClass(CallsRealMethods answer, MethodInfo methodInfo) {\n+        if (methodInfo.isDeclaredOnInterface()) {\n             reporter.cannotCallRealMethodOnInterface();\n         }\n     }\n \n-    private void validateDoNothing(DoesNothing answer, Invocation invocation) {\n-        if (!invocation.isVoid()) {\n+    private void validateDoNothing(DoesNothing answer, MethodInfo methodInfo) {\n+        if (!methodInfo.isVoid()) {\n             reporter.onlyVoidMethodsCanBeSetToDoNothing();\n         }\n     }\n \n-    private void validateReturnValue(Returns answer, Invocation invocation) {\n-        if (invocation.isVoid()) {\n-            reporter.cannotStubVoidMethodWithAReturnValue(invocation.getMethod().getName());\n+    private void validateReturnValue(Returns answer, MethodInfo methodInfo) {\n+        if (methodInfo.isVoid()) {\n+            reporter.cannotStubVoidMethodWithAReturnValue(methodInfo.getMethodName());\n         }\n         \n-        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n-            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n+        if (answer.returnsNull() && methodInfo.returnsPrimitive()) {\n+            reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), \"null\", methodInfo.getMethodName());\n         } \n \n-        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n-            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n+        if (!answer.returnsNull() && !methodInfo.isValidReturnType(answer.getReturnType())) {\n+            reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), answer.printReturnType(), methodInfo.getMethodName());\n         }\n     }\n \n-    private void validateException(ThrowsException answer, Invocation invocation) {\n+    private void validateException(ThrowsException answer, MethodInfo methodInfo) {\n         Throwable throwable = answer.getThrowable();\n         if (throwable == null) {\n             reporter.cannotStubWithNullThrowable();\n             return;\n         }\n         \n-        if (!invocation.isValidException(throwable)) {\n+        if (!methodInfo.isValidException(throwable)) {\n             reporter.checkedExceptionInvalid(throwable);\n         }\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.internal.util.Primitives;\n+import org.mockito.invocation.Invocation;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * by Szczepan Faber, created at: 3/31/12\n+ */\n+public class MethodInfo {\n+\n+    private Method method;\n+\n+    public MethodInfo(Invocation theInvocation) {\n+        this.method = theInvocation.getMethod();\n+    }\n+\n+    public boolean isValidException(Throwable throwable) {\n+        Class<?>[] exceptions = method.getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public boolean isValidReturnType(Class clazz) {\n+        if (method.getReturnType().isPrimitive() || clazz.isPrimitive()) {\n+            return Primitives.primitiveTypeOf(clazz) == Primitives.primitiveTypeOf(method.getReturnType());\n+        } else {\n+            return method.getReturnType().isAssignableFrom(clazz);\n+        }\n+    }\n+\n+    public boolean isVoid() {\n+        return this.method.getReturnType() == Void.TYPE;\n+    }\n+\n+    public String printMethodReturnType() {\n+        return method.getReturnType().getSimpleName();\n+    }\n+\n+    public String getMethodName() {\n+        return method.getName();\n+    }\n+\n+    public boolean returnsPrimitive() {\n+        return method.getReturnType().isPrimitive();\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public boolean isDeclaredOnInterface() {\n+        return method.getDeclaringClass().isInterface();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/ReturnsArgumentAt.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Returns the passed parameter identity at specified index.\n+ *\n+ * <p>The <code>argumentIndex</code> represents the index in the argument array of the invocation.</p>\n+ * <p>If this number equals -1 then the last argument is returned.</p>\n+ *\n+ * @see org.mockito.AdditionalAnswers\n+ * @since 1.9.5\n+ */\n+public class ReturnsArgumentAt implements Answer<Object>, Serializable {\n+\n+    private static final long serialVersionUID = -589315085166295101L;\n+\n+    public static final int LAST_ARGUMENT = -1;\n+\n+    private final int wantedArgumentPosition;\n+\n+    /**\n+     * Build the identity answer to return the argument at the given position in the argument array.\n+     *\n+     * @param wantedArgumentPosition The position of the argument identity to return in the invocation.\n+     *                      Using <code>-1</code> indicates the last argument.\n+     */\n+    public ReturnsArgumentAt(int wantedArgumentPosition) {\n+        this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        validateIndexWithinInvocationRange(invocation);\n+        return invocation.getArguments()[actualArgumentPosition(invocation)];\n+    }\n+\n+\n+    private int actualArgumentPosition(InvocationOnMock invocation) {\n+        return returningLastArg() ?\n+                lastArgumentIndexOf(invocation) :\n+                argumentIndexOf(invocation);\n+    }\n+\n+    private boolean returningLastArg() {\n+        return wantedArgumentPosition == LAST_ARGUMENT;\n+    }\n+\n+    private int argumentIndexOf(InvocationOnMock invocation) {\n+        return wantedArgumentPosition;\n+    }\n+\n+    private int lastArgumentIndexOf(InvocationOnMock invocation) {\n+        return invocation.getArguments().length - 1;\n+    }\n+\n+    private int checkWithinAllowedRange(int argumentPosition) {\n+        if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {\n+            new Reporter().invalidArgumentRangeAtIdentityAnswerCreationTime();\n+        }\n+        return argumentPosition;\n+    }\n+\n+    public int wantedArgumentPosition() {\n+        return wantedArgumentPosition;\n+    }\n+\n+    public void validateIndexWithinInvocationRange(InvocationOnMock invocation) {\n+        if (!argumentPositionInRange(invocation)) {\n+            new Reporter().invalidArgumentPositionRangeAtInvocationTime(invocation,\n+                                                                        returningLastArg(),\n+                                                                        wantedArgumentPosition);\n+        }\n+    }\n+\n+    private boolean argumentPositionInRange(InvocationOnMock invocation) {\n+        int actualArgumentPosition = actualArgumentPosition(invocation);\n+        if (actualArgumentPosition < 0) {\n+            return false;\n+        }\n+        if (!invocation.getMethod().isVarArgs()) {\n+            return invocation.getArguments().length > actualArgumentPosition;\n+        }\n+        // for all varargs accepts positive ranges\n+        return true;\n+    }\n+\n+    public Class returnedTypeOnSignature(InvocationOnMock invocation) {\n+        int actualArgumentPosition = actualArgumentPosition(invocation);\n+\n+        if(!invocation.getMethod().isVarArgs()) {\n+            return invocation.getMethod().getParameterTypes()[actualArgumentPosition];\n+        }\n+\n+        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n+        int varargPosition = parameterTypes.length - 1;\n+\n+        if(actualArgumentPosition < varargPosition) {\n+            return parameterTypes[actualArgumentPosition];\n+        } else {\n+            return parameterTypes[varargPosition].getComponentType();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/ReturnsElementsOf.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+/**\n+ * Returns elements of the collection. Keeps returning the last element forever.\n+ * Might be useful on occasion when you have a collection of elements to return.\n+ * <p>\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   //this:\n+ *   when(mock.foo()).thenReturn(1, 2, 3);\n+ *   //is equivalent to:\n+ *   when(mock.foo()).thenReturn(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));\n+ * </code></pre>\n+ */\n+public class ReturnsElementsOf implements Answer<Object> {\n+\n+    private final LinkedList<Object> elements;\n+\n+    public ReturnsElementsOf(Collection<?> elements) {\n+        if (elements == null) {\n+            throw new MockitoException(\"ReturnsElementsOf does not accept null as constructor argument.\\n\" +\n+            \t\t\"Please pass a collection instance\");\n+        }\n+        this.elements = new LinkedList<Object>(elements);\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        if (elements.size() == 1)\n+            return elements.get(0);\n+        else \n+            return elements.poll();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Internal answer to forward invocations on a real instance.\n+ *\n+ * @since 1.9.5\n+ */\n+public class ForwardsInvocations implements Answer<Object>, Serializable {\n+\n+\tprivate static final long serialVersionUID = -8343690268123254910L;\n+\n+\tprivate Object delegatedObject = null ;\n+\n+\tpublic ForwardsInvocations(Object delegatedObject) {\n+\t\tthis.delegatedObject = delegatedObject ;\n+\t}\n+\n+\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\n+\t\tMethod method = invocation.getMethod() ;\n+\n+        return method.invoke(delegatedObject, invocation.getArguments());\n+\t}\n+}\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.mockito.Mockito;\n-import org.mockito.internal.MockHandlerInterface;\n+import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n \n import java.io.Serializable;\n \n+/**\n+ * Returning deep stub implementation.\n+ *\n+ * Will return previously created mock if the invocation matches.\n+ *\n+ * @see Mockito#RETURNS_DEEP_STUBS\n+ * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n+ */\n public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n     \n     private static final long serialVersionUID = -6926328908792880098L;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         Class<?> clz = invocation.getMethod().getReturnType();\n-        if (!new MockCreationValidator().isTypeMockable(clz))\n+\n+        if (!new MockCreationValidator().isTypeMockable(clz)) {\n             return delegate.answer(invocation);\n+        }\n+\n         return getMock(invocation);\n     }\n \n-    private Object getMock(InvocationOnMock invocation) {\n+    private Object getMock(InvocationOnMock invocation) throws Throwable {\n+    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n+\n+        // matches invocation for verification\n+        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n+    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n+    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n+    \t\t}\n+\t\t}\n+\n+        // deep stub\n+        return recordDeepStubMock(invocation, container);\n+    }\n+\n+    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n         Class<?> clz = invocation.getMethod().getReturnType();\n         final Object mock = Mockito.mock(clz, this);\n \n-        MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n-        InvocationContainerImpl container = (InvocationContainerImpl)handler.getInvocationContainer();\n         container.addAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n                 return mock;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n import java.util.TreeSet;\n \n import org.mockito.internal.creation.ClassNameFinder;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.MockName;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.mock.MockName;\n import org.mockito.stubbing.Answer;\n \n /**\n         if (methodsGuru.isToString(invocation.getMethod())) {\n             Object mock = invocation.getMock();\n             MockName name = new MockUtil().getMockName(mock);\n-            if (name.isSurrogate()) {\n+            if (name.isDefault()) {\n                 return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n             } else {\n                 return name.toString();\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n package org.mockito.internal.stubbing.defaultanswers;\n \n import java.io.Serializable;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n+import java.lang.reflect.Modifier;\n \n import org.mockito.Mockito;\n-import org.mockito.cglib.proxy.MethodInterceptor;\n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.invocation.Location;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n     private static final long serialVersionUID = 7618312406617949441L;\n \n-    private final class ThrowingInterceptor implements MethodInterceptor {\n-        private final InvocationOnMock invocation;\n-        private final Location location = new Location();\n-\n-        private ThrowingInterceptor(InvocationOnMock invocation) {\n-            this.invocation = invocation;\n-        }\n-\n-        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n-            if (new ObjectMethodsGuru().isToString(method)) {\n-                return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n-                        invocation.toString();\n-            }\n-\n-            new Reporter().smartNullPointerException(invocation.toString(), location);\n-            return null;\n-        }\n-    }\n-\n     private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n \n     public Object answer(final InvocationOnMock invocation) throws Throwable {\n             return defaultReturnValue;\n         }\n         Class<?> type = invocation.getMethod().getReturnType();\n-        if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n-            return ClassImposterizer.INSTANCE.imposterise(new ThrowingInterceptor(invocation), type);\n+        if (!type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {\n+            final Location location = new LocationImpl();\n+            return Mockito.mock(type, new ThrowsSmartNullPointer(invocation, location));\n         }\n         return null;\n     }\n+\n+    private static class ThrowsSmartNullPointer implements Answer {\n+        private final InvocationOnMock unstubbedInvocation;\n+        private final Location location;\n+\n+        public ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {\n+            this.unstubbedInvocation = unstubbedInvocation;\n+            this.location = location;\n+        }\n+\n+        public Object answer(InvocationOnMock currentInvocation) throws Throwable {\n+            if (new ObjectMethodsGuru().isToString(currentInvocation.getMethod())) {\n+                return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n+                        unstubbedInvocation.toString();\n+            }\n+\n+            new Reporter().smartNullPointerException(unstubbedInvocation.toString(), location);\n+            return null;\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/DefaultMockingDetails.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import org.mockito.MockingDetails;\n+\n+/**\n+ * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n+ * a wrapper for {@link org.mockito.internal.util.MockUtil}.\n+ */\n+public class DefaultMockingDetails extends MockingDetails {\n+\n+    private Object toInspect;\n+    private MockUtil delegate;\n+\n+    public DefaultMockingDetails(Object toInspect, MockUtil delegate){\n+        this.toInspect = toInspect;\n+        this.delegate = delegate;\n+    }\n+    /**\n+     * Find out whether the object is a mock.\n+     * @return true if the object is a mock or a spy.\n+     */\n+    public boolean isMock(){\n+        return delegate.isMock( toInspect );\n+    }\n+\n+    /**\n+     * Find out whether the object is a spy.\n+     * @return true if the object is a spy.\n+     */\n+    public boolean isSpy(){\n+        return delegate.isSpy( toInspect );\n+    }\n+}\n+\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n+\n+import java.util.Collection;\n \n @SuppressWarnings(\"unchecked\")\n public class MockCreationValidator {\n     public boolean isTypeMockable(Class<?> clz) {\n         return ClassImposterizer.INSTANCE.canImposterise(clz);\n     }\n-    \n+\n     public void validateType(Class classToMock) {\n         if (!isTypeMockable(classToMock)) {\n             new Reporter().cannotMockFinalClass(classToMock);\n         }\n     }\n-    \n-    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n+\n+    public void validateExtraInterfaces(Class classToMock, Collection<Class> extraInterfaces) {\n         if (extraInterfaces == null) {\n             return;\n         }\n-        \n+\n         for (Class i : extraInterfaces) {\n             if (classToMock == i) {\n                 new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n             }\n         }\n     }\n-    \n+\n     public void validateMockedType(Class classToMock, Object spiedInstance) {\n         if (classToMock == null || spiedInstance == null) {\n             return;\n             new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n         }\n     }\n+\n+    public void validateDelegatedInstance(Class classToMock, Object delegatedInstance) {\n+    \tif (classToMock == null || delegatedInstance == null) {\n+            return;\n+        }\n+    \tif (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n+            new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockNameImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import org.mockito.mock.MockName;\n+\n+import java.io.Serializable;\n+\n+public class MockNameImpl implements MockName, Serializable {\n+    \n+    private static final long serialVersionUID = 8014974700844306925L;\n+    private final String mockName;\n+    private boolean defaultName;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MockNameImpl(String mockName, Class classToMock) {\n+        if (mockName == null) {\n+            this.mockName = toInstanceName(classToMock);\n+            this.defaultName = true;\n+        } else {\n+            this.mockName = mockName;\n+        }\n+    }\n+\n+    public MockNameImpl(String mockName) {\n+        this.mockName = mockName;\n+    }\n+\n+    private static String toInstanceName(Class<?> clazz) {\n+        String className = clazz.getSimpleName();\n+        if (className.length() == 0) {\n+            //it's an anonymous class, let's get name from the parent\n+            className = clazz.getSuperclass().getSimpleName();\n+        }\n+        //lower case first letter\n+        return className.substring(0, 1).toLowerCase() + className.substring(1);\n+    }\n+    \n+    public boolean isDefault() {\n+        return defaultName;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return mockName;\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import org.mockito.cglib.proxy.Callback;\n-import org.mockito.cglib.proxy.Factory;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.InvocationNotifierHandler;\n-import org.mockito.internal.MockHandler;\n-import org.mockito.internal.MockHandlerInterface;\n-import org.mockito.internal.creation.MethodInterceptorFilter;\n-import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.MockHandlerImpl;\n+import org.mockito.internal.configuration.ClassPathLoader;\n+import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n-\n-import java.io.Serializable;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+import org.mockito.plugins.MockMaker;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n-    \n-    private final MockCreationValidator creationValidator;\n \n-    public MockUtil(MockCreationValidator creationValidator) {\n-        this.creationValidator = creationValidator;\n-    }\n-    \n-    public MockUtil() {\n-        this(new MockCreationValidator());\n-    }\n+    private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n \n-    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n-        creationValidator.validateType(classToMock);\n-        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n-        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n-\n-        settings.initiateMockName(classToMock);\n-\n-        MethodInterceptorFilter filter = newMethodInterceptorFilter(settings);\n-        Class<?>[] interfaces = settings.getExtraInterfaces();\n-\n-        Class<?>[] ancillaryTypes;\n-        if (settings.isSerializable()) {\n-            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n-        } else {\n-            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n-        }\n+    public <T> T createMock(MockCreationSettings<T> settings) {\n+        InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n+                new MockHandlerImpl<T>(settings), settings);\n+        T mock = mockMaker.createMock(settings, mockHandler);\n \n         Object spiedInstance = settings.getSpiedInstance();\n-        \n-        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n-        \n         if (spiedInstance != null) {\n             new LenientCopyTool().copyToMock(spiedInstance, mock);\n         }\n-        \n+\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n-        ((Factory) mock).setCallback(0, newFilter);\n+        InvocationNotifierHandler oldHandler = (InvocationNotifierHandler) getMockHandler(mock);\n+        MockCreationSettings settings = oldHandler.getMockSettings();\n+        InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n+                new MockHandlerImpl<T>(settings), settings);\n+        mockMaker.resetMock(mock, newHandler, settings);\n     }\n \n-    private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n-        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n-        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n-        return new MethodInterceptorFilter(invocationNotifierHandler, settings);\n-    }\n-\n-    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n+    public <T> InternalMockHandler<T> getMockHandler(T mock) {\n         if (mock == null) {\n             throw new NotAMockException(\"Argument should be a mock, but is null!\");\n         }\n \n         if (isMockitoMock(mock)) {\n-            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n+            return (InternalMockHandler) mockMaker.getHandler(mock);\n         } else {\n             throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n         }\n-    }\n-\n-    private <T> boolean isMockitoMock(T mock) {\n-        return getInterceptor(mock) != null;\n     }\n \n     public boolean isMock(Object mock) {\n         return mock != null && isMockitoMock(mock);\n     }\n \n-    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n-        if (!(mock instanceof Factory)) {\n-            return null;\n-        }\n-        Factory factory = (Factory) mock;\n-        Callback callback = factory.getCallback(0);\n-        if (callback instanceof MethodInterceptorFilter) {\n-            return (MethodInterceptorFilter) callback;\n-        }\n-        return null;\n+    public boolean isSpy(Object mock) {\n+        return mock instanceof MockitoSpy && isMock(mock);\n+    }\n+\n+    private <T> boolean isMockitoMock(T mock) {\n+        return mockMaker.getHandler(mock) != null;\n     }\n \n     public MockName getMockName(Object mock) {\n         return getMockHandler(mock).getMockSettings().getMockName();\n     }\n+\n+    public void maybeRedefineMockName(Object mock, String newName) {\n+        MockName mockName = getMockName(mock);\n+        //TODO SF hacky...\n+        if (mockName.isDefault() && getMockHandler(mock).getMockSettings() instanceof CreationSettings) {\n+            ((CreationSettings) getMockHandler(mock).getMockSettings()).setMockName(new MockNameImpl(newName));\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockitoSpy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+/**\n+ * Mark internally a MockitoSpy.\n+ *\n+ * To be used un conjunction with {@link MockUtil#isMock(Object)}\n+ */\n+public interface MockitoSpy {\n+}\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n @SuppressWarnings(\"unchecked\")\n public class Primitives {\n     \n+    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n+        if(clazz.isPrimitive()) {\n+            return clazz;\n+        }\n+        return (Class<T>) primitiveTypes.get(clazz);\n+    }\n+\n     public static boolean isPrimitiveWrapper(Class<?> type) {\n         return wrapperReturnValues.containsKey(type);\n     }\n-    \n+\n     public static <T> T primitiveWrapperOf(Class<T> type) {\n         return (T) wrapperReturnValues.get(type);\n     }\n-    \n-    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n-        return (Class<T>) primitiveTypes.get(clazz);\n-    }\n-    \n+\n     public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n         return (T) primitiveValues.get(primitiveType);\n     }\n-    \n+    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n+    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n     private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n-    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n     private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n-    \n+\n+    static {\n+        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n+        primitiveTypes.put(Character.class, Character.TYPE);\n+        primitiveTypes.put(Byte.class, Byte.TYPE);\n+        primitiveTypes.put(Short.class, Short.TYPE);\n+        primitiveTypes.put(Integer.class, Integer.TYPE);\n+        primitiveTypes.put(Long.class, Long.TYPE);\n+        primitiveTypes.put(Float.class, Float.TYPE);\n+        primitiveTypes.put(Double.class, Double.TYPE);\n+    }\n+\n     static {\n         wrapperReturnValues.put(Boolean.class, Boolean.FALSE);\n         wrapperReturnValues.put(Character.class, new Character((char) 0));\n         wrapperReturnValues.put(Long.class, new Long(0));\n         wrapperReturnValues.put(Float.class, new Float(0));\n         wrapperReturnValues.put(Double.class, new Double(0));\n-    }\n-    \n-    static {\n-        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n-        primitiveTypes.put(Character.class, Character.TYPE);\n-        primitiveTypes.put(Byte.class, Byte.TYPE);\n-        primitiveTypes.put(Short.class, Short.TYPE);\n-        primitiveTypes.put(Integer.class, Integer.TYPE);\n-        primitiveTypes.put(Long.class, Long.TYPE);\n-        primitiveTypes.put(Float.class, Float.TYPE);\n-        primitiveTypes.put(Double.class, Double.TYPE);\n     }\n \n     static {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/ArrayUtils.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ArrayUtils {\n+\n+    public <T> boolean isEmpty(T[] array) {\n+        return array == null || array.length == 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+/**\n+ * hashCode and equals safe mock wrapper.\n+ *\n+ * <p>\n+ *     It doesn't use the actual mock {@link Object#hashCode} and {@link Object#equals} method as they might\n+ *     throw an NPE if those method cannot be stubbed <em>even internally</em>.\n+ * </p>\n+ *\n+ * <p>\n+ *     Instead the strategy is :\n+ *     <ul>\n+ *         <li>For hashCode : <strong>use {@link System#identityHashCode}</strong></li>\n+ *         <li>For equals : <strong>use the object reference equality</strong></li>\n+ *     </ul>\n+ * </p>\n+ *\n+ * @see HashCodeAndEqualsSafeSet\n+ */\n+public class HashCodeAndEqualsMockWrapper {\n+\n+    private Object mockInstance;\n+\n+    public HashCodeAndEqualsMockWrapper(Object mockInstance) {\n+        this.mockInstance = mockInstance;\n+    }\n+\n+    public Object get() {\n+        return mockInstance;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof HashCodeAndEqualsMockWrapper)) return false;\n+\n+        HashCodeAndEqualsMockWrapper that = (HashCodeAndEqualsMockWrapper) o;\n+\n+        return mockInstance == that.mockInstance;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(mockInstance);\n+    }\n+\n+    public static HashCodeAndEqualsMockWrapper of(Object mock) {\n+        return new HashCodeAndEqualsMockWrapper(mock);\n+    }\n+\n+    @Override public String toString() {\n+        MockUtil mockUtil = new MockUtil();\n+        return \"HashCodeAndEqualsMockWrapper{\" +\n+                \"mockInstance=\" + (mockUtil.isMock(mockInstance) ? mockUtil.getMockName(mockInstance) : typeInstanceString()) +\n+                '}';\n+    }\n+\n+    private String typeInstanceString() {\n+        return mockInstance.getClass().getSimpleName() + \"(\" + System.identityHashCode(mockInstance) + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import org.mockito.internal.util.Checks;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import static java.lang.reflect.Array.*;\n+\n+/**\n+ * hashCode and equals safe hash based set.\n+ *\n+ * <p>\n+ *     Useful for holding mocks that have un-stubbable hashCode or equals method,\n+ *     meaning that in this scenario the real code is always called and will most probably\n+ *     cause an {@link NullPointerException}.\n+ * </p>\n+ * <p>\n+ *     This collection wraps the mock in an augmented type {@link HashCodeAndEqualsMockWrapper}\n+ *     that have his own implementation.\n+ * </p>\n+ *\n+ * @see HashCodeAndEqualsMockWrapper\n+ */\n+public class HashCodeAndEqualsSafeSet implements Set<Object> {\n+\n+    private HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+\n+    public Iterator<Object> iterator() {\n+        return new Iterator<Object>() {\n+            private Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n+\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            public Object next() {\n+                return iterator.next().get();\n+            }\n+\n+            public void remove() {\n+                iterator.remove();\n+            }\n+        };\n+    }\n+\n+    public int size() {\n+        return backingHashSet.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return backingHashSet.isEmpty();\n+    }\n+\n+    public boolean contains(Object mock) {\n+        return backingHashSet.contains(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public boolean add(Object mock) {\n+        return backingHashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public boolean remove(Object mock) {\n+        return backingHashSet.remove(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public void clear() {\n+        backingHashSet.clear();\n+    }\n+\n+    @Override public Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+        if (!(o instanceof HashCodeAndEqualsSafeSet)) {\n+            return false;\n+        }\n+        HashCodeAndEqualsSafeSet that = (HashCodeAndEqualsSafeSet) o;\n+        return backingHashSet.equals(that.backingHashSet);\n+    }\n+\n+    @Override public int hashCode() {\n+        return backingHashSet.hashCode();\n+    }\n+\n+    public Object[] toArray() {\n+        return unwrapTo(new Object[size()]);\n+    }\n+\n+    private <T> T[] unwrapTo(T[] array) {\n+        Iterator<Object> iterator = iterator();\n+        for (int i = 0, objectsLength = array.length; i < objectsLength; i++) {\n+            if (iterator.hasNext()) {\n+                array[i] = (T) iterator.next();\n+            }\n+        }\n+        return array;\n+    }\n+\n+\n+    public <T> T[] toArray(T[] typedArray) {\n+        T[] array = typedArray.length >= size() ? typedArray :\n+                (T[]) newInstance(typedArray.getClass().getComponentType(), size());\n+        return unwrapTo(array);\n+    }\n+\n+    public boolean removeAll(Collection<?> mocks) {\n+        return backingHashSet.removeAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean containsAll(Collection<?> mocks) {\n+        return backingHashSet.containsAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean addAll(Collection<?> mocks) {\n+        return backingHashSet.addAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean retainAll(Collection<?> mocks) {\n+        return backingHashSet.retainAll(asWrappedMocks(mocks));\n+    }\n+\n+    private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {\n+        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n+        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+        for (Object mock : mocks) {\n+            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n+            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n+        }\n+        return hashSet;\n+    }\n+\n+    @Override public String toString() {\n+        return backingHashSet.toString();\n+    }\n+\n+    public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n+        return of(Arrays.asList(mocks));\n+    }\n+\n+    public static HashCodeAndEqualsSafeSet of(Iterable<Object> objects) {\n+        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet = new HashCodeAndEqualsSafeSet();\n+        if (objects != null) {\n+            for (Object mock : objects) {\n+                hashCodeAndEqualsSafeSet.add(mock);\n+            }\n+        }\n+        return hashCodeAndEqualsSafeSet;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/IdentitySet.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import java.util.LinkedList;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class IdentitySet {\n+\n+    LinkedList list = new LinkedList();\n+    \n+    public boolean contains(Object o) {\n+        for(Object existing:list) {\n+            if (existing == o) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void add(Object o) {\n+        list.add(o);        \n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/ListUtil.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.util.collections;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+public class ListUtil {\n+\n+    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n+        LinkedList<T> filtered = new LinkedList<T>();\n+        for (T t : collection) {\n+            if (!filter.isOut(t)) {\n+                filtered.add(t);\n+            }\n+        }\n+        return filtered;\n+    }\n+    \n+    public static interface Filter<T> {\n+        boolean isOut(T object);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/Sets.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n+\n+public abstract class Sets {\n+    public static Set<Object> newMockSafeHashSet(Iterable<Object> mocks) {\n+        return HashCodeAndEqualsSafeSet.of(mocks);\n+    }\n+\n+    public static Set<Object> newMockSafeHashSet(Object... mocks) {\n+        return HashCodeAndEqualsSafeSet.of(mocks);\n+    }\n+\n+    public static IdentitySet newIdentitySet() {\n+        return new IdentitySet();\n+    }\n+\n+    public static <T> Set<T> newSet(T ... elements) {\n+        if (elements == null) {\n+            throw new IllegalArgumentException(\"Expected an array of elements (or empty array) but received a null.\");\n+        }\n+        return new LinkedHashSet<T>(asList(elements));\n+    }\n+}\n--- a/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n+++ b/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n  */\n package org.mockito.internal.util.reflection;\n \n-import java.beans.BeanInfo;\n-import java.beans.IntrospectionException;\n-import java.beans.Introspector;\n-import java.beans.PropertyDescriptor;\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import java.util.Locale;\n \n /**\n  * This utility class will call the setter of the property to inject a new value.\n  */\n public class BeanPropertySetter {\n+\n+    private static final String SET_PREFIX = \"set\";\n \n     private final Object target;\n     private boolean reportNoSetterFound;\n         AccessibilityChanger changer = new AccessibilityChanger();\n         Method writeMethod = null;\n         try {\n-            BeanInfo targetInfo = Introspector.getBeanInfo(target.getClass());\n-            PropertyDescriptor[] propertyDescriptors = targetInfo.getPropertyDescriptors();\n+            writeMethod = target.getClass().getMethod(setterName(field.getName()), field.getType());\n \n-            for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n-                if(propertyNameMatchFieldName(propertyDescriptor)\n-                        && propertyTypeMatchFieldType(propertyDescriptor)) {\n-                    writeMethod = propertyDescriptor.getWriteMethod();\n-                    if(writeMethod != null) {\n-                        changer.enableAccess(writeMethod);\n-                        writeMethod.invoke(target, value);\n-                        return true;\n-                    }\n-                }\n-            }\n+            changer.enableAccess(writeMethod);\n+            writeMethod.invoke(target, value);\n+            return true;\n         } catch (InvocationTargetException e) {\n             throw new RuntimeException(\"Setter '\" + writeMethod + \"' of '\" + target + \"' with value '\" + value + \"' threw exception : '\" + e.getTargetException() + \"'\", e);\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(\"Access not authorized on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"'\", e);\n-        } catch (IntrospectionException e) {\n-            throw new RuntimeException(\"Something went wrong when trying to infer by introspection the setter of property '\" + field.getName() + \"' on type '\" + target.getClass() + \"'\" + target.getClass(), e);\n+        } catch (NoSuchMethodException e) {\n+            reportNoSetterFound();\n         } finally {\n             if(writeMethod != null) {\n                 changer.safelyDisableAccess(writeMethod);\n         return false;\n     }\n \n+    /**\n+     * Retrieve the setter name from the field name.\n+     *\n+     * <p>Implementation is based on the code of {@link java.beans.Introspector}.</p>\n+     *\n+     * @param fieldName the Field name\n+     * @return Setter name.\n+     */\n+    private String setterName(String fieldName) {\n+        return new StringBuilder(SET_PREFIX)\n+                .append(fieldName.substring(0, 1).toUpperCase(Locale.ENGLISH))\n+                .append(fieldName.substring(1))\n+                .toString();\n+    }\n+\n     private void reportNoSetterFound() {\n         if(reportNoSetterFound) {\n             throw new RuntimeException(\"Problems setting value on object: [\" + target + \"] for property : [\" + field.getName() + \"], setter not found\");\n         }\n     }\n \n-    private boolean propertyTypeMatchFieldType(PropertyDescriptor pd) {\n-        return field.getType().equals(pd.getPropertyType());\n-    }\n-\n-    private boolean propertyNameMatchFieldName(PropertyDescriptor pd) {\n-        return field.getName().equals(pd.getName());\n-    }\n-\n }\n--- a/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n \n package org.mockito.internal.util.reflection;\n \n+/**\n+ * Report on field initialization\n+ */\n public class FieldInitializationReport {\n     private Object fieldInstance;\n     private boolean wasInitialized;\n+    private boolean wasInitializedUsingConstructorArgs;\n \n-    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized) {\n+    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized, boolean wasInitializedUsingConstructorArgs) {\n         this.fieldInstance = fieldInstance;\n         this.wasInitialized = wasInitialized;\n+        this.wasInitializedUsingConstructorArgs = wasInitializedUsingConstructorArgs;\n     }\n \n+    /**\n+     * Returns the actual field instance.\n+     *\n+     * @return the actual instance\n+     */\n     public Object fieldInstance() {\n         return fieldInstance;\n     }\n \n+    /**\n+     * Indicate wether the field was created during the process or not.\n+     *\n+     * @return <code>true</code> if created, <code>false</code> if the field did already hold an instance.\n+     */\n     public boolean fieldWasInitialized() {\n         return wasInitialized;\n     }\n \n+    /**\n+     * Indicate wether the field was created using constructor args.\n+     *\n+     * @return <code>true</code> if field was created using constructor parameters.\n+     */\n+    public boolean fieldWasInitializedUsingContructorArgs() {\n+        return wasInitializedUsingConstructorArgs;\n+    }\n+\n+    /**\n+     * Returns the class of the actual instance in the field.\n+     *\n+     * @return Class of the instance\n+     */\n     public Class<?> fieldClass() {\n         return fieldInstance != null ? fieldInstance.getClass() : null;\n     }\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n      *\n      * @param fieldOwner Instance of the test.\n      * @param field Field to be initialize.\n+     * @param argResolver Constructor parameters resolver\n      */\n     public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {\n         this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));\n     }\n \n     /**\n-     * Initialize field if no initialized and return the actual instance.\n+     * Initialize field if not initialized and return the actual instance.\n      *\n      * @return Actual field instance.\n      */\n     private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {\n         Object fieldInstance = field.get(fieldOwner);\n         if(fieldInstance != null) {\n-            return new FieldInitializationReport(fieldInstance, false);\n-        }\n-\n-        instantiator.instantiate();\n-        return new FieldInitializationReport(field.get(fieldOwner), true);\n+            return new FieldInitializationReport(fieldInstance, false, false);\n+        }\n+\n+        return instantiator.instantiate();\n     }\n \n     /**\n     }\n \n     private interface ConstructorInstantiator {\n-        Object instantiate();\n+        FieldInitializationReport instantiate();\n     }\n \n     /**\n             this.field = field;\n         }\n \n-        public Object instantiate() {\n+        public FieldInitializationReport instantiate() {\n             final AccessibilityChanger changer = new AccessibilityChanger();\n             Constructor<?> constructor = null;\n             try {\n                 Object newFieldInstance = constructor.newInstance(noArg);\n                 new FieldSetter(testClass, field).set(newFieldInstance);\n \n-                return field.get(testClass);\n+                return new FieldInitializationReport(field.get(testClass), true, false);\n             } catch (NoSuchMethodException e) {\n                 throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n             } catch (InvocationTargetException e) {\n             this.argResolver = argumentResolver;\n         }\n \n-        public Object instantiate() {\n+        public FieldInitializationReport instantiate() {\n             final AccessibilityChanger changer = new AccessibilityChanger();\n             Constructor<?> constructor = null;\n             try {\n                 Object newFieldInstance = constructor.newInstance(args);\n                 new FieldSetter(testClass, field).set(newFieldInstance);\n \n-                return field.get(testClass);\n+                return new FieldInitializationReport(field.get(testClass), false, true);\n             } catch (IllegalArgumentException e) {\n                 throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n             } catch (InvocationTargetException e) {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.Incubating;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockito.internal.util.collections.ListUtil;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Small fluent reflection tools to work with fields.\n+ *\n+ * Code is very new and might need rework.\n+ */\n+@Incubating\n+public abstract class Fields {\n+\n+    /**\n+     * Instance fields declared in thes class and superclasses of the given instance.\n+     *\n+     * @param instance Instance from which declared fields will be retrieved.\n+     * @return InstanceFields of this object instance.\n+     */\n+    public static InstanceFields allDeclaredFieldsOf(Object instance) {\n+        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n+        for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));\n+        }\n+        return new InstanceFields(instance, instanceFields);\n+    }\n+\n+    /**\n+     * Instance fields declared in the of the given instance.\n+     *\n+     * @param instance Instance from which declared fields will be retrieved.\n+     * @return InstanceFields of this object instance.\n+     */\n+    public static InstanceFields declaredFieldsOf(Object instance) {\n+        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n+        instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));\n+        return new InstanceFields(instance, instanceFields);\n+    }\n+\n+    private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {\n+        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();\n+        for (Field field : fields) {\n+            InstanceField instanceField = new InstanceField(field, instance);\n+            instanceDeclaredFields.add(instanceField);\n+        }\n+        return instanceDeclaredFields;\n+    }\n+\n+    /**\n+     * Accept fields annotated by the given annotations.\n+     *\n+     * @param annotations Annotation types to check.\n+     * @return The filter.\n+     */\n+    public static Filter<InstanceField> annotatedBy(final Class<? extends Annotation>... annotations) {\n+        return new Filter<InstanceField>() {\n+            public boolean isOut(InstanceField instanceField) {\n+                Checks.checkNotNull(annotations, \"Provide at least one annotation class\");\n+\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if(instanceField.isAnnotatedBy(annotation)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Accept fields with non null value.\n+     *\n+     * @return The filter.\n+     */\n+    private static Filter<InstanceField> nullField() {\n+        return new Filter<InstanceField>() {\n+            public boolean isOut(InstanceField instanceField) {\n+                return instanceField.isNull();\n+            }\n+        };\n+    }\n+\n+    public static class InstanceFields {\n+        private final Object instance;\n+\n+        private final List<InstanceField> instanceFields;\n+\n+        public InstanceFields(Object instance, List<InstanceField> instanceFields) {\n+            this.instance = instance;\n+            this.instanceFields = instanceFields;\n+        }\n+\n+        public InstanceFields filter(Filter<InstanceField> withFilter) {\n+            return new InstanceFields(instance, ListUtil.filter(instanceFields, withFilter));\n+        }\n+\n+        public InstanceFields notNull() {\n+            return filter(nullField());\n+        }\n+\n+        public List<InstanceField> instanceFields() {\n+            return new ArrayList<InstanceField>(instanceFields);\n+        }\n+\n+        public List<Object> assignedValues() {\n+            List<Object> values = new ArrayList<Object>(instanceFields.size());\n+            for (InstanceField instanceField : instanceFields) {\n+                values.add(instanceField.read());\n+            }\n+            return values;\n+        }\n+\n+        public List<String> names() {\n+            List<String> fieldNames = new ArrayList<String>(instanceFields.size());\n+            for (InstanceField instanceField : instanceFields) {\n+                fieldNames.add(instanceField.name());\n+            }\n+            return fieldNames;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/InstanceField.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.internal.util.Checks;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Represents an accessible instance field.\n+ *\n+ * Contains the instance reference on which the field can be read adn write.\n+ */\n+public class InstanceField {\n+    private final Field field;\n+    private final Object instance;\n+    private FieldReader fieldReader;\n+\n+    /**\n+     * Create a new InstanceField.\n+     *\n+     * @param field The field that should be accessed, note that no checks are performed to ensure\n+     *              the field belong to this instance class.\n+     * @param instance The instance from which the field shall be accessed.\n+     */\n+    public InstanceField(Field field, Object instance) {\n+        this.field = Checks.checkNotNull(field, \"field\");\n+        this.instance = Checks.checkNotNull(instance, \"instance\");\n+    }\n+\n+    /**\n+     * Safely read the field.\n+     *\n+     * @return the field value.\n+     * @see FieldReader\n+     */\n+    public Object read() {\n+        return reader().read();\n+    }\n+\n+    /**\n+     * Set the given value to the field of this instance.\n+     *\n+     * @param value The value that should be written to the field.\n+     * @see FieldSetter\n+     */\n+    public void set(Object value) {\n+        new FieldSetter(instance, field).set(value);\n+    }\n+\n+    /**\n+     * Check that the field is not null.\n+     *\n+     * @return <code>true</code> if <code>null</code>, else <code>false</code>.\n+     */\n+    public boolean isNull() {\n+        return reader().isNull();\n+    }\n+\n+    /**\n+     * Check if the field is annotated by the given annotation.\n+     *\n+     * @param annotationClass The annotation type to check.\n+     * @return <code>true</code> if the field is annotated by this annotation, else <code>false</code>.\n+     */\n+    public boolean isAnnotatedBy(Class<? extends Annotation> annotationClass) {\n+        return field.isAnnotationPresent(annotationClass);\n+    }\n+\n+    /**\n+     * Returns the annotation instance for the given annotation type.\n+     *\n+     * @param annotationClass Tha annotation type to retrieve.\n+     * @param <A> Type of the annotation.\n+     * @return The annotation instance.\n+     */\n+    public <A extends Annotation> A annotation(Class<A> annotationClass) {\n+        return field.getAnnotation(annotationClass);\n+    }\n+\n+    /**\n+     * Returns the JDK {@link Field} instance.\n+     *\n+     * @return The actual {@link Field} instance.\n+     */\n+    public Field jdkField() {\n+        return field;\n+    }\n+\n+    private FieldReader reader() {\n+        if (fieldReader == null) {\n+            fieldReader = new FieldReader(instance, field);\n+        }\n+        return fieldReader;\n+    }\n+\n+    /**\n+     * Returns the name of the field.\n+     *\n+     * @return Name of the field.\n+     */\n+    public String name() {\n+        return field.getName();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        InstanceField that = (InstanceField) o;\n+\n+        if (!field.equals(that.field)) return false;\n+        if (!instance.equals(that.instance)) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = field.hashCode();\n+        result = 31 * result + instance.hashCode();\n+        return result;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/AtLeast.java\n+++ b/src/org/mockito/internal/verification/AtLeast.java\n import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker;\n import org.mockito.internal.verification.checkers.MissingInvocationChecker;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class AtLeast implements VerificationInOrderMode, VerificationMode {\n--- a/src/org/mockito/internal/verification/AtMost.java\n+++ b/src/org/mockito/internal/verification/AtMost.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class AtMost implements VerificationMode {\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/Calls.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrder;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.checkers.*;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+public class Calls implements VerificationMode, VerificationInOrderMode {\n+\n+    final int wantedCount;\n+\n+    public Calls(int wantedNumberOfInvocations) {\n+        if( wantedNumberOfInvocations <= 0 ) {\n+            throw new MockitoException( \"Negative and zero values are not allowed here\" );\n+        }\n+        this.wantedCount = wantedNumberOfInvocations;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        throw new MockitoException( \"calls is only intended to work with InOrder\" );\n+    }\n+\n+    public void verifyInOrder(VerificationDataInOrder data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        missingInvocation.check( allInvocations, wanted, this, data.getOrderingContext());\n+        NonGreedyNumberOfInvocationsInOrderChecker numberOfCalls = new NonGreedyNumberOfInvocationsInOrderChecker();\n+        numberOfCalls.check( allInvocations, wanted, wantedCount, data.getOrderingContext());\n+    }    \n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count (non-greedy): \" + wantedCount;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/verification/InOrderContextImpl.java\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.IdentitySet;\n+import org.mockito.internal.util.collections.IdentitySet;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class InOrderContextImpl implements InOrderContext {\n     \n--- a/src/org/mockito/internal/verification/InOrderWrapper.java\n+++ b/src/org/mockito/internal/verification/InOrderWrapper.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.InOrderImpl;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n import java.util.List;\n--- a/src/org/mockito/internal/verification/NoMoreInteractions.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractions.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class NoMoreInteractions implements VerificationMode, VerificationInOrderMode {\n \n     @SuppressWarnings(\"unchecked\")\n     public void verify(VerificationData data) {\n-        Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());                       \n+        Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n         if (unverified != null) {\n             new Reporter().noMoreInteractionsWanted(unverified, (List) data.getAllInvocations());\n         }\n--- a/src/org/mockito/internal/verification/Only.java\n+++ b/src/org/mockito/internal/verification/Only.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class Only implements VerificationMode {\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n \n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.ListUtil;\n-import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockito.invocation.Invocation;\n \n import java.io.Serializable;\n import java.util.Collections;\n \n     private static final long serialVersionUID = -2674402327380736290L;\n     private final List<Invocation> invocations = Collections.synchronizedList(new LinkedList<Invocation>());\n-    \n+\n     public void add(Invocation invocation) {\n         invocations.add(invocation);\n     }\n     }\n \n     public List<Invocation> getAll() {\n-        return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());\n+    \tList<Invocation> copiedList;\n+    \tsynchronized (invocations) {\n+\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n+\t\t}\n+\n+        return ListUtil.filter(copiedList, new RemoveToString());\n     }\n \n     public boolean isEmpty() {\n \n     private static class RemoveToString implements Filter<Invocation> {\n         public boolean isOut(Invocation invocation) {\n-            return invocation.isToString();\n+            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/Times.java\n+++ b/src/org/mockito/internal/verification/Times.java\n import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker;\n import org.mockito.internal.verification.checkers.NumberOfInvocationsChecker;\n import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class Times implements VerificationInOrderMode, VerificationMode {\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n \n public class VerificationDataImpl implements VerificationData {\n \n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n         return new Times(wantedNumberOfInvocations);\n     }\n \n+    public static Calls calls(int wantedNumberOfInvocations) {\n+        return new Calls( wantedNumberOfInvocations );\n+    }\n+\n     public static NoMoreInteractions noMoreInteractions() {\n         return new NoMoreInteractions();\n     }\n--- a/src/org/mockito/internal/verification/api/InOrderContext.java\n+++ b/src/org/mockito/internal/verification/api/InOrderContext.java\n  */\n package org.mockito.internal.verification.api;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.Invocation;\n \n public interface InOrderContext {\n \n--- a/src/org/mockito/internal/verification/api/VerificationData.java\n+++ b/src/org/mockito/internal/verification/api/VerificationData.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public interface VerificationData {\n \n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public interface VerificationDataInOrder {\n \n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public class VerificationDataInOrderImpl implements VerificationDataInOrder {\n \n--- a/src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastDiscrepancy.java\n  */\n package org.mockito.internal.verification.checkers;\n \n-import org.mockito.exceptions.Discrepancy;\n+import org.mockito.internal.reporting.Discrepancy;\n \n public class AtLeastDiscrepancy extends Discrepancy {\n \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class AtLeastXNumberOfInvocationsChecker {\n     \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class AtLeastXNumberOfInvocationsInOrderChecker {\n     \n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool;\n+import org.mockito.invocation.Invocation;\n \n public class MissingInvocationChecker {\n     \n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class MissingInvocationInOrderChecker {\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification.checkers;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.InvocationMarker;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.reporting.Discrepancy;\n+import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n+\n+import java.util.List;\n+\n+public class NonGreedyNumberOfInvocationsInOrderChecker {\n+\n+    private final InvocationsFinder finder;\n+    private final Reporter reporter;\n+    private final InvocationMarker marker;\n+\n+    public NonGreedyNumberOfInvocationsInOrderChecker() {\n+        this(new InvocationsFinder(), new Reporter(), new InvocationMarker());\n+    }\n+\n+    NonGreedyNumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter, InvocationMarker marker ) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+        this.marker = marker;\n+    }\n+    \n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        int actualCount = 0;\n+        Location lastLocation = null;\n+        while( actualCount < wantedCount ){\n+            Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n+            if( next == null ){\n+                reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );\n+            }\n+            marker.markVerified( next, wanted );\n+            context.markVerified( next );\n+            lastLocation = next.getLocation();\n+            actualCount++;\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n \n import java.util.List;\n \n-import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.reporting.Discrepancy;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class NumberOfInvocationsChecker {\n     \n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n \n import java.util.List;\n \n-import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.reporting.Discrepancy;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class NumberOfInvocationsInOrderChecker {\n     \n--- /dev/null\n+++ b/src/org/mockito/invocation/DescribedInvocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.invocation;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.Incubating;\n+\n+/**\n+ * Provides information about the invocation, specifically a human readable description and the location.\n+ */\n+@Incubating\n+public interface DescribedInvocation extends PrintableInvocation {\n+\n+    /**\n+     * Describes the invocation in the human friendly way.\n+     *\n+     * @return the description of this invocation.\n+     */\n+    String toString();\n+\n+    /**\n+     * The place in the code where the invocation happened.\n+     *\n+     * @return the location of the invocation.\n+     */\n+    Location getLocation();\n+}\n--- /dev/null\n+++ b/src/org/mockito/invocation/Invocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.invocation;\n+\n+import org.mockito.Incubating;\n+\n+/**\n+ * A method call on a mock object. Contains all information and state needed for the Mockito framework to operate.\n+ * This API might be useful for developers who extend Mockito.\n+ * <p>\n+ * The javadoc does not have lots of examples or documentation because its audience is different.\n+ * Vast majority of users don't need to use the Invocation. It's mostly useful for other framework authors\n+ * that extend Mockito.\n+ *\n+ * @since 1.9.5\n+ */\n+@Incubating\n+public interface Invocation extends InvocationOnMock, DescribedInvocation {\n+\n+    /**\n+     * @return whether the invocation has been already verified.\n+     * Needed for {@link org.mockito.Mockito#verifyNoMoreInteractions(Object...)}\n+     */\n+    boolean isVerified();\n+\n+    /**\n+     * @return the sequence number of the Invocation. Useful to determine the order of invocations.\n+     * Used by verification in order.\n+     */\n+    int getSequenceNumber();\n+\n+    /**\n+     * @return the location in code of this invocation.\n+     */\n+    Location getLocation();\n+\n+    /**\n+     * Returns unprocessed arguments whereas {@link #getArguments()} returns\n+     * arguments already processed (e.g. varargs expended, etc.).\n+     *\n+     * @return unprocessed arguments, exactly as provided to this invocation.\n+     */\n+    Object[] getRawArguments();\n+\n+    /**\n+     * Marks this invocation as verified so that it will not cause verification error at\n+     * {@link org.mockito.Mockito#verifyNoMoreInteractions(Object...)}\n+     */\n+    void markVerified();\n+\n+    /**\n+     * @return the stubbing information for this invocation. May return null - this means\n+     * the invocation was not stubbed.\n+     */\n+    StubInfo stubInfo();\n+\n+    /**\n+     * Marks this invocation as stubbed.\n+     *\n+     * @param stubInfo the information about stubbing.\n+     */\n+    void markStubbed(StubInfo stubInfo);\n+\n+    /**\n+     * Informs if the invocation participates in verify-no-more-invocations or verification in order.\n+     *\n+     * @return whether this invocation should be ignored for the purposes of\n+     * verify-no-more-invocations or verification in order.\n+     */\n+    boolean isIgnoredForVerification();\n+\n+    /**\n+     * Configures this invocation to be ignored for verify-no-more-invocations or verification in order.\n+     * See also {@link #isIgnoredForVerification()}\n+     */\n+    void ignoreForVerification();\n+}\n--- /dev/null\n+++ b/src/org/mockito/invocation/Location.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.invocation;\n+\n+import org.mockito.Incubating;\n+\n+/**\n+ * Describes the location of something in the source code.\n+ */\n+@Incubating\n+public interface Location {\n+\n+    /**\n+     * @return the location\n+     */\n+    String toString();\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/invocation/MockHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.invocation;\n+\n+import org.mockito.Incubating;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Mockito handler of an invocation on a mock. This is a core part of the API, the heart of Mockito.\n+ * See also the {@link org.mockito.plugins.MockMaker}.\n+ * <p>\n+ * This api is work in progress. Do not provide your own implementations.\n+ * Mockito will provide you with the implementation via other {@link org.mockito.plugins.MockMaker} methods.\n+ */\n+@Incubating\n+public interface MockHandler extends Serializable {\n+    /**\n+     * Takes an invocation object and handles it.\n+     * <p>\n+     * The default implementation provided by Mockito handles invocations by recording\n+     * method calls on mocks for further verification, captures the stubbing information when mock is stubbed,\n+     * returns the stubbed values for invocations that have been stubbed, and much more.\n+     *\n+     * @param invocation The invocation to handle\n+     * @return Result\n+     * @throws Throwable Throwable\n+     */\n+    @Incubating\n+    Object handle(Invocation invocation) throws Throwable;\n+}\n--- /dev/null\n+++ b/src/org/mockito/invocation/StubInfo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.invocation;\n+\n+import org.mockito.Incubating;\n+\n+/**\n+ * The information about stubbing, for example the location of stubbing.\n+ */\n+@Incubating\n+public interface StubInfo {\n+\n+    /**\n+     * @return the location where the invocation was stubbed.\n+     */\n+    Location stubbedAt();\n+}\n--- a/src/org/mockito/listeners/MethodInvocationReport.java\n+++ b/src/org/mockito/listeners/MethodInvocationReport.java\n package org.mockito.listeners;\n \n import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.DescribedInvocation;\n \n /**\n  * Represent a method call on a mock.\n  */\n public interface MethodInvocationReport {\n     /**\n+     * The return type is deprecated, please assign the return value from this method\n+     * to the {@link DescribedInvocation} type. Sorry for inconvenience but we had to move\n+     * {@link PrintableInvocation} to better place to keep the API consistency.\n+     *\n      * @return Information on the method call, never {@code null}\n      */\n-    PrintableInvocation getInvocation();\n+    DescribedInvocation getInvocation();\n \n     /**\n      * @return The resulting value of the method invocation, may be <code>null</code>\n--- /dev/null\n+++ b/src/org/mockito/mock/MockCreationSettings.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.mock;\n+\n+import org.mockito.Incubating;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Informs about the mock settings. An immutable view of {@link org.mockito.MockSettings}.\n+ */\n+@Incubating\n+public interface MockCreationSettings<T> {\n+\n+    /**\n+     * Mocked type. An interface or class the mock should implement / extend.\n+     */\n+    Class<T> getTypeToMock();\n+\n+    /**\n+     * the extra interfaces the mock object should implement.\n+     */\n+    Set<Class> getExtraInterfaces();\n+\n+    /**\n+     * the name of this mock, as printed on verification errors; see {@link org.mockito.MockSettings#name}.\n+     */\n+    MockName getMockName();\n+\n+    /**\n+     * the default answer for this mock, see {@link org.mockito.MockSettings#defaultAnswer}.\n+     */\n+    Answer getDefaultAnswer();\n+\n+    /**\n+     * the spied instance - needed for spies.\n+     */\n+    Object getSpiedInstance();\n+\n+    /**\n+     * if the mock is serializable, see {@link org.mockito.MockSettings#serializable}.\n+     */\n+    boolean isSerializable();\n+\n+    /**\n+     * the invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n+     */\n+    List<InvocationListener> getInvocationListeners();\n+}\n--- /dev/null\n+++ b/src/org/mockito/mock/MockName.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.mock;\n+\n+/**\n+ * Represents the name of the mock as shown in the verification failure reports, etc.\n+ */\n+public interface MockName {\n+\n+    /**\n+     * the name\n+     */\n+    String toString();\n+\n+    /**\n+     * default name means generated by Mockito. non-default means the user has named the mock at creation.\n+     */\n+    boolean isDefault();\n+}\n--- /dev/null\n+++ b/src/org/mockito/plugins/MockMaker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.plugins;\n+\n+import org.mockito.Incubating;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n+/**\n+ * The facility to create mocks.\n+ *\n+ * <p>By default, an internal cglib/asm/objenesis based implementation is used.</p>\n+ *\n+ * <p>{@code MockMaker} is an extension point that makes it possible to use custom dynamic proxies\n+ * and avoid using the default cglib/asm/objenesis implementation.\n+ * For example, the android users can use a MockMaker that can work with Dalvik virtual machine\n+ * and hence bring Mockito to android apps developers.</p>\n+ *\n+ * <h3>Implementing custom {@code MockMaker}</h3>\n+ *\n+ * <ul>\n+ *     <li>Implement {@link #createMock)}. Do not provide your own implementation of  </li>\n+ *     <li></li>\n+ *     <li></li>\n+ * </ul>\n+ *\n+ * <h3>Using the extension point</h3>\n+ *\n+ * <p>Suppose you wrote an extension to create mocks with some <em>Awesome</em> library, in order to tell\n+ * Mockito to use it you need to put in your classpath\n+ * <ol style=\"list-style-type: lower-alpha\">\n+ *     <li>The implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *     <li>A file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n+ *     <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n+ *     the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ * </ol></p>\n+ *\n+ * <p>Note that if several <code>mockito-extensions/org.mockito.plugins.MockMaker</code> files exists in the classpath\n+ * Mockito will only use the first returned by the standard {@link ClassLoader#getResource} mechanism.\n+ *\n+ * @see org.mockito.mock.MockCreationSettings\n+ * @see org.mockito.invocation.MockHandler\n+ * @since 1.9.5\n+ */\n+@Incubating\n+public interface MockMaker {\n+\n+    /**\n+     * If you want to provide your own implementation of {@code MockMaker} this method should:\n+     * <ul>\n+     *     <li>Create a proxy object that implements {@code settings.typeToMock} and potentially also {@code settings.extraInterfaces}.</li>\n+     *     <li>You may use the information from {@code settings} to create/configure your proxy object.</li>\n+     *     <li>Your proxy object should carry the {@code hander} with it. For example, if you generate byte code\n+     *     to create the proxy you could generate an extra field to keep the {@code handler} with the generated object.\n+     *     Your implementation of {@code MockMaker} is required to provide this instance of {@code handler} when\n+     *     {@link #getHandler(Object)} is called.\n+     *     </li>\n+     * </ul>\n+     *\n+     * @param settings - mock creation settings like type to mock, extra interfaces and so on.\n+     * @param handler See {@link org.mockito.invocation.MockHandler}.\n+     *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of\n+     *                {@link #getHandler(Object)} will return this instance.\n+     * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.\n+     * @return The mock instance.\n+     * @since 1.9.5\n+     */\n+    <T> T createMock(\n+            MockCreationSettings<T> settings,\n+            MockHandler handler\n+    );\n+\n+    /**\n+     * Returns the handler for the {@code mock}. <b>Do not</b> provide your own implementations at this time\n+     * because the work on the {@link MockHandler} api is not completed.\n+     * Use the instance provided to you by Mockito at {@link #createMock} or {@link #resetMock}.\n+     *\n+     * @param mock The mock instance.\n+     * @return may return null - it means that there is no handler attached to provided object.\n+     *   This means the passed object is not really a Mockito mock.\n+     * @since 1.9.5\n+     */\n+    MockHandler getHandler(Object mock);\n+\n+    /**\n+     * Replaces the existing handler on {@code mock} with {@code newHandler}.\n+     *\n+     * <p>The invocation handler actually store invocations to achieve\n+     * stubbing and verification. In order to reset the mock, we pass\n+     * a new instance of the invocation handler.</p>\n+     *\n+     * <p>Your implementation should make sure the {@code newHandler} is correctly associated to passed {@code mock}</p>\n+     *\n+     * @param mock The mock instance whose invocation handler is to be replaced.\n+     * @param newHandler The new invocation handler instance.\n+     * @param settings The mock settings - should you need to access some of the mock creation details.\n+     * @since 1.9.5\n+     */\n+    void resetMock(\n+            Object mock,\n+            MockHandler newHandler,\n+            MockCreationSettings settings\n+    );\n+}\n--- a/src/org/mockito/stubbing/OngoingStubbing.java\n+++ b/src/org/mockito/stubbing/OngoingStubbing.java\n      * @param throwableClasses to be thrown on method invocation\n      *\n      * @return iOngoingStubbing object that allows stubbing consecutive calls\n+     * @since 1.9.0\n      */\n     OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses);\n \n      * @return iOngoingStubbing object that allows stubbing consecutive calls\n      *\n      * @see #thenAnswer(Answer)\n+     * @since 1.9.0\n      */\n     OngoingStubbing<T> then(Answer<?> answer);\n \n      *\n      * @param <M> The mock type given by the variable type.\n      * @return Mock used in this ongoing stubbing.\n+     * @since 1.9.0\n      */\n     <M> M getMock();\n \n--- a/src/org/mockito/stubbing/Stubber.java\n+++ b/src/org/mockito/stubbing/Stubber.java\n      * \n      *  See examples in javadoc for {@link Mockito}\n      * \n-     * @param mock\n+     * @param mock The mock\n      * @return select method for stubbing\n      */\n     <T> T when(T mock);\n     Stubber doThrow(Throwable toBeThrown);\n \n     /**\n-     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class<? extends Throwable>)} style:\n+     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class)} style:\n      * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(RuntimeException.class).\n      *   doThrow(IllegalArgumentException.class)\n      * @return stubber - to select a method for stubbing\n      */\n     Stubber doReturn(Object toBeReturned);\n+\n+    /**\n+     * Use it for stubbing consecutive calls in {@link Mockito#doCallRealMethod()} style.\n+     * <p>\n+     * See javadoc for {@link Mockito#doCallRealMethod()}\n+     *\n+     * @return stubber - to select a method for stubbing\n+     */\n+    Stubber doCallRealMethod();\n }\n--- a/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n+++ b/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n package org.mockito.stubbing.answers;\n \n import java.util.Collection;\n-import java.util.LinkedList;\n-\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.stubbing.Answer;\n \n /**\n  * Returns elements of the collection. Keeps returning the last element forever.\n  *   when(mock.foo()).thenReturn(1, 2, 3);\n  *   //is equivalent to:\n  *   when(mock.foo()).thenReturn(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));\n- * <pre class=\"code\"><code class=\"java\">\n+ * </code></pre>\n+ *\n+ * @deprecated Use {@link org.mockito.AdditionalAnswers#returnsElementsOf}\n  */\n-@SuppressWarnings(\"unchecked\")\n-public class ReturnsElementsOf implements Answer {\n+@Deprecated\n+public class ReturnsElementsOf extends org.mockito.internal.stubbing.answers.ReturnsElementsOf {\n \n-    final LinkedList elements;\n-\n-    public ReturnsElementsOf(Collection elements) {\n-        if (elements == null) {\n-            throw new MockitoException(\"ReturnsElementsOf does not accept null as constructor argument.\\n\" +\n-            \t\t\"Please pass a collection instance\");\n-        }\n-        this.elements = new LinkedList(elements);\n-    }\n-\n-    public Object answer(InvocationOnMock invocation) throws Throwable {\n-        if (elements.size() == 1)\n-            return elements.get(0);\n-        else \n-            return elements.poll();\n+    @Deprecated\n+    public ReturnsElementsOf(Collection<?> elements) {\n+        super(elements);\n     }\n }\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n+package org.mockito.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.Fields;\n+import org.testng.IInvokedMethod;\n+import org.testng.ITestResult;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.mockito.internal.util.reflection.Fields.annotatedBy;\n+\n+public class MockitoAfterTestNGMethod {\n+\n+    public void applyFor(IInvokedMethod method, ITestResult testResult) {\n+        Mockito.validateMockitoUsage();\n+\n+        if (method.isTestMethod()) {\n+            resetMocks(testResult.getInstance());\n+        }\n+    }\n+\n+\n+    private void resetMocks(Object instance) {\n+        Mockito.reset(instanceMocksOf(instance).toArray());\n+    }\n+\n+    private Collection<Object> instanceMocksOf(Object instance) {\n+        return Fields.allDeclaredFieldsOf(instance)\n+                                            .filter(annotatedBy(Mock.class,\n+                                                                Spy.class,\n+                                                                MockitoAnnotations.Mock.class))\n+                                            .notNull()\n+                                            .assignedValues();\n+    }\n+\n+    private Set<Object> instanceMocksIn(Object instance, Class<?> clazz) {\n+        Set<Object> instanceMocks = new HashSet<Object>();\n+        Field[] declaredFields = clazz.getDeclaredFields();\n+        for (Field declaredField : declaredFields) {\n+            if (declaredField.isAnnotationPresent(Mock.class) || declaredField.isAnnotationPresent(Spy.class)) {\n+                declaredField.setAccessible(true);\n+                try {\n+                    Object fieldValue = declaredField.get(instance);\n+                    if (fieldValue != null) {\n+                        instanceMocks.add(fieldValue);\n+                    }\n+                } catch (IllegalAccessException e) {\n+                    throw new MockitoException(\"Could not access field \" + declaredField.getName());\n+                }\n+            }\n+        }\n+        return instanceMocks;\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoBeforeTestNGMethod.java\n+package org.mockito.testng;\n+\n+import org.mockito.Captor;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.configuration.CaptorAnnotationProcessor;\n+import org.mockito.internal.util.reflection.Fields;\n+import org.mockito.internal.util.reflection.InstanceField;\n+import org.testng.IInvokedMethod;\n+import org.testng.ITestResult;\n+\n+import java.util.List;\n+import java.util.WeakHashMap;\n+\n+import static org.mockito.internal.util.reflection.Fields.annotatedBy;\n+\n+public class MockitoBeforeTestNGMethod {\n+\n+    private WeakHashMap<Object, Boolean> initializedInstances = new WeakHashMap<Object, Boolean>();\n+\n+    /**\n+     * Initialize mocks.\n+     *\n+     * @param method Invoked method.\n+     * @param testResult TestNG Test Result\n+     */\n+    public void applyFor(IInvokedMethod method, ITestResult testResult) {\n+        initMocks(testResult);\n+        reinitCaptors(method, testResult);\n+    }\n+\n+    private void reinitCaptors(IInvokedMethod method, ITestResult testResult) {\n+        if (method.isConfigurationMethod()) {\n+            return;\n+        }\n+        initializeCaptors(testResult.getInstance());\n+    }\n+\n+    private void initMocks(ITestResult testResult) {\n+        if (alreadyInitialized(testResult.getInstance())) {\n+            return;\n+        }\n+        MockitoAnnotations.initMocks(testResult.getInstance());\n+        markAsInitialized(testResult.getInstance());\n+    }\n+\n+    private void initializeCaptors(Object instance) {\n+        List<InstanceField> instanceFields = Fields.allDeclaredFieldsOf(instance).filter(annotatedBy(Captor.class)).instanceFields();\n+        for (InstanceField instanceField : instanceFields) {\n+            new CaptorAnnotationProcessor().process(instanceField.annotation(Captor.class), instanceField.jdkField());\n+        }\n+    }\n+\n+    private void markAsInitialized(Object instance) {\n+        initializedInstances.put(instance, true);\n+    }\n+\n+    private boolean alreadyInitialized(Object instance) {\n+        return initializedInstances.containsKey(instance);\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoTestNGListener.java\n+package org.mockito.testng;\n+\n+import org.testng.IInvokedMethod;\n+import org.testng.IInvokedMethodListener;\n+import org.testng.ITestNGListener;\n+import org.testng.ITestResult;\n+import org.testng.annotations.Listeners;\n+\n+/**\n+ * Mockito TestNG Listener, this listener adds the following behavior to your test :\n+ * <ul>\n+ *     <li>\n+ *         Initializes mocks annotated with {@link org.mockito.Mock}, so that <strong>explicit usage of\n+ *         {@link org.mockito.MockitoAnnotations#initMocks(Object)} is not necessary</strong>.\n+ *         <strong>Note :</strong> With TestNG, mocks are initialized before any TestNG method, either a <em>configuration\n+ *         method</em> (&#064;BeforeMethod, &#064;BeforeClass, etc) or a <em>test</em> method, i.e. mocks are initialized\n+ *         once only once for each test instance.\n+ *     </li>\n+ *     <li>\n+ *         As mocks are initialized only once, they will be reset after each <em>test method</em>.\n+ *         See javadoc {@link org.mockito.Mockito#reset(Object[])}\n+ *     </li>\n+ *     <li>\n+ *         Validates framework usage after each test method. See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ *     </li>\n+ * </ul>\n+ *\n+ * <p>\n+ * The listener is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.\n+ * Explicitly validating framework usage is also optional because it is triggered automatically by Mockito every time you use the framework.\n+ * See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ *\n+ * <p>\n+ * Read more about &#064;Mock annotation in javadoc for {@link org.mockito.MockitoAnnotations}\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ * <b>&#064;Listeners(MockitoTestNGListener.class)</b>\n+ * public class ExampleTest {\n+ *\n+ *     &#064;Mock\n+ *     private List list;\n+ *\n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * </code></pre>\n+ */\n+public class MockitoTestNGListener implements IInvokedMethodListener {\n+\n+    private MockitoBeforeTestNGMethod beforeTest = new MockitoBeforeTestNGMethod();\n+    private MockitoAfterTestNGMethod afterTest = new MockitoAfterTestNGMethod();\n+\n+\n+    public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {\n+        if (hasMockitoTestNGListenerInTestHierarchy(testResult.getTestClass().getRealClass())) {\n+            beforeTest.applyFor(method, testResult);\n+        }\n+    }\n+\n+    public void afterInvocation(IInvokedMethod method, ITestResult testResult) {\n+        if (hasMockitoTestNGListenerInTestHierarchy(testResult.getTestClass().getRealClass())) {\n+            afterTest.applyFor(method, testResult);\n+        }\n+    }\n+\n+    protected boolean hasMockitoTestNGListenerInTestHierarchy(Class<?> testClass) {\n+        for (Class<?> clazz = testClass; clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            if (hasMockitoTestNGListener(clazz)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean hasMockitoTestNGListener(Class<?> clazz) {\n+        Listeners listeners = clazz.getAnnotation(Listeners.class);\n+        if (listeners == null) {\n+            return false;\n+        }\n+\n+        for (Class<? extends ITestNGListener> listenerClass : listeners.value()) {\n+            if (listenerClass() == listenerClass) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected Class<MockitoTestNGListener> listenerClass() {\n+        return MockitoTestNGListener.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/AnnotatedFieldsShouldBeInitializedByMockitoTestNGListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class AnnotatedFieldsShouldBeInitializedByMockitoTestNGListenerTest {\n+\n+    @Mock List list;\n+    @Spy HashMap map;\n+    @InjectMocks SomeType someType;\n+    @Captor ArgumentCaptor<List> captor;\n+\n+    @Test\n+    public void ensure_annotated_fields_are_instantiated() throws Exception {\n+        assertThat(list).isNotNull();\n+        assertThat(map).isNotNull();\n+        assertThat(captor).isNotNull();\n+        assertThat(someType).isNotNull();\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/CaptorAnnotatedFieldShouldBeClearedTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@Listeners(MockitoTestNGListener.class)\n+@Test(enabled = false, description = \"not yet ready\")\n+public class CaptorAnnotatedFieldShouldBeClearedTest {\n+\n+    @Captor ArgumentCaptor<String> captor;\n+    @Mock List<String> list;\n+\n+    @Test(enabled = false)\n+    public void first_test_method_that_uses_captor() throws Exception {\n+        list.add(\"a\");\n+        list.add(\"b\");\n+\n+        verify(list, times(2)).add(captor.capture());\n+        assertThat(captor.getAllValues()).containsOnly(\"a\", \"b\");\n+    }\n+\n+    @Test(enabled = false)\n+    public void second_test_method_that_uses_captor() throws Exception {\n+        list.add(\"t\");\n+        list.add(\"u\");\n+\n+        verify(list, times(2)).add(captor.capture());\n+        assertThat(captor.getAllValues()).containsOnly(\"t\", \"u\");\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ConfigurationMethodTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class ConfigurationMethodTest {\n+    @Mock private Map map;\n+\n+    @BeforeMethod\n+    public void some_behavior() {\n+        when(map.get(\"the answer to ...\")).thenReturn(42);\n+    }\n+\n+\n+    @Test\n+    public void mocks_should_stay_configured_with_behavior() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/DontResetMocksIfNoListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+public class DontResetMocksIfNoListenerTest {\n+\n+    @Mock private Map map;\n+\n+    @BeforeMethod\n+    public void init_mocks() {\n+        MockitoAnnotations.initMocks(this);\n+        when(map.get(\"the answer to ...\")).thenReturn(42);\n+    }\n+\n+    @Test\n+    public void mock_behavior_not_resetted_1() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+\n+    @Test\n+    public void mock_behavior_not_resetted_2() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/EnsureMocksAreInitializedBeforeBeforeClassMethodTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Observer;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class EnsureMocksAreInitializedBeforeBeforeClassMethodTest {\n+    \n+    @Mock Observer observer;\n+\n+    @BeforeClass\n+    private void make_sure_mock_is_initialized() {\n+        assertThat(observer).isNotNull();\n+    }\n+\n+    @Test\n+    public void dummy_test_see_BeforeClass_code() throws Exception {\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/InitializeChildTestWhenParentHasListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class InitializeChildTestWhenParentHasListenerTest extends ParentTest {\n+\n+    @Mock Map childMockField;\n+\n+    @Test\n+    public void verify_mocks_are_initialized() throws Exception {\n+        assertThat(childMockField).isNotNull();\n+        assertThat(parentMockField).isNotNull();\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/MockFieldsShouldBeResetBetweenTestMethodsTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class MockFieldsShouldBeResetBetweenTestMethodsTest {\n+    \n+    @Mock List<String> list;\n+    @Spy HashMap hashMap;\n+    @InjectMocks SomeType someType;\n+\n+    @Mock Observable will_be_nulled;\n+\n+    @Test\n+    public void behaviour_A_without_infection_from_behaviour_B() throws Exception {\n+        // verify mock is clean\n+        assertThat(list.get(0)).isNull();\n+        verify(list, never()).add(anyString());\n+\n+        // local behaviour A\n+        given(list.get(0)).willReturn(\"A\");\n+        assertThat(list.get(0)).isEqualTo(\"A\");\n+\n+        list.add(\"something else after A\");\n+    }\n+\n+    @Test\n+    public void behaviour_B_without_infection_from_behaviour_A() throws Exception {\n+        // verify mock is clean\n+        assertThat(list.get(0)).isNull();\n+        verify(list, never()).add(anyString());\n+\n+        // local behaviour A\n+        given(list.get(0)).willReturn(\"B\");\n+        assertThat(list.get(0)).isEqualTo(\"B\");\n+\n+        list.add(\"something else after B\");\n+    }\n+\n+    @Test\n+    public void dont_fail_when_reseting_null_field() throws Exception {\n+        will_be_nulled = null;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ParentTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+\n+import java.util.Map;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public abstract class ParentTest {\n+\n+    @Mock Map parentMockField;\n+\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ResetMocksInParentTestClassTooTest.java\n+package org.mockitousage.testng;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+public class ResetMocksInParentTestClassTooTest extends ParentTest {\n+\n+    @Test\n+    public void interact_with_parent_mock() throws Exception {\n+        parentMockField.get(\"a\");\n+    }\n+\n+    @Test\n+    public void verify__zero_interaction_with_parent_mock() throws Exception {\n+        verifyZeroInteractions(parentMockField);\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/SomeType.java\n+package org.mockitousage.testng;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SomeType {\n+    List list;\n+    Map map;\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/TestWithoutListenerShouldNotInitializeAnnotatedFieldsTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class TestWithoutListenerShouldNotInitializeAnnotatedFieldsTest {\n+\n+    @Mock List list;\n+    @Spy Map map;\n+    @InjectMocks SomeType someType;\n+    @Captor ArgumentCaptor<List> captor;\n+\n+    @Test\n+    public void test_not_annotated_by_MockitoTestNGListener_should_not_touch_annotated_fields() throws Exception {\n+        assertThat(list).isNull();\n+        assertThat(map).isNull();\n+        assertThat(captor).isNull();\n+        assertThat(someType).isNull();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseIncorrectAnnotationUsage.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseIncorrectAnnotationUsage {\n+    @Spy Map spy_cant_initialize_interface_fields;\n+    @Test public void dummy_test_method() throws Exception { }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseIncorrectStubbingSyntax.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.PrintStream;\n+\n+import static org.mockito.Matchers.anySet;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseIncorrectStubbingSyntax {\n+\n+    @Test(expectedExceptions = InvalidUseOfMatchersException.class)\n+    public void incorrect_stubbing_syntax_in_test() throws Exception {\n+        mock(PrintStream.class);\n+        anyString();\n+        anySet();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseWrongStubbingSyntaxInConfigurationMethod.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Matchers.anyString;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseWrongStubbingSyntaxInConfigurationMethod {\n+\n+    @Mock List list;\n+\n+    // should fail\n+    @BeforeMethod public void some_wrong_stubs() {\n+        anyString();\n+    }\n+\n+\n+    @Test\n+    public void here_to_execute_the_config_method() throws Exception {\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/TestNGShouldFailWhenMockitoListenerFailsTest.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockitousage.testng.utils.FailureRecordingListener;\n+import org.testng.TestNG;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.testng.Assert.assertTrue;\n+\n+@Test(\n+        singleThreaded = true,\n+        description = \"Test that failing tests report a Mockito exception\"\n+)\n+public class TestNGShouldFailWhenMockitoListenerFailsTest {\n+\n+    private final FailureRecordingListener failureRecorder = new FailureRecordingListener();\n+\n+    public void report_failure_on_incorrect_annotation_usage() throws Throwable {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectAnnotationUsage.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(MockitoException.class);\n+    }\n+\n+    @Test\n+    public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_test_methods() throws Exception {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectStubbingSyntax.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(InvalidUseOfMatchersException.class);\n+    }\n+\n+\n+    @Test\n+    public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_configuration_methods() throws Exception {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseWrongStubbingSyntaxInConfigurationMethod.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(InvalidUseOfMatchersException.class);\n+    }\n+\n+    @AfterMethod\n+    public void clear_failure_recorder() throws Exception {\n+        failureRecorder.clear();\n+    }\n+\n+\n+    private TestNG new_TestNG_with_failure_recorder_for(Class<?>... testNGClasses) {\n+        TestNG testNG = new TestNG();\n+        testNG.setVerbose(0);\n+        testNG.setUseDefaultListeners(false);\n+        testNG.addListener(failureRecorder);\n+\n+        testNG.setTestClasses(testNGClasses);\n+        return testNG;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/utils/FailureRecordingListener.java\n+package org.mockitousage.testng.utils;\n+\n+import org.testng.IConfigurationListener;\n+import org.testng.ITestContext;\n+import org.testng.ITestListener;\n+import org.testng.ITestResult;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * <strong>Not thread-safe</strong> listener that record only failures, either on the test or on a configuration method.\n+ */\n+public class FailureRecordingListener implements ITestListener, IConfigurationListener {\n+\n+    public List<ITestResult> failedTestResults = new ArrayList<ITestResult>();\n+\n+    public void onTestFailure(ITestResult result) {\n+        failedTestResults.add(result);\n+    }\n+\n+    public void onConfigurationFailure(ITestResult result) {\n+        failedTestResults.add(result);\n+    }\n+\n+    public Throwable lastThrowable() {\n+        ListIterator<ITestResult> iterator = failedTestResults.listIterator(failedTestResults.size());\n+        return iterator.hasPrevious() ? iterator.previous().getThrowable() : null;\n+    }\n+\n+    public void clear() {\n+        failedTestResults.clear();\n+    }\n+\n+    // don't care bellow\n+\n+\n+    public void onConfigurationSuccess(ITestResult itr) { }\n+    public void onConfigurationSkip(ITestResult itr) { }\n+    public void onTestStart(ITestResult result) { }\n+    public void onTestSuccess(ITestResult result) { }\n+    public void onTestSkipped(ITestResult result) { }\n+    public void onTestFailedButWithinSuccessPercentage(ITestResult result) { }\n+    public void onStart(ITestContext context) { }\n+    public void onFinish(ITestContext context) { }\n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.concurrentmockito;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n import org.junit.runner.Result;\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.MockHandlerTest;\n+import org.mockito.internal.MockHandlerImplTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n-import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.invocation.InvocationsFinderTest;\n import org.mockito.internal.matchers.ComparableMatchersTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n import org.mockito.internal.progress.TimesTest;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n-import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.util.collections.ListUtilTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;\n import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n import org.mockitousage.verification.VerificationUsingMatchersTest;\n import org.mockitoutil.TestBase;\n \n+import java.util.LinkedList;\n+import java.util.List;\n+\n public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n     \n     private static class AllTestsRunner extends Thread {\n                     ListUtilTest.class,\n                     MockingProgressImplTest.class,\n                     TimesTest.class,\n-                    MockHandlerTest.class,\n+                    MockHandlerImplTest.class,\n                     AllInvocationsFinderTest.class,\n                     ReturnsEmptyValuesTest.class,\n                     NumberOfInvocationsCheckerTest.class,\n                     ClassImposterizerTest.class,\n                     InvocationMatcherTest.class,\n                     InvocationsFinderTest.class,\n-                    InvocationTest.class,\n+                    InvocationImplTest.class,\n                     MockitoTest.class,\n                     MockUtilTest.class,\n                     ReporterTest.class,\n--- /dev/null\n+++ b/test/org/mockito/MockingDetailsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class MockingDetailsTest {\n+    \n+    private static class TestClass{\n+    }\n+\n+    @Mock TestClass mock1;\n+    @Spy TestClass spy1;\n+    TestClass mock2;\n+    TestClass spy2;\n+    TestClass nonMock;\n+    \n+    @Before\n+    public void setUp(){\n+        initMocks( this );\n+        mock2 = mock( TestClass.class );\n+        spy2 = spy( new TestClass());\n+        nonMock = new TestClass();\n+    }\n+    \n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForAnnotatedMock(){\n+        assertTrue(MockingDetails.of(mock1).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForDirectMock(){\n+        assertTrue(MockingDetails.of(mock2).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForAnnotatedSpy(){\n+        assertTrue(MockingDetails.of(spy1).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForDirectSpy(){\n+\n+        assertTrue(MockingDetails.of(spy2).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsMock_ForNonMock(){\n+        assertFalse(MockingDetails.of(nonMock).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForAnnotatedMock(){\n+        assertFalse(MockingDetails.of(mock1).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForDirectMock(){\n+        assertFalse(MockingDetails.of(mock2).isSpy());\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsSpy_ForAnnotatedSpy(){\n+        assertTrue(MockingDetails.of(spy1).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsSpy_ForDirectSpy(){\n+        assertTrue(MockingDetails.of(spy2).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForNonMock(){\n+        assertFalse(MockingDetails.of(nonMock).isSpy());\n+    }\n+}\n--- a/test/org/mockito/configuration/MockitoConfiguration.java\n+++ b/test/org/mockito/configuration/MockitoConfiguration.java\n     private Answer<Object> overriddenDefaultAnswer = null;\n     private boolean cleansStackTrace;\n     private AnnotationEngine overriddenEngine;\n+    private boolean enableClassCache = true;\n \n     //for testing purposes, allow to override the configuration\n     public void overrideDefaultAnswer(Answer<Object> defaultAnswer) {\n     public void overrideCleansStackTrace(boolean cleansStackTrace) {\n         this.cleansStackTrace = cleansStackTrace;\n     }\n-    \n+\n     //for testing purposes, allow to override the annotation engine\n     public void overrideAnnotationEngine(AnnotationEngine engine) {\n         this.overriddenEngine = engine;\n+    }\n+\n+    //for testing purposes, allow to override the annotation engine\n+    public void overrideEnableClassCache(boolean enableClassCache) {\n+        this.enableClassCache = enableClassCache;\n     }\n \n     @Override\n             return overriddenDefaultAnswer;\n         }\n     }\n-    \n+\n     @Override\n     public AnnotationEngine getAnnotationEngine() {\n         if (this.overriddenEngine != null) {\n     public boolean cleansStackTrace() {\n         return cleansStackTrace;\n     }\n+\n+    @Override\n+    public boolean enableClassCache() {\n+        return enableClassCache;\n+    }\n }\n--- a/test/org/mockito/exceptions/ReporterTest.java\n+++ b/test/org/mockito/exceptions/ReporterTest.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.reporting.*;\n import org.mockitoutil.TestBase;\n \n public class ReporterTest extends TestBase {\n \n     @Test(expected=TooLittleActualInvocations.class)\n     public void shouldLetPassingNullLastActualStackTrace() throws Exception {\n-        new Reporter().tooLittleActualInvocations(new Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);\n+        new Reporter().tooLittleActualInvocations(new org.mockito.internal.reporting.Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);\n     }\n     \n     @Test(expected=MockitoException.class)\n--- a/test/org/mockito/internal/AllInvocationsFinderTest.java\n+++ b/test/org/mockito/internal/AllInvocationsFinderTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockito/internal/InOrderImplTest.java\n+++ b/test/org/mockito/internal/InOrderImplTest.java\n \n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n+++ b/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n import org.mockito.Spy;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.invocation.Invocation;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.listeners.MethodInvocationReport;\n import org.mockito.runners.MockitoJUnitRunner;\n     @Spy private CustomListener customListener;\n \n     @Mock private Invocation invocation;\n-    @Mock private MockHandler mockHandler;\n+    @Mock private MockHandlerImpl mockHandler;\n \n     private InvocationNotifierHandler notifier;\n \n--- /dev/null\n+++ b/test/org/mockito/internal/MockHandlerImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.Arrays;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings({ \"unchecked\", \"serial\" })\n+public class MockHandlerImplTest extends TestBase {\n+\n+\tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n+\tprivate Invocation invocation = mock(InvocationImpl.class);\n+\n+\n+\t@Test\n+\tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+\t\t// given\n+\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());\n+\t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+\t\thandler.matchersBinder = new MatchersBinder() {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\t\tthrow new InvalidUseOfMatchersException();\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\thandler.handle(invocation);\n+\n+\t\t\t// then\n+\t\t\tfail();\n+\t\t} catch (InvalidUseOfMatchersException e) {\n+\t\t}\n+\n+\t\tassertNull(handler.mockingProgress.pullVerificationMode());\n+\t}\n+\n+\n+\n+\n+\t@Test(expected = MockitoException.class)\n+\tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n+\t\t// given\n+\t\tInvocationListener throwingListener = mock(InvocationListener.class);\n+\t\tdoThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));\n+\t\tMockHandlerImpl<?> handler = createCorrectlyStubbedHandler(throwingListener);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\t}\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n+\t\tMockHandlerImpl<?> handler = createHandlerWithListeners(throwingListener);\n+\t\tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+\t\treturn handler;\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandlerImpl<?> handler) {\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);\n+\t}\n+\n+\n+\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {\n+\t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);\n+\t}\n+\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createHandlerWithListeners(InvocationListener... listener) {\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));\n+\t\thandler.matchersBinder = mock(MatchersBinder.class);\n+\t\tgiven(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));\n+\t\treturn handler;\n+\t}\n+}\n--- a/test/org/mockito/internal/configuration/ReadingConfigurationFromClasspathTest.java\n+++ b/test/org/mockito/internal/configuration/ReadingConfigurationFromClasspathTest.java\n  */\n package org.mockito.internal.configuration;\n \n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.Arrays;\n+import java.util.Collections;\n import static org.mockito.Mockito.*;\n \n import org.junit.Test;\n import org.mockitoutil.TestBase;\n \n public class ReadingConfigurationFromClasspathTest extends TestBase {\n-    \n+\n     @Test\n     public void shouldReadConfigurationClassFromClassPath() {\n         ConfigurationAccess.getConfig().overrideDefaultAnswer(new Answer<Object>() {\n                 return \"foo\";\n             }});\n \n-        IMethods mock = mock(IMethods.class); \n+        IMethods mock = mock(IMethods.class);\n         assertEquals(\"foo\", mock.simpleMethod());\n     }\n+\n+    @Test\n+    public void readerToLinesEmptyString() throws IOException {\n+        assertEquals(Collections.emptyList(), ClassPathLoader.readerToLines(new StringReader(\"\")));\n+    }\n+\n+    @Test\n+    public void readerToLinesNoLineBreaks() throws IOException {\n+        assertEquals(Arrays.asList(\"a\"), ClassPathLoader.readerToLines(new StringReader(\"a\")));\n+    }\n+\n+    @Test\n+    public void readerToLinesWithLineBreaks() throws IOException {\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"),\n+                ClassPathLoader.readerToLines(new StringReader(\"a\\nb\\nc\")));\n+    }\n+\n+    @Test\n+    public void readerToLinesWithEmptyLines() throws IOException {\n+        assertEquals(Arrays.asList(\"a\", \"\", \"c\"),\n+                ClassPathLoader.readerToLines(new StringReader(\"a\\n\\nc\")));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceEmptyInput() throws IOException {\n+        assertEquals(\"\", ClassPathLoader.stripCommentAndWhitespace(\"\"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceWhitespaceInput() throws IOException {\n+        assertEquals(\"\", ClassPathLoader.stripCommentAndWhitespace(\" \"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceCommentInInput() throws IOException {\n+        assertEquals(\"a\", ClassPathLoader.stripCommentAndWhitespace(\"a#b\"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceMultipleHashes() throws IOException {\n+        assertEquals(\"a\", ClassPathLoader.stripCommentAndWhitespace(\"a#b#c\"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceWithWhitespaceAndComments() throws IOException {\n+        assertEquals(\"a\", ClassPathLoader.stripCommentAndWhitespace(\" a #b\"));\n+    }\n }\n--- a/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.MockitoInvocationHandler;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.MockitoMethod;\n import org.mockito.internal.invocation.SerializableMethod;\n \n public class MethodInterceptorFilterTest extends TestBase {\n \n-    MockitoInvocationHandler handler = Mockito.mock(MockitoInvocationHandler.class);\n+    InternalMockHandler handler = Mockito.mock(InternalMockHandler.class);\n     MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n \n     @Before\n \n         //then\n         assertTrue((Integer) ret != 0);\n-        Mockito.verify(handler, never()).handle(any(Invocation.class));\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n     }\n \n     @Test\n \n         //then\n         assertTrue((Boolean) ret);\n-        Mockito.verify(handler, never()).handle(any(Invocation.class));\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n     }\n     \n     //TODO: move to separate factory\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n         mockSettingsImpl.extraInterfaces(List.class, Set.class);\n         \n         //then\n-        assertEquals(List.class, mockSettingsImpl.getExtraInterfaces()[0]);\n-        assertEquals(Set.class, mockSettingsImpl.getExtraInterfaces()[1]);\n+        assertEquals(2, mockSettingsImpl.getExtraInterfaces().size());\n+        assertTrue(mockSettingsImpl.getExtraInterfaces().contains(List.class));\n+        assertTrue(mockSettingsImpl.getExtraInterfaces().contains(Set.class));\n     }\n \n     @Test\n             Assertions.assertThat(e.getMessage()).contains(\"does not accept null\");\n         }\n     }\n-\n-    private InvocationListener getListener(MockSettingsImpl settings) {\n-    \treturn settings.getInvocationListeners().iterator().next();\n-    }\n-    \n }\n--- a/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n+++ b/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n \n import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.ExposedInvocation;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n                 return invocation;\n             }});\n         \n-        Invocation i = (Invocation) mock.objectReturningMethodNoArgs();\n+        InvocationImpl i = (InvocationImpl) mock.objectReturningMethodNoArgs();\n         return new ExposedInvocation(i).getMethodProxy();\n     }\n }\n--- a/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n+++ b/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.StubInfo;\n+import org.mockito.internal.invocation.StubInfoImpl;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n \n     private ByteArrayOutputStream output;\n     private Invocation invocation = new InvocationBuilder().toInvocation();\n-    private PrintableInvocation stubbedInvocation = new InvocationBuilder().toInvocation();\n+    private DescribedInvocation stubbedInvocation = new InvocationBuilder().toInvocation();\n \n     @Before\n     public void init_Listener() throws Exception {\n \n     @Test\n     public void should_print_stubbed_info_if_availbable() throws Exception {\n-        invocation.markStubbed(new StubInfo(stubbedInvocation));\n+        invocation.markStubbed(new StubInfoImpl(stubbedInvocation));\n \n         listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"whatever\"));\n \n--- a/test/org/mockito/internal/debugging/WarningsFinderTest.java\n+++ b/test/org/mockito/internal/debugging/WarningsFinderTest.java\n \n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n+++ b/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n import java.util.List;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n--- a/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n+++ b/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n  */\n package org.mockito.internal.invocation;\n \n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n import org.junit.Test;\n import org.mockito.internal.matchers.*;\n--- a/test/org/mockito/internal/invocation/ExposedInvocation.java\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n \n     private final MockitoMethodProxy methodProxy;\n \n-    public ExposedInvocation(Invocation toBeExposed) {\n+    public ExposedInvocation(InvocationImpl toBeExposed) {\n          methodProxy = ((HasCGLIBMethodProxy) toBeExposed.realMethod).getMethodProxy();\n     }\n \n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n package org.mockito.internal.invocation;\n \n import org.mockito.Mockito;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n \n import java.lang.reflect.Method;\n import java.util.LinkedList;\n import java.util.List;\n+\n+import static java.util.Arrays.asList;\n \n /**\n  * Build an invocation.\n     private Object mock = Mockito.mock(IMethods.class);\n     private Method method;\n     private boolean verified;\n+    private List<Class<?>> argTypes;\n \n     /**\n      * Build the invocation\n      */\n     public Invocation toInvocation() {\n         if (method == null) {\n-            List<Class> argTypes = new LinkedList<Class>();\n-            for (Object arg : args) {\n-                if (arg == null) {\n-                    argTypes.add(Object.class);\n-                } else {\n-                    argTypes.add(arg.getClass());\n+            if (argTypes == null) {\n+                argTypes = new LinkedList<Class<?>>();\n+                for (Object arg : args) {\n+                    if (arg == null) {\n+                        argTypes.add(Object.class);\n+                    } else {\n+                        argTypes.add(arg.getClass());\n+                    }\n                 }\n             }\n-            \n+\n             try {\n                 method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n             } catch (Exception e) {\n             }\n         }\n         \n-        Invocation i = new Invocation(mock, new SerializableMethod(method), args, sequenceNumber, null);\n+        Invocation i = new InvocationImpl(mock, new SerializableMethod(method), args, sequenceNumber, null);\n         if (verified) {\n             i.markVerified();\n         }\n     public InvocationBuilder differentMethod() {\n         return this.method(\"differentMethod\");\n     }\n+\n+    public InvocationBuilder argTypes(Class<?>... argTypes) {\n+        this.argTypes = asList(argTypes);\n+        return this;\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.invocation;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.invocation.Invocation;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@SuppressWarnings({\"unchecked\"})\n+public class InvocationImplTest extends TestBase {\n+\n+    private Invocation invocation;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        invocation = new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+    }\n+\n+    @Test\n+    public void shouldKnowIfIsEqualTo() {\n+        Invocation equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+        Invocation nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n+        Invocation withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n+\n+        assertFalse(invocation.equals(null));\n+        assertFalse(invocation.equals(\"\"));\n+        assertTrue(invocation.equals(equal));\n+        assertFalse(invocation.equals(nonEqual));\n+        assertTrue(invocation.equals(withNewStringInstance));\n+    }\n+    \n+    @Test\n+    public void shouldEqualToNotConsiderSequenceNumber() {\n+        Invocation equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        \n+        assertTrue(invocation.equals(equal));\n+        assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());\n+    }\n+    \n+    @Test\n+    public void shouldBeACitizenOfHashes() {\n+        Map map = new HashMap();\n+        map.put(invocation, \"one\");\n+        assertEquals(\"one\", map.get(invocation));\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodName() {\n+        invocation = new InvocationBuilder().toInvocation();\n+        assertEquals(\"iMethods.simpleMethod();\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodArgs() {\n+        invocation = new InvocationBuilder().args(\"foo\").toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(\\\"foo\\\");\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodIntegerArgAndString() {\n+        invocation = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(\\\"foo\\\", 1);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintNull() {\n+        invocation = new InvocationBuilder().args((String) null).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(null);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintArray() {\n+        invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] { 1, 2, 3 }).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"oneArray([1, 2, 3]);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintNullIfArrayIsNull() throws Exception {\n+        Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n+        invocation = new InvocationBuilder().method(m).args((Object) null).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"oneArray(null);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintArgumentsInMultilinesWhenGetsTooBig() {\n+        invocation = new InvocationBuilder().args(\"veeeeery long string that makes it ugly in one line\", 1).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\n+                \"simpleMethod(\" +\n+                        \"\\n\" +\n+                        \"    \\\"veeeeery long string that makes it ugly in one line\\\",\" +\n+                        \"\\n\" +\n+                        \"    1\" +\n+                        \"\\n\" +\n+                        \");\"));\n+    }\n+    \n+    @Test\n+    public void shouldTransformArgumentsToMatchers() throws Exception {\n+        Invocation i = new InvocationBuilder().args(\"foo\", new String[]{\"bar\"}).toInvocation();\n+        List matchers = ArgumentsProcessor.argumentsToMatchers(i.getArguments());\n+\n+        assertEquals(2, matchers.size());\n+        assertEquals(Equals.class, matchers.get(0).getClass());\n+        assertEquals(ArrayEquals.class, matchers.get(1).getClass());\n+    }\n+    \n+    class Foo {\n+        public String bark() {\n+            return \"woof\";\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToCallRealMethod() throws Throwable {\n+        //when\n+        Invocation invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n+            public Object invoke(Object target, Object[] arguments) throws Throwable {\n+                return new Foo().bark();\n+            }});\n+        //then\n+        assertEquals(\"woof\", invocation.callRealMethod());\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n+        //given\n+        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n+\n+        try {\n+            //when\n+            invocationOnInterface.callRealMethod();\n+            //then\n+            fail();\n+        } catch(MockitoException e) {}\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n import org.junit.Test;\n import org.mockito.internal.util.ObjectBox;\n import org.mockito.internal.verification.InOrderContextImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class InvocationMarkerTest extends TestBase {\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.matchers.NotNull;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n-        PrintingFriendlyInvocation withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n-        PrintingFriendlyInvocation withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n+        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n+        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n \n         assertFalse(withOneArg.equals(null));\n         assertFalse(withOneArg.equals(withTwoArgs));\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.debugging.Location;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n         mockingProgress.setListener(listener);\n \n         //when\n-        mockingProgress.mockingStarted(\"foo\", List.class, new MockSettingsImpl());\n+        mockingProgress.mockingStarted(\"foo\", List.class);\n \n         //then\n-        verify(listener).mockingStarted(eq(\"foo\"), eq(List.class), (MockSettingsImpl) notNull());\n+        verify(listener).mockingStarted(eq(\"foo\"), eq(List.class));\n     }\n \n     @Test\n         mockingProgress.setListener(null);\n \n         //then no exception is thrown:\n-        mockingProgress.mockingStarted(null, null, null);\n+        mockingProgress.mockingStarted(null, null);\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/reporting/PluralizerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.reporting;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class PluralizerTest extends TestBase {\n+\n+    @Test\n+    public void shouldGetPluralizedNumber() {\n+        new Pluralizer();\n+        assertEquals(\"0 times\", Pluralizer.pluralize(0));\n+        assertEquals(\"1 time\", Pluralizer.pluralize(1));\n+        assertEquals(\"2 times\", Pluralizer.pluralize(2));\n+        assertEquals(\"20 times\", Pluralizer.pluralize(20));\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n package org.mockito.internal.stubbing;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.stubbing.answers.Returns;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n+import org.mockito.invocation.Invocation;\n \n import java.util.LinkedList;\n \n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.MockingProgressImpl;\n import org.mockito.internal.stubbing.answers.Returns;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class MockitoStubberTest extends TestBase{\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n  */\n package org.mockito.internal.stubbing.answers;\n \n-import static org.mockito.Mockito.*;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n+import org.mockito.internal.MockitoCore;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n \n import java.io.IOException;\n import java.nio.charset.CharacterCodingException;\n import java.util.ArrayList;\n \n-import org.junit.Test;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockitoutil.TestBase;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n \n @SuppressWarnings(\"unchecked\")\n-public class AnswersValidatorTest extends TestBase {\n+public class AnswersValidatorTest {\n \n     private AnswersValidator validator = new AnswersValidator();\n     private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n \n     @Test\n-    public void shouldValidateNullThrowable() throws Throwable {\n+    public void should_validate_null_throwable() throws Throwable {\n         try {\n-            validator.validate(new ThrowsException(null), null);\n+            validator.validate(new ThrowsException(null), new InvocationBuilder().toInvocation());\n             fail();\n         } catch (MockitoException e) {}\n     }\n \n     @Test\n-    public void shouldPassProperCheckedException() throws Throwable {\n+    public void should_pass_proper_checked_exception() throws Throwable {\n         validator.validate(new ThrowsException(new CharacterCodingException()), invocation);\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailInvalidCheckedException() throws Throwable {\n+    public void should_fail_invalid_checked_exception() throws Throwable {\n         validator.validate(new ThrowsException(new IOException()), invocation);\n     }\n     \n     @Test\n-    public void shouldPassRuntimeExceptions() throws Throwable {\n+    public void should_pass_RuntimeExceptions() throws Throwable {\n         validator.validate(new ThrowsException(new Error()), invocation);\n         validator.validate(new ThrowsException(new RuntimeException()), invocation);\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailWhenReturnValueIsSetForVoidMethod() throws Throwable {\n+    public void should_fail_when_return_Value_is_set_for_void_method() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailWhenNonVoidMethodDoesNothing() throws Throwable {\n+    public void should_fail_when_non_void_method_does_nothing() throws Throwable {\n         validator.validate(new DoesNothing(), new InvocationBuilder().simpleMethod().toInvocation());\n     }\n     \n     @Test\n-    public void shouldAllowVoidReturnForVoidMethod() throws Throwable {\n+    public void should_allow_void_return_for_void_method() throws Throwable {\n         validator.validate(new DoesNothing(), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     }\n     \n     @Test\n-    public void shouldAllowCorrectTypeOfReturnValue() throws Throwable {\n+    public void should_allow_correct_type_of_return_value() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().simpleMethod().toInvocation());\n         validator.validate(new Returns(false), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n-        validator.validate(new Returns(new Boolean(true)), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n+        validator.validate(new Returns(Boolean.TRUE), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n         validator.validate(new Returns(1), new InvocationBuilder().method(\"integerReturningMethod\").toInvocation());\n         validator.validate(new Returns(1L), new InvocationBuilder().method(\"longReturningMethod\").toInvocation());\n         validator.validate(new Returns(1L), new InvocationBuilder().method(\"longObjectReturningMethod\").toInvocation());\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailOnReturnTypeMismatch() throws Throwable {\n+    public void should_fail_on_return_type_mismatch() throws Throwable {\n         validator.validate(new Returns(\"String\"), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailOnWrongPrimitive() throws Throwable {\n+    public void should_fail_on_wrong_primitive() throws Throwable {\n         validator.validate(new Returns(1), new InvocationBuilder().method(\"doubleReturningMethod\").toInvocation());\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailOnNullWithPrimitive() throws Throwable {\n+    public void should_fail_on_null_with_primitive() throws Throwable {\n         validator.validate(new Returns(null), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n     }\n     \n     @Test\n-    public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\n+    public void should_fail_when_calling_real_method_on_interface() throws Throwable {\n         //given\n-        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        Invocation invocationOnInterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n         try {\n             //when\n-            validator.validate(new CallsRealMethods(), inovcationOnIterface);\n+            validator.validate(new CallsRealMethods(), invocationOnInterface);\n             //then\n             fail();\n         } catch (MockitoException e) {}\n     }\n             \n     @Test\n-    public void shouldBeOKWhenCallingRealMethodOnConcreteClass() throws Throwable {\n+    public void should_be_OK_when_calling_real_method_on_concrete_class() throws Throwable {\n         //given\n         ArrayList mock = mock(ArrayList.class);\n         mock.clear();\n-        Invocation invocationOnClass = getLastInvocation();\n+        Invocation invocationOnClass = new MockitoCore().getLastInvocation();\n         //when\n         validator.validate(new CallsRealMethods(), invocationOnClass);\n         //then no exception is thrown\n     }\n+\n+    @Test\n+    public void should_allow_possible_argument_types() throws Exception {\n+        validator.validate(\n+                new ReturnsArgumentAt(0),\n+                new InvocationBuilder().method(\"intArgumentReturningInt\").argTypes(int.class).arg(1000).toInvocation()\n+        );\n+        validator.validate(\n+                new ReturnsArgumentAt(0),\n+                new InvocationBuilder().method(\"toString\").argTypes(String.class).arg(\"whatever\").toInvocation()\n+        );\n+        validator.validate(\n+                new ReturnsArgumentAt(2),\n+                new InvocationBuilder().method(\"varargsObject\")\n+                                       .argTypes(int.class, Object[].class)\n+                                       .args(1000, \"Object\", \"Object\")\n+                                       .toInvocation()\n+        );\n+        validator.validate(\n+                new ReturnsArgumentAt(1),\n+                new InvocationBuilder().method(\"threeArgumentMethod\")\n+                                       .argTypes(int.class, Object.class, String.class)\n+                                       .args(1000, \"Object\", \"String\")\n+                                       .toInvocation()\n+        );\n+    }\n+\n+    @Test\n+    public void should_fail_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {\n+        try {\n+            validator.validate(new ReturnsArgumentAt(30), new InvocationBuilder().method(\"oneArg\").arg(\"A\").toInvocation());\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"invalid argument index\")\n+                    .containsIgnoringCase(\"iMethods.oneArg\")\n+                    .containsIgnoringCase(\"[0] String\")\n+                    .containsIgnoringCase(\"position\")\n+                    .contains(\"30\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation() throws Throwable {\n+        try {\n+            validator.validate(\n+                    new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT),\n+                    new InvocationBuilder().simpleMethod().toInvocation()\n+            );\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"invalid argument index\")\n+                    .containsIgnoringCase(\"iMethods.simpleMethod\")\n+                    .containsIgnoringCase(\"no arguments\")\n+                    .containsIgnoringCase(\"last parameter wanted\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type() throws Throwable {\n+        try {\n+            validator.validate(\n+                    new ReturnsArgumentAt(2),\n+                    new InvocationBuilder().method(\"varargsReturningString\")\n+                                           .argTypes(Object[].class)\n+                                           .args(\"anyString\", new Object(), \"anyString\")\n+                                           .toInvocation()\n+            );\n+            fail();\n+        } catch (WrongTypeOfReturnValue e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"argument of type\")\n+                    .containsIgnoringCase(\"Object\")\n+                    .containsIgnoringCase(\"varargsReturningString\")\n+                    .containsIgnoringCase(\"should return\")\n+                    .containsIgnoringCase(\"String\")\n+                    .containsIgnoringCase(\"possible argument indexes\");\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n+\n+import java.nio.charset.CharacterCodingException;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * by Szczepan Faber, created at: 3/31/12\n+ */\n+public class MethodInfoTest {\n+\n+    @Test\n+    public void shouldKnowValidThrowables() throws Exception {\n+        //when\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        MethodInfo info = new MethodInfo(invocation);\n+\n+        //then\n+        assertFalse(info.isValidException(new Exception()));\n+        assertTrue(info.isValidException(new CharacterCodingException()));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.junit.Test;\n+import org.mockito.internal.stubbing.answers.ReturnsArgumentAt;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockitousage.IMethods;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class ReturnsArgumentAtTest {\n+\t@Test\n+\tpublic void should_be_able_to_return_the_first_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(0).answer(invocationWith(\"A\", \"B\"))).isEqualTo(\"A\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_second_parameter()\n+\t\t\tthrows Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(1).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"B\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_last_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(-1).answer(invocationWith(\"A\"))).isEqualTo(\"A\");\n+\t\tassertThat(new ReturnsArgumentAt(-1).answer(invocationWith(\"A\", \"B\"))).isEqualTo(\"B\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_specified_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(0).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"A\");\n+\t\tassertThat(new ReturnsArgumentAt(1).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"B\");\n+\t\tassertThat(new ReturnsArgumentAt(2).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"C\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time() throws Throwable {\n+        try {\n+            new ReturnsArgumentAt(-30);\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"argument index\")\n+                    .containsIgnoringCase(\"positive number\")\n+                    .contains(\"1\")\n+                    .containsIgnoringCase(\"last argument\");\n+        }\n+    }\n+\n+\tprivate static InvocationOnMock invocationWith(final String... parameters) {\n+        return new InvocationOnMock() {\n+\n+            public Object getMock() {\n+                return null;\n+            }\n+\n+            public Method getMethod() {\n+                try {\n+                    return IMethods.class.getDeclaredMethod(\"varargsReturningString\", Object[].class);\n+                } catch (NoSuchMethodException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            public Object[] getArguments() {\n+                return parameters;\n+            }\n+\n+            public Object callRealMethod() throws Throwable {\n+                return null;\n+            }\n+        };\n+    }\n+\n+}\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n import java.util.*;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n import static org.mockito.Mockito.mock;\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n package org.mockito.internal.util;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import static java.util.Arrays.asList;\n \n @SuppressWarnings(\"unchecked\")\n public class MockCreationValidatorTest extends TestBase {\n     public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n         try {\n             //when\n-            validator.validateExtraInterfaces(IMethods.class, new Class<?>[] {IMethods.class});\n+            validator.validateExtraInterfaces(IMethods.class, (Collection) asList(IMethods.class));\n             fail();\n         } catch (MockitoException e) {\n             //then\n--- /dev/null\n+++ b/test/org/mockito/internal/util/MockNameImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class MockNameImplTest extends TestBase {\n+\n+    @Test\n+    public void shouldProvideTheNameForClass() throws Exception {\n+        //when\n+        String name = new MockNameImpl(null, SomeClass.class).toString();\n+        //then\n+        assertEquals(\"someClass\", name);\n+    }\n+\n+    @Test\n+    public void shouldProvideTheNameForAnonymousClass() throws Exception {\n+        //given\n+        SomeInterface anonymousInstance = new SomeInterface() {};\n+        //when\n+        String name = new MockNameImpl(null, anonymousInstance.getClass()).toString();\n+        //then\n+        assertEquals(\"someInterface\", name);\n+    }\n+\n+    @Test\n+    public void shouldProvideTheGivenName() throws Exception {\n+        //when\n+        String name = new MockNameImpl(\"The Hulk\", SomeClass.class).toString();\n+        //then\n+        assertEquals(\"The Hulk\", name);\n+    }\n+\n+    private class SomeClass {}\n+    private class SomeInterface {}\n+}\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n \n package org.mockito.internal.util;\n \n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.Enhancer;\n import org.mockitoutil.TestBase;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.Set;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n     \n-    public class CreationValidatorStub extends MockCreationValidator {\n-        private boolean extraInterfacesValidated;\n-        private boolean typeValidated;\n-        public void validateType(Class classToMock) {\n-            typeValidated = true;\n-        }\n-        public void validateExtraInterfaces(Class classToMock, Class ... interfaces) {\n-            extraInterfacesValidated = true;\n-        }\n-    }\n+    private MockUtil mockUtil = new MockUtil();\n \n-    private CreationValidatorStub creationValidator = new CreationValidatorStub();\n-    private MockUtil mockUtil = new MockUtil(creationValidator);\n-\n-    @Test \n-    public void shouldValidate() {\n-        //given\n-        assertFalse(creationValidator.extraInterfacesValidated);\n-        assertFalse(creationValidator.typeValidated);\n-\n-        //when\n-        mockUtil.createMock(IMethods.class, new MockSettingsImpl());\n-        \n-        //then\n-        assertTrue(creationValidator.extraInterfacesValidated);\n-        assertTrue(creationValidator.typeValidated);\n-    }\n-\n-    @Test \n+    @Test\n     public void shouldGetHandler() {\n         List mock = Mockito.mock(List.class);\n         assertNotNull(mockUtil.getMockHandler(mock));\n         assertFalse(mockUtil.isMock(\"i mock a mock\"));\n         assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n     }\n+\n+    @Test\n+    public void shouldValidateSpy() {\n+        assertFalse(mockUtil.isSpy(\"i mock a mock\"));\n+        assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));\n+        assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));\n+    }\n+\n+    @Test\n+    public void should_redefine_MockName_if_default() {\n+        List mock = Mockito.mock(List.class);\n+        mockUtil.maybeRedefineMockName(mock, \"newName\");\n+\n+        Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"newName\");\n+    }\n+\n+    @Test\n+    public void should_not_redefine_MockName_if_default() {\n+        List mock = Mockito.mock(List.class, \"original\");\n+        mockUtil.maybeRedefineMockName(mock, \"newName\");\n+\n+        Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"original\");\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Observer;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+public class HashCodeAndEqualsSafeSetTest {\n+\n+    @Test\n+    public void can_add_mock_that_have_failing_hashCode_method() throws Exception {\n+        new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));\n+    }\n+\n+    @Test\n+    public void mock_with_failing_hashCode_method_can_be_added() throws Exception {\n+        new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));\n+    }\n+\n+    @Test\n+    public void mock_with_failing_equals_method_can_be_used() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();\n+        UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);\n+        mocks.add(mock);\n+\n+        assertThat(mocks.contains(mock)).isTrue();\n+        assertThat(mocks.contains(mock(UnmockableHashCodeAndEquals.class))).isFalse();\n+    }\n+\n+    @Test\n+    public void can_remove() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();\n+        UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);\n+        mocks.add(mock);\n+        mocks.remove(mock);\n+\n+        assertThat(mocks.isEmpty()).isTrue();\n+    }\n+\n+\n+    @Test\n+    public void can_add_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+\n+        assertThat(workingSet.containsAll(mocks)).isTrue();\n+    }\n+\n+    @Test\n+    public void can_retain_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+        workingSet.add(mock(List.class));\n+\n+        assertThat(workingSet.retainAll(mocks)).isTrue();\n+        assertThat(workingSet.containsAll(mocks)).isTrue();\n+    }\n+\n+    @Test\n+    public void can_remove_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+        workingSet.add(mock(List.class));\n+\n+        assertThat(workingSet.removeAll(mocks)).isTrue();\n+        assertThat(workingSet.containsAll(mocks)).isFalse();\n+    }\n+\n+    @Test\n+    public void can_iterate() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        LinkedList<Object> accumulator = new LinkedList<Object>();\n+        for (Object mock : mocks) {\n+            accumulator.add(mock);\n+        }\n+        assertThat(accumulator).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void toArray_just_work() throws Exception {\n+        UnmockableHashCodeAndEquals mock1 = mock(UnmockableHashCodeAndEquals.class);\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1);\n+\n+        assertThat(mocks.toArray()[0]).isSameAs(mock1);\n+\n+        assertThat(mocks.toArray(new UnmockableHashCodeAndEquals[0])[0]).isSameAs(mock1);\n+    }\n+\n+    private static class UnmockableHashCodeAndEquals {\n+        @Override public final int hashCode() {\n+            throw new NullPointerException(\"I'm failing on hashCode and I don't care\");\n+        }\n+\n+        @Override public final boolean equals(Object obj) {\n+            throw new NullPointerException(\"I'm failing on equals and I don't care\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/IdentitySetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+public class IdentitySetTest {\n+    \n+    IdentitySet set = new IdentitySet();\n+    \n+    @Test\n+    public void shouldWork() throws Exception {\n+        //when\n+        Object o = new Object();\n+        set.add(o);\n+\n+        //then\n+        assertTrue(set.contains(o));\n+        assertFalse(set.contains(new Object()));\n+    }\n+    \n+    class Fake {\n+        @Override\n+        public boolean equals(Object obj) {\n+            return true;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldWorkEvenIfEqualsTheSame() throws Exception {\n+        //given\n+        assertEquals(new Fake(), new Fake());\n+        Fake fake = new Fake();\n+        \n+        //when\n+        set.add(fake);\n+\n+        //then\n+        assertTrue(set.contains(fake));\n+        assertFalse(set.contains(new Fake()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/ListUtilTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.mockitoutil.ExtraMatchers.hasExactlyInOrder;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ListUtilTest extends TestBase {\n+\n+    @Test\n+    public void shouldFilterList() throws Exception {\n+        List list = asList(\"one\", \"x\", \"two\", \"x\", \"three\");\n+        List filtered = ListUtil.filter(list, new Filter() {\n+            public boolean isOut(Object object) {\n+                return object == \"x\";\n+            }\n+        });\n+        \n+        assertThat(filtered, hasExactlyInOrder(\"one\", \"two\", \"three\"));\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyIfEmptyListGiven() throws Exception {\n+        List list = new LinkedList();\n+        List filtered = ListUtil.filter(list, null);\n+        assertTrue(filtered.isEmpty());\n+    }\n+}\n--- a/test/org/mockito/internal/util/reflection/BeanPropertySetterTest.java\n+++ b/test/org/mockito/internal/util/reflection/BeanPropertySetterTest.java\n import java.io.File;\n import java.io.FileOutputStream;\n import java.lang.reflect.Field;\n+import java.util.UUID;\n \n import static org.junit.Assert.*;\n \n public class BeanPropertySetterTest {\n \n     @Test\n-    public void shouldUseTheSetterOnTheTargetWithTheFieldType() throws Exception {\n+    public void use_the_correct_setter_on_the_target() throws Exception {\n+        // given\n         SomeBean someBean = new SomeBean();\n         Field theField = someBean.getClass().getDeclaredField(\"theField\");\n-\n         File valueToInject = new File(\"path\");\n \n+        // when\n         boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);\n \n+        // then\n         assertTrue(injected);\n-        assertTrue(someBean.setTheFieldWasUsed);\n+        assertTrue(someBean.theFieldSetterWasUsed);\n         assertSame(valueToInject, someBean.getTheField());\n     }\n \n     @Test\n-    public void shouldNotFailIfBeanHasOnlyASetter() throws Exception {\n-        SomeBeanWithJustASetter someBean = new SomeBeanWithJustASetter();\n-        Field theField = someBean.getClass().getDeclaredField(\"theField\");\n+    public void use_the_setter_on_the_target_when_field_name_begins_by_at_least_2_caps() throws Exception {\n+        // given\n+        BeanWithWeirdFields someBean = new BeanWithWeirdFields();\n+        Field theField = someBean.getClass().getDeclaredField(\"UUID\");\n+        UUID valueToInject = new UUID(0L, 0L);\n \n-        File valueToInject = new File(\"path\");\n-\n+        // when\n         boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);\n \n+        // then\n         assertTrue(injected);\n-        assertTrue(someBean.setTheFieldWasUsed);\n+        assertTrue(someBean.theFieldSetterWasUSed);\n+        assertSame(valueToInject, someBean.UUID);\n     }\n \n     @Test\n-    public void shouldFailIfMatchingSetterCannotBeFoundAndIfReportFailureTrue() throws Exception {\n+    public void should_not_fail_if_bean_class_declares_only_the_setter_for_the_property() throws Exception {\n+        // given\n+        SomeBeanWithJustASetter someBean = new SomeBeanWithJustASetter();\n+        Field theField = someBean.getClass().getDeclaredField(\"theField\");\n+        File valueToInject = new File(\"path\");\n+\n+        // when\n+        boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);\n+\n+        // then\n+        assertTrue(injected);\n+        assertTrue(someBean.theFieldSetterWasUsed);\n+    }\n+\n+    @Test\n+    public void should_fail_if_matching_setter_cannot_be_found_and_if_report_failure_is_true() throws Exception {\n+        // given\n         SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();\n         Field theField = bean.getClass().getDeclaredField(\"theField\");\n-\n         File valueToInject = new File(\"path\");\n \n         try {\n+            // when\n             new BeanPropertySetter(bean, theField, true).set(valueToInject);\n             fail();\n         } catch (Exception e) {\n+            // then\n             Assertions.assertThat(e.getMessage()).contains(\"setter not found\");\n         }\n     }\n \n     @Test\n-    public void shouldReturnFalseIfNoSetterFound() throws Exception {\n+    public void return_false_if_no_setter_was_found() throws Exception {\n+        // given\n         SomeBeanWithJustAGetter bean = new SomeBeanWithJustAGetter();\n         Field theField = bean.getClass().getDeclaredField(\"theField\");\n-\n         File valueToInject = new File(\"path\");\n \n+        // when\n         boolean injected = new BeanPropertySetter(bean, theField).set(valueToInject);\n \n+        // then\n         assertFalse(injected);\n     }\n \n     @Test\n-    public void shouldReturnFalseIfNoSetterWasFoundAndIfReportFailureFalse() throws Exception {\n+    public void return_false_if_no_setter_was_found_and_if_reportNoSetterFound_is_false() throws Exception {\n+        // given\n         SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();\n         Field theField = bean.getClass().getDeclaredField(\"theField\");\n-\n         File valueToInject = new File(\"path\");\n \n+        // when\n         boolean injected = new BeanPropertySetter(bean, theField, false).set(valueToInject);\n \n+        // then\n         assertFalse(injected);\n     }\n \n     static class SomeBean {\n         private File theField;\n-        boolean setTheFieldWasUsed;\n+        boolean theFieldSetterWasUsed;\n \n         public void setTheField(final File theField) {\n-            setTheFieldWasUsed = true;\n+            theFieldSetterWasUsed = true;\n             this.theField = theField;\n         }\n \n \n     static class SomeBeanWithJustASetter {\n         private File theField;\n-        boolean setTheFieldWasUsed;\n+        boolean theFieldSetterWasUsed;\n \n         public void setTheField(final File theField) {\n+            theFieldSetterWasUsed = true;\n             this.theField = theField;\n-            setTheFieldWasUsed = true;\n         }\n     }\n     static class SomeBeanWithJustAGetter {\n \n     static class SomeBeanWithNoSetterMatchingFieldType {\n         private File theField;\n-        boolean setTheFieldWasUsed;\n+        boolean theFieldSetterWasUsed;\n \n         public void setTheField(final FileOutputStream somethingElse) {\n-            setTheFieldWasUsed = true;\n+            theFieldSetterWasUsed = true;\n+        }\n+    }\n+\n+    static class BeanWithWeirdFields {\n+        private UUID UUID;\n+        boolean theFieldSetterWasUSed;\n+\n+        public void setUUID(UUID UUID) {\n+            theFieldSetterWasUSed = true;\n+            this.UUID = UUID;\n         }\n     }\n \n--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n \n         assertSame(backupInstance, report.fieldInstance());\n         assertFalse(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test\n \n         assertNotNull(report.fieldInstance());\n         assertTrue(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test\n \n         assertNotNull(report.fieldInstance());\n         assertTrue(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test\n \n         assertNotNull(report.fieldInstance());\n         assertTrue(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test(expected = MockitoException.class)\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/FieldsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+\n+import java.lang.reflect.Field;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class FieldsTest {\n+\n+    @Test\n+    public void fields_should_return_all_declared_fields_in_hierarchy() throws Exception {\n+        assertThat(Fields.allDeclaredFieldsOf(new HierarchyOfClasses()).names())\n+                .containsOnly(\"a\", \"b\", \"static_a\", \"static_b\");\n+    }\n+\n+    @Test\n+    public void fields_should_return_declared_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new HierarchyOfClasses()).names())\n+                .containsOnly(\"b\", \"static_b\");\n+    }\n+\n+    @Test\n+    public void can_filter_not_null_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new NullOrNotNullFields()).notNull().names())\n+                .containsOnly(\"c\");\n+    }\n+\n+    @Test\n+    public void can_get_values_of_instance_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new ValuedFields()).assignedValues())\n+                .containsOnly(\"a\", \"b\");\n+    }\n+\n+\n+    @Test\n+    public void can_get_list_of_InstanceField() throws Exception {\n+        ValuedFields instance = new ValuedFields();\n+\n+        assertThat(Fields.declaredFieldsOf(instance).instanceFields())\n+                .containsOnly(new InstanceField(field(\"a\", instance), instance),\n+                              new InstanceField(field(\"b\", instance), instance)\n+                );\n+    }\n+\n+    private Field field(String name, Object instance) throws NoSuchFieldException {\n+        return instance.getClass().getDeclaredField(name);\n+    }\n+\n+\n+    interface AnInterface {\n+        int someStaticInInterface = 0;\n+\n+    }\n+    public static class ParentClass implements AnInterface {\n+        static int static_a;\n+        int a;\n+\n+    }\n+    public static class HierarchyOfClasses extends ParentClass {\n+        static int static_b;\n+        int b = 1;\n+\n+    }\n+    public static class NullOrNotNullFields {\n+        static Object static_b;\n+        Object b;\n+        Object c = new Object();\n+    }\n+\n+    public static class ValuedFields {\n+        String a = \"a\";\n+        String b = \"b\";\n+    }\n+}\n--- a/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n+++ b/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n         private String privateInherited = \"private\";\n     }\n     \n-    static class SomeObject extends InheritMe {\n+    public static class SomeObject extends InheritMe {\n         @SuppressWarnings(\"unused\")\n         // required because static fields needs to be excluded from copying\n         private static int staticField = -100;\n         }\n     }\n \n-    static class SomeOtherObject {\n+    public static class SomeOtherObject {\n     }\n \n     private SomeObject from = new SomeObject(100);\n--- a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class NoMoreInteractionsTest extends TestBase {\n--- a/test/org/mockito/internal/verification/OnlyTest.java\n+++ b/test/org/mockito/internal/verification/OnlyTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoAssertionError;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n \n public class OnlyTest {\n \n--- a/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class RegisteredInvocationsTest extends TestBase {\n--- a/test/org/mockito/internal/verification/SmartPrinterTest.java\n+++ b/test/org/mockito/internal/verification/SmartPrinterTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class SmartPrinterTest extends TestBase {\n \n-    private PrintingFriendlyInvocation multi;\n-    private PrintingFriendlyInvocation shortie;\n+    private InvocationMatcher multi;\n+    private InvocationMatcher shortie;\n     @Mock private IMethods mock;\n \n     @Before\n     public void setup() throws Exception {\n         mock.varargs(\"first very long argument\", \"second very long argument\", \"another very long argument\");\n-        multi = getLastInvocation();\n-        multi.toString();\n-        \n+        multi = new InvocationMatcher(getLastInvocation());\n+\n         mock.varargs(\"short arg\");\n-        shortie = getLastInvocation();\n+        shortie = new InvocationMatcher(getLastInvocation());\n     }\n \n     @Test\n     public void shouldPrintBothInMultilinesWhenFirstIsMulti() {\n         //when\n-        SmartPrinter printer = new SmartPrinter(multi, shortie);\n+        SmartPrinter printer = new SmartPrinter(multi, shortie.getInvocation());\n         \n         //then\n         assertContains(\"\\n\", printer.getWanted().toString());\n     @Test\n     public void shouldPrintBothInMultilinesWhenSecondIsMulti() {\n         //when\n-        SmartPrinter printer = new SmartPrinter(shortie, multi);\n+        SmartPrinter printer = new SmartPrinter(shortie, multi.getInvocation());\n         \n         //then\n         assertContains(\"\\n\", printer.getWanted().toString());\n     @Test\n     public void shouldPrintBothInMultilinesWhenBothAreMulti() {\n         //when\n-        SmartPrinter printer = new SmartPrinter(multi, multi);\n+        SmartPrinter printer = new SmartPrinter(multi, multi.getInvocation());\n         \n         //then\n         assertContains(\"\\n\", printer.getWanted().toString());\n     @Test\n     public void shouldPrintBothInSingleLineWhenBothAreShort() {\n         //when\n-        SmartPrinter printer = new SmartPrinter(shortie, shortie);\n+        SmartPrinter printer = new SmartPrinter(shortie, shortie.getInvocation());\n         \n         //then\n         assertNotContains(\"\\n\", printer.getWanted().toString());\n--- a/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.internal.invocation.*;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class AtLeastXNumberOfInvocationsCheckerTest extends TestBase {\n--- a/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n class InvocationsFinderStub extends InvocationsFinder {\n     \n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationCheckerTest extends TestBase {\n         private Location actualLocation;\n         \n         @Override\n-        public void wantedButNotInvoked(PrintableInvocation wanted, List<? extends PrintableInvocation> invocations) {\n+        public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {\n             this.wanted = wanted;\n         }\n         \n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationInOrderCheckerTest extends TestBase {\n     }\n     \n     class ReporterStub extends Reporter {\n-        private PrintableInvocation wanted;\n-        private PrintableInvocation previous;\n+        private DescribedInvocation wanted;\n+        private DescribedInvocation previous;\n         private String wantedString;\n         private String actual;\n         private Location actualLocation;\n         \n-        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n+        @Override public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n             this.wanted = wanted;\n             this.previous = previous;\n         }\n         \n-        @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n+        @Override public void wantedButNotInvoked(DescribedInvocation wanted) {\n             this.wanted = wanted;\n         }\n \n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.exceptions.Discrepancy;\n-import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.DescribedInvocation;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsCheckerTest extends TestBase {\n     class ReporterStub extends Reporter {\n         private int wantedCount;\n         private int actualCount;\n-        private PrintableInvocation wanted;\n+        private DescribedInvocation wanted;\n         private Location location;\n-        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+        @Override public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n                     this.wantedCount = discrepancy.getWantedCount();\n                     this.actualCount = discrepancy.getActualCount();\n                     this.wanted = wanted;\n                     this.location = lastActualLocation;\n         }\n         \n-        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n+        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {\n                     this.wantedCount = wantedCount;\n                     this.actualCount = actualCount;\n                     this.wanted = wanted;\n         }\n         \n         @Override\n-        public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n+        public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {\n             this.wanted = wanted;\n             this.location = firstUndesired;\n         }\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsInOrderCheckerTest extends TestBase {\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n import java.util.Map;\n import java.util.Set;\n \n-import javax.swing.text.ChangedCharSetException;\n-\n public interface IMethods {\n \n     boolean booleanReturningMethod();\n \n     String oneArray(Object[] array);\n     \n-    String canThrowException() throws ChangedCharSetException, CharacterCodingException; \n+    String canThrowException() throws CharacterCodingException; \n \n     String oneArray(String[] array);\n \n     Object varargsObject(int i, Object... object);\n     \n     int varargs(Object ... object);\n-    \n+\n+    String varargsReturningString(Object ... object);\n+\n     int varargs(String ... string);\n \n     void mixedVarargs(Object i, String ... string);\n \n     void intArgumentMethod(int i);\n \n+    int intArgumentReturningInt(int i);\n+\n     boolean equals(String str);\n \n     boolean equals();\n \n     int hashCode(String str);\n+\n+    int toIntPrimitive(Integer i);\n+\n+    Integer toIntWrapper(int i);\n }\n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n  */\n package org.mockitousage;\n \n-import javax.swing.text.ChangedCharSetException;\n import java.io.IOException;\n-import java.util.*;\n import java.nio.charset.CharacterCodingException;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n public class MethodsImpl implements IMethods {\n     public boolean booleanReturningMethod() {\n         return null;\n     }\n \n-    public String canThrowException() throws ChangedCharSetException, CharacterCodingException {\n+    public String canThrowException() throws CharacterCodingException {\n         return null;\n     }\n \n         return -1;\n     }\n \n+    public String varargsReturningString(Object... object) {\n+        return null;\n+    }\n+\n     public int varargs(String... string) {\n         return -1;\n     }\n       \n     }\n \n+    public int intArgumentReturningInt(int i) {\n+        return 0;\n+    }\n+\n     public boolean equals(String str) {\n         return false;\n     }\n     public int hashCode(String str) {\n         return 0;\n     }\n+\n+    public int toIntPrimitive(Integer i) {\n+        return 0;\n+    }\n+\n+    public Integer toIntWrapper(int i) {\n+        return null;\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class InjectionOfInlinedMockDeclarationTest {\n+\n+    @InjectMocks private Receiver receiver;\n+    @InjectMocks private Receiver spiedReceiver = spy(new Receiver());\n+\n+    private Antenna oldAntenna = mock(Antenna.class);\n+    private Antenna satelliteAntenna = mock(Antenna.class);\n+    private Antenna antenna = mock(Antenna.class, \"dvbtAntenna\");\n+    private Tuner tuner = spy(new Tuner());\n+\n+    @Test\n+    public void mock_declared_fields_shall_be_injected_too() throws Exception {\n+        assertNotNull(receiver.oldAntenna);\n+        assertNotNull(receiver.satelliteAntenna);\n+        assertNotNull(receiver.dvbtAntenna);\n+        assertNotNull(receiver.tuner);\n+    }\n+\n+    @Test\n+    public void unnamed_mocks_should_be_resolved_withe_their_field_names() throws Exception {\n+        assertSame(oldAntenna, receiver.oldAntenna);\n+        assertSame(satelliteAntenna, receiver.satelliteAntenna);\n+    }\n+\n+    @Test\n+    public void named_mocks_should_be_resolved_with_their_name() throws Exception {\n+        assertSame(antenna, receiver.dvbtAntenna);\n+    }\n+\n+\n+    @Test\n+    public void inject_mocks_even_in_declared_spy() throws Exception {\n+        assertNotNull(spiedReceiver.oldAntenna);\n+        assertNotNull(spiedReceiver.tuner);\n+    }\n+\n+    // note that static class is not private !!\n+    static class Receiver {\n+        Antenna oldAntenna;\n+        Antenna satelliteAntenna;\n+        Antenna dvbtAntenna;\n+        Tuner tuner;\n+\n+        public boolean tune() { return true; }\n+    }\n+\n+    private static class Antenna { }\n+    private static class Tuner { }\n+\n+}\n--- a/test/org/mockitousage/basicapi/ResetTest.java\n+++ b/test/org/mockitousage/basicapi/ResetTest.java\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n             fail();\n         } catch (MissingMethodInvocationException e) {\n         }\n+    }\n+\n+    @Test(expected = NotAMockException.class)\n+    public void resettingNonMockIsSafe() {\n+        reset(\"\");\n+    }\n+\n+    @Test(expected = NotAMockException.class)\n+    public void resettingNullIsSafe() {\n+        reset(new Object[] {null});\n     }\n \n     @Test\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+// issue 322\n+// the only evidence of this failing test was shown on a RHEL with IBM J9 JVM 64bits\n+//\n+// details\n+// java.fullversion=JRE 1.6.0 IBM J9 2.6 Linux amd64-64 20111113_94967  (JIT enabled, AOT enabled)\n+// Linux2.6.32-220.4.2.el6.x86_64 #1SMP Mon Feb 6 16:39:28EST 2012x86_64 x86_64 x86_64 GNU/Linux\n+public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {\n+\n+\tint nThreads = 1;\n+\tstatic final int TEST_MILLIS = 1000;\n+\tstatic final int INTERVAL_MILLIS = 10;\n+\tstatic final int TIMES = TEST_MILLIS / INTERVAL_MILLIS;\n+\n+\tITarget target = Mockito.mock(ITarget.class);\n+\tExecutorService fixedThreadPool;\n+\t\n+\t@Before\n+\tpublic void setUp() {\n+\t\ttarget = Mockito.mock(ITarget.class);\n+\t\tfixedThreadPool = Executors.newFixedThreadPool(nThreads);\n+\t}\n+\n+\t@Test\n+\tpublic void testInvocationConcurrently() throws Exception {\n+\t\treset(target);\n+\t\tstartInvocations();\n+\t\tverify(target, timeout(TEST_MILLIS).times(TIMES*nThreads)).targetMethod(\"arg\");\n+\t\tverifyNoMoreInteractions(target);\n+\t}\n+\n+\tprivate void startInvocations() throws InterruptedException,\n+\t\t\tExecutionException {\n+\t\t\n+\t\tfor(int i=0; i<nThreads; i++) {\n+\t\t\tfixedThreadPool.submit(new TargetInvoker(i));\n+\t\t}\n+\n+\t}\n+\n+\t\n+\tpublic class TargetInvoker implements Callable<Object> {\n+\n+\t\tprivate final int seq;\n+\n+\t\tTargetInvoker(int seq) {\n+\t\t\tthis.seq = seq;\n+\t\t}\n+\t\t\n+\t\tpublic Object call() throws Exception {\n+\t\t\tSystem.err.println(\"started \" + seq);\n+\t\t\tfor (int i = 0; i < TIMES; i++) {\n+\t\t\t\tThread.yield();\n+\t\t\t\ttarget.targetMethod(\"arg\");\n+\t\t\t\tThread.sleep((long) INTERVAL_MILLIS);\n+\t\t\t}\n+\t\t\tSystem.err.println(\"finished\" + seq);\n+\t\t\treturn seq;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\tpublic static interface ITarget {\n+\n+\t\tpublic String targetMethod(String arg);\n+\t}\n+\t\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.nio.charset.Charset;\n+\n+// issue 327\n+public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {\n+    @Mock private Charset charset;\n+    @InjectMocks private FieldCharsetHolder fieldCharsetHolder;\n+    @InjectMocks private ConstructorCharsetHolder constructorCharsetHolder;\n+\n+    @Test\n+    public void dont_raise_NullPointerException() throws Exception {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    private static class FieldCharsetHolder {\n+        private Charset charset;\n+    }\n+\n+    private static class ConstructorCharsetHolder {\n+        public ConstructorCharsetHolder(Charset charset) {\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/bugs/ParentClassNotPublicVeryWeirdBugTest.java\n+++ b/test/org/mockitousage/bugs/ParentClassNotPublicVeryWeirdBugTest.java\n  */\n package org.mockitousage.bugs;\n \n-import static org.mockito.Mockito.*;\n-\n import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n \n //see bug 212\n-@Ignore //needs fixing\n+// @Ignore(\"needs fixing\")\n public class ParentClassNotPublicVeryWeirdBugTest {\n     \n     class SuperClass {\n     }\n     \n     @Test\n-    public void isValidMocked() {\n+    @Ignore(\"needs fixing\")\n+    public void is_valid_mocked() {\n         ClassForMocking clazzMock = mock(ClassForMocking.class);\n         Mockito.when(clazzMock.isValid()).thenReturn(true);\n     }\n+\n+    @Test\n+    public void report_why_this_exception_happen() throws Exception {\n+        ClassForMocking clazzMock = mock(ClassForMocking.class);\n+        try {\n+            Mockito.when(clazzMock.isValid()).thenReturn(true);\n+            fail();\n+        } catch (MissingMethodInvocationException e) {\n+            assertThat(e.getMessage())\n+                    .contains(\"the parent of the mocked class is not public.\")\n+                    .contains(\"It is a limitation of the mock engine\");\n+        }\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.configuration;\n+\n+\n+import org.fest.assertions.Condition;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.concurrent.Callable;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ClassCacheVersusClassReloadingTest {\n+\n+    private SimplePerRealmReloadingClassLoader testMethodClassLoaderRealm = new SimplePerRealmReloadingClassLoader(reloadMockito());\n+\n+    @Test\n+    public void should_throw_ClassCastException_on_second_call() throws Exception {\n+        doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+\n+        try {\n+            doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+            fail(\"should have raised a ClassCastException when Objenis Cache is enabled\");\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"classloading\")\n+                    .containsIgnoringCase(\"objenesis\")\n+                    .containsIgnoringCase(\"MockitoConfiguration\");\n+            assertThat(e.getCause())\n+                    .satisfies(thatCceIsThrownFrom(\"java.lang.Class.cast\"))\n+                    .satisfies(thatCceIsThrownFrom(\"org.mockito.internal.creation.jmock.ClassImposterizer.imposterise\"));\n+        }\n+    }\n+\n+    @Test\n+    public void should_not_throw_ClassCastException_when_objenesis_cache_disabled() throws Exception {\n+        prepareMockitoAndDisableObjenesisCache();\n+\n+        doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+        doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+    }\n+\n+    private Condition<Throwable> thatCceIsThrownFrom(final String stacktraceElementDescription) {\n+        return new Condition<Throwable>() {\n+            @Override\n+            public boolean matches(Throwable throwable) {\n+                StackTraceElement[] stackTrace = throwable.getStackTrace();\n+                for (StackTraceElement stackTraceElement : stackTrace) {\n+                    if (stackTraceElement.toString().contains(stacktraceElementDescription)) {\n+                        return true;\n+                    }\n+                }\n+\n+                return false;\n+            }\n+        };\n+    }\n+\n+    public static class DoTheMocking implements Callable {\n+        public Object call() throws Exception {\n+            Class clazz = this.getClass().getClassLoader().loadClass(\"org.mockitousage.configuration.ClassToBeMocked\");\n+            return mock(clazz);\n+        }\n+    }\n+\n+\n+    private static void doInNewChildRealm(ClassLoader parentRealm, String callableCalledInClassLoaderRealm) throws Exception {\n+        new SimplePerRealmReloadingClassLoader(parentRealm, reloadScope()).doInRealm(callableCalledInClassLoaderRealm);\n+    }\n+\n+    private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {\n+        return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n+            public boolean needReload(String qualifiedName) {\n+                return \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\".equals(qualifiedName)\n+                    || \"org.mockitousage.configuration.ClassToBeMocked\".equals(qualifiedName);\n+            }\n+        };\n+    }\n+\n+    private void prepareMockitoAndDisableObjenesisCache() throws Exception {\n+        testMethodClassLoaderRealm.doInRealm(\"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$PrepareMockito\");\n+    }\n+\n+    public static class PrepareMockito implements Callable {\n+        public Object call() throws Exception {\n+            Class.forName(\"org.mockito.Mockito\");\n+            ConfigurationAccess.getConfig().overrideEnableClassCache(false);\n+            return Boolean.TRUE;\n+        }\n+    }\n+\n+    private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {\n+        return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n+            public boolean needReload(String qualifiedName) {\n+                return (!qualifiedName.contains(\"org.mockito.cglib\") && qualifiedName.contains(\"org.mockito\"));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Custom classloader to load classes in hierarchic realm.\n+     *\n+     * Each class can be reloaded in the realm if the LoadClassPredicate says so.\n+     */\n+    private static class SimplePerRealmReloadingClassLoader extends URLClassLoader {\n+\n+        private ReloadClassPredicate reloadClassPredicate;\n+\n+        public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {\n+            super(new URL[]{obtainClassPath(), obtainClassPath(\"org.mockito.Mockito\")});\n+            this.reloadClassPredicate = reloadClassPredicate;\n+        }\n+\n+        public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {\n+            super(new URL[]{\n+                    obtainClassPath(),\n+                    obtainClassPath(\"org.mockito.Mockito\"),\n+            }, parentClassLoader);\n+            this.reloadClassPredicate = reloadClassPredicate;\n+        }\n+\n+        private static URL obtainClassPath() {\n+            String className = SimplePerRealmReloadingClassLoader.class.getName();\n+            return obtainClassPath(className);\n+        }\n+\n+        private static URL obtainClassPath(String className) {\n+            String path = className.replace('.', '/') + \".class\";\n+            String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();\n+\n+            try {\n+                return new URL(url.substring(0, url.length() - path.length()));\n+            } catch (MalformedURLException e) {\n+                throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n+            }\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String qualifiedName) throws ClassNotFoundException {\n+            if(reloadClassPredicate.needReload(qualifiedName)) {\n+                // return customLoadClass(qualifiedName);\n+                Class<?> foundClass = findClass(qualifiedName);\n+                return foundClass;\n+            }\n+            return super.loadClass(qualifiedName);\n+        }\n+\n+        public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {\n+            Callable<?> callableInRealm = (Callable<?>) this.loadClass(callableCalledInClassLoaderRealm).newInstance();\n+            return callableInRealm.call();\n+        }\n+\n+        public static interface ReloadClassPredicate {\n+            boolean needReload(String qualifiedName);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/configuration/ClassToBeMocked.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.configuration;\n+\n+/**\n+ * Some class to mock\n+ */\n+public class ClassToBeMocked { }\n--- a/test/org/mockitousage/customization/BDDMockitoTest.java\n+++ b/test/org/mockitousage/customization/BDDMockitoTest.java\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n+import org.mockitousage.MethodsImpl;\n import org.mockitoutil.TestBase;\n \n import java.util.Set;\n        \n        assertEquals(\"foo\", mock.simpleMethod(\"whatever\"));\n        assertEquals(\"bar\", mock.simpleMethod(\"whatever\"));\n+    }\n+\n+    @Test\n+    public void shouldStubConsecutivelyWithCallRealMethod() throws Exception {\n+        MethodsImpl mock = mock(MethodsImpl.class);\n+        willReturn(\"foo\").willCallRealMethod()\n+                .given(mock).simpleMethod();\n+\n+       assertEquals(\"foo\", mock.simpleMethod());\n+       assertEquals(null, mock.simpleMethod());\n     }\n     \n     @Test\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n \n import org.junit.Test;\n import org.mockito.InOrder;\n-import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.DescribedInvocation;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.listeners.MethodInvocationReport;\n \n     }\n \n     private static class RememberingListener implements InvocationListener {\n-        PrintableInvocation invocation;\n+        DescribedInvocation invocation;\n         Object returnValue;\n         String locationOfStubbing;\n \n--- /dev/null\n+++ b/test/org/mockitousage/internal/debugging/LocationImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.internal.debugging;\n+\n+import org.junit.Test;\n+import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.internal.exceptions.base.StackTraceFilter;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"serial\")\n+public class LocationImplTest extends TestBase {\n+\n+    @Test\n+    public void shouldLocationNotContainGetStackTraceMethod() {\n+        assertContains(\"shouldLocationNotContainGetStackTraceMethod\", new LocationImpl().toString());\n+    }\n+\n+    @Test\n+    public void shouldBeSafeInCaseForSomeReasonFilteredStackTraceIsEmpty() {\n+        //given\n+        StackTraceFilter filterReturningEmptyArray = new StackTraceFilter() {\n+            @Override\n+            public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n+                return new StackTraceElement[0];\n+            }\n+        };\n+\n+        //when\n+        String loc = new LocationImpl(filterReturningEmptyArray).toString();\n+\n+        //then\n+        assertEquals(\"-> at <<unknown line>>\", loc);\n+    }\n+}\n--- a/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n \n package org.mockitousage.matchers;\n \n-import static org.mockito.Matchers.*;\n-\n-import org.junit.After;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n import org.mockito.AdditionalMatchers;\n import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.runners.MockitoJUnitRunner;\n import org.mockitousage.IMethods;\n-import org.mockitoutil.TestBase;\n \n-public class InvalidUseOfMatchersTest extends TestBase {\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class InvalidUseOfMatchersTest {\n \n     @Mock private IMethods mock;\n \n-    @After\n-    public void resetState() {\n-        super.resetState();\n+    @Test\n+    public void should_detect_wrong_number_of_matchers_when_stubbing() {\n+        when(mock.threeArgumentMethod(1, \"2\", \"3\")).thenReturn(null);\n+        try {\n+            when(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).thenReturn(null);\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertThat(e.getMessage())\n+                      .contains(\"3 matchers expected\")\n+                      .contains(\"1 recorded\");\n+        }\n     }\n \n     @Test\n-    public void shouldDetectWrongNumberOfMatchersWhenStubbing() {\n-        Mockito.when(mock.threeArgumentMethod(1, \"2\", \"3\")).thenReturn(null);\n-        try {\n-            Mockito.when(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).thenReturn(null);\n-            fail();\n-        } catch (InvalidUseOfMatchersException e) {}\n-    }\n-\n-    @Test\n-    public void shouldDetectStupidUseOfMatchersWhenVerifying() {\n+    public void should_detect_stupid_use_of_matchers_when_verifying() {\n         mock.oneArg(true);\n         eq(\"that's the stupid way\");\n         eq(\"of using matchers\");\n         try {\n             Mockito.verify(mock).oneArg(true);\n             fail();\n-        } catch (InvalidUseOfMatchersException e) {}\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertThat(e.getMessage())\n+                      .contains(\"Misplaced argument matcher detected here\");\n+            e.printStackTrace();\n+        }\n     }\n \n     @Test\n-    public void shouldScreamWhenMatchersAreInvalid() {\n+    public void should_not_scream_on_correct_usage() throws Exception {\n         mock.simpleMethod(AdditionalMatchers.not(eq(\"asd\")));\n+        mock.simpleMethod(AdditionalMatchers.or(eq(\"jkl\"), eq(\"asd\")));\n+    }\n+\n+    @Test\n+    public void should_scream_when_no_matchers_inside_not() {\n         try {\n             mock.simpleMethod(AdditionalMatchers.not(\"jkl\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertContains(\"No matchers found for Not(?).\", e.getMessage());\n+            assertThat(e.getMessage())\n+                    .contains(\"No matchers found for\")\n+                    .containsIgnoringCase(\"Not(?)\");\n         }\n+    }\n \n+    @Test\n+    public void should_scream_when_not_enough_matchers_inside_or_AddtionalMatcher() {\n         try {\n             mock.simpleMethod(AdditionalMatchers.or(eq(\"jkl\"), \"asd\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertContains(\"2 matchers expected, 1 recorded.\", e.getMessage());\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"inside additional matcher Or(?)\")\n+                    .contains(\"2 sub matchers expected\")\n+                    .contains(\"1 recorded\");\n         }\n+    }\n \n+    @Test\n+    public void should_scream_when_Matchers_count_dont_match_parameter_count() {\n         try {\n             mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertContains(\"3 matchers expected, 1 recorded.\", e.getMessage());\n+            assertThat(e.getMessage())\n+                      .contains(\"3 matchers expected\")\n+                      .contains(\"1 recorded\");\n         }\n     }\n }\n--- a/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.misuse;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n \n import org.junit.After;\n import org.junit.Test;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.Observer;\n+\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.validateMockitoUsage;\n+import static org.mockito.Mockito.verify;\n \n public class DetectingMisusedMatchersTest extends TestBase {\n \n         super.resetState();\n     }\n \n-    private void misplacedArgumentMatcher() {\n+    private void misplaced_anyObject_argument_matcher() {\n         anyObject();\n+    }\n+    \n+    private void misplaced_anyInt_argument_matcher() {\n+        anyInt();\n+    }\n+    \n+    private void misplaced_anyBoolean_argument_matcher() {\n+        anyBoolean();\n     }\n \n     @Test\n-    public void shouldFailFastWhenArgumentMatchersAbused() {\n-        misplacedArgumentMatcher();\n+    public void should_fail_fast_when_argument_matchers_are_abused() {\n+        misplaced_anyObject_argument_matcher();\n         try {\n             mock(IMethods.class);\n             fail();\n             assertContains(\"Misplaced argument matcher\", e.getMessage());\n         }\n     }\n+    \n+    @Test\n+    public void should_report_argument_locations_when_argument_matchers_misused() {\n+        try {\n+        \tObserver observer = mock(Observer.class);\n+        \t\n+        \tmisplaced_anyInt_argument_matcher();\n+        \tmisplaced_anyObject_argument_matcher();\n+        \tmisplaced_anyBoolean_argument_matcher();\n+        \t\n+        \tobserver.update(null, null);\n+        \t\n+        \tvalidateMockitoUsage();\n+        \tfail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertContains(\"DetectingMisusedMatchersTest.misplaced_anyInt_argument_matcher\", e.getMessage());\n+            assertContains(\"DetectingMisusedMatchersTest.misplaced_anyObject_argument_matcher\", e.getMessage());\n+            assertContains(\"DetectingMisusedMatchersTest.misplaced_anyBoolean_argument_matcher\", e.getMessage());\n+        }\n+    }\n+   \n     \n     @Test\n     public void shouldSayUnfinishedVerificationButNotInvalidUseOfMatchers() {\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/SpyStubbingMisuseTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.misuse;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n+\n+import static org.junit.Assert.fail;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.*;\n+\n+public class SpyStubbingMisuseTest {\n+\n+    @Test\n+    public void nestedWhenTest() {\n+        Strategy mfoo = mock(Strategy.class);\n+        Sampler mpoo = mock(Sampler.class);\n+        Producer out = spy(new Producer(mfoo));\n+\n+        try {\n+            when(out.produce()).thenReturn(mpoo);\n+            fail();\n+        } catch (WrongTypeOfReturnValue e) {\n+            assertThat(e.getMessage()).contains(\"spy\").contains(\"syntax\").contains(\"doReturn|Throw\");\n+        }\n+    }\n+\n+    public class Sample { }\n+\n+    public class Strategy {\n+        Sample getSample() {\n+            return new Sample();\n+        }\n+    }\n+\n+    public class Sampler {\n+        Sample sample;\n+        Sampler(Strategy f) {\n+            sample = f.getSample();\n+        }\n+    }\n+\n+    public class Producer {\n+        Strategy strategy;\n+        Producer(Strategy f) {\n+            strategy = f;\n+        }\n+        Sampler produce() {\n+            return new Sampler(strategy);\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n  */\n package org.mockitousage.stubbing;\n \n-import static org.mockito.BDDMockito.*;\n-\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockitoutil.TestBase;\n+\n+import javax.net.SocketFactory;\n import java.io.ByteArrayOutputStream;\n import java.io.OutputStream;\n import java.net.Socket;\n-\n-import javax.net.SocketFactory;\n-\n-import org.junit.Test;\n-import org.mockitoutil.TestBase;\n+import java.util.Locale;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.*;\n \n \n public class DeepStubbingTest extends TestBase {\n             return address;\n         }\n         \n+        public Address getAddress(String addressName) {\n+        \treturn address;\n+        }\n+        \n         public FinalClass getFinalClass() {\n             return null;\n         }\n         public Street getStreet() {\n             return street;\n         }\n+\n+        public Street getStreet(Locale locale) {\n+            return street;\n+        }\n     }\n     \n     static class Street {\n         public String getName() {\n             return name;\n         }\n+\n+        public String getLongName() {\n+            return name;\n+        }\n     }    \n     \n-    static final class FinalClass {};    \n+    static final class FinalClass {}\n     \n     @Test\n     public void myTest() throws Exception {\n         \n         //then\n         verify(person.getAddress().getStreet()).getName();\n-    }   \n-    \n+    }\n+    \n+    @Test\n+\tpublic void verification_work_with_argument_Matchers_in_nested_calls() throws Exception {\n+\t\t//given\n+    \tperson.getAddress(\"111 Mock Lane\").getStreet();\n+    \tperson.getAddress(\"111 Mock Lane\").getStreet(Locale.ITALIAN).getName();\n+\n+\t\t//then\n+    \tverify(person.getAddress(anyString())).getStreet();\n+    \tverify(person.getAddress(anyString()).getStreet(Locale.CHINESE), never()).getName();\n+    \tverify(person.getAddress(anyString()).getStreet(eq(Locale.ITALIAN))).getName();\n+\t}\n+\n+    @Test\n+    public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() throws Exception {\n+        when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+\n+        person.getAddress(\"the docks\").getStreet().getName();\n+\n+        assertSame(person.getAddress(\"the docks\").getStreet(), person.getAddress(anyString()).getStreet());\n+        assertSame(person.getAddress(anyString()).getStreet(), person.getAddress(anyString()).getStreet());\n+        assertSame(person.getAddress(\"the docks\").getStreet(), person.getAddress(\"the docks\").getStreet());\n+        assertSame(person.getAddress(anyString()).getStreet(), person.getAddress(\"the docks\").getStreet());\n+        assertSame(person.getAddress(\"111 Mock Lane\").getStreet(), person.getAddress(\"the docks\").getStreet());\n+    }\n+\n+    @Test\n+    public void times_never_atLeast_atMost_verificationModes_should_work() throws Exception {\n+        when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet(Locale.ITALIAN).getName();\n+\n+        verify(person.getAddress(\"the docks\").getStreet(), times(3)).getName();\n+        verify(person.getAddress(\"the docks\").getStreet(Locale.CHINESE), never()).getName();\n+        verify(person.getAddress(\"the docks\").getStreet(Locale.ITALIAN), atMost(1)).getName();\n+    }\n+\n+\n+    @Test\n+    public void inOrder_only_work_on_the_very_last_mock_but_it_works() throws Exception {\n+        when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+        when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(\"deep\");\n+        when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(\"deep\");\n+\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet().getLongName();\n+        person.getAddress(\"the docks\").getStreet(Locale.ITALIAN).getName();\n+        person.getAddress(\"the docks\").getStreet(Locale.CHINESE).getName();\n+\n+        InOrder inOrder = inOrder(\n+                person.getAddress(\"the docks\").getStreet(),\n+                person.getAddress(\"the docks\").getStreet(Locale.CHINESE),\n+                person.getAddress(\"the docks\").getStreet(Locale.ITALIAN)\n+        );\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet(), times(1)).getName();\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet()).getLongName();\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.ITALIAN), atLeast(1)).getName();\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.CHINESE)).getName();\n+    }\n+\n+    @Test\n+    public void verificationMode_only_work_on_the_last_returned_mock() throws Exception {\n+        // 1st invocation on Address mock (stubbing)\n+        when(person.getAddress(\"the docks\").getStreet().getName()).thenReturn(\"deep\");\n+\n+        // 2nd invocation on Address mock (real)\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        // 3rd invocation on Address mock (verification)\n+        // (Address mock is not in verification mode)\n+        verify(person.getAddress(\"the docks\").getStreet()).getName();\n+\n+        try {\n+            verify(person.getAddress(\"the docks\"), times(1)).getStreet();\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            Assertions.assertThat(e.getMessage())\n+                    .contains(\"Wanted 1 time\")\n+                    .contains(\"But was 3 times\");\n+        }\n+    }\n+\n     @Test\n     public void shouldFailGracefullyWhenClassIsFinal() throws Exception {\n         //when        \n--- a/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n+import org.mockitousage.MethodsImpl;\n import org.mockitoutil.TestBase;\n \n import java.io.IOException;\n         \n         assertEquals(\"bar\", mock.simpleMethod());\n         assertEquals(\"bar\", mock.simpleMethod());\n+    }\n+\n+    @Test\n+    public void shouldAllowDoCallRealMethodInChainedStubbing() throws Exception {\n+        MethodsImpl methods = mock(MethodsImpl.class);\n+        doReturn(\"A\").doCallRealMethod()\n+                .when(methods).simpleMethod();\n+\n+        assertEquals(\"A\", methods.simpleMethod());\n+        assertEquals(null, methods.simpleMethod());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockitousage.IMethods;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.AdditionalAnswers.returnsArgAt;\n+import static org.mockito.AdditionalAnswers.returnsFirstArg;\n+import static org.mockito.AdditionalAnswers.returnsLastArg;\n+import static org.mockito.AdditionalAnswers.returnsSecondArg;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.anyVararg;\n+import static org.mockito.Matchers.eq;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class StubbingWithAdditionalAnswers {\n+\n+    @Mock IMethods iMethods;\n+\n+    @Test\n+    public void can_return_arguments_of_invocation() throws Exception {\n+        given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());\n+        given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());\n+        given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());\n+\n+        assertThat(iMethods.objectArgMethod(\"first\")).isEqualTo(\"first\");\n+        assertThat(iMethods.threeArgumentMethod(0, \"second\", \"whatever\")).isEqualTo(\"second\");\n+        assertThat(iMethods.threeArgumentMethod(1, \"whatever\", \"last\")).isEqualTo(\"last\");\n+    }\n+\n+    @Test\n+    public void can_return_expanded_arguments_of_invocation() throws Exception {\n+        given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAt(3));\n+\n+        assertThat(iMethods.varargsObject(1, \"bob\", \"alexander\", \"alice\", \"carl\")).isEqualTo(\"alice\");\n+    }\n+\n+    @Test\n+    public void can_return_primitives_or_wrappers() throws Exception {\n+        given(iMethods.toIntPrimitive(anyInt())).will(returnsFirstArg());\n+        given(iMethods.toIntWrapper(anyInt())).will(returnsFirstArg());\n+\n+        assertThat(iMethods.toIntPrimitive(1)).isEqualTo(1);\n+        assertThat(iMethods.toIntWrapper(1)).isEqualTo(1);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+import org.mockitousage.MethodsImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithDelegate {\n+\n+\t@Test\n+\tpublic void when_not_stubbed_delegate_should_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tmock.add(\"two\") ;\n+\n+        assertEquals(2, mock.size());\n+\t}\n+\n+\t@Test\n+\tpublic void when_stubbed_the_delegate_should_not_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tdoReturn(10).when(mock).size();\n+\n+\t\tmock.add(\"two\") ;\n+\n+\t\tassertEquals(10, mock.size());\n+        assertEquals(2, delegatedList.size());\n+\t}\n+\n+\t@Test\n+\tpublic void delegate_should_not_be_called_when_stubbed2() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mockedList = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tdoReturn(false).when(mockedList).add(Mockito.anyString()) ;\n+\n+        mockedList.add(\"two\") ;\n+\n+\t\tassertEquals(1, mockedList.size()) ;\n+\t\tassertEquals(1, delegatedList.size()) ;\n+\t}\n+\n+    @Test\n+    public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {\n+        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl()));\n+\n+        try {\n+            byte b = methods.byteObjectReturningMethod(); // real method returns null\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.toString()).doesNotContain(\"org.mockito\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderWithCallsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class VerificationInOrderWithCallsTest extends TestBase {\n+\n+    @Mock private IMethods mockOne;\n+    @Mock private IMethods mockTwo;\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    @Test\n+    public void shouldFailWhenMethodNotCalled(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCalledTooFewTimes(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+        exceptionRule.expectMessage( \"Wanted 2 times\" );\n+        exceptionRule.expectMessage( \"But was 1 time\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.voidMethod()\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+    \n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg(1);\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(2)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifyNoMoreInteractions(mockOne);\n+        verifyNoMoreInteractions(mockTwo);\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+    \n+    \n+    @Test\n+    public void shouldAllowFewerCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        \n+        exceptionRule.expect( NoInteractionsWanted.class );\n+\n+        // When\n+        verifyNoMoreInteractions( mockOne );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+\n+        // When\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( NoInteractionsWanted.class );\n+\n+        // When\n+        verifyNoMoreInteractions( mockOne );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+\n+        // When\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect(NoInteractionsWanted.class);\n+\n+        // When\n+        verifyNoMoreInteractions( mockTwo );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+\n+        // When\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithCallsAfterUseOfTimes(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, times(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithCallsAfterUseOfAtLeast(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithTimesAfterUseOfCalls(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, times(2)).oneArg( 2 );\n+        verifier.verify( mockOne, times(1)).oneArg( 1 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithAtLeastAfterUseOfCalls(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 2 );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithTimesAfterCallsInSameChunk(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, times(2)).oneArg( 1 );\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsWithZeroArgument(){\n+        // Given\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(0)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsWithNegativeArgument(){\n+        // Given\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(-1)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsForNonInOrderVerification(){\n+        // Given\n+        mockOne.voidMethod();\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"calls is only intended to work with InOrder\" );\n+\n+        // When\n+        verify( mockOne, calls(1)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.StateMaster;\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.configuration.ConfigurationAccess;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.SerializableMethod;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.io.*;\n import java.util.Collection;\n         for (int i = 0; i < args.length; i++) {\n             types[i] = args[i].getClass();\n         }\n-        return new Invocation(mock(type), new SerializableMethod(type.getMethod(methodName,\n+        return new InvocationImpl(mock(type), new SerializableMethod(type.getMethod(methodName,\n                 types)), args, 1, null);\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n-        return new Invocation(new Object(), new SerializableMethod(type.getMethod(methodName,\n+        return new InvocationImpl(new Object(), new SerializableMethod(type.getMethod(methodName,\n                 new Class[0])), new Object[0], 1, realMethod);\n     }\n ", "timestamp": 1336417008, "metainfo": ""}