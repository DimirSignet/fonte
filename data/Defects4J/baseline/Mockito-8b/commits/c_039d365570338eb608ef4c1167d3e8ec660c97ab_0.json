{"sha": "039d365570338eb608ef4c1167d3e8ec660c97ab", "log": "another bunch of refactorings...  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40232", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.verification.MarkingVerifier;\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n         List<Verifier> verifiers = Arrays.asList(\n                 new MissingInvocationVerifier(),\n                 new NumberOfInvocationsVerifier(),\n+                new MarkingVerifier(),\n                 new NoMoreInvocationsVerifier());\n         return new VerifyingRecorder(new AllInvocationsFinder(), verifiers);\n     }\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n         return mocksToBeVerifiedStrictly;\n     }\n \n-//    public boolean wantedCountIsZero() {\n-//        return wantedInvocationCount != null && wantedInvocationCount == 0;\n-//    }\n-\n     public boolean atLeastOnceMode() {\n         return wantedInvocationCount == null && verification == Verification.EXPLICIT;\n     }\n     }\n     \n     public boolean missingMethodMode() {\n-        return explicitMode() && (atLeastOnceMode() || wantedInvocationCount == 1);\n+        return explicitMode() && (atLeastOnceMode() || wantedInvocationCount > 0);\n     }\n \n     public boolean exactNumberOfInvocationsMode() {\n         return atLeastOnce || actualMatchesWanted;\n     }\n     \n+    public boolean tooLittleActualInvocations(int actualCount) {\n+        return !atLeastOnceMode() && wantedInvocationCount > actualCount;\n+    }\n+    \n+    public boolean tooManyActualInvocations(int actualCount) {\n+        return !atLeastOnceMode() && wantedInvocationCount < actualCount;\n+    }\n+    \n     @Override\n     public String toString() {\n         return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedStrictly;\n     }\n-\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/MarkingVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+/**\n+ * Marks invocations as verified / verified strictly\n+ */\n+public class MarkingVerifier implements Verifier {\n+    \n+    private final ActualInvocationsFinder finder;\n+\n+    public MarkingVerifier() {\n+        this(new ActualInvocationsFinder());\n+    }\n+    \n+    MarkingVerifier(ActualInvocationsFinder finder) {\n+        this.finder = finder;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        if (!mode.explicitMode()) {\n+            return;\n+        }\n+        \n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted, mode);\n+        \n+        for (Invocation invocation : actualInvocations) {\n+            invocation.markVerified();\n+            if (mode.strictMode()) {\n+                invocation.markVerifiedStrictly();\n+            }\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted, mode);\n         \n         if (actualInvocations.size() == 0) {\n-            //TODO add test to check that invocations are passed here, not actual...\n             Invocation similar = analyzer.findSimilarInvocation(invocations, wanted, mode);\n             reportMissingInvocationError(wanted, similar);\n-        }\n-        \n-        for (Invocation invocation : actualInvocations) {\n-            invocation.markVerified();\n-            //TODO dodgy!\n-            if (mode.strictMode() && mode.atLeastOnceMode()) {\n-                invocation.markVerifiedStrictly();\n-            }\n         }\n     }\n \n             reporter.wantedButNotInvoked(wanted.toString());\n         }\n     }\n-}\n+}\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted, mode);\n         \n         int actualCount = actualInvocations.size();\n-        int wantedCount = mode.wantedCount();\n-        \n-        //TODO less/more methods on mode\n-        if (actualCount < wantedCount) {\n+        if (mode.tooLittleActualInvocations(actualCount)) {\n             //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n             HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(actualInvocations, wanted);\n-            reporter.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n-        } else if (actualCount > wantedCount) {\n+            reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n+        } else if (mode.tooManyActualInvocations(actualCount)) {\n             //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n             HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(actualInvocations, wanted, mode);\n-            reporter.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n-        }\n-        \n-        //TODO duplicated\n-        for (Invocation invocation : actualInvocations) {\n-            invocation.markVerified();\n-            if (mode.strictMode()) {\n-                invocation.markVerifiedStrictly();\n-            }\n+            reporter.tooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n }\n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n     public void shouldKnowIfIsMissingMethodMode() throws Exception {\n         assertTrue(atLeastOnce().missingMethodMode());\n         assertTrue(times(1).missingMethodMode());\n+        assertTrue(times(10).missingMethodMode());\n         \n         assertFalse(noMoreInteractions().missingMethodMode());\n         assertFalse(times(0).missingMethodMode());\n-        assertFalse(times(2).missingMethodMode());\n     }\n     \n     @Test\n         assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n         assertFalse(atLeastOnce().exactNumberOfInvocationsMode());\n     }\n-    \n-//    @Test\n-//    public void shouldKnowIfWantedCountIsZero() throws Exception {\n-//        assertTrue(times(0).wantedCountIsZero());\n-//        \n-//        assertFalse(times(1).wantedCountIsZero());\n-//        assertFalse(times(2).wantedCountIsZero());\n-//        assertFalse(atLeastOnce().wantedCountIsZero());\n-//    }\n     \n     @Test\n     public void shouldKnowIfIsStrict() throws Exception {\n         assertTrue(atLeastOnce().matchesActualCount(1));\n         assertTrue(atLeastOnce().matchesActualCount(100));\n     }\n+    \n+    @Test\n+    public void shouldKnowIfTooLittleActualInvocations() throws Exception {\n+        assertTrue(times(1).tooLittleActualInvocations(0));\n+        assertTrue(times(100).tooLittleActualInvocations(99));\n+        \n+        assertFalse(times(0).tooLittleActualInvocations(0));\n+        assertFalse(times(1).tooLittleActualInvocations(1));\n+        assertFalse(times(1).tooLittleActualInvocations(2));\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfTooManyActualInvocations() throws Exception {\n+        assertTrue(times(0).tooManyActualInvocations(1));\n+        assertTrue(times(99).tooManyActualInvocations(100));\n+        \n+        assertFalse(times(0).tooManyActualInvocations(0));\n+        assertFalse(times(1).tooManyActualInvocations(1));\n+        assertFalse(times(2).tooManyActualInvocations(1));\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/ActualInvocationsFinderStub.java\n+/*\n+ * Copyright (c) 2007, Szczepan Faber. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+class ActualInvocationsFinderStub extends ActualInvocationsFinder {\n+    final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n+    List<Invocation> invocations;\n+    @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n+            VerificationModeImpl mode) {\n+        this.invocations = invocations;\n+        return actualToReturn;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/MarkingVerifierTest.java\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+\n+public class MarkingVerifierTest extends RequiresValidState {\n+\n+    private ActualInvocationsFinderStub finderStub;\n+    private MarkingVerifier verifier;\n+    \n+    @Before\n+    public void setup() {\n+        finderStub = new ActualInvocationsFinderStub();\n+        verifier = new MarkingVerifier(finderStub);\n+    }\n+\n+    @Test\n+    public void shouldWorkOnlyWhenModeIsExplicit() {\n+        verifier = new MarkingVerifier(null);\n+        verifier.verify(null, null, noMoreInteractions());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerified() {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().toInvocation();\n+        \n+        assertFalse(invocation.isVerified());\n+        assertFalse(invocationTwo.isVerified());\n+        \n+        finderStub.actualToReturn.addAll(asList(invocation, invocationTwo));\n+        \n+        verifier.verify(asList(invocation, invocationTwo), null, atLeastOnce());\n+        \n+        assertTrue(invocation.isVerified());\n+        assertTrue(invocationTwo.isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifiedStrictly() {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().toInvocation();\n+        \n+        assertFalse(invocation.isVerifiedStrictly());\n+        assertFalse(invocationTwo.isVerifiedStrictly());\n+        \n+        finderStub.actualToReturn.addAll(asList(invocation, invocationTwo));\n+        \n+        verifier.verify(asList(invocation, invocationTwo), null, new VerificationModeBuilder().strict());\n+        \n+        assertTrue(invocation.isVerifiedStrictly());\n+        assertTrue(invocationTwo.isVerifiedStrictly());\n+    }\n+}\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n import static org.junit.Assert.*;\n import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n-import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n     }\n     \n-    @Test\n-    public void shouldMarkAsVerified() {\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n-        Invocation invocationTwo = new InvocationBuilder().toInvocation();\n-        finderStub.actualToReturn.add(invocation);\n-        finderStub.actualToReturn.add(invocationTwo);\n-        \n-        verifier.verify(invocations, wanted, atLeastOnce());\n-        assertTrue(invocation.isVerified());\n-        assertTrue(invocationTwo.isVerified());\n-    }\n-    \n-    class ActualInvocationsFinderStub extends ActualInvocationsFinder {\n-        private final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n-        private List<Invocation> invocations;\n-        @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n-                VerificationModeImpl mode) {\n-            this.invocations = invocations;\n-            return actualToReturn;\n-        }\n-    }\n-    \n     class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private Invocation similarToReturn;\n         private List<Invocation> invocations;\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n import static org.junit.Assert.*;\n import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n-import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         assertEquals(wanted.toString(), reporterStub.wanted);\n     }\n     \n-    @Test\n-    public void shouldMarkAsVerified() {\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n-        Invocation invocationTwo = new InvocationBuilder().toInvocation();\n-        finderStub.actualToReturn.add(invocation);\n-        finderStub.actualToReturn.add(invocationTwo);\n-        \n-        verifier.verify(invocations, wanted, times(2));\n-        assertTrue(invocation.isVerified());\n-        assertTrue(invocationTwo.isVerified());\n-    }\n-    \n     class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private HasStackTrace invocationTraceToReturn;\n         private List<Invocation> invocations;\n         @Override public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n             this.invocations = invocations;\n             return invocationTraceToReturn;\n-        }\n-    }\n-    \n-    class ActualInvocationsFinderStub extends ActualInvocationsFinder {\n-        private final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n-        @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-            return actualToReturn;\n         }\n     }\n     \n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n                     InvalidUseOfMatchersTest.class,\n                     DescriptiveMessagesOnStrictOrderErrorsTest.class,\n                     InvalidStateDetectionTest.class,\n-                    StackTrackeFilteringTest.class\n+                    StackTraceFilteringTest.class\n                 );\n                 \n                 if (!result.wasSuccessful()) {\n--- /dev/null\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n+\n+public class PointingStackTraceToActualInvocationTest extends RequiresValidState {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        \n+        firstChunk();\n+        secondChunk();\n+        thirdChunk();\n+        fourthChunk();\n+    }\n+\n+    private void firstChunk() {\n+        mock.simpleMethod(1);\n+        mock.simpleMethod(1);\n+    }\n+    private void secondChunk() {\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void thirdChunk() {\n+        mock.simpleMethod(3);\n+        mock.simpleMethod(3);\n+    }\n+    private void fourthChunk() {\n+        mockTwo.simpleMethod(4);\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    public void shouldPointStackTraceToActualInvocation() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocation() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedInvocation() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldPointToTooManyInvocationsChunk() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(anyInt());\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldPointToTooLittleInvocationsUnverifiChunk() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(anyInt());\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerify() {\n+        verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/StackTraceFilteringTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.StateResetter;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWantedError;\n+import org.mockito.exceptions.verification.VerificationError;\n+\n+public class StackTraceFilteringTest extends RequiresValidState {\n+    \n+    private IMethods mock;\n+\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Before\n+    public void setup() {\n+        resetState();\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerify() {\n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerify\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyNoMoreInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyZeroInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceOnMockitoException() {\n+        verify(mock);\n+        try {\n+            verify(mock).oneArg(true); \n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceOnMockitoException\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyVerifying() {\n+        Strictly strictly = createStrictOrderVerifier(mock);\n+        mock.oneArg(true);\n+        mock.oneArg(false);\n+        \n+        strictly.verify(mock).oneArg(false); \n+        try {\n+            strictly.verify(mock).oneArg(true);\n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyThrowsMockitoException() {\n+        try {\n+            createStrictOrderVerifier();\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyThrowsMockitoException\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyVerifies() {\n+        try {\n+            Strictly strictly = createStrictOrderVerifier(mock);\n+            strictly.verify(null);\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifies\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler() {\n+        try {\n+            stub(mock.oneArg(true)).andThrow(new Exception());\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromMockHandler\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldShowProperExceptionStackTrace() throws Exception {\n+        stub(mock.simpleMethod()).andThrow(new RuntimeException());\n+\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (RuntimeException e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldShowProperExceptionStackTrace\"));\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(-999);\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).oneArg(true);\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n+        } catch (VerificationError e) {}\n     }    \n     \n     @Test\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n import static org.mockito.Mockito.*;\n import static org.mockito.util.ExtraMatchers.*;\n \n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n public class ExactNumberOfTimesVerificationTest extends RequiresValidState {\n \n     @Before\n     public void setup() {\n-        mock = Mockito.mock(LinkedList.class);\n+        mock = mock(LinkedList.class);\n     }\n \n     @Test\n         mock.clear();\n         mock.clear();\n \n-        Mockito.verify(mock, times(2)).clear();\n+        verify(mock, times(2)).clear();\n         try {\n-            Mockito.verify(mock, times(100)).clear();\n+            verify(mock, times(100)).clear();\n             fail();\n         } catch (TooLittleActualInvocationsError e) {\n             assertThat(e, messageContains(\"Wanted 100 times but was 2\"));\n         mock.clear();\n         mock.clear();\n \n-        Mockito.verify(mock, times(2)).clear();\n+        verify(mock, times(2)).clear();\n         try {\n-            Mockito.verify(mock, times(1)).clear();\n+            verify(mock, times(1)).clear();\n             fail();\n         } catch (TooManyActualInvocationsError e) {\n             assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n \n     @Test\n     public void shouldDetectActualInvocationsCountIsMoreThanZero() throws Exception {\n-        Mockito.verify(mock, times(0)).clear();\n+        verify(mock, times(0)).clear();\n         try {\n-            Mockito.verify(mock, times(15)).clear();\n+            verify(mock, times(15)).clear();\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {\n-            assertThat(e, messageContains(\"Wanted 15 times but was 0\"));\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"Wanted but not invoked\"));\n         }\n     }\n \n         mock.clear();\n \n         try {\n-            Mockito.verify(mock, times(0)).clear();\n+            verify(mock, times(0)).clear();\n             fail();\n         } catch (TooManyActualInvocationsError e) {\n             assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n \n     @Test\n     public void shouldPassWhenMethodsActuallyNotCalled() throws Exception {\n-        Mockito.verify(mock, times(0)).clear();\n-        Mockito.verify(mock, times(0)).add(\"yes, I wasn't called\");\n+        verify(mock, times(0)).clear();\n+        verify(mock, times(0)).add(\"yes, I wasn't called\");\n     }\n \n     @Test\n     public void shouldNotCountInStubbedInvocations() throws Exception {\n-        Mockito.stub(mock.add(\"test\")).andReturn(false);\n-        Mockito.stub(mock.add(\"test\")).andReturn(true);\n+        stub(mock.add(\"test\")).andReturn(false);\n+        stub(mock.add(\"test\")).andReturn(true);\n \n         mock.add(\"test\");\n         mock.add(\"test\");\n \n-        Mockito.verify(mock, times(2)).add(\"test\");\n+        verify(mock, times(2)).add(\"test\");\n     }\n }\n--- a/test/org/mockitousage/verification/StrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationTest.java\n         try {\n             strictly.verify(mockOne, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n+        } catch (VerificationError e) {}\n     }\n }", "timestamp": 1198527327, "metainfo": ""}