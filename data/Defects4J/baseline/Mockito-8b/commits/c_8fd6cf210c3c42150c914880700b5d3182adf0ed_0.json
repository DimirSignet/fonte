{"sha": "8fd6cf210c3c42150c914880700b5d3182adf0ed", "log": "issue 352 : simplified Primitives, HandyReturnValues and ReturnsEmptyValues", "commit": "\n--- a/src/org/mockito/internal/progress/HandyReturnValues.java\n+++ b/src/org/mockito/internal/progress/HandyReturnValues.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n import static org.mockito.internal.util.Primitives.*;\n     }\n \n     public <T> T returnFor(Class<T> clazz) {\n-        if (isPrimitiveWrapper(clazz)) {\n-            return primitiveWrapperOf(clazz);\n+        // explicitly return null if type is not a primitive or a wrapper\n+        if (isPrimitiveOrWrapper(clazz)) {\n+            return defaultValueForPrimitiveOrWrapper(clazz);\n         } \n-        return primitiveValueOrNullFor(clazz);\n+        return null;\n     }\n \n     public Map returnMap() {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n     }\n     \n     Object returnValueFor(Class<?> type) {\n-        if (type.isPrimitive()) {\n-            return Primitives.primitiveValueOrNullFor(type);\n-        } else if (Primitives.isPrimitiveWrapper(type)) {\n-            return Primitives.primitiveWrapperOf(type);\n+        if (Primitives.isPrimitiveOrWrapper(type)) {\n+            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n         //new instances are used instead of Collections.emptyList(), etc.\n         //to avoid UnsupportedOperationException if code under test modifies returned collection\n         } else if (type == Collection.class) {\n             return new TreeMap<Object, Object>();\n         } else if (type == LinkedHashMap.class) {\n             return new LinkedHashMap<Object, Object>();\n-        }       \n+        }\n+        // TODO return empty Iterable ; see issue 175\n+\n         //Let's not care about the rest of collections.\n         return null;\n     }\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n \n @SuppressWarnings(\"unchecked\")\n public class Primitives {\n-    \n+\n+    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n+    private static Map<Class<?>, Object> primitiveOrWrapperDefaultValues = new HashMap<Class<?>, Object>();\n+\n+\n+    /**\n+     * Returns the primitive type of the given class.\n+     * <p/>\n+     * The passed class can be any class : <code>boolean.class</code>, <code>Integer.class</code>\n+     * in witch case this method will return <code>boolean.class</code>, even <code>SomeObject.class</code>\n+     * in which case <code>null</code> will be returned.\n+     *\n+     * @param clazz The class from which primitive type has to be retrieved\n+     * @param <T>   The type\n+     * @return The primitive type if relevant, otherwise <code>null</code>\n+     */\n     public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n-        if(clazz.isPrimitive()) {\n+        if (clazz.isPrimitive()) {\n             return clazz;\n         }\n         return (Class<T>) primitiveTypes.get(clazz);\n     }\n \n-    public static boolean isPrimitiveWrapper(Class<?> type) {\n-        return wrapperReturnValues.containsKey(type);\n+    /**\n+     * Indicates if the given class is primitive type or a primitive wrapper.\n+     *\n+     * @param type The type to check\n+     * @return <code>true</code> if primitive or wrapper, <code>false</code> otherwise.\n+     */\n+    public static boolean isPrimitiveOrWrapper(Class<?> type) {\n+        return primitiveOrWrapperDefaultValues.containsKey(type);\n     }\n \n-    public static <T> T primitiveWrapperOf(Class<T> type) {\n-        return (T) wrapperReturnValues.get(type);\n+    /**\n+     * Returns the boxed default value for a primitive or a primitive wrapper.\n+     *\n+     * @param primitiveOrWrapperType The type to lookup the default value\n+     * @return The boxed default values as defined in Java Language Specification,\n+     *         <code>null</code> if the type is neither a primitive nor a wrapper\n+     */\n+    public static <T> T defaultValueForPrimitiveOrWrapper(Class<T> primitiveOrWrapperType) {\n+        return (T) primitiveOrWrapperDefaultValues.get(primitiveOrWrapperType);\n     }\n \n-    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n-        return (T) primitiveValues.get(primitiveType);\n-    }\n-    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n-    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n-    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n-    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n \n     static {\n         primitiveTypes.put(Boolean.class, Boolean.TYPE);\n     }\n \n     static {\n-        wrapperReturnValues.put(Boolean.class, false);\n-        wrapperReturnValues.put(Character.class, '\\u0000');\n-        wrapperReturnValues.put(Byte.class, (byte) 0);\n-        wrapperReturnValues.put(Short.class, (short) 0);\n-        wrapperReturnValues.put(Integer.class, 0);\n-        wrapperReturnValues.put(Long.class, 0L);\n-        wrapperReturnValues.put(Float.class, 0F);\n-        wrapperReturnValues.put(Double.class, 0D);\n-    }\n+        primitiveOrWrapperDefaultValues.put(Boolean.class, false);\n+        primitiveOrWrapperDefaultValues.put(Character.class, '\\u0000');\n+        primitiveOrWrapperDefaultValues.put(Byte.class, (byte) 0);\n+        primitiveOrWrapperDefaultValues.put(Short.class, (short) 0);\n+        primitiveOrWrapperDefaultValues.put(Integer.class, 0);\n+        primitiveOrWrapperDefaultValues.put(Long.class, 0L);\n+        primitiveOrWrapperDefaultValues.put(Float.class, 0F);\n+        primitiveOrWrapperDefaultValues.put(Double.class, 0D);\n \n-    static {\n-        primitiveValues.put(boolean.class, false);\n-        primitiveValues.put(char.class, '\\u0000');\n-        primitiveValues.put(byte.class, (byte) 0);\n-        primitiveValues.put(short.class, (short) 0);\n-        primitiveValues.put(int.class, 0);\n-        primitiveValues.put(long.class, 0L);\n-        primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0D);\n+        primitiveOrWrapperDefaultValues.put(boolean.class, false);\n+        primitiveOrWrapperDefaultValues.put(char.class, '\\u0000');\n+        primitiveOrWrapperDefaultValues.put(byte.class, (byte) 0);\n+        primitiveOrWrapperDefaultValues.put(short.class, (short) 0);\n+        primitiveOrWrapperDefaultValues.put(int.class, 0);\n+        primitiveOrWrapperDefaultValues.put(long.class, 0L);\n+        primitiveOrWrapperDefaultValues.put(float.class, 0F);\n+        primitiveOrWrapperDefaultValues.put(double.class, 0D);\n     }\n }", "timestamp": 1341064195, "metainfo": ""}