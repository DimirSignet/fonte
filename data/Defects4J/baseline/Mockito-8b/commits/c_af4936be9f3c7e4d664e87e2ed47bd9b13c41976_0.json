{"sha": "af4936be9f3c7e4d664e87e2ed47bd9b13c41976", "log": "Merged with tip", "commit": "\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n  */\n package org.mockito;\n \n+import org.mockito.internal.stubbing.answers.ReturnsArgumentAt;\n import org.mockito.internal.stubbing.answers.ReturnsElementsOf;\n import org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations;\n import org.mockito.stubbing.Answer;\n-import org.mockito.internal.stubbing.answers.ReturnsArgumentAt;\n \n import java.util.Collection;\n \n \n     /**\n      * An answer that directly forwards the calls to the delegate.\n-     *\n-     * Makes sense only for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API.\n-     * Possible use cases:\n+     * <p>\n+     * Useful for spies or partial mocks of objects that are difficult to mock\n+     * or spy using the usual spy API. Possible use cases:\n      * <ul>\n      *     <li>Final classes but with an interface</li>\n      *     <li>Already custom proxied object</li>\n      *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n-     *     <li>...</li>\n      * </ul>\n-     * Sets the real implementation to be called when the method is called on a mock object.\n+     * For more details including the use cases reported by users take a look at\n+     * <a link=\"http://code.google.com/p/mockito/issues/detail?id=145\">issue 145</a>.\n+     * <p>\n+     * The difference with the regular spy:\n+     * <ul>\n+     *   <li>\n+     *     The regular spy ({@link Mockito#spy(Object)}) contains <strong>all</strong> state from the spied instance\n+     *     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.\n+     *     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered\n+     *     for verifications, and they can be effectively stubbed.\n+     *   </li>\n+     *   <li>\n+     *     The mock that delegates simply delegates all methods to the delegate.\n+     *     The delegate is used all the time as methods are delegated onto it.\n+     *     If you call a method on a mock that delegates and it internally calls other methods on this mock,\n+     *     those calls are <strong>not</strong> remembered for verifications, stubbing does not have effect on them, too.\n+     *     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.\n+     *   </li>\n+     * </ul>\n+     * An example with a final class that we want to delegate to:\n      * <p>\n      * <pre class=\"code\"><code class=\"java\">\n-     *   final class DontMessTheCodeOfThisList implements list { ... }\n+     *   final class DontYouDareToMockMe implements list { ... }\n      *\n-     *   DontMessTheCodeOfThisList awesomeList = new DontMessTheCodeOfThisList();\n+     *   DontYouDareToMockMe awesomeList = new DontYouDareToMockMe();\n      *\n-     *   List listWithDelegate = mock(List.class, delegatesTo(awesomeList));\n+     *   List mock = mock(List.class, delegatesTo(awesomeList));\n      * </code></pre>\n      *\n      * <p>\n-     * This features suffer from the same drawback as the spy.\n+     * This feature suffers from the same drawback as the spy.\n      * The mock will call the delegate if you use regular when().then() stubbing style.\n      * Since the real implementation is called this might have some side effects.\n      * Therefore you should to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *      <a href=\"#24\">24. (New) One-liner stubs (Since 1.9.0)</a><br/>\n  *      <a href=\"#25\">25. (New) Verification ignoring stubs (Since 1.9.0)</a><br/>\n  *      <a href=\"#26\">26. (**New**) Mocking details (Since 1.9.5)</a><br/>\n- *      <a href=\"#27\">27. (**New**) Forward calls to real instance (Since 1.9.5)</a><br/>\n- *      <a href=\"#28\">28. (**New**) Introduction of the internal <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n+ *      <a href=\"#27\">27. (**New**) Delegate calls to real instance (Since 1.9.5)</a><br/>\n+ *      <a href=\"#28\">28. (**New**) <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n  * </b>\n  * \n  * <p>\n  *\n  *\n  * <h3 id=\"27\">27. (**New**) <a class=\"meaningful_link\" href=\"#delegating_call_to_real_instance\">Delegate calls to real instance</a> (Since 1.9.5)</h3>\n- * <p>Now mockito offer a specific way to delegate calls to a concrete instance. This is different than the\n- * spy because the regular spy contains all the state of the spied instance. TODO SF - add more information.\n- *\n- * <p>Note that this feature only makes sense only for spies or partial mocks of objects <strong>that are difficult to\n- * mock or spy</strong> using the usual spy API.\n+ *\n+ * <p>Useful for spies or partial mocks of objects <strong>that are difficult to mock or spy</strong> using the usual spy API.\n  * Possible use cases:\n  * <ul>\n  *     <li>Final classes but with an interface</li>\n  *     <li>Already custom proxied object</li>\n  *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n- *     <li>...</li>\n  * </ul>\n  *\n- * Possible example with an object interacting with native objects and spy that would not work:\n- * <pre class=\"code\"><code class=\"java\">\n- *   InteractingWithNativeStuff theSpy = spy(interactingWithNativeStuff);\n- *\n- *   // Some time after the GC collect interactingWithNativeStuff as it not anymore used,\n- *   // the finalizer is executed, for example to call a C++ destructor.\n- *\n- *   // Later on, it's finally the spy to be garbage collected, finalize method is called again,\n- *   // unfortunately the second interaction with the native objects will crash the JVM.\n- * </code></pre>\n- * Now with the forwarding feature in place :\n- * <pre class=\"code\"><code class=\"java\">\n- *   InteractingWithNativeStuff native = mock(InteractingWithNativeStuff.class, AdditionalAnswers.delegateTo(interactingWithNativeStuff));\n- *\n- *   //TODO SF - I don't quite follow this example... spied instance is also something we hold in the MockSettings...\n- *   // OK, the mock keeps a reference to the interactingWithNativeStuff, so the finalize method never kicks in.\n- * </code></pre>\n- *\n- * <p>Friendly reminder that final Methods cannot be mocked, so if <code>finalize</code> is <code>final</code> the\n- * real code will still be executed.\n- *\n- * <p>\n- * See more information there {@link AdditionalAnswers#delegatesTo(Object)}.\n- *\n- *\n- *\n- *\n- * <h3 id=\"28\">28. (**New**) <a class=\"meaningful_link\" href=\"#mock_maker_plugin\">Introduction of the internal <code>MockMaker</code> API</a> (Since 1.9.5)</h3>\n- * <p>Thanks to Google Android guys, we now have a brand new extension that allows anyone to write his own mock maker engine.\n- *\n- * <p>How does that work ?\n+ * <p>The difference with the regular spy:\n  * <ul>\n- *     <li>For a Mockito user : Just put the alternate MockMaker plugin, say mockito-dex-maker.jar</li>\n- *     <li>For a Mockito developer :\n- *         <ol style=\"list-style-type: lower-alpha\">\n- *             <li>Write the implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n- *             <li>Place a file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n- *             <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n- *             the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n- *         </ol>\n- *     </li>\n+ *   <li>\n+ *     The regular spy ({@link #spy(Object)}) contains <strong>all</strong> state from the spied instance\n+ *     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.\n+ *     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered\n+ *     for verifications, and they can be effectively stubbed.\n+ *   </li>\n+ *   <li>\n+ *     The mock that delegates simply delegates all methods to the delegate.\n+ *     The delegate is used all the time as methods are delegated onto it.\n+ *     If you call a method on a mock that delegates and it internally calls other methods on this mock,\n+ *     those calls are <strong>not</strong> remembered for verifications, stubbing does not have effect on them, too.\n+ *     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.\n+ *   </li>\n  * </ul>\n  *\n- * <p>Note that if several <code>mockito-extensions/org.mockito.plugins.MockMaker</code> files exists in the classpath\n- * Mockito will only use the first returned by the standard {@link ClassLoader#getResource} mechanism.\n- *\n- * Take a look at the API : {@link org.mockito.plugins.MockMaker}\n+ * <p>\n+ * See more information in docs for {@link AdditionalAnswers#delegatesTo(Object)}.\n+ *\n+ *\n+ *\n+ *\n+ * <h3 id=\"28\">28. (**New**) <a class=\"meaningful_link\" href=\"#mock_maker_plugin\"><code>MockMaker</code> API</a> (Since 1.9.5)</h3>\n+ * <p>Driven by requirements and patches from Google Android guys Mockito now offers an extension point\n+ *   that allows replacing the proxy generation engine. By default, Mockito uses cglib to create dynamic proxies.\n+ * <p>The extension point is for advanced users that want to extend Mockito. For example, it is now possible\n+ *   to use Mockito for Android testing with a help of dexmaker.\n+ * <p>For more details, motivations and examples please refer to\n+ * the docs for {@link org.mockito.plugins.MockMaker}.\n  *\n  */\n @SuppressWarnings(\"unchecked\")\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/InvocationNotifierHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.handler;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+\n+import java.util.List;\n+\n+/**\n+ * Handler, that call all listeners wanted for this mock, before delegating it\n+ * to the parameterized handler.\n+ *\n+ * Also imposterize MockHandlerImpl, delegate all call of InternalMockHandler to the real mockHandler\n+ */\n+class InvocationNotifierHandler<T> implements MockHandler, InternalMockHandler<T> {\n+\n+    private List<InvocationListener> invocationListeners;\n+    private InternalMockHandler<T> mockHandler;\n+\n+    public InvocationNotifierHandler(InternalMockHandler<T> mockHandler, MockCreationSettings settings) {\n+        this.mockHandler = mockHandler;\n+        this.invocationListeners = settings.getInvocationListeners();\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+        try {\n+            Object returnedValue = mockHandler.handle(invocation);\n+            notifyMethodCall(invocation, returnedValue);\n+            return returnedValue;\n+        } catch (Throwable t){\n+            notifyMethodCallException(invocation, t);\n+            throw t;\n+        }\n+    }\n+\n+\n+\tprivate void notifyMethodCall(Invocation invocation, Object returnValue) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    private void notifyMethodCallException(Invocation invocation, Throwable exception) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockHandler.getMockSettings();\n+    }\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return mockHandler.voidMethodStubbable(mock);\n+    }\n+\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        mockHandler.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return mockHandler.getInvocationContainer();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/MockHandlerFactory.java\n+package org.mockito.internal.handler;\n+\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n+/**\n+ * by Szczepan Faber, created at: 5/21/12\n+ */\n+public class MockHandlerFactory {\n+\n+    public InternalMockHandler create(MockCreationSettings settings) {\n+        InternalMockHandler handler = new MockHandlerImpl(settings);\n+        InternalMockHandler nullResultGuardian = new NullResultGuardian(handler);\n+        InternalMockHandler notifier = new InvocationNotifierHandler(nullResultGuardian, settings);\n+\n+        return notifier;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/MockHandlerImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.handler;\n+\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.verification.MockAwareVerificationMode;\n+import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n+ */\n+class MockHandlerImpl<T> implements InternalMockHandler<T> {\n+\n+    private static final long serialVersionUID = -2917871070982574165L;\n+\n+    InvocationContainerImpl invocationContainerImpl;\n+    MatchersBinder matchersBinder = new MatchersBinder();\n+    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+\n+    private final MockCreationSettings mockSettings;\n+\n+    public MockHandlerImpl(MockCreationSettings mockSettings) {\n+        this.mockSettings = mockSettings;\n+        this.mockingProgress = new ThreadSafeMockingProgress();\n+        this.matchersBinder = new MatchersBinder();\n+        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n+            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+            return null;\n+        }\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n+\n+        mockingProgress.validateState();\n+\n+        // if verificationMode is not null then someone is doing verify()\n+        if (verificationMode != null) {\n+            // We need to check if verification was started on the correct mock\n+            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+            // TODO: can I avoid this cast here?\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+                verificationMode.verify(data);\n+                return null;\n+            } else {\n+                // this means there is an invocation on a different mock. Re-adding verification mode\n+                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+                mockingProgress.verificationStarted(verificationMode);\n+            }\n+        }\n+\n+        // prepare invocation for stubbing\n+        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+        // look for existing answer for this invocation\n+        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+        if (stubbedInvocation != null) {\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n+        } else {\n+             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n+        }\n+\t}\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n+    }\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        invocationContainerImpl.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return invocationContainerImpl;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/NullResultGuardian.java\n+package org.mockito.internal.handler;\n+\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.progress.HandyReturnValues;\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+\n+import java.util.List;\n+\n+/**\n+ * Protects the results from delegate MockHandler. Makes sure the results are valid.\n+ *\n+ * by Szczepan Faber, created at: 5/22/12\n+ */\n+class NullResultGuardian implements InternalMockHandler {\n+    private final InternalMockHandler delegate;\n+\n+    public NullResultGuardian(InternalMockHandler delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+        Object result = delegate.handle(invocation);\n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        if(result == null && returnType.isPrimitive()) {\n+            //primitive values cannot be null\n+            return new HandyReturnValues().returnFor(returnType);\n+        } else {\n+            return result;\n+        }\n+    }\n+\n+    //boring delegation:\n+\n+    public MockCreationSettings getMockSettings() {\n+        return delegate.getMockSettings();\n+    }\n+\n+    public VoidMethodStubbable voidMethodStubbable(Object mock) {\n+        return delegate.voidMethodStubbable(mock);\n+    }\n+\n+    public void setAnswersForStubbing(List answers) {\n+        delegate.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return delegate.getInvocationContainer();\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.InvocationNotifierHandler;\n-import org.mockito.internal.MockHandlerImpl;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockito.internal.handler.MockHandlerFactory;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockito.invocation.MockHandler;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n import org.mockito.plugins.MockMaker;\n     private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n \n     public <T> T createMock(MockCreationSettings<T> settings) {\n-        InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n-                new MockHandlerImpl<T>(settings), settings);\n+        MockHandler mockHandler = new MockHandlerFactory().create(settings);\n+\n         T mock = mockMaker.createMock(settings, mockHandler);\n \n         Object spiedInstance = settings.getSpiedInstance();\n     }\n \n     public <T> void resetMock(T mock) {\n-        InvocationNotifierHandler oldHandler = (InvocationNotifierHandler) getMockHandler(mock);\n+        InternalMockHandler oldHandler = (InternalMockHandler) getMockHandler(mock);\n         MockCreationSettings settings = oldHandler.getMockSettings();\n-        InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n-                new MockHandlerImpl<T>(settings), settings);\n+        MockHandler newHandler = new MockHandlerFactory().create(settings);\n+\n         mockMaker.resetMock(mock, newHandler, settings);\n     }\n \n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.concurrentmockito;\n+\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n import org.junit.runner.Result;\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.MockHandlerImplTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.handler.MockHandlerImplTest;\n import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationsFinderTest;\n import org.mockitousage.stubbing.BasicStubbingTest;\n import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n-import org.mockitousage.verification.AtMostXVerificationTest;\n-import org.mockitousage.verification.BasicVerificationInOrderTest;\n-import org.mockitousage.verification.BasicVerificationTest;\n-import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;\n-import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;\n-import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n-import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n-import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n-import org.mockitousage.verification.RelaxedVerificationInOrderTest;\n-import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderTest;\n-import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n-import org.mockitousage.verification.VerificationUsingMatchersTest;\n+import org.mockitousage.verification.*;\n import org.mockitoutil.TestBase;\n \n import java.util.LinkedList;\n--- /dev/null\n+++ b/test/org/mockito/internal/handler/InvocationNotifierHandlerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.handler;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.BDDMockito.willThrow;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyList;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+\n+@RunWith(MockitoJUnitRunner.class)\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationNotifierHandlerTest {\n+    private static final String SOME_LOCATION = \"some location\";\n+    private static final RuntimeException SOME_EXCEPTION = new RuntimeException();\n+    private static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();\n+    private static final Answer SOME_ANSWER = mock(Answer.class);\n+\n+\n+    @Mock private InvocationListener listener1;\n+    @Mock private InvocationListener listener2;\n+    @Spy private CustomListener customListener;\n+\n+    @Mock private Invocation invocation;\n+    @Mock private MockHandlerImpl mockHandler;\n+\n+    private InvocationNotifierHandler notifier;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        notifier = new InvocationNotifierHandler(\n+                mockHandler,\n+                (MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)\n+        );\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_calling_delegate_handler() throws Throwable {\n+        // given\n+        given(mockHandler.handle(invocation)).willReturn(\"returned value\");\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_called_delegate_handler_returns_ex() throws Throwable {\n+        // given\n+        Exception computedException = new Exception(\"computed\");\n+        given(mockHandler.handle(invocation)).willReturn(computedException);\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it() throws Throwable {\n+        // given\n+        ParseException parseException = new ParseException(\"\", 0);\n+        given(mockHandler.handle(invocation)).willThrow(parseException);\n+\n+        // when\n+        try {\n+            notifier.handle(invocation);\n+            fail();\n+        } finally {\n+            // then\n+            verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+            verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+        }\n+    }\n+\n+    @Test\n+    public void should_report_listener_exception() throws Throwable {\n+        willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));\n+\n+        try {\n+            notifier.handle(invocation);\n+            fail();\n+        } catch (MockitoException me) {\n+            assertThat(me.getMessage())\n+                    .contains(\"invocation listener\")\n+                    .contains(\"CustomListener\")\n+                    .contains(\"threw an exception\")\n+                    .contains(\"NullPointerException\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() throws Exception {\n+        notifier.getInvocationContainer();\n+        notifier.getMockSettings();\n+        notifier.voidMethodStubbable(mock(IMethods.class));\n+        notifier.setAnswersForStubbing(new ArrayList<Answer>());\n+\n+        verify(mockHandler).getInvocationContainer();\n+        verify(mockHandler).getMockSettings();\n+        verify(mockHandler).voidMethodStubbable(any());\n+        verify(mockHandler).setAnswersForStubbing(anyList());\n+    }\n+\n+    private static class CustomListener implements InvocationListener {\n+        public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+            // nop\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/handler/MockHandlerFactoryTest.java\n+package org.mockito.internal.handler;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+/**\n+ * by Szczepan Faber, created at: 5/22/12\n+ */\n+public class MockHandlerFactoryTest extends TestBase {\n+\n+    IMethods mock = Mockito.mock(IMethods.class);\n+\n+    @Test\n+    //see issue 331\n+    public void handle_result_must_not_be_null_for_primitives() throws Throwable {\n+        //given:\n+        MockCreationSettings settings = (MockCreationSettings) new MockSettingsImpl().defaultAnswer(new Returns(null));\n+        InternalMockHandler handler = new MockHandlerFactory().create(settings);\n+\n+        mock.intReturningMethod();\n+        Invocation invocation = super.getLastInvocation();\n+\n+        //when:\n+        Object result = handler.handle(invocation);\n+\n+        //then null value is not a valid result for a primitive\n+        assertNotNull(result);\n+        assertEquals(0, result);\n+    }\n+\n+    @Test\n+    //see issue 331\n+    public void valid_handle_result_is_permitted() throws Throwable {\n+        //given:\n+        MockCreationSettings settings = (MockCreationSettings) new MockSettingsImpl().defaultAnswer(new Returns(123));\n+        InternalMockHandler handler = new MockHandlerFactory().create(settings);\n+\n+        mock.intReturningMethod();\n+        Invocation invocation = super.getLastInvocation();\n+\n+        //when:\n+        Object result = handler.handle(invocation);\n+\n+        //then\n+        assertEquals(123, result);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/handler/MockHandlerImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.handler;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.Arrays;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings({ \"unchecked\", \"serial\" })\n+public class MockHandlerImplTest extends TestBase {\n+\n+\tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n+\tprivate Invocation invocation = mock(InvocationImpl.class);\n+\n+\n+\t@Test\n+\tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+\t\t// given\n+\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());\n+\t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+\t\thandler.matchersBinder = new MatchersBinder() {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\t\tthrow new InvalidUseOfMatchersException();\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\thandler.handle(invocation);\n+\n+\t\t\t// then\n+\t\t\tfail();\n+\t\t} catch (InvalidUseOfMatchersException e) {\n+\t\t}\n+\n+\t\tassertNull(handler.mockingProgress.pullVerificationMode());\n+\t}\n+\n+\n+\n+\n+\t@Test(expected = MockitoException.class)\n+\tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n+\t\t// given\n+\t\tInvocationListener throwingListener = mock(InvocationListener.class);\n+\t\tdoThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));\n+\t\tMockHandlerImpl<?> handler = createCorrectlyStubbedHandler(throwingListener);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\t}\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n+\t\tMockHandlerImpl<?> handler = createHandlerWithListeners(throwingListener);\n+\t\tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+\t\treturn handler;\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandlerImpl<?> handler) {\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);\n+\t}\n+\n+\n+\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {\n+\t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);\n+\t}\n+\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createHandlerWithListeners(InvocationListener... listener) {\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));\n+\t\thandler.matchersBinder = mock(MatchersBinder.class);\n+\t\tgiven(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));\n+\t\treturn handler;\n+\t}\n+}\n--- a/src/org/mockito/MockingDetails.java\n+++ b/src/org/mockito/MockingDetails.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n-import org.mockito.internal.util.DefaultMockingDetails;\n-import org.mockito.internal.util.MockUtil;\n-\n /**\n- * Class to inspect any object, and identify whether a particular object is either a mock or a spy.\n+ * Provides mocking information.\n+ * For example, you can identify whether a particular object is either a mock or a spy.\n  *\n  * @since 1.9.5\n  */\n-public abstract class MockingDetails {\n+public interface MockingDetails {\n     \n-\n     /**\n-     * Create a MockingDetails to inspect a particular Object.\n-     * @param toInspect the object to inspect\n-     * @return A {@link org.mockito.MockingDetails} instance.\n-     *\n-     * @since 1.9.5\n-     */\n-    public static MockingDetails of( Object toInspect ){\n-        return new DefaultMockingDetails( toInspect, new MockUtil());\n-    }\n-\n-    /**\n-     * Find out whether the object is a mock.\n+     * Informs if the object is a mock.\n      * @return true if the object is a mock or a spy.\n      *\n      * @since 1.9.5\n      */\n-    public abstract boolean isMock();\n+    boolean isMock();\n \n     /**\n-     * Find out whether the object is a spy.\n+     * Informs if the object is a spy.\n      * @return true if the object is a spy.\n      *\n      * @since 1.9.5\n      */\n-    public abstract boolean isSpy();\n-}\n-\n+    boolean isSpy();\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *\n  * <h3 id=\"26\">26. (**New**) <a class=\"meaningful_link\" href=\"#mocking_details\">Mocking details</a> (Since 1.9.5)</h3>\n  * <p>\n- * To identify whether a particular object is a mock or a spy, you can write\n- * <pre class=\"code\"><code class=\"java\">\n- *     MockingDetails.of( someObject ).isMock();\n- *     MockingDetails.of( someObject ).isSpy();\n+ * To identify whether a particular object is a mock or a spy:\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     Mockito.mockingDetails(someObject).isMock();\n+ *     Mockito.mockingDetails(someObject).isSpy();\n  * </code></pre>\n  * Both the {@link MockingDetails#isMock} and {@link MockingDetails#isSpy()} methods return <code>boolean</code>.\n- * As a spy is considered a special kind of mock, <code>isMock()</code> returns true if the object is a spy.\n+ * As a spy is just a different kind of mock, <code>isMock()</code> returns true if the object is a spy.\n+ * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,\n+ * e.g. invocations, stubbing info, etc.\n  *\n  *\n  *\n                 .name(name)\n                 .defaultAnswer(RETURNS_DEFAULTS));\n     }\n+\n+    /**\n+     * Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.\n+     * Can be used to find out if given object is a Mockito mock\n+     * or to find out if a given mock is a spy or mock.\n+     * <p>\n+     * In future Mockito versions MockingDetails may grow and provide other useful information about the mock,\n+     * e.g. invocations, stubbing info, etc.\n+     *\n+     * @param toInspect - object to inspect\n+     * @return A {@link org.mockito.MockingDetails} instance.\n+     * @since 1.9.5\n+     */\n+    public static MockingDetails mockingDetails(Object toInspect) {\n+        return MOCKITO_CORE.mockingDetails(toInspect);\n+    }\n     \n     /**\n      * <b>Deprecated : Please use mock(Foo.class, defaultAnswer);</b>\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.InOrder;\n import org.mockito.MockSettings;\n+import org.mockito.MockingDetails;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\n import org.mockito.internal.stubbing.StubberImpl;\n+import org.mockito.internal.util.DefaultMockingDetails;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n         }\n         return mocks;\n     }\n+\n+    public MockingDetails mockingDetails(Object toInspect) {\n+        return new DefaultMockingDetails(toInspect, new MockUtil());\n+    }\n }\n--- a/src/org/mockito/internal/util/DefaultMockingDetails.java\n+++ b/src/org/mockito/internal/util/DefaultMockingDetails.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.MockingDetails;\n  * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n  * a wrapper for {@link org.mockito.internal.util.MockUtil}.\n  */\n-public class DefaultMockingDetails extends MockingDetails {\n+public class DefaultMockingDetails implements MockingDetails {\n \n     private Object toInspect;\n     private MockUtil delegate;\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MockingDetailsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+\n+public class MockingDetailsTest {\n+    \n+    private static class TestClass{\n+    }\n+\n+    @Mock\n+    TestClass mock1;\n+    @Spy\n+    TestClass spy1;\n+    TestClass mock2;\n+    TestClass spy2;\n+    TestClass nonMock;\n+    \n+    @Before\n+    public void setUp(){\n+        initMocks( this );\n+        mock2 = mock( TestClass.class );\n+        spy2 = spy( new TestClass());\n+        nonMock = new TestClass();\n+    }\n+    \n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForAnnotatedMock(){\n+        assertTrue(mockingDetails(mock1).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForDirectMock(){\n+        assertTrue(mockingDetails(mock2).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForAnnotatedSpy(){\n+        assertTrue(mockingDetails(spy1).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForDirectSpy(){\n+\n+        assertTrue(mockingDetails(spy2).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsMock_ForNonMock(){\n+        assertFalse(mockingDetails(nonMock).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForAnnotatedMock(){\n+        assertFalse(mockingDetails(mock1).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForDirectMock(){\n+        assertFalse(mockingDetails(mock2).isSpy());\n+    }\n+\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsSpy_ForAnnotatedSpy(){\n+        assertTrue(mockingDetails(spy1).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsSpy_ForDirectSpy(){\n+        assertTrue(mockingDetails(spy2).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForNonMock(){\n+        assertFalse(mockingDetails(nonMock).isSpy());\n+    }\n+}", "timestamp": 1338677719, "metainfo": ""}