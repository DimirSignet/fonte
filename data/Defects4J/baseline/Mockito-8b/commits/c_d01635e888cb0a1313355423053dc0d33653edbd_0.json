{"sha": "d01635e888cb0a1313355423053dc0d33653edbd", "log": "Fixed the issue that sometimes arguments didn't equal but toString() with the same value (e.g. Integer & Long case). Therefore the actual printing of args is now a bit smarter and attaches the types when necessary  --HG-- rename : src/org/mockito/internal/invocation/CanPrintInMultilines.java => src/org/mockito/internal/invocation/PrintingFriendlyInocation.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401464", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n package org.mockito.internal;\n \n import java.util.Arrays;\n+import java.util.List;\n \n import org.mockito.InOrder;\n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.OngoingStubbingImpl;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.StubberImpl;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n     public void validateMockitoUsage() {\n         mockingProgress.validateState();\n     }\n+\n+    /**\n+     * For testing purposes only. Is not the part of main API.\n+     */\n+    public Invocation getLastInvocation() {\n+        OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n+        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations().getAll();\n+        return allInvocations.get(allInvocations.size()-1);\n+    }\n }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.List;\n \n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n+import org.hamcrest.SelfDescribing;\n import org.hamcrest.StringDescription;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.MatchersPrinter;\n+import org.mockito.internal.matchers.HasVerboseVariant;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n  * Contains stack trace of invocation\n  */\n @SuppressWarnings(\"unchecked\")\n-public class Invocation implements PrintableInvocation, InvocationOnMock, CanPrintInMultilines {\n+public class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInocation {\n \n     private static final int MAX_LINE_LENGTH = 45;\n     private final int sequenceNumber;\n     }\n \n     public String toString() {\n-        return toString(argumentsToMatchers(), false);\n-    }\n-\n-    public boolean printsInMultilines() {\n-        return toString().contains(\"\\n\");\n-    }\n-\n-    public String toMultilineString() {\n-        return toString(argumentsToMatchers(), true);\n-    }\n-\n-    protected String toString(List<Matcher> matchers, boolean forceMultiline) {\n+        return toString(argumentsToMatchers(), new PrintSettings());\n+    }\n+\n+    protected String toString(List<Matcher> matchers, PrintSettings printSettings) {\n+        MatchersPrinter matchersPrinter = new MatchersPrinter();\n         String method = qualifiedMethodName();\n-        String invocation = method + getArgumentsLine(matchers);\n-        if (forceMultiline || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n-            return method + getArgumentsBlock(matchers);\n+        String invocation = method + matchersPrinter.getArgumentsLine(matchers, printSettings);\n+        if (printSettings.isMultiline() || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n+            return method + matchersPrinter.getArgumentsBlock(matchers, printSettings);\n         } else {\n             return invocation;\n         }\n \n     private String qualifiedMethodName() {\n         return new MockUtil().getMockName(mock) + \".\" + method.getName();\n-    }\n-\n-    private String getArgumentsLine(List<Matcher> matchers) {\n-        Description result = new StringDescription();\n-        result.appendList(\"(\", \", \", \");\", matchers);\n-        return result.toString();\n-    }\n-\n-    private String getArgumentsBlock(List<Matcher> matchers) {\n-        Description result = new StringDescription();\n-        result.appendList(\"(\\n    \", \",\\n    \", \"\\n);\", matchers);\n-        return result.toString();\n     }\n \n     protected List<Matcher> argumentsToMatchers() {\n     }\n \n     public static boolean isToString(Method method) {\n-        return method.getReturnType() == String.class && method.getParameterTypes().length == 0 && method.getName().equals(\"toString\");\n+        return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n+                && method.getName().equals(\"toString\");\n     }\n \n     public boolean isValidException(Throwable throwable) {\n     public Object callRealMethod() throws Throwable {\n         return realMethod.invoke(mock, arguments);\n     }\n-}\n+\n+    public String toString(PrintSettings printSettings) {\n+        return toString(argumentsToMatchers(), printSettings);\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class InvocationMatcher implements PrintableInvocation, CanPrintInMultilines {\n+public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInocation {\n \n     private final Invocation invocation;\n     private final List<Matcher> matchers;\n     }\n     \n     /* (non-Javadoc)\n-     * @see org.mockito.internal.invocation.CanPrintInMultilines#toString()\n+     * @see org.mockito.internal.invocation.PrintingFriendlyInocation#toString()\n      */\n     public String toString() {\n-        return invocation.toString(matchers, false);\n+        return invocation.toString(matchers, new PrintSettings());\n     }\n \n     /* (non-Javadoc)\n-     * @see org.mockito.internal.invocation.CanPrintInMultilines#hasMultilinePrint()\n+     * @see org.mockito.internal.invocation.PrintingFriendlyInocation#hasMultilinePrint()\n      */\n     public boolean printsInMultilines() {        \n         return toString().contains(\"\\n\");\n     }\n-\n-    /* (non-Javadoc)\n-     * @see org.mockito.internal.invocation.CanPrintInMultilines#toMultilineString()\n-     */\n-    public String toMultilineString() {\n-        return invocation.toString(matchers, true);\n-    }    \n \n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n+\n+    public String toString(PrintSettings printSettings) {\n+        return invocation.toString(matchers, printSettings);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/PrintSettings.java\n+package org.mockito.internal.invocation;\n+\n+public class PrintSettings {\n+\n+    private boolean multiline;\n+    private boolean verboseArguments;\n+\n+    public void setMultiline(boolean multiline) {\n+        this.multiline = multiline;\n+    }\n+\n+    public void setVerboseArguments(boolean verboseArguments) {\n+        this.verboseArguments = verboseArguments;\n+    }\n+\n+    public boolean isMultiline() {\n+        return multiline;\n+    }\n+\n+    public boolean isVerboseArguments() {\n+        return verboseArguments;\n+    }\n+\n+    public static PrintSettings verboseArgs() {\n+        PrintSettings settings = new PrintSettings();\n+        settings.verboseArguments = true;\n+        return settings;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/PrintingFriendlyInocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+public interface PrintingFriendlyInocation {\n+\n+    String toString(PrintSettings printSettings);\n+\n+}\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n package org.mockito.internal.matchers;\n \n import org.hamcrest.Description;\n+import org.hamcrest.SelfDescribing;\n import org.mockito.ArgumentMatcher;\n \n-\n-public class Equals extends ArgumentMatcher<Object> {\n+public class Equals extends ArgumentMatcher<Object> implements HasVerboseVariant {\n \n     private final Object wanted;\n \n     }\n \n     public void describeTo(Description description) {\n-        appendQuoting(description);\n-        if (wanted == null) {\n-            description.appendText(\"null\");\n-        } else {\n-            description.appendText(wanted.toString());\n-        }\n-        appendQuoting(description);\n+        description.appendText(describe(wanted));\n     }\n \n-    private void appendQuoting(Description description) {\n+    public String describe(Object object) {\n+        String text = quoting();\n+        if (object == null) {\n+            text+=\"null\";\n+        } else {\n+            text+=object.toString();\n+        }\n+        text+= quoting();\n+        return text;\n+    }\n+\n+    private String quoting() {\n         if (wanted instanceof String) {\n-            description.appendText(\"\\\"\");\n+            return \"\\\"\";\n         } else if (wanted instanceof Character) {\n-            description.appendText(\"'\");\n+            return \"'\";\n+        } else {\n+            return \"\";\n         }\n     }\n \n             return false;\n         }\n         Equals other = (Equals) o;\n-        return this.wanted == null && other.wanted == null\n-                || this.wanted != null\n-                && this.wanted.equals(other.wanted);\n+        return this.wanted == null && other.wanted == null || this.wanted != null && this.wanted.equals(other.wanted);\n     }\n \n     @Override\n     public int hashCode() {\n         throw new UnsupportedOperationException(\"hashCode() is not supported\");\n     }\n+\n+    public SelfDescribing getVerboseVariant() {\n+        return new SelfDescribing() {\n+            public void describeTo(Description description) {\n+                description.appendText(describe(\"(\"+ wanted.getClass().getSimpleName() +\") \" + wanted));\n+            }};\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/HasVerboseVariant.java\n+package org.mockito.internal.matchers;\n+\n+import org.hamcrest.SelfDescribing;\n+\n+public interface HasVerboseVariant {\n+    SelfDescribing getVerboseVariant();\n+}\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n \n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n+import org.hamcrest.SelfDescribing;\n import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class LocalizedMatcher implements Matcher {\n+public class LocalizedMatcher implements Matcher, HasVerboseVariant {\n \n     private final Matcher actualMatcher;\n     private Location location;\n     public String toString() {\n         return \"Localized: \" + this.actualMatcher;\n     }\n+\n+    public SelfDescribing getVerboseVariant() {\n+        if (actualMatcher instanceof HasVerboseVariant) {\n+            return ((HasVerboseVariant) actualMatcher).getVerboseVariant();\n+        } else {\n+            return this;\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/MatchersPrinter.java\n+package org.mockito.internal.matchers;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.SelfDescribing;\n+import org.hamcrest.StringDescription;\n+import org.mockito.internal.invocation.PrintSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MatchersPrinter {\n+    \n+    public String getArgumentsLine(List<Matcher> matchers, PrintSettings printSettings) {\n+        Description result = new StringDescription();\n+        result.appendList(\"(\", \", \", \");\", applyPrintSettings(matchers, printSettings));\n+        return result.toString();\n+    }\n+\n+    public String getArgumentsBlock(List<Matcher> matchers, PrintSettings printSettings) {\n+        Description result = new StringDescription();\n+        result.appendList(\"(\\n    \", \",\\n    \", \"\\n);\", applyPrintSettings(matchers, printSettings));\n+        return result.toString();\n+    }\n+\n+    private List<SelfDescribing> applyPrintSettings(List<Matcher> matchers, PrintSettings printSettings) {\n+        if (printSettings.isVerboseArguments()) {\n+            List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing>();\n+            for (final Matcher matcher : matchers) {\n+                if (matcher instanceof HasVerboseVariant) {\n+                    withPrintSettings.add(((HasVerboseVariant) matcher).getVerboseVariant());\n+                } else {\n+                    withPrintSettings.add(matcher);\n+                }\n+            }\n+            return withPrintSettings;\n+        } else {\n+            return (List) matchers;\n+        }\n+    }\n+\n+}\n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n         mockitoStubber.addAnswer(answer);\n         return new ConsecutiveStubbing<T>(mockitoStubber);\n     }\n+\n+    public RegisteredInvocations getRegisteredInvocations() {\n+        return registeredInvocations;\n+    }\n }\n--- a/src/org/mockito/internal/verification/SyncingPrinter.java\n+++ b/src/org/mockito/internal/verification/SyncingPrinter.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.CanPrintInMultilines;\n+import org.mockito.internal.invocation.PrintSettings;\n+import org.mockito.internal.invocation.PrintingFriendlyInocation;\n \n public class SyncingPrinter {\n \n     private final String wanted;\n     private final String actual;\n \n-    public SyncingPrinter(CanPrintInMultilines wanted, CanPrintInMultilines actual) {\n-        if (wanted.printsInMultilines() || actual.printsInMultilines()) {\n-            this.wanted = wanted.toMultilineString();\n-            this.actual = actual.toMultilineString();\n-        } else {\n-            this.wanted = wanted.toString();\n-            this.actual = actual.toString();\n-        }\n+    public SyncingPrinter(PrintingFriendlyInocation wanted, PrintingFriendlyInocation actual) {\n+        PrintSettings printSettings = new PrintSettings();\n+        printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n+        //TODO: after 1.8 think about something smarter here. \n+        //Let's have an information on what specific arguments have happened to have the same toString() but aren't equal() \n+        printSettings.setVerboseArguments(wanted.toString().equals(actual.toString()));\n+        \n+        this.wanted = wanted.toString(printSettings);\n+        this.actual = actual.toString(printSettings);\n     }\n \n     public String getWanted() {\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n     \n     @Test\n     public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n-        CanPrintInMultilines withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n-        CanPrintInMultilines withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n+        PrintingFriendlyInocation withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n+        PrintingFriendlyInocation withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n \n         assertFalse(withOneArg.equals(null));\n         assertFalse(withOneArg.equals(withTwoArgs));\n--- a/test/org/mockito/internal/matchers/EqualsTest.java\n+++ b/test/org/mockito/internal/matchers/EqualsTest.java\n  */\n package org.mockito.internal.matchers;\n \n+import org.hamcrest.SelfDescribing;\n+import org.hamcrest.StringDescription;\n import org.junit.Test;\n import org.mockitoutil.TestBase;\n \n         } catch (UnsupportedOperationException expected) {\n         }\n     }\n+    \n+    @Test\n+    public void shouldGiveVerboselyDescribedVersionOfInt() throws Exception {\n+        String descStr = describe(new Equals(100).getVerboseVariant());\n+        \n+        assertEquals(\"(Integer) 100\", descStr);\n+    }\n+\n+    @Test\n+    public void shouldGiveVerboselyDescribedVersionOfLong() throws Exception {\n+        String descStr = describe(new Equals(100L).getVerboseVariant());\n+        \n+        assertEquals(\"(Long) 100\", descStr);\n+    }\n+    \n+    @Test\n+    public void shouldAppendQuotingForString() {\n+        String descStr = describe(new Equals(\"str\"));\n+        \n+        assertEquals(\"\\\"str\\\"\", descStr);\n+    }\n+\n+    @Test\n+    public void shouldAppendQuotingForChar() {\n+        String descStr = describe(new Equals('s'));\n+        \n+        assertEquals(\"'s'\", descStr);\n+    }\n+    \n+    @Test\n+    public void shouldDescribeUsingToString() {\n+        String descStr = describe(new Equals(100));\n+        \n+        assertEquals(\"100\", descStr);\n+    }\n+\n+    @Test\n+    public void shouldDescribeNull() {\n+        String descStr = describe(new Equals(null));\n+        \n+        assertEquals(\"null\", descStr);\n+    }\n+\n+    private String describe(SelfDescribing m) {\n+        StringDescription desc = new StringDescription();\n+        m.describeTo(desc);\n+        String descStr = desc.toString();\n+        return descStr;\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/matchers/MatchersPrinterTest.java\n+package org.mockito.internal.matchers;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.PrintSettings;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MatchersPrinterTest extends TestBase {\n+\n+    MatchersPrinter printer = new MatchersPrinter();\n+\n+    @Test\n+    public void shouldGetArgumentsLine() {\n+        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());\n+        assertEquals(\"(1, 2);\", line);\n+    }\n+\n+    @Test\n+    public void shouldGetArgumentsBlock() {\n+        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());\n+        assertEquals(\"(\\n    1,\\n    2\\n);\", line);\n+    }\n+\n+    @Test\n+    public void shouldGetVerboseArguments() {\n+        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseArgs());\n+        assertEquals(\"((Long) 1, (Integer) 2);\", line);\n+    }\n+\n+    @Test\n+    public void shouldGetVerboseArgumentsInBlock() {\n+        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseArgs());\n+        assertEquals(\"(\\n    (Long) 1,\\n    (Integer) 2\\n);\", line);\n+    }\n+\n+    @Test\n+    public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose() {\n+        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL), PrintSettings.verboseArgs());\n+        assertEquals(\"((Long) 1, notNull());\", line);\n+    }\n+}\n--- a/test/org/mockito/internal/verification/SyncingPrinterTest.java\n+++ b/test/org/mockito/internal/verification/SyncingPrinterTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.CanPrintInMultilines;\n+import org.mockito.Mock;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.PrintingFriendlyInocation;\n+import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class SyncingPrinterTest extends TestBase {\n \n-    private CanPrintInMultilines multi;\n-    private CanPrintInMultilines normal;\n+    private PrintingFriendlyInocation multi;\n+    private PrintingFriendlyInocation shortie;\n+    @Mock private IMethods mock;\n \n     @Before\n-    public void setup() {\n-        multi = new CanPrintInMultilinesStub(true, \"multi\", \"normal\");\n-        normal = new CanPrintInMultilinesStub(false, \"multi\", \"normal\");\n+    public void setup() throws Exception {\n+        mock.varargs(\"first very long argument\", \"second very long argument\", \"another very long argument\");\n+        multi = getLastInvocation();\n+        multi.toString();\n+        \n+        mock.varargs(\"short arg\");\n+        shortie = getLastInvocation();\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInMultilinesWhenFirstIsMulti() {\n+        //when\n+        SyncingPrinter printer = new SyncingPrinter(multi, shortie);\n+        \n+        //then\n+        assertContains(\"\\n\", printer.getWanted().toString());\n+        assertContains(\"\\n\", printer.getActual().toString());\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInMultilinesWhenSecondIsMulti() {\n+        //when\n+        SyncingPrinter printer = new SyncingPrinter(shortie, multi);\n+        \n+        //then\n+        assertContains(\"\\n\", printer.getWanted().toString());\n+        assertContains(\"\\n\", printer.getActual().toString());\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInMultilinesWhenBothAreMulti() {\n+        //when\n+        SyncingPrinter printer = new SyncingPrinter(multi, multi);\n+        \n+        //then\n+        assertContains(\"\\n\", printer.getWanted().toString());\n+        assertContains(\"\\n\", printer.getActual().toString());\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInSingleLineWhenBothAreShort() {\n+        //when\n+        SyncingPrinter printer = new SyncingPrinter(shortie, shortie);\n+        \n+        //then\n+        assertNotContains(\"\\n\", printer.getWanted().toString());\n+        assertNotContains(\"\\n\", printer.getActual().toString());\n     }\n     \n     @Test\n-    public void shouldPrintBothInMultilinesWhenAtLeastOneIsMulti() {\n-        SyncingPrinter printer = new SyncingPrinter(multi, normal);\n-        assertEquals(\"multi\", printer.getWanted().toString());\n-        assertEquals(\"multi\", printer.getActual().toString());\n+    public void shouldPrintVerboseArgumentsWhenStringOutputIsTheSame() {\n+        //given\n+        mock.longArg(1);\n+        Invocation withLongArg = getLastInvocation();\n         \n-        printer = new SyncingPrinter(normal, multi);\n-        assertEquals(\"multi\", printer.getWanted().toString());\n-        assertEquals(\"multi\", printer.getActual().toString());\n+        mock.longArg(1);\n+        Invocation withIntArg = getLastInvocation();\n         \n-        printer = new SyncingPrinter(multi, multi);\n-        assertEquals(\"multi\", printer.getWanted().toString());\n-        assertEquals(\"multi\", printer.getActual().toString());\n-    }\n-    \n-    @Test\n-    public void shouldPrintBothInSingleLine() {\n-        SyncingPrinter printer = new SyncingPrinter(normal, normal);\n-        assertEquals(\"normal\", printer.getWanted().toString());\n-        assertEquals(\"normal\", printer.getActual().toString());\n-    }\n-\n-    static class CanPrintInMultilinesStub implements CanPrintInMultilines {\n-        private final boolean printsInMultilines;\n-        private final String multilineString;\n-        private final String normalString;\n-\n-        public CanPrintInMultilinesStub(boolean printsInMultilines, String multilineString, String normalString) {\n-            this.printsInMultilines = printsInMultilines;\n-            this.multilineString = multilineString;\n-            this.normalString = normalString;\n-        }\n+        //when\n+        SyncingPrinter printer = new SyncingPrinter(withLongArg, withIntArg);\n         \n-        public boolean printsInMultilines() {\n-            return printsInMultilines;\n-        }\n-\n-        public String toMultilineString() {\n-            return multilineString;\n-        }\n-        \n-        public String toString() {\n-            return normalString;\n-        }\n+        //then\n+        assertContains(\"longArg((Long) 1)\", printer.getWanted().toString());\n+        assertContains(\"longArg((Long) 1)\", printer.getActual().toString());\n     }\n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     Object collectionArgMethod(Collection<String> collection);\n \n     Object setArgMethod(Set<String> set);\n+\n+    void longArg(long longArg);\n }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/EqWithIntsDoesntCopeWithLongsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n+import org.mockitoutil.TestBase;\n+\n+//see issue \n+public class EqWithIntsDoesntCopeWithLongsTest extends TestBase {\n+\n+    class Boo {\n+        public void withLong(long y) {\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldNotReportArgumentTypesWhenToStringIsTheSame() throws Exception {\n+        //given\n+        Boo boo = mock(Boo.class);\n+        boo.withLong(100);\n+        \n+        try {\n+            //when\n+            verify(boo).withLong(eq(100));\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            //then\n+            assertContains(\"withLong((Integer) 100);\", e.getMessage());\n+            assertContains(\"withLong((Long) 100);\", e.getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.junit.Before;\n import org.mockito.MockitoAnnotations;\n import org.mockito.StateMaster;\n+import org.mockito.internal.MockitoCore;\n import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n         new StateMaster().reset();\n     }\n     \n+    protected Invocation getLastInvocation() {\n+        return new MockitoCore().getLastInvocation();\n+    }\n+\n     //I'm really tired of matchers, enter the assertor!\n     protected static <T> void assertThat(T o, Assertor<T> a) {\n         a.assertValue(o);\n                 , string.contains(sub));\n     }\n \n-    protected static Invocation invocationOf(Class<?> type, String methodName) throws NoSuchMethodException {\n+    protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n         return new Invocation(new Object(), type.getMethod(methodName,\n-                new Class[0]), new Object[0], 1, null);\n+                new Class[0]), args, 1, null);\n     }\n-    \n+\n     protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n         return new Invocation(new Object(), type.getMethod(methodName,\n                 new Class[0]), new Object[0], 1, realMethod);", "timestamp": 1244150077, "metainfo": ""}