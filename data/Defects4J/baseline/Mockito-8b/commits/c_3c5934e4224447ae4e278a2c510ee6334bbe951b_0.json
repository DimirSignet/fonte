{"sha": "3c5934e4224447ae4e278a2c510ee6334bbe951b", "log": "Started moving out stuff to a public interface type. Moved some implementation elsewhere so that the public api can be thin.", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.mockito.internal.reporting.PrintSettings;\n import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.invocation.PublicInvocation;\n \n import java.lang.reflect.Method;\n import java.util.ArrayList;\n  * Contains stack trace of invocation\n  */\n @SuppressWarnings(\"unchecked\")\n-public class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation, VerificationAwareInvocation {\n+public class Invocation implements PublicInvocation, PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation, VerificationAwareInvocation {\n \n     private static final long serialVersionUID = 8240069639250980199L;\n     private static final int MAX_LINE_LENGTH = 45;\n         return matchers;\n     }\n \n-    public boolean isValidException(Throwable throwable) {\n-        Class<?>[] exceptions = this.getMethod().getExceptionTypes();\n-        Class<?> throwableClass = throwable.getClass();\n-        for (Class<?> exception : exceptions) {\n-            if (exception.isAssignableFrom(throwableClass)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    public boolean isValidReturnType(Class clazz) {\n-        if (method.getReturnType().isPrimitive()) {\n-            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n-        } else {\n-            return method.getReturnType().isAssignableFrom(clazz);\n-        }\n-    }\n-\n-    public boolean isVoid() {\n-        return this.method.getReturnType() == Void.TYPE;\n-    }\n-\n-    public String printMethodReturnType() {\n-        return method.getReturnType().getSimpleName();\n-    }\n-\n-    public String getMethodName() {\n-        return method.getName();\n-    }\n-\n-    public boolean returnsPrimitive() {\n-        return method.getReturnType().isPrimitive();\n-    }\n-\n     public Location getLocation() {\n         return location;\n-    }\n-\n-    public int getArgumentsCount() {\n-        return arguments.length;\n     }\n \n     public Object[] getRawArguments() {\n     }\n \n     public Object callRealMethod() throws Throwable {\n-        if (isDeclaredOnInterface()) {\n+        if (this.getMethod().getDeclaringClass().isInterface()) {\n             new Reporter().cannotCallRealMethodOnInterface();\n         }\n         return realMethod.invoke(mock, rawArguments);\n     }\n-    \n-    public boolean isDeclaredOnInterface() {\n-        return this.getMethod().getDeclaringClass().isInterface();\n-    }      \n \n     public String toString(PrintSettings printSettings) {\n         return toString(argumentsToMatchers(), printSettings);\n     }\n \n-    void markVerified() {\n+    public void markVerified() {\n         this.verified = true;\n     }\n \n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n     private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {\n         if (!lastMatchers.isEmpty()) {\n             int recordedMatchersSize = lastMatchers.size();\n-            int expectedMatchersSize = invocation.getArgumentsCount();\n+            int expectedMatchersSize = invocation.getArguments().length;\n             if (expectedMatchersSize != recordedMatchersSize) {\n                 new Reporter().invalidUseOfMatchers(expectedMatchersSize, lastMatchers);\n             }\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.PublicInvocation;\n import org.mockito.stubbing.Answer;\n \n public class AnswersValidator {\n \n     private Reporter reporter = new Reporter();\n     \n-    public void validate(Answer<?> answer, Invocation invocation) {\n+    public void validate(Answer<?> answer, PublicInvocation theInvocation) {\n+        MethodInfo invocation = new MethodInfo(theInvocation);\n         if (answer instanceof ThrowsException) {\n             validateException((ThrowsException) answer, invocation);\n         }\n         }\n     }\n \n-    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\n-        if (invocation.isDeclaredOnInterface()) {\n+    private void validateMockingConcreteClass(CallsRealMethods answer, MethodInfo methodInfo) {\n+        if (methodInfo.isDeclaredOnInterface()) {\n             reporter.cannotCallRealMethodOnInterface();\n         }\n     }\n \n-    private void validateDoNothing(DoesNothing answer, Invocation invocation) {\n-        if (!invocation.isVoid()) {\n+    private void validateDoNothing(DoesNothing answer, MethodInfo methodInfo) {\n+        if (!methodInfo.isVoid()) {\n             reporter.onlyVoidMethodsCanBeSetToDoNothing();\n         }\n     }\n \n-    private void validateReturnValue(Returns answer, Invocation invocation) {\n-        if (invocation.isVoid()) {\n-            reporter.cannotStubVoidMethodWithAReturnValue(invocation.getMethod().getName());\n+    private void validateReturnValue(Returns answer, MethodInfo methodInfo) {\n+        if (methodInfo.isVoid()) {\n+            reporter.cannotStubVoidMethodWithAReturnValue(methodInfo.getMethodName());\n         }\n         \n-        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n-            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n+        if (answer.returnsNull() && methodInfo.returnsPrimitive()) {\n+            reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), \"null\", methodInfo.getMethodName());\n         } \n \n-        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n-            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n+        if (!answer.returnsNull() && !methodInfo.isValidReturnType(answer.getReturnType())) {\n+            reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), answer.printReturnType(), methodInfo.getMethodName());\n         }\n     }\n \n-    private void validateException(ThrowsException answer, Invocation invocation) {\n+    private void validateException(ThrowsException answer, MethodInfo methodInfo) {\n         Throwable throwable = answer.getThrowable();\n         if (throwable == null) {\n             reporter.cannotStubWithNullThrowable();\n             return;\n         }\n         \n-        if (!invocation.isValidException(throwable)) {\n+        if (!methodInfo.isValidException(throwable)) {\n             reporter.checkedExceptionInvalid(throwable);\n         }\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.internal.util.Primitives;\n+import org.mockito.invocation.PublicInvocation;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * by Szczepan Faber, created at: 3/31/12\n+ */\n+public class MethodInfo {\n+\n+    private Method method;\n+\n+    public MethodInfo(PublicInvocation theInvocation) {\n+        this.method = theInvocation.getMethod();\n+    }\n+\n+    public boolean isValidException(Throwable throwable) {\n+        Class<?>[] exceptions = method.getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public boolean isValidReturnType(Class clazz) {\n+        if (method.getReturnType().isPrimitive()) {\n+            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n+        } else {\n+            return method.getReturnType().isAssignableFrom(clazz);\n+        }\n+    }\n+\n+    public boolean isVoid() {\n+        return this.method.getReturnType() == Void.TYPE;\n+    }\n+\n+    public String printMethodReturnType() {\n+        return method.getReturnType().getSimpleName();\n+    }\n+\n+    public String getMethodName() {\n+        return method.getName();\n+    }\n+\n+    public boolean returnsPrimitive() {\n+        return method.getReturnType().isPrimitive();\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public boolean isDeclaredOnInterface() {\n+        return method.getDeclaringClass().isInterface();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/invocation/PublicInvocation.java\n+package org.mockito.invocation;\n+\n+import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.invocation.StubInfo;\n+\n+/**\n+ * by Szczepan Faber, created at: 3/31/12\n+ */\n+public interface PublicInvocation extends InvocationOnMock {\n+\n+    boolean isVerified();\n+\n+    int getSequenceNumber();\n+\n+    Location getLocation();\n+\n+    Object[] getRawArguments();\n+\n+    void markVerified();\n+\n+    StubInfo stubInfo();\n+\n+    void markStubbed(StubInfo stubInfo);\n+\n+    boolean isIgnoredForVerification();\n+\n+    void ignoreForVerification();\n+}\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n         assertEquals(ArrayEquals.class, matchers.get(1).getClass());\n     }\n     \n-    @Test\n-    public void shouldKnowValidThrowables() throws Exception {\n-        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n-        assertFalse(invocation.isValidException(new Exception()));\n-        assertTrue(invocation.isValidException(new CharacterCodingException()));\n-    }\n-    \n     class Foo {\n         public String bark() {\n             return \"woof\";\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import static org.mockito.Mockito.*;\n     @Test\n     public void shouldValidateNullThrowable() throws Throwable {\n         try {\n-            validator.validate(new ThrowsException(null), null);\n+            validator.validate(new ThrowsException(null), new InvocationBuilder().toInvocation());\n             fail();\n         } catch (MockitoException e) {}\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+\n+import java.nio.charset.CharacterCodingException;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * by Szczepan Faber, created at: 3/31/12\n+ */\n+public class MethodInfoTest {\n+\n+    @Test\n+    public void shouldKnowValidThrowables() throws Exception {\n+        //when\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        MethodInfo info = new MethodInfo(invocation);\n+\n+        //then\n+        assertFalse(info.isValidException(new Exception()));\n+        assertTrue(info.isValidException(new CharacterCodingException()));\n+    }\n+}", "timestamp": 1333228867, "metainfo": ""}