{"sha": "8d4e366abdfaa0038ced9c8e860867481a9707b4", "log": "moved classes around  --HG-- rename : src/org/mockito/runners/ExperimentalMockitoJUnitRunnerPM.java => test/org/junit/mockito/ExperimentalMockitoJUnitRunnerPM.java rename : test/org/mockito/runners/ExperimentalMockitoJUnitRunnerPMTest.java => test/org/junit/mockito/ExperimentalMockitoJUnitRunnerPMTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401179", "commit": "\n--- /dev/null\n+++ b/test/org/junit/mockito/ExperimentalMockitoJUnitRunnerPM.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.junit.mockito;\n+\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.BlockJUnit4ClassRunner;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+/**\n+ * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n+ * <p>\n+ * JUnit 4.5 runner initializes mocks annotated with {@link Mock},\n+ * so that explicit usage of {@link MockitoAnnotations#initMocks(Object)} is not necessary. \n+ * Mocks are initialized before each test method. \n+ * <p>\n+ * Runner is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.\n+ * <p>\n+ * Read more in javadoc for {@link MockitoAnnotations}\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * <b>&#064;RunWith(MockitoJUnit44Runner.class)</b>\n+ * public class ExampleTest {\n+ * \n+ *     &#064;Mock\n+ *     private List list;\n+ * \n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * <p>\n+ * \n+ * </pre>\n+ */\n+public class ExperimentalMockitoJUnitRunnerPM extends MockitoJUnitRunner {\n+\n+    private final MockitoLogger logger;\n+    \n+    public ExperimentalMockitoJUnitRunnerPM(Class<?> klass, MockitoLogger logger) throws InitializationError {\n+        super(klass);\n+        this.logger = logger; \n+    }\n+\n+    public ExperimentalMockitoJUnitRunnerPM(Class<?> klass) throws InitializationError {\n+        this(klass, new MockitoLoggerImpl());\n+    }\n+\n+    protected void runTestBody(RunNotifier notifier) {\n+        super.run(notifier);\n+    }\n+    \n+    @Override\n+    public void run(RunNotifier notifier) {\n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n+        \n+        beforeRun(notifier, debuggingInfo);\n+        \n+        runTestBody(notifier);\n+\n+        afterRun(debuggingInfo);\n+    }\n+\n+    private void afterRun(final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.clearData();\n+    }\n+\n+    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.collectData();\n+\n+        RunListener listener = new RunListener() {\n+            @Override public void testFailure(Failure failure) throws Exception {\n+                debuggingInfo.printWarnings(logger);\n+            }\n+        };\n+        \n+        notifier.addListener(listener);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/junit/mockito/ExperimentalMockitoJUnitRunnerPMTest.java\n+package org.junit.mockito;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.util.MockitoLoggerStub;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"serial\")\n+public class ExperimentalMockitoJUnitRunnerPMTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+    private ExperimentalMockitoJUnitRunnerPMStub runner;\n+    private MockitoLoggerStub loggerStub;\n+    private RunNotifier notifier;\n+\n+    @Before\n+    public void setup() throws InitializationError {\n+        loggerStub = new MockitoLoggerStub();\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub();\n+        notifier = new RunNotifier();\n+    }\n+    \n+    //just to get rid of noisy constructor\n+    class ExperimentalMockitoJUnitRunnerPMStub extends ExperimentalMockitoJUnitRunnerPM {\n+        public ExperimentalMockitoJUnitRunnerPMStub() throws InitializationError {\n+            super(ExperimentalMockitoJUnitRunnerPMTest.class, loggerStub);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRunTests() throws Exception {\n+        final StringBuilder sb = new StringBuilder();\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                sb.append(\"ran test body\");\n+            }\n+        };\n+        runner.run(notifier);\n+        assertEquals(\"ran test body\", sb.toString());\n+    }\n+    \n+    class TestBodyWasRan extends RuntimeException {};\n+    \n+    @Test(expected=TestBodyWasRan.class)\n+    public void shouldRunTests2() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                throw new TestBodyWasRan();\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldRunTestsWithHypotheticalPartialMock() throws Exception {\n+//        runner = spy(runner);\n+        \n+        //This even might not be needed because runOnParent() might be safe\n+        doNothing().when(runner).runTestBody(notifier);\n+        \n+        runner.run(notifier);\n+        \n+        verify(runner).runTestBody(notifier);\n+    }\n+    \n+    @Test\n+    public void usingAnnonymousInnerClass() throws Exception {\n+        //boring setup that goes to @Before\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        \n+        //arrange\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                someUnusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+            }\n+        };\n+        \n+        //act\n+        runner.run(notifier);\n+        \n+        //assert\n+        String loggedInfo = loggerStub.getLoggedInfo();\n+        assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void usingPartialMocking() throws Exception {\n+        //boring setup that goes to @Before\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        runner = spy(ExperimentalMockitoJUnitRunnerPMStub.class, guessConstructor(loggerStub));\n+        \n+        //arrange\n+        doAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) {\n+                RunNotifier notifier = (RunNotifier) invocation.getArguments()[0];\n+                someUnusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                return null;\n+            }\n+        }).when(runner).runTestBody(notifier);\n+        \n+        //act\n+        runner.run(notifier);\n+        \n+        //assert\n+        String loggedInfo = loggerStub.getLoggedInfo();\n+        assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+    }\n+\n+    private <T> T spy(Class<T> clazz, Constructor guessConstructor) {\n+        return null;\n+    }\n+\n+    class Constructor<T> {\n+        \n+    }\n+    \n+    private Constructor guessConstructor(Object ... constructorArguments) {\n+        return null;\n+    }\n+\n+    private ExperimentalMockitoJUnitRunnerPMStub partialMock(Class<ExperimentalMockitoJUnitRunnerPM> class1) {\n+        return null;\n+    }\n+\n+    @Test\n+    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                callUnstubbedMethodThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this method was not stubbed\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(456);\"));\n+                assertThat(loggedInfo, contains(\".callUnstubbedMethodThatQualifiesForWarning(\"));\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Test\n+    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                someStubbing();\n+//                callStubbedMethodCorrectly();\n+                callStubbedMethodWithDifferentArgs();\n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - stubbed method called with different arguments\"));\n+                assertThat(loggedInfo, contains(\"Stubbed this way:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(789);\"));\n+                assertThat(loggedInfo, contains(\".someStubbing(\"));\n+                \n+                assertThat(loggedInfo, contains(\"But called with different arguments:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(10);\"));\n+                assertThat(loggedInfo, contains(\".callStubbedMethodWithDifferentArgs(\"));\n+                \n+                assertThat(loggedInfo, notContains(\".callStubbedMethodCorrectly(\"));\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Test\n+    public void shouldNotLogUsedStubbingWarningWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                when(mock.simpleMethod()).thenReturn(\"foo\");\n+                mock.simpleMethod();\n+                \n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertEquals(\"\", loggedInfo);\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    \n+    public void shouldClearDebuggingDataAfterwards() throws Exception {\n+        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n+        \n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                someUnusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                assertTrue(debuggingInfo.hasData());\n+            }\n+        };\n+        \n+        runner.run(notifier);\n+        \n+        assertFalse(debuggingInfo.hasData());\n+    }    \n+\n+    private void someUnusedStubbingThatQualifiesForWarning() {\n+        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n+    }\n+\n+    private void callUnstubbedMethodThatQualifiesForWarning() {\n+        mock.simpleMethod(456);\n+    }\n+    \n+    private void someStubbing() {\n+        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n+    }\n+    \n+    private void callStubbedMethodWithDifferentArgs() {\n+        mock.simpleMethod(10);\n+    }\n+}", "timestamp": 1231678046, "metainfo": ""}