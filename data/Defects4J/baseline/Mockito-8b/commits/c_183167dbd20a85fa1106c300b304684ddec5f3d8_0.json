{"sha": "183167dbd20a85fa1106c300b304684ddec5f3d8", "log": "another batch of stuff related to doReturn() API  --HG-- rename : src/org/mockito/internal/stubbing/Stubber.java => src/org/mockito/internal/stubbing/MockitoStubber.java rename : src/org/mockito/internal/stubbing/MethodSelector.java => src/org/mockito/internal/stubbing/StubbedMethodSelector.java rename : src/org/mockito/internal/stubbing/MethodSelectorImpl.java => src/org/mockito/internal/stubbing/StubberImpl.java rename : test/org/mockito/internal/stubbing/StubberTest.java => test/org/mockito/internal/stubbing/MockitoStubberTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40677", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.progress.VerificationModeImpl;\n-import org.mockito.internal.stubbing.MethodSelector;\n-import org.mockito.internal.stubbing.MethodSelectorImpl;\n import org.mockito.internal.stubbing.Returns;\n+import org.mockito.internal.stubbing.StubberFoo;\n+import org.mockito.internal.stubbing.StubberImpl;\n import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n         return handler.voidMethodStubbable();\n     }\n     \n-    public static MethodSelector doReturn(Object toBeReturned) {\n+    public static StubberFoo doReturn(Object toBeReturned) {\n+        return doAnswer(new Returns(toBeReturned));\n+    }\n+    \n+    public static StubberFoo doReturn() {\n+        return doAnswer(new Returns());\n+    }\n+    \n+    public static StubberFoo doThrow(Throwable toBeThrown) {\n+        return doAnswer(new ThrowsException(toBeThrown));\n+    }\n+    \n+    public static StubberFoo doAnswer(Answer answer) {\n         MOCKING_PROGRESS.stubbingStarted();\n-        return new MethodSelectorImpl(new Returns(toBeReturned));\n-    }\n-    \n-    public static MethodSelector doThrow(Throwable toBeThrown) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return new MethodSelectorImpl(new ThrowsException(toBeThrown));\n+        return new StubberImpl().doAnswer(answer);\n     }\n     \n     /**\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.Returns;\n-import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.MockitoStubber;\n import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n public class MockHandler<T> implements MockAwareInterceptor<T> {\n \n     private final VerifyingRecorder verifyingRecorder;\n-    private final Stubber stubber;\n+    private final MockitoStubber mockitoStubber;\n     private final MatchersBinder matchersBinder;\n     private final MockingProgress mockingProgress;\n     private final String mockName;\n         this.mockName = mockName;\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n-        this.stubber = new Stubber(mockingProgress);\n+        this.mockitoStubber = new MockitoStubber(mockingProgress);\n \n         verifyingRecorder = createRecorder();\n     }\n     \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n-        if (stubber.hasAnswerForVoidMethod()) {\n+        if (mockitoStubber.hasAnswerForVoidMethod()) {\n             //stubbing voids\n             Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n-            stubber.addVoidMethodForStubbing(invocationMatcher);\n+            mockitoStubber.addVoidMethodForStubbing(invocationMatcher);\n             return null;\n         }\n         \n             return null;\n         }\n \n-        stubber.setInvocationForPotentialStubbing(invocationMatcher);\n+        mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n         verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n \n         mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n \n-        if (stubber.hasResultFor(invocation)) {\n-            return stubber.getResultFor(invocation);\n+        if (mockitoStubber.hasResultFor(invocation)) {\n+            return mockitoStubber.getResultFor(invocation);\n         } else if (MockUtil.isMock(instance)) {\n             return Configuration.instance().getReturnValues().valueFor(invocation);\n         } else {\n \n     private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n         public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n-            stubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n+            mockitoStubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n             return this;\n         }\n \n         public VoidMethodStubbable<T> toReturn() {\n-            stubber.addAnswerForVoidMethod(new Returns());\n+            mockitoStubber.addAnswerForVoidMethod(new Returns());\n             return this;\n         }\n \n         public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n-            stubber.addAnswerForVoidMethod(answer);\n+            mockitoStubber.addAnswerForVoidMethod(answer);\n             return this;\n         }\n \n     private class OngoingStubbingImpl implements OngoingStubbing<T> {\n         public OngoingStubbing<T> toReturn(Object value) {\n             verifyingRecorder.eraseLastInvocation();\n-            stubber.addAnswer(new Returns(value));\n+            mockitoStubber.addAnswer(new Returns(value));\n             return new ConsecutiveStubbing();\n         }\n \n         public OngoingStubbing<T> toThrow(Throwable throwable) {\n             verifyingRecorder.eraseLastInvocation();\n-            stubber.addAnswer(new ThrowsException(throwable));\n+            mockitoStubber.addAnswer(new ThrowsException(throwable));\n             return new ConsecutiveStubbing();\n         }\n \n         public OngoingStubbing<T> toAnswer(Answer<?> answer) {\n             verifyingRecorder.eraseLastInvocation();\n-            stubber.addAnswer(answer);\n+            mockitoStubber.addAnswer(answer);\n             return new ConsecutiveStubbing();\n         }\n     }\n \n     private class ConsecutiveStubbing implements OngoingStubbing<T> {\n         public OngoingStubbing<T> toReturn(Object value) {\n-            stubber.addConsecutiveAnswer(new Returns(value));\n+            mockitoStubber.addConsecutiveAnswer(new Returns(value));\n             return this;\n         }\n \n         public OngoingStubbing<T> toThrow(Throwable throwable) {\n-            stubber.addConsecutiveAnswer(new ThrowsException(throwable));\n+            mockitoStubber.addConsecutiveAnswer(new ThrowsException(throwable));\n             return this;\n         }\n \n         public OngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            stubber.addConsecutiveAnswer(answer);\n+            mockitoStubber.addConsecutiveAnswer(answer);\n             return this;\n         }\n     }\n \n-    public void setAnswerForStubbing(Answer<?> answer) {\n-        stubber.addAnswerForVoidMethod(answer);\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        mockitoStubber.addAnswersForVoidMethod(answers);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.stubbing.Answer;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoStubber {\n+\n+    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n+    private final MockingProgress mockingProgress;\n+    private final List<Answer> answersForVoidMethod = new ArrayList<Answer>();\n+\n+    private InvocationMatcher invocationForStubbing;\n+\n+    public MockitoStubber(MockingProgress mockingProgress) {\n+        this.mockingProgress = mockingProgress;\n+    }\n+\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        this.invocationForStubbing = invocation;\n+    }\n+\n+    public void addAnswer(Answer answer) {\n+        addAnswer(answer, false);\n+    }\n+\n+    public void addConsecutiveAnswer(Answer answer) {\n+        addAnswer(answer, true);\n+    }\n+    \n+    private void addAnswer(Answer answer, boolean isConsecutive) {\n+        mockingProgress.stubbingCompleted();\n+        AnswersValidator answersValidator = new AnswersValidator();\n+        answersValidator.validate(answer, invocationForStubbing.getInvocation());\n+        \n+        if (isConsecutive) {\n+            stubbed.getFirst().addAnswer(answer);\n+        } else {\n+            stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+        }\n+    } \n+    \n+    public boolean hasResultFor(Invocation invocation) {\n+        return findMatch(invocation) != null;\n+    }\n+    \n+    public Object getResultFor(Invocation invocation) throws Throwable {\n+        return findMatch(invocation).answer(invocation);\n+    }\n+\n+    private StubbedInvocationMatcher findMatch(Invocation invocation) {\n+        for (StubbedInvocationMatcher s : stubbed) {\n+            if (s.matches(invocation)) {\n+                return s;\n+            }\n+        }\n+        \n+        return null;\n+    }\n+\n+    //TODO it's not for void method any more\n+    public void addAnswerForVoidMethod(Answer answer) {\n+        answersForVoidMethod.add(answer);\n+    }\n+    \n+    //TODO dodgy name\n+    public void addAnswersForVoidMethod(List<Answer> answers) {\n+        answersForVoidMethod.addAll(answers);\n+    }\n+\n+    public boolean hasAnswerForVoidMethod() {\n+        return !answersForVoidMethod.isEmpty();\n+    }\n+\n+    //TODO it's not for void method any more\n+    public void addVoidMethodForStubbing(InvocationMatcher voidMethodInvocationMatcher) {\n+        invocationForStubbing = voidMethodInvocationMatcher;\n+        assert hasAnswerForVoidMethod();\n+        for (int i = 0; i < answersForVoidMethod.size(); i++) {\n+            addAnswer(answersForVoidMethod.get(i), i != 0);\n+        }\n+        answersForVoidMethod.clear();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/StubbedMethodSelector.java\n+package org.mockito.internal.stubbing;\n+\n+public interface StubbedMethodSelector {\n+\n+    <T> T when(T mock);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/StubberImpl.java\n+package org.mockito.internal.stubbing;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.stubbing.Answer;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubberImpl implements StubberFoo {\n+\n+    final List<Answer> answers = new LinkedList<Answer>();\n+    private final Reporter reporter = new Reporter();\n+\n+    public <T> T when(T mock) {\n+        if (mock == null) {\n+            reporter.nullPassedToWhenMethod();\n+        } else if (!MockUtil.isMock(mock)) {\n+            reporter.notAMockPassedToWhenMethod();\n+        }\n+        \n+        MockUtil.getMockHandler(mock).setAnswersForStubbing(answers);\n+        return mock;\n+    }\n+\n+    public StubberFoo doReturn(Object toBeReturned) {\n+        answers.add(new Returns(toBeReturned));\n+        return this;\n+    }\n+\n+    public StubberFoo doThrow(Throwable toBeThrown) {\n+        answers.add(new ThrowsException(toBeThrown));\n+        return this;\n+    }\n+\n+    public StubberFoo doReturn() {\n+        answers.add(new Returns());\n+        return this;\n+    }\n+\n+    public StubberFoo doAnswer(Answer answer) {\n+        answers.add(answer);\n+        return this;\n+    }\n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n import org.mockito.internal.progress.VerificationModeImplTest;\n-import org.mockito.internal.stubbing.StubberTest;\n import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n import org.mockito.internal.verification.MissingInvocationInOrderVerifierTest;\n                     MockHandlerTest.class,\n                     AllInvocationsFinderTest.class,\n                     DefaultReturnValuesTest.class,\n-                    StubberTest.class,\n                     NumberOfInvocationsVerifierTest.class,\n                     VerifyingRecorderTest.class,\n                     MissingInvocationVerifierTest.class,\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockitoutil.TestBase;\n+\n+public class MockitoStubberTest extends TestBase{\n+\n+    private MockitoStubber mockitoStubber;\n+    private MockingProgressImpl state;\n+    private Invocation simpleMethod;\n+    \n+    @Before\n+    public void setup() {\n+        state = new MockingProgressImpl();\n+        \n+        mockitoStubber = new MockitoStubber(state);\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        \n+        simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+    }\n+\n+    @Test\n+    public void shouldFinishStubbingWhenWrongThrowableIsSet() throws Exception {\n+        state.stubbingStarted();\n+        try {\n+            mockitoStubber.addAnswer(new ThrowsException(new Exception()));\n+            fail();\n+        } catch (MockitoException e) {\n+            state.validateState();\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFinishStubbingOnAddingReturnValue() throws Exception {\n+        state.stubbingStarted();\n+        mockitoStubber.addAnswer(new Returns(\"test\"));\n+        state.validateState();\n+    }\n+    \n+    @Test\n+    public void shouldGetResultsForMethods() throws Throwable {\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        mockitoStubber.addAnswer(new Returns(\"simpleMethod\"));\n+        \n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        mockitoStubber.addAnswer(new ThrowsException(new MyException()));\n+        \n+        assertEquals(\"simpleMethod\", mockitoStubber.getResultFor(simpleMethod));\n+        \n+        try {\n+            mockitoStubber.getResultFor(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAddThrowableForVoidMethod() throws Throwable {\n+        mockitoStubber.addAnswerForVoidMethod(new ThrowsException(new MyException()));\n+        mockitoStubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));\n+        \n+        try {\n+            mockitoStubber.getResultFor(simpleMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldValidateThrowableForVoidMethod() throws Throwable {\n+        mockitoStubber.addAnswerForVoidMethod(new ThrowsException(new Exception()));\n+        \n+        try {\n+            mockitoStubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldValidateThrowable() throws Throwable {\n+        try {\n+            mockitoStubber.addAnswer(new ThrowsException(null));\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @SuppressWarnings(\"serial\") class MyException extends RuntimeException {};\n+}\n--- a/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n+import java.io.IOException;\n+\n import org.junit.After;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.StateMaster;\n import org.mockito.MockitoAnnotations.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n-@SuppressWarnings(\"unchecked\")\n+@SuppressWarnings(\"serial\")\n public class StubbingUsingDoReturnTest extends TestBase {\n \n     @Mock private IMethods mock;\n         assertEquals(null, mock.simpleMethod(\"xxx\", 234));\n     }\n     \n-    @SuppressWarnings(\"serial\")\n-    class FooException extends RuntimeException {}\n+    class FooRuntimeException extends RuntimeException {}\n     \n     @Test\n     public void shouldStubWithThrowable() throws Exception {\n-        doThrow(new FooException()).when(mock).voidMethod();\n+        doThrow(new FooRuntimeException()).when(mock).voidMethod();\n         try {\n             mock.voidMethod();\n             fail();\n-        } catch (FooException e) {}\n+        } catch (FooRuntimeException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowSettingValidCheckedException() throws Exception {\n+        doThrow(new IOException()).when(mock).throwsIOException(0);\n+        \n+        try {\n+            mock.throwsIOException(0);\n+            fail();\n+        } catch (IOException e) {}\n+    }\n+    \n+    class FooCheckedException extends Exception {}\n+    \n+    @Test\n+    public void shouldDetectInvalidCheckedException() throws Exception {\n+        try {\n+            doThrow(new FooCheckedException()).when(mock).throwsIOException(0);\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.getMessage(), contains(\"Checked exception is invalid\"));\n+        }\n     }\n     \n     @Test\n     @Test\n     public void shouldScreamWhenNullPassed() throws Exception {\n         try {\n-            doReturn(\"foo\").when(null).toString();\n+            doReturn(\"foo\").when((Object) null).toString();\n             fail();\n         } catch (Exception e) {\n             assertThat(e.getMessage(), contains(\"Argument passed to when() is null\"));\n         }\n     }    \n     \n-    //TODO checked Exceptions\n+    @Test\n+    public void shouldAllowChainedStubbing() {\n+        doReturn(\"foo\").\n+        doThrow(new RuntimeException()).\n+        doReturn(\"bar\")\n+        .when(mock).simpleMethod();\n+        \n+        assertEquals(\"foo\", mock.simpleMethod());\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (RuntimeException e) {}\n+        \n+        assertEquals(\"bar\", mock.simpleMethod());\n+        assertEquals(\"bar\", mock.simpleMethod());\n+    }\n     \n-    //TODO chains\n+    @Test\n+    public void shouldAllowChainedStubbingOnVoidMethods() {\n+        doReturn().\n+        doReturn().\n+        doThrow(new RuntimeException())\n+        .when(mock).voidMethod();\n+        \n+        mock.voidMethod();\n+        mock.voidMethod();\n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (RuntimeException e) {}\n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (RuntimeException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldStubWithGenericAnswer() {\n+        doAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return \"foo\";\n+            }\n+        })\n+        .when(mock).simpleMethod();\n+        \n+        assertEquals(\"foo\", mock.simpleMethod());\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldNotAllowDoReturnOnNonVoids() {\n+        doReturn().when(mock).simpleMethod();\n+        fail();\n+    }\n     \n     //TODO state validation\n-    \n-    //TODO should verify\n     \n     //TODO exception messages with UnfinishedStubbingException\n     ", "timestamp": 1216239299, "metainfo": ""}