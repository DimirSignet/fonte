{"sha": "5a4cdb5a40542e01c1558f7fbc34df01cfa794aa", "log": "issue 238 : constructor injection is now alive :  - inject declared mocks only  - fail silently for now allowing people to instantiate fields themselves (however some error will need to be reported)  - @Spy and @InjectMocks with constructor injection don't work together.  --HG-- branch : issue 238 : constructor injection rename : test/org/mockitousage/annotation/InjectMocksTest.java => test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java rename : test/org/mockitousage/annotation/MockInjectionTest.java => test/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * <li>Minimizes repetitive mock and spy injection.</li>\n  * </ul>\n  * <p>\n- * Currently it injects fields via reflection. If you prefer constructor/setter injection - please contribute a patch.\n- * </p>\n+ * Mockito will try to inject mocks only either by constructor injection,\n+ * setter injection, or property injection in order and as described below.\n+ * If any of the following strategy fail, then Mockito <strong>won't report failure</strong>;\n+ * i.e. you will have to provide dependencies yourself.\n+ * <ol>\n+ *     <li><strong>Constructor injection</strong>; the biggest constructor is chosen,\n+ *     then arguments are resolved with mocks declared in the test only.\n+ *     <p><u>Note:</u> If arguments can not be found, then null is passed.\n+ *     If non-mockable types are wanted, then constructor injection won't happen.\n+ *     In these cases, you will have to satisfy dependencies yourself.</p></li>\n  *\n- * <p>\n- * Mockito tries to inject by type (using name in case types are the same). \n- * Mockito does not throw anything when injection fails - you will have to satisfy the dependencies manually.\n+ *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n+ *     then (using name if there is several property of the same type).\n+ *     <p><u>Note:</u> If type wasn't initialized before and have a no-arg constructor,\n+ *     then it will be initialized with this constructor.</p></li>\n+ *\n+ *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n+ *     then (using name if there is several property of the same type).\n+ *     <p><u>Note:</u> If type wasn't initialized before and have a no-arg constructor,\n+ *     then it will be initialized with this constructor.</p></li>\n+ * </ol>\n  * </p>\n  *\n  * <p>\n  *       &#064;Mock private ArticleDatabase database;\n  *       &#064;Spy private UserProvider userProvider = new ConsumerUserProvider();\n  *\n- *       &#064;InjectMocks private ArticleManager manager = new ArticleManager();\n+ *       &#064;InjectMocks private ArticleManager manager;\n  *\n  *       &#064;Test public void shouldDoSomething() {\n  *           manager.initiateArticle();\n  *       }\n  *   }\n  * </pre>\n- *\n- * <b>The field annotated with &#064;InjectMocks can be initiatialized explicitly (just like in the example).\n- * Alternatively, if you don't provide the instance Mockito will try to find zero argument constructor (even private) and create an instance for you.\n- * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></b>\n- *\n- * For example this class can be instantiated by Mockito :\n- * <pre>public class Bar {\n- *    private Bar() {}\n- *    public Bar(String publicConstructorWithOneArg) {}\n- * }</pre>\n- * </p>\n- *\n  * </p>\n  *\n  * <p>\n- * Note that &#064;InjectMocks will only inject mocks/spies created using the &#64;Spy or &#64;Mock annotation.\n+ * In the above example the field ArticleManager annotated with &#064;InjectMocks can have\n+ * a parameterized constructor only or a no-arg constructor only, or both.\n+ * All these constructors can be package protected, protected or private, however\n+ * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n+ *\n+ * <p>The same stands for setters or fields, they can be declared with private\n+ * visibility, Mockito will see them through reflection.</p>\n+ *\n+ * <p>So on the field that needs injection, for example constructor injection will happen here :</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {\n+ *           // parameterized constructor\n+ *       }\n+ *   }\n+ * </pre>\n+ *\n+ * <p>Property setter injection will happen here :</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       ArticleManager() {\n+ *           // no-arg constructor\n+ *       }\n+ *\n+ *       void setDatabase(ArticleDatabase database) {\n+ *           // setter\n+ *       }\n+ *   }\n+ * </pre>\n+ *\n+ * <p>Field injection will be used here :</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       private ArticleDatabase database;\n+ *       private ArticleCalculator calculator;\n+ *   }\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>And finally, no injection will happen on the type in this case:</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       private ArticleDatabase database;\n+ *       private ArticleCalculator calculator;\n+ *\n+ *       ArticleManager(ArticleObserver observer, boolean flag) {\n+ *           // observer is not declared in the test above.\n+ *           // flag is not mockable anyway\n+ *       }\n+ *   }\n+ * </pre>\n+ * </p>\n+ *\n+ *\n+ * <p>\n+ * Again, note that &#064;InjectMocks will only inject mocks/spies created using the &#64;Spy or &#64;Mock annotation.\n  * </p>\n  *\n  * <p>\n  * <b><code>MockitoAnnotations.injectMocks(this)</code></b> method has to called to initialize annotated objects.\n+ * A <code>MockitoJUnitRunner</code> can also be used to initialize mocks instead of the &#64;Before approach.\n  * <p>\n  *\n  * <p>\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *\n  * <h3 id=\"23\">23. (**New**) Automatic instantiation of &#064;Spy, &#064;InjectMocks fields (Since 1.9)</h3>\n  * <p>\n- * Mockito will now try to instantiate &#064;{@link Spy} and &#064;{@link InjectMocks} fields if you haven't provided instance at declaration\n- * *and* if the type has a zero-arg argument (even private).\n+ * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields\n+ * using constructor injection, setter injection, or field injection.\n  * <p>\n  * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)} or {@link MockitoJUnitRunner}.\n  * <p>\n- * Read more about available {@link MockitoAnnotations}\n+ * Read more about available tricks {@link InjectMocks}\n  * <pre>\n  * //instead:\n  * &#064;Spy BeerDrinker drinker = new BeerDrinker();\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.annotation.Annotation;\n                 assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                 Object instance = null;\n                 try {\n-                    instance = new FieldInitializer(testInstance, field).initialize();\n+                    FieldInitializationReport report = new FieldInitializer(testInstance, field).initialize();\n+                    instance = report.fieldInstance();\n                 } catch (MockitoException e) {\n                     new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                 }\n--- a/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n package org.mockito.internal.configuration.injection;\n \n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldInitializationReport;\n+import org.mockito.internal.util.reflection.FieldInitializer;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n+\n import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Set;\n \n /**\n  */\n public class ConstructorInjection extends MockInjectionStrategy {\n \n+    private ConstructorArgumentResolver argResolver;\n+\n+    public ConstructorInjection() { }\n+\n+    // visible for testing\n+    ConstructorInjection(ConstructorArgumentResolver argResolver) {\n+        this.argResolver = argResolver;\n+    }\n+\n     public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        try {\n+            SimpleArgumentResolver simpleArgumentResolver = new SimpleArgumentResolver(mockCandidates);\n+            FieldInitializationReport report = new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();\n \n-        // new FieldConstructorInitializer(field, fieldOwner).initialize(mockCandidates);\n+            return report.fieldWasInitialized();\n+        } catch (MockitoException e) {\n+            return false;\n+        }\n \n-        return false;\n+    }\n+\n+    /**\n+     * Returns mocks that match the argument type, if not possible assigns null.\n+     */\n+    static class SimpleArgumentResolver implements ConstructorArgumentResolver {\n+        final Set<Object> objects;\n+\n+        public SimpleArgumentResolver(Set<Object> objects) {\n+            this.objects = objects;\n+        }\n+\n+        public Object[] resolveTypeInstances(Class<?>... argTypes) {\n+            List<Object> argumentInstances = new ArrayList<Object>(argTypes.length);\n+            for (Class<?> argType : argTypes) {\n+                argumentInstances.add(objectThatIsAssignableFrom(argType));\n+            }\n+            return argumentInstances.toArray();\n+        }\n+\n+        private Object objectThatIsAssignableFrom(Class<?> argType) {\n+            for (Object object : objects) {\n+                if(argType.isAssignableFrom(object.getClass())) return object;\n+            }\n+            return null;\n+        }\n     }\n \n }\n--- a/src/org/mockito/internal/configuration/injection/MockInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n         return new OngoingMockInjection(fields, ofInstance);\n     }\n \n+    /**\n+     * Ongoing configuration of the mock injector.\n+     */\n     public static class OngoingMockInjection {\n         private Set<Field> fields = new HashSet<Field>();\n         private Set<Object> mocks = new HashSet<Object>();\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n+import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.reflect.Field;\n \n     public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n         Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n-        Object fieldInstanceNeedingInjection = null;\n+        FieldInitializationReport report = null;\n         try {\n-            fieldInstanceNeedingInjection = new FieldInitializer(fieldOwner, field).initialize();\n+            report = new FieldInitializer(fieldOwner, field).initialize();\n         } catch (MockitoException e) {\n             new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n         }\n \n+\n         // for each field in the class hierarchy\n-        Class<?> fieldClass = fieldInstanceNeedingInjection.getClass();\n+        boolean injectionOccurred = false;\n+        Class<?> fieldClass = report.fieldClass();\n+        Object fieldInstanceNeedingInjection = report.fieldInstance();\n         while (fieldClass != Object.class) {\n-            injectMockCandidate(fieldClass, mocksToBeInjected, fieldInstanceNeedingInjection);\n+            injectionOccurred |= injectMockCandidate(fieldClass, mocksToBeInjected, fieldInstanceNeedingInjection);\n             fieldClass = fieldClass.getSuperclass();\n         }\n-        return false;\n+        return injectionOccurred;\n     }\n \n \n-    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n+    private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n+        boolean injectionOccurred = false;\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n-            mocks.remove(injected);\n+            if(injected != null) {\n+                injectionOccurred |= true;\n+                mocks.remove(injected);\n+            }\n         }\n+        return injectionOccurred;\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n+package org.mockito.internal.util.reflection;\n+\n+public class FieldInitializationReport {\n+    private Object fieldInstance;\n+    private boolean wasInitialized;\n+\n+    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized) {\n+        this.fieldInstance = fieldInstance;\n+        this.wasInitialized = wasInitialized;\n+    }\n+\n+    public Object fieldInstance() {\n+        return fieldInstance;\n+    }\n+\n+    public boolean fieldWasInitialized() {\n+        return wasInitialized;\n+    }\n+\n+    public Class<?> fieldClass() {\n+        return fieldInstance != null ? fieldInstance.getClass() : null;\n+    }\n+}\n+\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n      * @param fieldOwner Instance of the test.\n      * @param field Field to be initialize.\n      */\n-    public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver resolver) {\n-        this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, resolver));\n+    public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {\n+        this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));\n     }\n \n     private FieldInitializer(Object fieldOwner, Field field, ConstructorInstantiator instantiator) {\n      *\n      * @return Actual field instance.\n      */\n-    public Object initialize() {\n+    public FieldInitializationReport initialize() {\n         final AccessibilityChanger changer = new AccessibilityChanger();\n         changer.enableAccess(field);\n \n         }\n     }\n \n-    private Object acquireFieldInstance() throws IllegalAccessException {\n+    private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {\n         Object fieldInstance = field.get(fieldOwner);\n         if(fieldInstance != null) {\n-            return fieldInstance;\n+            return new FieldInitializationReport(fieldInstance, false);\n         }\n \n         instantiator.instantiate();\n-        return field.get(fieldOwner);\n-    }\n-\n+        return new FieldInitializationReport(field.get(fieldOwner), true);\n+    }\n+\n+    /**\n+     * Represents the strategy used to resolve actual instances\n+     * to be given to a constructor given the argument types.\n+     */\n     public interface ConstructorArgumentResolver {\n+\n+        /**\n+         * Try to resolve instances from types.\n+         *\n+         * <p>\n+         * Checks on the real argument type or on the correct argument number\n+         * will happen during the field initialization {@link FieldInitializer#initialize()}.\n+         * I.e the only responsibility of this method, is to provide instances <strong>if possible</strong>.\n+         * </p>\n+         *\n+         * @param argTypes Constructor argument types, should not be null.\n+         * @return The argument instances to be given to the constructor, should not be null.\n+         */\n         Object[] resolveTypeInstances(Class<?>... argTypes);\n     }\n \n      * <p>\n      * Choose the constructor with the highest number of parameters, then\n      * call the ConstructorArgResolver to get actual argument instances.\n-     * If the resolver fail, then a technical MockitoException is thrown is thrown.\n+     * If the argResolver fail, then a technical MockitoException is thrown is thrown.\n      * Otherwise the instance is created with the resolved arguments.\n      * </p>\n      */\n     static class ParameterizedConstructorInstantiator implements ConstructorInstantiator {\n         private Object testClass;\n         private Field field;\n-        private ConstructorArgumentResolver resolver;\n+        private ConstructorArgumentResolver argResolver;\n         private Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {\n             public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {\n                 return constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n          * Internal, checks are done by FieldInitializer.\n          * Fields are assumed to be accessible.\n          */\n-        ParameterizedConstructorInstantiator(Object testClass, Field field, ConstructorArgumentResolver resolver) {\n+        ParameterizedConstructorInstantiator(Object testClass, Field field, ConstructorArgumentResolver argumentResolver) {\n             this.testClass = testClass;\n             this.field = field;\n-            this.resolver = resolver;\n+            this.argResolver = argumentResolver;\n         }\n \n         public Object instantiate() {\n                 checkParameterized(constructor, field);\n                 changer.enableAccess(constructor);\n \n-                final Object[] args = resolver.resolveTypeInstances(constructor.getParameterTypes());\n+                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());\n                 Object newFieldInstance = constructor.newInstance(args);\n                 new FieldSetter(testClass, field).set(newFieldInstance);\n \n                 return field.get(testClass);\n             } catch (IllegalArgumentException e) {\n-                throw new MockitoException(\"internal error : resolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n+                throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n             } catch (InvocationTargetException e) {\n                 throw new MockitoException(\"the constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n             } catch (InstantiationException e) {\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/injection/ConstructorInjectionTest.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Observer;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.BDDMockito.given;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class ConstructorInjectionTest {\n+\n+    @Mock private Observer observer;\n+    private ArgConstructor whatever;\n+\n+    @Mock private ConstructorArgumentResolver resolver;\n+    private ConstructorInjection underTest;\n+\n+    @Before\n+    public void initialize_dependencies() {\n+        underTest = new ConstructorInjection(resolver);\n+    }\n+\n+    @Test\n+    public void should_do_the_trick_of_instantiating() throws Exception {\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[] { observer });\n+\n+        boolean result = underTest.process(field(\"whatever\"), this, newSetOf(observer));\n+\n+        assertTrue(result);\n+        assertNotNull(whatever);\n+    }\n+\n+    private Set<Object> newSetOf(Object item) {\n+        HashSet<Object> mocks = new HashSet<Object>();\n+        mocks.add(item);\n+        return mocks;\n+    }\n+\n+    private Field field(String fieldName) throws NoSuchFieldException {\n+        return this.getClass().getDeclaredField(fieldName);\n+    }\n+\n+    private static class ArgConstructor {\n+        ArgConstructor(Observer observer) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/injection/SimpleArgumentResolverTest.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.junit.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SimpleArgumentResolverTest {\n+\n+    @Test\n+    public void should_return_object_matching_given_types() throws Exception {\n+        ConstructorInjection.SimpleArgumentResolver resolver =\n+                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream(), new HashMap()));\n+\n+        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);\n+\n+        assertEquals(3, resolvedInstance.length);\n+        assertTrue(resolvedInstance[0] instanceof Set);\n+        assertTrue(resolvedInstance[1] instanceof Map);\n+        assertTrue(resolvedInstance[2] instanceof OutputStream);\n+    }\n+\n+    @Test\n+    public void should_return_null_when_match_is_not_possible_on_given_types() throws Exception {\n+        ConstructorInjection.SimpleArgumentResolver resolver =\n+                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream()));\n+\n+        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);\n+\n+        assertEquals(3, resolvedInstance.length);\n+        assertTrue(resolvedInstance[0] instanceof Set);\n+        assertNull(resolvedInstance[1]);\n+        assertTrue(resolvedInstance[2] instanceof OutputStream);\n+    }\n+\n+    @Test\n+    public void should_return_null_when_types_are_primitives() throws Exception {\n+        ConstructorInjection.SimpleArgumentResolver resolver =\n+                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(), new TreeSet()));\n+\n+        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, Boolean.class);\n+\n+        assertEquals(3, resolvedInstance.length);\n+        assertTrue(resolvedInstance[0] instanceof Set);\n+        assertTrue(resolvedInstance[1] instanceof Map);\n+        assertNull(resolvedInstance[2]);\n+    }\n+\n+    private Set<Object> newSetOf(Object... objects) {\n+        return new HashSet<Object>(Arrays.asList(objects));\n+    }\n+\n+\n+}\n--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n     public void should_keep_same_instance_if_field_initialized() throws Exception {\n         final StaticClass backupInstance = alreadyInstantiated;\n         FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"alreadyInstantiated\"));\n-        assertSame(backupInstance, fieldInitializer.initialize());\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertSame(backupInstance, report.fieldInstance());\n+        assertFalse(report.fieldWasInitialized());\n     }\n \n     @Test\n     public void should_instantiate_field_when_type_has_no_constructor() throws Exception {\n         FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"noConstructor\"));\n-        assertNotNull(fieldInitializer.initialize());\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertNotNull(report.fieldInstance());\n+        assertTrue(report.fieldWasInitialized());\n     }\n \n     @Test\n     public void should_instantiate_field_with_default_constructor() throws Exception {\n         FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"defaultConstructor\"));\n-        assertNotNull(fieldInitializer.initialize());\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertNotNull(report.fieldInstance());\n+        assertTrue(report.fieldWasInitialized());\n     }\n \n     @Test\n     public void should_instantiate_field_with_private_default_constructor() throws Exception {\n         FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"privateDefaultConstructor\"));\n-        assertNotNull(fieldInitializer.initialize());\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertNotNull(report.fieldInstance());\n+        assertTrue(report.fieldWasInitialized());\n     }\n \n     @Test(expected = MockitoException.class)\n     @Test\n     public void can_instantiate_class_with_parameterized_constructor() throws Exception {\n         ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))\n-                        .willReturn(new Object[] { null }).getMock();\n+                        .willReturn(new Object[]{null}).getMock();\n \n         new FieldInitializer(this, field(\"noDefaultConstructor\"), resolver).initialize();\n \n--- a/test/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java\n+++ b/test/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java\n             new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n             fail();\n         } catch (MockitoException e) {\n-            assertThat(e.getMessage()).contains(\"resolver\").contains(\"incorrect types\");\n+            assertThat(e.getMessage()).contains(\"argResolver\").contains(\"incorrect types\");\n         }\n     }\n \n--- a/test/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java\n+++ b/test/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java\n         assertNotNull(test.mock);\n         assertNull(test.tested.dependency);\n     }\n-}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java\n+package org.mockitousage.annotation;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockitousage.examples.use.ArticleCalculator;\n+import org.mockitousage.examples.use.ArticleDatabase;\n+import org.mockitousage.examples.use.ArticleManager;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MockInjectionUsingConstructorTest {\n+    private MockUtil mockUtil = new MockUtil();\n+\n+    @Mock private ArticleCalculator calculator;\n+    @Mock private ArticleDatabase database;\n+\n+    @InjectMocks private ArticleManager articleManager;\n+    @Spy @InjectMocks private ArticleManager spiedArticleManager;\n+\n+\n+    @InjectMocks private ArticleVisitor should_be_initialized_several_times;\n+\n+    @Test\n+    public void shouldNotFailWhenNotInitialized() {\n+        assertNotNull(articleManager);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void innerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {\n+        when(calculator.countArticles(\"new\")).thenThrow(new IllegalArgumentException());\n+\n+        articleManager.updateArticleCounters(\"new\");\n+    }\n+\n+    @Test\n+    public void mockJustWorks() {\n+        articleManager.updateArticleCounters(\"new\");\n+    }\n+\n+    @Test\n+    public void constructor_is_called_for_each_test() throws Exception {\n+        int number_of_test_before_including_this_one = 4;\n+        assertEquals(number_of_test_before_including_this_one, articleVisitorInstantiationCount);\n+        assertEquals(number_of_test_before_including_this_one, articleVisitorMockInjectedInstances.size());\n+    }\n+\n+    @Test\n+    @Ignore(\"Works must be done on the spy annotation engine and the injection engine\")\n+    public void objects_created_with_constructor_initialization_can_be_spied() throws Exception {\n+        assertFalse(mockUtil.isMock(articleManager));\n+        assertTrue(mockUtil.isMock(spiedArticleManager));\n+    }\n+\n+    @Test\n+    @Ignore(\"Work should be done on error reporting on this matter\")\n+    public void should_report_failure_only_when_object_initialization_throws_exception() throws Exception {\n+\n+    }\n+\n+    private static int articleVisitorInstantiationCount = 0;\n+    private static Set<Object> articleVisitorMockInjectedInstances = new HashSet<Object>();\n+\n+    private static class ArticleVisitor {\n+        public ArticleVisitor(ArticleCalculator calculator) {\n+            articleVisitorInstantiationCount++;\n+            articleVisitorMockInjectedInstances.add(calculator);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+@SuppressWarnings({\"unchecked\", \"unused\"})\n+public class MockInjectionUsingSetterOrPropertyTest extends TestBase {\n+\n+\tprivate SuperUnderTesting superUnderTestWithoutInjection = new SuperUnderTesting();\n+\t@InjectMocks private SuperUnderTesting superUnderTest = new SuperUnderTesting();\n+\t@InjectMocks private BaseUnderTesting baseUnderTest = new BaseUnderTesting();\n+\t@InjectMocks private SubUnderTesting subUnderTest = new SubUnderTesting();\n+\t@InjectMocks private OtherBaseUnderTesting otherBaseUnderTest = new OtherBaseUnderTesting();\n+\n+    private BaseUnderTesting baseUnderTestingInstance = new BaseUnderTesting();\n+    @InjectMocks private BaseUnderTesting initializedBase = baseUnderTestingInstance;\n+    @InjectMocks private BaseUnderTesting notInitializedBase;\n+\n+    @Spy @InjectMocks private SuperUnderTesting initializedSpy = new SuperUnderTesting();\n+    @Spy @InjectMocks private SuperUnderTesting notInitializedSpy;\n+\n+    @Mock private Map map;\n+    @Mock private List list;\n+\t@Mock private Set histogram1;\n+\t@Mock private Set histogram2;\n+\t@Spy private TreeSet searchTree = new TreeSet();\n+    private MockUtil mockUtil = new MockUtil();\n+\n+    @Before\n+\tpublic void init() {\n+\t\t// initMocks called in TestBase Before method, so instances ar not the same\n+\t\tMockitoAnnotations.initMocks(this);\n+\t}\n+\n+    @Test\n+    public void shouldKeepSameInstanceIfFieldInitialized() {\n+        assertSame(baseUnderTestingInstance, initializedBase);\n+    }\n+\n+    @Test\n+    public void shouldInitializeAnnotatedFieldIfNull() {\n+        assertNotNull(notInitializedBase);\n+    }                                          \n+\n+    @Test\n+    public void shouldIInjectMocksInSpy() {\n+        assertNotNull(initializedSpy.getAList());\n+        assertTrue(mockUtil.isMock(initializedSpy));\n+    }\n+    @Test\n+    public void shouldInitializeSpyIfNullAndInjectMocks() {\n+        assertNotNull(notInitializedSpy);\n+        assertNotNull(notInitializedSpy.getAList());\n+        assertTrue(mockUtil.isMock(notInitializedSpy));\n+    }\n+\n+\t@Test\n+\tpublic void shouldInjectMocksIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, superUnderTest.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotInjectIfNotAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertNull(superUnderTestWithoutInjection.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksForClassHierarchyIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, baseUnderTest.getAList());\n+\t\tassertSame(map, baseUnderTest.getAMap());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksByName() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(histogram1, subUnderTest.getHistogram1());\n+\t\tassertSame(histogram2, subUnderTest.getHistogram2());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectSpies() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(searchTree, otherBaseUnderTest.getSearchTree());\n+\t}\n+\t\n+    @Test\n+    public void shouldInstantiateInjectMockFieldIfPossible() throws Exception {\n+        assertNotNull(notInitializedBase);\n+    }\n+\n+    @Test\n+    public void shouldKeepInstanceOnInjectMockFieldIfPresent() throws Exception {\n+        assertSame(baseUnderTestingInstance, initializedBase);\n+    }\n+\n+    @Test\n+    public void shouldReportNicely() throws Exception {\n+        Object failing = new Object() {\n+            @InjectMocks\n+            ThrowingConstructor c;\n+        };\n+        try {\n+            MockitoAnnotations.initMocks(failing);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertContains(\"correct usage of @InjectMocks\", e.getMessage());\n+        }\n+    }\n+\n+    static class ThrowingConstructor {\n+        ThrowingConstructor() { throw new RuntimeException(\"aha\");};\n+    }\n+\n+    static class SuperUnderTesting {\n+\n+\t\tprivate List aList;\n+\n+\t\tpublic List getAList() {\n+\t\t\treturn aList;\n+\t\t}\n+\t}\n+\n+\tstatic class BaseUnderTesting extends SuperUnderTesting {\n+\t\tprivate Map aMap;\n+\n+\t\tpublic Map getAMap() {\n+\t\t\treturn aMap;\n+\t\t}\n+\t}\n+\n+\tstatic class OtherBaseUnderTesting extends SuperUnderTesting {\n+\t\tprivate TreeSet searchTree;\n+\n+\t\tpublic TreeSet getSearchTree() {\n+\t\t\treturn searchTree;\n+\t\t}\n+\t}\n+\n+\tstatic class SubUnderTesting extends BaseUnderTesting {\n+\t\tprivate Set histogram1;\n+\t\tprivate Set histogram2;\n+\n+\t\tpublic Set getHistogram1() {\n+\t\t\treturn histogram1;\n+\t\t}\n+\n+\t\tpublic Set getHistogram2() {\n+\t\t\treturn histogram2;\n+\t\t}\n+\t}\n+}", "timestamp": 1300637831, "metainfo": ""}