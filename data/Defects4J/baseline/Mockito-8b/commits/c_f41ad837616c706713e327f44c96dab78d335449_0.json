{"sha": "f41ad837616c706713e327f44c96dab78d335449", "log": "tuned exceptions. changed expected into wanted in many places to move Mockito far away from \"record expected\" pattern.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4097", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n         return verify(mock, 1);\n     }\n     \n-    public static <T> T verify(T mock, int expectedNumberOfInvocations) {\n-        return verify(mock, VerifyingMode.times(expectedNumberOfInvocations));\n+    public static <T> T verify(T mock, int wantedNumberOfInvocations) {\n+        return verify(mock, VerifyingMode.times(wantedNumberOfInvocations));\n     }\n     \n     public static <T> T verify(T mock, VerifyingMode mode) {\n--- a/src/org/mockito/MockitoExperimental.java\n+++ b/src/org/mockito/MockitoExperimental.java\n \n /**\n  * experimental assert-like syntax\n- * \n- * @author Szczepan Faber\n  */\n public class MockitoExperimental extends Mockito {\n \n         return verify(mock);\n     }\n \n-    public static <T> T assertInvoked(T mock, int expectedNumberOfInvocations) {\n-        return verify(mock, expectedNumberOfInvocations);\n+    public static <T> T assertInvoked(T mock, int wantedNumberOfInvocations) {\n+        return verify(mock, wantedNumberOfInvocations);\n     }\n     \n     public static void assertNoMoreInteractions(Object ... mocks) {\n         return new WasInvokedMatcher<T>(mock);\n     }\n     \n-    public static <T> MockitoMatcher<T> wasInvoked(T mock, int expectedNumberOfInvocations) {\n-        return new WasInvokedMatcher<T>(mock, expectedNumberOfInvocations);\n+    public static <T> MockitoMatcher<T> wasInvoked(T mock, int wantedNumberOfInvocations) {\n+        return new WasInvokedMatcher<T>(mock, wantedNumberOfInvocations);\n     }\n     \n     public static <T> MockitoMatcher<T> noMoreInteractions(T mock) {\n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n     <T> T verify(T mock);\n \n     //TODO get rid of interface with int\n-    <T> T verify(T mock, int expectedNumberOfInvocations);\n+    <T> T verify(T mock, int wantedNumberOfInvocations);\n     \n     <T> T verify(T mock, VerifyingMode verifyingMode);\n     \n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n     public static void numberOfInvocationsDiffers(int wantedCount, int actualCount, String wanted) {\n         throw new NumberOfInvocationsError(join(\n                 wanted,\n-                \"Expected \" + pluralize(wantedCount) + \" but was \" + actualCount\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ));\n     }\n \n--- a/src/org/mockito/hamcrest/WasInvokedMatcher.java\n+++ b/src/org/mockito/hamcrest/WasInvokedMatcher.java\n \n public class WasInvokedMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n     private final T mock;\n-    private final int expectedNumberOfInvocations;\n+    private final int wantedNumberOfInvocations;\n \n     public WasInvokedMatcher(T mock) {\n         this(mock, -1);\n     }\n     \n-    public WasInvokedMatcher(T mock, int expectedNumberOfInvocations) {\n+    public WasInvokedMatcher(T mock, int wantedNumberOfInvocations) {\n         this.mock = mock;\n-        this.expectedNumberOfInvocations = expectedNumberOfInvocations;\n+        this.wantedNumberOfInvocations = wantedNumberOfInvocations;\n     }\n \n     public boolean matches(Object arg0) {\n         return mock;\n     }\n \n-    public int getExpectedNumberOfInvocations() {\n-        return expectedNumberOfInvocations;\n+    public int getWantedNumberOfInvocations() {\n+        return wantedNumberOfInvocations;\n     }\n }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n \n         List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n         \n-        ExpectedInvocation expectedInvocation = new ExpectedInvocation(invocation, processedMatchers);\n+        ExpectedInvocation invocationWithMatchers = new ExpectedInvocation(invocation, processedMatchers);\n         \n         if (verifyingMode != null) {\n-            behavior.verify(expectedInvocation, verifyingMode);\n+            behavior.verify(invocationWithMatchers, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n         }\n         \n         \n         mockitoState.reportLastControl(this);\n         \n-        behavior.addInvocation(expectedInvocation);\n+        behavior.addInvocation(invocationWithMatchers);\n         \n         if (throwableToBeSetOnVoidMethod != null) {\n             andThrows(throwableToBeSetOnVoidMethod);\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n         this.results.put(invocationForStubbing, result);\n     }\n \n-    public void verify(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        checkOrderOfInvocations(expected, verifyingMode);\n-        checkForMissingInvocation(expected, verifyingMode);\n-        checkForWrongNumberOfInvocations(expected, verifyingMode);        \n-        registeredInvocations.markInvocationsAsVerified(expected, verifyingMode);\n+    public void verify(ExpectedInvocation wanted, VerifyingMode mode) {\n+        checkOrderOfInvocations(wanted, mode);\n+        checkForMissingInvocation(wanted, mode);\n+        checkForWrongNumberOfInvocations(wanted, mode);        \n+        registeredInvocations.markInvocationsAsVerified(wanted, mode);\n     }\n     \n-    private void checkForMissingInvocation(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        int actualCount = registeredInvocations.countActual(expected);\n-        Integer expectedCount = verifyingMode.expectedCount();\n-        boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n+    private void checkForMissingInvocation(ExpectedInvocation wanted, VerifyingMode mode) {\n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        boolean atLeastOnce = mode.atLeastOnceMode();\n                \n-        if ((atLeastOnce || expectedCount == 1) && actualCount == 0) {\n-            reportMissingInvocationError(expected);\n+        if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n+            reportMissingInvocationError(wanted);\n         }\n     }\n \n-    void checkForWrongNumberOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        if (verifyingMode.orderOfInvocationsMatters()) {\n+    void checkForWrongNumberOfInvocations(ExpectedInvocation wanted, VerifyingMode mode) {\n+        if (mode.orderOfInvocationsMatters()) {\n             return;\n         }\n         \n-        int actuallyInvoked = registeredInvocations.countActual(expected);\n-        Integer expectedInvoked = verifyingMode.expectedCount();\n-        boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        boolean atLeastOnce = mode.atLeastOnceMode();\n         \n-        if (!atLeastOnce && actuallyInvoked != expectedInvoked) {\n-            Exceptions.numberOfInvocationsDiffers(expectedInvoked, actuallyInvoked, expected.toString());\n+        if (!atLeastOnce && actualCount != wantedCount) {\n+            Exceptions.numberOfInvocationsDiffers(wantedCount, actualCount, wanted.toString());\n         }\n     }\n \n         \n         List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n         \n-        if (mode.expectedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n+        if (mode.wantedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n             Exceptions.numberOfInvocationsDiffers(0, chunks.get(0).getCount(), wanted.toString());\n-        } else if (mode.expectedCountIsZero()) {\n+        } else if (mode.wantedCountIsZero()) {\n             return;\n         }\n         \n             reportDiscrepancy(wanted, chunks.get(0).getInvocation(), Exceptions.STRICT_DISCREPANCY);\n         }\n         \n-        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.expectedCount()) {\n-            Exceptions.numberOfInvocationsDiffers(mode.expectedCount(), chunks.get(0).getCount(), wanted.toString());\n+        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.wantedCount()) {\n+            Exceptions.numberOfInvocationsDiffers(mode.wantedCount(), chunks.get(0).getCount(), wanted.toString());\n         }\n     }\n \n     public void verifyNoMoreInteractions() {\n-        verifyNoMoreInteractions(\"No more interactions expected\");\n+        verifyNoMoreInteractions(\"No more interactions wanted\");\n     }\n     \n     public void verifyZeroInteractions() {\n-        verifyNoMoreInteractions(\"Zero interactions expected\");\n+        verifyNoMoreInteractions(\"Zero interactions wanted\");\n     }\n     \n     private void verifyNoMoreInteractions(String message) {\n         }\n     }\n \n-    public Object resultFor(Invocation invocation) throws Throwable {\n-        for (ExpectedInvocation expectedInvocation : results.keySet()) {\n-            if (expectedInvocation.matches(invocation)) {\n-                return results.get(expectedInvocation).answer();\n+    public Object resultFor(Invocation wanted) throws Throwable {\n+        for (ExpectedInvocation i : results.keySet()) {\n+            if (i.matches(wanted)) {\n+                return results.get(i).answer();\n             }\n         }\n \n-        return ToTypeMappings.emptyReturnValueFor(invocation.getMethod().getReturnType());\n+        return ToTypeMappings.emptyReturnValueFor(wanted.getMethod().getReturnType());\n     }\n \n     public T getMock() {\n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n     }\n     \n     public void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode mode) {\n-        if (mode.expectedCountIsZero()) {\n+        if (mode.wantedCountIsZero()) {\n             return;\n         }\n         \n         return chunks;\n     }\n     \n-    public Invocation findSimilarInvocation(ExpectedInvocation expectedInvocation) {\n+    public Invocation findSimilarInvocation(ExpectedInvocation wanted) {\n         for (Invocation registered : registeredInvocations) {\n-            String expectedMethodName = expectedInvocation.getMethod().getName();\n+            String wantedMethodName = wanted.getMethod().getName();\n             String registeredInvocationName = registered.getMethod().getName();\n-            if (expectedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n+            if (wantedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n                 return registered;\n             }\n         }\n         return null;\n     }\n     \n-    public int countActual(ExpectedInvocation expectedInvocation) {\n+    public int countActual(ExpectedInvocation wanted) {\n         int actual = 0;\n         for (Invocation registeredInvocation : registeredInvocations) {\n-            if (expectedInvocation.matches(registeredInvocation)) {\n+            if (wanted.matches(registeredInvocation)) {\n                 actual++;\n             }\n         }\n--- a/src/org/mockito/internal/StrictOrderVerifier.java\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n         return this.verify(mock, 1);\n     }\n     //TODO get rid of interface with int\n-    public <T> T verify(T mock, int expectedNumberOfInvocations) {\n-        return this.verify(mock, VerifyingMode.inOrder(expectedNumberOfInvocations, mocksToBeVerifiedInOrder));\n+    public <T> T verify(T mock, int wantedNumberOfInvocations) {\n+        return this.verify(mock, VerifyingMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n     }\n     \n     public <T> T verify(T mock, VerifyingMode verifyingMode) {\n         if (!mocksToBeVerifiedInOrder.contains(mock)) {\n             Exceptions.strictlyRequiresFamiliarMock();\n         }\n-        return Mockito.verify(mock, VerifyingMode.inOrder(verifyingMode.expectedCount(), mocksToBeVerifiedInOrder));\n+        return Mockito.verify(mock, VerifyingMode.inOrder(verifyingMode.wantedCount(), mocksToBeVerifiedInOrder));\n     }\n \n     public void verifyNoMoreInteractions() {\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n \n public class VerifyingMode {\n \n-    private final Integer expectedInvocationCount;\n+    private final Integer wantedInvocationCount;\n     private final List<Object> mocksToBeVerifiedInSequence;\n \n-    private VerifyingMode(Integer expectedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n-        if (expectedNumberOfInvocations != null && expectedNumberOfInvocations.intValue() < 0) {\n+    private VerifyingMode(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n+        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n             throw new MockitoException(\"Negative value is not allowed here\");\n         }\n-        this.expectedInvocationCount = expectedNumberOfInvocations;\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n         this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n     }\n     \n         return new VerifyingMode(null, Collections.emptyList());\n     }\n \n-    public static VerifyingMode times(int expectedNumberOfInvocations) {\n-        return new VerifyingMode(expectedNumberOfInvocations, Collections.emptyList());\n+    public static VerifyingMode times(int wantedNumberOfInvocations) {\n+        return new VerifyingMode(wantedNumberOfInvocations, Collections.emptyList());\n     }\n     \n     /**\n      */\n     public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n     \n-    static VerifyingMode inOrder(Integer expectedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n-        return new VerifyingMode(expectedNumberOfInvocations, mocksToBeVerifiedInOrder);\n+    static VerifyingMode inOrder(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n+        return new VerifyingMode(wantedNumberOfInvocations, mocksToBeVerifiedInOrder);\n     }\n \n     boolean atLeastOnceMode() {\n-        return expectedInvocationCount == null;\n+        return wantedInvocationCount == null;\n     }\n \n-    Integer expectedCount() {\n-        return expectedInvocationCount;\n+    Integer wantedCount() {\n+        return wantedInvocationCount;\n     }\n \n     List<Object> getAllMocksToBeVerifiedInSequence() {\n         return !mocksToBeVerifiedInSequence.isEmpty();\n     }\n \n-    public boolean expectedCountIsZero() {\n-        return expectedInvocationCount != null && expectedInvocationCount == 0;\n+    public boolean wantedCountIsZero() {\n+        return wantedInvocationCount != null && wantedInvocationCount == 0;\n     }\n }\n--- a/src/org/mockito/internal/matchers/ArrayEquals.java\n+++ b/src/org/mockito/internal/matchers/ArrayEquals.java\n \n public class ArrayEquals extends Equals {\n \n-    public ArrayEquals(Object expected) {\n-        super(expected);\n+    public ArrayEquals(Object wanted) {\n+        super(wanted);\n     }\n \n     public boolean matches(Object actual) {\n-        Object expected = getExpected();\n-        if (expected instanceof boolean[]\n+        Object wanted = getWanted();\n+        if (wanted instanceof boolean[]\n                 && (actual == null || actual instanceof boolean[])) {\n-            return Arrays.equals((boolean[]) expected, (boolean[]) actual);\n-        } else if (expected instanceof byte[]\n+            return Arrays.equals((boolean[]) wanted, (boolean[]) actual);\n+        } else if (wanted instanceof byte[]\n                 && (actual == null || actual instanceof byte[])) {\n-            return Arrays.equals((byte[]) expected, (byte[]) actual);\n-        } else if (expected instanceof char[]\n+            return Arrays.equals((byte[]) wanted, (byte[]) actual);\n+        } else if (wanted instanceof char[]\n                 && (actual == null || actual instanceof char[])) {\n-            return Arrays.equals((char[]) expected, (char[]) actual);\n-        } else if (expected instanceof double[]\n+            return Arrays.equals((char[]) wanted, (char[]) actual);\n+        } else if (wanted instanceof double[]\n                 && (actual == null || actual instanceof double[])) {\n-            return Arrays.equals((double[]) expected, (double[]) actual);\n-        } else if (expected instanceof float[]\n+            return Arrays.equals((double[]) wanted, (double[]) actual);\n+        } else if (wanted instanceof float[]\n                 && (actual == null || actual instanceof float[])) {\n-            return Arrays.equals((float[]) expected, (float[]) actual);\n-        } else if (expected instanceof int[]\n+            return Arrays.equals((float[]) wanted, (float[]) actual);\n+        } else if (wanted instanceof int[]\n                 && (actual == null || actual instanceof int[])) {\n-            return Arrays.equals((int[]) expected, (int[]) actual);\n-        } else if (expected instanceof long[]\n+            return Arrays.equals((int[]) wanted, (int[]) actual);\n+        } else if (wanted instanceof long[]\n                 && (actual == null || actual instanceof long[])) {\n-            return Arrays.equals((long[]) expected, (long[]) actual);\n-        } else if (expected instanceof short[]\n+            return Arrays.equals((long[]) wanted, (long[]) actual);\n+        } else if (wanted instanceof short[]\n                 && (actual == null || actual instanceof short[])) {\n-            return Arrays.equals((short[]) expected, (short[]) actual);\n-        } else if (expected instanceof Object[]\n+            return Arrays.equals((short[]) wanted, (short[]) actual);\n+        } else if (wanted instanceof Object[]\n                 && (actual == null || actual instanceof Object[])) {\n-            return Arrays.equals((Object[]) expected, (Object[]) actual);\n+            return Arrays.equals((Object[]) wanted, (Object[]) actual);\n         } else {\n             return super.matches(actual);\n         }\n \n     public void appendTo(StringBuffer buffer) {\n         //TODO not tested\n-        if (getExpected() != null && getExpected().getClass().isArray()) {\n-            appendArray(createObjectArray(getExpected()), buffer);\n+        if (getWanted() != null && getWanted().getClass().isArray()) {\n+            appendArray(createObjectArray(getWanted()), buffer);\n         } else {\n             super.appendTo(buffer);\n         }\n--- a/src/org/mockito/internal/matchers/Compare.java\n+++ b/src/org/mockito/internal/matchers/Compare.java\n \n public class Compare<T> implements IArgumentMatcher {\n \n-    private T expected;\n+    private T wanted;\n \n     private Comparator<T> comparator;\n \n     private LogicalOperator operator;\n \n-    public Compare(T expected, Comparator<T> comparator, LogicalOperator result) {\n-        this.expected = expected;\n+    public Compare(T wanted, Comparator<T> comparator, LogicalOperator result) {\n+        this.wanted = wanted;\n         this.comparator = comparator;\n         this.operator = result;\n     }\n \n     public void appendTo(StringBuffer buffer) {\n-        buffer.append(comparator + \"(\" + expected + \") \" + operator.getSymbol()\n+        buffer.append(comparator + \"(\" + wanted + \") \" + operator.getSymbol()\n                 + \" 0\");\n     }\n \n         if(actual == null) {\n             return false;\n         }\n-        return operator.matchResult(comparator.compare((T) actual, expected));\n+        return operator.matchResult(comparator.compare((T) actual, wanted));\n     }\n \n }\n--- a/src/org/mockito/internal/matchers/CompareTo.java\n+++ b/src/org/mockito/internal/matchers/CompareTo.java\n \n \n public abstract class CompareTo<T extends Comparable<T>> implements IArgumentMatcher {\n-    private final Comparable<T> expected;\n+    private final Comparable<T> wanted;\n \n     public CompareTo(Comparable<T> value) {\n-        this.expected = value;\n+        this.wanted = value;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n             return false;\n         }\n         \n-        return matchResult(((Comparable) actual).compareTo(expected));\n+        return matchResult(((Comparable) actual).compareTo(wanted));\n     }\n \n     public void appendTo(StringBuffer buffer) {\n-        buffer.append(getName() + \"(\" + expected + \")\");\n+        buffer.append(getName() + \"(\" + wanted + \")\");\n     }\n     \n     protected abstract String getName();\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n \n public class Equals implements IArgumentMatcher {\n \n-    private final Object expected;\n+    private final Object wanted;\n \n-    public Equals(Object expected) {\n-        this.expected = expected;\n+    public Equals(Object wanted) {\n+        this.wanted = wanted;\n     }\n \n     public boolean matches(Object actual) {\n-        if (this.expected == null) {\n+        if (this.wanted == null) {\n             return actual == null;\n         }\n-        return expected.equals(actual);\n+        return wanted.equals(actual);\n     }\n \n     public void appendTo(StringBuffer buffer) {\n         appendQuoting(buffer);\n-        buffer.append(expected);\n+        buffer.append(wanted);\n         appendQuoting(buffer);\n     }\n \n     private void appendQuoting(StringBuffer buffer) {\n-        if (expected instanceof String) {\n+        if (wanted instanceof String) {\n             buffer.append(\"\\\"\");\n-        } else if (expected instanceof Character) {\n+        } else if (wanted instanceof Character) {\n             buffer.append(\"'\");\n         }\n     }\n \n-    protected final Object getExpected() {\n-        return expected;\n+    protected final Object getWanted() {\n+        return wanted;\n     }\n \n     @Override\n         if (o == null || !this.getClass().equals(o.getClass()))\n             return false;\n         Equals other = (Equals) o;\n-        return this.expected == null && other.expected == null\n-                || this.expected != null\n-                && this.expected.equals(other.expected);\n+        return this.wanted == null && other.wanted == null\n+                || this.wanted != null\n+                && this.wanted.equals(other.wanted);\n     }\n \n     @Override\n--- a/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n \n \n public class EqualsWithDelta implements IArgumentMatcher {\n-    private final Number expected;\n+    private final Number wanted;\n \n     private final Number delta;\n \n     public EqualsWithDelta(Number value, Number delta) {\n-        this.expected = value;\n+        this.wanted = value;\n         this.delta = delta;\n     }\n \n     public boolean matches(Object actual) {\n         Number actualNumber = (Number) actual;\n-        return expected.doubleValue() - delta.doubleValue() <= actualNumber\n+        return wanted.doubleValue() - delta.doubleValue() <= actualNumber\n                 .doubleValue()\n-                && actualNumber.doubleValue() <= expected.doubleValue()\n+                && actualNumber.doubleValue() <= wanted.doubleValue()\n                         + delta.doubleValue();\n     }\n \n     public void appendTo(StringBuffer buffer) {\n-        buffer.append(\"eq(\" + expected + \", \" + delta + \")\");\n+        buffer.append(\"eq(\" + wanted + \", \" + delta + \")\");\n     }\n }\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n \n public class Same implements IArgumentMatcher {\n \n-    private final Object expected;\n+    private final Object wanted;\n \n-    public Same(Object expected) {\n-        this.expected = expected;\n+    public Same(Object wanted) {\n+        this.wanted = wanted;\n     }\n \n     public boolean matches(Object actual) {\n-        return expected == actual;\n+        return wanted == actual;\n     }\n \n     public void appendTo(StringBuffer buffer) {\n         buffer.append(\"same(\");\n         appendQuoting(buffer);\n-        buffer.append(expected);\n+        buffer.append(wanted);\n         appendQuoting(buffer);\n         buffer.append(\")\");\n     }\n \n     private void appendQuoting(StringBuffer buffer) {\n-        if (expected instanceof String) {\n+        if (wanted instanceof String) {\n             buffer.append(\"\\\"\");\n-        } else if (expected instanceof Character) {\n+        } else if (wanted instanceof Character) {\n             buffer.append(\"'\");\n         }\n     }\n--- a/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n     }\n     \n     @Test\n-    public void shouldVerifyActualNumberOfInvocationsSmallerThanExpected() throws Exception {\n+    public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted() throws Exception {\n         mock.clear();\n         mock.clear();\n         mock.clear();\n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n         \t\t\"\\n\" +\n-        \t\t\"Expected 100 times but was 3\";\n+        \t\t\"Wanted 100 times but was 3\";\n             assertEquals(expected, e.getMessage());\n         }\n     }\n     \n     @Test\n-    public void shouldVerifyActualNumberOfInvocationsLargerThanExpected() throws Exception {\n+    public void shouldVerifyActualNumberOfInvocationsLargerThanWanted() throws Exception {\n         mock.clear();\n         mock.clear();\n         mock.clear();\n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n                 \"\\n\" +\n-                \"Expected 1 time but was 3\";\n+                \"Wanted 1 time but was 3\";\n             assertEquals(expected, e.getMessage());\n         }\n     }\n             Mockito.verify(mock, 15).clear();\n             fail();\n         } catch (NumberOfInvocationsError e) {\n-            assertTrue(e.getMessage().endsWith(\"Expected 15 times but was 0\"));\n+            assertTrue(e.getMessage().endsWith(\"Wanted 15 times but was 0\"));\n         }\n     }\n     \n             Mockito.verify(mock, 15).clear();\n             fail();\n         } catch (NumberOfInvocationsError e) {\n-            assertTrue(e.getMessage().endsWith(\"Expected 15 times but was 1\"));\n+            assertTrue(e.getMessage().endsWith(\"Wanted 15 times but was 1\"));\n         }\n     }\n     \n     @Test\n-    public void shouldFailWhenExpectedNumberOfInvocationIsZero() throws Exception {\n+    public void shouldFailWhenWantedNumberOfInvocationIsZero() throws Exception {\n         mock.clear();\n         \n         try {\n     }\n     \n     @Test\n-    public void shouldVerifyWhenExpectedNumberOfInvocationIsZero() throws Exception {\n+    public void shouldVerifyWhenWantedNumberOfInvocationIsZero() throws Exception {\n         Mockito.verify(mock, 0).clear();\n     }\n     \n--- a/test/org/mockito/usage/verification/NiceMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesOnStrictOrderErrorsTest.java\n \n import org.junit.*;\n import org.mockito.*;\n-import org.mockito.exceptions.VerificationError;\n+import org.mockito.exceptions.*;\n import org.mockito.usage.IMethods;\n \n public class NiceMessagesOnStrictOrderErrorsTest {\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }   \n+    \n+    @Test\n+    public void shouldPrintWrongNumberOfInvocations() {\n+        strictly.verify(one).simpleMethod(1);\n+        strictly.verify(one).simpleMethod(11);\n+        try {\n+            strictly.verify(two, 1).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 1 time but was 2\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n }\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n     }\n     \n     @Test\n-    public void shouldPrintActualAndExpectedWhenTheDifferenceIsAboutArguments() {\n+    public void shouldPrintActualAndWantedWhenTheDifferenceIsAboutArguments() {\n         mock.oneArg(true);\n         mock.twoArgumentMethod(1, 2);\n         \n     }\n     \n     @Test\n-    public void shouldPrintActualAndExpectedWhenActualMethodNameAndExpectedMethodNameAreTheSame() {\n+    public void shouldPrintActualAndWantedWhenActualMethodNameAndWantedMethodNameAreTheSame() {\n         mock.simpleMethod();\n         \n         try {\n     }    \n     \n     @Test\n-    public void shouldPrintActualAndUnverifiedExpectedWhenTheDifferenceIsAboutArguments() {\n+    public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments() {\n         mock.twoArgumentMethod(1, 1);\n         mock.twoArgumentMethod(2, 2);\n         mock.twoArgumentMethod(3, 3);\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-            \t\t\"No more interactions expected\" +\n+            \t\t\"No more interactions wanted\" +\n             \t\t\"\\n\" +\n             \t\t\"Unexpected: IMethods.oneArg(false)\";\n             assertEquals(expectedMessage, actualMessage);         \n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-                    \"Zero interactions expected\" +\n+                    \"Zero interactions wanted\" +\n                     \"\\n\" +\n                     \"Unexpected: IMethods.twoArgumentMethod(1, 2)\";\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }\n     \n-    //TODO do we need nice message when expected number of invocations = 0?\n+    //TODO do we need nice message when wanted number of invocations = 0?\n }\n--- a/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n     }\n     \n     @Test\n-    public void shouldVerifyWhenExpectedNumberOfInvocationsUsed() throws Exception {\n+    public void shouldVerifyWhenWantedNumberOfInvocationsUsed() throws Exception {\n         List mock = mock(List.class);\n \n         mock.add(\"one\");\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n         strictly.verify(mockOne, 0).oneArg(false);\n         strictly.verify(mockOne).simpleMethod(1);\n         strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockTwo, 0).simpleMethod(22);\n         strictly.verify(mockThree).simpleMethod(3);\n         strictly.verify(mockTwo).simpleMethod(2);\n         strictly.verify(mockOne).simpleMethod(4);\n     }\n     \n     @Test(expected=NumberOfInvocationsError.class)\n-    public void shouldFailOnFirstMethodBecauseOneInvocationExpected() {\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n         strictly.verify(mockOne, 0).simpleMethod(1);\n     }\n     \n     @Test(expected=NumberOfInvocationsError.class)\n-    public void shouldFailOnFirstMethodBecauseOneInvocationExpectedAgain() {\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n         strictly.verify(mockOne, 2).simpleMethod(1);\n     }\n     \n     @Test\n-    public void shouldFailOnSecondMethodBecauseTwoInvocationsExpected() {\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWanted() {\n         strictly.verify(mockOne, 1).simpleMethod(1);\n         try {\n             strictly.verify(mockTwo, 3).simpleMethod(2);\n     }\n     \n     @Test\n-    public void shouldFailOnSecondMethodBecauseTwoInvocationsExpectedAgain() {\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n         strictly.verify(mockOne, 1).simpleMethod(1);\n         try {\n             strictly.verify(mockTwo, 0).simpleMethod(2);\n     }    \n     \n     @Test\n-    public void shouldFailOnLastMethodBecauseOneInvocationExpected() {\n+    public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n         strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n         strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n     }\n     \n     @Test\n-    public void shouldFailOnLastMethodBecauseOneInvocationExpectedAgain() {\n+    public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n         strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n         strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n     /* ------------- */\n     \n     @Test(expected=VerificationError.class)\n-    public void shouldFailOnFirstMethodBecauseDifferentArgsExpected() {\n+    public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n         strictly.verify(mockOne).simpleMethod(100);\n     }\n     \n     @Test(expected=VerificationError.class)\n-    public void shouldFailOnFirstMethodBecauseDifferentMethodExpected() {\n+    public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n         strictly.verify(mockOne).oneArg(true);\n     }\n     \n     @Test\n-    public void shouldFailOnSecondMethodBecauseDifferentArgsExpected() {\n+    public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n         strictly.verify(mockOne).simpleMethod(1);\n         try {\n             strictly.verify(mockTwo, 2).simpleMethod(-999);\n     }\n     \n     @Test\n-    public void shouldFailOnSecondMethodBecauseDifferentMethodExpected() {\n+    public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n         strictly.verify(mockOne, 1).simpleMethod(1);\n         try {\n             strictly.verify(mockTwo, 2).oneArg(true);\n     }    \n     \n     @Test\n-    public void shouldFailOnLastMethodBecauseDifferentArgsExpected() {\n+    public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n         strictly.verify(mockOne).simpleMethod(1);\n         strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n         strictly.verify(mockThree).simpleMethod(3);\n     }\n     \n     @Test\n-    public void shouldFailOnLastMethodBecauseDifferentMethodExpected() {\n+    public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n         strictly.verify(mockOne).simpleMethod(1);\n         strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n         strictly.verify(mockThree).simpleMethod(3);", "timestamp": 1196378179, "metainfo": ""}