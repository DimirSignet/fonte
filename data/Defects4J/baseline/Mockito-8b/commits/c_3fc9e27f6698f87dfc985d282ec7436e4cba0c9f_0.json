{"sha": "3fc9e27f6698f87dfc985d282ec7436e4cba0c9f", "log": "Added missing tests  --HG-- rename : test/org/mockitousage/basicapi/MockInjectionTest.java => test/org/mockitousage/annotation/MockInjectionTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401871", "commit": "\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n         Field[] fields = context.getDeclaredFields();\n         for (Field field : fields) {\n             if (field.isAnnotationPresent(InjectMock.class)) {\n-                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+//                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                 injectMocks(testClass);\n             }\n         }\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/MockInjectionTest.java\n+package org.mockitousage.annotation;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMock;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockInjectionTest extends TestBase {\n+\n+\tprivate SuperUnderTesting superUnderTestWithoutInjection = new SuperUnderTesting();\n+\t@InjectMock private SuperUnderTesting superUnderTest = new SuperUnderTesting();\n+\t@InjectMock private BaseUnderTesting baseUnderTest = new BaseUnderTesting();\n+\t@InjectMock private SubUnderTesting subUnderTest = new SubUnderTesting();\n+\t@InjectMock private OtherBaseUnderTesting otherBaseUnderTest = new OtherBaseUnderTesting();\n+\t@Mock private Map map;\t\n+    @Mock private List list;\n+\t@Mock private Set histogram1;\n+\t@Mock private Set histogram2;\n+\t@Spy private TreeSet searchTree = new TreeSet();\n+\n+\t@Before\n+\tpublic void init() {\n+\t\t// initMocks called in TestBase Before method, so instances ar not the same\n+\t\tMockitoAnnotations.initMocks(this);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, superUnderTest.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotInjectIfNotAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertNull(superUnderTestWithoutInjection.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksForClassHierarchyIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, baseUnderTest.getAList());\n+\t\tassertSame(map, baseUnderTest.getAMap());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksByName() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(histogram1, subUnderTest.getHistogram1());\n+\t\tassertSame(histogram2, subUnderTest.getHistogram2());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectSpies() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(searchTree, otherBaseUnderTest.getSearchTree());\n+\t}\n+\n+\tclass SuperUnderTesting {\n+\n+\t\tprivate List aList;\n+\n+\t\tpublic List getAList() {\n+\t\t\treturn aList;\n+\t\t}\n+\t}\n+\n+\tclass BaseUnderTesting extends SuperUnderTesting {\n+\t\tprivate Map aMap;\n+\n+\t\tpublic Map getAMap() {\n+\t\t\treturn aMap;\n+\t\t}\n+\t}\n+\n+\tclass OtherBaseUnderTesting extends SuperUnderTesting {\n+\t\tprivate TreeSet searchTree;\n+\n+\t\tpublic TreeSet getSearchTree() {\n+\t\t\treturn searchTree;\n+\t\t}\n+\t}\n+\n+\tclass SubUnderTesting extends BaseUnderTesting {\n+\t\tprivate Set histogram1;\n+\t\tprivate Set histogram2;\n+\n+\t\tpublic Set getHistogram1() {\n+\t\t\treturn histogram1;\n+\t\t}\n+\n+\t\tpublic Set getHistogram2() {\n+\t\t\treturn histogram2;\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/SpyInjectionTest.java\n+package org.mockitousage.annotation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMock;\n+import org.mockito.Spy;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class SpyInjectionTest extends TestBase {\n+\n+    @Spy List spy = new LinkedList();\n+    @InjectMock HasSpy hasSpy = new HasSpy();\n+    \n+    static class HasSpy {\n+        private List spy;\n+        public void setSpy(List spy) {\n+            this.spy = spy;\n+        }        \n+    }\n+    \n+\t@Test\n+    public void shouldDoStuff() throws Exception {\n+        isMock(hasSpy.spy);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java\n+package org.mockitousage.annotation;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMock;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class WrongSetOfAnnotationsTest extends TestBase {\n+\t\n+\t//TODO unsupported combinations of annotations (spy - captor, spy - mock)\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowMockAndSpy() throws Exception {\n+        MockitoAnnotations.initMocks(new Object() {\n+            @Mock @Spy List mock;\n+        });\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSpyAndInjectMock() throws Exception {\n+        MockitoAnnotations.initMocks(new Object() {\n+            @InjectMock @Spy List mock;\n+        });\n+    }\n+    \n+//    @Test(expected=MockitoException.class)\n+    //TODO\n+    public void shouldNotAllowMockAndInjectMock() throws Exception {\n+        MockitoAnnotations.initMocks(new Object() {\n+            @InjectMock @Mock List mock;\n+        });\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowCaptorAndMock() throws Exception {\n+        MockitoAnnotations.initMocks(new Object() {\n+            @Mock @Captor ArgumentCaptor captor;\n+        });\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowCaptorAndSpy() throws Exception {\n+        MockitoAnnotations.initMocks(new Object() {\n+            @Spy @Captor ArgumentCaptor captor;\n+        });\n+    }\n+    \n+    //@Test(expected=MockitoException.class)\n+    //TODO\n+    public void shouldNotAllowCaptorAndInjectMock() throws Exception {\n+        MockitoAnnotations.initMocks(new Object() {\n+            @InjectMock @Captor ArgumentCaptor captor;\n+        });\n+    }\n+    \n+    \n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.SerializableMethod;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockito.internal.util.MockUtil;\n \n import java.io.*;\n \n         new ObjectOutputStream(serialized).writeObject(mock);\n         return serialized;\n     }\n+\n+    protected boolean isMock(Object o) {\n+        return new MockUtil().isMock(o);\n+    }\n }", "timestamp": 1267127404, "metainfo": ""}