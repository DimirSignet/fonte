{"sha": "4cce7fa8d5943a37041531f290c2633395665bd2", "log": "Growing the release plugin  Added clean up feature but I'm not liking it very much", "commit": "\n--- a/buildSrc/src/main/groovy/org/mockito/release/steps/ConfigurableReleaseStep.java\n+++ b/buildSrc/src/main/groovy/org/mockito/release/steps/ConfigurableReleaseStep.java\n \n public interface ConfigurableReleaseStep extends ReleaseStep {\n \n-  void rollback(Closure closure); //TODO SF avoid leaking closure here as the release steps should be a java tool\n+  //TODO SF avoid leaking closures here as the release steps should be a java tool\n+\n+  /**\n+   * Rollback operation is executed if the release process fails in some further step\n+   */\n+  void rollback(Closure closure);\n+\n+  /**\n+   * Executed if release is successful. Executed if release is failed provided there is no rollback.\n+   */\n+  void cleanup(Closure closure);\n }\n--- a/buildSrc/src/main/groovy/org/mockito/release/steps/DefaultReleaseStep.java\n+++ b/buildSrc/src/main/groovy/org/mockito/release/steps/DefaultReleaseStep.java\n \n class DefaultReleaseStep implements ConfigurableReleaseStep {\n \n-    private final String description;\n-    private final Operation operation;\n-    private Operation rollback;\n+  private final String description;\n+  private final Operation operation;\n+  private Operation rollback;\n+  private Operation cleanup;\n \n-    public DefaultReleaseStep(String description, Operation operation) {\n-        this.description = description;\n-        this.operation = operation;\n-    }\n+  public DefaultReleaseStep(String description, Operation operation) {\n+    this.description = description;\n+    this.operation = operation;\n+  }\n \n-    public String getDescription() {\n-        return description;\n-    }\n+  public String getDescription() {\n+    return description;\n+  }\n \n-    public void rollback(Closure closure) {\n-        rollback = Operations.toOperation(closure);\n-    }\n+  public void rollback(Closure closure) {\n+    rollback = Operations.toOperation(closure);\n+  }\n \n-    public Operation getRollback() {\n-        return rollback;\n-    }\n+  public void cleanup(Closure closure) {\n+    this.cleanup = Operations.toOperation(closure);\n+  }\n \n-    public void perform() {\n-        operation.perform();\n-    }\n+  public Operation getRollback() {\n+    return rollback;\n+  }\n+\n+  public void perform() {\n+    operation.perform();\n+  }\n+\n+  public Operation getCleanup() {\n+    return cleanup;\n+  }\n }\n--- a/buildSrc/src/main/groovy/org/mockito/release/steps/DefaultReleaseSteps.java\n+++ b/buildSrc/src/main/groovy/org/mockito/release/steps/DefaultReleaseSteps.java\n \n   public void perform() {\n         System.out.println(\"Performing \" + steps.size() + \" release steps\");\n-        List<ReleaseStep> attempted = new LinkedList<ReleaseStep>();\n+        LinkedList<ReleaseStep> attempted = new LinkedList<ReleaseStep>();\n         for (ReleaseStep step : steps) {\n             attempted.add(step);\n             System.out.println(\"Step \" + attempted.size() + \": \" + step.getDescription());\n                 throw new RuntimeException(\"Release failed at step \" + attempted.size() + \" (\" + step.getDescription() + \"). Rollback was performed.\", t);\n             }\n         }\n+        //TODO SF needs tidy up. I should model better the cleanup VS rollback operation\n+        while(!attempted.isEmpty()) {\n+          ReleaseStep step = attempted.removeLast();\n+          Operation cleanup = step.getCleanup();\n+          if (cleanup != null) {\n+            System.out.println(\"Found cleanup operation for step \" + (attempted.size() + 1) + \" (\" + step.getDescription() + \")\");\n+            cleanup.perform();\n+          }\n+        }\n     }\n \n     private static void rollback(List<ReleaseStep> attempted) {\n         while(!targets.isEmpty()) {\n             ReleaseStep s = targets.removeLast();\n             Operation r = s.getRollback();\n+            Operation c = s.getCleanup();\n             if (r != null) {\n-                System.out.println(\"Rolling back step \" + (targets.size() + 1) + \" (\" + s.getDescription() + \")\");\n-                r.perform();\n+              System.out.println(\"Rolling back step \" + (targets.size() + 1) + \" (\" + s.getDescription() + \")\");\n+              r.perform();\n+            } else if (c != null) {\n+              System.out.println(\"Cleaning up after step \" + (targets.size() + 1) + \" (\" + s.getDescription() + \")\");\n+              c.perform();\n             } else {\n-                System.out.println(\"No rollback for step \" + (targets.size() + 1) + \" (\" + s.getDescription() + \")\");\n+              System.out.println(\"No rollback for step \" + (targets.size() + 1) + \" (\" + s.getDescription() + \")\");\n             }\n         }\n     }\n--- a/buildSrc/src/main/groovy/org/mockito/release/steps/ReleaseStep.java\n+++ b/buildSrc/src/main/groovy/org/mockito/release/steps/ReleaseStep.java\n \n public interface ReleaseStep extends Operation {\n \n-    String getDescription();\n+  String getDescription();\n \n   /**\n    * may return null. TODO: I don't like this\n    */\n-    Operation getRollback();\n+  Operation getRollback();\n+\n+  /**\n+   * may return null. TODO: I don't like this\n+   */\n+  Operation getCleanup();\n }", "timestamp": 1419889056, "metainfo": ""}