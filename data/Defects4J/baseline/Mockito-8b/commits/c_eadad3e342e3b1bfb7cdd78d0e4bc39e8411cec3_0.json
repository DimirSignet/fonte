{"sha": "eadad3e342e3b1bfb7cdd78d0e4bc39e8411cec3", "log": "final javadoc tuning  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40731", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * <h3>1. Let's verify some behaviour!</h3>\n  * \n  * <pre>\n- * //Let's import Mockito statically so that code looks clearer\n+ * //Let's import Mockito statically so that the code looks clearer\n  * import static org.mockito.Mockito.*;\n  * \n  * //mock creation\n  * \n  * //following prints \"null\" because get(999) was not stubbed\n  * System.out.println(mockedList.get(999));\n- * \n- * //Stubbed invocations <b>are verified implicitly</b>. The execution flow of your own code does it completely <b>for free</b>. \n- * //Although it is possible to verify a stubbed invocation, in majority of cases <b>it's not necessary</b>:\n+ *  \n+ * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n+ * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n+ * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n  * verify(mockedList).get(0);\n  * </pre>\n  * \n  * <li> Last stubbing is more important - when you stubbed the same method with\n  * the same arguments many times. </li>\n  * \n- * <li> \n- * Although it is possible to verify a stubbed invocation, in majority\n- * of cases it's not necessary: Let's say you've stubbed foo.bar()\n- * method. If your code cares what value foo.bar() returns, something\n- * else will fail if you forget to call foo.bar(). Hence you don't have\n- * to verify() it. It's  (e.g. it's just redundant). Not convinced? See  \n- * <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a></li>\n  * </ul>\n  * \n  * <h3>3. Argument matchers</h3>\n  * verifyNoMoreInteractions(mockedList);\n  * </pre>\n  * \n- * Some users who did a lot of classical, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n+ * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n  * verifyNoMoreInteractions() is not recommended to use in every test method. \n  * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n  * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n  * \n  * Stubbing voids requires different approach from {@link Mockito#stub(Object)} because the compiler does not like void methods inside brackets...\n  * <p>\n- * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids.\n+ * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n+ * The main reason is improved readability and consistency with the family of doAnswer() methods.\n  * <p>\n  * Use doThrow() when you want to stub a void method with an exception:\n  * <pre>\n  * <h3> 13. (**Totally New**) Spying on real objects</h3>\n  * \n  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n+ * <p>\n+ * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n+ * <p>\n+ * Spying on real objects is associated with \"partial mocking\" concept. \n  * \n  * <pre>\n  *   List list = new LinkedList();\n     \n     /**\n      * Creates mock with a name. Naming mocks can be helpful for debugging. \n-     * Remember that naming mocks is not a solution for complex test/code which uses too many mocks. \n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. In that case we recommend merciless refactoring.\n      * <p>\n      * If you use &#064;Mock annotation then you've got naming mocks for free. &#064;Mock uses field name as mock name.\n      * <p>\n     }\n \n     /**\n-     * Creates a spy of the real object. Example:\n+     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n+     * <p>\n+     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n+     * <p>\n+     * Spying on real objects is associated with \"partial mocking\" concept.\n+     * <p>\n+     * Example:\n      * \n      * <pre>\n      *   List list = new LinkedList();\n      *   verify(spy).add(\"two\");\n      * </pre>\n      * \n-     * <h3>IMPORTANT</h3>\n+     * <h4>Important gotcha on spying real objects!</h4>\n      * \n      * Sometimes it's impossible to use {@link Mockito#stub(Object)} for stubbing spies. Example:\n      * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * \n-     * @param <T>\n      * @param object\n      *            to spy on\n      * @return a spy of the real object\n      * Last stubbing is more important - when you stubbed the same method with\n      * the same arguments many times.\n      * <p>\n-     * Although it is possible to verify a stubbed invocation, in majority\n-     * of cases it's not necessary: Let's say you've stubbed foo.bar()\n-     * method. If your code cares what value foo.bar() returns, something\n-     * else will fail if you forget to call foo.bar(). Hence you don't have\n-     * to verify() it (e.g. it's just redundant). Not convinced? See  \n-     * <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>. \n+     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n+     * Let's say you've stubbed foo.bar(). \n+     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n+     * If your code doesn't care what get(0) returns then it should not be stubbed. \n+     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n      * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * </pre>\n      * \n      * <p>\n-     * Although it is possible to verify a stubbed invocation, in majority\n-     * of cases it's not necessary. Let's say you've stubbed foo.bar()\n-     * method. If your code cares what value foo.bar() returns, something\n-     * else will fail if you forget to call foo.bar(). Hence you don't have\n-     * to verify() it (e.g. it's just redundant). Not convinced? See  \n-     * <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n+     * Let's say you've stubbed foo.bar(). \n+     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n+     * If your code doesn't care what get(0) returns then it should not be stubbed. \n+     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n      * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * <p>\n      * Stubbed invocations (if called) are also treated as interactions.\n      * <p>\n-     * Some users who did a lot of classical, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n+     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n      * verifyNoMoreInteractions() is not recommended to use in every test method. \n      * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n      * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n--- a/src/org/mockito/internal/progress/OngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n import org.mockito.stubbing.Answer;\n \n /**\n- * Stubs with return value or exception. E.g:\n+ * Stubs a method call with return value or an exception. E.g:\n  *\n  * <pre>\n  * stub(mock.someMethod()).toReturn(10);\n public interface OngoingStubbing<T> {\n \n     /**\n-     * Stub mock object with given return value. E.g:\n+     * Set a return value for the stubbed method. E.g:\n      * <pre>\n      * stub(mock.someMethod()).toReturn(10);\n      * </pre>\n     OngoingStubbing<T> toReturn(T value);\n \n     /**\n-     * Stub mock object with throwable that will be thrown on method invocation. E.g:\n+     * Set a Throwable to be thrown when the stubbed method is called. E.g:\n      * <pre>\n      * stub(mock.someMethod()).toThrow(new RuntimeException());\n      * </pre>\n     OngoingStubbing<T> toThrow(Throwable throwable);\n \n     /**\n-     * Stub mock object with a custom answer. E.g:\n+     * Set a generic Answer for the stubbed method. E.g:\n      * <pre>\n      * stub(mock.someMethod(10)).toAnswer(new Answer<Integer>() {\n      *     public Integer answer(InvocationOnMock invocation) throws Throwable {", "timestamp": 1217081061, "metainfo": ""}