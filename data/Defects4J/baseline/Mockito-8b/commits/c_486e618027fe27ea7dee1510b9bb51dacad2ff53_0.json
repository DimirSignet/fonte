{"sha": "486e618027fe27ea7dee1510b9bb51dacad2ff53", "log": "Tidied up the code around the timeout verification.  Attempted to make the Timer class easier to comprehend.", "commit": "\n--- a/src/org/mockito/internal/verification/Timer.java\n+++ b/src/org/mockito/internal/verification/Timer.java\n public class Timer {\n \n     private final long durationMillis;\n+    private long startTime = -1;\n \n     public Timer(long durationMillis) {\n         this.durationMillis = durationMillis;\n     }\n \n-    public boolean isUp(long startTime) {\n+    /**\n+     * Informs whether the timer is still counting down.\n+     */\n+    public boolean isCounting() {\n+        assert startTime != -1;\n         return System.currentTimeMillis() - startTime <= durationMillis;\n     }\n+\n+    /**\n+     * Starts the timer count down.\n+     */\n+    public void start() {\n+        startTime = System.currentTimeMillis();\n+    }\n }\n--- a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n     public void verify(VerificationData data) {\n         AssertionError error = null;\n         \n-        long startTime = System.currentTimeMillis();\n-        while (timer.isUp(startTime)) {\n+        timer.start();\n+        while (timer.isCounting()) {\n             try {\n                 delegate.verify(data);\n                 \n--- a/test/org/mockito/internal/verification/TimerTest.java\n+++ b/test/org/mockito/internal/verification/TimerTest.java\n \n     @Test\n     public void should_return_true_if_task_is_in_acceptable_time_bounds() {\n+        //given\n         long duration = 10000L;\n-        long now = System.currentTimeMillis();\n         Timer timer = new Timer(duration);\n \n-        boolean isTimeUp = timer.isUp(now);\n+        //when\n+        timer.start();\n+        boolean stillCounting = timer.isCounting();\n \n-        assertThat(isTimeUp, is(true));\n+        //then\n+        assertThat(stillCounting, is(true));\n     }\n \n     @Test\n     public void should_return_false_if_task_is_outside_the_acceptable_time_bounds() {\n-        long duration = 0L;\n-        Timer timer = new Timer(duration);\n-        long timeFromPast = generate_time_from_past();\n+        //given\n+        Timer timer = new Timer(-1);\n+        timer.start();\n \n-        boolean isTimeUp = timer.isUp(timeFromPast);\n+        //when\n+        boolean stillCounting = timer.isCounting();\n \n-        assertThat(isTimeUp, is(false));\n+        //then\n+        assertThat(timer.isCounting(), is(false));\n     }\n-\n-    long generate_time_from_past() {\n-        return System.currentTimeMillis() - 10000L;\n-    }\n-\n }\n--- a/test/org/mockito/verification/TimeoutTest.java\n+++ b/test/org/mockito/verification/TimeoutTest.java\n  */\n package org.mockito.verification;\n \n-import static org.mockito.Mockito.*;\n-\n import org.junit.Test;\n+import org.mockito.InOrder;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.internal.verification.*;\n import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n \n public class TimeoutTest extends TestBase {\n     \n     public void should_pass_when_verification_passes() {\n         Timeout t = new Timeout(1, 3, mode, timer);\n \n-        when(timer.isUp(anyLong())).thenReturn(true, true, true, false);\n+        when(timer.isCounting()).thenReturn(true);\n         doNothing().when(mode).verify(data);\n \n         t.verify(data);\n+\n+        InOrder inOrder = inOrder(timer);\n+        inOrder.verify(timer).start();\n+        inOrder.verify(timer).isCounting();\n     }\n-    \n+\n     @Test\n     public void should_fail_because_verification_fails() {\n         Timeout t = new Timeout(1, 2, mode, timer);\n \n-        when(timer.isUp(anyLong())).thenReturn(true, true, true, false);\n+        when(timer.isCounting()).thenReturn(true, true, true, false);\n         doThrow(error).\n         doThrow(error).\n         doThrow(error).\n             t.verify(data);\n             fail();\n         } catch (MockitoAssertionError e) {}\n+\n+        verify(timer, times(4)).isCounting();\n     }\n     \n     @Test\n     public void should_pass_even_if_first_verification_fails() {\n         Timeout t = new Timeout(1, 5, mode, timer);\n \n-        when(timer.isUp(anyLong())).thenReturn(true, true, true, false);\n+        when(timer.isCounting()).thenReturn(true, true, true, false);\n         doThrow(error).\n         doThrow(error).\n         doNothing().\n         when(mode).verify(data);\n         \n         t.verify(data);\n+        verify(timer, times(3)).isCounting();\n     }\n \n     @Test\n         Timeout t = new Timeout(10, 50, mode, timer);\n         \n         doThrow(error).when(mode).verify(data);\n-        when(timer.isUp(anyLong())).thenReturn(true, true, true, true, true, false);\n+        when(timer.isCounting()).thenReturn(true, true, true, true, true, false);\n \n         try {\n             t.verify(data);", "timestamp": 1411850417, "metainfo": ""}