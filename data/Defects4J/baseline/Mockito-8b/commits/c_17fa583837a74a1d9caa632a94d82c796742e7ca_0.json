{"sha": "17fa583837a74a1d9caa632a94d82c796742e7ca", "log": "moved class to different package  --HG-- rename : src/org/mockito/internal/MockUtil.java => src/org/mockito/internal/util/MockUtil.java rename : test/org/mockito/MockUtilTest.java => test/org/mockito/internal/util/MockUtilTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40538", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n-import org.mockito.internal.MockUtil;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.util.MockUtil;\n \n /**\n  * Enables mocks creation, verification and stubbing.\n--- a/src/org/mockito/internal/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n \n import org.mockito.internal.invocation.GlobalInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.MockUtil;\n \n public class AllInvocationsFinder implements GlobalInvocationsFinder {\n     \n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.MockUtil;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n     }\n \n     private String qualifiedMethodName() {\n-        //TODO this surely breaks sane dependencies between packages:\n-        String name = MockUtil.getMockName(mock);\n-        return name + \".\" + method.getName();\n+        return MockUtil.getMockName(mock) + \".\" + method.getName();\n     }\n \n     private String getArgumentsLine(List<Matcher> matchers) {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockUtil.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.MockHandler;\n+import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.creation.MockFactory;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+\n+public class MockUtil {\n+    \n+    public static <T> T createMock(Class<T> classToMock, String mockName, MockingProgress progress) {\n+        MockFactory<T> proxyFactory = new MockFactory<T>();\n+        MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder());\n+        MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n+        return proxyFactory.createMock(classToMock, filter);\n+    }\n+    \n+    public static <T> MockHandler<T> getMockHandler(T mock) {\n+        if (mock == null) {\n+            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n+        }\n+        \n+        try {\n+            if (Enhancer.isEnhanced(mock.getClass())) {\n+                return ((MethodInterceptorFilter<MockHandler<T>>) getInterceptor(mock)).getDelegate();\n+            } else {\n+                throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n+            }\n+        } catch (ClassCastException e) {\n+            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n+        Factory factory = (Factory) mock;\n+        return (MethodInterceptorFilter) factory.getCallback(0);\n+    }\n+    \n+    public static void validateMock(Object mock) {\n+        getMockHandler(mock);\n+    }\n+    \n+    public static boolean isMock(Object mock) {\n+        try {\n+            getMockHandler(mock);\n+            return true;\n+        } catch (MockitoException e) {\n+            return false;\n+        }\n+    }\n+\n+    public static String getMockName(Object mock) {\n+        return getMockHandler(mock).getMockName();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.NoOp;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+\n+public class MockUtilTest extends TestBase {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test \n+    public void shouldGetHandler() {\n+        List mock = Mockito.mock(List.class);\n+        assertNotNull(MockUtil.getMockHandler(mock));\n+    }\n+\n+    @Test \n+    public void shouldScreamWhenEnhancedButNotAMockPassed() {\n+        Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);\n+        try {\n+            MockUtil.getMockHandler(o);\n+            fail();\n+        } catch (NotAMockException e) {}\n+    }\n+\n+    @Test (expected=NotAMockException.class)\n+    public void shouldScreamWhenNotAMockPassed() {\n+        MockUtil.getMockHandler(\"\");\n+    }\n+    \n+    @Test (expected=MockitoException.class)\n+    public void shouldScreamWhenNullPassed() {\n+        MockUtil.getMockHandler(null);\n+    }\n+    \n+    @Test\n+    public void shouldValidateMock() {\n+        assertFalse(MockUtil.isMock(\"i mock a mock\"));\n+        assertTrue(MockUtil.isMock(Mockito.mock(List.class)));\n+    }\n+}\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.junit.runner.JUnitCore;\n import org.junit.runner.Result;\n import org.junit.runner.notification.Failure;\n-import org.mockito.MockUtilTest;\n import org.mockito.MockitoTest;\n import org.mockito.TestBase;\n import org.mockito.configuration.DefaultReturnValuesTest;\n import org.mockito.internal.stubbing.ResultTest;\n import org.mockito.internal.stubbing.StubberTest;\n import org.mockito.internal.util.ListUtilTest;\n+import org.mockito.internal.util.MockUtilTest;\n import org.mockito.internal.verification.MissingInvocationInOrderVerifierTest;\n import org.mockito.internal.verification.MissingInvocationVerifierTest;\n import org.mockito.internal.verification.NoMoreInvocationsVerifierTest;", "timestamp": 1207607877, "metainfo": ""}