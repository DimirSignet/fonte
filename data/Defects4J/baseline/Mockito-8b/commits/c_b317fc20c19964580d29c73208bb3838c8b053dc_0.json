{"sha": "b317fc20c19964580d29c73208bb3838c8b053dc", "log": "names refactoring  --HG-- rename : src/org/mockito/internal/progress/OngoingVerifyingMode.java => src/org/mockito/internal/progress/VerificationMode.java rename : test/org/mockito/internal/progress/OngoingVerifyingModeTest.java => test/org/mockito/internal/progress/VerificationModeTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40183", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     \n     static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n-    public static OngoingVerifyingMode atLeastOnce() {\n-        return OngoingVerifyingMode.atLeastOnce();\n+    public static VerificationMode atLeastOnce() {\n+        return VerificationMode.atLeastOnce();\n     }\n     \n     public static <T> T mock(Class<T> classToMock) {\n     }\n     \n     public static <T> T verify(T mock, int wantedNumberOfInvocations) {\n-        return verify(mock, OngoingVerifyingMode.times(wantedNumberOfInvocations));\n+        return verify(mock, VerificationMode.times(wantedNumberOfInvocations));\n     }\n     \n-    public static <T> T verify(T mock, OngoingVerifyingMode mode) {\n+    public static <T> T verify(T mock, VerificationMode mode) {\n         MockUtil.validateMock(mock);\n-        mockingProgress.verifyingStarted(mode);\n+        mockingProgress.verificationStarted(mode);\n         return mock;\n     }\n \n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n import java.util.*;\n \n import org.mockito.exceptions.Exceptions;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n class StrictOrderVerifier implements Strictly {\n     \n     public <T> T verify(T mock) {\n         return this.verify(mock, 1);\n     }\n-    //TODO OngoingVerifyingMode should be interfaced so that 'ongoing' bit is hidden\n+    //TODO VerificationMode should be interfaced so that 'ongoing' bit is hidden\n     //TODO get rid of interface with int\n     public <T> T verify(T mock, int wantedNumberOfInvocations) {\n-        return this.verify(mock, OngoingVerifyingMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n+        return this.verify(mock, VerificationMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n     }\n     \n-    public <T> T verify(T mock, OngoingVerifyingMode ongoingVerifyingMode) {\n+    public <T> T verify(T mock, VerificationMode verificationMode) {\n         if (!mocksToBeVerifiedInOrder.contains(mock)) {\n             Exceptions.strictlyRequiresFamiliarMock();\n         }\n-        return Mockito.verify(mock, OngoingVerifyingMode.inOrder(ongoingVerifyingMode.wantedCount(), mocksToBeVerifiedInOrder));\n+        return Mockito.verify(mock, VerificationMode.inOrder(verificationMode.wantedCount(), mocksToBeVerifiedInOrder));\n     }\n \n     public void addMockToBeVerifiedInOrder(Object mock) {\n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public interface Strictly {\n \n     //TODO get rid of interface with int\n     <T> T verify(T mock, int wantedNumberOfInvocations);\n     \n-    <T> T verify(T mock, OngoingVerifyingMode ongoingVerifyingMode);\n+    <T> T verify(T mock, VerificationMode verificationMode);\n     \n }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.stubbing.EmptyReturnValues;\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n             return null;\n         }\n         \n-        OngoingVerifyingMode ongoingVerifyingMode = mockingProgress.pullVerifyingMode();\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n         mockingProgress.validateState();\n         \n         Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n         \n-        if (ongoingVerifyingMode != null) {\n-            verifyingRecorder.verify(invocationMatcher, ongoingVerifyingMode);\n+        if (verificationMode != null) {\n+            verifyingRecorder.verify(invocationMatcher, verificationMode);\n             return EmptyReturnValues.emptyValueFor(method.getReturnType());\n         } \n         \n--- a/src/org/mockito/internal/invocation/InvocationsCalculator.java\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculator.java\n import java.util.List;\n \n import org.mockito.exceptions.parents.HasStackTrace;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class InvocationsCalculator {\n \n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n \n-    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, VerificationMode mode) {\n         int counter = 0;\n         for (Invocation registered : invocations) {\n             if (wanted.matches(registered)) {\n--- a/src/org/mockito/internal/invocation/InvocationsMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsMarker.java\n \n import java.util.List;\n \n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n //TODO name\n public class InvocationsMarker {\n \n     public void markInvocationsAsVerified(List<Invocation> invocations,\n-            InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+            InvocationMatcher wanted, VerificationMode mode) {\n         if (mode.wantedCountIsZero()) {\n             return;\n         }\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n-\n-\n-//TODO verificationMode instead verifying\n @SuppressWarnings(\"unchecked\")\n public interface MockingProgress {\n \n \n     OngoingStubbing pullStubable();\n \n-    void verifyingStarted(OngoingVerifyingMode verifyingMode);\n+    void verificationStarted(VerificationMode verificationMode);\n \n-    OngoingVerifyingMode pullVerifyingMode();\n+    VerificationMode pullVerificationMode();\n \n     void stubbingStarted();\n \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n public class MockingProgressImpl implements MockingProgress {\n     \n     private OngoingStubbing ongoingStubbing;\n-    private OngoingVerifyingMode ongoingVerifyingMode;\n+    private VerificationMode verificationMode;\n     private int invocationSequenceNumber = 1;\n     private boolean stubbingInProgress = false;\n \n         return temp;\n     }\n     \n-    public void verifyingStarted(OngoingVerifyingMode verify) {\n+    public void verificationStarted(VerificationMode verify) {\n         validateState();\n-        ongoingVerifyingMode = verify;\n+        verificationMode = verify;\n     }\n \n-    public OngoingVerifyingMode pullVerifyingMode() {\n-        OngoingVerifyingMode temp = ongoingVerifyingMode;\n-        ongoingVerifyingMode = null;\n+    public VerificationMode pullVerificationMode() {\n+        VerificationMode temp = verificationMode;\n+        verificationMode = null;\n         return temp;\n     }\n \n     }\n \n     public void validateState() {\n-        if (ongoingVerifyingMode != null) {\n-            ongoingVerifyingMode = null;\n+        if (verificationMode != null) {\n+            verificationMode = null;\n             Exceptions.unfinishedVerificationException();\n         }\n         \n     \n     public String toString() {\n         return  \"ongoingStubbing: \" + ongoingStubbing + \n-        \", ongoingVerifyingMode: \" + ongoingVerifyingMode +\n+        \", verificationMode: \" + verificationMode +\n         \", invocationSequenceNumber: \" + invocationSequenceNumber +\n         \", stubbingInProgress: \" + stubbingInProgress;\n     }\n \n     public void reset() {\n         stubbingInProgress = false;\n-        ongoingVerifyingMode = null;\n+        verificationMode = null;\n         invocationSequenceNumber = 1;\n     }\n }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n         return threadSafely().pullStubable();\n     }\n     \n-    public void verifyingStarted(OngoingVerifyingMode verify) {\n-        threadSafely().verifyingStarted(verify);\n+    public void verificationStarted(VerificationMode verify) {\n+        threadSafely().verificationStarted(verify);\n     }\n \n-    public OngoingVerifyingMode pullVerifyingMode() {\n-        return threadSafely().pullVerifyingMode();\n+    public VerificationMode pullVerificationMode() {\n+        return threadSafely().pullVerificationMode();\n     }\n \n     public int nextSequenceNumber() {\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/VerificationMode.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.mockito.exceptions.parents.MockitoException;\n+\n+public class VerificationMode {\n+\n+    private final Integer wantedInvocationCount;\n+    private final List<Object> mocksToBeVerifiedInSequence;\n+\n+    private VerificationMode(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n+        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+        this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n+    }\n+    \n+    public static VerificationMode atLeastOnce() {\n+        return new VerificationMode(null, Collections.emptyList());\n+    }\n+\n+    public static VerificationMode times(int wantedNumberOfInvocations) {\n+        return new VerificationMode(wantedNumberOfInvocations, Collections.emptyList());\n+    }\n+    \n+    /**\n+     * Don't use VerificationMode class directly. \n+     * <p>\n+     * Use Mockito.atLeastOnce() and Mockito.times()\n+     */\n+    public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n+    \n+    public static VerificationMode inOrder(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n+        return new VerificationMode(wantedNumberOfInvocations, mocksToBeVerifiedInOrder);\n+    }\n+\n+    public boolean atLeastOnceMode() {\n+        return wantedInvocationCount == null;\n+    }\n+\n+    public Integer wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+\n+    public List<Object> getAllMocksToBeVerifiedInSequence() {\n+        return mocksToBeVerifiedInSequence;\n+    }\n+\n+//TODO name    \n+    public boolean orderOfInvocationsMatters() {\n+        return !mocksToBeVerifiedInSequence.isEmpty();\n+    }\n+\n+    public boolean wantedCountIsZero() {\n+        return wantedInvocationCount != null && wantedInvocationCount == 0;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedInSequence;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.invocation.InvocationsPrinter;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class MissingInvocationVerifier implements Verifier {\n \n-    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n         int actualCount = calculator.countActual(wanted);\n         Integer wantedCount = mode.wantedCount();\n         boolean atLeastOnce = mode.atLeastOnceMode();\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n \n-    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n         if (mode.atLeastOnceMode()) {\n             return;\n         }\n--- a/src/org/mockito/internal/verification/Verifier.java\n+++ b/src/org/mockito/internal/verification/Verifier.java\n \n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n \n public interface Verifier {\n \n-    void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode);\n+    void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode);\n     \n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class VerifyingRecorder {\n \n         return registeredInvocations;\n     }\n \n-    public void verify(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+    public void verify(InvocationMatcher wanted, VerificationMode mode) {\n         List<Invocation> invocations = getInvocationsForEvaluation(mode);\n         InvocationsCalculator calculator = new InvocationsCalculator(invocations);\n         \n         marker.markInvocationsAsVerified(invocations, wanted, mode);\n     }\n     \n-    private List<Invocation> getInvocationsForEvaluation(OngoingVerifyingMode mode) {\n+    private List<Invocation> getInvocationsForEvaluation(VerificationMode mode) {\n         if (mode.orderOfInvocationsMatters()) {\n             return chunker.getFirstUnverifiedInvocationChunk(mode.getAllMocksToBeVerifiedInSequence());\n         } else {\n     \n     public void verifyNoMoreInteractions() {\n         //TODO refactor to have single verify method\n-        //TODO OngoingVerifyingMode.times(0) should be explicit\n-        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n+        //TODO VerificationMode.times(0) should be explicit\n+        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(VerificationMode.times(0)));\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n     }\n     \n     public void verifyZeroInteractions() {\n-        //TODO OngoingVerifyingMode.times(0) should be explicit\n-        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n+        //TODO VerificationMode.times(0) should be explicit\n+        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(VerificationMode.times(0)));\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         MockingProgressImpl state = new MockingProgressImpl();\n-        state.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+        state.verificationStarted(VerificationMode.atLeastOnce());\n         MockControl control = new MockControl(state, new ExceptionThrowingBinder());\n         \n         try {\n             fail();\n         } catch (InvalidUseOfMatchersException e) {}\n         \n-        assertNull(state.pullVerifyingMode());\n+        assertNull(state.pullVerificationMode());\n     }\n     \n     private class ExceptionThrowingBinder extends MatchersBinder {\n--- a/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n \n public class InvocationsCalculatorTest extends RequiresValidState {\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n-        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(0));\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n         HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n-        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(1));\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n         HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n-        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(2));\n+        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n-        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(100));\n+        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n package org.mockito.internal.invocation;\n \n import static org.junit.Assert.assertEquals;\n-import static org.mockito.internal.progress.OngoingVerifyingMode.atLeastOnce;\n-import static org.mockito.internal.progress.OngoingVerifyingMode.inOrder;\n-import static org.mockito.internal.progress.OngoingVerifyingMode.times;\n+import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationMode.inOrder;\n+import static org.mockito.internal.progress.VerificationMode.times;\n \n import java.util.Arrays;\n import java.util.List;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class InvocationsMarkerTest extends RequiresValidState {\n \n     \n     @Test\n     public void shouldMarkAsVerifedInOrderAllInvocationsFromChunk() throws Exception {\n-        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        VerificationMode mode = inOrder(null, Arrays.asList(new Object()));\n         Invocation doesntMatter = null;\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n         \n     \n     @Test\n     public void shouldMarkAsVerifedAllInvocationsFromThirdChunk() throws Exception {\n-        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        VerificationMode mode = inOrder(null, Arrays.asList(new Object()));\n         \n         Invocation doesntMatter = null;\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n--- a/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.MockingProgressImpl;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class MockingProgressImplTest extends RequiresValidState {\n \n     }\n     \n     @Test\n-    public void shouldSwitchVerifyingMode() throws Exception {\n-        assertNull(mockingProgress.pullVerifyingMode());\n+    public void shouldStartVerificationAndPullVerificationMode() throws Exception {\n+        assertNull(mockingProgress.pullVerificationMode());\n         \n-        OngoingVerifyingMode mode = OngoingVerifyingMode.times(19);\n+        VerificationMode mode = VerificationMode.times(19);\n         \n-        mockingProgress.verifyingStarted(mode);\n+        mockingProgress.verificationStarted(mode);\n         \n-        assertSame(mode, mockingProgress.pullVerifyingMode());\n+        assertSame(mode, mockingProgress.pullVerificationMode());\n+        \n+        assertNull(mockingProgress.pullVerificationMode());\n     }\n     \n     @Test\n     public void shouldCheckIfVerificationWasFinished() throws Exception {\n-        mockingProgress.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+        mockingProgress.verificationStarted(VerificationMode.atLeastOnce());\n         try {\n-            mockingProgress.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+            mockingProgress.verificationStarted(VerificationMode.atLeastOnce());\n             fail();\n         } catch (MockitoException e) {}\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/VerificationModeTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.progress.VerificationMode;\n+\n+public class VerificationModeTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n+        VerificationMode mode = VerificationMode.atLeastOnce();\n+        assertTrue(mode.atLeastOnceMode());\n+        \n+        mode = VerificationMode.times(50);\n+        assertFalse(mode.atLeastOnceMode());\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            VerificationMode.times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n     }\n \n     @Test\n-    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n-        OngoingVerifyingMode inOrder = OngoingVerifyingMode.atLeastOnce();\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenAtLeastOnceVerification() throws Exception {\n+        VerificationMode inOrder = VerificationMode.atLeastOnce();\n         \n         verifier.verify(null, null, inOrder);\n     }\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n+import org.mockito.internal.progress.VerificationMode;\n \n public class VerifyingRecorderTest extends RequiresValidState {\n     \n     public void shouldMarkInvocationsAsVerified() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        OngoingVerifyingMode mode = OngoingVerifyingMode.atLeastOnce();\n+        VerificationMode mode = VerificationMode.atLeastOnce();\n         recorder.verify(differentMethod, mode);\n         \n         assertThat(marker.invocations, collectionHasExactlyInOrder(simpleMethod));\n     public void shouldVerify() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        OngoingVerifyingMode mode = OngoingVerifyingMode.atLeastOnce();\n+        VerificationMode mode = VerificationMode.atLeastOnce();\n         recorder.verify(differentMethod, mode);\n         \n         assertEquals(verifier.mode, mode);\n     public void shouldVerifyInOrder() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        OngoingVerifyingMode mode = OngoingVerifyingMode.inOrder(10, Arrays.<Object>asList(\"mock\"));\n+        VerificationMode mode = VerificationMode.inOrder(10, Arrays.<Object>asList(\"mock\"));\n         recorder.verify(differentMethod, mode);\n         \n         assertEquals(verifier.mode, mode);\n     class InvocationsMarkerStub extends InvocationsMarker {\n         private List<Invocation> invocations;\n         private InvocationMatcher wanted;\n-        private OngoingVerifyingMode mode;\n-        @Override public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        private VerificationMode mode;\n+        @Override public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n             this.invocations = invocations;\n             this.wanted = wanted;\n             this.mode = mode;\n     class VerifierStub implements Verifier {\n         private InvocationsCalculator calculator;\n         private InvocationMatcher wanted;\n-        private OngoingVerifyingMode mode;\n-        public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        private VerificationMode mode;\n+        public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n             this.calculator = calculator;\n             this.wanted = wanted;\n             this.mode = mode;\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.OngoingVerifyingModeTest;\n+import org.mockito.internal.progress.VerificationModeTest;\n import org.mockito.internal.stubbing.EmptyReturnValuesTest;\n import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n import org.mockitousage.binding.BridgeMethodPuzzleTest;\n                     NumberOfInvocationsVerifierTest.class, \n                     MockingProgressImplTest.class, \n                     EmptyReturnValuesTest.class, \n-                    OngoingVerifyingModeTest.class, \n+                    VerificationModeTest.class, \n                     InvocationTest.class, \n                     MockUtilTest.class, \n                     MockitoAssertionErrorTest.class, ", "timestamp": 1197640523, "metainfo": ""}