{"sha": "52a27f7bfeae32bd3ed4f58b999e76011e6af8df", "log": "Added javadoc for reset() Made reset() accepting multiple mocks  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401327", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n-    private static MockitoCore MOCKITO_CORE = new MockitoCore();\n+    private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n     \n     /**\n      * Default ReturnValues used by the framework.\n     }\n \n     /**\n-\t * <pre>\n-\t *   //Instead of:\n-\t *   stub(mock.count()).toReturn(10);\n-\t * \n-\t *   //Please do:\n-\t *   when(mock.count()).thenReturn(10);\n-\t * </pre> \n-\t * \n-\t * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n-\t * <p>\n-\t * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n-\t * <pre>\n-\t *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n-\t *   stub(          <i>replace with:</i>  when(\n-\t *   .toReturn(     <i>replace with:</i>  .thenReturn(\n-\t *   .toThrow(      <i>replace with:</i>  .thenThrow(\n-\t *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n-\t * </pre>\n-\t * If you're an existing user then sorry for making your code littered with deprecation warnings. \n-\t * This change was required to make Mockito better.\n-\t * \n-\t * @param methodCall\n-\t *            method call\n-\t * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n-\t */\n-\t@Deprecated\n-\tpublic static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n-\t\treturn MOCKITO_CORE.stub(methodCall);\n-\t}\n-    \n-    /**\n-\t * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n-\t * <p>\n-\t * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n-\t * <p>\n-\t * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n-\t * <p>\n-\t * Examples:\n-\t * \n-\t * <pre>\n-\t * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n-\t *\n-\t * //you can use flexible argument matchers, e.g:\n-\t * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n-\t *\n-\t * //setting exception to be thrown:\n-\t * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n-\t *\n-\t * //you can set different behavior for consecutive method calls.\n-\t * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n-\t * when(mock.someMethod(\"some arg\"))\n-\t *  .thenThrow(new RuntimeException())\n-\t *  .thenReturn(\"foo\");\n-\t *  \n-\t * //Alternative, shorter version for consecutive stubbing:\n-\t * when(mock.someMethod(\"some arg\"))\n-\t *  .thenReturn(\"one\", \"two\");\n-\t * //is the same as:\n-\t * when(mock.someMethod(\"some arg\"))\n-\t *  .thenReturn(\"one\")\n-\t *  .thenReturn(\"two\");\n-\t *\n-\t * //shorter version for consecutive method calls throwing exceptions:\n-\t * when(mock.someMethod(\"some arg\"))\n-\t *  .thenThrow(new RuntimeException(), new NullPointerException();\n-\t *   \n-\t * </pre>\n-\t * \n-\t * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n-\t * <p>\n-\t * Stubbing can be overridden: for example common stubbing can go to fixture\n-\t * setup but the test methods can override it.\n-\t * <p>\n-\t * Once stubbed, the method will always return stubbed value regardless\n-\t * of how many times it is called.\n-\t * <p>\n-\t * Last stubbing is more important - when you stubbed the same method with\n-\t * the same arguments many times.\n-\t * <p>\n-\t * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n-\t * Let's say you've stubbed foo.bar(). \n-\t * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n-\t * If your code doesn't care what get(0) returns then it should not be stubbed. \n-\t * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n-\t * \n-\t * <p>\n-\t * See examples in javadoc for {@link Mockito} class\n-\t * @param methodCall method to be stubbed\n-\t */\n-\tpublic static <T> NewOngoingStubbing<T> when(T methodCall) {\n-\t\treturn MOCKITO_CORE.when(methodCall);\n-\t}\n-\n-    /**\n-     * Verifies certain behavior <b>happened once</b> \n-     * <p>\n-     * Alias to <code>verify(mock, times(1))</code> E.g:\n-     * <pre>\n-     *   verify(mock).someMethod(\"some arg\");\n-     * </pre>\n-     * Above is equivalent to:\n-     * <pre>\n-     *   verify(mock, times(1)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n+     * <pre>\n+     *   //Instead of:\n+     *   stub(mock.count()).toReturn(10);\n+     * \n+     *   //Please do:\n+     *   when(mock.count()).thenReturn(10);\n+     * </pre> \n+     * \n+     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n+     * <p>\n+     * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n+     * <pre>\n+     *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n+     *   stub(          <i>replace with:</i>  when(\n+     *   .toReturn(     <i>replace with:</i>  .thenReturn(\n+     *   .toThrow(      <i>replace with:</i>  .thenThrow(\n+     *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n+     * </pre>\n+     * If you're an existing user then sorry for making your code littered with deprecation warnings. \n+     * This change was required to make Mockito better.\n+     * \n+     * @param methodCall\n+     *            method call\n+     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n+     */\n+    @Deprecated\n+    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+        return MOCKITO_CORE.stub(methodCall);\n+    }\n+    \n+    /**\n+     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n+     * <p>\n+     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n+     * <p>\n+     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n+     * <p>\n+     * Examples:\n+     * \n+     * <pre>\n+     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n+     *\n+     * //you can use flexible argument matchers, e.g:\n+     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n+     *\n+     * //setting exception to be thrown:\n+     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n+     *\n+     * //you can set different behavior for consecutive method calls.\n+     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenThrow(new RuntimeException())\n+     *  .thenReturn(\"foo\");\n+     *  \n+     * //Alternative, shorter version for consecutive stubbing:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenReturn(\"one\", \"two\");\n+     * //is the same as:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenReturn(\"one\")\n+     *  .thenReturn(\"two\");\n+     *\n+     * //shorter version for consecutive method calls throwing exceptions:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenThrow(new RuntimeException(), new NullPointerException();\n+     *   \n+     * </pre>\n+     * \n+     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n+     * <p>\n+     * Stubbing can be overridden: for example common stubbing can go to fixture\n+     * setup but the test methods can override it.\n+     * <p>\n+     * Once stubbed, the method will always return stubbed value regardless\n+     * of how many times it is called.\n+     * <p>\n+     * Last stubbing is more important - when you stubbed the same method with\n+     * the same arguments many times.\n      * <p>\n      * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n      * Let's say you've stubbed foo.bar(). \n      * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n+     * @param methodCall method to be stubbed\n+     */\n+    public static <T> NewOngoingStubbing<T> when(T methodCall) {\n+        return MOCKITO_CORE.when(methodCall);\n+    }\n+\n+    /**\n+     * Verifies certain behavior <b>happened once</b> \n+     * <p>\n+     * Alias to <code>verify(mock, times(1))</code> E.g:\n+     * <pre>\n+     *   verify(mock).someMethod(\"some arg\");\n+     * </pre>\n+     * Above is equivalent to:\n+     * <pre>\n+     *   verify(mock, times(1)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * <p>\n+     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n+     * Let's say you've stubbed foo.bar(). \n+     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n+     * If your code doesn't care what get(0) returns then it should not be stubbed. \n+     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+     * \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n      * \n      * @param mock to be verified\n      * @return mock object itself\n     }\n     \n     /**\n-\t * TODO javadoc\n-\t * \n-\t * @param <T>\n-\t * @param mock\n-\t */\n-\tpublic static <T> void reset(T mock) {\n-\t\tMOCKITO_CORE.reset(mock);\n-\t}\n+     * Smart Mockito users hardly use this method because they know it could be a sign of poor tests.\n+     * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n+     * <p>\n+     * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n+     * First potential smell is reset() in the middle of the test method. This probably means you're testing too much.\n+     * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \n+     * There are several threads about it on mockito mailing list.\n+     * <p>\n+     * The only reason we added reset() method is to\n+     * make it possible to work with container-injected mocks.\n+     * See issue 55 (<a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">here</a>)\n+     * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n+     * \n+     * @param <T>\n+     * @param mocks\n+     */\n+    public static <T> void reset(T ... mocks) {\n+        MOCKITO_CORE.reset(mocks);\n+    }\n+ \n+    /**\n+     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n+     * <pre>\n+     *   verify(mock, times(5)).someMethod(\"was called five times\");\n+     *   \n+     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n+     *   \n+     *   //you can use flexible argument matchers, e.g:\n+     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n+     * </pre>\n+     * \n+     * <b>times(1) is the default</b> and can be omitted\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mock to be verified\n+     * @param mode times(x), atLeastOnce() or never()\n+     * \n+     * @return mock object itself\n+     */\n+    public static <T> T verify(T mock, VerificationMode mode) {\n+        return MOCKITO_CORE.verify(mock, mode);\n+    }\n \n- \n-    /**\n-\t * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n-\t * <pre>\n-\t *   verify(mock, times(5)).someMethod(\"was called five times\");\n-\t *   \n-\t *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n-\t *   \n-\t *   //you can use flexible argument matchers, e.g:\n-\t *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n-\t * </pre>\n-\t * \n-\t * <b>times(1) is the default</b> and can be omitted\n-\t * <p>\n-\t * See examples in javadoc for {@link Mockito} class\n-\t * \n-\t * @param mock to be verified\n-\t * @param mode times(x), atLeastOnce() or never()\n-\t * \n-\t * @return mock object itself\n-\t */\n-\tpublic static <T> T verify(T mock, VerificationMode mode) {\n-\t\treturn MOCKITO_CORE.verify(mock, mode);\n-\t}\n-\n-    /**\n-\t * Checks if any of given mocks has any unverified interaction.\n-\t * <p>\n-\t * You can use this method after you verified your mocks - to make sure that nothing\n-\t * else was invoked on your mocks.\n-\t * <p>\n-\t * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n-\t * <p>\n-\t * Stubbed invocations (if called) are also treated as interactions.\n-\t * <p>\n-\t * A word of <b>warning</b>: \n-\t * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n-\t * verifyNoMoreInteractions() is not recommended to use in every test method. \n-\t * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n-\t * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n-\t * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n-\t * <p>\n-\t * This method will also detect unverified invocations that occurred before the test method,\n-\t * for example: in setUp(), &#064;Before method or in constructor.\n-\t * Consider writing nice code that makes interactions only in test methods.\n-\t * \n-\t * <p>\n-\t * Example:\n-\t * \n-\t * <pre>\n-\t * //interactions\n-\t * mock.doSomething();\n-\t * mock.doSomethingUnexpected();\n-\t * \n-\t * //verification\n-\t * verify(mock).doSomething();\n-\t * \n-\t * //following will fail because 'doSomethingUnexpected()' is unexpected\n-\t * verifyNoMoreInteractions(mock);\n-\t * \n-\t * </pre>\n-\t * \n-\t * See examples in javadoc for {@link Mockito} class\n-\t * \n-\t * @param mocks to be verified\n-\t */\n-\tpublic static void verifyNoMoreInteractions(Object... mocks) {\n-\t\tMOCKITO_CORE.verifyNoMoreInteractions(mocks);\n-\t}\n+    /**\n+     * Checks if any of given mocks has any unverified interaction.\n+     * <p>\n+     * You can use this method after you verified your mocks - to make sure that nothing\n+     * else was invoked on your mocks.\n+     * <p>\n+     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n+     * <p>\n+     * Stubbed invocations (if called) are also treated as interactions.\n+     * <p>\n+     * A word of <b>warning</b>: \n+     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n+     * verifyNoMoreInteractions() is not recommended to use in every test method. \n+     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n+     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n+     * <p>\n+     * This method will also detect unverified invocations that occurred before the test method,\n+     * for example: in setUp(), &#064;Before method or in constructor.\n+     * Consider writing nice code that makes interactions only in test methods.\n+     * \n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     * //interactions\n+     * mock.doSomething();\n+     * mock.doSomethingUnexpected();\n+     * \n+     * //verification\n+     * verify(mock).doSomething();\n+     * \n+     * //following will fail because 'doSomethingUnexpected()' is unexpected\n+     * verifyNoMoreInteractions(mock);\n+     * \n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mocks to be verified\n+     */\n+    public static void verifyNoMoreInteractions(Object... mocks) {\n+        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n+    }\n \n     /**\n      * Verifies that no interactions happened on given mocks.\n     }\n \n     public static void assertMocksNotEmpty(Object[] mocks) {\n-\t\tMOCKITO_CORE.assertMocksNotEmpty(mocks);\n-\t}\n+        MOCKITO_CORE.assertMocksNotEmpty(mocks);\n+    }\n \n     /**\n-\t * <pre>\n-\t *   //Instead of:\n-\t *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n-\t * \n-\t *   //Please do:\n-\t *   doThrow(e).when(mock).someVoidMethod();\n-\t * </pre> \n-\t * \n-\t * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n-\t * <p>\n-\t * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n-\t * \n-\t * <pre>\n-\t * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n-\t * \n-\t * //you can stub with different behavior for consecutive calls.\n-\t * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n-\t * stubVoid(mock)\n-\t *   .toThrow(new RuntimeException())\n-\t *   .toReturn()\n-\t *   .on().someMethod();\n-\t * </pre>\n-\t * \n-\t * See examples in javadoc for {@link Mockito} class\n-\t * \n-\t * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n-\t * \n-\t * @param mock\n-\t *            to stub\n-\t * @return stubbable object that allows stubbing with throwable\n-\t */\n-\tpublic static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-\t\treturn MOCKITO_CORE.stubVoid(mock);\n-\t}\n+     * <pre>\n+     *   //Instead of:\n+     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n+     * \n+     *   //Please do:\n+     *   doThrow(e).when(mock).someVoidMethod();\n+     * </pre> \n+     * \n+     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n+     * <p>\n+     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n+     * \n+     * <pre>\n+     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n+     * \n+     * //you can stub with different behavior for consecutive calls.\n+     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n+     * stubVoid(mock)\n+     *   .toThrow(new RuntimeException())\n+     *   .toReturn()\n+     *   .on().someMethod();\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n+     * \n+     * @param mock\n+     *            to stub\n+     * @return stubbable object that allows stubbing with throwable\n+     */\n+    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n+        return MOCKITO_CORE.stubVoid(mock);\n+    }\n     \n     /**\n      * Use doThrow() when you want to stub the void method with an exception.\n     }\n     \n     /**\n-\t * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n-\t * <p>\n-\t * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n-\t * <p>\n-\t * Example:\n-\t * \n-\t * <pre>\n-\t *  doAnswer(new Answer() {\n-\t *      public Object answer(InvocationOnMock invocation) {\n-\t *          Object[] args = invocation.getArguments();\n-\t *          Mock mock = invocation.getMock();\n-\t *          return null;\n-\t *      }})\n-\t *  .when(mock).someMethod();\n-\t * </pre>\n-\t * \n-\t * @param answer to answer when the stubbed method is called\n-\t * @return stubber - to select a method for stubbing\n-\t */\n-\tpublic static Stubber doAnswer(Answer answer) {\n-\t\treturn MOCKITO_CORE.doAnswer(answer);\n-\t}  \n+     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n+     * <p>\n+     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     *  doAnswer(new Answer() {\n+     *      public Object answer(InvocationOnMock invocation) {\n+     *          Object[] args = invocation.getArguments();\n+     *          Mock mock = invocation.getMock();\n+     *          return null;\n+     *      }})\n+     *  .when(mock).someMethod();\n+     * </pre>\n+     * \n+     * @param answer to answer when the stubbed method is called\n+     * @return stubber - to select a method for stubbing\n+     */\n+    public static Stubber doAnswer(Answer answer) {\n+        return MOCKITO_CORE.doAnswer(answer);\n+    }  \n     \n     /**\n      * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b> \n     }\n  \n     /**\n-\t * Creates InOrder object that allows verifying mocks in order.\n-\t * \n-\t * <pre>\n-\t *   InOrder inOrder = inOrder(firstMock, secondMock);\n-\t *   \n-\t *   inOrder.verify(firstMock).add(\"was called first\");\n-\t *   inOrder.verify(secondMock).add(\"was called second\");\n-\t * </pre>\n-\t * \n-\t * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n-\t * but only those that you are interested in testing in order.\n-\t * <p>\n-\t * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n-\t *\n-\t * See examples in javadoc for {@link Mockito} class\n-\t * \n-\t * @param mocks to be verified in order\n-\t * \n-\t * @return InOrder object to be used to verify in order\n-\t */\n-\tpublic static InOrder inOrder(Object... mocks) {\n-\t\treturn MOCKITO_CORE.inOrder(mocks);\n-\t}\n+     * Creates InOrder object that allows verifying mocks in order.\n+     * \n+     * <pre>\n+     *   InOrder inOrder = inOrder(firstMock, secondMock);\n+     *   \n+     *   inOrder.verify(firstMock).add(\"was called first\");\n+     *   inOrder.verify(secondMock).add(\"was called second\");\n+     * </pre>\n+     * \n+     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n+     * but only those that you are interested in testing in order.\n+     * <p>\n+     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n+     *\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mocks to be verified in order\n+     * \n+     * @return InOrder object to be used to verify in order\n+     */\n+    public static InOrder inOrder(Object... mocks) {\n+        return MOCKITO_CORE.inOrder(mocks);\n+    }\n   \n     /**\n      * Allows verifying exact number of invocations. E.g:\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoCore {\n \n-\tReporter REPORTER = new Reporter();\n-\tpublic static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n-\t\n-\tpublic <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n-\t    MOCKING_PROGRESS.validateState();\n-\t    MOCKING_PROGRESS.resetOngoingStubbing();\n-\t    return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n-\t}\n-\t\n-\tpublic OngoingStubbing stub() {\n-\t    OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n-\t    if (stubbing == null) {\n-\t        MOCKING_PROGRESS.reset();\n-\t        REPORTER.missingMethodInvocation();\n-\t    }\n-\t    return stubbing;\n-\t}\n+    private static final Reporter REPORTER = new Reporter();\n+    public static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n+    \n+    public <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n+        MOCKING_PROGRESS.validateState();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n+        return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n+    }\n+    \n+    public OngoingStubbing stub() {\n+        OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n+        if (stubbing == null) {\n+            MOCKING_PROGRESS.reset();\n+            REPORTER.missingMethodInvocation();\n+        }\n+        return stubbing;\n+    }\n \n-\t@Deprecated\n-\tpublic <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n-\t    MOCKING_PROGRESS.stubbingStarted();\n-\t    return (DeprecatedOngoingStubbing) stub();\n-\t}\n+    @Deprecated\n+    public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return (DeprecatedOngoingStubbing) stub();\n+    }\n \n-\tpublic <T> NewOngoingStubbing<T> when(T methodCall) {\n-\t    MOCKING_PROGRESS.stubbingStarted();\n-\t    return (NewOngoingStubbing) stub();\n-\t}\n-\t\n-\t\n-\tpublic <T> T verify(T mock, VerificationMode mode) {\n-\t    if (mock == null) {\n-\t        REPORTER.nullPassedToVerify();\n-\t    } else if (!MockUtil.isMock(mock)) {\n-\t        REPORTER.notAMockPassedToVerify();\n-\t    }\n-\t    MOCKING_PROGRESS.verificationStarted(mode);\n-\t    return mock;\n-\t}\n-\t\n-\tpublic <T> void reset(T mock) {\n-\t    //TODO Perhaps we should validate the state instead of resetting?\n-\t    MOCKING_PROGRESS.reset();\n-\t    MOCKING_PROGRESS.resetOngoingStubbing();\n-\t    //TODO Perhaps we should maintain previous ReturnValues?\n-\t    MockUtil.resetMock(mock, MOCKING_PROGRESS, Mockito.RETURNS_DEFAULTS);\n-\t}\n-\t\n-\tpublic void verifyNoMoreInteractions(Object... mocks) {\n-\t    assertMocksNotEmpty(mocks);\n-\t    MOCKING_PROGRESS.validateState();\n-\t    for (Object mock : mocks) {\n-\t        try {\n-\t            if (mock == null) {\n-\t                REPORTER.nullPassedToVerifyNoMoreInteractions();\n-\t            }\n-\t            MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n-\t        } catch (NotAMockException e) {\n-\t            REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n-\t        }\n-\t    }\n-\t}\n-\t\n-\tpublic void assertMocksNotEmpty(Object[] mocks) {\n-\t    if (mocks == null || mocks.length == 0) {\n-\t        REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n-\t    }\n-\t}\n-\t\n-\tpublic InOrder inOrder(Object... mocks) {\n-\t    if (mocks == null || mocks.length == 0) {\n-\t        REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n-\t    }\n-\t    for (Object mock : mocks) {\n-\t        if (mock == null) {\n-\t            REPORTER.nullPassedWhenCreatingInOrder();\n-\t        } else if (!MockUtil.isMock(mock)) {\n-\t            REPORTER.notAMockPassedWhenCreatingInOrder();\n-\t        }\n-\t    }\n-\t    InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n-\t    return inOrder;\n-\t}\n-\t\n-\tpublic Stubber doAnswer(Answer answer) {\n-\t    MOCKING_PROGRESS.stubbingStarted();\n-\t    MOCKING_PROGRESS.resetOngoingStubbing();\n-\t    return new StubberImpl().doAnswer(answer);\n-\t}\n-\t\n-\tpublic <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-\t    MockHandler<T> handler = MockUtil.getMockHandler(mock);\n-\t    MOCKING_PROGRESS.stubbingStarted();\n-\t    return handler.voidMethodStubbable(mock);\n-\t}\n+    public <T> NewOngoingStubbing<T> when(T methodCall) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return (NewOngoingStubbing) stub();\n+    }\n+    \n+    \n+    public <T> T verify(T mock, VerificationMode mode) {\n+        if (mock == null) {\n+            REPORTER.nullPassedToVerify();\n+        } else if (!MockUtil.isMock(mock)) {\n+            REPORTER.notAMockPassedToVerify();\n+        }\n+        MOCKING_PROGRESS.verificationStarted(mode);\n+        return mock;\n+    }\n+    \n+    public <T> void reset(T ... mocks) {\n+        //TODO Perhaps we should validate the state instead of resetting?\n+        MOCKING_PROGRESS.reset();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n+        //TODO Perhaps we should maintain previous ReturnValues?\n+        \n+        for (T m : mocks) {\n+            MockUtil.resetMock(m, MOCKING_PROGRESS, Mockito.RETURNS_DEFAULTS);\n+        }\n+    }\n+    \n+    public void verifyNoMoreInteractions(Object... mocks) {\n+        assertMocksNotEmpty(mocks);\n+        MOCKING_PROGRESS.validateState();\n+        for (Object mock : mocks) {\n+            try {\n+                if (mock == null) {\n+                    REPORTER.nullPassedToVerifyNoMoreInteractions();\n+                }\n+                MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n+            } catch (NotAMockException e) {\n+                REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n+            }\n+        }\n+    }\n+    \n+    public void assertMocksNotEmpty(Object[] mocks) {\n+        if (mocks == null || mocks.length == 0) {\n+            REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n+        }\n+    }\n+    \n+    public InOrder inOrder(Object... mocks) {\n+        if (mocks == null || mocks.length == 0) {\n+            REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n+        }\n+        for (Object mock : mocks) {\n+            if (mock == null) {\n+                REPORTER.nullPassedWhenCreatingInOrder();\n+            } else if (!MockUtil.isMock(mock)) {\n+                REPORTER.notAMockPassedWhenCreatingInOrder();\n+            }\n+        }\n+        InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n+        return inOrder;\n+    }\n+    \n+    public Stubber doAnswer(Answer answer) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n+        return new StubberImpl().doAnswer(answer);\n+    }\n+    \n+    public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n+        MockHandler<T> handler = MockUtil.getMockHandler(mock);\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return handler.voidMethodStubbable(mock);\n+    }\n \n }\n--- a/src/org/mockito/internal/returnvalues/MockReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/MockReturnValues.java\n import org.mockito.invocation.InvocationOnMock;\n \n public class MockReturnValues implements ReturnValues {\n-\t\n+    \n     private MockitoCore mockitoCore = new MockitoCore();\n-\tprivate ReturnValues delegate = new MoreEmptyReturnValues();\n-\t\n-\tpublic Object valueFor(InvocationOnMock invocation){\n-\t\tObject ret = delegate.valueFor(invocation);\n-\t\tif (ret != null) {\n-\t\t\treturn ret;\n-\t\t}\n-\t\t\t\n-\t\treturn returnValueFor(invocation.getMethod().getReturnType());\n-\t}\n+    private ReturnValues delegate = new MoreEmptyReturnValues();\n+    \n+    public Object valueFor(InvocationOnMock invocation){\n+        Object ret = delegate.valueFor(invocation);\n+        if (ret != null) {\n+            return ret;\n+        }\n+            \n+        return returnValueFor(invocation.getMethod().getReturnType());\n+    }\n \n-\t@SuppressWarnings(\"unchecked\")\n-\tObject returnValueFor(Class<?> class1) {\n-\t\tif (!ClassImposterizer.INSTANCE.canImposterise(class1)) {\n-\t\t\treturn null;\n-\t\t}\n-\t\t\n-\t\treturn mockitoCore.mock((Class)class1, null, null, this);\n-\t}\n+    @SuppressWarnings(\"unchecked\")\n+    Object returnValueFor(Class<?> class1) {\n+        if (!ClassImposterizer.INSTANCE.canImposterise(class1)) {\n+            return null;\n+        }\n+        \n+        return mockitoCore.mock((Class) class1, null, null, this);\n+    }\n \n }\n--- a/test/org/mockitousage/reset/ResetTest.java\n+++ b/test/org/mockitousage/reset/ResetTest.java\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n-import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class ResetTest extends TestBase {\n \n-    private IMethods mock;\n-\n-    @Before\n-    public void setup() {\n-        mock = mock(IMethods.class);\n-    }\n+    @Mock private IMethods mock;\n+    @Mock private IMethods mockTwo;\n \n     @Test\n     public void shouldClearArgumentMatcherStackSoAbuseOfArgumentMatchersIsNotDetectedAfterReset() {\n         assertContains(\"Mock for IMethods\", \"\" + mockTwo);\n         assertEquals(\"mockie\", \"\" + mock);\n     }\n+    \n+    @Test\n+    public void shouldResetMultipleMocks() {\n+        mock.simpleMethod();\n+        mockTwo.simpleMethod();\n+        reset(mock, mockTwo);\n+        verifyNoMoreInteractions(mock, mockTwo);\n+    }\n }", "timestamp": 1239805656, "metainfo": ""}