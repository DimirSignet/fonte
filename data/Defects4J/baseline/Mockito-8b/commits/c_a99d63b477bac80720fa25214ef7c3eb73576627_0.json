{"sha": "a99d63b477bac80720fa25214ef7c3eb73576627", "log": "Renamed Invocation -> InvocationImpl before using the interface type where possible...  --HG-- rename : src/org/mockito/internal/invocation/Invocation.java => src/org/mockito/internal/invocation/InvocationImpl.java", "commit": "\n--- a/src/org/mockito/exceptions/PrintableInvocation.java\n+++ b/src/org/mockito/exceptions/PrintableInvocation.java\n \n package org.mockito.exceptions;\n \n-import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.invocation.Location;\n \n public interface PrintableInvocation {\n     \n     String toString();\n     \n-    LocationImpl getLocation();\n+    Location getLocation();\n     \n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n                 ));\n     }\n \n-    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n+    public void noMoreInteractionsWanted(InvocationImpl undesired, List<VerificationAwareInvocation> invocations) {\n         ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n         String scenario = scenarioPrinter.print(invocations);\n \n         ));\n     }\n \n-    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n+    public void noMoreInteractionsWantedInOrder(InvocationImpl undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n--- a/src/org/mockito/internal/InOrderImpl.java\n+++ b/src/org/mockito/internal/InOrderImpl.java\n import org.mockito.InOrder;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.InOrderWrapper;\n import org.mockito.internal.verification.VerificationModeFactory;\n         return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));\n     }\n \n-    public boolean isVerified(Invocation i) {\n+    public boolean isVerified(InvocationImpl i) {\n         return inOrderContext.isVerified(i);\n     }\n \n-    public void markVerified(Invocation i) {        \n+    public void markVerified(InvocationImpl i) {\n         inOrderContext.markVerified(i);\n     }\n \n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.listeners.InvocationListener;\n         this.invocationListeners = settings.getInvocationListeners();\n     }\n \n-    public Object handle(Invocation invocation) throws Throwable {\n+    public Object handle(InvocationImpl invocation) throws Throwable {\n         try {\n             Object returnedValue = mockHandler.handle(invocation);\n             notifyMethodCall(invocation, returnedValue);\n     }\n \n \n-\tprivate void notifyMethodCall(Invocation invocation, Object returnValue) {\n+\tprivate void notifyMethodCall(InvocationImpl invocation, Object returnValue) {\n \t\tfor (InvocationListener listener : invocationListeners) {\n             try {\n                 listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));\n         }\n \t}\n \n-    private void notifyMethodCallException(Invocation invocation, Throwable exception) {\n+    private void notifyMethodCallException(InvocationImpl invocation, Throwable exception) {\n \t\tfor (InvocationListener listener : invocationListeners) {\n             try {\n                 listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n package org.mockito.internal;\n \n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n         this(oldMockHandler.getMockSettings());\n     }\n \n-    public Object handle(Invocation invocation) throws Throwable {\n+    public Object handle(InvocationImpl invocation) throws Throwable {\n \t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n             // stubbing voids with stubVoid() or doAnswer() style\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.InOrder;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.progress.IOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n      * For testing purposes only. Is not the part of main API.\n      * @return last invocation\n      */\n-    public Invocation getLastInvocation() {\n+    public InvocationImpl getLastInvocation() {\n         OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n-        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n+        List<InvocationImpl> allInvocations = ongoingStubbing.getRegisteredInvocations();\n         return allInvocations.get(allInvocations.size()-1);\n     }\n \n     public Object[] ignoreStubs(Object... mocks) {\n         for (Object m : mocks) {\n             InvocationContainer invocationContainer = new MockUtil().getMockHandler(m).getInvocationContainer();\n-            List<Invocation> ins = invocationContainer.getInvocations();\n-            for (Invocation in : ins) {\n+            List<InvocationImpl> ins = invocationContainer.getInvocations();\n+            for (InvocationImpl in : ins) {\n                 if (in.stubInfo() != null) {\n                     in.ignoreForVerification();\n                 }\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n         MockitoMethod mockitoMethod = createMockitoMethod(method);\n         \n         FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n-        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n+        InvocationImpl invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n         return handler.handle(invocation);\n     }\n    \n--- a/src/org/mockito/internal/debugging/FindingsListener.java\n+++ b/src/org/mockito/internal/debugging/FindingsListener.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n public interface FindingsListener {\n-    void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed);\n+    void foundStubCalledWithDifferentArgs(InvocationImpl unused, InvocationMatcher unstubbed);\n \n-    void foundUnusedStub(Invocation unused);\n+    void foundUnusedStub(InvocationImpl unused);\n \n     void foundUnstubbed(InvocationMatcher unstubbed);\n }\n--- a/src/org/mockito/internal/debugging/LoggingListener.java\n+++ b/src/org/mockito/internal/debugging/LoggingListener.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n \n         this.logger = logger;\n     }\n \n-    public void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed) {\n+    public void foundStubCalledWithDifferentArgs(InvocationImpl unused, InvocationMatcher unstubbed) {\n         logger.log(join(\n                 \" *** Stubbing warnings from Mockito: *** \",\n                 \"\",\n                 \"\"));\n     }\n \n-    public void foundUnusedStub(Invocation unused) {\n+    public void foundUnusedStub(InvocationImpl unused) {\n         logger.log(\"This stubbing was never used   \" + unused.getLocation() + \"\\n\");\n     }\n \n--- a/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+++ b/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n package org.mockito.internal.debugging;\n \n import org.mockito.MockitoDebugger;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.UnusedStubsFinder;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n \n \n     public String printInvocations(Object ... mocks) {\n         String out = \"\";\n-        List<Invocation> invocations = allInvocationsFinder.find(asList(mocks));\n+        List<InvocationImpl> invocations = allInvocationsFinder.find(asList(mocks));\n         out += line(\"********************************\");\n         out += line(\"*** Mockito interactions log ***\");\n         out += line(\"********************************\");\n-        for(Invocation i:invocations) {\n+        for(InvocationImpl i:invocations) {\n             out += line(i.toString());\n             out += line(\" invoked: \" + i.getLocation());\n             if (i.stubInfo() != null) {\n         out += line(\"***       Unused stubs       ***\");\n         out += line(\"********************************\");\n         \n-        for(Invocation i:invocations) {\n+        for(InvocationImpl i:invocations) {\n             out += line(i.toString());\n             out += line(\" stubbed: \" + i.getLocation());\n         }\n--- a/src/org/mockito/internal/debugging/WarningsCollector.java\n+++ b/src/org/mockito/internal/debugging/WarningsCollector.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.UnusedStubsFinder;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n     }\n \n     public String getWarnings() {\n-        List<Invocation> unused = new UnusedStubsFinder().find(createdMocks);\n-        List<Invocation> all = new AllInvocationsFinder().find(createdMocks);\n+        List<InvocationImpl> unused = new UnusedStubsFinder().find(createdMocks);\n+        List<InvocationImpl> all = new AllInvocationsFinder().find(createdMocks);\n         List<InvocationMatcher> allInvocationMatchers = InvocationMatcher.createFrom(all);\n \n         String warnings = new WarningsPrinterImpl(unused, allInvocationMatchers, false).print();\n--- a/src/org/mockito/internal/debugging/WarningsFinder.java\n+++ b/src/org/mockito/internal/debugging/WarningsFinder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n import java.util.Iterator;\n \n @SuppressWarnings(\"unchecked\")\n public class WarningsFinder {\n-    private final List<Invocation> baseUnusedStubs;\n+    private final List<InvocationImpl> baseUnusedStubs;\n     private final List<InvocationMatcher> baseAllInvocations;\n \n-    public WarningsFinder(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations) {\n+    public WarningsFinder(List<InvocationImpl> unusedStubs, List<InvocationMatcher> allInvocations) {\n         this.baseUnusedStubs = unusedStubs;\n         this.baseAllInvocations = allInvocations;\n     }\n     \n     public void find(FindingsListener findingsListener) {\n-        List<Invocation> unusedStubs = new LinkedList(this.baseUnusedStubs);\n+        List<InvocationImpl> unusedStubs = new LinkedList(this.baseUnusedStubs);\n         List<InvocationMatcher> allInvocations = new LinkedList(this.baseAllInvocations);\n \n-        Iterator<Invocation> unusedIterator = unusedStubs.iterator();\n+        Iterator<InvocationImpl> unusedIterator = unusedStubs.iterator();\n         while(unusedIterator.hasNext()) {\n-            Invocation unused = unusedIterator.next();\n+            InvocationImpl unused = unusedIterator.next();\n             Iterator<InvocationMatcher> unstubbedIterator = allInvocations.iterator();\n             while(unstubbedIterator.hasNext()) {\n                 InvocationMatcher unstubbed = unstubbedIterator.next();\n             }\n         }\n \n-        for (Invocation i : unusedStubs) {\n+        for (InvocationImpl i : unusedStubs) {\n             findingsListener.foundUnusedStub(i);\n         }\n \n--- a/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n import org.mockito.internal.util.SimpleMockitoLogger;\n     private final boolean warnAboutUnstubbed;\n     private WarningsFinder finder;\n \n-    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n+    public WarningsPrinterImpl(List<InvocationImpl> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n         this(unusedStubs, unstubbedInvocations, false);\n     }\n \n-    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations, boolean warnAboutUnstubbed) {\n+    public WarningsPrinterImpl(List<InvocationImpl> unusedStubs, List<InvocationMatcher> allInvocations, boolean warnAboutUnstubbed) {\n         this(warnAboutUnstubbed, new WarningsFinder(unusedStubs, allInvocations));\n     }\n \n--- a/src/org/mockito/internal/invocation/ArgumentsComparator.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsComparator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.hamcrest.Matcher;\n \n @SuppressWarnings(\"unchecked\")\n public class ArgumentsComparator {\n-    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n+    public boolean argumentsMatch(InvocationMatcher invocationMatcher, InvocationImpl actual) {\n         Object[] actualArgs = actual.getArguments();\n         return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);\n     }\n     }\n \n     //ok, this method is a little bit messy but the vararg business unfortunately is messy...      \n-    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n+    private boolean varArgsMatch(InvocationMatcher invocationMatcher, InvocationImpl actual) {\n         if (!actual.getMethod().isVarArgs()) {\n             //if the method is not vararg forget about it\n             return false;\n--- a/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n+++ b/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n \n public interface CapturesArgumensFromInvocation {\n     \n-    void captureArgumentsFrom(Invocation i);\n+    void captureArgumentsFrom(InvocationImpl i);\n     \n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.invocation;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.internal.exceptions.VerificationAwareInvocation;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockito.internal.reporting.PrintSettings;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.invocation.PublicInvocation;\n+import org.mockito.invocation.StubInfo;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+/**\n+ * Method call on a mock object.\n+ * <p>\n+ * Contains sequence number which should be globally unique and is used for\n+ * verification in order.\n+ * <p>\n+ * Contains stack trace of invocation\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationImpl implements PublicInvocation, PrintableInvocation, InvocationOnMock, VerificationAwareInvocation {\n+\n+    private static final long serialVersionUID = 8240069639250980199L;\n+    private final int sequenceNumber;\n+    private final Object mock;\n+    private final MockitoMethod method;\n+    private final Object[] arguments;\n+    private final Object[] rawArguments;\n+\n+    private final LocationImpl location;\n+    private boolean verified;\n+    private boolean isIgnoredForVerification;\n+\n+    final RealMethod realMethod;\n+    private StubInfo stubInfo;\n+\n+    public InvocationImpl(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n+        this.method = mockitoMethod;\n+        this.mock = mock;\n+        this.realMethod = realMethod;\n+        this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);\n+        this.rawArguments = args;\n+        this.sequenceNumber = sequenceNumber;\n+        this.location = new LocationImpl();\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public Method getMethod() {\n+        return method.getJavaMethod();\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public boolean isVerified() {\n+        return verified || isIgnoredForVerification;\n+    }\n+\n+    public int getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !o.getClass().equals(this.getClass())) {\n+            return false;\n+        }\n+\n+        InvocationImpl other = (InvocationImpl) o;\n+\n+        return this.mock.equals(other.mock) && this.method.equals(other.method) && this.equalArguments(other.arguments);\n+    }\n+\n+    private boolean equalArguments(Object[] arguments) {\n+        return Arrays.equals(arguments, this.arguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 1;\n+    }\n+\n+    public String toString() {\n+        return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);\n+    }\n+\n+    public LocationImpl getLocation() {\n+        return location;\n+    }\n+\n+    public Object[] getRawArguments() {\n+        return this.rawArguments;\n+    }\n+\n+    public Object callRealMethod() throws Throwable {\n+        if (this.getMethod().getDeclaringClass().isInterface()) {\n+            new Reporter().cannotCallRealMethodOnInterface();\n+        }\n+        return realMethod.invoke(mock, rawArguments);\n+    }\n+\n+    public void markVerified() {\n+        this.verified = true;\n+    }\n+\n+    public StubInfo stubInfo() {\n+        return stubInfo;\n+    }\n+\n+    public void markStubbed(StubInfo stubInfo) {\n+        this.stubInfo = stubInfo;\n+    }\n+\n+    public boolean isIgnoredForVerification() {\n+        return isIgnoredForVerification;\n+    }\n+\n+    public void ignoreForVerification() {\n+        isIgnoredForVerification = true;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationMarker.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import java.util.List;\n \n public class InvocationMarker {\n \n-    public void markVerified(List<Invocation> invocations, CapturesArgumensFromInvocation wanted) {\n-        for (Invocation invocation : invocations) {\n+    public void markVerified(List<InvocationImpl> invocations, CapturesArgumensFromInvocation wanted) {\n+        for (InvocationImpl invocation : invocations) {\n             markVerified(invocation, wanted);\n         }\n     }\n \n-\tpublic void markVerified(Invocation invocation, CapturesArgumensFromInvocation wanted) {\n+\tpublic void markVerified(InvocationImpl invocation, CapturesArgumensFromInvocation wanted) {\n \t\tinvocation.markVerified();\n \t\twanted.captureArgumentsFrom(invocation);\n \t}\n \n-    public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {\n+    public void markVerifiedInOrder(List<InvocationImpl> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {\n         markVerified(chunk, wanted);\n         \n-        for (Invocation i : chunk) {\n+        for (InvocationImpl i : chunk) {\n             context.markVerified(i);\n         }\n     }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n public class InvocationMatcher implements PrintableInvocation, CapturesArgumensFromInvocation, Serializable {\n \n     private static final long serialVersionUID = -3047126096857467610L;\n-    private final Invocation invocation;\n+    private final InvocationImpl invocation;\n     private final List<Matcher> matchers;\n \n-    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n+    public InvocationMatcher(InvocationImpl invocation, List<Matcher> matchers) {\n         this.invocation = invocation;\n         if (matchers.isEmpty()) {\n             this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n         }\n     }\n     \n-    public InvocationMatcher(Invocation invocation) {\n+    public InvocationMatcher(InvocationImpl invocation) {\n         this(invocation, Collections.<Matcher>emptyList());\n     }\n \n         return invocation.getMethod();\n     }\n     \n-    public Invocation getInvocation() {\n+    public InvocationImpl getInvocation() {\n         return this.invocation;\n     }\n     \n         return new PrintSettings().print(matchers, invocation);\n     }\n \n-    public boolean matches(Invocation actual) {\n+    public boolean matches(InvocationImpl actual) {\n         return invocation.getMock().equals(actual.getMock())\n                 && hasSameMethod(actual)\n                 && new ArgumentsComparator().argumentsMatch(this, actual);\n      * similar means the same method name, same mock, unverified \n      * and: if arguments are the same cannot be overloaded\n      */\n-    public boolean hasSimilarMethod(Invocation candidate) {\n+    public boolean hasSimilarMethod(InvocationImpl candidate) {\n         String wantedMethodName = getMethod().getName();\n         String currentMethodName = candidate.getMethod().getName();\n         \n         return !overloadedButSameArgs;\n     }\n \n-    public boolean hasSameMethod(Invocation candidate) {        \n+    public boolean hasSameMethod(InvocationImpl candidate) {\n         //not using method.equals() for 1 good reason:\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         return invocation.getLocation();\n     }\n \n-    public void captureArgumentsFrom(Invocation i) {\n+    public void captureArgumentsFrom(InvocationImpl i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n             if (m instanceof CapturesArguments && i.getArguments().length > k) {\n         }\n     }\n \n-    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n+    public static List<InvocationMatcher> createFrom(List<InvocationImpl> invocations) {\n         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n \n-        for (Invocation i : invocations) {\n+        for (InvocationImpl i : invocations) {\n             out.add(new InvocationMatcher(i));\n         }\n \n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n \n public class InvocationsFinder {\n \n-    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n+    public List<InvocationImpl> findInvocations(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n         return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n     }\n \n-    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {\n-        List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);\n+    public List<InvocationImpl> findAllMatchingUnverifiedChunks(List<InvocationImpl> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {\n+        List<InvocationImpl> unverified = removeVerifiedInOrder(invocations, orderingContext);\n         return ListUtil.filter(unverified, new RemoveNotMatching(wanted));\n     }\n \n      * if wanted is 1 and mode is times(x), where x != 2 then returns\n      * 1,1,1\n      */\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n-        List<Invocation> unverified = removeVerifiedInOrder(invocations, context);\n-        List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n+    public List<InvocationImpl> findMatchingChunk(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        List<InvocationImpl> unverified = removeVerifiedInOrder(invocations, context);\n+        List<InvocationImpl> firstChunk = getFirstMatchingChunk(wanted, unverified);\n         \n         if (wantedCount != firstChunk.size()) {\n             return this.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n         }\n     }\n \n-    private List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {\n-        List<Invocation> firstChunk = new LinkedList<Invocation>();\n-        for (Invocation invocation : unverified) {\n+    private List<InvocationImpl> getFirstMatchingChunk(InvocationMatcher wanted, List<InvocationImpl> unverified) {\n+        List<InvocationImpl> firstChunk = new LinkedList<InvocationImpl>();\n+        for (InvocationImpl invocation : unverified) {\n             if (wanted.matches(invocation)) {\n                 firstChunk.add(invocation);\n             } else if (!firstChunk.isEmpty()) {\n         return firstChunk;\n     }\n     \n-    public Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){\n-        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){\n+    public InvocationImpl findFirstMatchingUnverifiedInvocation( List<InvocationImpl> invocations, InvocationMatcher wanted, InOrderContext context ){\n+        for( InvocationImpl invocation : removeVerifiedInOrder( invocations, context )){\n             if( wanted.matches( invocation )){\n                 return invocation;\n             }\n         return null;\n     }\n     \n-    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n-        Invocation firstSimilar = null;\n-        for (Invocation invocation : invocations) {\n+    public InvocationImpl findSimilarInvocation(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n+        InvocationImpl firstSimilar = null;\n+        for (InvocationImpl invocation : invocations) {\n             if (!wanted.hasSimilarMethod(invocation)) {\n                 continue;\n             }\n         return firstSimilar;\n     }\n     \n-    public Invocation findFirstUnverified(List<Invocation> invocations) {\n+    public InvocationImpl findFirstUnverified(List<InvocationImpl> invocations) {\n         return findFirstUnverified(invocations, null);\n     }\n     \n-    Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {\n-        for (Invocation i : invocations) {\n+    InvocationImpl findFirstUnverified(List<InvocationImpl> invocations, Object mock) {\n+        for (InvocationImpl i : invocations) {\n             boolean mockIsValid = mock == null || mock == i.getMock();\n             if (!i.isVerified() && mockIsValid) {\n                 return i;\n         return null;\n     }\n \n-    public LocationImpl getLastLocation(List<Invocation> invocations) {\n+    public LocationImpl getLastLocation(List<InvocationImpl> invocations) {\n         if (invocations.isEmpty()) {\n             return null;\n         } else {\n-            Invocation last = invocations.get(invocations.size() - 1);\n+            InvocationImpl last = invocations.get(invocations.size() - 1);\n             return last.getLocation();\n         }\n     }\n     \n-    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n-        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));\n+    public InvocationImpl findPreviousVerifiedInOrder(List<InvocationImpl> invocations, InOrderContext context) {\n+        LinkedList<InvocationImpl> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));\n         \n         if (verifiedOnly.isEmpty()) {\n             return null;\n         }\n     }\n     \n-    private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {\n-        List<Invocation> unverified = new LinkedList<Invocation>();\n-        for (Invocation i : invocations) {\n+    private List<InvocationImpl> removeVerifiedInOrder(List<InvocationImpl> invocations, InOrderContext orderingContext) {\n+        List<InvocationImpl> unverified = new LinkedList<InvocationImpl>();\n+        for (InvocationImpl i : invocations) {\n             if (orderingContext.isVerified(i)) {\n                 unverified.clear();\n             } else {\n         return unverified;\n     }\n     \n-    private class RemoveNotMatching implements Filter<Invocation> {\n+    private class RemoveNotMatching implements Filter<InvocationImpl> {\n         private final InvocationMatcher wanted;\n \n         private RemoveNotMatching(InvocationMatcher wanted) {\n             this.wanted = wanted;\n         }\n \n-        public boolean isOut(Invocation invocation) {\n+        public boolean isOut(InvocationImpl invocation) {\n             return !wanted.matches(invocation);\n         }\n     }\n \n-    private class RemoveUnverifiedInOrder implements Filter<Invocation> {\n+    private class RemoveUnverifiedInOrder implements Filter<InvocationImpl> {\n         private final InOrderContext orderingContext;\n \n         public RemoveUnverifiedInOrder(InOrderContext orderingContext) {\n             this.orderingContext = orderingContext;\n         }\n \n-        public boolean isOut(Invocation invocation) {\n+        public boolean isOut(InvocationImpl invocation) {\n             return !orderingContext.isVerified(invocation);\n         }\n     }\n      * @param context\n      * @param orderedInvocations\n      */\n-    public Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {        \n-        Invocation candidate = null;\n-        for(Invocation i : orderedInvocations) {\n+    public InvocationImpl findFirstUnverifiedInOrder(InOrderContext context, List<InvocationImpl> orderedInvocations) {\n+        InvocationImpl candidate = null;\n+        for(InvocationImpl i : orderedInvocations) {\n             if (!context.isVerified(i)) {\n                 candidate = candidate != null ? candidate : i;\n             } else {\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n \n     private static final long serialVersionUID = -311433939339443463L;\n \n-    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, InvocationImpl invocation) {\n         List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n         return invocationWithMatchers;\n     }\n \n-    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {\n+    private void validateMatchers(InvocationImpl invocation, List<LocalizedMatcher> lastMatchers) {\n         if (!lastMatchers.isEmpty()) {\n             int recordedMatchersSize = lastMatchers.size();\n             int expectedMatchersSize = invocation.getArguments().length;\n--- a/src/org/mockito/internal/invocation/UnusedStubsFinder.java\n+++ b/src/org/mockito/internal/invocation/UnusedStubsFinder.java\n      * \n      * @param mocks\n      */\n-    public List<Invocation> find(List<?> mocks) {\n-        List<Invocation> unused = new LinkedList<Invocation>();\n+    public List<InvocationImpl> find(List<?> mocks) {\n+        List<InvocationImpl> unused = new LinkedList<InvocationImpl>();\n         for (Object mock : mocks) {\n             MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(mock);\n             List<StubbedInvocationMatcher> fromSingleMock = handler.getInvocationContainer().getStubbedInvocations();\n--- a/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n package org.mockito.internal.invocation.finder;\n \n import org.mockito.internal.MockHandlerInterface;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.MockUtil;\n \n import java.util.*;\n      * @param mocks mocks\n      * @return invocations\n      */\n-    public List<Invocation> find(List<?> mocks) {\n-        Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n+    public List<InvocationImpl> find(List<?> mocks) {\n+        Set<InvocationImpl> invocationsInOrder = new TreeSet<InvocationImpl>(new SequenceNumberComparator());\n         for (Object mock : mocks) {\n             MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(mock);\n-            List<Invocation> fromSingleMock = handler.getInvocationContainer().getInvocations();\n+            List<InvocationImpl> fromSingleMock = handler.getInvocationContainer().getInvocations();\n             invocationsInOrder.addAll(fromSingleMock);\n         }\n         \n-        return new LinkedList<Invocation>(invocationsInOrder);\n+        return new LinkedList<InvocationImpl>(invocationsInOrder);\n     }\n \n-    private final class SequenceNumberComparator implements Comparator<Invocation> {\n-        public int compare(Invocation o1, Invocation o2) {\n+    private final class SequenceNumberComparator implements Comparator<InvocationImpl> {\n+        public int compare(InvocationImpl o1, InvocationImpl o2) {\n             return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());\n         }\n     }\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n \n package org.mockito.internal.invocation.finder;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.collections.ListUtil;\n \n import java.util.List;\n  */\n public class VerifiableInvocationsFinder {\n \n-    public List<Invocation> find(List<?> mocks) {\n-        List<Invocation> invocations = new AllInvocationsFinder().find(mocks);\n+    public List<InvocationImpl> find(List<?> mocks) {\n+        List<InvocationImpl> invocations = new AllInvocationsFinder().find(mocks);\n         return ListUtil.filter(invocations, new RemoveIgnoredForVerification());\n     }\n \n-    static class RemoveIgnoredForVerification implements ListUtil.Filter<Invocation>{\n-        public boolean isOut(Invocation i) {\n+    static class RemoveIgnoredForVerification implements ListUtil.Filter<InvocationImpl>{\n+        public boolean isOut(InvocationImpl i) {\n             return i.isIgnoredForVerification();\n         }\n     }\n--- a/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n+++ b/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n package org.mockito.internal.listeners;\n \n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.listeners.MethodInvocationReport;\n \n /**\n  * Report on a method call\n  */\n public class NotifiedMethodInvocationReport implements MethodInvocationReport {\n-        private final Invocation invocation;\n+        private final InvocationImpl invocation;\n         private Object returnedValue;\n         private Throwable throwable;\n \n          * @param invocation Information on the method call\n          * @param returnedValue The value returned by the method invocation\n          */\n-        public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n+        public NotifiedMethodInvocationReport(InvocationImpl invocation, Object returnedValue) {\n             this.invocation = invocation;\n             this.returnedValue = returnedValue;\n         }\n          * @param invocation Information on the method call\n          * @param throwable Tha throwable raised by the method invocation\n          */\n-        public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n+        public NotifiedMethodInvocationReport(InvocationImpl invocation, Throwable throwable) {\n             this.invocation = invocation;\n             this.throwable = throwable;\n         }\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n package org.mockito.internal.progress;\n \n import org.mockito.MockSettings;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.verification.VerificationMode;\n \n \n     void stubbingStarted();\n \n-    void stubbingCompleted(Invocation invocation);\n+    void stubbingCompleted(InvocationImpl invocation);\n     \n     void validateState();\n \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.Localized;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.verification.VerificationMode;\n         getArgumentMatcherStorage().validateState();\n     }\n \n-    public void stubbingCompleted(Invocation invocation) {\n+    public void stubbingCompleted(InvocationImpl invocation) {\n         stubbingInProgress = null;\n     }\n     \n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n import java.io.Serializable;\n \n import org.mockito.MockSettings;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.verification.VerificationMode;\n \n         threadSafely().validateState();\n     }\n \n-    public void stubbingCompleted(Invocation invocation) {\n+    public void stubbingCompleted(InvocationImpl invocation) {\n         threadSafely().stubbingCompleted(invocation);\n     }\n     \n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.invocation.ArgumentsProcessor;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.matchers.MatchersPrinter;\n import org.mockito.internal.util.MockUtil;\n         this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n     }\n \n-    public String print(List<Matcher> matchers, Invocation invocation) {\n+    public String print(List<Matcher> matchers, InvocationImpl invocation) {\n         MatchersPrinter matchersPrinter = new MatchersPrinter();\n         String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName();\n         String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);\n         }\n     }\n \n-    public String print(Invocation invocation) {\n+    public String print(InvocationImpl invocation) {\n         return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);\n     }\n \n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n package org.mockito.internal.reporting;\n \n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n /**\n     private final String wanted;\n     private final String actual;\n \n-    public SmartPrinter(InvocationMatcher wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n+    public SmartPrinter(InvocationMatcher wanted, InvocationImpl actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n         PrintSettings printSettings = new PrintSettings();\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n         printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n--- a/src/org/mockito/internal/stubbing/InvocationContainer.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n \n import java.util.List;\n \n //TODO move to different package\n public interface InvocationContainer {\n-    List<Invocation> getInvocations();\n+    List<InvocationImpl> getInvocations();\n \n     List<StubbedInvocationMatcher> getStubbedInvocations();\n }\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n  */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.StubInfoImpl;\n import org.mockito.internal.progress.MockingProgress;\n     }\n \n     public void addAnswer(Answer answer, boolean isConsecutive) {\n-        Invocation invocation = invocationForStubbing.getInvocation();\n+        InvocationImpl invocation = invocationForStubbing.getInvocation();\n         mockingProgress.stubbingCompleted(invocation);\n         AnswersValidator answersValidator = new AnswersValidator();\n         answersValidator.validate(answer, invocation);\n         }\n     }\n \n-    Object answerTo(Invocation invocation) throws Throwable {\n+    Object answerTo(InvocationImpl invocation) throws Throwable {\n         return findAnswerFor(invocation).answer(invocation);\n     }\n \n-    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n+    public StubbedInvocationMatcher findAnswerFor(InvocationImpl invocation) {\n         synchronized (stubbed) {\n             for (StubbedInvocationMatcher s : stubbed) {\n                 if (s.matches(invocation)) {\n         return \"invocationForStubbing: \" + invocationForStubbing;\n     }\n \n-    public List<Invocation> getInvocations() {\n+    public List<InvocationImpl> getInvocations() {\n         return registeredInvocations.getAll();\n     }\n \n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.DeprecatedOngoingStubbing;\n import org.mockito.stubbing.OngoingStubbing;\n         return new ConsecutiveStubbing<T>(invocationContainerImpl);\n     }\n \n-    public List<Invocation> getRegisteredInvocations() {\n+    public List<InvocationImpl> getRegisteredInvocations() {\n         //TODO interface for tests\n         return invocationContainerImpl.getInvocations();\n     }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n import java.util.TreeSet;\n \n import org.mockito.internal.creation.ClassNameFinder;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.util.MockName;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.ObjectMethodsGuru;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n import org.mockito.Mockito;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.plugins.MockMaker;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.plugins.MockitoInvocationHandler;\n             this.invocation = invocation;\n         }\n \n-        public Object handle(Invocation nullDereference) throws Throwable {\n+        public Object handle(InvocationImpl nullDereference) throws Throwable {\n             if (new ObjectMethodsGuru().isToString(nullDereference.getMethod())) {\n                 return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n                         invocation.toString();\n--- a/src/org/mockito/internal/verification/AtLeast.java\n+++ b/src/org/mockito/internal/verification/AtLeast.java\n import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n     }\n     \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<Invocation> allInvocations = data.getAllInvocations();\n+        List<InvocationImpl> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n--- a/src/org/mockito/internal/verification/AtMost.java\n+++ b/src/org/mockito/internal/verification/AtMost.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n     }\n \n     public void verify(VerificationData data) {\n-        List<Invocation> invocations = data.getAllInvocations();\n+        List<InvocationImpl> invocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         InvocationsFinder finder = new InvocationsFinder();\n-        List<Invocation> found = finder.findInvocations(invocations, wanted);\n+        List<InvocationImpl> found = finder.findInvocations(invocations, wanted);\n         int foundSize = found.size();\n         if (foundSize > maxNumberOfInvocations) {\n             new Reporter().wantedAtMostX(maxNumberOfInvocations, foundSize);\n--- a/src/org/mockito/internal/verification/Calls.java\n+++ b/src/org/mockito/internal/verification/Calls.java\n package org.mockito.internal.verification;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n     }\n \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<Invocation> allInvocations = data.getAllInvocations();\n+        List<InvocationImpl> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n--- a/src/org/mockito/internal/verification/InOrderContextImpl.java\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.collections.IdentitySet;\n import org.mockito.internal.verification.api.InOrderContext;\n \n     \n     final IdentitySet verified = new IdentitySet();\n \n-    public boolean isVerified(Invocation invocation) {\n+    public boolean isVerified(InvocationImpl invocation) {\n         return verified.contains(invocation);\n     }\n \n-    public void markVerified(Invocation i) {\n+    public void markVerified(InvocationImpl i) {\n         verified.add(i);\n     }\n }\n--- a/src/org/mockito/internal/verification/InOrderWrapper.java\n+++ b/src/org/mockito/internal/verification/InOrderWrapper.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.mockito.internal.InOrderImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n     }\n \n     public void verify(VerificationData data) {\n-        List<Invocation> invocations = new VerifiableInvocationsFinder().find(inOrder.getMocksToBeVerifiedInOrder());\n+        List<InvocationImpl> invocations = new VerifiableInvocationsFinder().find(inOrder.getMocksToBeVerifiedInOrder());\n         VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl(inOrder, invocations, data.getWanted());\n         mode.verifyInOrder(dataInOrder);\n     }\n--- a/src/org/mockito/internal/verification/NoMoreInteractions.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractions.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n \n     @SuppressWarnings(\"unchecked\")\n     public void verify(VerificationData data) {\n-        Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());                       \n+        InvocationImpl unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n         if (unverified != null) {\n             new Reporter().noMoreInteractionsWanted(unverified, (List) data.getAllInvocations());\n         }\n     }\n \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<Invocation> invocations = data.getAllInvocations();\n-        Invocation unverified = new InvocationsFinder().findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);\n+        List<InvocationImpl> invocations = data.getAllInvocations();\n+        InvocationImpl unverified = new InvocationsFinder().findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);\n         \n         if (unverified != null) {\n             new Reporter().noMoreInteractionsWantedInOrder(unverified);\n--- a/src/org/mockito/internal/verification/Only.java\n+++ b/src/org/mockito/internal/verification/Only.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n \t@SuppressWarnings(\"unchecked\")\n     public void verify(VerificationData data) {\n \t\tInvocationMatcher wantedMatcher = data.getWanted();\n-\t\tList<Invocation> invocations = data.getAllInvocations();\n-\t\tList<Invocation> chunk = finder.findInvocations(invocations,wantedMatcher);\n+\t\tList<InvocationImpl> invocations = data.getAllInvocations();\n+\t\tList<InvocationImpl> chunk = finder.findInvocations(invocations,wantedMatcher);\n \t\tif (invocations.size() != 1 && chunk.size() > 0) {\t\t\t\n-\t\t\tInvocation unverified = finder.findFirstUnverified(invocations);\n+\t\t\tInvocationImpl unverified = finder.findFirstUnverified(invocations);\n \t\t\treporter.noMoreInteractionsWanted(unverified, (List) invocations);\n \t\t} else if (invocations.size() != 1 || chunk.size() == 0) {\n \t\t\treporter.wantedButNotInvoked(wantedMatcher);\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n \n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.collections.ListUtil.Filter;\n public class RegisteredInvocations implements Serializable {\n \n     private static final long serialVersionUID = -2674402327380736290L;\n-    private final List<Invocation> invocations = Collections.synchronizedList(new LinkedList<Invocation>());\n+    private final List<InvocationImpl> invocations = Collections.synchronizedList(new LinkedList<InvocationImpl>());\n \n-    public void add(Invocation invocation) {\n+    public void add(InvocationImpl invocation) {\n         invocations.add(invocation);\n     }\n \n         }\n     }\n \n-    public List<Invocation> getAll() {\n-    \tList<Invocation> copiedList;\n+    public List<InvocationImpl> getAll() {\n+    \tList<InvocationImpl> copiedList;\n     \tsynchronized (invocations) {\n-\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n+\t\t\tcopiedList = new LinkedList<InvocationImpl>(invocations) ;\n \t\t}\n \n         return ListUtil.filter(copiedList, new RemoveToString());\n         return invocations.isEmpty();\n     }\n \n-    private static class RemoveToString implements Filter<Invocation> {\n-        public boolean isOut(Invocation invocation) {\n+    private static class RemoveToString implements Filter<InvocationImpl> {\n+        public boolean isOut(InvocationImpl invocation) {\n             return new ObjectMethodsGuru().isToString(invocation.getMethod());\n         }\n     }\n--- a/src/org/mockito/internal/verification/Times.java\n+++ b/src/org/mockito/internal/verification/Times.java\n import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n     }\n     \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<Invocation> allInvocations = data.getAllInvocations();\n+        List<InvocationImpl> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         if (wantedCount > 0) {\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.internal.util.ObjectMethodsGuru;\n         this.assertWantedIsVerifiable();\n     }\n \n-    public List<Invocation> getAllInvocations() {\n+    public List<InvocationImpl> getAllInvocations() {\n         return invocations.getInvocations();\n     }\n \n--- a/src/org/mockito/internal/verification/api/InOrderContext.java\n+++ b/src/org/mockito/internal/verification/api/InOrderContext.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n \n public interface InOrderContext {\n \n-    boolean isVerified(Invocation invocation);\n+    boolean isVerified(InvocationImpl invocation);\n \n-    void markVerified(Invocation i);\n+    void markVerified(InvocationImpl i);\n \n }\n--- a/src/org/mockito/internal/verification/api/VerificationData.java\n+++ b/src/org/mockito/internal/verification/api/VerificationData.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n public interface VerificationData {\n \n-    List<Invocation> getAllInvocations();\n+    List<InvocationImpl> getAllInvocations();\n \n     InvocationMatcher getWanted();   \n     \n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n public interface VerificationDataInOrder {\n \n-    List<Invocation> getAllInvocations();\n+    List<InvocationImpl> getAllInvocations();\n \n     InvocationMatcher getWanted();   \n     \n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.api;\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n public class VerificationDataInOrderImpl implements VerificationDataInOrder {\n \n     private final InOrderContext inOrder;\n-    private final List<Invocation> allInvocations;\n+    private final List<InvocationImpl> allInvocations;\n     private final InvocationMatcher wanted;\n \n-    public VerificationDataInOrderImpl(InOrderContext inOrder, List<Invocation> allInvocations, InvocationMatcher wanted) {\n+    public VerificationDataInOrderImpl(InOrderContext inOrder, List<InvocationImpl> allInvocations, InvocationMatcher wanted) {\n         this.inOrder = inOrder;\n         this.allInvocations = allInvocations;\n         this.wanted = wanted;        \n     }\n \n-    public List<Invocation> getAllInvocations() {\n+    public List<InvocationImpl> getAllInvocations() {\n         return allInvocations;\n     }\n \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n     InvocationsFinder finder = new InvocationsFinder();\n     InvocationMarker invocationMarker = new InvocationMarker();\n \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         this.orderingContext = orderingContext;\n     }\n \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<InvocationImpl> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);\n         \n         int actualCount = chunk.size();\n         \n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.reporting.SmartPrinter;\n         this.reporter = reporter;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted) {\n-        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n+        List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n         if (actualInvocations.isEmpty()) {\n-            Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n+            InvocationImpl similar = finder.findSimilarInvocation(invocations, wanted);\n             if (similar != null) {\n                 ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n                 Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.reporting.SmartPrinter;\n         this.reporter = reporter;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode, InOrderContext context) {\n-        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, VerificationMode mode, InOrderContext context) {\n+        List<InvocationImpl> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n         \n         if (!chunk.isEmpty()) {\n             return;\n         }\n         \n-        Invocation previousInOrder = finder.findPreviousVerifiedInOrder(invocations, context);\n+        InvocationImpl previousInOrder = finder.findPreviousVerifiedInOrder(invocations, context);\n         if (previousInOrder == null) {\n             /**\n              * It is of course possible to have an issue where the arguments are different\n              * is missing, then this method checks if the arguments are different or if the order\n              * is not invoked.\n              */\n-             List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+             List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n              if (actualInvocations == null || actualInvocations.isEmpty())  {\n-                 Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n+                 InvocationImpl similar = finder.findSimilarInvocation(invocations, wanted);\n                  if (similar != null) {\n                      Integer[] indicesOfSimilarMatchingArguments =\n                              new ArgumentMatchingTool().getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(),\n--- a/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         this.marker = marker;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         int actualCount = 0;\n         LocationImpl lastLocation = null;\n         while( actualCount < wantedCount ){\n-            Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n+            InvocationImpl next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n             if( next == null ){\n                 reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );\n             }\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n         this.finder = finder;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         this.reporter = reporter;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount, context);\n+    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount, context);\n         \n         int actualCount = chunk.size();\n         \n--- a/src/org/mockito/plugins/MockitoInvocationHandler.java\n+++ b/src/org/mockito/plugins/MockitoInvocationHandler.java\n package org.mockito.plugins;\n \n import org.mockito.internal.Incubating;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n \n import java.io.Serializable;\n \n      * @throws Throwable Throwable\n      */\n     @Incubating\n-    Object handle(Invocation invocation) throws Throwable;\n+    Object handle(InvocationImpl invocation) throws Throwable;\n \n }\n--- a/test/org/mockito/internal/AllInvocationsFinderTest.java\n+++ b/test/org/mockito/internal/AllInvocationsFinderTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n         mockTwo.simpleMethod(200);\n         mockOne.simpleMethod(300);\n         \n-        List<Invocation> invocations = finder.find(asList(mockOne, mockTwo));\n+        List<InvocationImpl> invocations = finder.find(asList(mockOne, mockTwo));\n         \n         assertEquals(3, invocations.size());\n         assertArgumentEquals(100, invocations.get(0));\n     public void shouldNotCountDuplicatedInteractions() throws Exception {\n         mockOne.simpleMethod(100);\n \n-        List<Invocation> invocations = finder.find(asList(mockOne, mockOne, mockOne));\n+        List<InvocationImpl> invocations = finder.find(asList(mockOne, mockOne, mockOne));\n \n         assertEquals(1, invocations.size());\n     }\n \n-    private void assertArgumentEquals(Object argumentValue, Invocation invocation) {\n+    private void assertArgumentEquals(Object argumentValue, InvocationImpl invocation) {\n         assertEquals(argumentValue, invocation.getArguments()[0]);\n     }\n }\n--- a/test/org/mockito/internal/InOrderImplTest.java\n+++ b/test/org/mockito/internal/InOrderImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import static java.util.Arrays.*;\n \n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n     public void shouldMarkVerifiedInOrder() throws Exception {\n         //given\n         InOrderImpl impl = new InOrderImpl((List) asList(mock));\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         assertFalse(impl.isVerified(i));\n         \n         //when\n--- a/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n+++ b/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.junit.Before;\n import org.mockito.Spy;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.listeners.MethodInvocationReport;\n     @Mock private InvocationListener listener2;\n     @Spy private CustomListener customListener;\n \n-    @Mock private Invocation invocation;\n+    @Mock private InvocationImpl invocation;\n     @Mock private MockHandler mockHandler;\n \n     private InvocationNotifierHandler notifier;\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n public class MockHandlerTest extends TestBase {\n \n \tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n-\tprivate Invocation invocation = mock(Invocation.class);\n+\tprivate InvocationImpl invocation = mock(InvocationImpl.class);\n \n \n \t@Test\n \tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n \t\t// given\n-\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\tInvocationImpl invocation = new InvocationBuilder().toInvocation();\n \t\t@SuppressWarnings(\"rawtypes\")\n \t\tMockHandler<?> handler = new MockHandler();\n \t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n \t\thandler.matchersBinder = new MatchersBinder() {\n-\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, InvocationImpl invocation) {\n \t\t\t\tthrow new InvalidUseOfMatchersException();\n \t\t\t}\n \t\t};\n \n \tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandler<?> handler, StubbedInvocationMatcher value) {\n \t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n-\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(Invocation.class))).willReturn(value);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);\n \t}\n \n \n--- a/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.plugins.MockitoInvocationHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.MockitoMethod;\n import org.mockito.internal.invocation.SerializableMethod;\n \n         //then\n         assertTrue((Integer) ret != 0);\n-        Mockito.verify(handler, never()).handle(any(Invocation.class));\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n     }\n \n     @Test\n \n         //then\n         assertTrue((Boolean) ret);\n-        Mockito.verify(handler, never()).handle(any(Invocation.class));\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n     }\n     \n     //TODO: move to separate factory\n--- a/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n+++ b/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n \n import static org.mockito.Mockito.mock;\n \n import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.ExposedInvocation;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n                 return invocation;\n             }});\n         \n-        Invocation i = (Invocation) mock.objectReturningMethodNoArgs();\n+        InvocationImpl i = (InvocationImpl) mock.objectReturningMethodNoArgs();\n         return new ExposedInvocation(i).getMethodProxy();\n     }\n }\n--- a/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n+++ b/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.StubInfoImpl;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n     private VerboseMockInvocationLogger listener;\n \n     private ByteArrayOutputStream output;\n-    private Invocation invocation = new InvocationBuilder().toInvocation();\n+    private InvocationImpl invocation = new InvocationBuilder().toInvocation();\n     private PrintableInvocation stubbedInvocation = new InvocationBuilder().toInvocation();\n \n     @Before\n--- a/test/org/mockito/internal/debugging/WarningsFinderTest.java\n+++ b/test/org/mockito/internal/debugging/WarningsFinderTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import static java.util.Arrays.*;\n \n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockitousage.IMethods;\n     @Test\n     public void shouldPrintUnusedStub() {\n         // given\n-        Invocation unusedStub = new InvocationBuilder().simpleMethod().toInvocation();\n+        InvocationImpl unusedStub = new InvocationBuilder().simpleMethod().toInvocation();\n \n         // when\n         WarningsFinder finder = new WarningsFinder(asList(unusedStub), Arrays.<InvocationMatcher>asList());\n         InvocationMatcher unstubbedInvocation = new InvocationBuilder().differentMethod().toInvocationMatcher();\n \n         // when\n-        WarningsFinder finder = new WarningsFinder(Arrays.<Invocation>asList(), Arrays.<InvocationMatcher>asList(unstubbedInvocation));\n+        WarningsFinder finder = new WarningsFinder(Arrays.<InvocationImpl>asList(), Arrays.<InvocationMatcher>asList(unstubbedInvocation));\n         finder.find(listener);\n \n         // then\n     @Test\n     public void shouldPrintStubWasUsedWithDifferentArgs() {\n         // given\n-        Invocation stub = new InvocationBuilder().arg(\"foo\").mock(mock).toInvocation();\n+        InvocationImpl stub = new InvocationBuilder().arg(\"foo\").mock(mock).toInvocation();\n         InvocationMatcher wrongArg = new InvocationBuilder().arg(\"bar\").mock(mock).toInvocationMatcher();\n \n         // when\n-        WarningsFinder finder = new WarningsFinder(Arrays.<Invocation> asList(stub), Arrays.<InvocationMatcher> asList(wrongArg));\n+        WarningsFinder finder = new WarningsFinder(Arrays.<InvocationImpl> asList(stub), Arrays.<InvocationMatcher> asList(wrongArg));\n         finder.find(listener);\n \n         // then\n--- a/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n+++ b/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.exceptions.util;\n \n import static java.util.Arrays.*;\n import java.util.List;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockitoutil.TestBase;\n \n     @Test\n     public void shouldPrintInvocations() {\n         //given\n-        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n-        Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();\n+        InvocationImpl verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n+        InvocationImpl unverified = new InvocationBuilder().differentMethod().toInvocation();\n         \n         //when\n         String out = sp.print((List) asList(verified, unverified));\n     @Test\n     public void shouldNotPrintInvocationsWhenSingleUnwanted() {\n         //given\n-        Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();\n+        InvocationImpl unverified = new InvocationBuilder().differentMethod().toInvocation();\n         \n         //when\n         String out = sp.print((List) asList(unverified));\n--- a/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n+++ b/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockitoutil.TestBase;\n     @Test\n     public void shouldKnowWhenArgumentsMatch() {\n         //given\n-        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"1\", 100).toInvocationMatcher();\n \n         //when\n     @Test\n     public void shouldKnowWhenArgsDifferent() {\n         //given\n-        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\", 100).toInvocationMatcher();\n \n         //when\n     @Test\n     public void shouldKnowWhenActualArgsSizeIsDifferent() {\n         //given\n-        Invocation invocation = new InvocationBuilder().args(\"100\", 100).toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().args(\"100\", 100).toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\").toInvocationMatcher();\n \n         //when\n     @Test\n     public void shouldKnowWhenMatchersSizeIsDifferent() {\n         //given\n-        Invocation invocation = new InvocationBuilder().args(\"100\").toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().args(\"100\").toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\", 100).toInvocationMatcher();\n \n         //when\n     public void shouldKnowWhenVarargsMatch() {\n         //given\n         mock.varargs(\"1\", \"2\", \"3\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), Any.ANY, new InstanceOf(String.class)));\n \n         //when\n     public void shouldKnowWhenVarargsDifferent() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"100\"), Any.ANY));\n \n         //when\n     public void shouldNotAllowAnyObjectMatchEntireVararg() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(Any.ANY));\n \n         //when\n     public void shouldAllowAnyVarargMatchEntireVararg() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldNotAllowAnyObjectWithMixedVarargs() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));\n \n         //when\n     public void shouldAllowAnyObjectWithMixedVarargs() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldNotMatchWhenSomeOtherArgumentDoesNotMatch() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(100), AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));\n \n         //when\n     public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull() {\n         //given\n         mock.mixedVarargs(null, null, \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(null), AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldMatchAnyVarargEvenIfMatcherIsDecorated() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n \n         //when\n--- a/test/org/mockito/internal/invocation/ExposedInvocation.java\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockito.internal.creation.MockitoMethodProxy;\n \n     private final MockitoMethodProxy methodProxy;\n \n-    public ExposedInvocation(Invocation toBeExposed) {\n+    public ExposedInvocation(InvocationImpl toBeExposed) {\n          methodProxy = ((HasCGLIBMethodProxy) toBeExposed.realMethod).getMethodProxy();\n     }\n \n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n      *\n      * @return invocation\n      */\n-    public Invocation toInvocation() {\n+    public InvocationImpl toInvocation() {\n         if (method == null) {\n             List<Class> argTypes = new LinkedList<Class>();\n             for (Object arg : args) {\n             }\n         }\n         \n-        Invocation i = new Invocation(mock, new SerializableMethod(method), args, sequenceNumber, null);\n+        InvocationImpl i = new InvocationImpl(mock, new SerializableMethod(method), args, sequenceNumber, null);\n         if (verified) {\n             i.markVerified();\n         }\n--- a/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import java.util.Arrays;\n     public void shouldMarkInvocationAsVerified() {\n         //given\n         InvocationMarker marker = new InvocationMarker();\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n         assertFalse(i.isVerified());\n         \n     public void shouldCaptureArguments() {\n         //given\n         InvocationMarker marker = new InvocationMarker();\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         final ObjectBox box = new ObjectBox();\n         CapturesArgumensFromInvocation c = new CapturesArgumensFromInvocation() {\n-            public void captureArgumentsFrom(Invocation i) {\n+            public void captureArgumentsFrom(InvocationImpl i) {\n                 box.put(i);\n             }};\n         \n         //given\n         InOrderContextImpl context = new InOrderContextImpl();\n         InvocationMarker marker = new InvocationMarker();\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n         assertFalse(context.isVerified(i));\n         assertFalse(i.isVerified());\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n \n     @Test\n     public void shouldBeACitizenOfHashes() throws Exception {\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n-        Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n         \n         Map map = new HashMap();\n         map.put(new InvocationMatcher(invocation), \"one\");\n     \n     @Test\n     public void shouldKnowIfIsSimilarTo() throws Exception {\n-        Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n+        InvocationImpl same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n         assertTrue(simpleMethod.hasSimilarMethod(same));\n         \n-        Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n+        InvocationImpl different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(different));\n     }\n     \n     @Test\n     public void shouldNotBeSimilarToVerifiedInvocation() throws Exception {\n-        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n+        InvocationImpl verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(verified));\n     }\n        \n     @Test\n     public void shouldNotBeSimilarIfMocksAreDifferent() throws Exception {\n-        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        InvocationImpl onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));\n     }    \n     \n         String sameArg = \"test\";\n         \n         InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();\n-        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n+        InvocationImpl overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n         \n         assertFalse(invocation.hasSimilarMethod(overloadedInvocation));\n     } \n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n         \n         InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg(\"foo\").toInvocationMatcher();\n-        Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n+        InvocationImpl overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n         \n         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n     @Test\n     public void shouldCaptureArgumentsFromInvocation() throws Exception {\n         //given\n-        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         CapturingMatcher capturingMatcher = new CapturingMatcher();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), capturingMatcher));\n         \n     public void shouldMatchVarargsUsingAnyVarargs() throws Exception {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n         //given\n         mock.varargs();\n-        Invocation invocation = getLastInvocation();\n+        InvocationImpl invocation = getLastInvocation();\n \n         //when\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n     @Test\n     public void shouldCreateFromInvocations() throws Exception {\n         //given\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         //when\n         List<InvocationMatcher> out = InvocationMatcher.createFrom(asList(i));\n         //then\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n @SuppressWarnings({\"unchecked\"})\n public class InvocationTest extends TestBase {\n \n-    private Invocation invocation;\n+    private InvocationImpl invocation;\n \n     @Before\n     public void setup() throws Exception {\n \n     @Test\n     public void shouldKnowIfIsEqualTo() {\n-        Invocation equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n-        Invocation nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n-        Invocation withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n+        InvocationImpl equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+        InvocationImpl nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n+        InvocationImpl withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n \n         assertFalse(invocation.equals(null));\n         assertFalse(invocation.equals(\"\"));\n     \n     @Test\n     public void shouldEqualToNotConsiderSequenceNumber() {\n-        Invocation equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        InvocationImpl equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n         \n         assertTrue(invocation.equals(equal));\n         assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());\n     \n     @Test\n     public void shouldTransformArgumentsToMatchers() throws Exception {\n-        Invocation i = new InvocationBuilder().args(\"foo\", new String[]{\"bar\"}).toInvocation();\n+        InvocationImpl i = new InvocationBuilder().args(\"foo\", new String[]{\"bar\"}).toInvocation();\n         List matchers = ArgumentsProcessor.argumentsToMatchers(i.getArguments());\n \n         assertEquals(2, matchers.size());\n     @Test\n     public void shouldBeAbleToCallRealMethod() throws Throwable {\n         //when\n-        Invocation invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n+        InvocationImpl invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n             public Object invoke(Object target, Object[] arguments) throws Throwable {\n                 return new Foo().bark();\n             }});\n     @Test\n     public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n         //given\n-        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocationOnInterface = new InvocationBuilder().toInvocation();\n \n         try {\n             //when\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n \n public class InvocationsFinderTest extends TestBase {\n     \n-    private LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n-    private Invocation simpleMethodInvocation;\n-    private Invocation simpleMethodInvocationTwo;\n-    private Invocation differentMethodInvocation;\n+    private LinkedList<InvocationImpl> invocations = new LinkedList<InvocationImpl>();\n+    private InvocationImpl simpleMethodInvocation;\n+    private InvocationImpl simpleMethodInvocationTwo;\n+    private InvocationImpl differentMethodInvocation;\n     private InvocationsFinder finder;\n     InOrderContext context = new InOrderContextImpl();\n     \n \n     @Test\n     public void shouldFindActualInvocations() throws Exception {\n-        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        List<InvocationImpl> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));\n         assertThat(actual, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n         actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));\n     \n     @Test\n     public void shouldFindFirstSimilarInvocationByName() throws Exception {\n-        Invocation overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg(\"test\").toInvocation();\n+        InvocationImpl overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg(\"test\").toInvocation();\n         \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));\n+        InvocationImpl found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));\n         assertSame(found, simpleMethodInvocation);\n     }\n     \n     @Test\n     public void shouldFindInvocationWithTheSameMethod() throws Exception {\n-        Invocation overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg(\"test\").toInvocation();\n+        InvocationImpl overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg(\"test\").toInvocation();\n         \n         invocations.add(overloadedDifferentMethod);\n         \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));\n+        InvocationImpl found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));\n         assertSame(found, overloadedDifferentMethod);\n     }\n     \n         LocationImpl last = finder.getLastLocation(invocations);\n         assertSame(differentMethodInvocation.getLocation(), last);\n         \n-        assertNull(finder.getLastLocation(Collections.<Invocation>emptyList()));\n+        assertNull(finder.getLastLocation(Collections.<InvocationImpl>emptyList()));\n     } \n     \n     @Test\n     public void shouldFindAllMatchingUnverifiedChunks() throws Exception {\n-        List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n+        List<InvocationImpl> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n         assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n         context.markVerified(simpleMethodInvocation);\n     \n     @Test\n     public void shouldFindMatchingChunk() throws Exception {\n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);\n+        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n     \n     @Test\n     public void shouldReturnAllChunksWhenModeIsAtLeastOnce() throws Exception {\n-        Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n+        InvocationImpl simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n+        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n     public void shouldReturnAllChunksWhenWantedCountDoesntMatch() throws Exception {\n-        Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n+        InvocationImpl simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n+        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n     public void shouldFindPreviousInOrder() throws Exception {\n-        Invocation previous = finder.findPreviousVerifiedInOrder(invocations, context);\n+        InvocationImpl previous = finder.findPreviousVerifiedInOrder(invocations, context);\n         assertNull(previous);\n         \n         context.markVerified(simpleMethodInvocation);\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n public class InvocationContainerImplTest {\n \n     InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress());\n-    Invocation invocation = new InvocationBuilder().toInvocation();\n+    InvocationImpl invocation = new InvocationBuilder().toInvocation();\n     LinkedList<Throwable> exceptions = new LinkedList<Throwable>();\n \n     @Test\n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n \n     private InvocationContainerImpl invocationContainerImpl;\n     private MockingProgress state;\n-    private Invocation simpleMethod;\n+    private InvocationImpl simpleMethod;\n \n     @Before\n     public void setup() {\n         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n         invocationContainerImpl.addAnswer(new Returns(\"simpleMethod\"));\n         \n-        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        InvocationImpl differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n         invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));\n         \n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockitoutil.TestBase;\n \n public class AnswersValidatorTest extends TestBase {\n \n     private AnswersValidator validator = new AnswersValidator();\n-    private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+    private InvocationImpl invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n \n     @Test\n     public void shouldValidateNullThrowable() throws Throwable {\n     @Test\n     public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\n         //given\n-        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        InvocationImpl inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n         try {\n             //when\n             validator.validate(new CallsRealMethods(), inovcationOnIterface);\n         //given\n         ArrayList mock = mock(ArrayList.class);\n         mock.clear();\n-        Invocation invocationOnClass = getLastInvocation();\n+        InvocationImpl invocationOnClass = getLastInvocation();\n         //when\n         validator.validate(new CallsRealMethods(), invocationOnClass);\n         //then no exception is thrown\n--- a/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n package org.mockito.internal.stubbing.answers;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n \n import java.nio.charset.CharacterCodingException;\n     @Test\n     public void shouldKnowValidThrowables() throws Exception {\n         //when\n-        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n         MethodInfo info = new MethodInfo(invocation);\n \n         //then\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n import java.util.*;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockitoutil.TestBase;\n \n import static org.mockito.Mockito.mock;\n         //given\n         Date d = mock(Date.class);\n         d.compareTo(new Date());\n-        Invocation compareTo = this.getLastInvocation();\n+        InvocationImpl compareTo = this.getLastInvocation();\n \n         //when\n         Object result = values.answer(compareTo);\n--- a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.*;\n \n import org.junit.Test;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockitoutil.TestBase;\n     public void shouldVerifyInOrder() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         assertFalse(context.isVerified(i));\n         \n         try {\n     public void shouldVerifyInOrderAndPass() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationImpl i = new InvocationBuilder().toInvocation();\n         context.markVerified(i);\n         assertTrue(context.isVerified(i));\n         \n     public void shouldVerifyInOrderMultipleInvoctions() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        Invocation i = new InvocationBuilder().seq(1).toInvocation();\n-        Invocation i2 = new InvocationBuilder().seq(2).toInvocation();\n+        InvocationImpl i = new InvocationBuilder().seq(1).toInvocation();\n+        InvocationImpl i2 = new InvocationBuilder().seq(2).toInvocation();\n \n         //when\n         context.markVerified(i2);\n     public void shouldVerifyInOrderMultipleInvoctionsAndThrow() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        Invocation i = new InvocationBuilder().seq(1).toInvocation();\n-        Invocation i2 = new InvocationBuilder().seq(2).toInvocation();\n+        InvocationImpl i = new InvocationBuilder().seq(1).toInvocation();\n+        InvocationImpl i2 = new InvocationBuilder().seq(2).toInvocation();\n         \n         try {\n             //when     \n--- a/test/org/mockito/internal/verification/OnlyTest.java\n+++ b/test/org/mockito/internal/verification/OnlyTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import static org.junit.Assert.*;\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoAssertionError;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n     Only only = new Only();\n     \n     public class VerificationDataStub implements VerificationData {\n-        private final Invocation invocation;\n+        private final InvocationImpl invocation;\n         private final InvocationMatcher wanted;\n \n-        public VerificationDataStub(InvocationMatcher wanted, Invocation invocation) {\n+        public VerificationDataStub(InvocationMatcher wanted, InvocationImpl invocation) {\n             this.invocation = invocation;\n             this.wanted = wanted;\n         }\n \n-        public List<Invocation> getAllInvocations() {\n+        public List<InvocationImpl> getAllInvocations() {\n             return Arrays.asList(invocation);\n         }\n \n     @Test\n     public void shouldMarkAsVerified() {\n         //given\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n         assertFalse(invocation.isVerified());\n         \n         //when\n     @Test\n     public void shouldNotMarkAsVerifiedWhenAssertionFailed() {\n         //given\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n         assertFalse(invocation.isVerified());\n         \n         //when\n--- a/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldNotReturnToStringMethod() throws Exception {\n-        Invocation toString = new InvocationBuilder().method(\"toString\").toInvocation();\n-        Invocation simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+        InvocationImpl toString = new InvocationBuilder().method(\"toString\").toInvocation();\n+        InvocationImpl simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n         \n         invocations.add(toString);\n         invocations.add(simpleMethod);\n--- a/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification.checkers;\n \n import static java.util.Arrays.asList;\n         //given\n         AtLeastXNumberOfInvocationsChecker c = new AtLeastXNumberOfInvocationsChecker();\n         c.invocationMarker = Mockito.mock(InvocationMarker.class);\n-        Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();\n-        Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().simpleMethod().toInvocation();\n+        InvocationImpl invocationTwo = new InvocationBuilder().differentMethod().toInvocation();\n \n         //when\n         c.check(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1);\n--- a/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n \n class InvocationsFinderStub extends InvocationsFinder {\n     \n-    Invocation similarToReturn;\n-    Invocation firstUnverifiedToReturn;\n-    Invocation previousInOrderToReturn;\n+    InvocationImpl similarToReturn;\n+    InvocationImpl firstUnverifiedToReturn;\n+    InvocationImpl previousInOrderToReturn;\n     \n-    final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n-    final List<Invocation> validMatchingChunkToReturn = new LinkedList<Invocation>();\n-    final List<Invocation> allMatchingUnverifiedChunksToReturn = new LinkedList<Invocation>();\n+    final List<InvocationImpl> actualToReturn = new LinkedList<InvocationImpl>();\n+    final List<InvocationImpl> validMatchingChunkToReturn = new LinkedList<InvocationImpl>();\n+    final List<InvocationImpl> allMatchingUnverifiedChunksToReturn = new LinkedList<InvocationImpl>();\n     \n-    List<Invocation> invocations;\n+    List<InvocationImpl> invocations;\n     \n     @Override\n-    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context) {\n+    public List<InvocationImpl> findAllMatchingUnverifiedChunks(List<InvocationImpl> invocations, InvocationMatcher wanted, InOrderContext context) {\n         return allMatchingUnverifiedChunksToReturn;\n     }\n     \n     @Override\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+    public List<InvocationImpl> findMatchingChunk(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         return validMatchingChunkToReturn;\n     }\n \n-    @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n+    @Override public List<InvocationImpl> findInvocations(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n         this.invocations = invocations;\n         return actualToReturn;\n     }\n     \n-    @Override public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n+    @Override public InvocationImpl findSimilarInvocation(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n         this.invocations = invocations;\n         return similarToReturn;\n     }\n     \n-    @Override public Invocation findFirstUnverified(List<Invocation> invocations) {\n+    @Override public InvocationImpl findFirstUnverified(List<InvocationImpl> invocations) {\n         this.invocations = invocations;\n         return firstUnverifiedToReturn;\n     }\n     \n     @Override\n-    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n+    public InvocationImpl findPreviousVerifiedInOrder(List<InvocationImpl> invocations, InOrderContext context) {\n         return previousInOrderToReturn;\n     }\n }\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockitoutil.TestBase;\n     private ReporterStub reporterStub;\n     \n     private InvocationMatcher wanted;\n-    private List<Invocation> invocations;\n+    private List<InvocationImpl> invocations;\n \n     @Before\n     public void setup() {\n     @Test\n     public void shouldReportWantedInvocationDiffersFromActual() {\n         assertTrue(finderStub.actualToReturn.isEmpty());\n-        Invocation actualInvocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl actualInvocation = new InvocationBuilder().toInvocation();\n         finderStub.similarToReturn = actualInvocation;\n         \n         checker.check(invocations, wanted);\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.VerificationModeBuilder;\n     private MissingInvocationInOrderChecker checker;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n-    private LinkedList<Invocation> invocations;\n+    private LinkedList<InvocationImpl> invocations;\n     private InvocationsFinderStub finderStub;\n     private InOrderContext context = new InOrderContextImpl();\n     \n         checker = new MissingInvocationInOrderChecker(finderStub, reporterStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n-        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+        invocations = new LinkedList<InvocationImpl>(asList(new InvocationBuilder().toInvocation()));\n     }                                                                    \n \n     @Test\n     public void shouldPassWhenMatchingInteractionFound() throws Exception {\n-        Invocation actual = new InvocationBuilder().toInvocation();\n+        InvocationImpl actual = new InvocationBuilder().toInvocation();\n         finderStub.allMatchingUnverifiedChunksToReturn.add(actual);\n         \n         checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n     \n     @Test\n     public void shouldReportWantedDiffersFromActual() throws Exception {\n-        Invocation previous = new InvocationBuilder().toInvocation();\n+        InvocationImpl previous = new InvocationBuilder().toInvocation();\n         finderStub.previousInOrderToReturn = previous;\n         \n         checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockitoutil.TestBase;\n     private NumberOfInvocationsChecker checker;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n-    private LinkedList<Invocation> invocations;\n+    private LinkedList<InvocationImpl> invocations;\n     private InvocationsFinderStub finderStub;\n     \n     @Before\n         checker = new NumberOfInvocationsChecker(reporterStub, finderStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n-        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+        invocations = new LinkedList<InvocationImpl>(asList(new InvocationBuilder().toInvocation()));\n     }\n \n     @Test\n \n     @Test\n     public void shouldReportWithLastInvocationStackTrace() throws Exception {\n-        Invocation first = new InvocationBuilder().toInvocation();\n-        Invocation second = new InvocationBuilder().toInvocation();\n+        InvocationImpl first = new InvocationBuilder().toInvocation();\n+        InvocationImpl second = new InvocationBuilder().toInvocation();\n         \n         finderStub.actualToReturn.addAll(asList(first, second));\n         \n     \n     @Test\n     public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n-        Invocation first = new InvocationBuilder().toInvocation();\n-        Invocation second = new InvocationBuilder().toInvocation();\n-        Invocation third = new InvocationBuilder().toInvocation();\n+        InvocationImpl first = new InvocationBuilder().toInvocation();\n+        InvocationImpl second = new InvocationBuilder().toInvocation();\n+        InvocationImpl third = new InvocationBuilder().toInvocation();\n         \n         finderStub.actualToReturn.addAll(asList(first, second, third));\n         \n     \n     @Test\n     public void shouldReportNeverWantedButInvoked() throws Exception {\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n         finderStub.actualToReturn.add(invocation);\n         \n         checker.check(invocations, wanted, 0);\n     \n     @Test\n     public void shouldMarkInvocationsAsVerified() throws Exception {\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n         finderStub.actualToReturn.add(invocation);\n         assertFalse(invocation.isVerified());\n         \n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.InOrderContextImpl;\n     private NumberOfInvocationsInOrderChecker checker;\n     private Reporter reporter;\n     private InvocationMatcher wanted;\n-    private LinkedList<Invocation> invocations;\n+    private LinkedList<InvocationImpl> invocations;\n     private InvocationsFinderStub finderStub;\n     private InOrderContext context = new InOrderContextImpl();\n     \n         checker = new NumberOfInvocationsInOrderChecker(finderStub, reporter);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n-        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+        invocations = new LinkedList<InvocationImpl>(asList(new InvocationBuilder().toInvocation()));\n     }\n     \n     @Test\n     \n     @Test\n     public void shouldReportTooLittleInvocations() throws Exception {\n-        Invocation first = new InvocationBuilder().toInvocation();\n-        Invocation second = new InvocationBuilder().toInvocation();\n+        InvocationImpl first = new InvocationBuilder().toInvocation();\n+        InvocationImpl second = new InvocationBuilder().toInvocation();\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n     \n     @Test\n     public void shouldReportTooManyInvocations() throws Exception {\n-        Invocation first = new InvocationBuilder().toInvocation();\n-        Invocation second = new InvocationBuilder().toInvocation();\n+        InvocationImpl first = new InvocationBuilder().toInvocation();\n+        InvocationImpl second = new InvocationBuilder().toInvocation();\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n     \n     @Test\n     public void shouldMarkAsVerifiedInOrder() throws Exception {\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n+        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n         assertFalse(context.isVerified(invocation));\n         finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n         \n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.StateMaster;\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.configuration.ConfigurationAccess;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.SerializableMethod;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.util.MockUtil;\n         new StateMaster().reset();\n     }\n     \n-    protected Invocation getLastInvocation() {\n+    protected InvocationImpl getLastInvocation() {\n         return new MockitoCore().getLastInvocation();\n     }\n \n                 , string.contains(sub));\n     }\n     \n-    protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n+    protected static InvocationImpl invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n         Class[] types = new Class[args.length];\n         for (int i = 0; i < args.length; i++) {\n             types[i] = args[i].getClass();\n         }\n-        return new Invocation(mock(type), new SerializableMethod(type.getMethod(methodName,\n+        return new InvocationImpl(mock(type), new SerializableMethod(type.getMethod(methodName,\n                 types)), args, 1, null);\n     }\n \n-    protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n-        return new Invocation(new Object(), new SerializableMethod(type.getMethod(methodName,\n+    protected static InvocationImpl invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n+        return new InvocationImpl(new Object(), new SerializableMethod(type.getMethod(methodName,\n                 new Class[0])), new Object[0], 1, realMethod);\n     }\n ", "timestamp": 1333231806, "metainfo": ""}