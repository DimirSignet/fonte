{"sha": "3d5808bfeb0ead973550d69bbc2b29db6f74695c", "log": "Merge branch 'patch-1' of github.com:wernight/mockito into wernight-patch-1  [ci skip]", "commit": "\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/PomComparator.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+\n+import static org.mockito.release.util.ArgumentValidation.notNull;\n+\n+class PomComparator {\n+\n+    private Closure<String> left;\n+    private Closure<String> right;\n+\n+    PomComparator setPair(Closure<String> left, Closure<String> right) {\n+        notNull(left, \"pom content to compare\", right, \"pom content to compare\");\n+        this.left = left;\n+        this.right = right;\n+        return this;\n+    }\n+\n+    boolean areEqual() {\n+        String left = this.left.call();\n+        String right = this.right.call();\n+\n+        notNull(left, \"pom content to compare\", right, \"pom content to compare\");\n+\n+        return replaceVersion(left).equals(replaceVersion(right));\n+    }\n+\n+    private String replaceVersion(String pom) {\n+        return pom.replaceFirst(\"<version>(.*)</version>\", \"<version>foobar</version>\");\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/PublicationsComparator.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+\n+import java.io.File;\n+\n+/**\n+ * Compares publications\n+ */\n+public interface PublicationsComparator {\n+\n+    /**\n+     * Sets files for comparison\n+     */\n+    void compareBinaries(Closure<File> left, Closure<File> right);\n+\n+    /**\n+     * Sets poms for comparison\n+     */\n+    void comparePoms(Closure<String> left, Closure<String> right);\n+\n+    /**\n+     * Gives information if publications are equal\n+     */\n+    boolean isPublicationsEqual();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/PublicationsComparatorTask.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.tasks.TaskAction;\n+\n+import java.io.File;\n+\n+public class PublicationsComparatorTask extends DefaultTask implements PublicationsComparator {\n+\n+    private ZipComparator zipComparator = new ZipComparator(new ZipCompare());\n+    private PomComparator pomComparator = new PomComparator();\n+    private Boolean publicationsEqual;\n+\n+    public void compareBinaries(Closure<File> left, Closure<File> right) {\n+        zipComparator.setPair(left, right);\n+    }\n+\n+    public void comparePoms(Closure<String> left, Closure<String> right) {\n+        pomComparator.setPair(left, right);\n+    }\n+\n+    public boolean isPublicationsEqual() {\n+        assert publicationsEqual != null : \"Comparison task was not executed yet, the 'publicationsEqual' information not available.\";\n+        return publicationsEqual;\n+    }\n+\n+    @TaskAction public void comparePublications() {\n+        getLogger().lifecycle(\"{} - about to compare publications\", getPath());\n+\n+        boolean poms = pomComparator.areEqual();\n+        getLogger().lifecycle(\"{} - pom files equal: {}\", getPath(), poms);\n+\n+        ZipComparator.Result result = zipComparator.compareFiles();\n+        getLogger().info(\"{} - compared binaries: '{}' and '{}'\", getPath(), result.getFile1(), result.getFile2());\n+        boolean jars = result.areEqual();\n+        getLogger().lifecycle(\"{} - source jars equal: {}\", getPath(), jars);\n+\n+\n+        this.publicationsEqual = jars && poms;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/ZipComparator.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+\n+import java.io.File;\n+\n+import static org.mockito.release.util.ArgumentValidation.notNull;\n+\n+class ZipComparator {\n+\n+    private Closure<File> file1;\n+    private Closure<File> file2;\n+\n+    private final ZipCompare zipCompare;\n+\n+    ZipComparator(ZipCompare zipCompare) {\n+        this.zipCompare = zipCompare;\n+    }\n+\n+    ZipComparator setPair(Closure<File> file1, Closure<File> file2) {\n+        notNull(file1, \"zip/jar file to compare\", file2, \"zip/jar file to compare\");\n+        this.file1 = file1;\n+        this.file2 = file2;\n+        return this;\n+    }\n+\n+    Result compareFiles() {\n+        final File file1 = this.file1.call();\n+        final File file2 = this.file2.call();\n+        notNull(file1, \"zip/jar file to compare\", file2, \"zip/jar file to compare\");\n+\n+        final boolean equals = zipCompare.compareZips(file1.getAbsolutePath(), file2.getAbsolutePath());\n+\n+        return new Result() {\n+            public boolean areEqual() { return equals; }\n+            public File getFile1() { return file1; }\n+            public File getFile2() { return file2; }\n+        };\n+    }\n+\n+    static interface Result {\n+        boolean areEqual();\n+        File getFile1();\n+        File getFile2();\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/ZipCompare.java\n+package org.mockito.release.comparison;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+//TODO SF - borrowed code, not very nice, should not write to system out and should throw decent exceptions\n+class ZipCompare {\n+\n+    boolean compareZips(String filePath1, String filePath2) {\n+        ZipFile file1;\n+        try {\n+            file1 = new ZipFile(filePath1);\n+        } catch (IOException e) {\n+            System.out.println(\"Could not open zip file \" + filePath1 + \": \" + e);\n+            return false;\n+        }\n+\n+        ZipFile file2;\n+        try {\n+            file2 = new ZipFile(filePath2);\n+        } catch (IOException e) {\n+            System.out.println(\"Could not open zip file \" + filePath1 + \": \" + e);\n+            return false;\n+        }\n+\n+        System.out.println(\"Comparing \" + filePath1 + \" with \" + filePath2 + \":\");\n+\n+        Set set1 = new LinkedHashSet();\n+        for (Enumeration e = file1.entries(); e.hasMoreElements(); )\n+            set1.add(((ZipEntry) e.nextElement()).getName());\n+\n+        Set set2 = new LinkedHashSet();\n+        for (Enumeration e = file2.entries(); e.hasMoreElements(); )\n+            set2.add(((ZipEntry) e.nextElement()).getName());\n+\n+        int errcount = 0;\n+        int filecount = 0;\n+        for (Iterator i = set1.iterator(); i.hasNext(); ) {\n+            String name = (String) i.next();\n+            if (!set2.contains(name)) {\n+                System.out.println(name + \" not found in \" + filePath2);\n+                errcount += 1;\n+                continue;\n+            }\n+            try {\n+                set2.remove(name);\n+                if (!streamsEqual(file1.getInputStream(file1.getEntry(name)), file2.getInputStream(file2\n+                        .getEntry(name)))) {\n+                    System.out.println(name + \" does not match\");\n+                    errcount += 1;\n+                    continue;\n+                }\n+            } catch (Exception e) {\n+                System.out.println(name + \": IO Error \" + e);\n+                e.printStackTrace();\n+                errcount += 1;\n+                continue;\n+            }\n+            filecount += 1;\n+        }\n+        for (Iterator i = set2.iterator(); i.hasNext(); ) {\n+            String name = (String) i.next();\n+            System.out.println(name + \" not found in \" + filePath1);\n+            errcount += 1;\n+        }\n+        System.out.println(filecount + \" entries matched\");\n+        if (errcount > 0) {\n+            System.out.println(errcount + \" entries did not match\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    static boolean streamsEqual(InputStream stream1, InputStream stream2) throws IOException {\n+        byte[] buf1 = new byte[4096];\n+        byte[] buf2 = new byte[4096];\n+        boolean done1 = false;\n+        boolean done2 = false;\n+\n+        try {\n+            while (!done1) {\n+                int off1 = 0;\n+                int off2 = 0;\n+\n+                while (off1 < buf1.length) {\n+                    int count = stream1.read(buf1, off1, buf1.length - off1);\n+                    if (count < 0) {\n+                        done1 = true;\n+                        break;\n+                    }\n+                    off1 += count;\n+                }\n+                while (off2 < buf2.length) {\n+                    int count = stream2.read(buf2, off2, buf2.length - off2);\n+                    if (count < 0) {\n+                        done2 = true;\n+                        break;\n+                    }\n+                    off2 += count;\n+                }\n+                if (off1 != off2 || done1 != done2)\n+                    return false;\n+                for (int i = 0; i < off1; i++) {\n+                    if (buf1[i] != buf2[i])\n+                        return false;\n+                }\n+            }\n+            return true;\n+        } finally {\n+            stream1.close();\n+            stream2.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/GitNotesBuilder.java\n+package org.mockito.release.notes;\n+\n+import org.gradle.api.Project;\n+import org.mockito.release.notes.exec.Exec;\n+import org.mockito.release.notes.improvements.ImprovementSet;\n+import org.mockito.release.notes.improvements.ImprovementsProvider;\n+import org.mockito.release.notes.improvements.Improvements;\n+import org.mockito.release.notes.vcs.ContributionSet;\n+import org.mockito.release.notes.vcs.ContributionsProvider;\n+import org.mockito.release.notes.vcs.Vcs;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.util.Date;\n+\n+class GitNotesBuilder implements NotesBuilder {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(GitNotesBuilder.class);\n+\n+    private final File workDir;\n+    private final String authTokenEnvVar;\n+\n+    /**\n+     * @param workDir the working directory for external processes execution (for example: git log)\n+     * @param authTokenEnvVar the env var that holds the GitHub auth token\n+     */\n+    GitNotesBuilder(File workDir, String authTokenEnvVar) {\n+        this.workDir = workDir;\n+        this.authTokenEnvVar = authTokenEnvVar;\n+    }\n+\n+    public String buildNotes(String version, String fromRevision, String toRevision) {\n+        LOG.info(\"Getting release notes between {} and {}\", fromRevision, toRevision);\n+\n+        ContributionsProvider contributionsProvider = Vcs.getGitProvider(Exec.getProcessRunner(workDir));\n+        ContributionSet contributions = contributionsProvider.getContributionsBetween(fromRevision, toRevision);\n+\n+        ImprovementsProvider improvementsProvider = Improvements.getGitHubProvider(authTokenEnvVar);\n+        ImprovementSet improvements = improvementsProvider.getImprovements(contributions);\n+\n+        return new NotesPrinter().printNotes(version, new Date(), contributions, improvements);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/Notes.java\n+package org.mockito.release.notes;\n+\n+import org.gradle.api.Project;\n+import org.mockito.release.notes.versions.PreviousVersion;\n+import org.mockito.release.notes.versions.Versions;\n+\n+import java.io.File;\n+\n+/**\n+ * Release notes services\n+ */\n+public class Notes {\n+\n+    /**\n+     * Release notes build based on git and GitHub.\n+     *\n+     * @param workDir working directory for executing external processes like 'git log'\n+     * @param authTokenEnvVar env variable name that holds the GitHub auth token\n+     */\n+    public static NotesBuilder gitHubNotesBuilder(File workDir, String authTokenEnvVar) {\n+        return new GitNotesBuilder(workDir, authTokenEnvVar);\n+    }\n+\n+    /**\n+     * Provides previous version information based on the release notes content file\n+     */\n+    public static PreviousVersion previousVersion(String releaseNotesContent) {\n+        return Versions.previousFromNotesContent(releaseNotesContent);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/NotesBuilder.java\n+package org.mockito.release.notes;\n+\n+/**\n+ * Builds the release notes text\n+ */\n+public interface NotesBuilder {\n+\n+    /**\n+     * Release notes text for contributions between given versions.\n+     *\n+     * @param version the version of the release we're building the notes\n+     * @param fromRevision valid git revision (can be tag name or HEAD)\n+     * @param toRevision valid git revision (can be tag name or HEAD)\n+     */\n+    String buildNotes(String version, String fromRevision, String toRevision);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/NotesPrinter.java\n+package org.mockito.release.notes;\n+\n+import org.mockito.release.notes.util.HumanReadable;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+class NotesPrinter {\n+\n+    public String printNotes(String version, Date date, HumanReadable contributions, HumanReadable improvements) {\n+        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm z\");\n+        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        String now = format.format(date);\n+\n+        return \"### \" + version + \" (\" + now + \")\" + \"\\n\\n\"\n+                + contributions.toText() + \"\\n\"\n+                + improvements.toText() + \"\\n\\n\";\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/exec/DefaultProcessRunner.java\n+package org.mockito.release.notes.exec;\n+\n+import org.mockito.release.notes.util.ReleaseNotesException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+class DefaultProcessRunner implements ProcessRunner {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(DefaultProcessRunner.class);\n+    private final File workDir;\n+\n+    DefaultProcessRunner(File workDir) {\n+        this.workDir = workDir;\n+    }\n+\n+    public String run(String... commandLine) {\n+        LOG.info(\"Executing command: {}\", (Object) commandLine);\n+\n+        try {\n+            Process process = new ProcessBuilder(commandLine).directory(workDir).redirectErrorStream(true).start();\n+            return readFully(new BufferedReader(new InputStreamReader(process.getInputStream())));\n+        } catch (Exception e) {\n+            throw new ReleaseNotesException(\"Problems executing command: \" + Arrays.toString(commandLine), e);\n+        }\n+    }\n+\n+    private static String readFully(BufferedReader reader) throws IOException {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            String line;\n+            while((line = reader.readLine()) != null) {\n+                sb.append(line).append(\"\\n\");\n+            }\n+            return sb.toString();\n+        } finally {\n+            reader.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/exec/Exec.java\n+package org.mockito.release.notes.exec;\n+\n+import java.io.File;\n+\n+public class Exec {\n+\n+    public static ProcessRunner getProcessRunner(File workDir) {\n+        return new DefaultProcessRunner(workDir);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/exec/ProcessRunner.java\n+package org.mockito.release.notes.exec;\n+\n+/**\n+ * Provides ways to execute external processes\n+ */\n+public interface ProcessRunner {\n+\n+    /**\n+     * Executes given command line and returns the output.\n+     *\n+     * @param commandLine to execute\n+     * @return combined error and standard output.\n+     */\n+    String run(String ... commandLine);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/DefaultImprovements.java\n+package org.mockito.release.notes.improvements;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+class DefaultImprovements implements ImprovementSet {\n+\n+    private final List<Improvement> improvements = new LinkedList<Improvement>();\n+\n+    public String toText() {\n+        if (improvements.isEmpty()) {\n+            //TODO SF we should break the build if there are no notable improvements yet the binaries have changed\n+            return \"* No notable improvements. See the commits for detailed changes.\";\n+        }\n+        StringBuilder sb = new StringBuilder(\"* Improvements: \").append(improvements.size());\n+        for (Improvement i : improvements) {\n+            sb.append(\"\\n  * \").append(i.toText());\n+        }\n+        return sb.toString();\n+    }\n+\n+    public void add(Improvement improvement) {\n+        improvements.add(improvement);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/GitHubAuthToken.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.util.ReleaseNotesException;\n+\n+class GitHubAuthToken {\n+\n+    private final String envVariableName;\n+\n+    public GitHubAuthToken(String envVariableName) {\n+        this.envVariableName = envVariableName;\n+    }\n+\n+    public String getToken() {\n+        String out = System.getenv(envVariableName);\n+        if (out == null) {\n+            throw new ReleaseNotesException(\"Environmental variable '\" + envVariableName + \"' is missing.\", null);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/GitHubImprovementsProvider.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.vcs.ContributionSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class GitHubImprovementsProvider implements ImprovementsProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GitHubImprovementsProvider.class);\n+    private final String authToken;\n+\n+    public GitHubImprovementsProvider(String authToken) {\n+        this.authToken = authToken;\n+    }\n+\n+    public ImprovementSet getImprovements(ContributionSet contributions) {\n+        LOGGER.info(\"Parsing {} commits with {} tickets\", contributions.getAllCommits().size(), contributions.getAllTickets().size());\n+        DefaultImprovements out = new DefaultImprovements();\n+        new GitHubTicketFetcher().fetchTickets(authToken, contributions.getAllTickets(), out);\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/GitHubTicketFetcher.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.json.simple.JSONObject;\n+import org.json.simple.JSONValue;\n+import org.mockito.release.notes.util.IOUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+class GitHubTicketFetcher {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(GitHubTicketFetcher.class);\n+\n+    void fetchTickets(String authToken, Collection<String> ticketIds, DefaultImprovements improvements) {\n+        if (ticketIds.isEmpty()) {\n+            return;\n+        }\n+        LOG.info(\"Querying GitHub API for {} tickets\", ticketIds.size());\n+        String url = \"https://api.github.com/repos/mockito/mockito/issues?access_token=\" + authToken;\n+        url += \"&state=closed&filter=all\";\n+\n+        Set<Long> tickets = new HashSet<Long>();\n+        for (String id : ticketIds) {\n+            tickets.add(Long.parseLong(id));\n+        }\n+\n+        try {\n+            fetch(tickets, improvements, url);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems fetching \" + ticketIds.size() + \" from GitHub\", e);\n+        }\n+    }\n+\n+    private void fetch(Set<Long> tickets, DefaultImprovements improvements, String url) throws IOException {\n+        InputStream response = new URL(url).openStream();\n+        String content = IOUtil.readFully(response);\n+        LOG.info(\"GitHub API responded successfully.\");\n+        List<JSONObject> issues = (List) JSONValue.parse(content);\n+        LOG.info(\"GitHub API returned {} issues.\", issues.size());\n+\n+        for (JSONObject issue : issues) {\n+            long id = (Long) issue.get(\"number\");\n+            if (tickets.remove(id)) {\n+                String issueUrl = (String) issue.get(\"html_url\");\n+                String title = (String) issue.get(\"title\");\n+                improvements.add(new Improvement(id, title, issueUrl, new HashSet()));\n+\n+                if (tickets.isEmpty()) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/Improvement.java\n+package org.mockito.release.notes.improvements;\n+\n+import java.net.URL;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+class Improvement {\n+\n+    private final long id;\n+    private final String title;\n+    private final String url;\n+    private final Collection<String> labels;\n+\n+    public Improvement(long id, String title, String url, Collection<String> labels) {\n+        this.id = id;\n+        this.title = title;\n+        this.url = url;\n+        this.labels = labels;\n+    }\n+\n+    public String toText() {\n+        return title + \" [(#\" + id + \")](\" + url + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/ImprovementSet.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.util.HumanReadable;\n+\n+/**\n+ * the improvements\n+ */\n+public interface ImprovementSet extends HumanReadable {\n+\n+    /**\n+     * human readable representation of the improvements\n+     */\n+    String toText();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/Improvements.java\n+package org.mockito.release.notes.improvements;\n+\n+/**\n+ * Improvements based on some issue tracking system outside of the vcs.\n+ */\n+public class Improvements {\n+\n+    /**\n+     * Fetches tickets from GitHub. Needs GitHub auth token.\n+     *\n+     * @param authToken the GitHub auth token\n+     */\n+    public static ImprovementsProvider getGitHubProvider(final String authToken) {\n+        return new GitHubImprovementsProvider(authToken);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/improvements/ImprovementsProvider.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.vcs.ContributionSet;\n+\n+public interface ImprovementsProvider {\n+\n+    ImprovementSet getImprovements(ContributionSet contributions);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/util/HumanReadable.java\n+package org.mockito.release.notes.util;\n+\n+/**\n+ * Human readable text representation\n+ */\n+public interface HumanReadable {\n+\n+    /**\n+     * the text representation\n+     */\n+    String toText();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/util/IOUtil.java\n+package org.mockito.release.notes.util;\n+\n+import java.io.*;\n+\n+/**\n+ * IO utils. A bit of reinventing the wheel but we don't want extra dependencies at this stage and we want to be java.\n+ */\n+public class IOUtil {\n+\n+    /**\n+     * Reads string from the stream and closes it\n+     */\n+    public static String readFully(InputStream stream) {\n+        BufferedReader r = null;\n+        try {\n+            r = new BufferedReader(new InputStreamReader(stream));\n+            return readNow(stream);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems reading stream\", e);\n+        } finally {\n+            close(r);\n+        }\n+    }\n+\n+    /**\n+     * Closes the target. Does nothing when target is null. Is not silent, throws exception on IOException.\n+     *\n+     * @param closeable the target, may be null\n+     */\n+    public static void close(Closeable closeable) {\n+        if (closeable != null) {\n+            try {\n+                closeable.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Problems closing stream\", e);\n+            }\n+        }\n+    }\n+\n+    private static String readNow(InputStream is) throws IOException {\n+        java.util.Scanner s = new java.util.Scanner(is).useDelimiter(\"\\\\A\");\n+        return s.hasNext() ? s.next() : \"\";\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/util/Predicate.java\n+package org.mockito.release.notes.util;\n+\n+/**\n+ * Generic predicate\n+ */\n+public interface Predicate<T> {\n+\n+    /**\n+     * returns true if the predicate is satisfied for given object\n+     */\n+    boolean isTrue(T object);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/util/ReleaseNotesException.java\n+package org.mockito.release.notes.util;\n+\n+public class ReleaseNotesException extends RuntimeException {\n+\n+    public ReleaseNotesException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/Commit.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.Collection;\n+\n+public interface Commit {\n+\n+    /**\n+     * Author identifier. For git it would be 'email'\n+     */\n+    String getAuthorId();\n+\n+    /**\n+     * Author display name. For git it would be 'author'\n+     */\n+    String getAuthor();\n+\n+    /**\n+     * Commit message\n+     */\n+    String getMessage();\n+\n+    /**\n+     * Tickets referenced by the commit. For example, jira issue ids or GitHub issue ids.\n+     */\n+    Collection<String> getTickets();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/Contribution.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+class Contribution implements Comparable<Contribution> {\n+\n+    //email identifies the contributor, author alias not necessarily\n+    final String authorId;\n+    final String author;\n+    final List<Commit> commits = new LinkedList<Commit>();\n+\n+    Contribution(Commit commit) {\n+        authorId = commit.getAuthorId();\n+        author = commit.getAuthor();\n+        commits.add(commit);\n+    }\n+\n+    Contribution add(Commit commit) {\n+        assert authorId.equals(commit.getAuthorId());\n+        commits.add(commit);\n+        return this;\n+    }\n+\n+    public String toText() {\n+        return commits.size() + \": \" + author;\n+    }\n+\n+    public int compareTo(Contribution other) {\n+        return Integer.valueOf(other.getCommits().size()).compareTo(commits.size());\n+    }\n+\n+    public Collection<Commit> getCommits() {\n+        return commits;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/ContributionSet.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.HumanReadable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A set of contributions\n+ */\n+public interface ContributionSet extends HumanReadable {\n+\n+    /**\n+     * all commits in given contribution set, spanning all authors\n+     */\n+    Collection<Commit> getAllCommits();\n+\n+    /**\n+     * all tickets referenced in commit messages\n+     */\n+    Collection<String> getAllTickets();\n+\n+    /**\n+     * human readable text representation\n+     */\n+    String toText();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/ContributionsProvider.java\n+package org.mockito.release.notes.vcs;\n+\n+/**\n+ * Knows the contributions\n+ */\n+public interface ContributionsProvider {\n+\n+    /**\n+     * Provides contributions between specified versions\n+     */\n+    ContributionSet getContributionsBetween(String fromRev, String toRev);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/DefaultContributionSet.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.Predicate;\n+\n+import java.util.*;\n+\n+class DefaultContributionSet implements ContributionSet {\n+    private final Map<String, Contribution> contributions = new HashMap<String, Contribution>();\n+    private final Collection<Commit> commits = new LinkedList<Commit>();\n+    private final Predicate<Commit> ignoreCommit;\n+    private final Set<String> tickets = new LinkedHashSet<String>();\n+\n+    public DefaultContributionSet(Predicate<Commit> ignoredCommit) {\n+        this.ignoreCommit = ignoredCommit;\n+    }\n+\n+    void add(Commit commit) {\n+        if (ignoreCommit.isTrue(commit)) {\n+            return;\n+        }\n+        commits.add(commit);\n+        tickets.addAll(commit.getTickets());\n+        Contribution c = contributions.get(commit.getAuthorId());\n+        if (c == null) {\n+            contributions.put(commit.getAuthorId(), new Contribution(commit));\n+        } else {\n+            c.add(commit);\n+        }\n+    }\n+\n+    public Collection<Commit> getAllCommits() {\n+        return commits;\n+    }\n+\n+    public Collection<String> getAllTickets() {\n+        return tickets;\n+    }\n+\n+    public String toText() {\n+        StringBuilder sb = new StringBuilder(\"* Authors: \").append(contributions.size())\n+                .append(\"\\n* Commits: \").append(commits.size());\n+\n+        for (Map.Entry<String, Contribution> entry : sortByValue(contributions)) {\n+            Contribution c = entry.getValue();\n+            sb.append(\"\\n  * \").append(c.toText());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static <K, V extends Comparable<V>> List<Map.Entry<K, V>> sortByValue(Map<K, V> map) {\n+        List<Map.Entry<K, V>> entries = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n+        Collections.sort(entries, new ByValue<K, V>());\n+        return entries;\n+    }\n+\n+    private static class ByValue<K, V extends Comparable<V>> implements Comparator<Map.Entry<K, V>> {\n+        public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n+            return o1.getValue().compareTo(o2.getValue());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/GitCommit.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+\n+class GitCommit implements Commit {\n+\n+    private final String email;\n+    private final String author;\n+    private final String message;\n+    private Set<String> tickets;\n+\n+    public GitCommit(String email, String author, String message) {\n+        this.email = email;\n+        this.author = author;\n+        this.message = message;\n+        this.tickets = TicketParser.parseTickets(message);\n+    }\n+\n+    public String getAuthorId() {\n+        return email;\n+    }\n+\n+    public String getAuthor() {\n+        return author;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public Collection<String> getTickets() {\n+        return tickets;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/GitContributionsProvider.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.Predicate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class GitContributionsProvider implements ContributionsProvider {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(GitContributionsProvider.class);\n+    private final GitLogProvider logProvider;\n+    private final Predicate<Commit> ignoredCommit;\n+\n+    GitContributionsProvider(GitLogProvider logProvider, Predicate<Commit> ignoredCommit) {\n+        this.logProvider = logProvider;\n+        this.ignoredCommit = ignoredCommit;\n+    }\n+\n+    public ContributionSet getContributionsBetween(String fromRev, String toRev) {\n+        LOG.info(\"Fetching {} from the repo\", fromRev);\n+\n+        LOG.info(\"Loading all commits between {} and {}\", fromRev, toRev);\n+\n+        String commitToken = \"@@commit@@\";\n+        String infoToken = \"@@info@@\";\n+        String log = logProvider.getLog(fromRev, toRev, \"--pretty=format:%ae\" + infoToken + \"%an\" + infoToken + \"%B%N\" + commitToken);\n+\n+        DefaultContributionSet contributions = new DefaultContributionSet(ignoredCommit);\n+\n+        for (String entry : log.split(commitToken)) {\n+            String[] entryParts = entry.split(infoToken);\n+            if (entryParts.length == 3) {\n+                String email = entryParts[0].trim();\n+                String author = entryParts[1].trim();\n+                String message = entryParts[2].trim();\n+                contributions.add(new GitCommit(email, author, message));\n+            }\n+        }\n+\n+        return contributions;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/GitLogProvider.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.exec.ProcessRunner;\n+\n+class GitLogProvider {\n+\n+    private final ProcessRunner runner;\n+\n+    GitLogProvider(ProcessRunner runner) {\n+        this.runner = runner;\n+    }\n+\n+    public String getLog(String fromRev, String toRev, String format) {\n+        runner.run(\"git\", \"fetch\", \"origin\", \"+refs/tags/\" + fromRev + \":refs/tags/\" + fromRev);\n+        return runner.run(\"git\", \"log\", format, fromRev + \"..\" + toRev);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/IgnoreCiSkip.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.Predicate;\n+\n+/**\n+ * Ignores commits with [ci skip]\n+ */\n+class IgnoreCiSkip implements Predicate<Commit> {\n+\n+    public boolean isTrue(Commit commit) {\n+        //we used #id for Travis CI build number in commits performed by Travis. Let's avoid pulling those ids here.\n+        //also, if ci was skipped we probably are not interested in such change, no?\n+        //Currently, all our [ci skip] are infrastructure commits plus documentation changes made by humans via github web interface\n+        return commit.getMessage().contains(\"[ci skip]\");\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/TicketParser.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class TicketParser {\n+\n+    /**\n+     * Collects all ticked ids found in message, ticket format is #123\n+     */\n+    static Set<String> parseTickets(String message) {\n+        Set<String> tickets = new LinkedHashSet<String>();\n+        Pattern ticket = Pattern.compile(\"#\\\\d+\");\n+        Matcher m = ticket.matcher(message);\n+        while(m.find()) {\n+            String ticketId = m.group().substring(1); //remove leading '#'\n+            tickets.add(ticketId);\n+        }\n+        return tickets;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/vcs/Vcs.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.exec.ProcessRunner;\n+\n+/**\n+ * Vcs services\n+ */\n+public class Vcs {\n+\n+    /**\n+     * Provides means to get contributions.\n+     */\n+    public static ContributionsProvider getGitProvider(ProcessRunner runner) {\n+        return new GitContributionsProvider(new GitLogProvider(runner), new IgnoreCiSkip());\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/versions/FromNotesContent.java\n+package org.mockito.release.notes.versions;\n+\n+import org.mockito.release.notes.util.ReleaseNotesException;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Retrieves previously released version based on the top entry in the current release notes content.\n+ */\n+class FromNotesContent implements PreviousVersion {\n+\n+    private final String releaseNotesContent;\n+\n+    FromNotesContent(String releaseNotesContent) {\n+        this.releaseNotesContent = releaseNotesContent;\n+    }\n+\n+    public String getPreviousVersion() {\n+        //Example: \"### 1.9.5 (06-10-2012)\", we want to extract \"1.9.5\"\n+        Pattern p = Pattern.compile(\"(?s)^### (.+?) .*\");\n+        Matcher m = p.matcher(releaseNotesContent);\n+        if(!m.matches()) {\n+            throw new ReleaseNotesException(\"Unable to parse previous version from release notes content: \" + releaseNotesContent, null);\n+        }\n+        return m.group(1);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/versions/PreviousVersion.java\n+package org.mockito.release.notes.versions;\n+\n+/**\n+ * Provides the previous version.\n+ */\n+public interface PreviousVersion {\n+\n+    /**\n+     * The previous version\n+     */\n+    String getPreviousVersion();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/notes/versions/Versions.java\n+package org.mockito.release.notes.versions;\n+\n+/**\n+ * Version services\n+ */\n+public class Versions {\n+\n+    /**\n+     * Provides a way to retrieve previous version based on the content of the release notes file.\n+     */\n+    public static PreviousVersion previousFromNotesContent(String notesContent) {\n+        return new FromNotesContent(notesContent);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/util/ArgumentValidation.java\n+package org.mockito.release.util;\n+\n+/**\n+ * Utility for validation of arguments\n+ */\n+public abstract class ArgumentValidation {\n+\n+    /**\n+     * None of the input targets can not be null otherwise IllegalArgumentException is thrown.\n+     * Every second argument must a String describing the previous element.\n+     */\n+    public static void notNull(Object ... targets) {\n+        if (targets.length % 2 != 0) {\n+            throw new IllegalArgumentException(\"notNull method requires pairs of argument + message\");\n+        }\n+\n+        boolean nullFound = false;\n+        for (Object t : targets) {\n+            if (t == null) {\n+                nullFound = true;\n+                continue;\n+            }\n+            if (nullFound) {\n+                if (!(t instanceof String)) {\n+                    throw new IllegalArgumentException(\"notNull method requires pairs of argument + message\");\n+                }\n+                throw new IllegalArgumentException(((String) t).concat(\" cannot be null.\"));\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/util/InputOutput.java\n+package org.mockito.release.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+/**\n+ * Utility for input/output\n+ */\n+public class InputOutput {\n+\n+    /**\n+     * Closes input, does nothing when input is null\n+     */\n+    public static void closeStream(Closeable closable) {\n+        if (closable != null) {\n+            try {\n+                closable.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Problems closing stream.\", e);\n+            }\n+        }\n+    }\n+}\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n     }\n \n     /**\n-     * An answer that directly forwards the calls to the delegate.\n+     * An answer that directly forwards the calls to the delegate. The delegate may or may not be of the same type as the mock.\n+     * If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.\n      * <p>\n      * Useful for spies or partial mocks of objects that are difficult to mock\n      * or spy using the usual spy API. Possible use cases:\n      *   doReturn(\"foo\").when(listWithDelegate).get(0);\n      * </code></pre>\n      *\n-     * @param delegate The delegate to forward calls to.\n+     * @param delegate The delegate to forward calls to. It does not have to be of the same type as the mock (although it usually is).\n+     *                 The only requirement is that the instance should have compatible method signatures including the return values.\n+     *                 Only the methods that were actually executed on the mock need to be present on the delegate type.\n      * @return the answer\n      *\n      * @since 1.9.5\n--- a/src/org/mockito/Incubating.java\n+++ b/src/org/mockito/Incubating.java\n  * The annotation conveys following information:\n  * <ul>\n  * <li>The API is fairly new and we would appreciate your feedback. For example, what are you missing from the API\n- * to solve your use case (yes, please, real use cases).</li>\n- * <li>For types or methods that are already released this annotation means that that the API might change.\n- * The chance for that is small and we will always try to make any changes in a backwards compatible way.\n- * The only reason we would want to change it is to provide better support for using and extending Mockito.\n+ * to solve your use case.</li>\n+ * <li>The API might change.\n+ * The chance for that is small because we care great deal for the initial design.\n+ * The incubating API might change based on the feedback from the community in order to make the API most useful for the users.\n  * </li>\n  * <li>\n  * For types or methods that are not yet released it means the API is <strong>work in progress</strong>\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n      *\n      * @param mode serialization mode\n      * @return settings instance so that you can fluently specify other settings\n-     * @since 1.9.8\n+     * @since 1.10.0\n      */\n     MockSettings serializable(SerializableMode mode);\n \n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings stubOnly();\n+\n+    /**\n+     * Mockito attempts to use constructor when creating instance of the mock.\n+     * This is particularly useful for spying on abstract classes. See also {@link Mockito#spy(Class)}.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * //Robust API, via settings builder:\n+     * OtherAbstract spy = mock(OtherAbstract.class, withSettings()\n+     *   .useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+     *\n+     * //Mocking a non-static inner abstract class:\n+     * InnerAbstract spy = mock(InnerAbstract.class, withSettings()\n+     *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     * @since 1.10.12\n+     */\n+    @Incubating\n+    MockSettings useConstructor();\n+\n+    /**\n+     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor()}.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * InnerClass mock = mock(InnerClass.class, withSettings()\n+     *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     * @since 1.10.12\n+     */\n+    @Incubating\n+    MockSettings outerInstance(Object outerClassInstance);\n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;\n import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.junit.MockitoJUnitRule;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockito.stubbing.*;\n import org.mockito.verification.After;\n  *      <a href=\"#26\">26. Mocking details (Since 1.9.5)</a><br/>\n  *      <a href=\"#27\">27. Delegate calls to real instance (Since 1.9.5)</a><br/>\n  *      <a href=\"#28\">28. <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n- *      <a href=\"#29\">29. BDD style verification (Since 1.9.8)</a><br/>\n+ *      <a href=\"#29\">29. (new) BDD style verification (Since 1.10.0)</a><br/>\n+ *      <a href=\"#30\">30. (new) Spying or mocking abstract classes (Since 1.10.12)</a><br/>\n  * </b>\n  *\n  * <p>\n  * MockitoAnnotations.initMocks(testClass);\n  * </code></pre>\n  *\n- * You can use built-in runner: {@link MockitoJUnitRunner}.\n+ * You can use built-in runner: {@link MockitoJUnitRunner} or a rule: {@link MockitoJUnitRule}.\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n  *\n  *\n  * <p>\n  * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.\n- * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner}.\n+ * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner} or rule:\n+ * {@link MockitoJUnitRule}.\n  * <p>\n  *\n  *\n  * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields\n  * using <b>constructor</b> injection, <b>setter</b> injection, or <b>field</b> injection.\n  * <p>\n- * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)} or {@link MockitoJUnitRunner}.\n+ * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)}, {@link MockitoJUnitRunner}\n+ * or {@link MockitoJUnitRule}.\n  * <p>\n  * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}\n  * <pre class=\"code\"><code class=\"java\">\n  * <h3 id=\"27\">27. <a class=\"meaningful_link\" href=\"#delegating_call_to_real_instance\">Delegate calls to real instance</a> (Since 1.9.5)</h3>\n  *\n  * <p>Useful for spies or partial mocks of objects <strong>that are difficult to mock or spy</strong> using the usual spy API.\n- * Possible use cases:\n+ * Since Mockito 1.10.11, the delegate may or may not be of the same type as the mock.\n+ * If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.\n+ *\n+ * Possible use cases for this feature:\n  * <ul>\n  *     <li>Final classes but with an interface</li>\n  *     <li>Already custom proxied object</li>\n  *\n  *\n  *\n- * <h3 id=\"29\">29. <a class=\"meaningful_link\" href=\"#BDD_behavior_verification\">BDD style verification</a> (Since 1.9.8)</h3>\n+ * <h3 id=\"29\">29. <a class=\"meaningful_link\" href=\"#BDD_behavior_verification\">(new) BDD style verification</a> (Since 1.10.0)</h3>\n  *\n  * Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD <b>then</b> keyword.\n  *\n  * For more information and an example see {@link BDDMockito}.\n+ *\n+ *\n+ *\n+ * <h3 id=\"30\">30. <a class=\"meaningful_link\" href=\"#spying_abstract_classes\">(new) Spying or mocking abstract classes (Since 1.10.12)</a></h3>\n+ *\n+ * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).\n+ * <p>\n+ * Previously, spying was only possible on instances of objects.\n+ * New API makes it possible to use constructor when creating an instance of the mock.\n+ * This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class.\n+ * At the moment, only parameter-less constructor is supported, let us know if it is not enough.\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   //convenience API, new overloaded spy() method:\n+ *   SomeAbstract spy = spy(SomeAbstract.class);\n+ *\n+ *   //Robust API, via settings builder:\n+ *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()\n+ *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+ *\n+ *   //Mocking a non-static inner abstract class:\n+ *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()\n+ *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+ * </code></pre>\n+ *\n+ * For more information please see {@link MockSettings#useConstructor()}.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     }\n \n     /**\n+     * Please refer to the documentation of {@link #spy(Object)}.\n+     * Overusing spies hints at code design smells.\n+     * <p>\n+     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.\n+     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.\n+     * This is particularly useful for spying on abstract classes because they cannot be instantiated.\n+     * See also {@link MockSettings#useConstructor()}.\n+     * <p>\n+     * Examples:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   SomeAbstract spy = spy(SomeAbstract.class);\n+     *\n+     *   //Robust API, via settings builder:\n+     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings()\n+     *      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+     *\n+     *   //Mocking a non-static inner abstract class:\n+     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings()\n+     *      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+     * </code></pre>\n+     *\n+     * @param classToSpy the class to spy\n+     * @param <T> type of the spy\n+     * @return a spy of the provided class\n+     * @since 1.10.12\n+     */\n+    @Incubating\n+    public static <T> T spy(Class<T> classToSpy) {\n+        return MOCKITO_CORE.mock(classToSpy, withSettings()\n+                .useConstructor()\n+                .defaultAnswer(CALLS_REAL_METHODS));\n+    }\n+\n+    /**\n      * Stubs a method call with return value or an exception. E.g:\n      *\n      * <pre class=\"code\"><code class=\"java\">\n      * <p>\n      * Examples of incorrect use:\n      * <pre class=\"code\"><code class=\"java\">\n-     * //Oops, someone forgot thenReturn() part:\n+     * //Oops, thenReturn() part is missing:\n      * when(mock.get());\n      *\n-     * //Oops, someone put the verified method call inside verify() where it should be outside:\n+     * //Oops, verified method call is inside verify() where it should be on the outside:\n      * verify(mock.execute());\n      *\n-     * //Oops, someone has used EasyMock for too long and forgot to specify the method to verify:\n+     * //Oops, missing method to verify:\n      * verify(mock);\n      * </code></pre>\n      *\n      * For example, one of the users wanted to put <code>validateMockitoUsage()</code> in his <code>&#064;After</code> method\n      * so that he knows immediately when he misused Mockito.\n      * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.\n-     * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner will always fail in the test method with defect\n+     * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner and rule will always fail in the test method with defect\n      * whereas ordinary 'next-time' validation might fail the <b>next</b> test method.\n      * But even though JUnit might report next test as red, don't worry about it\n      * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.\n      * <p>\n-     * <b>Built-in runner: {@link MockitoJUnitRunner}</b> does validateMockitoUsage() after each test method.\n+     * <b>Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoJUnitRule}</b> do validateMockitoUsage() after each test method.\n      * <p>\n      * Bear in mind that <b>usually you don't have to <code>validateMockitoUsage()</code></b>\n      * and framework validation triggered on next-time basis should be just enough,\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.invocation.Location;\n import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.SerializableMode;\n \n import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n                 \"\"\n         ));\n     }\n+    \n+    public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {\n+    \tthrow new MockitoException(join(\n+    \t        \"Methods called on delegated instance must have compatible return types with the mock.\",\n+    \t        \"When calling: \" + mockMethod + \" on mock: \" + new MockUtil().getMockName(mock),\n+    \t        \"return type should be: \" + mockMethod.getReturnType().getSimpleName() + \", but was: \" + delegateMethod.getReturnType().getSimpleName(),\n+    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n+    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n+    \t));\n+    }\n+\n+\tpublic void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {\n+\t\tthrow new MockitoException(join(\n+    \t        \"Methods called on mock must exist in delegated instance.\",\n+    \t        \"When calling: \" + mockMethod + \" on mock: \" + new MockUtil().getMockName(mock),\n+    \t        \"no such method was found.\",\n+    \t        \"Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods\",\n+    \t        \"(delegate instance had type: \" + delegate.getClass().getSimpleName() + \")\"\n+    \t));\n+\t}\n+\n+    public void usingConstructorWithFancySerializable(SerializableMode mode) {\n+        throw new MockitoException(\"Mocks instantiated with constructor cannot be combined with \" + mode + \" serialization mode.\");\n+    }\n }\n--- a/src/org/mockito/exceptions/base/MockitoSerializationIssue.java\n+++ b/src/org/mockito/exceptions/base/MockitoSerializationIssue.java\n  *     However note that other calls related to the stackTrace will refer to the filter stacktrace.\n  * </p>\n  *\n- * @since 1.9.6\n+ * @since 1.10.0\n  */\n public class MockitoSerializationIssue extends ObjectStreamException {\n \n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n  */\n public class ClassPathLoader {\n     private static final String DEFAULT_MOCK_MAKER_CLASS =\n-            \"org.mockito.internal.creation.CglibMockMaker\";\n+            \"org.mockito.internal.creation.cglib.CglibMockMaker\";\n     private static final String DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS =\n             \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\";\n     public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n     /**\n      * Returns the implementation of the mock maker available for the current runtime.\n      *\n-     * <p>Returns {@link org.mockito.internal.creation.CglibMockMaker} if no\n+     * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n      * {@link MockMaker} extension exists or is visible in the current classpath.</p>\n      */\n     public static MockMaker getMockMaker() {\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSettings, MockCreationSettings<T> {\n \n     private static final long serialVersionUID = 4475297236197939569L;\n+    private boolean useConstructor;\n+    private Object outerClassInstance;\n \n     public MockSettings serializable() {\n         return serializable(SerializableMode.BASIC);\n         return this;\n     }\n \n+    public MockSettings useConstructor() {\n+        this.useConstructor = true;\n+        return this;\n+    }\n+\n+    public MockSettings outerInstance(Object outerClassInstance) {\n+        this.outerClassInstance = outerClassInstance;\n+        return this;\n+    }\n+\n+    public boolean isUsingConstructor() {\n+        return useConstructor;\n+    }\n+\n+    public Object getOuterClassInstance() {\n+        return outerClassInstance;\n+    }\n+\n     public boolean isStubOnly() {\n         return this.stubOnly;\n     }\n //        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n \n         validator.validateSerializable(typeToMock, source.isSerializable());\n+        validator.validateConstructorUse(source.isUsingConstructor(), source.getSerializableMode());\n \n+        //TODO SF - I don't think we really need CreationSettings type\n         CreationSettings<T> settings = new CreationSettings<T>(source);\n         settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n         settings.setTypeToMock(typeToMock);\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoSerializationIssue;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+import org.mockito.mock.SerializableMode;\n+\n+import java.io.*;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n+\n+/**\n+ * This is responsible for serializing a mock, it is enabled if the mock is implementing\n+ * {@link Serializable}.\n+ *\n+ * <p>\n+ *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},\n+ *     if the mock settings is set to be serializable it will add the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable}\n+ *     interface.\n+ *     This interface defines a the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n+ *     whose signature match the one that is looked by the standard Java serialization.\n+ * </p>\n+ *\n+ * <p>\n+ *     Then in the {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter} of mockito, if the <code>writeReplace</code> method is called,\n+ *     it will use the custom implementation of this class {@link #writeReplace(Object)}. This method has a specific\n+ *     knowledge on how to serialize a mockito mock that is based on CGLIB.\n+ * </p>\n+ *\n+ * <p><strong>Only one instance per mock! See {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter}</strong></p>\n+ *\n+ * TODO use a proper way to add the interface\n+ * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n+ * TODO check the class is mockable in the deserialization side\n+ *\n+ * @see org.mockito.internal.creation.cglib.CglibMockMaker\n+ * @see org.mockito.internal.creation.cglib.MethodInterceptorFilter\n+ * @author Brice Dutheil\n+ * @since 1.10.0\n+ */\n+@Incubating\n+class AcrossJVMSerializationFeature implements Serializable {\n+    private static final long serialVersionUID = 7411152578314420778L;\n+    private static final String MOCKITO_PROXY_MARKER = \"MockitoProxyMarker\";\n+    private boolean instanceLocalCurrentlySerializingFlag = false;\n+    private final Lock mutex = new ReentrantLock();\n+\n+    public boolean isWriteReplace(Method method) {\n+        return  method.getReturnType() == Object.class\n+                && method.getParameterTypes().length == 0\n+                && method.getName().equals(\"writeReplace\");\n+    }\n+\n+\n+    /**\n+     * Custom implementation of the <code>writeReplace</code> method for serialization.\n+     *\n+     * Here's how it's working and why :\n+     * <ol>\n+     *     <li>\n+     *         <p>When first entering in this method, it's because some is serializing the mock, with some code like :\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     objectOutputStream.writeObject(mock);\n+     * </code></pre>\n+     *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and\n+     *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.\n+     *         At this point, the code will return an\n+     *         {@link AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy}.</p>\n+     *     </li>\n+     *     <li>\n+     *         <p>Now, in the constructor\n+     *         {@link AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n+     *         the mock is being serialized in a custom way (using\n+     *         {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream}) to a\n+     *         byte array. So basically it means the code is performing double nested serialization of the passed\n+     *         <code>mockitoMock</code>.</p>\n+     *\n+     *         <p>However the <code>ObjectOutputStream</code> will still detect the custom\n+     *         <code>writeReplace</code> and execute it.\n+     *         <em>(For that matter disabling replacement via {@link ObjectOutputStream#enableReplaceObject(boolean)}\n+     *         doesn't disable the <code>writeReplace</code> call, but just just toggle replacement in the\n+     *         written stream, <strong><code>writeReplace</code> is always called by\n+     *         <code>ObjectOutputStream</code></strong>.)</em></p>\n+     *\n+     *         <p>In order to avoid this recursion, obviously leading to a {@link StackOverflowError}, this method is using\n+     *         a flag that marks the mock as already being replaced, and then shouldn't replace itself again.\n+     *         <strong>This flag is local to this class</strong>, which means the flag of this class unfortunately needs\n+     *         to be protected against concurrent access, hence the reentrant lock.</p>\n+     *     </li>\n+     * </ol>\n+     *\n+     *\n+     * @param mockitoMock The Mockito mock to be serialized.\n+     * @return A wrapper ({@link AcrossJVMMockSerializationProxy}) to be serialized by the calling ObjectOutputStream.\n+     * @throws ObjectStreamException\n+     */\n+    public Object writeReplace(Object mockitoMock) throws ObjectStreamException {\n+        try {\n+            // reentrant lock for critical section. could it be improved ?\n+            mutex.lock();\n+            // mark started flag // per thread, not per instance\n+            // temporary loosy hack to avoid stackoverflow\n+            if(mockIsCurrentlyBeingReplaced()) {\n+                return mockitoMock;\n+            }\n+            mockReplacementStarted();\n+\n+            return new AcrossJVMMockSerializationProxy(mockitoMock);\n+        } catch (IOException ioe) {\n+            MockUtil mockUtil = new MockUtil();\n+            MockName mockName = mockUtil.getMockName(mockitoMock);\n+            String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();\n+            throw new MockitoSerializationIssue(join(\n+                    \"The mock '\" + mockName + \"' of type '\" + mockedType + \"'\",\n+                    \"The Java Standard Serialization reported an '\" + ioe.getClass().getSimpleName() + \"' saying :\",\n+                    \"  \" + ioe.getMessage()\n+            ), ioe);\n+        } finally {\n+            // unmark\n+            mockReplacementCompleted();\n+            mutex.unlock();\n+        }\n+    }\n+\n+\n+    private void mockReplacementCompleted() {\n+        instanceLocalCurrentlySerializingFlag = false;\n+    }\n+\n+\n+    private void mockReplacementStarted() {\n+        instanceLocalCurrentlySerializingFlag = true;\n+    }\n+\n+\n+    private boolean mockIsCurrentlyBeingReplaced() {\n+        return instanceLocalCurrentlySerializingFlag;\n+    }\n+\n+\n+    /**\n+     * Enable serialization serialization that will work across classloaders / and JVM.\n+     *\n+     * <p>Only enable if settings says the mock should be serializable. In this case add the\n+     * {@link AcrossJVMMockitoMockSerializable} to the extra interface list.</p>\n+     *\n+     * @param settings Mock creation settings.\n+     * @param <T> Type param to not be bothered by the generics\n+     */\n+    public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {\n+        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n+            // havin faith that this set is modifiable\n+            // TODO use a proper way to add the interface\n+            settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerializable.class);\n+        }\n+    }\n+\n+\n+    /**\n+     * This is the serialization proxy that will encapsulate the real mock data as a byte array.\n+     *\n+     * <p>When called in the constructor it will serialize the mock in a byte array using a\n+     * custom {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream} that\n+     * will annotate the mock class in the stream.\n+     * Other information are used in this class in order to facilitate deserialization.\n+     * </p>\n+     *\n+     * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via\n+     * the custom {@link MockitoMockObjectInputStream} that will be in charge of creating the mock class.</p>\n+     */\n+    public static class AcrossJVMMockSerializationProxy implements Serializable {\n+\n+\n+        private static final long serialVersionUID = -7600267929109286514L;\n+        private final byte[] serializedMock;\n+        private final Class typeToMock;\n+        private final Set<Class> extraInterfaces;\n+        /**\n+         * Creates the wrapper that be used in the serialization stream.\n+         *\n+         * <p>Immediately serializes the Mockito mock using specifically crafted\n+         * {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream},\n+         * in a byte array.</p>\n+         *\n+         * @param mockitoMock The Mockito mock to serialize.\n+         * @throws IOException\n+         */\n+        public AcrossJVMMockSerializationProxy(Object mockitoMock) throws IOException {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);\n+\n+            objectOutputStream.writeObject(mockitoMock);\n+\n+            objectOutputStream.close();\n+            out.close();\n+\n+            MockCreationSettings mockSettings = new MockUtil().getMockSettings(mockitoMock);\n+            this.serializedMock = out.toByteArray();\n+            this.typeToMock = mockSettings.getTypeToMock();\n+            this.extraInterfaces = mockSettings.getExtraInterfaces();\n+        }\n+\n+        /**\n+         * Resolves the proxy to a new deserialized instance of the Mockito mock.\n+         *\n+         * <p>Uses the custom crafted {@link MockitoMockObjectInputStream} to deserialize the mock.</p>\n+         *\n+         * @return A deserialized instance of the Mockito mock.\n+         * @throws ObjectStreamException\n+         */\n+        private Object readResolve() throws ObjectStreamException {\n+            try {\n+                ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);\n+                ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);\n+\n+                Object deserializedMock = objectInputStream.readObject();\n+\n+                bis.close();\n+                objectInputStream.close();\n+\n+                return deserializedMock;\n+            } catch (IOException ioe) {\n+                throw new MockitoSerializationIssue(join(\n+                        \"Mockito mock cannot be deserialized to a mock of '\" + typeToMock.getCanonicalName() + \"'. The error was :\",\n+                        \"  \" + ioe.getMessage(),\n+                        \"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), ioe);\n+            } catch (ClassNotFoundException cce) {\n+                throw new MockitoSerializationIssue(join(\n+                        \"A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :\",\n+                        \"  \" + cce.getMessage(),\n+                        \"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), cce);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectInputStream</code> that will resolve the Mockito proxy class.\n+     *\n+     * <p>\n+     *     This specificaly crafted ObjectInoutStream has the most important role to resolve the Mockito generated\n+     *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream\n+     *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it\n+     *     delegates class resolution to the default super behavior.\n+     *     The mirror method used for serializing the mock is\n+     *     {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream#annotateClass(Class)}.\n+     * </p>\n+     *\n+     * <p>\n+     *     When this marker is found, {@link org.mockito.internal.creation.cglib.ClassImposterizer} methods are being used to create the mock class.\n+     *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the\n+     *     {@link org.mockito.internal.creation.util.SearchingClassLoader} that will look if this enhanced class has\n+     *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer\n+     *     code.</em>\n+     * </p>\n+     */\n+    public static class MockitoMockObjectInputStream extends ObjectInputStream {\n+        private final Class typeToMock;\n+        private final Set<Class> extraInterfaces;\n+\n+        public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {\n+            super(in) ;\n+            this.typeToMock = typeToMock;\n+            this.extraInterfaces = extraInterfaces;\n+            enableResolveObject(true); // ensure resolving is enabled\n+        }\n+\n+        /**\n+         * Resolve the Mockito proxy class if it is marked as such.\n+         *\n+         * <p>Uses the fields {@link #typeToMock} and {@link #extraInterfaces} to\n+         * create the Mockito proxy class as the <code>ObjectStreamClass</code>\n+         * doesn't carry useful information for this purpose.</p>\n+         *\n+         * @param desc Description of the class in the stream, not used.\n+         * @return The class that will be used to deserialize the instance mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+            if (notMarkedAsAMockitoMock(readObject())) {\n+                return super.resolveClass(desc);\n+            }\n+\n+            // TODO check the class is mockable in the deserialization side\n+            // ClassImposterizer.INSTANCE.canImposterise(typeToMock);\n+\n+            // create the Mockito mock class before it can even be deserialized\n+            //TODO SF unify creation of imposterizer, constructor code duplicated, pulling in CreationSettings internal class\n+            ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator(new CreationSettings()));\n+            imposterizer.setConstructorsAccessible(typeToMock, true);\n+            Class<?> proxyClass = imposterizer.createProxyClass(\n+                    typeToMock,\n+                    extraInterfaces.toArray(new Class[extraInterfaces.size()])\n+            );\n+\n+            hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);\n+\n+            return proxyClass;\n+\n+        }\n+\n+        /**\n+         * Hack the <code>name</code> field of the given <code>ObjectStreamClass</code> with\n+         * the <code>newProxyClass</code>.\n+         *\n+         * The parent ObjectInputStream will check the name of the class in the stream matches the name of the one\n+         * that is created in this method.\n+         *\n+         * The CGLIB classes uses a hash of the classloader and/or maybe some other data that allow them to be\n+         * relatively unique in a JVM.\n+         *\n+         * When names differ, which happens when the mock is deserialized in another ClassLoader, a\n+         * <code>java.io.InvalidObjectException</code> is thrown, so this part of the code is hacking through\n+         * the given <code>ObjectStreamClass</code> to change the name with the newly created class.\n+         *\n+         * @param descInstance The <code>ObjectStreamClass</code> that will be hacked.\n+         * @param proxyClass The proxy class whose name will be applied.\n+         * @throws InvalidObjectException\n+         */\n+        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {\n+            try {\n+              Field classNameField = descInstance.getClass().getDeclaredField(\"name\");\n+              new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());\n+            } catch (NoSuchFieldException nsfe) {\n+                // TODO use our own mockito mock serialization exception\n+                throw new MockitoSerializationIssue(join(\n+                        \"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',\",\n+                        \"this is definitely a bug in our code as it means the JDK team changed a few internal things.\",\n+                        \"\",\n+                        \"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome.\"\n+                ), nsfe);\n+            }\n+        }\n+\n+        /**\n+         * Read the stream class annotation and identify it as a Mockito mock or not.\n+         *\n+         * @param marker The marker to identify.\n+         * @return <code>true</code> if not marked as a Mockito, <code>false</code> if the class annotation marks a Mockito mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {\n+            return !MOCKITO_PROXY_MARKER.equals(marker);\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectOutputStream</code>.\n+     *\n+     * <p>\n+     *     This output stream has the role of marking in the stream the Mockito class. This\n+     *     marking process is necessary to identify the proxy class that will need to be recreated.\n+     *\n+     *     The mirror method used for deserializing the mock is\n+     *     {@link MockitoMockObjectInputStream#resolveClass(ObjectStreamClass)}.\n+     * </p>\n+     *\n+     */\n+    private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n+        private static final String NOTHING = \"\";\n+\n+        public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n+            super(out);\n+        }\n+\n+        /**\n+         * Annotates (marks) the class if this class is a Mockito mock.\n+         *\n+         * @param cl The class to annotate.\n+         * @throws IOException\n+         */\n+        @Override\n+        protected void annotateClass(Class<?> cl) throws IOException {\n+            writeObject(mockitoProxyClassMarker(cl));\n+            // might be also useful later, for embedding classloader info ...maybe ...maybe not\n+        }\n+\n+        /**\n+         * Returns the Mockito marker if this class is a Mockito mock.\n+         *\n+         * @param cl The class to mark.\n+         * @return The marker if this is a Mockito proxy class, otherwise returns a void marker.\n+         */\n+        private String mockitoProxyClassMarker(Class<?> cl) {\n+            if (AcrossJVMMockitoMockSerializable.class.isAssignableFrom(cl)) {\n+                return MOCKITO_PROXY_MARKER;\n+            } else {\n+                return NOTHING;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an\n+     * <code>ObjectOutputStream</code>.\n+     *\n+     * It will be applied before the creation of the mock when the mock setting says it should serializable.\n+     *\n+     * @see #enableSerializationAcrossJVM(org.mockito.mock.MockCreationSettings)\n+     */\n+    public interface AcrossJVMMockitoMockSerializable {\n+        public Object writeReplace() throws java.io.ObjectStreamException;\n+    }\n+}\n--- a/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n+++ b/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n \n import java.io.Serializable;\n import java.lang.reflect.Field;\n \n-import org.mockito.internal.creation.MockitoMethodProxy;\n-import org.mockito.cglib.proxy.MethodProxy;\n+class CGLIBHacker {\n \n-public class CGLIBHacker implements Serializable {\n-\n-    private static final long serialVersionUID = -4389233991416356668L;\n-\n-    public void setMockitoNamingPolicy(MockitoMethodProxy mockitoMethodProxy) {\n+    public void setMockitoNamingPolicy(MethodProxy methodProxy) {\n         try {\n-            MethodProxy methodProxy = mockitoMethodProxy.getMethodProxy();\n             Field createInfoField = reflectOnCreateInfo(methodProxy);\n             createInfoField.setAccessible(true);\n             Object createInfo = createInfoField.get(methodProxy);\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/CglibMockMaker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.plugins.MockMaker;\n+\n+/**\n+ * A MockMaker that uses cglib to generate mocks on a JVM.\n+ */\n+public final class CglibMockMaker implements MockMaker {\n+\n+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n+        InternalMockHandler mockitoHandler = cast(handler);\n+        new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);\n+        return new ClassImposterizer(new InstantiatorProvider().getInstantiator(settings)).imposterise(\n+                new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n+    }\n+\n+    private InternalMockHandler cast(MockHandler handler) {\n+        if (!(handler instanceof InternalMockHandler)) {\n+            throw new MockitoException(\"At the moment you cannot provide own implementations of MockHandler.\" +\n+                    \"\\nPlease see the javadocs for the MockMaker interface.\");\n+        }\n+        return (InternalMockHandler) handler;\n+    }\n+\n+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n+        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));\n+    }\n+\n+    public MockHandler getHandler(Object mock) {\n+        if (!(mock instanceof Factory)) {\n+            return null;\n+        }\n+        Factory factory = (Factory) mock;\n+        Callback callback = factory.getCallback(0);\n+        if (!(callback instanceof MethodInterceptorFilter)) {\n+            return null;\n+        }\n+        return ((MethodInterceptorFilter) callback).getHandler();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/ClassImposterizer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.core.CodeGenerationException;\n+import org.mockito.cglib.core.NamingPolicy;\n+import org.mockito.cglib.core.Predicate;\n+import org.mockito.cglib.proxy.*;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.instance.InstantationException;\n+import org.mockito.internal.creation.instance.Instantiator;\n+import org.mockito.internal.creation.util.SearchingClassLoader;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n+\n+/**\n+ * Inspired on jMock (thanks jMock guys!!!)\n+ */\n+class ClassImposterizer {\n+\n+    private final Instantiator instantiator;\n+\n+    public ClassImposterizer(Instantiator instantiator) {\n+        this.instantiator = instantiator;\n+    }\n+    \n+    private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {\n+        @Override\n+        public String getClassName(String prefix, String source, Object key, Predicate names) {\n+            return \"codegen.\" + super.getClassName(prefix, source, key, names);\n+        }\n+    };\n+    \n+    private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {\n+        public int accept(Method method) {\n+            return method.isBridge() ? 1 : 0;\n+        }\n+    };\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n+        return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n+    }\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n+        Class<Factory> proxyClass = null;\n+        Object proxyInstance = null;\n+        try {\n+            setConstructorsAccessible(mockedType, true);\n+            proxyClass = createProxyClass(mockedType, ancillaryTypes);\n+            proxyInstance = createProxy(proxyClass, interceptor);\n+            return mockedType.cast(proxyInstance);\n+        } catch (ClassCastException cce) {\n+            throw new MockitoException(join(\n+                \"ClassCastException occurred while creating the mockito proxy :\",\n+                \"  class to mock : \" + describeClass(mockedType),\n+                \"  created class : \" + describeClass(proxyClass),\n+                \"  proxy instance class : \" + describeClass(proxyInstance),\n+                \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n+                \"\",\n+                \"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)\"\n+            ), cce);\n+        } finally {\n+            setConstructorsAccessible(mockedType, false);\n+        }\n+    }\n+\n+    private static String describeClass(Class type) {\n+        return type == null? \"null\" : \"'\" + type.getCanonicalName() + \"', loaded by classloader : '\" + type.getClassLoader() + \"'\";\n+    }\n+\n+    private static String describeClass(Object instance) {\n+        return instance == null? \"null\" : describeClass(instance.getClass());\n+    }\n+\n+    //TODO this method does not belong here\n+    public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n+        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n+            constructor.setAccessible(accessible);\n+        }\n+    }\n+    \n+    public Class<Factory> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {\n+        if (mockedType == Object.class) {\n+            mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n+        }\n+        \n+        Enhancer enhancer = new Enhancer() {\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            protected void filterConstructors(Class sc, List constructors) {\n+                // Don't filter\n+            }\n+        };\n+        Class<?>[] allMockedTypes = prepend(mockedType, interfaces);\n+\t\tenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));\n+        enhancer.setUseFactory(true);\n+        if (mockedType.isInterface()) {\n+            enhancer.setSuperclass(Object.class);\n+            enhancer.setInterfaces(allMockedTypes);\n+        } else {\n+            enhancer.setSuperclass(mockedType);\n+            enhancer.setInterfaces(interfaces);\n+        }\n+        enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\n+        enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\n+        if (mockedType.getSigners() != null) {\n+            enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);\n+        } else {\n+            enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\n+        }\n+\n+        enhancer.setSerialVersionUID(42L);\n+        \n+        try {\n+            return enhancer.createClass(); \n+        } catch (CodeGenerationException e) {\n+            if (Modifier.isPrivate(mockedType.getModifiers())) {\n+                throw new MockitoException(\"\\n\"\n+                        + \"Mockito cannot mock this class: \" + mockedType \n+                        + \".\\n\"\n+                        + \"Most likely it is a private class that is not visible by Mockito\");\n+            }\n+            throw new MockitoException(\"\\n\"\n+                    + \"Mockito cannot mock this class: \" + mockedType \n+                    + \"\\n\" \n+                    + \"Mockito can only mock visible & non-final classes.\"\n+                    + \"\\n\" \n+                    + \"If you're not sure why you're getting this error, please report to the mailing list.\", e);\n+        }\n+    }\n+    \n+    private Object createProxy(Class<Factory> proxyClass, final MethodInterceptor interceptor) {\n+        Factory proxy;\n+        try {\n+            proxy = instantiator.newInstance(proxyClass);\n+        } catch (InstantationException e) {\n+            throw new MockitoException(\"Unable to create mock instance of type '\" + proxyClass.getSuperclass().getSimpleName() + \"'\", e);\n+        }\n+        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n+        return proxy;\n+    }\n+    \n+    private Class<?>[] prepend(Class<?> first, Class<?>... rest) {\n+        Class<?>[] all = new Class<?>[rest.length+1];\n+        all[0] = first;\n+        System.arraycopy(rest, 0, all, 1, rest.length);\n+        return all;\n+    }\n+    \n+    public static class ClassWithSuperclassToWorkAroundCglibBug {}\n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+\n+class DelegatingMockitoMethodProxy implements MockitoMethodProxy {\n+\n+    private final MethodProxy methodProxy;\n+\n+    public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {\n+        return methodProxy.invokeSuper(target, arguments);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n+import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod;\n+import org.mockito.internal.progress.SequenceNumber;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Should be one instance per mock instance, see CglibMockMaker.\n+ */\n+class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n+\n+    private static final long serialVersionUID = 6182795666612683784L;\n+    private final InternalMockHandler handler;\n+    final ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n+    private final MockCreationSettings mockSettings;\n+    private final AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();\n+\n+    public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {\n+        this.handler = handler;\n+        this.mockSettings = mockSettings;\n+    }\n+\n+    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n+            throws Throwable {\n+        if (objectMethodsGuru.isEqualsMethod(method)) {\n+            return proxy == args[0];\n+        } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n+            return hashCodeForMock(proxy);\n+        } else if (acrossJVMSerializationFeature.isWriteReplace(method)) {\n+            return acrossJVMSerializationFeature.writeReplace(proxy);\n+        }\n+        \n+        MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n+        new CGLIBHacker().setMockitoNamingPolicy(methodProxy);\n+        \n+        MockitoMethod mockitoMethod = createMockitoMethod(method);\n+        \n+        CleanTraceRealMethod realMethod = new CleanTraceRealMethod(mockitoMethodProxy);\n+        Invocation invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n+        return handler.handle(invocation);\n+    }\n+   \n+    public MockHandler getHandler() {\n+        return handler;\n+    }\n+\n+    private int hashCodeForMock(Object mock) {\n+        return System.identityHashCode(mock);\n+    }\n+\n+    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n+        if (mockSettings.isSerializable())\n+            return new SerializableMockitoMethodProxy(methodProxy);\n+        return new DelegatingMockitoMethodProxy(methodProxy);\n+    }\n+    \n+    public MockitoMethod createMockitoMethod(Method method) {\n+        if (mockSettings.isSerializable()) {\n+            return new SerializableMethod(method);\n+        } else {\n+            return new DelegatingMethod(method);\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java\n+++ b/src/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n \n import org.mockito.cglib.core.DefaultNamingPolicy;\n \n-public class MockitoNamingPolicy extends DefaultNamingPolicy {\n+class MockitoNamingPolicy extends DefaultNamingPolicy {\n     \n     public static final MockitoNamingPolicy INSTANCE = new MockitoNamingPolicy(); \n     \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+import org.mockito.internal.util.reflection.Whitebox;\n+\n+import java.io.Serializable;\n+\n+class SerializableMockitoMethodProxy implements MockitoMethodProxy, Serializable {\n+\n+    private static final long serialVersionUID = -5337859962876770632L;\n+    private final Class<?> c1;\n+    private final Class<?> c2;\n+    private final String desc;\n+    private final String name;\n+    private final String superName;\n+    transient MethodProxy methodProxy;\n+\n+    public SerializableMockitoMethodProxy(MethodProxy methodProxy) {\n+        assert methodProxy != null;\n+        Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        c1 = (Class<?>) Whitebox.getInternalState(info, \"c1\");\n+        c2 = (Class<?>) Whitebox.getInternalState(info, \"c2\");\n+        desc = methodProxy.getSignature().getDescriptor();\n+        name = methodProxy.getSignature().getName();\n+        superName = methodProxy.getSuperName();\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    private MethodProxy getMethodProxy() {\n+        if (methodProxy == null) {\n+            methodProxy = MethodProxy.create(c1, c2, desc, name, superName);\n+        }\n+        return methodProxy;\n+    }\n+\n+    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {\n+        return getMethodProxy().invokeSuper(target, arguments);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/SerializableNoOp.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.NoOp;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Offer a Serializable implementation of the NoOp CGLIB callback.\n+ */\n+class SerializableNoOp implements NoOp, Serializable {\n+\n+    private static final long serialVersionUID = 7434976328690189159L;\n+    public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n+package org.mockito.internal.creation.instance;\n+\n+import java.lang.reflect.Constructor;\n+\n+public class ConstructorInstantiator implements Instantiator {\n+\n+    private final Object outerClassInstance;\n+\n+    public ConstructorInstantiator(Object outerClassInstance) {\n+        this.outerClassInstance = outerClassInstance;\n+    }\n+\n+    public <T> T newInstance(Class<T> cls) {\n+        if (outerClassInstance == null) {\n+            return noArgConstructor(cls);\n+        }\n+        return withParams(cls, outerClassInstance);\n+    }\n+\n+    private static <T> T withParams(Class<T> cls, Object... params) {\n+        try {\n+            //this is kind of overengineered because we don't need to support more params\n+            //however, I know we will be needing it :)\n+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\n+                Class<?>[] types = constructor.getParameterTypes();\n+                if (paramsMatch(types, params)) {\n+                    return (T) constructor.newInstance(params);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw paramsException(cls, e);\n+        }\n+        throw paramsException(cls, null);\n+    }\n+\n+    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n+        return new InstantationException(\"Unable to create mock instance of '\"\n+                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n+    }\n+\n+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n+        if (params.length != types.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < params.length; i++) {\n+            if (!types[i].isInstance(params[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static <T> T noArgConstructor(Class<T> cls) {\n+        try {\n+            return cls.newInstance();\n+        } catch (Exception e) {\n+            throw new InstantationException(\"Unable to create mock instance of '\"\n+                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/instance/InstantationException.java\n+package org.mockito.internal.creation.instance;\n+\n+public class InstantationException extends RuntimeException {\n+\n+    public InstantationException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/instance/Instantiator.java\n+package org.mockito.internal.creation.instance;\n+\n+/**\n+ * Provides instances of classes.\n+ */\n+public interface Instantiator {\n+\n+    /**\n+     * Creates instance of given class\n+     */\n+    <T> T newInstance(Class<T> cls) throws InstantationException;\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/instance/InstantiatorProvider.java\n+package org.mockito.internal.creation.instance;\n+\n+import org.mockito.mock.MockCreationSettings;\n+\n+public class InstantiatorProvider {\n+\n+    private final static Instantiator INSTANCE = new ObjenesisInstantiator();\n+\n+    public Instantiator getInstantiator(MockCreationSettings settings) {\n+        if (settings.isUsingConstructor()) {\n+            return new ConstructorInstantiator(settings.getOuterClassInstance());\n+        } else {\n+            return INSTANCE;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/instance/ObjenesisInstantiator.java\n+package org.mockito.internal.creation.instance;\n+\n+import org.mockito.internal.configuration.GlobalConfiguration;\n+import org.objenesis.ObjenesisStd;\n+\n+class ObjenesisInstantiator implements Instantiator {\n+\n+    //TODO: in order to provide decent exception message when objenesis is not found,\n+    //have a constructor in this class that tries to instantiate ObjenesisStd and if it fails then show decent exception that dependency is missing\n+    //TODO: for the same reason catch and give better feedback when hamcrest core is not found.\n+    private final ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());\n+\n+    public <T> T newInstance(Class<T> cls) {\n+        return objenesis.newInstance(cls);\n+    }\n+}\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n     protected SerializableMode serializableMode = SerializableMode.NONE;\n     protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n     protected boolean stubOnly;\n+    private boolean useConstructor;\n+    private Object outerClassInstance;\n \n     public CreationSettings() {}\n \n         this.serializableMode = copy.serializableMode;\n         this.invocationListeners = copy.invocationListeners;\n         this.stubOnly = copy.stubOnly;\n+        this.useConstructor = copy.isUsingConstructor();\n+        this.outerClassInstance = copy.getOuterClassInstance();\n     }\n \n     public Class<T> getTypeToMock() {\n         return invocationListeners;\n     }\n \n+    public boolean isUsingConstructor() {\n+        return useConstructor;\n+    }\n+\n+    public Object getOuterClassInstance() {\n+        return outerClassInstance;\n+    }\n+\n     public boolean isStubOnly() {\n         return stubOnly;\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/util/MockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.util;\n+\n+//TODO SF Replace with RealMethod and get rid of (possibly).\n+public interface MockitoMethodProxy {\n+    Object invokeSuper(Object target, Object[] arguments) throws Throwable;\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/util/SearchingClassLoader.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.util;\n+\n+import static java.lang.Thread.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Inspired on jMock (thanks jMock guys!!!)\n+ */\n+public class SearchingClassLoader extends ClassLoader {\n+    private final ClassLoader nextToSearch;\n+    \n+    public SearchingClassLoader(ClassLoader parent, ClassLoader nextToSearch) {\n+        super(parent);\n+        this.nextToSearch = nextToSearch;\n+    }\n+    \n+    public static ClassLoader combineLoadersOf(Class<?>... classes) {\n+        return combineLoadersOf(classes[0], classes);\n+    }\n+    \n+    private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {\n+        List<ClassLoader> loaders = new ArrayList<ClassLoader>();\n+        \n+        addIfNewElement(loaders, first.getClassLoader());\n+        for (Class<?> c : others) {\n+            addIfNewElement(loaders, c.getClassLoader());\n+        }\n+        \n+        // To support Eclipse Plug-in tests.\n+        // In an Eclipse plug-in, we will not be on the system class loader\n+        // but in the class loader of the plug-in.\n+        //\n+        // Note: I've been unable to reproduce the error in the test suite.\n+        addIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());\n+        \n+        // To support the Maven Surefire plugin.\n+        // Note: I've been unable to reproduce the error in the test suite.\n+        addIfNewElement(loaders, currentThread().getContextClassLoader());\n+\n+        //Had to comment that out because it didn't work with in-container Spring tests\n+        //addIfNewElement(loaders, ClassLoader.getSystemClassLoader());\n+        \n+        return combine(loaders);\n+    }\n+    \n+    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n+        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n+        \n+        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n+            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n+        }\n+        \n+        return loader;\n+    }\n+    \n+    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n+        if (c != null && !loaders.contains(c)) {\n+            loaders.add(c);\n+        }\n+    }\n+    \n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        if (nextToSearch != null) {\n+            return nextToSearch.loadClass(name);\n+        } else {\n+            return super.findClass(name); // will throw ClassNotFoundException\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/CleanTraceRealMethod.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Provides stack trace filtering on exception.\n+ */\n+public class CleanTraceRealMethod implements RealMethod, Serializable {\n+\n+    private static final long serialVersionUID = 3596550785818938496L;\n+    private final RealMethod realMethod;\n+\n+    public CleanTraceRealMethod(MockitoMethodProxy methodProxy) {\n+        this(new DefaultRealMethod(methodProxy));\n+    }\n+\n+    public CleanTraceRealMethod(RealMethod realMethod) {\n+        this.realMethod = realMethod;\n+    }\n+\n+    public Object invoke(Object target, Object[] arguments) throws Throwable {\n+        try {\n+            return realMethod.invoke(target, arguments);\n+        } catch (Throwable t) {\n+            new ConditionalStackTraceFilter().filter(t);\n+            throw t;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/DefaultRealMethod.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+\n+import java.io.Serializable;\n+\n+public class DefaultRealMethod implements RealMethod, Serializable {\n+\n+    private static final long serialVersionUID = -4596470901191501582L;\n+    private final MockitoMethodProxy methodProxy;\n+\n+    public DefaultRealMethod(MockitoMethodProxy methodProxy) {\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    public Object invoke(Object target, Object[] arguments) throws Throwable {\n+        return methodProxy.invokeSuper(target, arguments);\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/realmethod/RealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/RealMethod.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation.realmethod;\n-\n \n public interface RealMethod {\n \n--- /dev/null\n+++ b/src/org/mockito/internal/rules/JUnitRule.java\n+package org.mockito.internal.rules;\n+\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Internal implementation.\n+ */\n+public class JUnitRule {\n+    private Object object;\n+\n+    public JUnitRule(Object object) {\n+        this.object = object;\n+    }\n+\n+    public Statement apply(final Statement base, Description description) {\n+        return new Statement() {\n+            @Override\n+            public void evaluate() throws Throwable {\n+                MockitoAnnotations.initMocks(object);\n+                base.evaluate();\n+                Mockito.validateMockitoUsage();\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/rules/JunitRuleImpl.java\n+package org.mockito.internal.rules;\n+\n+/**\n+ * Created by jerzy on 2014-09-19.\n+ */\n+public class JunitRuleImpl {\n+}\n--- a/src/org/mockito/internal/stubbing/BaseStubbing.java\n+++ b/src/org/mockito/internal/stubbing/BaseStubbing.java\n     public OngoingStubbing<T> thenReturn(T value, T... values) {\n         OngoingStubbing<T> stubbing = thenReturn(value);            \n         if (values == null) {\n+            //TODO below does not seem right\n             return stubbing.thenReturn(null);\n         }\n         for (T v: values) {\n--- a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n-import java.io.Serializable;\n-\n+import org.mockito.Answers;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Modifier;\n \n /**\n  * Optional Answer that adds partial mocking support\n     private static final long serialVersionUID = 9057165148930624087L;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n+    \tif (Modifier.isAbstract(invocation.getMethod().getModifiers())) {\n+    \t\treturn Answers.RETURNS_DEFAULTS.get().answer(invocation);\n+    \t}\n         return invocation.callRealMethod();\n     }\n }\n--- a/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n     private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n \n     public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {\n-\n         this.throwableClass = throwableClass;\n     }\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-\n+        //TODO centralize the use of Objenesis. Why do we use ObjenesisHelper?\n         Throwable throwable = (Throwable) ObjenesisHelper.newInstance(throwableClass);\n         throwable.fillInStackTrace();\n         filter.filter(throwable);\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.stubbing.answers.MethodInfo;\n+import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.Method;\n \n /**\n  * Internal answer to forward invocations on a real instance.\n  * @since 1.9.5\n  */\n public class ForwardsInvocations implements Answer<Object>, Serializable {\n+    private static final long serialVersionUID = -8343690268123254910L;\n \n-\tprivate static final long serialVersionUID = -8343690268123254910L;\n+    private Object delegatedObject = null ;\n \n-\tprivate Object delegatedObject = null ;\n+    public ForwardsInvocations(Object delegatedObject) {\n+        this.delegatedObject = delegatedObject ;\n+    }\n \n-\tpublic ForwardsInvocations(Object delegatedObject) {\n-\t\tthis.delegatedObject = delegatedObject ;\n-\t}\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        Method mockMethod = invocation.getMethod();\n+        \n+        Object result = null;\n+        \n+        try {\n+            Method delegateMethod = getDelegateMethod(mockMethod);\n+            \n+            if (!compatibleReturnTypes(mockMethod.getReturnType(), delegateMethod.getReturnType())) {\n+                new Reporter().delegatedMethodHasWrongReturnType(mockMethod, delegateMethod, invocation.getMock(), delegatedObject);\n+            }\n+            \n+            result = delegateMethod.invoke(delegatedObject, invocation.getArguments());\n+        } catch (NoSuchMethodException e) {\n+            new Reporter().delegatedMethodDoesNotExistOnDelegate(mockMethod, invocation.getMock(), delegatedObject);\n+        } catch (InvocationTargetException e) {\n+            // propagate the original exception from the delegate\n+            throw e.getCause();\n+        }\n+        \n+        return result;\n+    }\n \n-\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\n-\t\tMethod method = invocation.getMethod() ;\n+    private Method getDelegateMethod(Method mockMethod) throws NoSuchMethodException {\n+        if (mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {\n+            // Compatible class. Return original method.\n+            return mockMethod;\n+        } else {\n+            // Return method of delegate object with the same signature as mockMethod.\n+            return delegatedObject.getClass().getMethod(mockMethod.getName(), mockMethod.getParameterTypes());\n+        }\n+    }\n \n-        return method.invoke(delegatedObject, invocation.getArguments());\n-\t}\n-}\n+    private static boolean compatibleReturnTypes(Class<?> superType, Class<?> subType) {\n+        return superType.equals(subType) || superType.isAssignableFrom(subType);\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import static org.mockito.Mockito.withSettings;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n import org.mockito.MockSettings;\n import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n  * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n  */\n public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n-    \n+\n     private static final long serialVersionUID = -7105341425736035847L;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n     }\n \n     private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n-    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n-    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n+        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n         // matches invocation for verification\n         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n-    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n-    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n-    \t\t}\n-\t\t}\n+            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n+                return stubbedInvocationMatcher.answer(invocation);\n+            }\n+        }\n \n         // record deep stub answer\n-        return recordDeepStubAnswer(newDeepStubMock(returnTypeGenericMetadata), container);\n+        return recordDeepStubAnswer(\n+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\n+                container\n+        );\n     }\n \n     /**\n      * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n      *\n      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n+     * @param parentMock The parent of the current deep stub mock.\n      * @return The mock\n      */\n-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\n+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\n         return mockitoCore().mock(\n                 returnTypeGenericMetadata.rawType(),\n-                withSettingsUsing(returnTypeGenericMetadata)\n+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\n         );\n     }\n \n-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                 : withSettings();\n \n-        return mockSettings\n-\t\t        .serializable()\n+        return propagateSerializationSettings(mockSettings, parentMockSettings)\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n+    }\n+\n+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\n+        return mockSettings.serializable(parentMockSettings.getSerializableMode());\n     }\n \n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.util.reflection.Constructors;\n+import org.mockito.mock.SerializableMode;\n \n import java.io.Serializable;\n import java.util.Collection;\n             new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n         }\n     }\n+\n+    public void validateConstructorUse(boolean usingConstructor, SerializableMode mode) {\n+        if (usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS) {\n+            new Reporter().usingConstructorWithFancySerializable(mode);\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/junit/MockitoJUnitRule.java\n+package org.mockito.junit;\n+\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+import org.mockito.internal.rules.JUnitRule;\n+\n+import static org.mockito.internal.util.Checks.checkNotNull;\n+\n+/**\n+ * The MockitoJUnitRule Rule can be used instead of {@link org.mockito.runners.MockitoJUnitRunner}.\n+ * Requires JUnit 4.9 (at least).\n+ *\n+ * This rule adds following behavior:\n+ * <ul>\n+ *   <li>\n+ *      Initializes mocks annotated with {@link org.mockito.Mock},\n+ *      so that explicit usage of {@link org.mockito.MockitoAnnotations#initMocks(Object)} is not necessary.\n+ *      Mocks are initialized before each test method.\n+ *   <li>\n+ *      validates framework usage after each test method. See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ * </ul>\n+ * Example use:\n+ * <pre class=\"code\"><code class=\"java\">\n+ * public class ExampleTest {\n+ *\n+ *     &#064;Rule\n+ *     public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);</b>\n+ *\n+ *     &#064;Mock\n+ *     private List list;\n+ *\n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * </code></pre>\n+ */\n+public class MockitoJUnitRule implements TestRule {\n+\n+    private final JUnitRule jUnitRule;\n+\n+    /**\n+     * @param targetTest the test class instance where the rule is declared. Cannot be null.\n+     */\n+    public MockitoJUnitRule(Object targetTest) {\n+        checkNotNull(targetTest, \"Mockito JUnit rule target\");\n+        this.jUnitRule = new JUnitRule(targetTest);\n+    }\n+\n+    public Statement apply(final Statement base, Description description) {\n+        return jUnitRule.apply(base, description);\n+    }\n+\n+}\n--- a/src/org/mockito/mock/MockCreationSettings.java\n+++ b/src/org/mockito/mock/MockCreationSettings.java\n     boolean isStubOnly();\n \n     /**\n-     * the invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n+     * The invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n      */\n     List<InvocationListener> getInvocationListeners();\n+\n+    /**\n+     * Informs whether the mock instance should be created via constructor\n+     *\n+     * @since 1.10.12\n+     */\n+    @Incubating\n+    boolean isUsingConstructor();\n+\n+    /**\n+     * Used when mocking non-static inner classes in conjunction with {@link #isUsingConstructor()}\n+     *\n+     * @return the outer class instance used for creation of the mock object via the constructor.\n+     * @since 1.10.12\n+     */\n+    @Incubating\n+    Object getOuterClassInstance();\n }\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.creation.cglib.ClassImposterizerTest;\n import org.mockito.internal.handler.MockHandlerImplTest;\n import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n--- a/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n+++ b/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n-\n-import static org.mockito.Mockito.spy;\n \n import org.junit.Test;\n import org.mockito.cglib.core.NamingPolicy;\n-import org.mockito.internal.creation.MockitoMethodProxy;\n+import org.mockito.cglib.proxy.MethodProxy;\n import org.mockitoutil.TestBase;\n import org.powermock.reflect.Whitebox;\n+\n+import static org.mockito.Mockito.spy;\n \n public class CGLIBHackerTest extends TestBase {\n \n     @Test\n     public void shouldSetMockitoNamingPolicy() throws Exception {\n         //given\n-        MockitoMethodProxy methodProxy = new MethodProxyBuilder().build();\n+        MethodProxy methodProxy = MethodProxy.create(String.class, Integer.class, \"\", \"\", \"\");\n         \n         //when\n         new CGLIBHacker().setMockitoNamingPolicy(methodProxy);\n         \n         //then\n-        Object realMethodProxy = Whitebox.invokeMethod(methodProxy, \"getMethodProxy\", new Object[0]);\n-        Object createInfo = Whitebox.getInternalState(realMethodProxy, \"createInfo\");\n+        Object createInfo = Whitebox.getInternalState(methodProxy, \"createInfo\");\n         NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, \"namingPolicy\");\n         assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);\n     }\n     @Test\n     public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied() throws Exception {\n         //given\n-        MockitoMethodProxy proxiedMethodProxy = spy(new MethodProxyBuilder().build());\n+        MethodProxy proxiedMethodProxy = spy(MethodProxy.create(String.class, Integer.class, \"\", \"\", \"\"));\n         \n         //when\n         new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);\n         \n         //then\n-        Object realMethodProxy = Whitebox.invokeMethod(proxiedMethodProxy, \"getMethodProxy\", new Object[0]);\n-        Object createInfo = Whitebox.getInternalState(realMethodProxy, \"createInfo\");\n+        Object createInfo = Whitebox.getInternalState(proxiedMethodProxy, \"createInfo\");\n         NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, \"namingPolicy\");\n         assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/ClassImposterizerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.instance.ConstructorInstantiator;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ClassImposterizerTest extends TestBase {\n+\n+    ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator(new CreationSettings()));\n+\n+    @Test\n+    public void shouldCreateMockFromInterface() throws Exception {\n+        SomeInterface proxy = imposterizer.imposterise(new MethodInterceptorStub(), SomeInterface.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(Object.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClass() throws Exception {\n+        ClassWithoutConstructor proxy = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(ClassWithoutConstructor.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {\n+        try {\n+            new ClassWithDodgyConstructor();\n+            fail();\n+        } catch (Exception e) {}\n+        \n+        ClassWithDodgyConstructor mock = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);\n+        assertNotNull(mock);\n+    }\n+    \n+    @Test \n+    public void shouldMocksHaveDifferentInterceptors() throws Exception {\n+        SomeClass mockOne = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        SomeClass mockTwo = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        \n+        Factory cglibFactoryOne = (Factory) mockOne;\n+        Factory cglibFactoryTwo = (Factory) mockTwo;\n+        \n+        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n+    }\n+    \n+    @Test\n+    public void shouldUseAnicilliaryTypes() {\n+        SomeClass mock = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);\n+        \n+        assertThat(mock, is(instanceOf(SomeInterface.class)));\n+    }\n+\n+    @Test\n+    public void shouldCreateClassByConstructor() {\n+        imposterizer = new ClassImposterizer(new ConstructorInstantiator(null));\n+        OtherClass mock = imposterizer.imposterise(new MethodInterceptorStub(), OtherClass.class);\n+        assertNotNull(mock);\n+    }\n+\n+    class SomeClass {}\n+    interface SomeInterface {}\n+    static class OtherClass {}\n+    \n+    private class ClassWithoutConstructor {}\n+\n+    private class ClassWithDodgyConstructor {\n+        public ClassWithDodgyConstructor() {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private final class MethodInterceptorStub implements MethodInterceptor {\n+\n+        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+            return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n+import org.mockitousage.MethodsImpl;\n+import org.mockitoutil.TestBase;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Method;\n+\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.withSettings;\n+\n+public class MethodInterceptorFilterTest extends TestBase {\n+\n+    InternalMockHandler handler = Mockito.mock(InternalMockHandler.class);\n+    MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n+\n+    @Test\n+    public void shouldBeSerializable() throws Exception {\n+        new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null, null));\n+    }\n+\n+    @Test\n+    public void shouldProvideOwnImplementationOfHashCode() throws Throwable {\n+        //when\n+        Object ret = filter.intercept(new MethodsImpl(), MethodsImpl.class.getMethod(\"hashCode\"), new Object[0], null);\n+\n+        //then\n+        assertTrue((Integer) ret != 0);\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n+    }\n+\n+    @Test\n+    public void shouldProvideOwnImplementationOfEquals() throws Throwable {\n+        //when\n+        MethodsImpl proxy = new MethodsImpl();\n+        Object ret = filter.intercept(proxy, MethodsImpl.class.getMethod(\"equals\", Object.class), new Object[] {proxy}, null);\n+\n+        //then\n+        assertTrue((Boolean) ret);\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n+    }\n+    \n+    //TODO: move to separate factory\n+    @Test\n+    public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());\n+        Method method = new InvocationBuilder().toInvocation().getMethod();\n+        \n+        // when\n+        MockitoMethod mockitoMethod = filter.createMockitoMethod(method);\n+        \n+        // then\n+        assertThat(mockitoMethod, instanceOf(SerializableMethod.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n+        Method method = new InvocationBuilder().toInvocation().getMethod();\n+        \n+        // when\n+        MockitoMethod mockitoMethod = filter.createMockitoMethod(method);\n+        \n+        // then\n+        assertThat(mockitoMethod, instanceOf(DelegatingMethod.class));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxyTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockitoutil.TestBase;\n+import org.powermock.reflect.Whitebox;\n+\n+public class SerializableMockitoMethodProxyTest extends TestBase {\n+\n+    @Test\n+    public void shouldCreateCorrectCreationInfo() throws Exception {\n+        // given\n+        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"\", \"\", \"\");\n+        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);\n+        serializableMockitoMethodProxy.methodProxy = null;\n+\n+        // when\n+        Object methodProxy = Whitebox.invokeMethod(serializableMockitoMethodProxy, \"getMethodProxy\",  new Object[0]);\n+\n+        // then\n+        Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        assertEquals(String.class, Whitebox.getInternalState(info, \"c1\"));\n+        assertEquals(Integer.class, Whitebox.getInternalState(info, \"c2\"));\n+    }\n+\n+    @Test\n+    public void shouldCreateCorrectSignatures() throws Exception {\n+        // given\n+        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"a\", \"b\", \"c\");\n+        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);\n+        serializableMockitoMethodProxy.methodProxy = null;\n+\n+        // when\n+        MethodProxy methodProxy = (MethodProxy) Whitebox.invokeMethod(serializableMockitoMethodProxy, \"getMethodProxy\",  new Object[0]);\n+\n+        // then\n+        assertEquals(\"a\", methodProxy.getSignature().getDescriptor());\n+        assertEquals(\"b\", methodProxy.getSignature().getName());\n+        assertEquals(\"c\", methodProxy.getSuperName());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SerializableMockitoMethodProxyTest []\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java\n+package org.mockito.internal.creation.instance;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class ConstructorInstantiatorTest extends TestBase {\n+\n+    static class SomeClass {}\n+    class SomeInnerClass {}\n+    class ChildOfThis extends ConstructorInstantiatorTest {}\n+    static class SomeClass2 {\n+        SomeClass2(String x) {}\n+    }\n+\n+    @Test public void creates_instances() {\n+        assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);\n+    }\n+\n+    @Test public void creates_instances_of_inner_classes() {\n+        assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);\n+        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);\n+    }\n+\n+    @Test public void explains_when_constructor_cannot_be_found() {\n+        try {\n+            new ConstructorInstantiator(null).newInstance(SomeClass2.class);\n+            fail();\n+        } catch (InstantationException e) {\n+            assertEquals(\"Unable to create mock instance of 'SomeClass2'.\\n\" +\n+                    \"Please ensure it has parameter-less constructor.\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/rules/InjectTestCase.java\n+package org.mockito.internal.rules;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+\n+@Ignore(\"used internally by JUnitRuleTest\")\n+public class InjectTestCase {\n+\n+    @Mock\n+    private Injected injected;\n+\n+    @InjectMocks\n+    private InjectInto injectInto;\n+\n+    @Test\n+    public void dummy() throws Exception {\n+    }\n+\n+    public void unfinishedStubbingThrowsException() throws Exception {\n+        Mockito.when(injected.stringMethod());\n+    }\n+\n+    public Injected getInjected() {\n+        return injected;\n+    }\n+\n+    public InjectInto getInjectInto() {\n+        return injectInto;\n+    }\n+\n+    private static class Injected {\n+        public String stringMethod() {\n+            return \"string\";\n+        }\n+    }\n+\n+    private static class InjectInto {\n+        private Injected injected;\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/rules/JUnitRuleTest.java\n+package org.mockito.internal.rules;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n+\n+public class JUnitRuleTest {\n+\n+    private JUnitRule jUnitRule;\n+    private InjectTestCase injectTestCase;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        injectTestCase = new InjectTestCase();\n+        jUnitRule = new JUnitRule(injectTestCase);\n+    }\n+\n+    @Test\n+    public void testInject() throws Throwable {\n+        jUnitRule.apply(new DummyStatement(), Description.EMPTY).evaluate();\n+        assertNotNull(\"\", injectTestCase.getInjected());\n+        assertNotNull(\"\", injectTestCase.getInjectInto());\n+    }\n+\n+    @Test\n+    public void testThrowAnException() throws Throwable {\n+        try {\n+            jUnitRule.apply(new ExceptionStatement(), Description.EMPTY).evaluate();\n+            fail(\"Should throw exception\");\n+        } catch (RuntimeException e) {\n+            assertEquals(\"Correct message\", \"Statement exception\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testMockitoValidation() throws Throwable {\n+        try {\n+            jUnitRule.apply(new UnfinishedStubbingStatement(), Description.EMPTY).evaluate();\n+            fail(\"Should detect unvalid Mockito usage\");\n+        } catch (UnfinishedStubbingException e) {\n+        }\n+    }\n+\n+    private static class DummyStatement extends Statement {\n+        @Override\n+        public void evaluate() throws Throwable {\n+        }\n+    }\n+\n+    private static class ExceptionStatement extends Statement {\n+        @Override\n+        public void evaluate() throws Throwable {\n+            throw new RuntimeException(\"Statement exception\");\n+        }\n+    }\n+\n+    private static class UnfinishedStubbingStatement extends Statement {\n+        @Override\n+        public void evaluate() throws Throwable {\n+            InjectTestCase injectTestCase = new InjectTestCase();\n+            MockitoAnnotations.initMocks(injectTestCase);\n+            injectTestCase.unfinishedStubbingThrowsException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/junit/MockitoJUnitRuleTest.java\n+package org.mockito.junit;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+\n+import static org.junit.Assert.*;\n+\n+public class MockitoJUnitRuleTest {\n+\n+    @Rule\n+    public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);\n+\n+    @Mock\n+    private Injected injected;\n+\n+    @InjectMocks\n+    private InjectInto injectInto;\n+\n+    @Test\n+    public void testInjectMocks() throws Exception {\n+        assertNotNull(\"Mock created\", injected);\n+        assertNotNull(\"Object created\", injectInto);\n+        assertEquals(\"A injected into B\", injected, injectInto.getInjected());\n+\n+    }\n+\n+    @Test\n+    public void testThrowExceptionWhenNullTarget() throws Exception {\n+        try {\n+            new MockitoJUnitRule(null);\n+            fail();\n+        } catch (NullPointerException e) {\n+            assertEquals(\"valid message\", \"Mockito JUnit rule target should not be null\", e.getMessage());\n+        }\n+    }\n+\n+    private static class Injected {\n+    }\n+\n+    private static class InjectInto {\n+\n+        private Injected injected;\n+\n+        public Injected getInjected() {\n+            return injected;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/DeepStubsWronglyReportsSerializationProblemsTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * In GH issue 99 : https://github.com/mockito/mockito/issues/99\n+ */\n+public class DeepStubsWronglyReportsSerializationProblemsTest {\n+\n+    @Test\n+    public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {\n+        NotSerializableShouldBeMocked the_deep_stub = mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething();\n+        assertThat(the_deep_stub).isNotNull();\n+    }\n+\n+    public static class ToBeDeepStubbed {\n+        public ToBeDeepStubbed() { }\n+\n+        public NotSerializableShouldBeMocked getSomething() {\n+            return null;\n+        }\n+    }\n+\n+    public static class NotSerializableShouldBeMocked {\n+        NotSerializableShouldBeMocked(String mandatory_param) { }\n+    }\n+\n+}\n--- a/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n+++ b/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n                     .containsIgnoringCase(\"MockitoConfiguration\");\n             assertThat(e.getCause())\n                     .satisfies(thatCceIsThrownFrom(\"java.lang.Class.cast\"))\n-                    .satisfies(thatCceIsThrownFrom(\"org.mockito.internal.creation.jmock.ClassImposterizer.imposterise\"));\n+                    .satisfies(thatCceIsThrownFrom(\"org.mockito.internal.creation.cglib.ClassImposterizer.imposterise\"));\n         }\n     }\n \n--- /dev/null\n+++ b/test/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java\n+package org.mockitousage.constructor;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.mock.SerializableMode;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class CreatingMocksWithConstructorTest extends TestBase {\n+\n+    static abstract class AbstractMessage {\n+        private final String message;\n+        AbstractMessage() {\n+            this.message = \"hey!\";\n+        }\n+        String getMessage() {\n+            return message;\n+        }\n+    }\n+\n+    static class Message extends AbstractMessage {}\n+    class InnerClass extends AbstractMessage {}\n+\n+    @Test\n+    public void can_create_mock_with_constructor() {\n+        Message mock = mock(Message.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+        //the message is a part of state of the mocked type that gets initialized in constructor\n+        assertEquals(\"hey!\", mock.getMessage());\n+    }\n+\n+    @Test\n+    public void can_mock_abstract_classes() {\n+        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+        assertEquals(\"hey!\", mock.getMessage());\n+    }\n+\n+    @Test\n+    public void can_spy_abstract_classes() {\n+        AbstractMessage mock = spy(AbstractMessage.class);\n+        assertEquals(\"hey!\", mock.getMessage());\n+    }\n+\n+    @Test\n+    public void can_mock_inner_classes() {\n+        InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));\n+        assertEquals(\"hey!\", mock.getMessage());\n+    }\n+\n+    static class HasConstructor {\n+        HasConstructor(String x) {}\n+    }\n+\n+    @Test\n+    public void exception_message_when_constructor_not_found() {\n+        try {\n+            //when\n+            spy(HasConstructor.class);\n+            //then\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Unable to create mock instance of type 'HasConstructor'\", e.getMessage());\n+            assertContains(\"Please ensure it has parameter-less constructor\", e.getCause().getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void mocking_inner_classes_with_wrong_outer_instance() {\n+        try {\n+            //when\n+            mock(InnerClass.class, withSettings().useConstructor().outerInstance(\"foo\").defaultAnswer(CALLS_REAL_METHODS));\n+            //then\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Unable to create mock instance of type 'InnerClass'\", e.getMessage());\n+            assertContains(\"Please ensure that the outer instance has correct type and that the target class has parameter-less constructor\", e.getCause().getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void mocking_interfaces_with_constructor() {\n+        //at the moment this is allowed however we can be more strict if needed\n+        //there is not much sense in creating a spy of an interface\n+        mock(IMethods.class, withSettings().useConstructor());\n+        spy(IMethods.class);\n+    }\n+\n+    @Test\n+    public void prevents_across_jvm_serialization_with_constructor() {\n+        try {\n+            //when\n+            mock(AbstractMessage.class, withSettings().useConstructor().serializable(SerializableMode.ACROSS_CLASSLOADERS));\n+            //then\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Mocks instantiated with constructor cannot be combined with \" + SerializableMode.ACROSS_CLASSLOADERS + \" serialization mode.\", e.getMessage());\n+        }\n+    }\n+\n+    static abstract class AbstractThing {\n+    \tabstract String name();\n+    \tString fullName() {\n+    \t\treturn \"abstract \" + name();\n+    \t}\n+    }\n+    \n+    @Test\n+    public void abstractMethodReturnsDefault() {\n+    \tAbstractThing thing = spy(AbstractThing.class);\n+    \tassertEquals(\"abstract null\", thing.fullName());\n+    }\n+    \n+    @Test\n+    public void abstractMethodStubbed() {\n+    \tAbstractThing thing = spy(AbstractThing.class);\n+    \twhen(thing.name()).thenReturn(\"me\");\n+    \tassertEquals(\"abstract me\", thing.fullName());\n+    }\n+ \n+    @Test\n+    public void testCallsRealInterfaceMethod() {\n+    \tList<String> list = mock(List.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));\n+    \tassertNull(list.get(1));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/internal/invocation/realmethod/CleanTraceRealMethodTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.internal.invocation.realmethod;\n+\n+import static org.mockitoutil.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockitoutil.TestBase;\n+\n+public class CleanTraceRealMethodTest extends TestBase {\n+\n+    @Before\n+    public void keepStackTracesClean() {\n+        makeStackTracesClean();\n+    }\n+    \n+    class Foo {\n+        public String throwSomething() {\n+            throw new RuntimeException();\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows() throws Throwable {\n+        //given\n+        CleanTraceRealMethod realMethod = new CleanTraceRealMethod(new RealMethod() {\n+            public Object invoke(Object target, Object[] arguments) throws Throwable {\n+                return new Foo().throwSomething();\n+            }});\n+        \n+        //when\n+        try {\n+            realMethod.invoke(null, null);\n+            fail();\n+        //then\n+        } catch (Exception e) {\n+            assertThat(e, hasMethodInStackTraceAt(0, \"throwSomething\"));\n+            assertThat(e, hasMethodInStackTraceAt(1, \"invoke\"));\n+            assertThat(e, hasMethodInStackTraceAt(2, \"shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegateTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitousage.MethodsImpl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithDelegateTest {\n+   public class FakeList<T> {\n+        private T value;\n+        \n+        public T get(int i) {\n+            return value;\n+        }\n+        \n+        public T set(int i, T value) {\n+            T oldValue = value;\n+            this.value = value;\n+            return oldValue;\n+        }\n+        \n+        public int size() {\n+            return 10;\n+        }\n+        \n+        public ArrayList<T> subList(int fromIndex, int toIndex) {\n+            return new ArrayList<T>();\n+        }\n+    }\n+    \n+    public class FakeListWithWrongMethods<T> {\n+        public double size() {\n+            return 10;\n+        }\n+        \n+        public Collection<T> subList(int fromIndex, int toIndex) {\n+            return new ArrayList<T>();\n+        }\n+    }\n+\t\n+\t@Test\n+\tpublic void when_not_stubbed_delegate_should_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tmock.add(\"two\") ;\n+\n+        assertEquals(2, mock.size());\n+\t}\n+\n+\t@Test\n+\tpublic void when_stubbed_the_delegate_should_not_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tdoReturn(10).when(mock).size();\n+\n+\t\tmock.add(\"two\") ;\n+\n+\t\tassertEquals(10, mock.size());\n+        assertEquals(2, delegatedList.size());\n+\t}\n+\n+\t@Test\n+\tpublic void delegate_should_not_be_called_when_stubbed2() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mockedList = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tdoReturn(false).when(mockedList).add(Mockito.anyString()) ;\n+\n+        mockedList.add(\"two\") ;\n+\n+\t\tassertEquals(1, mockedList.size()) ;\n+\t\tassertEquals(1, delegatedList.size()) ;\n+\t}\n+\n+    @Test\n+    public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {\n+        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl()));\n+\n+        try {\n+            byte b = methods.byteObjectReturningMethod(); // real method returns null\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.toString()).doesNotContain(\"org.mockito\");\n+        }\n+    }\n+    \n+    @Test\n+    public void instance_of_different_class_can_be_called() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));\n+        \n+        mock.set(1, \"1\");\n+        assertThat(mock.get(1).equals(\"1\"));\n+    }\n+    \n+    @Test\n+    public void method_with_subtype_return_can_be_called() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));\n+        \n+        List<String> subList = mock.subList(0, 0);\n+        assertThat(subList.isEmpty());\n+    }\n+    \n+    @Test\n+    public void calling_missing_method_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));\n+        \n+        try {\n+            mock.isEmpty();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Methods called on mock must exist\");\n+        }\n+    }\n+    \n+    @Test\n+    public void calling_method_with_wrong_primitive_return_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<String>()));\n+        \n+        try {\n+            mock.size();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Methods called on delegated instance must have compatible return type\");\n+        }\n+    }\n+    \n+    @Test\n+    public void calling_method_with_wrong_reference_return_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<String>()));\n+        \n+        try {\n+            mock.subList(0, 0);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Methods called on delegated instance must have compatible return type\");\n+        }\n+    }\n+\n+    @Test\n+    public void exception_should_be_propagated_from_delegate() throws Exception {\n+        final RuntimeException failure = new RuntimeException(\"angry-method\");\n+        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl() {\n+            @Override\n+            public String simpleMethod() {\n+                throw failure;\n+            }\n+        }));\n+\n+        try {\n+            methods.simpleMethod(); // delegate throws an exception\n+            fail();\n+        } catch (RuntimeException e) {\n+            assertThat(e).isEqualTo(failure);\n+        }\n+    }\n+}", "timestamp": 1416993949, "metainfo": ""}