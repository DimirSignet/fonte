{"sha": "55db3c7811a05ecae85144e9651160d745af4ea8", "log": "umbilical cord between mockito package and easymock package is cut!  --HG-- rename : src/org/mockito/matchers/HasNoIvocationsMatcher.java => src/org/mockito/hamcrest/HasNoIvocationsMatcher.java rename : src/org/mockito/matchers/HasNoMoreIvocationsMatcher.java => src/org/mockito/hamcrest/HasNoMoreIvocationsMatcher.java rename : src/org/mockito/matchers/MockitoMatcher.java => src/org/mockito/hamcrest/MockitoMatcher.java rename : src/org/mockito/matchers/WasInvokedMatcher.java => src/org/mockito/hamcrest/WasInvokedMatcher.java rename : src/org/easymock/internal/ClassProxyFactory.java => src/org/mockito/internal/ClassProxyFactory.java rename : src/org/easymock/internal/ExpectedInvocation.java => src/org/mockito/internal/ExpectedInvocation.java rename : src/org/easymock/IAnswer.java => src/org/mockito/internal/IAnswer.java rename : src/org/easymock/internal/Invocation.java => src/org/mockito/internal/Invocation.java rename : src/org/mockito/InvocationWithMatchers.java => src/org/mockito/internal/InvocationWithMatchers.java rename : src/org/easymock/internal/LastArguments.java => src/org/mockito/internal/LastArguments.java rename : src/org/mockito/MethodSelector.java => src/org/mockito/internal/MethodSelector.java rename : src/org/mockito/MockAwareInvocationHandler.java => src/org/mockito/internal/MockAwareInvocationHandler.java rename : src/org/mockito/MockUtil.java => src/org/mockito/internal/MockUtil.java rename : src/org/mockito/MockitoBehavior.java => src/org/mockito/internal/MockitoBehavior.java rename : src/org/mockito/MockitoControl.java => src/org/mockito/internal/MockitoControl.java rename : src/org/mockito/MockitoExpectation.java => src/org/mockito/internal/MockitoExpectation.java rename : src/org/mockito/MockitoInvocation.java => src/org/mockito/internal/MockitoInvocation.java rename : src/org/easymock/internal/MockitoObjectMethodsFilter.java => src/org/mockito/internal/MockitoObjectMethodsFilter.java rename : src/org/mockito/MockitoOperations.java => src/org/mockito/internal/MockitoOperations.java rename : src/org/easymock/internal/Result.java => src/org/mockito/internal/Result.java rename : src/org/easymock/internal/RuntimeExceptionWrapper.java => src/org/mockito/internal/RuntimeExceptionWrapper.java rename : src/org/easymock/internal/ToTypeMappings.java => src/org/mockito/internal/ToTypeMappings.java rename : src/org/mockito/VerifyingMode.java => src/org/mockito/internal/VerifyingMode.java rename : src/org/mockito/VoidMethodExpectation.java => src/org/mockito/internal/VoidMethodExpectation.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4024", "commit": "\n--- a/src/org/easymock/EasyMock.java\n+++ b/src/org/easymock/EasyMock.java\n import java.util.Comparator;\n \n import org.easymock.internal.ClassExtensionHelper;\n-import org.easymock.internal.LastArguments;\n import org.easymock.internal.LastControl;\n import org.easymock.internal.MockInvocationHandler;\n import org.easymock.internal.MocksControl;\n-import org.easymock.internal.MockitoObjectMethodsFilter;\n-import org.easymock.internal.matchers.Any;\n-import org.easymock.internal.matchers.Compare;\n-import org.easymock.internal.matchers.Contains;\n-import org.easymock.internal.matchers.Equals;\n-import org.easymock.internal.matchers.EqualsWithDelta;\n-import org.easymock.internal.matchers.GreaterOrEqual;\n-import org.easymock.internal.matchers.GreaterThan;\n-import org.easymock.internal.matchers.InstanceOf;\n-import org.easymock.internal.matchers.LessOrEqual;\n-import org.easymock.internal.matchers.LessThan;\n-import org.easymock.internal.matchers.Matches;\n-import org.easymock.internal.matchers.NotNull;\n-import org.easymock.internal.matchers.Null;\n+import org.mockito.internal.*;\n+import org.mockito.internal.matchers.*;\n+import org.mockito.matchers.*;\n \n public class EasyMock {\n \n--- a/src/org/easymock/IExpectationSetters.java\n+++ b/src/org/easymock/IExpectationSetters.java\n  */\n package org.easymock;\n \n-import org.mockito.MockitoExpectation;\n+import org.mockito.internal.*;\n \n /**\n  * Allows setting expectations for an associated expected invocation.\n--- a/src/org/easymock/MockControl.java\n+++ b/src/org/easymock/MockControl.java\n                 \"method call on the mock needed before setting return value\")\n                 .andReturn(value);\n         callWithConvertedRange(setter, range);\n-    }\n-\n-    /**\n-     * Records that the mock object will by default allow the last method\n-     * specified by a method call.\n-     * \n-     * @exception IllegalStateException\n-     *                if the mock object is in replay state, if no method was\n-     *                called on the mock object before, or if the last method\n-     *                called on the mock was no void method.\n-     */\n-    public void setDefaultVoidCallable() {\n-        ((MocksControl) expectLastCall(\"method call on the mock needed before setting default void callable\"))\n-                .setLegacyDefaultVoidCallable();\n-    }\n-\n-    /**\n-     * Records that the mock object will by default allow the last method\n-     * specified by a method call, and will react by throwing the provided\n-     * Throwable.\n-     * \n-     * @param throwable\n-     *            throwable the throwable to be thrown\n-     * @exception IllegalArgumentException\n-     *                if the last method called on the mock cannot throw the\n-     *                provided Throwable.\n-     * @exception NullPointerException\n-     *                if throwable is null.\n-     * @exception IllegalStateException\n-     *                if the mock object is in replay state, or if no method was\n-     *                called on the mock object before.\n-     */\n-    public void setDefaultThrowable(Throwable throwable) {\n-        ctrl.setLegacyDefaultThrowable(throwable);\n-    }\n-\n-    /**\n-     * Records that the mock object will by default allow the last method\n-     * specified by a method call, and will react by returning the provided\n-     * return value.\n-     * \n-     * @param value\n-     *            the return value.\n-     * @throws IllegalStateException\n-     *             if the mock object is in replay state, if no method was\n-     *             called on the mock object before. or if the last method\n-     *             called on the mock does not return <code>boolean</code>.\n-     */\n-    public void setDefaultReturnValue(Object value) {\n-        ctrl.setLegacyDefaultReturnValue(value);\n     }\n \n     /**\n--- a/src/org/easymock/internal/ArrayMatcher.java\n+++ b/src/org/easymock/internal/ArrayMatcher.java\n package org.easymock.internal;\n \n import org.easymock.AbstractMatcher;\n-import org.easymock.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.ArrayEquals;\n \n public class ArrayMatcher extends AbstractMatcher {\n     public String argumentToString(Object argument) {\n--- a/src/org/easymock/internal/ClassExtensionHelper.java\n+++ b/src/org/easymock/internal/ClassExtensionHelper.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n \n-import org.easymock.internal.ClassProxyFactory.MockMethodInterceptor;\n+import org.mockito.internal.*;\n+import org.mockito.internal.ClassProxyFactory.MockMethodInterceptor;\n \n public final class ClassExtensionHelper {\n \n--- a/src/org/easymock/internal/ExpectedInvocationAndResult.java\n+++ b/src/org/easymock/internal/ExpectedInvocationAndResult.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.easymock.internal;\n+\n+import org.mockito.internal.*;\n \n public class ExpectedInvocationAndResult {\n     ExpectedInvocation expectedInvocation;\n--- a/src/org/easymock/internal/ExpectedInvocationAndResults.java\n+++ b/src/org/easymock/internal/ExpectedInvocationAndResults.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.easymock.internal;\n+\n+import org.mockito.internal.ExpectedInvocation;\n \n public class ExpectedInvocationAndResults {\n     ExpectedInvocation expectedInvocation;\n--- a/src/org/easymock/internal/ILegacyMethods.java\n+++ b/src/org/easymock/internal/ILegacyMethods.java\n package org.easymock.internal;\n \n public interface ILegacyMethods extends ILegacyMatcherMethods {\n-    void setDefaultReturnValue(Object value);\n-\n-    void setDefaultThrowable(Throwable throwable);\n-\n-    void setDefaultVoidCallable();\n }\n--- a/src/org/easymock/internal/IMocksBehavior.java\n+++ b/src/org/easymock/internal/IMocksBehavior.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.easymock.internal;\n+\n+import org.mockito.internal.*;\n \n public interface IMocksBehavior extends ILegacyMatcherMethods {\n \n--- a/src/org/easymock/internal/IMocksControlState.java\n+++ b/src/org/easymock/internal/IMocksControlState.java\n  */\n package org.easymock.internal;\n \n-import org.easymock.IAnswer;\n+import org.mockito.internal.*;\n \n public interface IMocksControlState extends ILegacyMethods {\n \n--- a/src/org/easymock/internal/LastControl.java\n+++ b/src/org/easymock/internal/LastControl.java\n \n import java.util.*;\n \n-import org.easymock.IArgumentMatcher;\n-import org.easymock.internal.matchers.And;\n-import org.easymock.internal.matchers.Not;\n-import org.easymock.internal.matchers.Or;\n+import org.mockito.internal.matchers.*;\n \n public class LastControl {\n     private static final ThreadLocal<MocksControl> threadToControl = new ThreadLocal<MocksControl>();\n--- a/src/org/easymock/internal/LegacyMatcherProvider.java\n+++ b/src/org/easymock/internal/LegacyMatcherProvider.java\n \n import org.easymock.ArgumentsMatcher;\n import org.easymock.MockControl;\n+import org.mockito.internal.RuntimeExceptionWrapper;\n \n public class LegacyMatcherProvider {\n \n--- a/src/org/easymock/internal/MockInvocationHandler.java\n+++ b/src/org/easymock/internal/MockInvocationHandler.java\n import java.lang.reflect.InvocationHandler;\n import java.lang.reflect.Method;\n \n-import org.mockito.MockAwareInvocationHandler;\n+import org.mockito.internal.*;\n \n public class MockInvocationHandler implements InvocationHandler, MockAwareInvocationHandler {\n \n--- a/src/org/easymock/internal/MocksBehavior.java\n+++ b/src/org/easymock/internal/MocksBehavior.java\n \n import org.easymock.ArgumentsMatcher;\n import org.easymock.MockControl;\n+import org.mockito.internal.*;\n \n public class MocksBehavior implements IMocksBehavior {\n \n \n     public void addExpected(ExpectedInvocation expected, Result result,\n             Range count) {\n-        if (legacyMatcherProvider != null) {\n-            expected = expected.withMatcher(legacyMatcherProvider\n-                    .getMatcher(expected.getMethod()));\n-        }\n         addBehaviorListIfNecessary(expected);\n         lastBehaviorList().addExpected(expected, result, count);\n     }\n         }\n         throw new AssertionErrorWrapper(new AssertionError(\n                 \"\\n  Unexpected method call \"\n-                        + actual.toString(MockControl.EQUALS_MATCHER) + \":\"\n+                        + actual.toString() + \":\"\n                         + errorMessage.toString()));\n     }\n \n--- a/src/org/easymock/internal/MocksControl.java\n+++ b/src/org/easymock/internal/MocksControl.java\n package org.easymock.internal;\n \n import org.easymock.ArgumentsMatcher;\n-import org.easymock.IAnswer;\n import org.easymock.IExpectationSetters;\n import org.easymock.IMocksControl;\n+import org.mockito.internal.*;\n \n public class MocksControl implements IMocksControl {\n \n             throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n         }\n     }\n-\n-    public void setLegacyDefaultReturnValue(Object value) {\n-        try {\n-            state.setDefaultReturnValue(value);\n-        } catch (RuntimeExceptionWrapper e) {\n-            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n-        }\n-    }\n-\n-    public void setLegacyDefaultVoidCallable() {\n-        state.setDefaultVoidCallable();\n-    }\n-\n-    public void setLegacyDefaultThrowable(Throwable throwable) {\n-        try {\n-            state.setDefaultThrowable(throwable);\n-        } catch (RuntimeExceptionWrapper e) {\n-            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n-        }\n-    }\n }\n--- a/src/org/easymock/internal/Range.java\n+++ b/src/org/easymock/internal/Range.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.easymock.internal;\n+\n+import org.mockito.internal.RuntimeExceptionWrapper;\n \n public class Range {\n     private int minimum;\n--- a/src/org/easymock/internal/RecordState.java\n+++ b/src/org/easymock/internal/RecordState.java\n import java.util.*;\n \n import org.easymock.ArgumentsMatcher;\n-import org.easymock.IAnswer;\n-import org.easymock.IArgumentMatcher;\n import org.easymock.MockControl;\n+import org.mockito.internal.*;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n \n public class RecordState implements IMocksControlState {\n \n         lastInvocationUsed = true;\n     }\n \n-    public void setDefaultReturnValue(Object value) {\n-        requireMethodCall(\"default return value\");\n-        value = convertNumberClassIfNeccessary(value);\n-        requireAssignable(value);\n-        if (lastResult != null) {\n-            times(MocksControl.ONCE);\n-        }\n-        behavior.addStub(\n-                lastInvocation.withMatcher(MockControl.ALWAYS_MATCHER), Result\n-                        .createReturnResult(value));\n-        lastInvocationUsed = true;\n-    }\n-\n     public void asStub() {\n         requireMethodCall(\"stub behavior\");\n         requireVoidMethod();\n         lastInvocationUsed = true;\n     }\n \n-    public void setDefaultVoidCallable() {\n-        requireMethodCall(\"default void callable\");\n-        requireVoidMethod();\n-        behavior.addStub(\n-                lastInvocation.withMatcher(MockControl.ALWAYS_MATCHER), Result\n-                        .createReturnResult(null));\n-        lastInvocationUsed = true;\n-    }\n-\n     public void andStubThrow(Throwable throwable) {\n         requireMethodCall(\"stub Throwable\");\n         requireValidThrowable(throwable);\n             times(MocksControl.ONCE);\n         }\n         behavior.addStub(lastInvocation, Result.createThrowResult(throwable));\n-        lastInvocationUsed = true;\n-    }\n-\n-    public void setDefaultThrowable(Throwable throwable) {\n-        requireMethodCall(\"default Throwable\");\n-        requireValidThrowable(throwable);\n-        if (lastResult != null) {\n-            times(MocksControl.ONCE);\n-        }\n-        behavior.addStub(\n-                lastInvocation.withMatcher(MockControl.ALWAYS_MATCHER), Result\n-                        .createThrowResult(throwable));\n         lastInvocationUsed = true;\n     }\n \n         }\n         Class<?> returnedType = lastInvocation.getMethod().getReturnType();\n         if (returnedType.isPrimitive()) {\n-            returnedType = ToTypeMappings.primitiveToWrapperType.get(returnedType);\n+            returnedType = null;//ToTypeMappings.primitiveToWrapperType.get(returnedType);\n         }\n         if (!returnedType.isAssignableFrom(returnValue.getClass())) {\n             throw new RuntimeExceptionWrapper(new IllegalStateException(\n--- a/src/org/easymock/internal/ReplayState.java\n+++ b/src/org/easymock/internal/ReplayState.java\n import java.lang.reflect.Method;\n \n import org.easymock.ArgumentsMatcher;\n-import org.easymock.IAnswer;\n+import org.mockito.internal.*;\n \n public class ReplayState implements IMocksControlState {\n \n--- a/src/org/easymock/internal/Results.java\n+++ b/src/org/easymock/internal/Results.java\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n+\n+import org.mockito.internal.*;\n \n public class Results {\n \n--- a/src/org/easymock/internal/UnorderedBehavior.java\n+++ b/src/org/easymock/internal/UnorderedBehavior.java\n \n import java.util.ArrayList;\n import java.util.List;\n+\n+import org.mockito.internal.*;\n \n public class UnorderedBehavior {\n \n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n package org.mockito;\n \n-import org.easymock.internal.LastArguments;\n-import org.easymock.internal.matchers.*;\n+import org.mockito.internal.LastArguments;\n+import org.mockito.internal.matchers.*;\n+import org.mockito.matchers.*;\n \n public class Matchers {\n     \n     /**\n      * Expects a comparable argument greater than or equal the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n     \n     /**\n      * Expects a byte argument greater than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a double argument greater than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a float argument greater than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects an int argument greater than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a long argument greater than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a short argument greater than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a comparable argument less than or equal the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n      \n     /**\n      * Expects a byte argument less than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a double argument less than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a float argument less than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects an int argument less than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a long argument less than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a short argument less than or equal to the given value. For\n-     * details, see the EasyMock documentation.\n+     * details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a comparable argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n     \n     /**\n      * Expects a byte argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a double argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a float argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects an int argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a long argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a short argument greater than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a comparable argument less than the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param value\n      *            the given value.\n     \n     /**\n      * Expects a byte argument less than the given value. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a double argument less than the given value. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a float argument less than the given value. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects an int argument less than the given value. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a long argument less than the given value. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects a short argument less than the given value. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param value\n      *            the given value.\n     \n     /**\n      * Expects a string that contains the given substring. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param substring\n      *            the substring.\n \n     /**\n      * Expects a comparable argument equals to the given value according to their\n-     * compareTo method. For details, see the EasyMock documentation.\n+     * compareTo method. For details, see the documentation.\n      * \n      * @param value\n      *            the given value.\n \n     /**\n      * Expects an Object that is the same as the given value. For details, see\n-     * the EasyMock documentation.\n+     * the documentation.\n      * \n      * @param <T>\n      *            the type of the object, it is passed through to prevent casts.\n \n     /**\n      * Expects a string that ends with the given suffix. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param suffix\n      *            the suffix.\n \n     /**\n      * Expects a string that starts with the given prefix. For details, see the\n-     * EasyMock documentation.\n+     * documentation.\n      * \n      * @param prefix\n      *            the prefix.\n \n     /**\n      * Expects a string that contains a substring that matches the given regular\n-     * expression. For details, see the EasyMock documentation.\n+     * expression. For details, see the documentation.\n      * \n      * @param regex\n      *            the regular expression.\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n package org.mockito;\n \n-import org.easymock.internal.*;\n import org.mockito.exceptions.NotAMockMethodException;\n-import org.mockito.matchers.*;\n+import org.mockito.hamcrest.*;\n+import org.mockito.internal.*;\n \n public class Mockito {\n \n--- /dev/null\n+++ b/src/org/mockito/hamcrest/HasNoIvocationsMatcher.java\n+/**\n+ * \n+ */\n+package org.mockito.hamcrest;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+\n+public class HasNoIvocationsMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n+    \n+    private final T mock;\n+\n+    public HasNoIvocationsMatcher(T mock) {\n+        this.mock = mock;\n+    }\n+    \n+    public boolean matches(Object arg0) {\n+        return false;\n+    }\n+\n+    public void describeTo(Description arg0) {\n+    };\n+    \n+    public T getMock() {\n+        return mock;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/hamcrest/HasNoMoreIvocationsMatcher.java\n+/**\n+ * \n+ */\n+package org.mockito.hamcrest;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+\n+public class HasNoMoreIvocationsMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n+    \n+    private final T mock;\n+\n+    public HasNoMoreIvocationsMatcher(T mock) {\n+        this.mock = mock;\n+    }\n+    \n+    public boolean matches(Object arg0) {\n+        return false;\n+    }\n+\n+    public void describeTo(Description arg0) {\n+    };\n+    \n+    public T getMock() {\n+        return mock;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/hamcrest/MockitoMatcher.java\n+package org.mockito.hamcrest;\n+\n+import org.hamcrest.Matcher;\n+\n+public interface MockitoMatcher<T> extends Matcher<T> {\n+    T getMock();\n+}\n--- /dev/null\n+++ b/src/org/mockito/hamcrest/WasInvokedMatcher.java\n+/**\n+ * \n+ */\n+package org.mockito.hamcrest;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+\n+public class WasInvokedMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n+    private final T mock;\n+    private final int exactNumberOfInvocations;\n+\n+    public WasInvokedMatcher(T mock) {\n+        this(mock, -1);\n+    }\n+    \n+    public WasInvokedMatcher(T mock, int exactNumberOfInvocations) {\n+        this.mock = mock;\n+        this.exactNumberOfInvocations = exactNumberOfInvocations;\n+    }\n+\n+    public boolean matches(Object arg0) {\n+        return true;\n+    }\n+\n+    public void describeTo(Description arg0) {\n+    }\n+\n+    public T getMock() {\n+        return mock;\n+    }\n+\n+    public int getExactNumberOfInvocations() {\n+        return exactNumberOfInvocations;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/ClassProxyFactory.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.*;\n+import java.lang.reflect.InvocationHandler;\n+import java.util.*;\n+\n+import net.sf.cglib.core.*;\n+import net.sf.cglib.proxy.*;\n+\n+import org.mockito.*;\n+import org.mockito.internal.*;\n+\n+/**\n+ * Factory generating a mock for a class.\n+ * <p>\n+ * Note that this class is stateful\n+ */\n+public class ClassProxyFactory<T> {\n+\n+    public static interface MockMethodInterceptor extends MethodInterceptor {\n+        InvocationHandler getHandler();\n+\n+        void setMockedMethods(Method[] mockedMethods);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T createProxy(Class<T> toMock, final MockAwareInvocationHandler handler) {\n+\n+        // Dirty trick to fix MockitoObjectMethodsFilter\n+        // It will replace the equals, hashCode, toString methods it kept that\n+        // are the ones\n+        // from Object.class by the correct ones since they might have been\n+        // overloaded\n+        // in the mocked class.\n+    \tif (!toMock.isInterface()) {\n+\t        try {\n+\t        \t\n+\t            updateMethod(handler, toMock.getMethod(\"equals\",\n+\t                    new Class[] { Object.class }));\n+\t            updateMethod(handler, toMock.getMethod(\"hashCode\", new Class[0]));\n+\t            updateMethod(handler, toMock.getMethod(\"toString\", new Class[0]));\n+\t        } catch (NoSuchMethodException e) {\n+\t            throw new RuntimeException(\n+\t                    \"We strangly failed to retrieve methods that always exist on an object...\");\n+\t        }\n+    \t}\n+\n+        MethodInterceptor interceptor = new MockMethodInterceptor() {\n+\n+            private Set<Method> mockedMethods;\n+\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                if (method.isBridge()) {\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+                if (mockedMethods != null && !mockedMethods.contains(method)) {\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+                return handler.invoke(obj, method, args);\n+            }\n+\n+            public InvocationHandler getHandler() {\n+                return handler;\n+            }\n+\n+            public void setMockedMethods(Method[] mockedMethods) {\n+                this.mockedMethods = new HashSet<Method>(Arrays\n+                        .asList(mockedMethods));\n+            }\n+        };\n+\n+        // Create the mock\n+        Enhancer enhancer = new Enhancer() {\n+            /**\n+             * Filter all private constructors but do not check that there are\n+             * some left\n+             */\n+            protected void filterConstructors(Class sc, List constructors) {\n+                CollectionUtils.filter(constructors, new VisibilityPredicate(\n+                        sc, true));\n+            }\n+        };\n+        \n+        //TODO not tested\n+        if (toMock.isInterface()) {\n+\t\t\tenhancer.setInterfaces(new Class[] { toMock });\n+\t\t} else {\n+\t\t\tenhancer.setSuperclass(toMock);\n+\t\t}\n+        \n+        enhancer.setCallbackType(interceptor.getClass());\n+\n+        Class mockClass = enhancer.createClass();\n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+\n+        Factory mock;\n+        try {\n+            mock = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(\"Fail to instantiate mock for \" + toMock\n+                    + \" on \" + System.getProperty(\"java.vm.vendor\") + \" JVM\");\n+        }\n+\n+        // This call is required. Cglib has some \"magic code\" making sure a\n+        // callback is used by only one instance of a given class. So only the\n+        // instance created right after registering the callback will get it.\n+        // However, this is done in the construtor which I'm bypassing to\n+        // allow class instantiation without calling a constructor.\n+        // Fortunatly, the \"magic code\" is also called in getCallback which is\n+        // why I'm calling it here mock.getCallback(0);\n+        mock.getCallback(0);\n+\n+        handler.setMock(mock);\n+        return (T) mock;\n+    }\n+\n+    private void updateMethod(InvocationHandler objectMethodsFilter,\n+            Method correctMethod) {\n+        Field methodField = retrieveField(MockitoObjectMethodsFilter.class,\n+                correctMethod.getName() + \"Method\");\n+        updateField(objectMethodsFilter, correctMethod, methodField);\n+    }\n+\n+    private Field retrieveField(Class clazz, String field) {\n+        try {\n+            return clazz.getDeclaredField(field);\n+        } catch (NoSuchFieldException e) {\n+            throw new InternalError(\n+                    \"There must be some refactoring because the \" + field\n+                            + \" field was there...\");\n+        }\n+    }\n+\n+    private void updateField(Object instance, Object value, Field field) {\n+        boolean accessible = field.isAccessible();\n+        field.setAccessible(true);\n+        try {\n+            field.set(instance, value);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\n+                    \"Should be accessible since we set it ourselves\");\n+        }\n+        field.setAccessible(accessible);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/ExpectedInvocation.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.mockito.internal.matchers.*;\n+\n+public class ExpectedInvocation {\n+\n+    protected final Invocation invocation;\n+\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public ExpectedInvocation(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        this.invocation = invocation;\n+        this.matchers = createMissingMatchers(invocation, matchers);\n+    }\n+\n+    private List<IArgumentMatcher> createMissingMatchers(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        if (matchers != null) {\n+            if (matchers.size() != invocation.getArguments().length) {\n+                throw new IllegalStateException(\"\"\n+                        + invocation.getArguments().length\n+                        + \" matchers expected, \" + matchers.size()\n+                        + \" recorded.\");\n+            }\n+            ;\n+            return matchers;\n+        }\n+        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !this.getClass().equals(o.getClass()))\n+            return false;\n+\n+        ExpectedInvocation other = (ExpectedInvocation) o;\n+        return this.invocation.equals(other.invocation)\n+                && ((this.matchers == null && other.matchers == null) || (this.matchers != null && this.matchers\n+                        .equals(other.matchers)));\n+    }\n+\n+    public int hashCode() {\n+        return 1;\n+    }\n+\n+    public boolean matches(Invocation actual) {\n+        return this.invocation.getMock().equals(\n+                actual.getMock())\n+                && this.invocation.getMethod().equals(actual.getMethod())\n+                && matches(actual.getArguments());\n+    }\n+\n+    private boolean matches(Object[] arguments) {\n+        if (arguments.length != matchers.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!matchers.get(i).matches(arguments[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String toString() {\n+        StringBuffer result = new StringBuffer();\n+        result.append(invocation.getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(result);\n+            if (it.hasNext()) {\n+                result.append(\", \");\n+            }\n+        }\n+        result.append(\")\");\n+        return result.toString();\n+    }\n+\n+    public Method getMethod() {\n+        return invocation.getMethod();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/IAnswer.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+/**\n+ * Used to answer expected calls.\n+ * @param <T> the type to return.\n+ */\n+public interface IAnswer<T> {\n+    /**\n+     * is called to answer an expected call. \n+     * The answer may be to return a value, or to throw an exception.\n+     * The arguments of the call for which the answer is generated \n+     * are available via getCurrentArguments() - be careful\n+     * here, using the arguments is not refactoring-safe.\n+     * \n+     * @return the value to be returned\n+     * @throws Throwable the throwable to be thrown\n+     */\n+    T answer() throws Throwable;\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/Invocation.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static java.lang.Character.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.internal.matchers.ArrayEquals;\n+\n+public class Invocation {\n+\n+    private final Object mock;\n+\n+    private final Method method;\n+\n+    private final Object[] arguments;\n+\n+    public Invocation(Object mock, Method method, Object[] args) {\n+        this.mock = mock;\n+        this.method = method;\n+        this.arguments = expandVarArgs(method.isVarArgs(), args);\n+    }\n+\n+    private static Object[] expandVarArgs(final boolean isVarArgs,\n+            final Object[] args) {\n+        if (!isVarArgs || isVarArgs && args[args.length - 1] != null\n+                && !args[args.length - 1].getClass().isArray()) {\n+            return args == null ? new Object[0] : args;\n+        }\n+        Object[] varArgs = ArrayEquals.createObjectArray(args[args.length - 1]);\n+        final int nonVarArgsCount = args.length - 1;\n+        final int varArgsCount = varArgs.length;\n+        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n+        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n+        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n+        return newArgs;\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !o.getClass().equals(this.getClass()))\n+            return false;\n+\n+        Invocation other = (Invocation) o;\n+\n+        return this.mock.equals(other.mock) && this.method.equals(other.method)\n+                && this.equalArguments(other.arguments);\n+    }\n+\n+    public int hashCode() {\n+        throw new UnsupportedOperationException(\"hashCode() is not implemented\");\n+    }\n+\n+    private boolean equalArguments(Object[] arguments) {\n+        if (this.arguments.length != arguments.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < this.arguments.length; i++) {\n+            Object myArgument = this.arguments[i];\n+            Object otherArgument = arguments[i];\n+\n+            if (isPrimitiveParameter(i)) {\n+                if (!myArgument.equals(otherArgument)) {\n+                    return false;\n+                }\n+            } else {\n+                if (myArgument != otherArgument) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isPrimitiveParameter(int parameterPosition) {\n+        Class<?>[] parameterTypes = method.getParameterTypes();\n+        if (method.isVarArgs()) {\n+            parameterPosition = Math.min(parameterPosition,\n+                    parameterTypes.length - 1);\n+        }\n+        return parameterTypes[parameterPosition].isPrimitive();\n+    }\n+\n+    public String getMockAndMethodName() {\n+        String mockName = mock.toString();\n+        String methodName = method.getName();\n+        if (toStringIsDefined(mock) && isJavaIdentifier(mockName)) {\n+            return mockName + \".\" + methodName;\n+        } else {\n+            return methodName;\n+        }\n+    }\n+\n+    private boolean toStringIsDefined(Object o) {\n+        try {\n+            o.getClass().getDeclaredMethod(\"toString\", (Class[]) null)\n+                    .getModifiers();\n+            return true;\n+        } catch (SecurityException ignored) {\n+            \n+            return false;\n+            \n+        } catch (NoSuchMethodException shouldNeverHappen) {\n+            \n+            throw new RuntimeException(\"The toString() method could not be found!\");\n+            \n+        }\n+    }\n+\n+    public static boolean isJavaIdentifier(String mockName) {\n+        if (mockName.length() == 0 || mockName.indexOf(' ') > -1\n+                || !Character.isJavaIdentifierStart(mockName.charAt(0))) {\n+            return false;\n+        }\n+        for (char c : mockName.substring(1).toCharArray()) {\n+            if (!isJavaIdentifierPart(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n+package org.mockito.internal;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+\n+public class InvocationWithMatchers extends ExpectedInvocation {\n+\n+    public InvocationWithMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        super(invocation, matchers);\n+    }\n+    \n+    public MockitoInvocation getInvocation() {\n+        return (MockitoInvocation) this.invocation;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/LastArguments.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.util.*;\n+\n+import org.mockito.internal.matchers.*;\n+\n+public class LastArguments {\n+    private static final ThreadLocal<Stack<Object[]>> threadToCurrentArguments = new ThreadLocal<Stack<Object[]>>();\n+\n+    private static final ThreadLocal<Stack<IArgumentMatcher>> threadToArgumentMatcherStack = new ThreadLocal<Stack<IArgumentMatcher>>();\n+\n+    public static synchronized void reportMatcher(IArgumentMatcher matcher) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        if (stack == null) {\n+            stack = new Stack<IArgumentMatcher>();\n+            threadToArgumentMatcherStack.set(stack);\n+        }\n+        stack.push(matcher);\n+    }\n+\n+    public static synchronized List<IArgumentMatcher> pullMatchers() {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        if (stack == null) {\n+            return null;\n+        }\n+        threadToArgumentMatcherStack.remove();\n+        return new ArrayList<IArgumentMatcher>(stack);\n+    }\n+\n+    public static synchronized void reportAnd(int count) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        stack.push(new And(popLastArgumentMatchers(count)));\n+    }\n+\n+    public static synchronized void reportNot() {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        stack.push(new Not(popLastArgumentMatchers(1).get(0)));\n+    }\n+\n+    private static List<IArgumentMatcher> popLastArgumentMatchers(int count) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        assertState(stack.size() >= count, \"\" + count + \" matchers expected, \"\n+                + stack.size() + \" recorded.\");\n+        List<IArgumentMatcher> result = new LinkedList<IArgumentMatcher>();\n+        result.addAll(stack.subList(stack.size() - count, stack.size()));\n+        for (int i = 0; i < count; i++) {\n+            stack.pop();\n+        }\n+        return result;\n+    }\n+\n+    private static void assertState(boolean toAssert, String message) {\n+        if (!toAssert) {\n+            threadToArgumentMatcherStack.remove();\n+            throw new IllegalStateException(message);\n+        }\n+    }\n+\n+    public static void reportOr(int count) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        stack.push(new Or(popLastArgumentMatchers(count)));\n+    }\n+\n+    public static Object[] getCurrentArguments() {\n+        Stack<Object[]> stack = threadToCurrentArguments.get();\n+        if (stack == null || stack.empty()) {\n+            return null;\n+        }\n+        return stack.lastElement();\n+    }\n+\n+    public static void pushCurrentArguments(Object[] args) {\n+        Stack<Object[]> stack = threadToCurrentArguments.get();\n+        if (stack == null) {\n+            stack = new Stack<Object[]>();\n+            threadToCurrentArguments.set(stack);\n+        }\n+        stack.push(args);\n+    }\n+\n+    public static void popCurrentArguments() {\n+        Stack<Object[]> stack = threadToCurrentArguments.get();\n+        stack.pop();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MethodSelector.java\n+package org.mockito.internal;\n+\n+public interface MethodSelector<T> {\n+    \n+    T on();\n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockAwareInvocationHandler.java\n+package org.mockito.internal;\n+\n+import java.lang.reflect.InvocationHandler;\n+\n+public interface MockAwareInvocationHandler extends InvocationHandler {\n+    void setMock(Object mock);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockUtil.java\n+/*\n+ * Copyright (c) 2007 Szczepan Faber \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import net.sf.cglib.proxy.*;\n+\n+import org.mockito.exceptions.NotAMockException;\n+import org.mockito.internal.ClassProxyFactory.MockMethodInterceptor;\n+\n+public class MockUtil {\n+    \n+    private static MockMethodInterceptor getInterceptor(Object mock) {\n+        Factory factory = (Factory) mock;\n+        return (MockMethodInterceptor) factory.getCallback(0);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> MockitoControl<T> getControl(T mock) {\n+        MockitoObjectMethodsFilter<MockitoControl<T>> handler;\n+\n+        try {\n+            if (Enhancer.isEnhanced(mock.getClass())) {\n+                handler = (MockitoObjectMethodsFilter) getInterceptor(mock)\n+                        .getHandler();\n+            } else {\n+                throw new NotAMockException(mock);\n+            }\n+            \n+            return handler.getDelegate();\n+        } catch (ClassCastException e) {\n+            throw new NotAMockException(mock);\n+        }\n+    }\n+    \n+    public static void validateMock(Object mock) {\n+        getControl(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n+package org.mockito.internal;\n+\n+import java.util.*;\n+\n+import org.mockito.exceptions.*;\n+\n+public class MockitoBehavior {\n+\n+    private List<InvocationWithMatchers> registeredInvocations = new LinkedList<InvocationWithMatchers>();\n+    private Map<InvocationWithMatchers, Result> results = new HashMap<InvocationWithMatchers, Result>();\n+    \n+    public void addInvocation(InvocationWithMatchers invocation) {\n+        this.registeredInvocations.add(invocation);\n+    }\n+\n+    public void addResult(Result result) {\n+        this.results.put(registeredInvocations.remove(registeredInvocations.size()-1), result);\n+    }\n+\n+    public void verify(InvocationWithMatchers invocation, VerifyingMode verifyingMode) {\n+        int actuallyInvoked = numberOfActualInvocations(invocation);\n+        \n+        if (verifyingMode.numberOfInvocationsMatters()) {\n+            int expectedInvoked = verifyingMode.getExactNumberOfInvocations();\n+            \n+            if (actuallyInvoked != expectedInvoked) {\n+                throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked);\n+            } \n+        } else {\n+            if (actuallyInvoked == 0) {\n+                throw new MockVerificationAssertionError();\n+            }\n+        }\n+    }\n+\n+    private int numberOfActualInvocations(InvocationWithMatchers expectedInvocation) {\n+        int verifiedInvocations = 0;\n+        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n+            MockitoInvocation invocation = registeredInvocation.getInvocation();\n+            if (expectedInvocation.matches(invocation)) {\n+                verifiedInvocations += 1;\n+                invocation.markVerified();\n+            } else {\n+                verifiedInvocations += 0;\n+            }\n+        }\n+\n+        return verifiedInvocations;\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n+            if (!registeredInvocation.getInvocation().isVerified()) {\n+                throw new MockVerificationAssertionError();\n+            }\n+        }\n+    }\n+\n+    public Object resultFor(MockitoInvocation invocation) throws Throwable {\n+        for (InvocationWithMatchers invocationWithMatchers : results.keySet()) {\n+            if (invocationWithMatchers.matches(invocation)) {\n+                return results.get(invocationWithMatchers).answer();\n+            }\n+        }\n+\n+        return ToTypeMappings.emptyReturnValueFor(invocation.getMethod().getReturnType());\n+    }\n+\n+    public MockitoInvocation lastInvocation() {\n+        return registeredInvocations.get(registeredInvocations.size() - 1).getInvocation();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoControl.java\n+package org.mockito.internal;\n+\n+import java.lang.reflect.*;\n+import java.util.List;\n+\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+\n+public class MockitoControl<T> implements MockAwareInvocationHandler, InvocationHandler, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n+\n+    private MockitoBehavior behavior = new MockitoBehavior();\n+    private Object mock;\n+    \n+    public MockitoControl() {}\n+\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+        List<IArgumentMatcher> lastMatchers = LastArguments.pullMatchers();\n+\n+        MockitoInvocation invocation = new MockitoInvocation(proxy, method, args);\n+        InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, lastMatchers);\n+        \n+        if (MockitoOperations.mockVerificationScenario()) {\n+            VerifyingMode verifyingMode = MockitoOperations.removeVerifyingMode();\n+            \n+            behavior.verify(invocationWithMatchers, verifyingMode);\n+            return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n+        }\n+        \n+        MockitoOperations.reportLastControlForStubbing(this);\n+        \n+        behavior.addInvocation(invocationWithMatchers);\n+        \n+        if (MockitoOperations.settingThrowableOnVoidMethodScenario()) {\n+            Throwable throwable = MockitoOperations.removeThrowableToBeSetOnVoidMethod();\n+        \n+            andThrows(throwable);\n+            return null;\n+        }\n+\n+        return behavior.resultFor(invocation);\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        behavior.verifyNoMoreInteractions();\n+    }\n+\n+    public void andReturn(T value) {\n+//      TODO count number of andReturn vs number of stubbing\n+//      TODO why do we need that in easy_Mock: value = convertNumberClassIfNeccessary(value);\n+        behavior.addResult(Result.createReturnResult(value));\n+    }\n+\n+    public void andThrows(Throwable throwable) {\n+        validateThrowable(throwable);\n+        //TODO count number of andReturn vs number of stubbing\n+        behavior.addResult(Result.createThrowResult(throwable));\n+    }\n+    \n+    private void validateThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            throw new IllegalArgumentException(\"Cannot set null throwable\");\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+    \n+        if (! isValidCheckedException(throwable)) {\n+            throw new IllegalArgumentException(\"Given checked exception is invalid for this method\"); \n+        }\n+    }\n+\n+    private boolean isValidCheckedException(Throwable throwable) {\n+        MockitoInvocation lastInvocation = behavior.lastInvocation();\n+\n+        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+\n+    public MethodSelector<T> toThrow(Throwable throwable) {\n+        //TODO refactor so we don't use static state to keep the throwable\n+        MockitoOperations.reportThrowableToBeSetOnVoidMethod(throwable);\n+        return this;\n+    }\n+\n+    public T on() {\n+        // TODO check if mock can be of the type T\n+        return (T) mock;\n+    }\n+\n+    public void setMock(Object mock) {\n+        this.mock = mock;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoExpectation.java\n+package org.mockito.internal;\n+\n+\n+public interface MockitoExpectation<T> {\n+\n+    void andReturn(T value);\n+\n+    void andThrows(Throwable throwable);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoInvocation.java\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+\n+\n+//TODO kill this class and move verified to InvocationWithMatchers\n+public class MockitoInvocation extends Invocation {\n+\n+    private boolean verified;\n+\n+    public MockitoInvocation(Object mock, Method method, Object[] args) {\n+        super(mock, method, args);\n+    }\n+\n+    public void markVerified() {\n+        verified = true;\n+    }\n+\n+    public boolean isVerified() {\n+        return verified;\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        return 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoObjectMethodsFilter.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.internal.*;\n+\n+//TODO rename\n+public class MockitoObjectMethodsFilter<T extends MockAwareInvocationHandler> implements MockAwareInvocationHandler {\n+    private final Method equalsMethod;\n+\n+    private final Method hashCodeMethod;\n+\n+    private final Method toStringMethod;\n+\n+    private final T delegate;\n+\n+    private final String name;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MockitoObjectMethodsFilter(Class toMock, T delegate,\n+            String name) {\n+        if (name != null && !Invocation.isJavaIdentifier(name)) {\n+            throw new IllegalArgumentException(String.format(\"'%s' is not a valid Java identifier.\", name));\n+            \n+        }\n+        try {\n+            if (toMock.isInterface()) {\n+                toMock = Object.class;\n+            }\n+            equalsMethod = toMock.getMethod(\"equals\",\n+                    new Class[] { Object.class });\n+            hashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n+            toStringMethod = toMock.getMethod(\"toString\", (Class[]) null);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"An Object method could not be found!\");\n+        }\n+        this.delegate = delegate;\n+        this.name = name;\n+    }\n+\n+    public final Object invoke(Object proxy, Method method, Object[] args)\n+            throws Throwable {\n+        if (equalsMethod.equals(method)) {\n+            return Boolean.valueOf(proxy == args[0]);\n+        }\n+        if (hashCodeMethod.equals(method)) {\n+            return new Integer(System.identityHashCode(proxy));\n+        }\n+        if (toStringMethod.equals(method)) {\n+            return mockToString(proxy);\n+        }\n+        return delegate.invoke(proxy, method, args);\n+    }\n+\n+    private String mockToString(Object proxy) {\n+        return (name != null) ? name : \"Mock for \" + mockType(proxy);\n+    }\n+\n+    private String mockType(Object proxy) {\n+\t\tif (proxy.getClass().getInterfaces().length == 2) {\n+\t\t\treturn proxy.getClass().getInterfaces()[0].getSimpleName();\n+\t\t} else {\n+\t\t\treturn proxy.getClass().getSuperclass().getSimpleName();\n+\t\t}\n+\t}\n+\n+    public T getDelegate() {\n+        return delegate;\n+    }\n+\n+    public void setMock(Object mock) {\n+        delegate.setMock(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoOperations.java\n+package org.mockito.internal;\n+\n+/**\n+ * static state. therefore dangerous and may have nasty bugs.\n+ * TODO look at every method that changes state and make sure the state is cleared afterwards\n+ * \n+ * @author sfaber\n+ */\n+public class MockitoOperations {\n+    \n+    private final static ThreadLocal<MockitoControl> controlForStubbing = new ThreadLocal<MockitoControl>();\n+    private final static ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n+    private final static ThreadLocal<Throwable> throwableToBeSetOnVoidMethod = new ThreadLocal<Throwable>();\n+\n+    public static synchronized void reportLastControlForStubbing(MockitoControl mockitoControl) {\n+        controlForStubbing.set(mockitoControl);\n+    }\n+\n+    public static synchronized MockitoExpectation controlToBeStubbed() {\n+        return controlForStubbing.get();\n+    }\n+    \n+    public static synchronized void reportVerifyingMode(VerifyingMode verify) {\n+        verifyingModeLocal.set(verify);\n+    }\n+\n+    public static synchronized boolean mockVerificationScenario() {\n+        return verifyingModeLocal.get() != null; \n+    }\n+\n+    public static synchronized VerifyingMode removeVerifyingMode() {\n+        VerifyingMode verifyingMode = verifyingModeLocal.get();\n+        verifyingModeLocal.set(null);\n+        return verifyingMode;\n+    }\n+\n+    public static void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n+        throwableToBeSetOnVoidMethod.set(throwable);\n+    }\n+\n+    public static Throwable removeThrowableToBeSetOnVoidMethod() {\n+        Throwable throwable = throwableToBeSetOnVoidMethod.get();\n+        throwableToBeSetOnVoidMethod.set(null);\n+        return throwable;\n+    }\n+\n+    public static boolean settingThrowableOnVoidMethodScenario() {\n+        return throwableToBeSetOnVoidMethod.get() != null; \n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/ObjenesisClassInstantiator.java\n+package org.mockito.internal;\n+\n+import org.objenesis.ObjenesisHelper;\n+\n+public class ObjenesisClassInstantiator {\n+\n+    public static Object newInstance(Class clazz) throws InstantiationException {\n+        return ObjenesisHelper.newInstance(clazz);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/Result.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+\n+public class Result implements IAnswer {\n+\n+    private IAnswer value;\n+\n+    private Result(IAnswer value) {\n+        this.value = value;\n+    }\n+\n+    public static Result createThrowResult(final Throwable throwable) {\n+        return new Result(new IAnswer<Object>() {\n+            public Object answer() throws Throwable {\n+                throw throwable;\n+            }\n+        });\n+    }\n+    public static Result createReturnResult(final Object value) {\n+\n+        return new Result(new IAnswer<Object>() {\n+            public Object answer() throws Throwable {\n+                return value;\n+            }\n+        });\n+    }\n+\n+    public static Result createAnswerResult(IAnswer answer) {\n+        return new Result(answer);\n+    }\n+\n+    public Object answer() throws Throwable {\n+        return value.answer();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/RuntimeExceptionWrapper.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+public class RuntimeExceptionWrapper extends RuntimeException {\n+    private final RuntimeException runtimeException;\n+\n+    public RuntimeExceptionWrapper(final RuntimeException runtimeException) {\n+        this.runtimeException = runtimeException;\n+    }\n+\n+    public RuntimeException getRuntimeException() {\n+        return runtimeException;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/ToTypeMappings.java\n+package org.mockito.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+public class ToTypeMappings {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Class> primitiveToWrapperType = new HashMap<Class, Class>();\n+\n+    static {\n+        primitiveToWrapperType.put(Boolean.TYPE, Boolean.class);\n+        primitiveToWrapperType.put(Byte.TYPE, Byte.class);\n+        primitiveToWrapperType.put(Short.TYPE, Short.class);\n+        primitiveToWrapperType.put(Character.TYPE, Character.class);\n+        primitiveToWrapperType.put(Integer.TYPE, Integer.class);\n+        primitiveToWrapperType.put(Long.TYPE, Long.class);\n+        primitiveToWrapperType.put(Float.TYPE, Float.class);\n+        primitiveToWrapperType.put(Double.TYPE, Double.class);\n+    }\n+    \n+    public static Object emptyReturnValueFor(Class type) {\n+        return emptyReturnValueToType.get(type);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n+    \n+    static {\n+        emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());\n+        \n+        emptyReturnValueToType.put(Set.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(HashSet.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(SortedSet.class, new TreeSet<Object>());        \n+        emptyReturnValueToType.put(TreeSet.class, new TreeSet<Object>());\n+        emptyReturnValueToType.put(LinkedHashSet.class, new LinkedHashSet<Object>());        \n+\n+        emptyReturnValueToType.put(List.class, new LinkedList<Object>());       \n+        emptyReturnValueToType.put(LinkedList.class, new LinkedList<Object>());\n+        emptyReturnValueToType.put(ArrayList.class, new ArrayList<Object>());\n+        \n+        emptyReturnValueToType.put(Map.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(HashMap.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(SortedMap.class, new TreeMap<Object, Object>());        \n+        emptyReturnValueToType.put(TreeMap.class, new TreeMap<Object, Object>());\n+        emptyReturnValueToType.put(LinkedHashMap.class, new LinkedHashMap<Object, Object>());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/VerifyingMode.java\n+package org.mockito.internal;\n+\n+import org.mockito.exceptions.MockVerificationAssertionError;\n+\n+public class VerifyingMode {\n+\n+    private static final int ANY_NUMBER_OF_TIMES = -1;\n+    private final int exactNumberOfInvocations;\n+\n+    public VerifyingMode(int exactNumberOfTimes) {\n+        this.exactNumberOfInvocations = exactNumberOfTimes;\n+    }\n+    \n+    public static VerifyingMode anyTimes() {\n+        return new VerifyingMode(ANY_NUMBER_OF_TIMES);\n+    }\n+\n+    public static VerifyingMode times(int exactNumberOfInvocations) {\n+        if (exactNumberOfInvocations < 0) {\n+            throw new IllegalArgumentException(\"Negative value is not allowed here\");\n+        }\n+        return new VerifyingMode(exactNumberOfInvocations);\n+    }\n+\n+    public boolean numberOfInvocationsMatters() {\n+        return exactNumberOfInvocations != ANY_NUMBER_OF_TIMES;\n+    }\n+\n+    public int getExactNumberOfInvocations() {\n+        return exactNumberOfInvocations;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/VoidMethodExpectation.java\n+package org.mockito.internal;\n+\n+\n+public interface VoidMethodExpectation<T> {\n+\n+    MethodSelector<T> toThrow(Throwable throwable);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/And.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+\n+public class And implements IArgumentMatcher {\n+\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public And(List<IArgumentMatcher> matchers) {\n+        this.matchers = matchers;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        for (IArgumentMatcher matcher : matchers) {\n+            if (!matcher.matches(actual)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"and(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(buffer);\n+            if (it.hasNext()) {\n+                buffer.append(\", \");\n+            }\n+        }\n+        buffer.append(\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Any.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Any implements IArgumentMatcher {\n+\n+    public static final Any ANY = new Any();    \n+    \n+    private Any() {\n+        \n+    }\n+    \n+    public boolean matches(Object actual) {\n+        return true;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"<any>\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/ArrayEquals.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+public class ArrayEquals extends Equals {\n+\n+    public ArrayEquals(Object expected) {\n+        super(expected);\n+    }\n+\n+    public boolean matches(Object actual) {\n+        Object expected = getExpected();\n+        if (expected instanceof boolean[]\n+                && (actual == null || actual instanceof boolean[])) {\n+            return Arrays.equals((boolean[]) expected, (boolean[]) actual);\n+        } else if (expected instanceof byte[]\n+                && (actual == null || actual instanceof byte[])) {\n+            return Arrays.equals((byte[]) expected, (byte[]) actual);\n+        } else if (expected instanceof char[]\n+                && (actual == null || actual instanceof char[])) {\n+            return Arrays.equals((char[]) expected, (char[]) actual);\n+        } else if (expected instanceof double[]\n+                && (actual == null || actual instanceof double[])) {\n+            return Arrays.equals((double[]) expected, (double[]) actual);\n+        } else if (expected instanceof float[]\n+                && (actual == null || actual instanceof float[])) {\n+            return Arrays.equals((float[]) expected, (float[]) actual);\n+        } else if (expected instanceof int[]\n+                && (actual == null || actual instanceof int[])) {\n+            return Arrays.equals((int[]) expected, (int[]) actual);\n+        } else if (expected instanceof long[]\n+                && (actual == null || actual instanceof long[])) {\n+            return Arrays.equals((long[]) expected, (long[]) actual);\n+        } else if (expected instanceof short[]\n+                && (actual == null || actual instanceof short[])) {\n+            return Arrays.equals((short[]) expected, (short[]) actual);\n+        } else if (expected instanceof Object[]\n+                && (actual == null || actual instanceof Object[])) {\n+            return Arrays.equals((Object[]) expected, (Object[]) actual);\n+        } else {\n+            return super.matches(actual);\n+        }\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        if (getExpected() != null && getExpected().getClass().isArray()) {\n+            appendArray(createObjectArray(getExpected()), buffer);\n+        } else {\n+            super.appendTo(buffer);\n+        }\n+    }\n+\n+    private void appendArray(Object[] array, StringBuffer buffer) {\n+        buffer.append(\"[\");\n+        for (int i = 0; i < array.length; i++) {\n+            new Equals(array[i]).appendTo(buffer);\n+            if (i != array.length - 1) {\n+                buffer.append(\", \");\n+            }\n+        }\n+        buffer.append(\"]\");\n+    }\n+\n+    public static Object[] createObjectArray(Object array) {\n+        if (array instanceof Object[]) {\n+            return (Object[]) array;\n+        }\n+        Object[] result = new Object[Array.getLength(array)];\n+        for (int i = 0; i < Array.getLength(array); i++) {\n+            result[i] = Array.get(array, i);\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Compare.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Henri Tremblay.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+import java.util.Comparator;\n+\n+\n+public class Compare<T> implements IArgumentMatcher {\n+\n+    private T expected;\n+\n+    private Comparator<T> comparator;\n+\n+    private LogicalOperator operator;\n+\n+    public Compare(T expected, Comparator<T> comparator, LogicalOperator result) {\n+        this.expected = expected;\n+        this.comparator = comparator;\n+        this.operator = result;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(comparator + \"(\" + expected + \") \" + operator.getSymbol()\n+                + \" 0\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean matches(Object actual) {\n+        if(actual == null) {\n+            return false;\n+        }\n+        return operator.matchResult(comparator.compare((T) actual, expected));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/CompareEqual.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+public class CompareEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public CompareEqual(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"cmpEq\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result == 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/CompareTo.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public abstract class CompareTo<T extends Comparable<T>> implements IArgumentMatcher {\n+    private final Comparable<T> expected;\n+\n+    public CompareTo(Comparable<T> value) {\n+        this.expected = value;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean matches(Object actual) {\n+        \n+        if(!(actual instanceof Comparable)) {\n+            return false;\n+        }\n+        \n+        return matchResult(((Comparable) actual).compareTo(expected));\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(getName() + \"(\" + expected + \")\");\n+    }\n+    \n+    protected abstract String getName();\n+    \n+    protected abstract boolean matchResult(int result);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Contains.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Contains implements IArgumentMatcher {\n+\n+    private final String substring;\n+\n+    public Contains(String substring) {\n+        this.substring = substring;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String)\n+                && ((String) actual).indexOf(substring) >= 0;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"contains(\\\"\" + substring + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/EndsWith.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class EndsWith implements IArgumentMatcher {\n+\n+    private final String suffix;\n+\n+    public EndsWith(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String) && ((String) actual).endsWith(suffix);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"endsWith(\\\"\" + suffix + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Equals.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Equals implements IArgumentMatcher {\n+\n+    private final Object expected;\n+\n+    public Equals(Object expected) {\n+        this.expected = expected;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        if (this.expected == null) {\n+            return actual == null;\n+        }\n+        return expected.equals(actual);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        appendQuoting(buffer);\n+        buffer.append(expected);\n+        appendQuoting(buffer);\n+    }\n+\n+    private void appendQuoting(StringBuffer buffer) {\n+        if (expected instanceof String) {\n+            buffer.append(\"\\\"\");\n+        } else if (expected instanceof Character) {\n+            buffer.append(\"'\");\n+        }\n+    }\n+\n+    protected final Object getExpected() {\n+        return expected;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == null || !this.getClass().equals(o.getClass()))\n+            return false;\n+        Equals other = (Equals) o;\n+        return this.expected == null && other.expected == null\n+                || this.expected != null\n+                && this.expected.equals(other.expected);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        throw new UnsupportedOperationException(\"hashCode() is not supported\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class EqualsWithDelta implements IArgumentMatcher {\n+    private final Number expected;\n+\n+    private final Number delta;\n+\n+    public EqualsWithDelta(Number value, Number delta) {\n+        this.expected = value;\n+        this.delta = delta;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        Number actualNumber = (Number) actual;\n+        return expected.doubleValue() - delta.doubleValue() <= actualNumber\n+                .doubleValue()\n+                && actualNumber.doubleValue() <= expected.doubleValue()\n+                        + delta.doubleValue();\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"eq(\" + expected + \", \" + delta + \")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Find.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+import java.util.regex.Pattern;\n+\n+\n+public class Find implements IArgumentMatcher {\n+\n+    private final String regex;\n+\n+    public Find(String regex) {\n+        this.regex = regex;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String)\n+                && Pattern.compile(regex).matcher((String) actual).find();\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"find(\\\"\" + regex.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/GreaterOrEqual.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+public class GreaterOrEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public GreaterOrEqual(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"geq\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result >= 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/GreaterThan.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+public class GreaterThan<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public GreaterThan(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"gt\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result > 0;\n+    }    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/IArgumentMatcher.java\n+/*\n+ * Copyright (c) 2001-2006 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+/**\n+ * Decides whether an actual argument is accepted.\n+ */\n+public interface IArgumentMatcher {\n+    \n+    /**\n+     * Returns whether this matcher accepts the given argument. \n+     * <p>\n+     * Like Object.equals(), it should be aware that the argument passed might \n+     * be null and of any type. So you will usually start the method with an \n+     * instanceof and/or null check.\n+     * <p>\n+     * The method should <b>never</b> assert if the argument doesn't match. It\n+     * should only return false.\n+     * \n+     * @param argument the argument\n+     * @return whether this matcher accepts the given argument.\n+     */\n+    boolean matches(Object argument);\n+\n+    /**\n+     * Appends a string representation of this matcher to the given buffer. In case\n+     * of failure, the printed message will show this string to allow to know which\n+     * matcher was used for the failing call.\n+     * \n+     * @param buffer the buffer to which the string representation is appended.\n+     */\n+    void appendTo(StringBuffer buffer);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/InstanceOf.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class InstanceOf implements IArgumentMatcher {\n+\n+    private final Class<?> clazz;\n+\n+    public InstanceOf(Class clazz) {\n+        this.clazz = clazz;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual != null) && clazz.isAssignableFrom(actual.getClass());\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"isA(\" + clazz.getName() + \")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/LessOrEqual.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+public class LessOrEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public LessOrEqual(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"leq\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result <= 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/LessThan.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+public class LessThan<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public LessThan(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"lt\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result < 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/LogicalOperator.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Henri Tremblay.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+public enum LogicalOperator {\n+    LESS_THAN(\"<\") {\n+        public boolean matchResult(int result) {\n+            return result < 0;\n+        }\n+    },\n+    LESS_OR_EQUAL(\"<=\") {\n+        public boolean matchResult(int result) {\n+            return result <= 0;\n+        }\n+    },\n+    EQUAL(\"==\") {\n+        public boolean matchResult(int result) {\n+            return result == 0;\n+        }\n+    },\n+    GREATER_OR_EQUAL(\">=\") {\n+        public boolean matchResult(int result) {\n+            return result >= 0;\n+        }\n+    },\n+    GREATER(\">\") {\n+        public boolean matchResult(int result) {\n+            return result > 0;\n+        }\n+    };\n+    \n+    private String symbol;\n+    \n+    private LogicalOperator(String symbol) {\n+        this.symbol = symbol;\n+    }\n+    \n+    public String getSymbol() {\n+        return symbol;\n+    }\n+    \n+    public abstract boolean matchResult(int result);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Matches.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Matches implements IArgumentMatcher {\n+\n+    private final String regex;\n+\n+    public Matches(String regex) {\n+        this.regex = regex;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String) && ((String) actual).matches(regex);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"matches(\\\"\" + regex.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")\n+                + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Not.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Not implements IArgumentMatcher {\n+\n+    private final IArgumentMatcher first;\n+\n+    public Not(IArgumentMatcher first) {\n+        this.first = first;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return !first.matches(actual);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"not(\");\n+        first.appendTo(buffer);\n+        buffer.append(\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/NotNull.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class NotNull implements IArgumentMatcher {\n+\n+    public static final NotNull NOT_NULL = new NotNull();\n+    \n+    private NotNull() {\n+        \n+    }\n+    \n+    public boolean matches(Object actual) {\n+        return actual != null;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"notNull()\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Null.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Null implements IArgumentMatcher {\n+\n+    public static final Null NULL = new Null();\n+\n+    private Null() {\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return actual == null;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"isNull()\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Or.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+\n+public class Or implements IArgumentMatcher {\n+\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public Or(List<IArgumentMatcher> matchers) {\n+        this.matchers = matchers;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        for (IArgumentMatcher matcher : matchers) {\n+            if (matcher.matches(actual)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"or(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(buffer);\n+            if (it.hasNext()) {\n+                buffer.append(\", \");\n+            }\n+        }\n+        buffer.append(\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/Same.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class Same implements IArgumentMatcher {\n+\n+    private final Object expected;\n+\n+    public Same(Object expected) {\n+        this.expected = expected;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return expected == actual;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"same(\");\n+        appendQuoting(buffer);\n+        buffer.append(expected);\n+        appendQuoting(buffer);\n+        buffer.append(\")\");\n+    }\n+\n+    private void appendQuoting(StringBuffer buffer) {\n+        if (expected instanceof String) {\n+            buffer.append(\"\\\"\");\n+        } else if (expected instanceof Character) {\n+            buffer.append(\"'\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/StartsWith.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers;\n+\n+\n+public class StartsWith implements IArgumentMatcher {\n+\n+    private final String prefix;\n+\n+    public StartsWith(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String)\n+                && ((String) actual).startsWith(prefix);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"startsWith(\\\"\" + prefix + \"\\\")\");\n+    }\n+}\n--- a/test/org/mockito/InvocationTest.java\n+++ b/test/org/mockito/InvocationTest.java\n import org.easymock.internal.*;\n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.internal.Invocation;\n \n public class InvocationTest {\n \n             assertEquals(\"hashCode() is not implemented\", expected.getMessage());\n         }\n     }\n-\n-    @Test\n-    public void shouldDisplayMocksToStringIfValidJavaIdentifier()\n-            throws SecurityException, NoSuchMethodException {\n-        Method method = ToString.class.getMethod(\"aMethod\", new Class[0]);\n-        Invocation invocation = new Invocation(new ToString(\"validJavaIdentifier\"),\n-                method, null);\n-\n-        assertEquals(invocation.toString(new EqualsMatcher()),\n-                \"validJavaIdentifier.aMethod()\");\n-\n-        invocation = new Invocation(new ToString(\"no-valid-java-identifier\"),\n-                method, null);\n-\n-        assertEquals(invocation.toString(new EqualsMatcher()), \"aMethod()\");\n-\n-    }\n-    \n-    class ToString {\n-        private final String name;\n-\n-        public ToString(String name) {\n-            this.name = name;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-\n-        public void aMethod() {\n-        }\n-    }\n }\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n package org.mockito;\n \n import static org.junit.Assert.*;\n-import static org.mockito.MockUtil.*;\n+import static org.mockito.internal.MockUtil.*;\n \n import java.util.*;\n \n--- a/test/org/mockito/MockitoOperationsTest.java\n+++ b/test/org/mockito/MockitoOperationsTest.java\n \n import org.junit.Test;\n import org.mockito.*;\n+import org.mockito.internal.*;\n \n import static org.junit.Assert.*;\n \n--- a/test/org/mockito/VerifyingModeTest.java\n+++ b/test/org/mockito/VerifyingModeTest.java\n package org.mockito;\n \n import org.junit.Test;\n-import org.mockito.VerifyingMode;\n+import org.mockito.internal.VerifyingMode;\n \n import static org.junit.Assert.*;\n \n--- a/test/org/mockito/internal/CglibTest.java\n+++ b/test/org/mockito/internal/CglibTest.java\n import net.sf.cglib.proxy.MethodInterceptor;\n import net.sf.cglib.proxy.MethodProxy;\n \n-import org.easymock.ObjenesisClassInstantiator;\n import org.junit.Test;\n \n /**\n--- a/test/org/mockito/internal/ClassProxyFactoryTest.java\n+++ b/test/org/mockito/internal/ClassProxyFactoryTest.java\n \n import java.lang.reflect.Method;\n \n-import org.easymock.internal.ClassProxyFactory;\n import org.junit.*;\n-import org.mockito.MockAwareInvocationHandler;\n \n public class ClassProxyFactoryTest {\n \n--- a/test/org/mockito/internal/ToTypeMappingsTest.java\n+++ b/test/org/mockito/internal/ToTypeMappingsTest.java\n \n import java.util.*;\n \n-import org.easymock.internal.ToTypeMappings;\n import org.junit.Test;\n \n public class ToTypeMappingsTest {\n--- a/test/org/mockito/internal/matchers/EqualsTest.java\n+++ b/test/org/mockito/internal/matchers/EqualsTest.java\n \n import static org.junit.Assert.*;\n \n-import org.easymock.internal.matchers.Equals;\n import org.junit.Test;\n \n \n--- a/test/org/mockito/usage/MockitoExploitsTest.java\n+++ b/test/org/mockito/usage/MockitoExploitsTest.java\n import org.junit.*;\n import org.mockito.*;\n import org.mockito.exceptions.*;\n+import org.mockito.internal.MockitoOperations;\n \n /**\n  * TODO find out what is important to protect ourselves and what's just too defensive \n--- a/test/org/mockito/usage/matchers/ComparableMatchersTest.java\n+++ b/test/org/mockito/usage/matchers/ComparableMatchersTest.java\n \n import org.easymock.internal.matchers.*;\n import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n+import org.mockito.matchers.*;\n \n //TODO do we need matchers like GreaterThan - does it make any sense?\n public class ComparableMatchersTest {\n--- a/test/org/mockito/usage/matchers/MatchersToStringTest.java\n+++ b/test/org/mockito/usage/matchers/MatchersToStringTest.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.easymock.IArgumentMatcher;\n import org.easymock.internal.matchers.*;\n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n+import org.mockito.matchers.*;\n \n public class MatchersToStringTest {\n     private StringBuffer buffer;", "timestamp": 1195318867, "metainfo": ""}