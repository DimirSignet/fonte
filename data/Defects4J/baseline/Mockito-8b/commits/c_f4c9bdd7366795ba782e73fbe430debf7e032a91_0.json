{"sha": "f4c9bdd7366795ba782e73fbe430debf7e032a91", "log": "Refactored towards simplicity (around the way MockHandler dealt with spies). Figured out a slight bug to fix soon.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401456", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     public static <T> T spy(T object) {\n         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                 .spiedInstance(object)\n-                .defaultAnswer(RETURNS_DEFAULTS));\n+                .defaultAnswer(CALLS_REAL_METHODS));\n     }\n \n     /**\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n \n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.exceptions.base.ConditionalStackTraceFilter;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n         OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n         mockingProgress.reportOngoingStubbing(ongoingStubbing);\n \n-        Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n-        if (!invocation.isVoid() && answer == null) {\n+        Answer<?> stubbedAnswer = mockitoStubber.findAnswerFor(invocation);\n+        if (!invocation.isVoid() && stubbedAnswer == null) {\n             //it is a return-value interaction but not stubbed. This *might* be a problem\n             mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n         }\n         \n-        if (answer != null) {\n+        if (stubbedAnswer != null) {\n             mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n-            return answer.answer(invocation);\n-        } else if (mockSettings.isSpy() == false) {\n-            return mockSettings.getDefaultAnswer().answer(invocation);\n+            return stubbedAnswer.answer(invocation);\n         } else {\n-            Object ret = methodProxy.invokeSuper(proxy, args);\n+            Object ret = null;\n+            try {\n+                ret = mockSettings.getDefaultAnswer().answer(invocation);\n+            } catch (Throwable t) {\n+                //TODO: this needs to be a different filter. \n+                //The one detects first stack trace element that is mockito internal\n+                //detects last stack trace element that is mockito internal\n+                //removes both of them and all inside\n+                \n+                new ConditionalStackTraceFilter().filter(t);\n+                throw t;\n+            }\n             //redo setting invocation for potential stubbing in case of partial mocks / spies.\n             //Without it, the real method inside 'when' might have delegated \n             //to other self method and overwrite the intended stubbed method with a different one.\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n         return this;\n     }\n \n-    public boolean isSpy() {\n-        return spiedInstance != null;\n-    }\n-\n     @SuppressWarnings(\"unchecked\")\n     public MockSettings defaultAnswer(Answer defaultAnswer) {\n         this.defaultAnswer = defaultAnswer;\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n         assertEquals(List.class, mockSettingsImpl.getExtraInterfaces()[0]);\n         assertEquals(Set.class, mockSettingsImpl.getExtraInterfaces()[1]);\n     }\n-    \n-    @Test\n-    public void shouldKnowIfIsASpy() throws Exception {\n-        //when\n-        mockSettingsImpl.spiedInstance(new Object());\n-        \n-        //then\n-        assertTrue(mockSettingsImpl.isSpy());\n-    }\n-    \n-    @Test\n-    public void shouldKnowNotBeASpyIfNoSpiedInstance() throws Exception {\n-        //when\n-        mockSettingsImpl.spiedInstance(null);\n-        \n-        //then\n-        assertFalse(mockSettingsImpl.isSpy());\n-    }\n }\n--- a/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n+++ b/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n \n import static org.mockito.Mockito.*;\n \n-import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mockito;\n+import org.mockitoutil.ExtraMatchers;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n public class PartialMockingWithSpiesTest extends TestBase {\n \n-    @After\n-    public void validateMockitoUsage() {\n-        Mockito.validateMockitoUsage();\n+    @Before\n+    public void pleaseMakeStackTracesClean() {\n+        makeStackTracesClean();\n     }\n     \n     class InheritMe {\n         \n         public String howMuchDidYouInherit() {\n             return getInherited();\n+        }\n+        \n+        public String getNameButDelegateToMethodThatThrows() {\n+            throwSomeException();\n+            return guessName().name;\n+        }\n+\n+        private void throwSomeException() {\n+            throw new RuntimeException(\"boo\");\n         }\n     }\n     \n     }\n \n     @Test\n+    public void shouldAllowStubbingWithThrowablesMethodsThatDelegateToOtherMethods() {\n+        // when\n+        doThrow(new RuntimeException(\"appetite for destruction\"))\n+            .when(spy).getNameButDelegateToMethodThatThrows();\n+        \n+        // then\n+        try {\n+            spy.getNameButDelegateToMethodThatThrows();\n+            fail();\n+        } catch(Exception e) {\n+            assertEquals(\"appetite for destruction\", e.getMessage());\n+        }\n+    }\n+    \n+//    @Test\n+    public void shouldStackTraceGetFilteredOnUserExceptions() {\n+        try {\n+            // when\n+            spy.getNameButDelegateToMethodThatThrows();\n+            fail();\n+        } catch (Throwable t) {\n+            assertThat(t, ExtraMatchers.hasMethodsInStackTrace(\n+                    \"throwSomeException\",\n+                    \"getNameButDelegateToMethodThatThrows\",\n+                    \"shouldStackTraceGetFilteredOnUserExceptions\"\n+                    ));\n+        }\n+    }\n+\n+    @Test\n     public void shouldVerify() {\n         // when\n         spy.getName();\n--- a/test/org/mockitoutil/ExtraMatchers.java\n+++ b/test/org/mockitoutil/ExtraMatchers.java\n     public static org.hamcrest.Matcher<java.lang.Object> clazz(java.lang.Class<?> type) {\n         return CoreMatchers.is(type);\n     }\n+\n+    public static Assertor hasMethodsInStackTrace(final String ... methods) {\n+        return new Assertor<Throwable>() {\n+            public void assertValue(Throwable value) {\n+                StackTraceElement[] trace = value.getStackTrace();\n+                for (int i = 0; i < methods.length; i++) {\n+                    assertEquals(\"Expected methods[\" + i + \"] to be in the stack trace.\", methods[i], trace[i].getMethodName());\n+                }\n+            }\n+        };\n+    }\n }", "timestamp": 1243374282, "metainfo": ""}