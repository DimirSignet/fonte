{"sha": "4a44708c4e97d3c1d80f7d8ae991cee6ae1fdc3e", "log": "Managed to add some testing around experimental JUnitRunner that warns about unusued stubs and unstubbed calls  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401120", "commit": "\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n \n public class DebuggingInfo {\n \n+    //TODO Thread safety issue?\n     private final List<Invocation> stubbedInvocations = new LinkedList<Invocation>();\n-    private final List<InvocationMatcher> unstubbedInvocations = new LinkedList<InvocationMatcher>();\n+    private final List<InvocationMatcher> potentiallyUnstubbedInvocations = new LinkedList<InvocationMatcher>();\n+    //TODO this code is crap. Use different field to maintain unusedInvocations\n+    private final List<InvocationMatcher> unusedInvocations = new LinkedList<InvocationMatcher>();\n+    private boolean collectingData;\n \n     public void addStubbedInvocation(Invocation invocation) {\n+        if (!collectingData) {\n+            return;\n+        }\n+        \n         //TODO test \n         //this is required because we don't know if unstubbedInvocation was really stubbed later...\n-        Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations.iterator();\n+        Iterator<InvocationMatcher> unstubbedIterator = potentiallyUnstubbedInvocations.iterator();\n         while(unstubbedIterator.hasNext()) {\n             InvocationMatcher unstubbed = unstubbedIterator.next();\n             if (unstubbed.getInvocation().equals(invocation)) {\n                 unstubbedIterator.remove();\n             }\n         }\n-        unstubbedInvocations.remove(invocation);\n+\n         stubbedInvocations.add(invocation);\n     }\n \n     public void addPotentiallyUnstubbed(InvocationMatcher invocationMatcher) {\n-        unstubbedInvocations.add(invocationMatcher);\n-    }\n-\n-    public List<Invocation> pullStubbedInvocations() {\n-        List<Invocation> ret = new LinkedList<Invocation>(stubbedInvocations);\n-        stubbedInvocations.clear();\n-        return ret;\n-    }\n-\n-    public List<InvocationMatcher> pullUnstubbedInvocations() {\n-        List<InvocationMatcher> ret = new LinkedList<InvocationMatcher>(unstubbedInvocations);\n-        unstubbedInvocations.clear();\n-        return ret;\n+        if (!collectingData) {\n+            return;\n+        }\n+        potentiallyUnstubbedInvocations.add(invocationMatcher);\n     }\n \n     public void collectData() {\n-        // TODO Auto-generated method stub\n+        collectingData = true;\n     }\n \n     public void clearData() {\n-        // TODO Auto-generated method stub\n+        collectingData = false;\n+        potentiallyUnstubbedInvocations.clear();\n+        stubbedInvocations.clear();\n     }\n \n     public void printWarnings(MockitoLogger logger) {\n-        WarningsPrinter warningsPrinter = new WarningsPrinter(stubbedInvocations, unstubbedInvocations);\n-        warningsPrinter.print(logger);\n+        if (hasData()) {\n+            WarningsPrinter warningsPrinter = new WarningsPrinter(stubbedInvocations, potentiallyUnstubbedInvocations);\n+            warningsPrinter.print(logger);\n+        }\n+    }\n+\n+    public boolean hasData() {\n+        return !stubbedInvocations.isEmpty() || !potentiallyUnstubbedInvocations.isEmpty();\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"unusedInvocations: \" + stubbedInvocations + \"\\nunstubbed invocations:\" + potentiallyUnstubbedInvocations;\n     }\n }\n--- a/src/org/mockito/internal/debugging/WarningsPrinter.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinter.java\n     }\n \n     public void print(MockitoLogger logger) {\n-        if (!shouldPrint()) {\n-            return;\n-        }\n-        \n         //TODO it should be visible that this method changes the state\n         warnAboutStubsUsedWithDifferentArgs(logger);\n         warnAboutUnusedStubs(logger);\n \n     private void warnAboutUnstubbedInvocations(MockitoLogger logger) {\n         for (InvocationMatcher i : unstubbedInvocations) {\n-            logger.println(join(\n+            logger.log(join(\n                 \"[Mockito] Warning - this method was not stubbed:\",\n                 i,\n                 \"Here:\",\n \n     private void warnAboutUnusedStubs(MockitoLogger logger) {\n         for (Invocation i : unusedStubs) {\n-            logger.println(join(\n+            logger.log(join(\n                 \"[Mockito] Warning - this stub was not used:\",\n                 i,\n                 \"Here:\",\n             while(unstubbedIterator.hasNext()) {\n                 InvocationMatcher unstubbed = unstubbedIterator.next();\n                 if(unstubbed.hasSimilarMethod(unused)) { \n-                    logger.println(join(\n+                    logger.log(join(\n                             \"[Mockito] Warning - stubbed method called with different arguments.\",\n                             \"Stubbed this way:\",\n                             unused,\n             }\n         }\n     }\n-\n-    private boolean shouldPrint() {\n-        //TODO test, include unstubbedInvocations...\n-        return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n-    }\n }\n--- a/src/org/mockito/internal/util/MockitoLogger.java\n+++ b/src/org/mockito/internal/util/MockitoLogger.java\n \n public interface MockitoLogger {\n \n-    void println(Object what);\n-\n-    void println();\n+    void log(Object what);\n \n }\n--- a/src/org/mockito/internal/util/MockitoLoggerImpl.java\n+++ b/src/org/mockito/internal/util/MockitoLoggerImpl.java\n     /* (non-Javadoc)\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n-    public void println(Object what) {\n+    public void log(Object what) {\n         System.out.println(what.toString());\n     }\n-\n-    /* (non-Javadoc)\n-     * @see org.mockito.internal.util.MockitoLogger#println()\n-     */\n-    public void println() {\n-        System.out.println();\n-    }\n }\n--- a/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n  */\n public class ExperimentalMockitoJUnitRunner extends BlockJUnit4ClassRunner {\n \n-    private final MockitoLogger logger;\n+    static MockitoLogger logger = new MockitoLoggerImpl();\n     \n     public ExperimentalMockitoJUnitRunner(Class<?> klass) throws InitializationError {\n         super(klass);\n-        logger = new MockitoLoggerImpl();\n     }\n \n     @Override\n         return super.withBefores(method, target, statement);\n     }\n     \n+    static interface SimpleRunner {\n+        void run(RunNotifier notifier);\n+    }\n+    \n     @Override\n     public void run(RunNotifier notifier) {\n+        this.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                ExperimentalMockitoJUnitRunner.super.run(notifier);\n+            }\n+        });\n+    }\n+    \n+    public void run(RunNotifier notifier, SimpleRunner littleRunner) {\n         final MockingProgress progress = new ThreadSafeMockingProgress();\n         final DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n         \n         debuggingInfo.collectData();\n-        \n+\n         RunListener listener = new RunListener() {\n-            @Override\n-            public void testFailure(Failure failure) throws Exception {\n+            @Override public void testFailure(Failure failure) throws Exception {\n                 debuggingInfo.printWarnings(logger);\n-                super.testFailure(failure);\n             }\n         };\n+        \n         notifier.addListener(listener);\n-        super.run(notifier);\n+        littleRunner.run(notifier);\n         \n         debuggingInfo.clearData();\n     }\n--- a/src/org/mockito/runners/MockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/MockitoJUnitRunner.java\n import org.junit.runners.model.Statement;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n+\n+//TODO validate state in the runner?\n \n /**\n  * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n--- /dev/null\n+++ b/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerTest.java\n+package org.mockito.runners;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner.SimpleRunner;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class ExperimentalMockitoJUnitRunnerTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+    private ExperimentalMockitoJUnitRunner runner;\n+    private MockitoLoggerStub logger;\n+    private RunNotifier notifier;\n+\n+    @Before\n+    public void setup() throws InitializationError {\n+        runner = new ExperimentalMockitoJUnitRunner(this.getClass());\n+        logger = new MockitoLoggerStub();\n+        ExperimentalMockitoJUnitRunner.logger = logger;\n+        notifier = new RunNotifier();\n+    }\n+    \n+    @After\n+    public void restoreLogger() {\n+        ExperimentalMockitoJUnitRunner.logger = new MockitoLoggerImpl();\n+    }\n+\n+    @Test(expected=RunWasCalled.class)\n+    public void shouldRunTests() throws Exception {\n+        runner.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                throw new RunWasCalled();\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                //this is what happens when the test runs:\n+                //first, unused stubbing:\n+                unusedStubbingThatQualifiesForWarning();\n+                //then, let's make the test fail so that warnings are printed\n+                notifier.fireTestFailure(null);\n+                //assert\n+                String loggedInfo = logger.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n+                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                callUnstubbedMethodThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+\n+                String loggedInfo = logger.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this method was not stubbed\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(456);\"));\n+                assertThat(loggedInfo, contains(\".callUnstubbedMethodThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n+        runner.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                someStubbing();\n+                callStubbedMethodCorrectly();\n+                callStubbedMethodWithDifferentArgs();\n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = logger.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - stubbed method called with different arguments\"));\n+                assertThat(loggedInfo, contains(\"Stubbed this way:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(789);\"));\n+                assertThat(loggedInfo, contains(\".someStubbing(\"));\n+                \n+                assertThat(loggedInfo, contains(\"But called with different arguments:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(10);\"));\n+                assertThat(loggedInfo, contains(\".callStubbedMethodWithDifferentArgs(\"));\n+                \n+                assertThat(loggedInfo, notContains(\".callStubbedMethodCorrectly(\"));\n+            }\n+        });\n+    }\n+    \n+    public void shouldClearDebuggingDataAfterwards() throws Exception {\n+        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n+        \n+        runner.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                unusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                assertTrue(debuggingInfo.hasData());\n+            }\n+        });\n+        \n+        assertFalse(debuggingInfo.hasData());\n+    }    \n+\n+    private void unusedStubbingThatQualifiesForWarning() {\n+        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n+    }\n+\n+    private void callUnstubbedMethodThatQualifiesForWarning() {\n+        mock.simpleMethod(456);\n+    }\n+    \n+    private void someStubbing() {\n+        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n+    }\n+    \n+    private void callStubbedMethodCorrectly() {\n+        mock.simpleMethod(789);\n+    }\n+\n+    private void callStubbedMethodWithDifferentArgs() {\n+        mock.simpleMethod(10);\n+    }\n+    \n+    public class MockitoLoggerStub extends MockitoLoggerImpl {\n+        \n+        StringBuilder loggedInfo = new StringBuilder();\n+        \n+        public void log(Object what) {\n+//            can be uncommented when debugging this test\n+//            super.println(what);\n+            loggedInfo.append(what);\n+        }\n+\n+        public String getLoggedInfo() {\n+            return loggedInfo.toString();\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    private static class RunWasCalled extends RuntimeException {}; \n+}\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n-import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n //This is required to make sure stack trace is well filtered when runner is ON\n-@RunWith(MockitoJUnitRunner.class)\n+@RunWith(ExperimentalMockitoJUnitRunner.class)\n public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {\n     \n     private IMethods mock;\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n //This is required to make sure stack trace is well filtered when runner is ON\n-@RunWith(MockitoJUnitRunner.class)\n+@RunWith(ExperimentalMockitoJUnitRunner.class)\n public class PointingStackTraceToActualInvocationChunkTest extends TestBase {\n     \n     private IMethods mock;\n--- /dev/null\n+++ b/test/org/mockitousage/warnings/CollectingDebugDataTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.warnings;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class CollectingDebugDataTest extends TestBase {\n+\n+    @Mock IMethods mock;\n+    \n+    @Test\n+    public void shouldNotCollectWhenNoJUnitRunner() throws Throwable {\n+        //stubbing\n+        when(mock.simpleMethod()).thenReturn(\"foo\");\n+        \n+        //calling unstubbed method\n+        mock.differentMethod();\n+        \n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        \n+        assertFalse(progress.getDebuggingInfo().hasData());\n+    }\n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n     }\n     \n     //I'm really tired of matchers, enter the assertor!\n-    protected <T> void assertThat(T o, Assertor<T> a) {\n+    protected static <T> void assertThat(T o, Assertor<T> a) {\n         a.assertValue(o);\n     }\n     \n-    protected <T> void assertThat(T actual, Matcher<T> m) {\n+    protected static <T> void assertThat(T actual, Matcher<T> m) {\n         org.junit.Assert.assertThat(actual, m);\n     }\n     \n-    protected <T> void assertThat(String message, T actual, Matcher<T> m) {\n+    protected static <T> void assertThat(String message, T actual, Matcher<T> m) {\n         org.junit.Assert.assertThat(message, actual, m);\n     }\n     \n             }\n         };\n     }\n+    \n+    public static <T> Assertor<String> notContains(final String substring) {\n+        return new Assertor<String>() {\n+            public void assertValue(String value) {\n+                assertFalse(\"This substring: \\n\" + substring + \n+                        \"\\nshould NOT be inside of:\\n\" + value\n+                        , value.contains(substring));\n+            }\n+        };\n+    }\n+    \n+    //Assertors will never be matchers...\n+//    public static <T> Assertor<T> not(final Assertor<T> assertor) {\n+//        return new Assertor<T>() {\n+//            public void assertValue(T value) {\n+//                boolean failed = false;\n+//                try {\n+//                    assertor.assertValue(value);\n+//                } catch (AssertionError e) {\n+//                    failed = true;\n+//                }\n+//                \n+//                assertTrue(\"Assertion failed\", failed);\n+//            }\n+//        };\n+//    }\n     \n     public static <T> Assertor<String> endsWith(final String substring) {\n         return new Assertor<String>() {", "timestamp": 1230846665, "metainfo": ""}