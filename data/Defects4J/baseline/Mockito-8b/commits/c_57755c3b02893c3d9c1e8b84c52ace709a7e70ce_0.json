{"sha": "57755c3b02893c3d9c1e8b84c52ace709a7e70ce", "log": "First working steps to have a serialization that works across classloaders/JVMs", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+package org.mockito.internal.creation;\n+\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.StringJoiner;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+import org.mockito.mock.MockCreationSettings;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InvalidObjectException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+\n+/**\n+ * XXX not thread-safe prototype !!!!\n+ *\n+ * @author Brice Dutheil\n+ */\n+public class AcrossJVMSerializationFeature implements Serializable {\n+    private static final long serialVersionUID = 7411152578314420778L;\n+    private static WeakHashMap<Object, Boolean> currentlySerializing = new WeakHashMap();\n+\n+    public boolean isWriteReplace(Method method) {\n+        return  method.getReturnType() == Object.class\n+                && method.getParameterTypes().length == 0\n+                && method.getName().equals(\"writeReplace\");\n+    }\n+\n+\n+    public Object writeReplace(Object proxy) throws ObjectStreamException {\n+        // mark started flag // per thread, not per instance\n+        // temporary loosy hack to avoid stackoverflow\n+        if(Boolean.TRUE.equals(currentlySerializing.get(proxy))) {\n+            return proxy;\n+        }\n+        currentlySerializing.put(proxy, true);\n+\n+        try {\n+            return new AcrossJVMMockSerializationProxy(proxy);         // stackoverflow\n+        } catch (IOException ioe) {\n+            throw new NotSerializableException(proxy.getClass().getCanonicalName()); // TODO throw our own serialization exception\n+        } finally {\n+            // unmark\n+            currentlySerializing.remove(proxy);\n+        }\n+\n+    }\n+\n+\n+\n+    public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {\n+        // havin faith that this set is modifiable\n+        settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerilizable.class);\n+    }\n+\n+\n+    /**\n+     * This is the serialization proxy that will encapsulate the real mock data.\n+     *\n+     * It will allow deserilization of the mock in another classloader/vm through custom deserilization ObjectInputStream\n+     */\n+    public static class AcrossJVMMockSerializationProxy implements Serializable {\n+        private static final long serialVersionUID = -7600267929109286514L;\n+        private byte[] serializedMock;\n+        private Class typeToMock;\n+        private Set<Class> extraInterfaces;\n+\n+\n+        public AcrossJVMMockSerializationProxy(Object proxy) throws IOException {\n+            MockCreationSettings mockSettings = new MockUtil().getMockHandler(proxy).getMockSettings();\n+\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);\n+\n+            objectOutputStream.writeObject(proxy);\n+\n+            objectOutputStream.close();\n+            out.close();\n+\n+            this.serializedMock = out.toByteArray();\n+            this.typeToMock = mockSettings.getTypeToMock();\n+            this.extraInterfaces = mockSettings.getExtraInterfaces();\n+        }\n+\n+\n+        private Object readResolve() throws ObjectStreamException {\n+            try {\n+                ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);\n+                ObjectInputStream mockitoMockObjectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);\n+\n+                Object object = mockitoMockObjectInputStream.readObject();\n+\n+                bis.close();\n+                mockitoMockObjectInputStream.close();\n+                return object;\n+            } catch (IOException ioe) {\n+                throw new InvalidObjectException(\"For some reason mock cannot ve dematerialized : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n+            } catch (ClassNotFoundException cce) {\n+                throw new InvalidObjectException(\"For some reason Mockito Mock class cannot be found : \" + cce.toString());\n+            }\n+        }\n+    }\n+\n+\n+\n+    public static class MockitoMockObjectInputStream extends ObjectInputStream {\n+        private Class typeToMock;\n+        private Set<Class> extraInterfaces;\n+\n+        public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {\n+            super(in) ;\n+            this.typeToMock = typeToMock;\n+            this.extraInterfaces = extraInterfaces;\n+            enableResolveObject(true);\n+        }\n+\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+            Object anObject = readObject();\n+            if (\"MockitoProxyMarker\".equals(anObject)) {\n+                ClassImposterizer.INSTANCE.canImposterise(typeToMock);\n+                ClassImposterizer.INSTANCE.setConstructorsAccessible(typeToMock, true);\n+                Class<?> proxyClass = ClassImposterizer.INSTANCE.createProxyClass(\n+                        typeToMock,\n+                        extraInterfaces.toArray(new Class[extraInterfaces.size()])\n+                );\n+\n+                try {\n+                    new FieldSetter(desc, desc.getClass().getDeclaredField(\"name\")).set(proxyClass.getCanonicalName());\n+                } catch (NoSuchFieldException e) {\n+                    e.printStackTrace();\n+                }\n+\n+                return proxyClass;\n+            }\n+\n+            return super.resolveClass(desc);\n+        }\n+    }\n+\n+\n+\n+\n+    public interface AcrossJVMMockitoMockSerilizable {\n+        public Object writeReplace() throws java.io.ObjectStreamException;\n+    }\n+\n+\n+    private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n+        public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n+            super(out);\n+        }\n+\n+        @Override\n+        protected void annotateClass(Class<?> cl) throws IOException {\n+            if (Factory.class.isAssignableFrom(cl)) {\n+                writeObject(\"MockitoProxyMarker\");\n+            } else {\n+                writeObject(\"\");\n+            }\n+            // might be also useful later, for embedding classloader info maybe\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n \n     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n         InternalMockHandler mockitoHandler = cast(handler);\n+        new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);\n         return ClassImposterizer.INSTANCE.imposterise(\n                 new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n     }\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n \n package org.mockito.internal.creation;\n \n-import java.io.Serializable;\n-import java.lang.reflect.Method;\n-\n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.invocation.Invocation;\n-import org.mockito.invocation.MockHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n-import org.mockito.internal.invocation.*;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n import org.mockito.mock.MockCreationSettings;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n \n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n             return proxy == args[0];\n         } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n             return hashCodeForMock(proxy);\n+        } else if (new AcrossJVMSerializationFeature().isWriteReplace(method)) {\n+            return new AcrossJVMSerializationFeature().writeReplace(proxy);\n         }\n         \n         MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n         }\n     }\n     \n-    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n+    public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n         for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n             constructor.setAccessible(accessible);\n         }\n     }\n     \n-    private Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\n+    public Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\n         if (mockedType == Object.class) {\n             mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n         }\n         } else {\n             enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\n         }\n+\n+        enhancer.setSerialVersionUID(42L);\n         \n         try {\n             return enhancer.createClass(); \n--- a/src/org/mockito/internal/util/ObjectMethodsGuru.java\n+++ b/src/org/mockito/internal/util/ObjectMethodsGuru.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n+\n+import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.invocation.MockitoMethod;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-\n-import org.mockito.internal.creation.DelegatingMethod;\n-import org.mockito.internal.invocation.MockitoMethod;\n \n public class ObjectMethodsGuru implements Serializable {\n \n     }\n \n     public boolean isToString(MockitoMethod method) {\n-        return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n+        return method.getReturnType() == String.class\n+                && method.getParameterTypes().length == 0\n                 && method.getName().equals(\"toString\");\n     }\n \n     public boolean isEqualsMethod(Method method) {\n-        return method.getName().equals(\"equals\") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class;\n+        return method.getName().equals(\"equals\")\n+                && method.getParameterTypes().length == 1\n+                && method.getParameterTypes()[0] == Object.class;\n     }\n \n     public boolean isHashCodeMethod(Method method) {\n-        return method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0;\n+        return method.getName().equals(\"hashCode\")\n+                && method.getParameterTypes().length == 0;\n     }\n \n     public boolean isCompareToMethod(Method method) {\n-        return Comparable.class.isAssignableFrom(method.getDeclaringClass()) && method.getName().equals(\"compareTo\")\n-                && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == method.getDeclaringClass();\n+        return Comparable.class.isAssignableFrom(method.getDeclaringClass())\n+                && method.getName().equals(\"compareTo\")\n+                && method.getParameterTypes().length == 1\n+                && method.getParameterTypes()[0] == method.getDeclaringClass();\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/AcrossClassLoaderSerializationTest.java\n+package org.mockitousage.basicapi;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.SimplePerRealmReloadingClassLoader;\n+import org.mockitoutil.SimpleSerializationUtil;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.FileOutputStream;\n+import java.util.concurrent.Callable;\n+\n+\n+/**\n+ * Doesn't work, for now. maybe with more hacky way to tamper the outputstream, still...\n+ *\n+ * While investigating, I discovered that <code>ObjectOutputStream</code> will write the real class in the stream\n+ * through <code>writeClass</code> before the <code>writeReplace</code> (see <code>writeObject0</code>), that means\n+ * that the CGLIB proxy class is written in the stream anyway, unless you don't use an ObjectOutputStream directly.\n+ *\n+ * So when one use the standard <code>ObjectInputStream</code> it will read the bytestream and use the written class\n+ * info to lookup for it in the classloader, unfortunately this class matches the class in another classloader and\n+ * isn't available anyway at deserialization time. Overriding <code>resolveClass</code> in a subclass of\n+ * <code>ObjectInoutStream</code> might help though to overcome this shortcomming.\n+ *\n+ *\n+ * Yet JDK proxies are serializable, how are they doing it !? Well <code>ObjectOutputStream</code> have specific\n+ * treatment for JDK proxy especially there <code>writeClassDesc</code> which uses an <code>ObjectStreamClass</code>\n+ * that is initialized in his constructor with <code>Proxy.isProxy</code>\n+ *\n+ * Note for the hacker, the class descriptor of a JDK Proxy is written with the following byte\n+ * <code>ObjectStreamConstants.TC_PROXYCLASSDESC</code> this byte in the stream will trigger the specific overridable\n+ * <code>resolveProxyClass</code> (see <code>readClassDesc</code>), though yet again it means the method has to be\n+ * overrided in the input stream.\n+ *\n+ * TODO for the hacker, not for real... See if it is possible to tamper the BlockDataOutputStream and then simulate a writeReplace\n+ * ... well probably don't worth it\n+ *\n+ */\n+public class AcrossClassLoaderSerializationTest {\n+\n+    @Test\n+    public void name() throws Exception {\n+        byte[] bytes = create_mock_and_Serialize_it();\n+\n+        System.out.println(new String(bytes));\n+\n+        FileOutputStream outputStream = new FileOutputStream(\"acrossJVM\", false);\n+        outputStream.write(bytes);\n+        outputStream.close();\n+\n+        Object the_deserialized_mock = read_stream_and_deserialize_it(bytes);\n+\n+        System.out.println(the_deserialized_mock);\n+    }\n+\n+    private Object read_stream_and_deserialize_it(byte[] bytes) throws Exception {\n+        return new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), reload_all())\n+                .doInRealm(\n+                        \"org.mockitousage.basicapi.AcrossClassLoaderSerializationTest$ReadStreanAndDeserializeIt\",\n+                        new Class[]{ byte[].class },\n+                        new Object[]{ bytes }\n+                );\n+    }\n+\n+    private byte[] create_mock_and_Serialize_it() throws Exception {\n+        return (byte[]) new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), reload_all())\n+                .doInRealm(\"org.mockitousage.basicapi.AcrossClassLoaderSerializationTest$CreateMockAndSerializeIt\");\n+    }\n+\n+    private SimplePerRealmReloadingClassLoader.ReloadClassPredicate reload_all() {\n+        return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n+            public boolean acceptReloadOf(String qualifiedName) {\n+                return qualifiedName.contains(\"org.mockitousage\")\n+//                        || qualifiedName.contains(\"org.mockito\")\n+//                        || qualifiedName.contains(\"org.mockito.cglib\")\n+                        || qualifiedName.contains(\"org.mockitoutil\");\n+            }\n+        };\n+    }\n+\n+\n+    public static class CreateMockAndSerializeIt implements Callable<byte[]> {\n+        public byte[] call() throws Exception {\n+            IMethods mock = Mockito.mock(IMethods.class, Mockito.withSettings().serializable());\n+            // use MethodProxy before\n+//            mock.linkedListReturningMethod();\n+\n+            return SimpleSerializationUtil.serializeMock(mock).toByteArray();\n+        }\n+    }\n+\n+\n+    public static class ReadStreanAndDeserializeIt implements Callable<Object> {\n+        private byte[] bytes;\n+\n+        public ReadStreanAndDeserializeIt(byte[] bytes) {\n+            this.bytes = bytes;\n+        }\n+\n+        public Object call() throws Exception {\n+            ByteArrayInputStream unserialize = new ByteArrayInputStream(bytes);\n+            return SimpleSerializationUtil.deserializeMock(unserialize, IMethods.class);\n+        }\n+    }\n+\n+\n+\n+}\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n  */\n \n package org.mockitousage.verification;\n-\n-import static org.mockito.AdditionalMatchers.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import static org.mockito.AdditionalMatchers.aryEq;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.matches;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {\n \n     private IMethods mock;\n     }\n \n     @Test\n-    public void should_print_method_name_and_arguments_of_other_interactions() throws Exception {\n+    public void should_print_method_name_and_arguments_of_other_interactions_with_different_methods() throws Exception {\n         try {\n             mock.arrayMethod(new String[] {\"a\", \"b\", \"c\"});\n             mock.forByte((byte) 25);\n             assertContains(\"iMethods.forByte(25)\", e.getMessage());\n         }\n     }\n+\n+    @Test\n+    public void should_print_method_name_and_arguments_of_other_interactions_of_same_method() throws Exception {\n+        try {\n+            mock.forByte((byte) 25);\n+            mock.forByte((byte) 12);\n+\n+            verify(mock).forByte((byte) 42);\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            System.out.println(e);\n+            assertContains(\"iMethods.forByte(42)\", e.getMessage());\n+            assertContains(\"iMethods.forByte(25)\", e.getMessage());\n+            assertContains(\"iMethods.forByte(12)\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void test1() {\n+        AnInterface m = Mockito.mock(AnInterface.class);\n+\n+        for (int i = 1; i <= 2; i++) {\n+            m.foo(i);\n+        }\n+\n+        verify(m).foo(1);\n+        verify(m).foo(2);\n+        verify(m).foo(3); // XXX: doesn't mention the parameters of foo(1) and foo(2)\n+        verify(m).foo(4);\n+    }\n+\n+    @Test\n+    public void test2() {\n+        AnInterface m = Mockito.mock(AnInterface.class);\n+\n+        for (int i = 1; i <= 4; i++) {\n+            m.foo(i);\n+        }\n+\n+        verify(m).foo(1);\n+        verify(m).foo(2);\n+        verify(m).foo(5); // XXX: doesn't mention foo(4) at all\n+    }\n+\n+    public interface AnInterface {\n+        void foo(int i);\n+    }\n+    \n }\n--- a/test/org/mockitoutil/SimpleSerializationUtil.java\n+++ b/test/org/mockitoutil/SimpleSerializationUtil.java\n     public static <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,\n             ClassNotFoundException {\n         InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());\n+        return deserializeMock(unserialize, type);\n+    }\n+\n+    public static <T> T deserializeMock(InputStream unserialize, Class<T> type) throws IOException, ClassNotFoundException {\n         Object readObject = new ObjectInputStream(unserialize).readObject();\n         Assert.assertNotNull(readObject);\n         return type.cast(readObject);", "timestamp": 1354525863, "metainfo": ""}