{"sha": "038235e0df9f693df19296b340225c95aedb2a85", "log": "Got rid of some duplication and removed TODOs and warnings  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401865", "commit": "\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.GlobalConfiguration;\n+import org.mockito.internal.util.reflection.FieldSetter;\n import org.mockito.runners.MockitoJUnitRunner;\n \n /**\n         }\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n         boolean alreadyAssigned = false;\n         for(Annotation annotation : field.getAnnotations()) {\n             Object mock = annotationEngine.createMockFor(annotation, field);\n             if (mock != null) {\n                 throwIfAlreadyAssigned(field, alreadyAssigned);\n-                alreadyAssigned = true;\n-                boolean wasAccessible = field.isAccessible();\n-                field.setAccessible(true);\n+                alreadyAssigned = true;                \n                 try {\n-                    field.set(testClass, mock);\n-                } catch (IllegalAccessException e) {\n+                    new FieldSetter(testClass, field).set(mock);\n+                } catch (Exception e) {\n                     throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                             + annotation, e);\n-                } finally {\n-                    field.setAccessible(wasAccessible);\n-                }    \n+                }\n             }\n         }\n     }\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldSetter;\n \n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n             for(Annotation annotation : field.getAnnotations()) {           \n                 Object mock = createMockFor(annotation, field);\n                 if (mock != null) {\n-                    throwIfAlreadyAssigned(field, alreadyAssigned);\n-                    alreadyAssigned = true;\n-                    //TODO this is deprecated all over the place\n-                    boolean wasAccessible = field.isAccessible();\n-                    field.setAccessible(true);\n+                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n+                    alreadyAssigned = true;                    \n                     try {\n-                        field.set(testClass, mock);\n-                    } catch (IllegalAccessException e) {\n+                        new FieldSetter(testClass, field).set(mock);\n+                    } catch (Exception e) {\n                         throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                 + annotation, e);\n-                    } finally {\n-                        field.setAccessible(wasAccessible);\n-                    }    \n+                    }\n                 }        \n             }\n         }\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n \n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldSetter;\n \n /**\n  * Initializes mock/spies dependencies for fields annotated with &#064;InjectMock\n         }\n     }\n \n-    private void inject(Field field, Object fieldInstance, Object matchingMock) {\n-        boolean wasAccessible = field.isAccessible();\n-        field.setAccessible(true);\n+    private void inject(Field field, Object fieldInstance, Object matchingMock) {        \n         try {\n-            field.set(fieldInstance, matchingMock);\n-        } catch (IllegalAccessException e) {\n+            new FieldSetter(fieldInstance, field).set(matchingMock);            \n+        } catch (Exception e) {\n             throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n-        } finally {\n-            field.setAccessible(wasAccessible);\n         }\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/FieldSetter.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Field;\n+\n+public class FieldSetter {\n+\n+    private final Object target;\n+    private final Field field;\n+\n+    public FieldSetter(Object target, Field field) {\n+        this.target = target;\n+        this.field = field;\n+    }\n+\n+    public void set(Object value) {\n+        AccessibilityChanger changer = new AccessibilityChanger();\n+        changer.enableAccess(field);\n+        try {\n+            field.set(target, value);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems setting value: [\" + value + \"] on object: [\" + target + \"] at field: [\" + field + \"]\");\n+        }\n+        changer.safelyDisableAccess(field);\n+    }\n+}", "timestamp": 1267054315, "metainfo": ""}