{"sha": "899fd91f31246e569eea833b129eacd4b57bb9f7", "log": "Changed ReturnsSmartNulls so that it does not use MockMaker. Instead it uses the regular way of creating mocks. This also enables some further refactorings in the Invocations area.", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n import org.mockito.Mockito;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.invocation.Invocation;\n import org.mockito.invocation.Location;\n-import org.mockito.plugins.MockMaker;\n-import org.mockito.internal.configuration.ClassPathLoader;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.stubbing.Answer;\n \n /**\n public class ReturnsSmartNulls implements Answer<Object>, Serializable {\n \n     private static final long serialVersionUID = 7618312406617949441L;\n-    private static MockMaker mockMaker = ClassPathLoader.getMockMaker();\n-\n-    private final class ThrowingInterceptor implements MockitoInvocationHandler {\n-        private final InvocationOnMock invocation;\n-        private final Location location = new LocationImpl();\n-\n-        private ThrowingInterceptor(InvocationOnMock invocation) {\n-            this.invocation = invocation;\n-        }\n-\n-        public Object handle(Invocation nullDereference) throws Throwable {\n-            if (new ObjectMethodsGuru().isToString(nullDereference.getMethod())) {\n-                return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n-                        invocation.toString();\n-            }\n-\n-            new Reporter().smartNullPointerException(invocation.toString(), location);\n-            return null;\n-        }\n-    }\n \n     private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n \n         }\n         Class<?> type = invocation.getMethod().getReturnType();\n         if (!type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {\n-            ThrowingInterceptor handler = new ThrowingInterceptor(invocation);\n-            return mockMaker.createMock(type, new Class[0], handler, new MockSettingsImpl());\n+            final Location location = new LocationImpl();\n+            return Mockito.mock(type, new ThrowsSmartNullPointer(invocation, location));\n         }\n         return null;\n     }\n+\n+    private static class ThrowsSmartNullPointer implements Answer {\n+        private final InvocationOnMock unstubbedInvocation;\n+        private final Location location;\n+\n+        public ThrowsSmartNullPointer(InvocationOnMock unstubbedInvocation, Location location) {\n+            this.unstubbedInvocation = unstubbedInvocation;\n+            this.location = location;\n+        }\n+\n+        public Object answer(InvocationOnMock currentInvocation) throws Throwable {\n+            if (new ObjectMethodsGuru().isToString(currentInvocation.getMethod())) {\n+                return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n+                        unstubbedInvocation.toString();\n+            }\n+\n+            new Reporter().smartNullPointerException(unstubbedInvocation.toString(), location);\n+            return null;\n+        }\n+    }\n }", "timestamp": 1333912707, "metainfo": ""}