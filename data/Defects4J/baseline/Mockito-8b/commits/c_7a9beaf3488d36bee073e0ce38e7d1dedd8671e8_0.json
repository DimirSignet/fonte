{"sha": "7a9beaf3488d36bee073e0ce38e7d1dedd8671e8", "log": "refactored to use MockitoCore instance  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401325", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n+    private static MockitoCore MOCKITO_CORE = new MockitoCore();\n+    \n     /**\n      * Default ReturnValues used by the framework.\n      * <p>\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return MockitoCore.mock(classToMock, null, null, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock(classToMock, null, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, String name) {\n-        return MockitoCore.mock(classToMock, name, null, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock(classToMock, name, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n-        return MockitoCore.mock(classToMock, null, (T) null, returnValues);\n+        return MOCKITO_CORE.mock(classToMock, null, (T) null, returnValues);\n     }\n     \n     /**\n      * @return a spy of the real object\n      */\n     public static <T> T spy(T object) {\n-        return MockitoCore.mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n     }\n \n     /**\n \t */\n \t@Deprecated\n \tpublic static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n-\t\treturn MockitoCore.stub(methodCall);\n+\t\treturn MOCKITO_CORE.stub(methodCall);\n \t}\n     \n     /**\n \t * @param methodCall method to be stubbed\n \t */\n \tpublic static <T> NewOngoingStubbing<T> when(T methodCall) {\n-\t\treturn MockitoCore.when(methodCall);\n+\t\treturn MOCKITO_CORE.when(methodCall);\n \t}\n \n     /**\n      * @return mock object itself\n      */\n     public static <T> T verify(T mock) {\n-        return MockitoCore.verify(mock, times(1));\n+        return MOCKITO_CORE.verify(mock, times(1));\n     }\n     \n     /**\n \t * @param mock\n \t */\n \tpublic static <T> void reset(T mock) {\n-\t\tMockitoCore.reset(mock);\n+\t\tMOCKITO_CORE.reset(mock);\n \t}\n \n  \n \t * @return mock object itself\n \t */\n \tpublic static <T> T verify(T mock, VerificationMode mode) {\n-\t\treturn MockitoCore.verify(mock, mode);\n+\t\treturn MOCKITO_CORE.verify(mock, mode);\n \t}\n \n     /**\n \t * @param mocks to be verified\n \t */\n \tpublic static void verifyNoMoreInteractions(Object... mocks) {\n-\t\tMockitoCore.verifyNoMoreInteractions(mocks);\n+\t\tMOCKITO_CORE.verifyNoMoreInteractions(mocks);\n \t}\n \n     /**\n      * @param mocks to be verified\n      */\n     public static void verifyZeroInteractions(Object... mocks) {\n-        MockitoCore.verifyNoMoreInteractions(mocks);\n+        MOCKITO_CORE.verifyNoMoreInteractions(mocks);\n     }\n \n     public static void assertMocksNotEmpty(Object[] mocks) {\n-\t\tMockitoCore.assertMocksNotEmpty(mocks);\n+\t\tMOCKITO_CORE.assertMocksNotEmpty(mocks);\n \t}\n \n     /**\n \t * @return stubbable object that allows stubbing with throwable\n \t */\n \tpublic static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-\t\treturn MockitoCore.stubVoid(mock);\n+\t\treturn MOCKITO_CORE.stubVoid(mock);\n \t}\n     \n     /**\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doThrow(Throwable toBeThrown) {\n-        return MockitoCore.doAnswer(new ThrowsException(toBeThrown));\n+        return MOCKITO_CORE.doAnswer(new ThrowsException(toBeThrown));\n     }\n     \n     /**\n \t * @return stubber - to select a method for stubbing\n \t */\n \tpublic static Stubber doAnswer(Answer answer) {\n-\t\treturn MockitoCore.doAnswer(answer);\n+\t\treturn MOCKITO_CORE.doAnswer(answer);\n \t}  \n     \n     /**\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doNothing() {\n-        return MockitoCore.doAnswer(new DoesNothing());\n+        return MOCKITO_CORE.doAnswer(new DoesNothing());\n     }    \n     \n     /**\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doReturn(Object toBeReturned) {\n-        return MockitoCore.doAnswer(new Returns(toBeReturned));\n+        return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));\n     }\n  \n     /**\n \t * @return InOrder object to be used to verify in order\n \t */\n \tpublic static InOrder inOrder(Object... mocks) {\n-\t\treturn MockitoCore.inOrder(mocks);\n+\t\treturn MOCKITO_CORE.inOrder(mocks);\n \t}\n   \n     /**\n--- a/src/org/mockito/internal/InOrderImpl.java\n+++ b/src/org/mockito/internal/InOrderImpl.java\n  */\n class InOrderImpl implements InOrder {\n     \n+    private final MockitoCore mockitoCore = new MockitoCore();\n     private final Reporter reporter = new Reporter();\n     private final List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n     \n         } else if (!(mode instanceof VerificationInOrderMode)) {\n             throw new MockitoException(mode.getClass().getSimpleName() + \" is not implemented to work with InOrder\");\n         }\n-        return MockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));\n+        return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));\n     }\n }\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoCore {\n \n-\tstatic final Reporter REPORTER = new Reporter();\n+\tReporter REPORTER = new Reporter();\n \tpublic static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n \t\n-\tpublic static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n+\tpublic <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n \t    MOCKING_PROGRESS.validateState();\n \t    MOCKING_PROGRESS.resetOngoingStubbing();\n \t    return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n \t}\n \t\n-\tpublic static OngoingStubbing stub() {\n+\tpublic OngoingStubbing stub() {\n \t    OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n \t    if (stubbing == null) {\n \t        MOCKING_PROGRESS.reset();\n \t}\n \n \t@Deprecated\n-\tpublic static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+\tpublic <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n \t    MOCKING_PROGRESS.stubbingStarted();\n \t    return (DeprecatedOngoingStubbing) stub();\n \t}\n \n-\tpublic static <T> NewOngoingStubbing<T> when(T methodCall) {\n+\tpublic <T> NewOngoingStubbing<T> when(T methodCall) {\n \t    MOCKING_PROGRESS.stubbingStarted();\n \t    return (NewOngoingStubbing) stub();\n \t}\n \t\n \t\n-\tpublic static <T> T verify(T mock, VerificationMode mode) {\n+\tpublic <T> T verify(T mock, VerificationMode mode) {\n \t    if (mock == null) {\n \t        REPORTER.nullPassedToVerify();\n \t    } else if (!MockUtil.isMock(mock)) {\n \t    return mock;\n \t}\n \t\n-\tpublic static <T> void reset(T mock) {\n+\tpublic <T> void reset(T mock) {\n \t    //TODO Perhaps we should validate the state instead of resetting?\n \t    MOCKING_PROGRESS.reset();\n \t    MOCKING_PROGRESS.resetOngoingStubbing();\n \t    MockUtil.resetMock(mock, MOCKING_PROGRESS, Mockito.RETURNS_DEFAULTS);\n \t}\n \t\n-\tpublic static void verifyNoMoreInteractions(Object... mocks) {\n-\t    MockitoCore.assertMocksNotEmpty(mocks);\n+\tpublic void verifyNoMoreInteractions(Object... mocks) {\n+\t    assertMocksNotEmpty(mocks);\n \t    MOCKING_PROGRESS.validateState();\n \t    for (Object mock : mocks) {\n \t        try {\n \t    }\n \t}\n \t\n-\tpublic static void assertMocksNotEmpty(Object[] mocks) {\n+\tpublic void assertMocksNotEmpty(Object[] mocks) {\n \t    if (mocks == null || mocks.length == 0) {\n \t        REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n \t    }\n \t}\n \t\n-\tpublic static InOrder inOrder(Object... mocks) {\n+\tpublic InOrder inOrder(Object... mocks) {\n \t    if (mocks == null || mocks.length == 0) {\n \t        REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n \t    }\n \t    return inOrder;\n \t}\n \t\n-\tpublic static Stubber doAnswer(Answer answer) {\n+\tpublic Stubber doAnswer(Answer answer) {\n \t    MOCKING_PROGRESS.stubbingStarted();\n \t    MOCKING_PROGRESS.resetOngoingStubbing();\n \t    return new StubberImpl().doAnswer(answer);\n \t}\n \t\n-\tpublic static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n+\tpublic <T> VoidMethodStubbable<T> stubVoid(T mock) {\n \t    MockHandler<T> handler = MockUtil.getMockHandler(mock);\n \t    MOCKING_PROGRESS.stubbingStarted();\n \t    return handler.voidMethodStubbable(mock);\n--- a/src/org/mockito/internal/returnvalues/MockReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/MockReturnValues.java\n \n public class MockReturnValues implements ReturnValues {\n \t\n+    private MockitoCore mockitoCore = new MockitoCore();\n \tprivate ReturnValues delegate = new MoreEmptyReturnValues();\n \t\n \tpublic Object valueFor(InvocationOnMock invocation){\n \t\t\treturn null;\n \t\t}\n \t\t\n-\t\treturn MockitoCore.mock((Class)class1, null, null, this);\n+\t\treturn mockitoCore.mock((Class)class1, null, null, this);\n \t}\n \n }", "timestamp": 1239803691, "metainfo": ""}