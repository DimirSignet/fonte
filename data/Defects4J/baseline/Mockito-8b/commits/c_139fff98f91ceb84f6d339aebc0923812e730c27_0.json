{"sha": "139fff98f91ceb84f6d339aebc0923812e730c27", "log": "issue 260 : scan inlined mocks for dependency injection", "commit": "\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldReader;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n  */\n @SuppressWarnings({\"deprecation\", \"unchecked\"})\n public class InjectingAnnotationEngine implements AnnotationEngine {\n-    \n+    MockUtil mockUtil = new MockUtil();\n     AnnotationEngine delegate = new DefaultAnnotationEngine();\n     AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n \n \n     /**\n      * Initializes mock/spies dependencies for objects annotated with\n-     * &#064;InjectMocks for given testClass.\n+     * &#064;InjectMocks for given testClassInstance.\n      * <p>\n      * See examples in javadoc for {@link MockitoAnnotations} class.\n      * \n-     * @param testClass\n+     * @param testClassInstance\n      *            Test class, usually <code>this</code>\n      */\n-    public void injectMocks(final Object testClass) {\n-        Class<?> clazz = testClass.getClass();\n+    public void injectMocks(final Object testClassInstance) {\n+        Class<?> clazz = testClassInstance.getClass();\n         Set<Field> mockDependentFields = new HashSet<Field>();\n         Set<Object> mocks = new HashSet<Object>();\n         \n         while (clazz != Object.class) {\n-            mockDependentFields.addAll(scanForInjection(testClass, clazz));\n-            mocks.addAll(scanMocks(testClass, clazz));\n+            mockDependentFields.addAll(scanForInjection(testClassInstance, clazz));\n+            mocks.addAll(scanMocks(testClassInstance, clazz));\n             clazz = clazz.getSuperclass();\n         }\n         \n-        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClass);\n+        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n     }\n \n     /**\n      * Scan fields annotated by &#064;InjectMocks\n      *\n-     * @param testClass\n-     * @param clazz\n-     * @return\n+     * @param testClassInstance Instance of the test\n+     * @param clazz Current class in the hierarchy of the test\n+     * @return Fields that depends on Mock\n      */\n-    private Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n+    private Set<Field> scanForInjection(final Object testClassInstance, final Class<?> clazz) {\n         Set<Field> mockDependentFields = new HashSet<Field>();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n         return mockDependentFields;\n     }\n \n-    private Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n+    private Set<Object> scanMocks(final Object testClassInstance, final Class<?> clazz) {\n         Set<Object> mocks = new HashSet<Object>();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n-            if (null != field.getAnnotation(Spy.class) || null != field.getAnnotation(org.mockito.Mock.class)\n-                    || null != field.getAnnotation(org.mockito.MockitoAnnotations.Mock.class)) {\n-                Object fieldInstance = null;\n-                boolean wasAccessible = field.isAccessible();\n-                field.setAccessible(true);\n-                try {\n-                    fieldInstance = field.get(testClass);\n-                } catch (IllegalAccessException e) {\n-                    throw new MockitoException(\"Problems reading this field dependency \" + field.getName() + \" for injection\", e);\n-                } finally {\n-                    field.setAccessible(wasAccessible);\n-                }\n+            FieldReader fieldReader = new FieldReader(testClassInstance, field);\n+            if (containsMockOrSpy(field, fieldReader)) {\n+                Object fieldInstance = fieldReader.read();\n+//                boolean wasAccessible = field.isAccessible();\n+//                field.setAccessible(true);\n+//                try {\n+//                    fieldInstance = field.get(testClassInstance);\n+//                } catch (IllegalAccessException e) {\n+//                    throw new MockitoException(\"Problems reading this field dependency \" + field.getName() + \" for injection\", e);\n+//                } finally {\n+//                    field.setAccessible(wasAccessible);\n+//                }\n                 if (fieldInstance != null) {\n                     mocks.add(fieldInstance);\n                 }\n         }\n         return mocks;\n     }\n+\n+    private boolean containsMockOrSpy(Field field, FieldReader fieldReader) {\n+        return null != field.getAnnotation(Spy.class)\n+                || null != field.getAnnotation(Mock.class)\n+                || null != field.getAnnotation(MockitoAnnotations.Mock.class)\n+                || mockUtil.isMock(fieldReader.read())\n+                || mockUtil.isSpy(fieldReader.read());\n+    }\n }\n--- a/src/org/mockito/internal/util/ArrayUtils.java\n+++ b/src/org/mockito/internal/util/ArrayUtils.java\n \n @SuppressWarnings(\"unchecked\")\n public class ArrayUtils {\n-    public Class<?>[] concat(Class<?>[] interfaces, Class<?> clazz) {\n-        int length = interfaces.length;\n-        Class[] out = new Class[length +1];\n-        System.arraycopy(interfaces, 0, out, 0, length);\n-        out[length] = clazz;\n+    public Class<?>[] concat(Class<?>[] interfaces, Class<?>... clazz) {\n+        int interfacesCount = interfaces.length;\n+        int appendedCount = clazz.length;\n+        Class[] out = new Class[interfacesCount + appendedCount];\n+        System.arraycopy(interfaces, 0, out, 0, interfacesCount);\n+        System.arraycopy(clazz, 0, out, interfacesCount, appendedCount);\n         return out;\n     }\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n         settings.initiateMockName(classToMock);\n \n         MethodInterceptorFilter filter = newMethodInterceptorFilter(settings);\n+        Class<?>[] ancillaryTypes = prepareAncillaryTypes(settings);\n+\n+\n+        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n+\n+        Object spiedInstance = settings.getSpiedInstance();\n+        if (spiedInstance != null) {\n+            new LenientCopyTool().copyToMock(spiedInstance, mock);\n+        }\n+        \n+        return mock;\n+    }\n+\n+    private Class<?>[] prepareAncillaryTypes(MockSettingsImpl settings) {\n         Class<?>[] interfaces = settings.getExtraInterfaces();\n \n         Class<?>[] ancillaryTypes;\n         } else {\n             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n         }\n-\n-        Object spiedInstance = settings.getSpiedInstance();\n-        \n-        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n-        \n-        if (spiedInstance != null) {\n-            new LenientCopyTool().copyToMock(spiedInstance, mock);\n+        if (settings.getSpiedInstance() != null) {\n+            ancillaryTypes = new ArrayUtils().concat(ancillaryTypes, MockitoSpy.class);\n         }\n-        \n-        return mock;\n+        return ancillaryTypes;\n     }\n \n     public <T> void resetMock(T mock) {\n         }\n     }\n \n+    public boolean isMock(Object mock) {\n+        return mock != null && isMockitoMock(mock);\n+    }\n+\n+    public boolean isSpy(Object mock) {\n+        return mock instanceof MockitoSpy && isMock(mock);\n+    }\n+\n     private <T> boolean isMockitoMock(T mock) {\n         return getInterceptor(mock) != null;\n-    }\n-\n-    public boolean isMock(Object mock) {\n-        return mock != null && isMockitoMock(mock);\n     }\n \n     private <T> MethodInterceptorFilter getInterceptor(T mock) {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockitoSpy.java\n+package org.mockito.internal.util;\n+\n+/**\n+ * Mark internally a MockitoSpy.\n+ *\n+ * To be used un conjunction with {@link MockUtil#isMock(Object)}\n+ */\n+public interface MockitoSpy {\n+}\n--- a/test/org/mockito/internal/util/ArrayUtilsTest.java\n+++ b/test/org/mockito/internal/util/ArrayUtilsTest.java\n import java.io.Serializable;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n public class ArrayUtilsTest extends TestBase {\n \n     }\n \n     @Test\n-    public void shouldConcatenateItemToFullArray() throws Exception {\n+    public void shouldConcatenateItemsToFullArray() throws Exception {\n         //when\n-        Class<?>[] items = utils.concat(new Class[] {Serializable.class, Map.class}, List.class);\n+        Class<?>[] items = utils.concat(new Class[] {Serializable.class, Map.class}, List.class, Set.class);\n \n         //then\n-        Assertions.assertThat(items).containsOnly(Serializable.class, Map.class, List.class);\n+        Assertions.assertThat(items).containsOnly(Serializable.class, Map.class, List.class, Set.class);\n     }\n }\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n         assertFalse(mockUtil.isMock(\"i mock a mock\"));\n         assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n     }\n+\n+    @Test\n+    public void shouldValidateSpy() {\n+        assertFalse(mockUtil.isSpy(\"i mock a mock\"));\n+        assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));\n+        assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java\n+package org.mockitousage.annotation;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class InjectionOfInlinedMockDeclarationTest {\n+\n+    @InjectMocks private Receiver receiver;\n+    @InjectMocks private Receiver spiedReceiver = spy(new Receiver());\n+\n+    private Antena antena = mock(Antena.class);\n+    private Tuner tuner = spy(new Tuner());\n+\n+    @Test\n+    public void mock_declared_fields_shall_be_injected_too() throws Exception {\n+        assertNotNull(receiver.antena);\n+        assertNotNull(receiver.tuner);\n+    }\n+\n+    @Test\n+    public void inject_mocks_even_in_declared_spy() throws Exception {\n+        assertNotNull(spiedReceiver.antena);\n+        assertNotNull(spiedReceiver.tuner);\n+    }\n+\n+    // note that static class is not private !!\n+    static class Receiver {\n+        Antena antena;\n+        Tuner tuner;\n+\n+        public boolean tune() { return true; }\n+    }\n+\n+    private static class Antena { }\n+    private static class Tuner { }\n+\n+}", "timestamp": 1318008227, "metainfo": ""}