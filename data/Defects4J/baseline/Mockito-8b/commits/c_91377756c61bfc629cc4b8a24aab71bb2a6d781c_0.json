{"sha": "91377756c61bfc629cc4b8a24aab71bb2a6d781c", "log": "renamed to MockHandler  --HG-- rename : src/org/mockito/internal/MockControl.java => src/org/mockito/internal/MockHandler.java rename : test/org/mockito/internal/MockControlTest.java => test/org/mockito/internal/MockHandlerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40211", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n package org.mockito;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.MockControl;\n+import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockUtil;\n import org.mockito.internal.creation.MockFactory;\n import org.mockito.internal.creation.ObjectMethodsFilter;\n \n     public static <T> T mock(Class<T> classToMock) {\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n-        MockControl<T> mockControl = new MockControl<T>(MOCKING_PROGRESS, new MatchersBinder());\n-        return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n-                classToMock, mockControl));\n+        MockHandler<T> mockHandler = new MockHandler<T>(MOCKING_PROGRESS, new MatchersBinder());\n+        return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockHandler>(\n+                classToMock, mockHandler));\n     }\n \n     public static <T> OngoingStubbing<T> stub(T methodCallToStub) {\n         assertMocksNotEmpty(mocks);\n         MOCKING_PROGRESS.validateState();\n         for (Object mock : mocks) {\n-            MockUtil.getControl(mock).verifyNoMoreInteractions();\n+            MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n         }\n     }\n \n     }\n \n     public static <T> VoidMethodStubable<T> stubVoid(T mock) {\n-        MockControl<T> control = MockUtil.getControl(mock);\n+        MockHandler<T> handler = MockUtil.getMockHandler(mock);\n         MOCKING_PROGRESS.stubbingStarted();\n-        return control;\n+        return handler;\n     }\n \n     public static Strictly createStrictOrderVerifier(Object ... mocks) {\n--- a/src/org/mockito/internal/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n     public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n         List<Invocation> allInvocations = new LinkedList<Invocation>();\n         for (Object mock : mocks) {\n-            List<Invocation> invocationsOfSingleMock = MockUtil.getControl(mock).getRegisteredInvocations();\n+            List<Invocation> invocationsOfSingleMock = MockUtil.getMockHandler(mock).getRegisteredInvocations();\n             allInvocations.addAll(invocationsOfSingleMock);\n         }\n         return allInvocations;\n--- /dev/null\n+++ b/src/org/mockito/internal/MockHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.mockito.internal.creation.MockAwareInvocationHandler;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsChunker;\n+import org.mockito.internal.invocation.InvocationsMarker;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.stubbing.EmptyReturnValues;\n+import org.mockito.internal.stubbing.StubbedMethodSelector;\n+import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.VoidMethodStubable;\n+import org.mockito.internal.verification.MissingInvocationVerifier;\n+import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n+import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n+import org.mockito.internal.verification.Verifier;\n+import org.mockito.internal.verification.VerifyingRecorder;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ *\n+ * @param <T> type of mock object to handle\n+ */\n+public class MockHandler<T> implements MockAwareInvocationHandler<T>, OngoingStubbing<T>, VoidMethodStubable<T>, StubbedMethodSelector<T> {\n+\n+    private final VerifyingRecorder verifyingRecorder;\n+    private final Stubber stubber;\n+    private final MatchersBinder matchersBinder;\n+    private final MockingProgress mockingProgress;\n+    \n+    private T mock;\n+    \n+    public MockHandler(MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n+        this.mockingProgress = mockingProgress;\n+        this.matchersBinder = matchersBinder;\n+        stubber = new Stubber(mockingProgress);\n+        \n+        verifyingRecorder = createRecorder(); \n+    }\n+\n+    private VerifyingRecorder createRecorder() {\n+        InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder());\n+        InvocationsMarker marker = new InvocationsMarker();\n+        List<Verifier> verifiers = Arrays.asList(\n+                new MissingInvocationVerifier(), \n+                new NumberOfInvocationsVerifier(),\n+                new NoMoreInvocationsVerifier());\n+        return new VerifyingRecorder(chunker, marker, verifiers);\n+    }\n+\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+        if (stubber.hasThrowableForVoidMethod()) {\n+            Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n+            stubber.addVoidMethodForThrowable(invocationMatcher);\n+            return null;\n+        }\n+        \n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+        mockingProgress.validateState();\n+        \n+        Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n+        \n+        if (verificationMode != null) {\n+            verifyingRecorder.verify(invocationMatcher, verificationMode);\n+            return EmptyReturnValues.emptyValueFor(method.getReturnType());\n+        } \n+        \n+        stubber.setInvocationForPotentialStubbing(invocationMatcher);\n+        verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n+\n+        mockingProgress.reportStubable(this);\n+        \n+        return stubber.resultFor(invocationMatcher.getInvocation());\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        verifyingRecorder.verify(VerificationMode.noMoreInteractions());\n+    }\n+    \n+    public void andReturn(T value) {\n+        verifyingRecorder.eraseLastInvocation();\n+        stubber.addReturnValue(value);\n+    }\n+\n+    public void andThrow(Throwable throwable) {\n+        verifyingRecorder.eraseLastInvocation();\n+        stubber.addThrowable(throwable);\n+    }\n+    \n+    public StubbedMethodSelector<T> toThrow(Throwable throwable) {\n+        stubber.addThrowableForVoidMethod(throwable);\n+        return this;\n+    }\n+\n+    public T on() {\n+        return mock;\n+    }\n+\n+    public void setMock(T mock) {\n+        this.mock = mock;\n+    }\n+\n+    public List<Invocation> getRegisteredInvocations() {\n+        return verifyingRecorder.getRegisteredInvocations();\n+    }\n+}\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n-    public static <T> MockControl<T> getControl(T mock) {\n+    public static <T> MockHandler<T> getMockHandler(T mock) {\n         if (mock == null) {\n             throw new MockitoException(\"Mock cannot be null\");\n         }\n         \n-        ObjectMethodsFilter<MockControl<T>> handler;\n+        ObjectMethodsFilter<MockHandler<T>> handler;\n \n         try {\n             if (Enhancer.isEnhanced(mock.getClass())) {\n     }\n     \n     public static void validateMock(Object mock) {\n-        getControl(mock);\n+        getMockHandler(mock);\n     }\n }\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n \n     void reportStubable(OngoingStubbing ongoingStubbing);\n \n+    //TODO stubabble\n     OngoingStubbing pullStubable();\n \n     void verificationStarted(VerificationMode verificationMode);\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n \n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.fail;\n-import static org.mockito.internal.MockUtil.getControl;\n+import static org.mockito.internal.MockUtil.getMockHandler;\n import static org.mockito.internal.MockUtil.validateMock;\n \n import java.util.ArrayList;\n \n     @SuppressWarnings(\"unchecked\")\n     @Test \n-    public void shouldGetControl() {\n+    public void shouldGetHandler() {\n         List mock = Mockito.mock(List.class);\n-        assertNotNull(getControl(mock));\n+        assertNotNull(getMockHandler(mock));\n     }\n \n     @Test \n     public void shouldScreamWhenEnhancedButNotAMockPassed() {\n         Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);\n         try {\n-            getControl(o);\n+            getMockHandler(o);\n             fail();\n         } catch (NotAMockException e) {}\n     }\n \n     @Test (expected=NotAMockException.class)\n     public void shouldScreamWhenNotAMockPassed() {\n-        getControl(\"\");\n+        getMockHandler(\"\");\n     }\n     \n     @Test (expected=MockitoException.class)\n     public void shouldScreamWhenNullPassed() {\n-        getControl(null);\n+        getMockHandler(null);\n     }\n     \n     @Test (expected=NotAMockException.class)\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n public class MockitoTest extends RequiresValidState {\n \n     @Test\n-    public void shouldRemoveStubbedControlFromStateWhenStubbing() {\n+    public void shouldRemoveStubableFromProgressAfterStubbing() {\n         List mock = Mockito.mock(List.class);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n--- /dev/null\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.progress.VerificationMode;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockHandlerTest extends RequiresValidState {\n+    \n+    @Test\n+    public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+        MockingProgressImpl state = new MockingProgressImpl();\n+        state.verificationStarted(VerificationMode.atLeastOnce());\n+        MockHandler handler = new MockHandler(state, new ExceptionThrowingBinder());\n+        \n+        try {\n+            handler.invoke(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{});\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {}\n+        \n+        assertNull(state.pullVerificationMode());\n+    }\n+    \n+    private class ExceptionThrowingBinder extends MatchersBinder {\n+        @Override\n+        public InvocationMatcher bindMatchers(Invocation invocation) {\n+            throw new InvalidUseOfMatchersException(\"\");\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n import org.mockito.exceptions.base.MockitoExceptionTest;\n-import org.mockito.internal.MockControlTest;\n+import org.mockito.internal.MockHandlerTest;\n import org.mockito.internal.creation.CglibTest;\n import org.mockito.internal.creation.MockFactoryTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n                     MatchersTest.class,\n                     ReplacingObjectMethodsTest.class,\n                     //below are tests that mess up the state\n-                    MockControlTest.class,\n+                    MockHandlerTest.class,\n                     MockitoTest.class,\n                     InvalidUsageTest.class,\n                     InvalidUseOfMatchersTest.class,\n--- a/test/org/mockitousage/StackTrackeFilteringTest.java\n+++ b/test/org/mockitousage/StackTrackeFilteringTest.java\n     }\n     \n     @Test\n-    public void shouldFilterStackTraceWhenThrowingExceptionFromControl() {\n+    public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler() {\n         try {\n             stub(mock.oneArg(true)).andThrow(new Exception());\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromControl\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromMockHandler\"));\n         }\n     }\n     ", "timestamp": 1197733985, "metainfo": ""}