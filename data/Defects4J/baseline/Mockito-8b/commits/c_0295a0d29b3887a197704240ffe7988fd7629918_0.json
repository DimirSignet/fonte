{"sha": "0295a0d29b3887a197704240ffe7988fd7629918", "log": "Updated headers so that it contains open-source license, etc  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401882", "commit": "\n--- a/src/org/mockito/Captor.java\n+++ b/src/org/mockito/Captor.java\n-/*\n- * Copyright (c) 2010 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito;\n-\n-import java.lang.annotation.*;\n-\n-/**\n- * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n- * <p>Example:\n- * <pre>\n- * public class Test{\n- *\n- *    &#64;Captor ArgumentCaptor&lt;AsyncCallback&lt;Foo&gt;&gt; captor;\n- *\n- *    &#64;Before\n- *    public void init(){\n- *       MockitoAnnotations.init(this);\n- *    }\n- *\n- *    &#64;Test public void shouldDoSomethingUseful() {\n- *       //...\n- *       verify(mock.doStuff(captor.capture()));\n- *       assertEquals(\"foo\", captor.getValue());\n- *    }\n- * }\n- * </pre>\n- * <p>\n- * One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n- */\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.FIELD)\n-@Documented\n-public @interface Captor {}\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n+ * <p>Example:\n+ * <pre>\n+ * public class Test{\n+ *\n+ *    &#64;Captor ArgumentCaptor&lt;AsyncCallback&lt;Foo&gt;&gt; captor;\n+ *\n+ *    &#64;Before\n+ *    public void init(){\n+ *       MockitoAnnotations.init(this);\n+ *    }\n+ *\n+ *    &#64;Test public void shouldDoSomethingUseful() {\n+ *       //...\n+ *       verify(mock.doStuff(captor.capture()));\n+ *       assertEquals(\"foo\", captor.getValue());\n+ *    }\n+ * }\n+ * </pre>\n+ * <p>\n+ * One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+@Documented\n+public @interface Captor {}\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.Documented;\n--- a/src/org/mockito/MockitoDebugger.java\n+++ b/src/org/mockito/MockitoDebugger.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n public interface MockitoDebugger {\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n-package org.mockito;\n-\n-import java.lang.annotation.*;\n-\n-/**\n- * Allows shorthand wrapping of field instances in an spy object.\n- * \n- * <p>\n- * Example:\n- * \n- * <pre>\n- * public class Test{\n- *    &#64;Spy Foo spyOnFoo = new Foo();\n- *    &#64;Before\n- *    public void init(){\n- *       MockitoAnnotations.init(this);\n- *    }\n- *    ...\n- * }\n- * </pre>\n- * <p>\n- * Same as doing:\n- * \n- * <pre>\n- * Foo spyOnFoo = Mockito.spy(new Foo());\n- * </pre>\n- * \n- * <b>Warning</b> if you call <code>MockitoAnnotations.init(this)</code> in a\n- * super class <b>constructor</b> then this will not work. It is because fields\n- * in subclass are only instantiated after super class constructor has returned.\n- * It's better to use &#64;Before.\n- */\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.FIELD)\n-@Documented\n-public @interface Spy {\n-}\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Allows shorthand wrapping of field instances in an spy object.\n+ * \n+ * <p>\n+ * Example:\n+ * \n+ * <pre>\n+ * public class Test{\n+ *    &#64;Spy Foo spyOnFoo = new Foo();\n+ *    &#64;Before\n+ *    public void init(){\n+ *       MockitoAnnotations.init(this);\n+ *    }\n+ *    ...\n+ * }\n+ * </pre>\n+ * <p>\n+ * Same as doing:\n+ * \n+ * <pre>\n+ * Foo spyOnFoo = Mockito.spy(new Foo());\n+ * </pre>\n+ * \n+ * <b>Warning</b> if you call <code>MockitoAnnotations.init(this)</code> in a\n+ * super class <b>constructor</b> then this will not work. It is because fields\n+ * in subclass are only instantiated after super class constructor has returned.\n+ * It's better to use &#64;Before.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+@Documented\n+public @interface Spy {\n+}\n--- a/src/org/mockito/internal/MockHandlerInterface.java\n+++ b/src/org/mockito/internal/MockHandlerInterface.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import java.util.List;\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import java.lang.reflect.Field;\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import java.lang.annotation.Annotation;\n--- a/src/org/mockito/internal/debugging/FindingsListener.java\n+++ b/src/org/mockito/internal/debugging/FindingsListener.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.Invocation;\n--- a/src/org/mockito/internal/debugging/LoggingListener.java\n+++ b/src/org/mockito/internal/debugging/LoggingListener.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.Invocation;\n--- a/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+++ b/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.MockitoDebugger;\n--- a/src/org/mockito/internal/debugging/WarningsCollector.java\n+++ b/src/org/mockito/internal/debugging/WarningsCollector.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import java.util.LinkedList;\n--- a/src/org/mockito/internal/debugging/WarningsFinder.java\n+++ b/src/org/mockito/internal/debugging/WarningsFinder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.Invocation;\n--- a/src/org/mockito/internal/exceptions/ExceptionIncludingMockitoWarnings.java\n+++ b/src/org/mockito/internal/exceptions/ExceptionIncludingMockitoWarnings.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.exceptions;\n \n public class ExceptionIncludingMockitoWarnings extends RuntimeException {\n--- a/src/org/mockito/internal/invocation/StubInfo.java\n+++ b/src/org/mockito/internal/invocation/StubInfo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockito.exceptions.PrintableInvocation;\n--- a/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n+++ b/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n import org.mockito.MockSettings;\n--- a/src/org/mockito/internal/listeners/MockingProgressListener.java\n+++ b/src/org/mockito/internal/listeners/MockingProgressListener.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n public interface MockingProgressListener {\n--- a/src/org/mockito/internal/listeners/MockingStartedListener.java\n+++ b/src/org/mockito/internal/listeners/MockingStartedListener.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n import org.mockito.MockSettings;\n--- a/src/org/mockito/internal/stubbing/InvocationContainer.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.mockito.internal.invocation.Invocation;\n--- a/src/org/mockito/internal/stubbing/answers/ClonesArguments.java\n+++ b/src/org/mockito/internal/stubbing/answers/ClonesArguments.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/Answers.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/Answers.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.mockito.internal.stubbing.answers.CallsRealMethods;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n /*\n- * Copyright (c) 2009 Mockito contributors\n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n--- a/src/org/mockito/internal/util/ArrayUtils.java\n+++ b/src/org/mockito/internal/util/ArrayUtils.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n @SuppressWarnings(\"unchecked\")\n--- a/src/org/mockito/internal/util/junit/JUnitFailureHacker.java\n+++ b/src/org/mockito/internal/util/junit/JUnitFailureHacker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.junit;\n \n import org.junit.runner.notification.Failure;\n--- a/src/org/mockito/internal/util/reflection/FieldReader.java\n+++ b/src/org/mockito/internal/util/reflection/FieldReader.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.Field;\n--- a/src/org/mockito/internal/util/reflection/FieldSetter.java\n+++ b/src/org/mockito/internal/util/reflection/FieldSetter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.Field;\n--- a/test/org/mockito/internal/debugging/LoggingListenerTest.java\n+++ b/test/org/mockito/internal/debugging/LoggingListenerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import static org.mockito.Matchers.*;\n--- a/test/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java\n+++ b/test/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n import org.junit.After;\n--- a/test/org/mockito/internal/util/ArrayUtilsTest.java\n+++ b/test/org/mockito/internal/util/ArrayUtilsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.fest.assertions.Assertions;\n--- a/test/org/mockito/internal/util/MockNameTest.java\n+++ b/test/org/mockito/internal/util/MockNameTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/SimpleMockitoLoggerTest.java\n+++ b/test/org/mockito/internal/util/SimpleMockitoLoggerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.junit.Test;\n--- a/test/org/mockito/internal/util/junit/JUnitFailureHackerTest.java\n+++ b/test/org/mockito/internal/util/junit/JUnitFailureHackerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.junit;\n \n import org.fest.assertions.Assertions;\n--- a/test/org/mockito/internal/verification/DummyVerificationMode.java\n+++ b/test/org/mockito/internal/verification/DummyVerificationMode.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.mockito.internal.verification.api.VerificationData;\n--- a/test/org/mockito/internal/verification/VerificationDataImplTest.java\n+++ b/test/org/mockito/internal/verification/VerificationDataImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/annotation/MockInjectionTest.java\n+++ b/test/org/mockitousage/annotation/MockInjectionTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import org.junit.Before;\n--- a/test/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import java.util.LinkedList;\n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import static org.mockito.Mockito.*;\n--- a/test/org/mockitousage/annotation/SpyInjectionTest.java\n+++ b/test/org/mockitousage/annotation/SpyInjectionTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import java.util.LinkedList;\n--- a/test/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java\n+++ b/test/org/mockitousage/annotation/WrongSetOfAnnotationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import java.util.List;\n--- a/test/org/mockitousage/debugging/Foo.java\n+++ b/test/org/mockitousage/debugging/Foo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.debugging;\n \n interface Foo {\n--- a/test/org/mockitousage/debugging/NewMockito.java\n+++ b/test/org/mockitousage/debugging/NewMockito.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.debugging;\n \n import org.mockito.Mockito;\n--- a/test/org/mockitousage/debugging/PrintingInvocationsDetectsUnusedStubTest.java\n+++ b/test/org/mockitousage/debugging/PrintingInvocationsDetectsUnusedStubTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.debugging;\n \n import static org.mockito.BDDMockito.*;\n--- a/test/org/mockitousage/debugging/PrintingInvocationsWhenEverythingOkTest.java\n+++ b/test/org/mockitousage/debugging/PrintingInvocationsWhenEverythingOkTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.debugging;\n \n import static org.mockito.BDDMockito.*;\n--- a/test/org/mockitousage/debugging/PrintingInvocationsWhenStubNotUsedTest.java\n+++ b/test/org/mockitousage/debugging/PrintingInvocationsWhenStubNotUsedTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.debugging;\n \n import org.junit.After;\n--- a/test/org/mockitousage/junitrunner/Filters.java\n+++ b/test/org/mockitousage/junitrunner/Filters.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.junitrunner;\n \n import org.junit.runner.Description;\n--- a/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n-/*\n- * Copyright (c) 2009 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockitousage.stubbing;\n-\n-import static org.mockito.BDDMockito.*;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.OutputStream;\n-import java.net.Socket;\n-\n-import javax.net.SocketFactory;\n-\n-import org.junit.Test;\n-import org.mockitoutil.TestBase;\n-\n-\n-public class DeepStubbingTest extends TestBase {\n-\n-    static class Person {\n-        Address address;\n-\n-        public Address getAddress() {\n-            return address;\n-        }\n-        \n-        public FinalClass getFinalClass() {\n-            return null;\n-        }\n-    }\n-    \n-    static class Address {\n-        Street street;\n-\n-        public Street getStreet() {\n-            return street;\n-        }\n-    }\n-    \n-    static class Street {\n-        String name;\n-\n-        public String getName() {\n-            return name;\n-        }\n-    }    \n-    \n-    static final class FinalClass {};    \n-    \n-    @Test\n-    public void myTest() throws Exception {\n-        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf.createSocket(anyString(), eq(80))).thenReturn(null);\n-        sf.createSocket(\"what\", 80);\n-    }\n-\n-    @Test\n-    public void simpleCase() throws Exception {\n-        OutputStream out = new ByteArrayOutputStream();\n-        Socket socket = mock(Socket.class);\n-        when(socket.getOutputStream()).thenReturn(out);\n-\n-        assertSame(out, socket.getOutputStream());\n-    }\n-\n-    /**\n-     * Test that deep stubbing works for one intermediate level\n-     */\n-    @Test\n-    public void oneLevelDeep() throws Exception {\n-        OutputStream out = new ByteArrayOutputStream();\n-\n-        SocketFactory socketFactory = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(socketFactory.createSocket().getOutputStream()).thenReturn(out);\n-\n-        assertSame(out, socketFactory.createSocket().getOutputStream());\n-    }\n-\n-    /**\n-     * Test that stubbing of two mocks stubs don't interfere\n-     */\n-    @Test\n-    public void interactions() throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n-        OutputStream out2 = new ByteArrayOutputStream();\n-\n-        SocketFactory sf1 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf1.createSocket().getOutputStream()).thenReturn(out1);\n-\n-        SocketFactory sf2 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf2.createSocket().getOutputStream()).thenReturn(out2);\n-\n-        assertSame(out1, sf1.createSocket().getOutputStream());\n-        assertSame(out2, sf2.createSocket().getOutputStream());\n-    }\n-\n-    /**\n-     * Test that stubbing of methods of different arguments don't interfere\n-     */\n-    @Test\n-    public void withArguments() throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n-        OutputStream out2 = new ByteArrayOutputStream();\n-        OutputStream out3 = new ByteArrayOutputStream();\n-\n-        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf.createSocket().getOutputStream()).thenReturn(out1);\n-        when(sf.createSocket(\"google.com\", 80).getOutputStream()).thenReturn(out2);\n-        when(sf.createSocket(\"stackoverflow.com\", 80).getOutputStream()).thenReturn(out3);\n-\n-        assertSame(out1, sf.createSocket().getOutputStream());\n-        assertSame(out2, sf.createSocket(\"google.com\", 80).getOutputStream());\n-        assertSame(out3, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n-    }\n-\n-    /**\n-     * Test that deep stubbing work with argument patterns\n-     */\n-    @Test\n-    public void withAnyPatternArguments() throws Exception {\n-        OutputStream out = new ByteArrayOutputStream();\n-\n-        //TODO: should not use javax in case it changes\n-        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);\n-\n-        assertSame(out, sf.createSocket(\"google.com\", 80).getOutputStream());\n-        assertSame(out, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n-    }\n-\n-    /**\n-     * Test that deep stubbing work with argument patterns\n-     */\n-    @Test\n-    public void withComplexPatternArguments() throws Exception {\n-        OutputStream out1 = new ByteArrayOutputStream();\n-        OutputStream out2 = new ByteArrayOutputStream();\n-\n-        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf.createSocket(anyString(), eq(80)).getOutputStream()).thenReturn(out1);\n-        when(sf.createSocket(anyString(), eq(8080)).getOutputStream()).thenReturn(out2);\n-\n-        assertSame(out2, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n-        assertSame(out1, sf.createSocket(\"google.com\", 80).getOutputStream());\n-        assertSame(out2, sf.createSocket(\"google.com\", 8080).getOutputStream());\n-        assertSame(out1, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n-    }\n-\n-    /**\n-     * Test that deep stubbing work with primitive expected values\n-     */\n-    @Test\n-    public void withSimplePrimitive() throws Exception {\n-        int a = 32;\n-\n-        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf.createSocket().getPort()).thenReturn(a);\n-\n-        assertEquals(a, sf.createSocket().getPort());\n-    }\n-\n-    /**\n-     * Test that deep stubbing work with primitive expected values with\n-     * pattern method arguments\n-     */\n-    @Test\n-    public void withPatternPrimitive() throws Exception {\n-        int a = 12, b = 23, c = 34;\n-\n-        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n-        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(80)).getPort()).thenReturn(a);\n-        when(sf.createSocket(eq(\"google.com\"), anyInt()).getPort()).thenReturn(b);\n-        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(8080)).getPort()).thenReturn(c);\n-\n-        assertEquals(b, sf.createSocket(\"google.com\", 80).getPort());\n-        assertEquals(c, sf.createSocket(\"stackoverflow.com\", 8080).getPort());\n-        assertEquals(a, sf.createSocket(\"stackoverflow.com\", 80).getPort());\n-    }\n-    \n-    Person person = mock(Person.class, RETURNS_DEEP_STUBS);\n-       \n-    @Test\n-    public void shouldStubbingBasicallyWorkFine() throws Exception {\n-        //given\n-        given(person.getAddress().getStreet().getName()).willReturn(\"Norymberska\");\n-        \n-        //when\n-        String street = person.getAddress().getStreet().getName();\n-        \n-        //then\n-        assertEquals(\"Norymberska\", street);\n-    }    \n-    \n-    @Test\n-    public void shouldVerificationBasicallyWorkFine() throws Exception {\n-        //given\n-        person.getAddress().getStreet().getName();\n-        \n-        //then\n-        verify(person.getAddress().getStreet()).getName();\n-    }   \n-    \n-    @Test\n-    public void shouldFailGracefullyWhenClassIsFinal() throws Exception {\n-        //when        \n-        FinalClass value = new FinalClass();\n-        given(person.getFinalClass()).willReturn(value);\n-        \n-        //then\n-        assertEquals(value, person.getFinalClass());\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.mockito.BDDMockito.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+\n+import javax.net.SocketFactory;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class DeepStubbingTest extends TestBase {\n+\n+    static class Person {\n+        Address address;\n+\n+        public Address getAddress() {\n+            return address;\n+        }\n+        \n+        public FinalClass getFinalClass() {\n+            return null;\n+        }\n+    }\n+    \n+    static class Address {\n+        Street street;\n+\n+        public Street getStreet() {\n+            return street;\n+        }\n+    }\n+    \n+    static class Street {\n+        String name;\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }    \n+    \n+    static final class FinalClass {};    \n+    \n+    @Test\n+    public void myTest() throws Exception {\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), eq(80))).thenReturn(null);\n+        sf.createSocket(\"what\", 80);\n+    }\n+\n+    @Test\n+    public void simpleCase() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+        Socket socket = mock(Socket.class);\n+        when(socket.getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, socket.getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing works for one intermediate level\n+     */\n+    @Test\n+    public void oneLevelDeep() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+\n+        SocketFactory socketFactory = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(socketFactory.createSocket().getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, socketFactory.createSocket().getOutputStream());\n+    }\n+\n+    /**\n+     * Test that stubbing of two mocks stubs don't interfere\n+     */\n+    @Test\n+    public void interactions() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf1 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf1.createSocket().getOutputStream()).thenReturn(out1);\n+\n+        SocketFactory sf2 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf2.createSocket().getOutputStream()).thenReturn(out2);\n+\n+        assertSame(out1, sf1.createSocket().getOutputStream());\n+        assertSame(out2, sf2.createSocket().getOutputStream());\n+    }\n+\n+    /**\n+     * Test that stubbing of methods of different arguments don't interfere\n+     */\n+    @Test\n+    public void withArguments() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+        OutputStream out3 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket().getOutputStream()).thenReturn(out1);\n+        when(sf.createSocket(\"google.com\", 80).getOutputStream()).thenReturn(out2);\n+        when(sf.createSocket(\"stackoverflow.com\", 80).getOutputStream()).thenReturn(out3);\n+\n+        assertSame(out1, sf.createSocket().getOutputStream());\n+        assertSame(out2, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out3, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with argument patterns\n+     */\n+    @Test\n+    public void withAnyPatternArguments() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+\n+        //TODO: should not use javax in case it changes\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with argument patterns\n+     */\n+    @Test\n+    public void withComplexPatternArguments() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), eq(80)).getOutputStream()).thenReturn(out1);\n+        when(sf.createSocket(anyString(), eq(8080)).getOutputStream()).thenReturn(out2);\n+\n+        assertSame(out2, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n+        assertSame(out1, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out2, sf.createSocket(\"google.com\", 8080).getOutputStream());\n+        assertSame(out1, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with primitive expected values\n+     */\n+    @Test\n+    public void withSimplePrimitive() throws Exception {\n+        int a = 32;\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket().getPort()).thenReturn(a);\n+\n+        assertEquals(a, sf.createSocket().getPort());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with primitive expected values with\n+     * pattern method arguments\n+     */\n+    @Test\n+    public void withPatternPrimitive() throws Exception {\n+        int a = 12, b = 23, c = 34;\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(80)).getPort()).thenReturn(a);\n+        when(sf.createSocket(eq(\"google.com\"), anyInt()).getPort()).thenReturn(b);\n+        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(8080)).getPort()).thenReturn(c);\n+\n+        assertEquals(b, sf.createSocket(\"google.com\", 80).getPort());\n+        assertEquals(c, sf.createSocket(\"stackoverflow.com\", 8080).getPort());\n+        assertEquals(a, sf.createSocket(\"stackoverflow.com\", 80).getPort());\n+    }\n+    \n+    Person person = mock(Person.class, RETURNS_DEEP_STUBS);\n+       \n+    @Test\n+    public void shouldStubbingBasicallyWorkFine() throws Exception {\n+        //given\n+        given(person.getAddress().getStreet().getName()).willReturn(\"Norymberska\");\n+        \n+        //when\n+        String street = person.getAddress().getStreet().getName();\n+        \n+        //then\n+        assertEquals(\"Norymberska\", street);\n+    }    \n+    \n+    @Test\n+    public void shouldVerificationBasicallyWorkFine() throws Exception {\n+        //given\n+        person.getAddress().getStreet().getName();\n+        \n+        //then\n+        verify(person.getAddress().getStreet()).getName();\n+    }   \n+    \n+    @Test\n+    public void shouldFailGracefullyWhenClassIsFinal() throws Exception {\n+        //when        \n+        FinalClass value = new FinalClass();\n+        given(person.getFinalClass()).willReturn(value);\n+        \n+        //then\n+        assertEquals(value, person.getFinalClass());\n+    }\n }", "timestamp": 1267996421, "metainfo": ""}