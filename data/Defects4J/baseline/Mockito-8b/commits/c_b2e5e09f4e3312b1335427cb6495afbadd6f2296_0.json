{"sha": "b2e5e09f4e3312b1335427cb6495afbadd6f2296", "log": "fixed javadoc fixed a bug that returned collections where static and therefore could potentially keep objects  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40364", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * </pre>\n  * \n  * <p>\n- * Once created, mock object will record all invocations. Then you can\n+ * Once created, mock will remember all invocations. Then you can\n  * selectively verify whatever interaction you are interested in.\n  * \n  * <h3>How about some stubbing?</h3>\n  * \n  * <pre>\n- * //You can create mocks of concrete classes, not only interfaces\n+ * //You can mock concrete classes, not only interfaces\n  * LinkedList mockedList = mock(LinkedList.class);\n  * \n  * //stubbing\n  * //following throws runtime exception\n  * System.out.println(mockedList.get(1));\n  * \n- * //following prints \"null\"\n+ * //following prints \"null\" because get(999) was not stubbed\n  * System.out.println(mockedList.get(999));\n  * \n- * //if you want you can still verify stubbed invocation\n+ * //if you really want you can still verify stubbed invocation. In most cases it's not necessary, though. \n  * verify(mockedList).get(0);\n  * </pre>\n  * \n  * <ul>\n  * <li>\n- * By default, for all methods that return value, mock object will return null,\n+ * By default, for all methods that return value, mock will return null,\n  * appropriate primitive value (0, false, etc.) or an empty collection.\n+ * </li>\n+ * <li>\n+ * Stubbing can be overridden: for example common stubbing can go to fixture setup\n+ * but test methods can override it anyway\n  * </li>\n  * <li>\n  * Once stubbed, mocked method will always return stubbed value regardless of how many times it is called.\n  * </li>\n  * <li>\n- * Last stubbing is more important - when you stubbed the same method many times.\n+ * Last stubbing is more important - when you stubbed the same method with the same arguments many times.\n  * </li>\n  * <li>\n- * Although it's possible to verify stubbed methods it's a good pattern to focus on testing if stubbed value is used correctly.\n+ * Although it's possible to verify stubbed methods it's a good pattern to focus on testing that stubbed value is used correctly.\n  * </li> \n  * </ul>\n  * \n      *\n      * For stubbing void methods with throwables see: {@link Mockito#stubVoid}\n      * <p>\n+     * Stubbing can be overridden: for example common stubbing can go to fixture setup\n+     * but test methods can override it anyway \n+     * <p>\n      * Once stubbed, mocked method will always return stubbed value regardless of how many times it is called.\n      * <p>\n-     * Last stubbing is more important - when you stubbed the same method many times.\n+     * Last stubbing is more important - when you stubbed the same method with the same arguments many times.\n+     * <p>\n+     * Although it's possible to verify stubbed methods it's a good pattern to focus on testing that stubbed value is used correctly.\n      * <p>\n      * See examples in javadoc for {@link Mockito}\n      * \n--- a/src/org/mockito/internal/stubbing/EmptyReturnValues.java\n+++ b/src/org/mockito/internal/stubbing/EmptyReturnValues.java\n \n public class EmptyReturnValues {\n     \n+    //new instances are used instead of Collections.emptyList(), etc.\n+    //to avoid UnsupportedOperationException if code under test modifies returned collection\n     public static Object emptyValueFor(Class<?> type) {\n-        return emptyReturnValueToType.get(type);\n-    }\n-    \n-    @SuppressWarnings(\"unchecked\")\n-    private static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n-    \n-    static {\n-        emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());\n+        if (type == Collection.class) {\n+            return new LinkedList<Object>();\n+        } else if (type == Set.class) {\n+            return new HashSet<Object>();\n+        } else if (type == HashSet.class) {\n+            return new HashSet<Object>();\n+        } else if (type == SortedSet.class) {\n+            return new TreeSet<Object>();\n+        } else if (type == TreeSet.class) {\n+            return new TreeSet<Object>();\n+        } else if (type == LinkedHashSet.class) {\n+            return new LinkedHashSet<Object>();\n+        } else if (type == List.class) {\n+            return new LinkedList<Object>();\n+        } else if (type == LinkedList.class) {\n+            return new LinkedList<Object>();\n+        } else if (type == ArrayList.class) {\n+            return new ArrayList<Object>();\n+        } else if (type == Map.class) {\n+            return new HashMap<Object, Object>();\n+        } else if (type == HashMap.class) {\n+            return new HashMap<Object, Object>();\n+        } else if (type == SortedMap.class) {\n+            return new TreeMap<Object, Object>();\n+        } else if (type == TreeMap.class) {\n+            return new TreeMap<Object, Object>();\n+        } else if (type == LinkedHashMap.class) {\n+            return new LinkedHashMap<Object, Object>();\n+        }       \n         \n-        emptyReturnValueToType.put(Set.class, new HashSet<Object>());\n-        emptyReturnValueToType.put(HashSet.class, new HashSet<Object>());\n-        emptyReturnValueToType.put(SortedSet.class, new TreeSet<Object>());        \n-        emptyReturnValueToType.put(TreeSet.class, new TreeSet<Object>());\n-        emptyReturnValueToType.put(LinkedHashSet.class, new LinkedHashSet<Object>());        \n-\n-        emptyReturnValueToType.put(List.class, new LinkedList<Object>());       \n-        emptyReturnValueToType.put(LinkedList.class, new LinkedList<Object>());\n-        emptyReturnValueToType.put(ArrayList.class, new ArrayList<Object>());\n-        \n-        emptyReturnValueToType.put(Map.class, new HashMap<Object, Object>());\n-        emptyReturnValueToType.put(HashMap.class, new HashMap<Object, Object>());\n-        emptyReturnValueToType.put(SortedMap.class, new TreeMap<Object, Object>());        \n-        emptyReturnValueToType.put(TreeMap.class, new TreeMap<Object, Object>());\n-        emptyReturnValueToType.put(LinkedHashMap.class, new LinkedHashMap<Object, Object>());\n+        //let's not care about the rest of collections\n+        return null;\n     }\n }\n--- a/test/org/mockito/internal/stubbing/EmptyReturnValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/EmptyReturnValuesTest.java\n  */\n package org.mockito.internal.stubbing;\n \n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n import java.util.Collection;\n--- a/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n+++ b/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n  */\n package org.mockitousage.stubbing;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.*;\n \n import java.util.LinkedList;\n import java.util.List;\n         assertTrue(mock.map().isEmpty());\n         assertTrue(mock.hashSet().isEmpty());\n     }\n-\n+    \n+    @Test \n+    public void shouldReturnMutableEmptyCollection() {\n+        CollectionsServer mock = Mockito.mock(CollectionsServer.class);\n+        \n+        List list = mock.list();\n+        list.add(\"test\");\n+       \n+        assertTrue(mock.list().isEmpty());\n+    }\n+    \n     private class CollectionsServer {\n         List list() {\n             return null;", "timestamp": 1202847238, "metainfo": ""}