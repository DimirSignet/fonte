{"sha": "14065beb6cae316d657c8a3639e8b4c4cbdc1776", "log": "draft version of spy() feature  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40671", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * \n  * <h1>Contents</h1>\n  * \n- * <b>\n- *         1. Let's verify some behaviour!\n- *   <br/> 2. How about some stubbing?\n- *   <br/> 3. Argument matchers\n- *   <br/> 4. Verifying exact number of invocations / at least once / never\n- *   <br/> 5. Stubbing void methods with exceptions\n- *   <br/> 6. Verification in order\n- *   <br/> 7. Making sure interaction(s) never happened on mock\n- *   <br/> 8. Finding redundant invocations\n- *   <br/> 9. Shorthand for mocks creation - &#064;Mock annotation\n- *   <br/> 10. (**New**) Stubbing consecutive calls (iterator-style stubbing)\n- *   <br/> 11. (**New**) Stubbing with callbacks\n+ * <b> 1. Let's verify some behaviour! <br/> 2. How about some stubbing? <br/>\n+ * 3. Argument matchers <br/> 4. Verifying exact number of invocations / at\n+ * least once / never <br/> 5. Stubbing void methods with exceptions <br/> 6.\n+ * Verification in order <br/> 7. Making sure interaction(s) never happened on\n+ * mock <br/> 8. Finding redundant invocations <br/> 9. Shorthand for mocks\n+ * creation - &#064;Mock annotation <br/> 10. (**New**) Stubbing consecutive\n+ * calls (iterator-style stubbing) <br/> 11. (**New**) Stubbing with callbacks\n  * </b>\n  * \n  * <p>\n- * Following examples mock List, because everyone knows its interface (methods like add(), get(), clear() will be used). \n- * <br>You probably wouldn't mock List class 'in real'.  \n+ * Following examples mock List, because everyone knows its interface (methods\n+ * like add(), get(), clear() will be used). <br>\n+ * You probably wouldn't mock List class 'in real'.\n  * \n  * <h3>1. Let's verify some behaviour!</h3>\n  * \n  * </pre>\n  * \n  * <p>\n- * Once created, mock will remember all invocations. Then you can\n- * selectively verify whatever interaction you are interested in.\n+ * Once created, mock will remember all invocations. Then you can selectively\n+ * verify whatever interaction you are interested in.\n  * \n  * <h3>2. How about some stubbing?</h3>\n  * \n  * //following prints \"null\" because get(999) was not stubbed\n  * System.out.println(mockedList.get(999));\n  * \n- * //Stubbed invocations <b>are verified implicitly</b>. The execution flow of your own code does it completely <b>for free</b>. \n- * //Although it is possible to verify a stubbed invocation, in majority of cases <b>it's not necessary</b>:\n+ * //Stubbed invocations &lt;b&gt;are verified implicitly&lt;/b&gt;. The execution flow of your own code does it completely &lt;b&gt;for free&lt;/b&gt;. \n+ * //Although it is possible to verify a stubbed invocation, in majority of cases &lt;b&gt;it's not necessary&lt;/b&gt;:\n  * verify(mockedList).get(0);\n  * </pre>\n  * \n  * <ul>\n- * <li>\n- * By default, for all methods that return value, mock returns null,\n- * an empty collection or appropriate primitive/primitive wrapper value \n- * (e.g: 0, false, ... for int/Integer, boolean/Boolean, ...).\n- * </li>\n- * <li>\n- * Stubbing can be overridden: for example common stubbing can go to fixture setup\n- * but test methods can override it.\n- * </li>\n- * <li>\n- * Once stubbed, mocked method will always return stubbed value regardless of how many times it is called.\n- * </li>\n- * <li>\n- * Last stubbing is more important - when you stubbed the same method with the same arguments many times.\n- * </li>\n- * <li>\n- * Although it is possible to verify a stubbed invocation, in majority of cases <b>it's not necessary</b>.\n- * Stubbed invocations <b>are verified implicitly</b>. The execution flow of your own code does it completely <b>for free</b>.\n- * </li> \n+ * <li> By default, for all methods that return value, mock returns null, an\n+ * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n+ * false, ... for int/Integer, boolean/Boolean, ...). </li>\n+ * <li> Stubbing can be overridden: for example common stubbing can go to\n+ * fixture setup but test methods can override it. </li>\n+ * <li> Once stubbed, mocked method will always return stubbed value regardless\n+ * of how many times it is called. </li>\n+ * <li> Last stubbing is more important - when you stubbed the same method with\n+ * the same arguments many times. </li>\n+ * <li> Although it is possible to verify a stubbed invocation, in majority of\n+ * cases <b>it's not necessary</b>. Stubbed invocations <b>are verified\n+ * implicitly</b>. The execution flow of your own code does it completely\n+ * <b>for free</b>. </li>\n  * </ul>\n  * \n  * <h3>3. Argument matchers</h3>\n  * \n  * <pre>\n- *  //stubbing using built-in anyInt() argument matcher\n- *  stub(mockedList.get(anyInt())).toReturn(\"element\");\n- *  \n- *  //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n- *  stub(mockedList.contains(argThat(isValid()))).toReturn(\"element\");\n- *  \n- *  //following prints \"element\"\n- *  System.out.println(mockedList.get(999));\n- *  \n- *  //<b>you can also verify using argument matcher</b>\n- *  verify(mockedList).get(anyInt());\n- * </pre>\n- * \n- * <p>\n- * Argument matchers allow flexible verification or stubbing. \n- * See the <b>whole library of</b> {@link Matchers} including examples of <b>custom argument matchers / hamcrest matchers</b>. \n+ * //stubbing using built-in anyInt() argument matcher\n+ * stub(mockedList.get(anyInt())).toReturn(\"element\");\n+ * \n+ * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n+ * stub(mockedList.contains(argThat(isValid()))).toReturn(\"element\");\n+ * \n+ * //following prints \"element\"\n+ * System.out.println(mockedList.get(999));\n+ * \n+ * //&lt;b&gt;you can also verify using argument matcher&lt;/b&gt;\n+ * verify(mockedList).get(anyInt());\n+ * </pre>\n+ * \n+ * <p>\n+ * Argument matchers allow flexible verification or stubbing. See the <b>whole\n+ * library of</b> {@link Matchers} including examples of <b>custom argument\n+ * matchers / hamcrest matchers</b>.\n  * <p>\n  * <b>Warning:</b>\n  * <p>\n- * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n+ * If you are using argument matchers, <b>all arguments</b> have to be provided\n+ * by matchers.\n  * <p>\n  * E.g: (example shows verification but the same applies to stubbing):\n- * <pre>\n- *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n+ * \n+ * <pre>\n+ *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;eq(\"third argument\")&lt;/b&gt;);\n  *   //above is correct - eq() is also an argument matcher\n  *   \n- *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n+ *   verify(mock).someMethod(anyInt(), anyString(), &lt;b&gt;\"third argument\"&lt;/b&gt;);\n  *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n  * </pre>\n  * \n  * <h3>4. Verifying exact number of invocations / at least once / never</h3>\n- *\n- *<pre>\n- *  //using mock \n- *  mockedList.add(\"once\");\n- *  \n- *  mockedList.add(\"twice\");\n- *  mockedList.add(\"twice\");\n- *  \n- *  mockedList.add(\"three times\");\n- *  mockedList.add(\"three times\");\n- *  mockedList.add(\"three times\");\n- *  \n- *  //following two verifications work exactly the same - times(1) is used by default\n- *  verify(mockedList).add(\"once\");\n- *  verify(mockedList, times(1)).add(\"once\");\n- *  \n- *  //exact number of invocations verification\n- *  verify(mockedList, times(2)).add(\"twice\");\n- *  verify(mockedList, times(3)).add(\"three times\");\n- *  \n- *  //verification using never(). never() is an alias to times(0)\n- *  verify(mockedList, never()).add(\"never happened\");\n- *  \n- *  //verification using atLeastOnce()\n- *  verify(mockedList, atLeastOnce()).add(\"three times\");\n- *  \n- * </pre>\n- * \n- * <p>\n- * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be omitted.\n+ * \n+ * <pre>\n+ * //using mock \n+ * mockedList.add(\"once\");\n+ * \n+ * mockedList.add(\"twice\");\n+ * mockedList.add(\"twice\");\n+ * \n+ * mockedList.add(\"three times\");\n+ * mockedList.add(\"three times\");\n+ * mockedList.add(\"three times\");\n+ * \n+ * //following two verifications work exactly the same - times(1) is used by default\n+ * verify(mockedList).add(\"once\");\n+ * verify(mockedList, times(1)).add(\"once\");\n+ * \n+ * //exact number of invocations verification\n+ * verify(mockedList, times(2)).add(\"twice\");\n+ * verify(mockedList, times(3)).add(\"three times\");\n+ * \n+ * //verification using never(). never() is an alias to times(0)\n+ * verify(mockedList, never()).add(\"never happened\");\n+ * \n+ * //verification using atLeastOnce()\n+ * verify(mockedList, atLeastOnce()).add(\"three times\");\n+ * \n+ * </pre>\n+ * \n+ * <p>\n+ * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n+ * omitted.\n  * \n  * <h3>5. Stubbing void methods with exceptions</h3>\n  * \n  * <pre>\n- *   stubVoid(mockedList).toThrow(new RuntimeException()).on().clear();\n- *   \n- *   //following throws exception\n- *   mockedList.clear();\n- * </pre>\n- *\n+ * stubVoid(mockedList).toThrow(new RuntimeException()).on().clear();\n+ * \n+ * //following throws exception\n+ * mockedList.clear();\n+ * </pre>\n+ * \n  * <h3>6. Verification in order</h3>\n  * \n  * <pre>\n- *   List firstMock = mock(List.class);\n- *   List secondMock = mock(List.class);\n- *   \n- *   //using mocks\n- *   firstMock.add(\"was called first\");\n- *   secondMock.add(\"was called second\");\n- *   \n- *   //create inOrder object passing any mocks that need to be verified in order\n- *   InOrder inOrder = inOrder(firstMock, secondMock);\n- *   \n- *   //following will make sure that firstMock was called before secondMock\n- *   inOrder.verify(firstMock).add(\"was called first\");\n- *   inOrder.verify(secondMock).add(\"was called second\");\n- * </pre>\n- * \n- * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n- * but only those that you are interested in testing in order. \n- * <p>\n- * Also, you can create InOrder object passing only mocks that relevant for in-order verification.  \n- *\n+ * List firstMock = mock(List.class);\n+ * List secondMock = mock(List.class);\n+ * \n+ * //using mocks\n+ * firstMock.add(\"was called first\");\n+ * secondMock.add(\"was called second\");\n+ * \n+ * //create inOrder object passing any mocks that need to be verified in order\n+ * InOrder inOrder = inOrder(firstMock, secondMock);\n+ * \n+ * //following will make sure that firstMock was called before secondMock\n+ * inOrder.verify(firstMock).add(\"was called first\");\n+ * inOrder.verify(secondMock).add(\"was called second\");\n+ * </pre>\n+ * \n+ * Verification in order is flexible - <b>you don't have to verify all\n+ * interactions</b> one-by-one but only those that you are interested in\n+ * testing in order.\n+ * <p>\n+ * Also, you can create InOrder object passing only mocks that relevant for\n+ * in-order verification.\n+ * \n  * <h3>7. Making sure interaction(s) never happened on mock</h3>\n  * \n  * <pre>\n- *   //using mocks - only mockOne is interacted\n- *   mockOne.add(\"one\");\n- *   \n- *   //ordinary verification\n- *   verify(mockOne).add(\"one\");\n- *   \n- *   //verify that method was never called on a mock\n- *   verify(mockOne, never()).add(\"two\"); \n- *   \n- *   //verify that other mocks were not interacted\n- *   verifyZeroInteractions(mockTwo, mockThree);\n- *   \n- *   //following works exactly the same as above\n- *   verifyNoMoreInteractions(mockTwo, mockThree);\n- * </pre>\n- *\n+ * //using mocks - only mockOne is interacted\n+ * mockOne.add(\"one\");\n+ * \n+ * //ordinary verification\n+ * verify(mockOne).add(\"one\");\n+ * \n+ * //verify that method was never called on a mock\n+ * verify(mockOne, never()).add(\"two\");\n+ * \n+ * //verify that other mocks were not interacted\n+ * verifyZeroInteractions(mockTwo, mockThree);\n+ * \n+ * //following works exactly the same as above\n+ * verifyNoMoreInteractions(mockTwo, mockThree);\n+ * </pre>\n+ * \n  * See more {@link Mockito#verifyNoMoreInteractions}\n  * \n  * <p>\n- * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but \n- * the first one is more explicit and can read better.\n- *\n+ * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions()\n+ * but the first one is more explicit and can read better.\n+ * \n  * <h3>8. Finding redundant invocations</h3>\n  * \n  * <pre>\n- *   //using mocks\n- *   mockedList.add(\"one\");\n- *   mockedList.add(\"two\");\n- *   \n- *   verify(mockedList).add(\"one\");\n- *   \n- *   //following verification will fail \n- *   verifyNoMoreInteractions(mockedList);\n- * </pre>\n- * \n- * Remember that usually it's not necessary to call verifyNoMoreInteractions() all the time.\n- * See also {@link Mockito#never()} - it is more explicit and communicates an intent well. \n+ * //using mocks\n+ * mockedList.add(\"one\");\n+ * mockedList.add(\"two\");\n+ * \n+ * verify(mockedList).add(\"one\");\n+ * \n+ * //following verification will fail \n+ * verifyNoMoreInteractions(mockedList);\n+ * </pre>\n+ * \n+ * Remember that usually it's not necessary to call verifyNoMoreInteractions()\n+ * all the time. See also {@link Mockito#never()} - it is more explicit and\n+ * communicates an intent well.\n  * <p>\n  * \n  * <h3>9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n  * \n  * <ul>\n- * <li>Minimizes repetitive mock creation code.</li> \n+ * <li>Minimizes repetitive mock creation code.</li>\n  * <li>Makes the test class more readable.</li>\n- * <li>Makes the verification error easier to read because <b>field name</b> is used to identify the mock.</li>\n+ * <li>Makes the verification error easier to read because <b>field name</b>\n+ * is used to identify the mock.</li>\n  * </ul>\n  * \n  * <pre>\n  *       private ArticleManager manager;\n  * </pre>\n  * \n- * <b>Important!</b> This needs to be somewhere in the base class or a test runner:\n- *   \n- * <pre>\n- *   MockitoAnnotations.initMocks(testClass);\n- * </pre>\n- * \n- * Examples how to write a junit test runner are in Mockito test code (mockito/test/org/mockitousage/examples/junitrunner package);\n+ * <b>Important!</b> This needs to be somewhere in the base class or a test\n+ * runner:\n+ * \n+ * <pre>\n+ * MockitoAnnotations.initMocks(testClass);\n+ * </pre>\n+ * \n+ * Examples how to write a junit test runner are in Mockito test code\n+ * (mockito/test/org/mockitousage/examples/junitrunner package);\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n  * \n  * <h3> 10. (**New**) Stubbing consecutive calls (iterator-style stubbing)</h3>\n  * \n- * Sometimes we need to stub with different return value/exception for the same method call. \n- * Typical use case could be mocking iterators. Initially this feature was not included in original version of Mockito to promote simple mocking.\n- * Instead of iterators we strongly recommend using Iterable or simply collections. Those offer natural ways of stubbing (e.g. using real collections).\n- * In rare scenarios stubbing consecutive calls could useful, though:\n- * <p>\n- * <pre>\n- *   stub(mock.someMethod(\"some arg\"))\n- *    .toThrow(new RuntimeException())\n- *    .toReturn(\"foo\");\n- *    \n- *   //First call: throws runtime exception:\n- *   mock.someMethod(\"some arg\");\n- *   \n- *   //Second call: prints \"foo\"\n- *   System.out.println(mock.someMethod(\"some arg\"));\n- *   \n- *   //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n- *   System.out.println(mock.someMethod(\"some arg\"));\n+ * Sometimes we need to stub with different return value/exception for the same\n+ * method call. Typical use case could be mocking iterators. Initially this\n+ * feature was not included in original version of Mockito to promote simple\n+ * mocking. Instead of iterators we strongly recommend using Iterable or simply\n+ * collections. Those offer natural ways of stubbing (e.g. using real\n+ * collections). In rare scenarios stubbing consecutive calls could useful,\n+ * though:\n+ * <p>\n+ * \n+ * <pre>\n+ * stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException()).toReturn(\"foo\");\n+ * \n+ * //First call: throws runtime exception:\n+ * mock.someMethod(\"some arg\");\n+ * \n+ * //Second call: prints \"foo\"\n+ * System.out.println(mock.someMethod(\"some arg\"));\n+ * \n+ * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n+ * System.out.println(mock.someMethod(\"some arg\"));\n  * </pre>\n  * \n  * <h3> 11. (**New**) Stubbing with callbacks</h3>\n  * \n- * Yet another controversial feature which was not included in Mockito originally. \n- * We strongly recommend using simple stubbing (toReturn() or toThrow() only).\n- * Those two should be <b>just enough</b> to test/test-drive any decent (clean & simple) code. \n+ * Yet another controversial feature which was not included in Mockito\n+ * originally. We strongly recommend using simple stubbing (toReturn() or\n+ * toThrow() only). Those two should be <b>just enough</b> to test/test-drive\n+ * any decent (clean & simple) code.\n  * \n  * Allows stubbing with generic {@link Answer} interface\n  * \n  * <p>\n- * <pre>\n- *   stub(mock.someMethod(anyString()))\n- *     .toAnswer(new Answer() {\n- *       Object answer(InvocationOnMock invocation) {\n+ * \n+ * <pre>\n+ * stub(mock.someMethod(anyString())).toAnswer(new Answer() {\n+ *     Object answer(InvocationOnMock invocation) {\n  *         Object[] args = invocation.getArguments();\n  *         Object mock = invocation.getMock();\n  *         return \"called with arguments: \" + args;\n- *       }\n- *     });\n- *    \n- *   //Following prints \"called with arguments: foo\"\n- *   System.out.println(mock.someMethod(\"foo\"));\n+ *     }\n+ * });\n+ * \n+ * //Following prints \"called with arguments: foo\"\n+ * System.out.println(mock.someMethod(\"foo\"));\n+ * </pre>\n+ * \n+ * <h3> 13. (**New**) Spying on real objects</h3>\n+ * \n+ * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n+ * \n+ * <pre>\n+ *   List list = new LinkedList();\n+ *   List spy = Mockito.spy(list);\n+ * \n+ *   //optionally, you can stub out some methods:\n+ *   stub(spy.size()).toReturn(100);\n+ * \n+ *   //using the spy calls <b>real</b> methods\n+ *   spy.add(\"one\");\n+ *   spy.add(\"two\");\n+ * \n+ *   //prints \"one\" - the first element of a list\n+ *   System.out.println(spy.get(0));\n+ * \n+ *   //size() method was stubbed - 100 is printed\n+ *   System.out.println(spy.size());\n+ * \n+ *   //optionally, you can verify\n+ *   verify(spy).add(\"one\");\n+ *   verify(spy).add(\"two\");\n+ * </pre>\n+ * \n+ * <h3>IMPORTANT</h3>\n+ * \n+ * Sometimes it's impossible to use {@link Mockito#stub(Object)} for stubbing spies. Example:\n+ * \n+ * <pre>\n+ *   List list = new LinkedList();\n+ *   List spy = Mockito.spy(list);\n+ *   \n+ *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException because the list is yet empty\n+ *   stub(spy.get(0)).toReturn(\"foo\");\n+ *   \n+ *   //You have to use doReturn() for stubbing\n+ *   doReturn(\"foo\").when(spy).get(0);\n  * </pre>\n  */\n+@SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n     private Mockito() {}\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return MockUtil.createMock(classToMock, null, MOCKING_PROGRESS);\n+        return mock(classToMock, null);\n     }\n     \n-    static <T> T mock(Class<T> classToMock, String name) {\n-        return MockUtil.createMock(classToMock, name, MOCKING_PROGRESS);\n+    /**\n+     * Creates mock with a name. Naming mocks can be helpful for debugging. \n+     * Remember that naming mocks is not a solution for complex test/code which uses too many mocks. \n+     * <p>\n+     * If you use &#064;Mock annotation then you've got naming mocks for free. &#064;Mock uses field name as mock name.\n+     * <p>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param classToMock class or interface to mock\n+     * @return mock object\n+     */\n+    public static <T> T mock(Class<T> classToMock, String name) {\n+        return MockUtil.createMock(classToMock, name, MOCKING_PROGRESS, null);\n+    }\n+\n+    /**\n+     * Creates a spy of the real object. Example:\n+     * \n+     * <pre>\n+     *   List list = new LinkedList();\n+     *   List spy = Mockito.spy(list);\n+     * \n+     *   //optionally, you can stub out some methods:\n+     *   stub(spy.size()).toReturn(100);\n+     * \n+     *   //using the spy calls <b>real</b> methods\n+     *   spy.add(\"one\");\n+     *   spy.add(\"two\");\n+     * \n+     *   //prints \"one\" - the first element of a list\n+     *   System.out.println(spy.get(0));\n+     * \n+     *   //size() method was stubbed - 100 is printed\n+     *   System.out.println(spy.size());\n+     * \n+     *   //optionally, you can verify\n+     *   verify(spy).add(\"one\");\n+     *   verify(spy).add(\"two\");\n+     * </pre>\n+     * \n+     * <h3>IMPORTANT</h3>\n+     * \n+     * Sometimes it's impossible to use {@link Mockito#stub(Object)} for stubbing spies. Example:\n+     * \n+     * <pre>\n+     *   List list = new LinkedList();\n+     *   List spy = Mockito.spy(list);\n+     *   \n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException because the list is yet empty\n+     *   stub(spy.get(0)).toReturn(\"foo\");\n+     *   \n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </pre>\n+     * \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param <T>\n+     * @param object\n+     *            to spy on\n+     * @return a spy of the real object\n+     */\n+    public static <T> T spy(T object) {\n+        return MockUtil.createMock((Class<T>) object.getClass(), null, MOCKING_PROGRESS, object);\n     }\n \n     /**\n      *   stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n      *   \n      *   //setting exception to be thrown:\n-     *   stub(mock.someMethod(&quot;some arg&quot;)).toThrow(new RuntimeException());\n+     *   stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n      *   \n      *   //you can stub with different behavior for consecutive calls.\n      *   //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.   \n      *            method call\n      * @return OngoingStubbing object to set stubbed value/exception\n      */\n+    //TODO change the javadoc to what was said on the mailing list\n     @SuppressWarnings(\"unchecked\")\n     public static <T> OngoingStubbing<T> stub(T methodCall) {\n         MOCKING_PROGRESS.stubbingStarted();\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import net.sf.cglib.proxy.MethodProxy;\n \n import org.mockito.internal.configuration.Configuration;\n-import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.creation.MockAwareInterceptor;\n import org.mockito.internal.invocation.AllInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.stubbing.Returns;\n import org.mockito.internal.stubbing.Stubber;\n-import org.mockito.internal.stubbing.Returns;\n+import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n-import org.mockito.internal.stubbing.ThrowsException;\n+import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n     private final MockingProgress mockingProgress;\n     private final String mockName;\n \n-    private T mock;\n+    private T instance;\n \n     public MockHandler(String mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n         this.mockName = mockName;\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n-        stubber = new Stubber(mockingProgress);\n+        this.stubber = new Stubber(mockingProgress);\n \n         verifyingRecorder = createRecorder();\n     }\n-\n+    \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         if (stubber.hasAnswerForVoidMethod()) {\n+            //stubbing voids\n             Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n             stubber.addVoidMethodForStubbing(invocationMatcher);\n             return null;\n         }\n-\n+        \n         VerificationModeImpl verificationMode = mockingProgress.pullVerificationMode();\n         mockingProgress.validateState();\n \n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n \n         if (verificationMode != null) {\n+            //verifying\n             verifyingRecorder.verify(invocationMatcher, verificationMode);\n-            return Configuration.instance().getReturnValues().valueFor(invocationMatcher.getInvocation());\n+            return null;\n         }\n \n         stubber.setInvocationForPotentialStubbing(invocationMatcher);\n \n         mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n \n-        return stubber.resultFor(invocationMatcher.getInvocation());\n+        if (stubber.hasResultFor(invocation)) {\n+            return stubber.getResultFor(invocation);\n+        } else if (MockUtil.isMock(instance)) {\n+            return Configuration.instance().getReturnValues().valueFor(invocation);\n+        } else {\n+            return methodProxy.invoke(instance, args);\n+        }\n     }\n \n     public void verifyNoMoreInteractions() {\n         return new VoidMethodStubbableImpl();\n     }\n \n-    public void setMock(T mock) {\n-        this.mock = mock;\n+    public void setInstance(T instance) {\n+        this.instance = instance;\n     }\n \n     public List<Invocation> getRegisteredInvocations() {\n     }\n \n     public String getMockName() {\n-        if (mockName != null) {\n-            return mockName;\n-        } else {\n-            return toInstanceName(ClassNameFinder.classNameForMock(mock));\n-        }\n-    }\n-\n-    //lower case first letter\n-    private String toInstanceName(String className) {\n-        return className.substring(0, 1).toLowerCase() + className.substring(1);\n+        return mockName;\n     }\n \n     private VerifyingRecorder createRecorder() {\n         }\n \n         public T on() {\n-            return mock;\n+            return instance;\n         }\n     }\n \n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n             return hashCodeForMock(proxy);\n         }\n         \n-        return delegate.intercept(proxy, method, args, null);\n+        return delegate.intercept(proxy, method, args, methodProxy);\n     }\n \n     private int hashCodeForMock(Object mock) {\n         return delegate;\n     }\n \n-    public void setMock(Object mock) {\n-        delegate.setMock(mock);\n+    public void setInstance(Object instance) {\n+        delegate.setInstance(instance);\n     }\n }\n--- a/src/org/mockito/internal/creation/MockAwareInterceptor.java\n+++ b/src/org/mockito/internal/creation/MockAwareInterceptor.java\n import net.sf.cglib.proxy.MethodProxy;\n \n public interface MockAwareInterceptor<T> extends MethodInterceptor {\n-  \n+\n     Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable;\n     \n-    void setMock(T mock);\n-    \n-}\n+    void setInstance(T mock);\n+}\n--- a/src/org/mockito/internal/creation/MockFactory.java\n+++ b/src/org/mockito/internal/creation/MockFactory.java\n public class MockFactory<T> {\n \n     @SuppressWarnings(\"unchecked\")\n-    public T createMock(Class<T> toMock, final MethodInterceptorFilter filter) {\n+    public T createMock(Class<T> toMock, final MethodInterceptorFilter filter, Object optionalInstance) {\n         validateClass(toMock);\n         Enhancer enhancer = createEnhancer(toMock);\n         enhancer.setCallbackType(filter.getClass());\n \n         Factory mock = createMock(mockClass);\n \n-        filter.setMock(mock);\n+        filter.setInstance(optionalInstance != null ? optionalInstance : mock);\n         return (T) mock;\n     }\n \n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n         } else {\n             stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n         }\n-    }    \n+    } \n+    \n+    public boolean hasResultFor(Invocation invocation) {\n+        return findMatch(invocation) != null;\n+    }\n+    \n+    public Object getResultFor(Invocation invocation) throws Throwable {\n+        return findMatch(invocation).answer(invocation);\n+    }\n \n-    public Object resultFor(Invocation invocation) throws Throwable {\n+    private StubbedInvocationMatcher findMatch(Invocation invocation) {\n         for (StubbedInvocationMatcher s : stubbed) {\n             if (s.matches(invocation)) {\n-                return s.answer(invocation);\n+                return s;\n             }\n         }\n-        return Configuration.instance().getReturnValues().valueFor(invocation);\n+        \n+        return null;\n     }\n \n     public void addAnswerForVoidMethod(Answer answer) {\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n \n public class MockUtil {\n     \n-    public static <T> T createMock(Class<T> classToMock, String mockName, MockingProgress progress) {\n+    //TODO reorder args\n+    public static <T> T createMock(Class<T> classToMock, String mockName, MockingProgress progress, T optionalInstance) {\n+        if (mockName == null) {\n+            mockName = toInstanceName(classToMock);\n+        }\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n         MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder());\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n-        return proxyFactory.createMock(classToMock, filter);\n+        return proxyFactory.createMock(classToMock, filter, optionalInstance);\n+    }\n+\n+    private static String toInstanceName(Class<?> clazz) {\n+        String className = clazz.getSimpleName();\n+        //lower case first letter\n+        return className.substring(0, 1).toLowerCase() + className.substring(1);\n     }\n     \n     public static <T> MockHandler<T> getMockHandler(T mock) {\n--- a/test/org/mockito/internal/creation/MockFactoryTest.java\n+++ b/test/org/mockito/internal/creation/MockFactoryTest.java\n     @Test\n     public void shouldCreateMockFromInterface() throws Exception {\n         MockFactory<SomeInterface> factory = new MockFactory<SomeInterface>();\n-        SomeInterface proxy = factory.createMock(SomeInterface.class, new MockAwareStub());\n+        SomeInterface proxy = factory.createMock(SomeInterface.class, new MockAwareStub(), null);\n         \n         Class superClass = proxy.getClass().getSuperclass();\n         assertEquals(Object.class, superClass);\n     @Test\n     public void shouldCreateMockFromClass() throws Exception {\n         MockFactory<ClassWithoutConstructor> factory = new MockFactory<ClassWithoutConstructor>();\n-        ClassWithoutConstructor proxy = factory.createMock(ClassWithoutConstructor.class, new MockAwareStub());\n+        ClassWithoutConstructor proxy = factory.createMock(ClassWithoutConstructor.class, new MockAwareStub(), null);\n         \n         Class superClass = proxy.getClass().getSuperclass();\n         assertEquals(ClassWithoutConstructor.class, superClass);\n         } catch (Exception e) {}\n         \n         MockFactory<ClassWithDodgyConstructor> factory = new MockFactory<ClassWithDodgyConstructor>();\n-        ClassWithDodgyConstructor mock = factory.createMock(ClassWithDodgyConstructor.class, new MockAwareStub());\n+        ClassWithDodgyConstructor mock = factory.createMock(ClassWithDodgyConstructor.class, new MockAwareStub(), null);\n         assertNotNull(mock);\n     }\n     \n     @Test \n     public void shouldMocksHaveDifferentInterceptors() throws Exception {\n         MockFactory<SomeClass> factory = new MockFactory<SomeClass>();\n-        SomeClass mockOne = factory.createMock(SomeClass.class, new MockAwareStub());\n-        SomeClass mockTwo = factory.createMock(SomeClass.class, new MockAwareStub());\n+        SomeClass mockOne = factory.createMock(SomeClass.class, new MockAwareStub(), null);\n+        SomeClass mockTwo = factory.createMock(SomeClass.class, new MockAwareStub(), null);\n         \n         Factory cglibFactoryOne = (Factory) mockOne;\n         Factory cglibFactoryTwo = (Factory) mockTwo;\n             super(Object.class, null);\n         }\n \n-        public void setMock(Object mock) {}\n+        public void setInstance(Object mock) {}\n     }\n }\n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n         stubber.addAnswer(new ThrowsException(new MyException()));\n         \n-        assertEquals(\"simpleMethod\", stubber.resultFor(simpleMethod));\n+        assertEquals(\"simpleMethod\", stubber.getResultFor(simpleMethod));\n         \n         try {\n-            stubber.resultFor(differentMethod);\n+            stubber.getResultFor(differentMethod);\n             fail();\n         } catch (MyException e) {}\n-    }\n-    \n-    @Test\n-    public void shouldGetEmptyResultIfMethodsDontMatch() throws Throwable {\n-        stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n-        stubber.addAnswer(new Returns(\"simpleMethod\"));\n-        \n-        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n-        \n-        assertEquals(null, stubber.resultFor(differentMethod));\n     }\n     \n     @Test\n         stubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));\n         \n         try {\n-            stubber.resultFor(simpleMethod);\n+            stubber.getResultFor(simpleMethod);\n             fail();\n         } catch (MyException e) {}\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/MockingRealObjectsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockingRealObjectsTest extends TestBase {\n+\n+    List list = new LinkedList();\n+    List spy = Mockito.spy(list);\n+    \n+    @Test\n+    public void shouldVerify() {\n+        spy.add(\"one\");\n+        spy.add(\"two\");\n+        \n+        assertEquals(\"one\", spy.get(0));\n+        assertEquals(\"two\", spy.get(1));\n+        \n+        verify(spy).add(\"one\");\n+        verify(spy).add(\"two\");\n+    }\n+    \n+    @Test\n+    public void shouldStub() {\n+        spy.add(\"one\");\n+        stub(spy.get(0))\n+            .toReturn(\"1\")\n+            .toReturn(\"1 again\");\n+               \n+        assertEquals(\"1\", spy.get(0));\n+        assertEquals(\"1 again\", spy.get(0));\n+        assertEquals(\"one\", spy.iterator().next());\n+        \n+        assertEquals(1, spy.size());\n+    }\n+    \n+    @Ignore(\"needs fixing - the real clear() method is called :)\")\n+    @Test\n+    public void shouldStubVoid() {\n+        spy.add(\"one\");\n+        stubVoid(spy)\n+            .toReturn()\n+            .toThrow(new RuntimeException())\n+            .on().clear();\n+\n+        spy.add(\"one\");\n+        spy.clear();\n+        try {\n+            spy.clear();\n+            fail();\n+        } catch (RuntimeException e) {}\n+            \n+        assertEquals(1, spy.size());\n+    }\n+    \n+    @Test\n+    public void shouldToString() {\n+        spy.add(\"foo\");\n+        assertEquals(\"[foo]\" , spy.toString());\n+    }\n+}", "timestamp": 1216153767, "metainfo": ""}