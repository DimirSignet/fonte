{"sha": "e350de0d835c4b6d680d6600246a71fa418c26a7", "log": "added some yet unfinished bridge method tests  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40102", "commit": "\n--- /dev/null\n+++ b/test/org/mockito/usage/binding/BridgeMethodPuzzleTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.usage.binding;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.hasBridgeMethod;\n+\n+import org.junit.Test;\n+\n+\n+/**\n+ * Bridge method is generated by compiler when erasure in parent class is\n+ * different. When is different then it means that in runtime we will have\n+ * overloading rather than overridding Therefore the compiler generates bridge\n+ * method in Subclass so that erasures are the same, signatures of methods match\n+ * and overridding is ON.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class BridgeMethodPuzzleTest {\n+\n+    class Super<T> {\n+        public String say(T t) {\n+            return \"Super says: \" + t;\n+        }\n+    }\n+     \n+    class Sub extends Super<String> {\n+        @Override\n+        public String say(String t)  {\n+            return \"Sub says: \" + t;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldHaveBridgeMethod() throws Exception {\n+        Super s = new Sub();\n+        \n+        assertEquals(\"Sub says: Hello\", s.say(\"Hello\"));\n+        \n+        assertThat(Sub.class, hasBridgeMethod(\"say\"));\n+        assertThat(s, hasBridgeMethod(\"say\"));\n+    }\n+    \n+    @Test\n+    public void shouldVerifyCorrectlyWhenBridgeMethodCalled() throws Exception {\n+        //Super has following erasure: say(Object) which differs from Sub.say(String)\n+        //mock has to detect it and do the polymorphic call: Sub.say(Object) \n+        Super s = mock(Sub.class);\n+        \n+        s.say(\"Hello\");\n+        \n+        verify(s).say(\"Hello\");\n+    }\n+    \n+    @Test\n+    public void shouldVerifyCorrectlyWhenBridgeMethodIsNotCalled() throws Exception {\n+        //no problem here, no polymorphic call\n+        Sub s = mock(Sub.class);\n+        \n+        s.say(\"Hello\");\n+        \n+        verify(s).say(\"Hello\");\n+    }\n+}", "timestamp": 1196431439, "metainfo": ""}