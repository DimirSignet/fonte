{"sha": "f24ddf805cd158dc2fe838ff2db6314ea6f942c4", "log": "removed some unnecessary analyzer code  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40236", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n         return null;\n     }\n     \n-    // 1 222  33\n-    // v vvvv\n-    //     ^ - last matching\n-    public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n-        Invocation lastMatching = null;\n-        for (Invocation invocation : invocations) {\n-            if (wanted.matches(invocation)) {\n-                lastMatching = invocation;\n-            }\n-        }\n-        return lastMatching != null ? lastMatching.getStackTrace() : null;\n-    }\n-\n-    // 1 222  33\n-    // v vv\n-    //     ^ - first undesired\n-    public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        int counter = 0;\n-        for (Invocation invocation : invocations) {\n-            if (wanted.matches(invocation)) {\n-                counter++;\n-                if (counter > mode.wantedCount()) {\n-                    return invocation.getStackTrace();\n-                }\n-            }\n-        }\n-        throw new IllegalArgumentException(\"There are no undesired invocations!\");\n-    }\n-    \n     public List<Invocation> removeUntilLastStrictlyVerified(List<Invocation> invocations) {\n         List<Invocation> unverified = new LinkedList<Invocation>();\n         for (Invocation i : invocations) {\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n         return mocksToBeVerifiedStrictly;\n     }\n \n-    public boolean atLeastOnceMode() {\n+    boolean atLeastOnceMode() {\n         return wantedInvocationCount == null && verification == Verification.EXPLICIT;\n-    }\n-\n-    public boolean strictMode() {\n-        return !mocksToBeVerifiedStrictly.isEmpty();\n     }\n \n     public boolean explicitMode() {\n         return verification == Verification.EXPLICIT;\n     }\n     \n+    public boolean strictMode() {\n+        return !mocksToBeVerifiedStrictly.isEmpty();\n+    }\n+    \n     public boolean missingMethodMode() {\n         return explicitMode() && (atLeastOnceMode() || wantedInvocationCount > 0);\n+    }\n+    \n+    public boolean exactNumberOfInvocationsMode() {\n+        return !strictMode() && explicitMode();\n     }\n \n     public boolean matchesActualCount(int actualCount) {\n     public String toString() {\n         return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedStrictly;\n     }\n-\n }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n     \n     private final Reporter reporter;\n-    private final InvocationsAnalyzer analyzer;\n     private final ActualInvocationsFinder finder;\n \n     public NumberOfInvocationsVerifier() {\n-        this(new Reporter(), new InvocationsAnalyzer(), new ActualInvocationsFinder());\n+        this(new Reporter(), new ActualInvocationsFinder());\n     }\n     \n-    NumberOfInvocationsVerifier(Reporter reporter, InvocationsAnalyzer analyzer, ActualInvocationsFinder finder) {\n+    NumberOfInvocationsVerifier(Reporter reporter, ActualInvocationsFinder finder) {\n         this.reporter = reporter;\n-        this.analyzer = analyzer;\n         this.finder = finder;\n     }\n     \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        //TODO push to mode\n-        if (mode.strictMode() || !mode.explicitMode()) {\n+        if (!mode.exactNumberOfInvocationsMode()) {\n             return;\n         }\n         \n         \n         int actualCount = actualInvocations.size();\n         if (mode.tooLittleActualInvocations(actualCount)) {\n-            HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(actualInvocations, wanted);\n+            HasStackTrace lastInvocation = getLastSafely(actualInvocations);\n             reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n         } else if (mode.tooManyActualInvocations(actualCount)) {\n-            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(actualInvocations, wanted, mode);\n+            HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n             reporter.tooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n         }\n         \n             i.markVerified();\n         }\n     }\n+\n+    private HasStackTrace getLastSafely(List<Invocation> actualInvocations) {\n+        if (actualInvocations.isEmpty()) {\n+            return null;\n+        } else {\n+            return actualInvocations.get(actualInvocations.size() - 1).getStackTrace();\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/verification/StrictVerifier.java\n+++ b/src/org/mockito/internal/verification/StrictVerifier.java\n         int actualCount = chunk.size();\n         \n         if (mode.tooLittleActualInvocations(actualCount)) {\n-            HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(chunk, wanted);\n+            HasStackTrace lastInvocation = getLastSafely(chunk);\n             reporter.strictlyTooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n         } else if (mode.tooManyActualInvocations(actualCount)) {\n-            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(chunk, wanted, mode);\n+            HasStackTrace firstUndesired = chunk.get(mode.wantedCount()).getStackTrace();\n             reporter.strictlyTooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n         }\n         \n-        //TODO not tested\n         for (Invocation i : chunk) {\n             i.markVerifiedStrictly();\n         }\n     }\n+    \n+    private HasStackTrace getLastSafely(List<Invocation> actualInvocations) {\n+        if (actualInvocations.isEmpty()) {\n+            return null;\n+        } else {\n+            return actualInvocations.get(actualInvocations.size() - 1).getStackTrace();\n+        }\n+    }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n     }\n     \n     @Test\n-    public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n-        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(0));\n-        HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n-        assertSame(firstUndesired, expected);\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n-        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(1));\n-        HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n-        assertSame(firstUndesired, expected);\n-    }\n-    \n-    @Test(expected=IllegalArgumentException.class)\n-    public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n-        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), times(2));\n-    }\n-    \n-    @Test(expected=IllegalArgumentException.class)\n-    public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n-        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), times(100));\n-    }\n-    \n-    @Test\n     public void shouldFindSimilarInvocationByName() throws Exception {\n         Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertSame(found, simpleMethodInvocation);\n         Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertNotSame(onDifferentMock, found);\n     }  \n-    \n-    @Test\n-    public void shouldFindLastMatchingInvocationTrace() throws Exception {\n-        HasStackTrace found = analyzer.findLastMatchingInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        assertSame(simpleMethodInvocationTwo.getStackTrace(), found);\n-        \n-        found = analyzer.findLastMatchingInvocationTrace(invocations, new InvocationMatcher(differentMethodInvocation));\n-        assertSame(differentMethodInvocation.getStackTrace(), found);\n-    }\n-    \n-    @Test\n-    public void shouldNotFindLastMatchingInvocationTrace() throws Exception {\n-        InvocationMatcher doesntMatch = new InvocationBuilder().otherMethod().toInvocationMatcher();\n-        HasStackTrace found = analyzer.findLastMatchingInvocationTrace(invocations, doesntMatch);\n-        assertNull(found);\n-    }\n }\n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n         assertFalse(noMoreInteractions().missingMethodMode());\n         assertFalse(times(0).missingMethodMode());\n     }\n-    \n-//    @Test\n-//    public void shouldKnowIfIsExactNumberOfInvocationsMode() throws Exception {\n-//        assertTrue(times(0).exactNumberOfInvocationsMode());\n-//        assertTrue(times(1).exactNumberOfInvocationsMode());\n-//        assertTrue(times(2).exactNumberOfInvocationsMode());\n-//        \n-//        assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n-//        assertFalse(atLeastOnce().exactNumberOfInvocationsMode());\n-//    }\n     \n     @Test\n     public void shouldKnowIfIsStrict() throws Exception {\n         assertFalse(times(20).wantedCountIsZero());\n         assertFalse(atLeastOnce().wantedCountIsZero());\n     }\n+    \n+    @Test\n+    public void shouldKnowIfExactNumberOfInvocationsMode() throws Exception {\n+        assertTrue(times(0).exactNumberOfInvocationsMode());\n+        assertTrue(times(1).exactNumberOfInvocationsMode());\n+        assertTrue(atLeastOnce().exactNumberOfInvocationsMode());\n+        \n+        assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n+        assertFalse(strict(1, asList(new Object())).exactNumberOfInvocationsMode());\n+    }\n }\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n import static org.junit.Assert.*;\n import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n-import java.util.List;\n+import java.util.LinkedList;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n \n     private NumberOfInvocationsVerifier verifier;\n-    private InvocationsAnalyzerStub analyzerStub;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n-    private List<Invocation> invocations;\n+    private LinkedList<Invocation> invocations;\n     private ActualInvocationsFinderStub finderStub;\n     \n     @Before\n     public void setup() {\n         reporterStub = new ReporterStub();\n-        analyzerStub = new InvocationsAnalyzerStub();\n         finderStub = new ActualInvocationsFinderStub();\n-        verifier = new NumberOfInvocationsVerifier(reporterStub, analyzerStub, finderStub);\n+        verifier = new NumberOfInvocationsVerifier(reporterStub, finderStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n-        invocations = asList(new InvocationBuilder().toInvocation());\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n     }\n \n     @Test\n     @Test\n     public void shouldReportWithLastInvocationStackTrace() throws Exception {\n         VerificationModeImpl mode = times(100);\n-        MockitoException lastInvocation = new MockitoException(\"\");\n-        analyzerStub.invocationTraceToReturn = lastInvocation;\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        \n+        finderStub.actualToReturn.addAll(asList(first, second));\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(lastInvocation, reporterStub.stackTrace);\n+        assertSame(second.getStackTrace(), reporterStub.stackTrace);\n     }\n     \n     @Test\n-    public void shouldAskAnalyzerWithActualInvocationsWhenTooLittleActual() throws Exception {\n+    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {\n         VerificationModeImpl mode = times(100);\n-        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        assertTrue(finderStub.actualToReturn.isEmpty());\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(finderStub.actualToReturn, analyzerStub.invocations);\n+        assertNull(reporterStub.stackTrace);\n     }\n     \n     @Test\n     public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n-        VerificationModeImpl mode = times(0);\n-        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n-        MockitoException firstUndesiredInvocation = new MockitoException(\"\");\n-        analyzerStub.invocationTraceToReturn = firstUndesiredInvocation;\n+        VerificationModeImpl mode = times(2);\n+\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        Invocation third = new InvocationBuilder().toInvocation();\n+        \n+        finderStub.actualToReturn.addAll(asList(first, second, third));\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(firstUndesiredInvocation, reporterStub.stackTrace);\n-    }\n-    \n-    @Test\n-    public void shouldAskAnalyzerWithActualInvocationsWhenTooManyActual() throws Exception {\n-        VerificationModeImpl mode = times(0);\n-        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n-        \n-        verifier.verify(invocations, wanted, mode);\n-        \n-        assertSame(finderStub.actualToReturn, analyzerStub.invocations);\n+        assertSame(third.getStackTrace(), reporterStub.stackTrace);\n     }\n     \n     @Test\n         assertTrue(invocation.isVerified());\n     }\n     \n-    class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n-        private HasStackTrace invocationTraceToReturn;\n-        private List<Invocation> invocations;\n-        @Override public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-            this.invocations = invocations;\n-            return invocationTraceToReturn;\n-        }\n-        @Override public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n-            this.invocations = invocations;\n-            return invocationTraceToReturn;\n-        }\n-    }\n-    \n     class ReporterStub extends Reporter {\n         private int wantedCount;\n         private int actualCount;", "timestamp": 1198699430, "metainfo": ""}