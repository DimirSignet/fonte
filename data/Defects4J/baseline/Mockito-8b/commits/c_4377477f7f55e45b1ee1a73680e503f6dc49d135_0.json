{"sha": "4377477f7f55e45b1ee1a73680e503f6dc49d135", "log": "Test for issue 277 : Improving code readability a bit", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n package org.mockito.internal.stubbing.defaultanswers;\n \n import java.io.Serializable;\n-import java.util.List;\n \n import org.mockito.Mockito;\n import org.mockito.internal.MockHandlerInterface;\n \n     private Object getMock(InvocationOnMock invocation) throws Throwable {\n     \tMockHandlerInterface<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n-    \tInvocationContainerImpl container = (InvocationContainerImpl)handler.getInvocationContainer();\n-    \tList<StubbedInvocationMatcher> stubbedInvocations = container.getStubbedInvocations();\n-    \tfor (StubbedInvocationMatcher stubbedInvocationMatcher : stubbedInvocations) {\n+    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n+\n+        // matches invocation for verification\n+        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n     \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n     \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n     \t\t}\n \t\t}\n-    \t\n+\n+        // deep stub\n+        return recordDeepStubMock(invocation, container);\n+    }\n+\n+    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n         Class<?> clz = invocation.getMethod().getReturnType();\n         final Object mock = Mockito.mock(clz, this);\n \n--- a/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n import static org.mockito.Matchers.anyInt;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Matchers.eq;\n-import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.*;\n \n import java.io.ByteArrayOutputStream;\n import java.io.OutputStream;\n import java.net.Socket;\n+import java.util.Locale;\n \n import javax.net.SocketFactory;\n \n         Street street;\n \n         public Street getStreet() {\n+            return street;\n+        }\n+\n+        public Street getStreet(Locale locale) {\n             return street;\n         }\n     }\n \tpublic void shouldVerificationWorkWithArgumentMatchersInNestedCalls() throws Exception {\n \t\t//given\n     \tperson.getAddress(\"111 Mock Lane\").getStreet();\n-\t\t\n+    \tperson.getAddress(\"111 Mock Lane\").getStreet(Locale.ITALIAN).getName();\n+\n \t\t//then\n     \tverify(person.getAddress(anyString())).getStreet();\n+    \tverify(person.getAddress(anyString()).getStreet(Locale.CHINESE), never()).getName();\n+    \tverify(person.getAddress(anyString()).getStreet(eq(Locale.ITALIAN))).getName();\n \t}\n     \n     @Test", "timestamp": 1317991481, "metainfo": ""}