{"sha": "8748ed3631d385a746471218b3b8052c88fd057d", "log": "Fixed issue 62. Rare case of not matching anyObject() for varargs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401311", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n \n     private boolean verified;\n     private boolean verifiedInOrder;\n+    private Object[] rawArguments;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n         this.mock = mock;\n         this.method = method;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n+        this.rawArguments = args;\n         this.sequenceNumber = sequenceNumber;\n         this.location = new Location();\n     }\n     public boolean isVarArgs() {\n         return method.isVarArgs();\n     }\n+\n+    public int getArgumentsCount() {\n+        return arguments.length;\n+    }\n+\n+    public Object[] getRawArguments() {\n+        return this.rawArguments;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n                 && hasSameMethod(actual)\n-                && argumentsMatch(actual);\n+                && (argumentsMatch(actual.getArguments()) || argumentsMatch(actual.getRawArguments()));\n     }\n \n-    private boolean argumentsMatch(Invocation actual) {\n-        Object[] arguments = actual.getArguments();\n-        if (arguments.length != matchers.size()) {\n+    private boolean argumentsMatch(Object[] actualArgs) {\n+        if (actualArgs.length != matchers.size()) {\n             return false;\n         }\n-        for (int i = 0; i < arguments.length; i++) {\n-            if (!matchers.get(i).matches(arguments[i])) {\n+        for (int i = 0; i < actualArgs.length; i++) {\n+            if (!matchers.get(i).matches(actualArgs[i])) {\n                 return false;\n             }\n         }\n         final boolean isUnverified = !candidate.isVerified();\n         final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n         final boolean methodEquals = hasSameMethod(candidate);\n-        final boolean overloadedButSameArgs = !methodEquals && argumentsMatch(candidate);        \n+        final boolean overloadedButSameArgs = !methodEquals && argumentsMatch(candidate.getArguments());        \n         \n         if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\n             return true;\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n     private void validateMatchers(Invocation invocation, List<Matcher> matchers) {\n         if (matchers != null) {\n             int recordedMatchersSize = matchers.size();\n-            int expectedMatchersSize = invocation.getArguments().length;\n+            int expectedMatchersSize = invocation.getArgumentsCount();\n             if (expectedMatchersSize != recordedMatchersSize) {\n                 new Reporter().invalidUseOfMatchers(expectedMatchersSize, recordedMatchersSize);\n             }\n--- a/test/org/mockitousage/bugs/VarargsNotPlayingWithAnyObjectTest.java\n+++ b/test/org/mockitousage/bugs/VarargsNotPlayingWithAnyObjectTest.java\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockitoutil.TestBase;\n \n+//see issue 62\n public class VarargsNotPlayingWithAnyObjectTest extends TestBase {\n \n     interface VarargMethod {\n         Object run(String... args);\n     }\n+    \n+    @Mock VarargMethod mock;\n \n-    @Ignore\n     @Test\n-    public void testVarargStubbing() {\n-        VarargMethod mock = Mockito.mock(VarargMethod.class);\n+    public void shouldAllowAnyObjectForVarArgs() {\n         mock.run(\"a\", \"b\");\n         \n         verify(mock).run((String[]) anyObject());\n+        verify(mock).run(anyString(), anyString());\n+        verify(mock).run((String) anyObject(), (String) anyObject());\n         verify(mock).run(new String[] {anyObject()});\n+        \n         verify(mock, never()).run();\n+        verify(mock, never()).run(anyString(), eq(\"f\"));\n+    }\n+    \n+    @Test\n+    public void shouldAllowAnyObjectForVarArgsStubbing() {\n+        when(mock.run((String[]) anyObject())).thenReturn(\"foo\");\n+        \n+        assertEquals(\"foo\", mock.run(\"a\", \"b\"));\n     }\n }", "timestamp": 1239192854, "metainfo": ""}