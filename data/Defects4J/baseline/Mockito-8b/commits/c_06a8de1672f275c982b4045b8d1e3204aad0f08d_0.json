{"sha": "06a8de1672f275c982b4045b8d1e3204aad0f08d", "log": "Did some clean up with TODOs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401313", "commit": "\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n import org.mockito.internal.util.Decamelizer;\n-\n-//TODO misplaced argument matcher when calling final method is weird and confusing\n \n /**\n  * Allows creating customized argument matchers. \n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n         return fromMockObject || fromOrgMockito && !isRunner;\n     }\n \n-    //TODO remove hasStackTrace strings\n-    public void filterStackTrace(Throwable hasStackTrace) {\n-        StackTraceElement[] filtered = filterStackTrace(hasStackTrace.getStackTrace());\n-        hasStackTrace.setStackTrace(filtered);\n+    public void filterStackTrace(Throwable throwable) {\n+        StackTraceElement[] filtered = filterStackTrace(throwable.getStackTrace());\n+        throwable.setStackTrace(filtered);\n     }\n \n     public StackTraceElement[] filterStackTrace(StackTraceElement[] target) {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n         return null;\n     }\n \n-    //TODO rename\n-    public Location getLastStackTrace(List<Invocation> invocations) {\n+    public Location getLastLocation(List<Invocation> invocations) {\n         if (invocations.isEmpty()) {\n             return null;\n         } else {\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            Location lastLocation = finder.getLastStackTrace(actualInvocations);\n+            Location lastLocation = finder.getLastLocation(actualInvocations);\n             reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        \n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            Location lastLocation = finder.getLastStackTrace(chunk);\n+            Location lastLocation = finder.getLastLocation(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            Location lastInvocation = finder.getLastStackTrace(actualInvocations);\n+            Location lastInvocation = finder.getLastLocation(actualInvocations);\n             reporter.tooLittleActualInvocations(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount == 0 && actualCount > 0) {\n             Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            Location lastInvocation = finder.getLastStackTrace(chunk);\n+            Location lastInvocation = finder.getLastLocation(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount < actualCount) {\n             Location firstUndesired = chunk.get(wantedCount).getLocation();\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         Mockito.inOrder(\"notMock\");\n     }\n     \n-    //TODO after 1.7 stack trace remover does not work very well when it comes to threads\n-    //TODO after 1.7 print warning when trying to mock a final class\n-}\n+    //TODO after 1.7 stack filter does not work very well when it comes to threads?\n+}\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n     \n     @Test\n     public void shouldGetLastStackTrace() throws Exception {\n-        Location last = finder.getLastStackTrace(invocations);\n+        Location last = finder.getLastLocation(invocations);\n         assertSame(differentMethodInvocation.getLocation(), last);\n         \n-        assertNull(finder.getLastStackTrace(Collections.<Invocation>emptyList()));\n+        assertNull(finder.getLastLocation(Collections.<Invocation>emptyList()));\n     } \n     \n     @Test\n--- a/test/org/mockitousage/matchers/ArgumentCaptorTest.java\n+++ b/test/org/mockitousage/matchers/ArgumentCaptorTest.java\n \n         public T getValue() {\n             //TODO after 1.7 nice instanceof check here?\n+            //TODO capture according to what one guy wrote to the mailing list?\n             return (T) argument;\n         }\n     }\n--- a/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n \n import org.junit.After;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockitousage.IMethods;\n-import org.mockitoutil.ExtraMatchers;\n import org.mockitoutil.TestBase;\n \n public class DetectingMisusedMatchersTest extends TestBase {\n             fail();\n         } catch (UnfinishedVerificationException e) {}\n     }\n-    \n-    @Ignore(\"let's not implement it...\")\n-    @Test\n-    public void shouldFailAndShowWhereMatchersAreMisused() {\n-        misplacedArgumentMatcher();\n-        try {\n-            mock(IMethods.class);\n-            fail();\n-        } catch (InvalidUseOfMatchersException e) {\n-            assertThat(e, messageContains(\"Misplaced argument matcher\"));\n-            assertThat(e.getCause(), ExtraMatchers.hasFirstMethodInStackTrace(\"misplacedArgumentMatcher\"));\n-        }\n-    }\n }\n--- a/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n         mock = mock(IMethods.class);\n     }\n     \n-    //TODO do the same for other misusing problems\n-    @Test\n-    public void shouldShowWhereIsUnfinishedVerification() throws Exception {\n-        unfinishedVerificationHere();\n-        try {\n-            mock(IMethods.class);\n-            fail();\n-        } catch (UnfinishedVerificationException e) {\n-            assertContains(\"InvalidStateDetectionTest.unfinishedVerificationHere\", e.getMessage());\n-        }\n-    }\n-\n-    private void unfinishedVerificationHere() {\n-        verify(mock);\n-    }\n-\n     @Test\n     public void shouldDetectUnfinishedStubbing() {\n         when(mock.simpleMethod());\n--- a/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n+++ b/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n import org.mockito.StateMaster;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n             assertThat(e, messageContains(\"unfinishedStubbingHere(\"));\n         }\n     }\n+    \n+    @Test\n+    public void shouldShowWhereIsUnfinishedVerification() throws Exception {\n+        unfinishedVerificationHere();\n+        try {\n+            mock(IMethods.class);\n+            fail();\n+        } catch (UnfinishedVerificationException e) {\n+            assertContains(\"unfinishedVerificationHere(\", e.getMessage());\n+        }\n+    }\n+\n+    private void unfinishedVerificationHere() {\n+        verify(mock);\n+    }\n }\n--- a/test/org/mockitoutil/ExtraMatchers.java\n+++ b/test/org/mockitoutil/ExtraMatchers.java\n @SuppressWarnings(\"unchecked\")\n public class ExtraMatchers {\n \n-    //TODO remove\n     public static <T> Assertor<Throwable> hasFirstMethodInStackTrace(final String method) {\n         return hasMethodInStackTraceAt(0, method);\n     }\n         };\n     }\n     \n-    public static <T> Assertor<Collection> has(final T ... elements) {\n-        return new Assertor<Collection>() {\n-\n-            public void assertValue(Collection value) {\n-                for (T element : elements) {\n-                    assertTrue(\n-                            \"Element:\" +\n-                            \"\\n\" +\n-                            element +\n-                            \"does not exists in:\" +\n-                            \"\\n\" +\n-                            value, \n-                            value.contains(element));\n-                }\n-            }\n-        };\n-    }\n-    \n     public static <T> Assertor<Collection> hasExactlyInOrder(final T ... elements) {\n         return new Assertor<Collection>() {\n ", "timestamp": 1239194691, "metainfo": ""}