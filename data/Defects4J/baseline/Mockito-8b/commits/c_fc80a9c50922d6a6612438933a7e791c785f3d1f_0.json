{"sha": "fc80a9c50922d6a6612438933a7e791c785f3d1f", "log": "enabled another test, getting almost done with refactoring  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40318", "commit": "\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n \n //TODO pmd rule so that all that starts with should have @Test annotation (or all XTest have some annotations on public methods)\n-@Ignore\n public class PointingStackTraceToActualInvocationChunkInOrderTest extends RequiresValidState {\n     \n     private IMethods mock;\n     }\n     \n     @Test\n-    public void shouldPointStackTraceToActualInvocation() {\n+    public void shouldPointStackTraceToPreviousInvocation() {\n         inOrder.verify(mock, times(2)).simpleMethod(anyInt());\n         inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n         \n     }\n     \n     @Test\n-    public void shouldPointToActualInvocation() {\n+    public void shouldPointToThirdInteractionBecauseAtLeastOnceUsed() {\n         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n             inOrder.verify(mockTwo).simpleMethod(999);\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n         }\n     }\n     \n     @Test\n-    public void shouldPointToUnverifiedInvocation() {\n-        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+    public void shouldPointToThirdChunkWhenTooLittleActualInvocations() {\n+        inOrder.verify(mock, times(2)).simpleMethod(anyInt());\n         inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n             inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n         }\n     }\n     \n     @Test\n-    public void shouldPointToTooManyInvocationsChunk() {\n+    public void shouldPointToFourthChunkBecauseTooManyActualInvocations() {\n         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n-            inOrder.verify(mockTwo).simpleMethod(anyInt());\n-            fail();\n-        } catch (VerifcationInOrderFailed e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n-        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n-        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        \n-        try {\n-            inOrder.verify(mockTwo, times(3)).simpleMethod(anyInt());\n+            inOrder.verify(mockTwo, times(0)).simpleMethod(anyInt());\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));", "timestamp": 1200958446, "metainfo": ""}