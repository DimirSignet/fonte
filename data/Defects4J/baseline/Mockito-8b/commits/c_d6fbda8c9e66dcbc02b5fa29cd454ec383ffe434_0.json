{"sha": "d6fbda8c9e66dcbc02b5fa29cd454ec383ffe434", "log": "Added more context to the exception message.", "commit": "\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.configuration;\n-\n-import org.mockito.configuration.IMockitoConfiguration;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.misusing.MockitoConfigurationException;\n-import org.mockito.plugins.MockMaker;\n-import org.mockito.plugins.StackTraceCleanerProvider;\n-\n-import java.io.*;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.List;\n-\n-/**\n- * Loads configuration or extension points available in the classpath.\n- *\n- * <p>\n- * <ul>\n- *     <li>\n- *         Can load the mockito configuration. The user who want to provide his own mockito configuration\n- *         should write the class <code>org.mockito.configuration.MockitoConfiguration</code> that implements\n- *         {@link IMockitoConfiguration}. For example :\n- *         <pre class=\"code\"><code class=\"java\">\n- * package org.mockito.configuration;\n- *\n- * //...\n- *\n- * public class MockitoConfiguration implements IMockitoConfiguration {\n- *     boolean enableClassCache() { return false; }\n- *\n- *     // ...\n- * }\n- *     </code></pre>\n- *     </li>\n- *     <li>\n- *         Can load available mockito extensions. Currently Mockito only have one extension point the\n- *         {@link MockMaker}. This extension point allows a user to provide his own bytecode engine to build mocks.\n- *         <br>Suppose you wrote an extension to create mocks with some <em>Awesome</em> library, in order to tell\n- *         Mockito to use it you need to put in your classpath\n- *         <ol style=\"list-style-type: lower-alpha\">\n- *             <li>The implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n- *             <li>A file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n- *             <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n- *             the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n- *         </ol>\n- *     </li>\n- * </ul>\n- * </p>\n- */\n-public class ClassPathLoader {\n-    private static final String DEFAULT_MOCK_MAKER_CLASS =\n-            \"org.mockito.internal.creation.CglibMockMaker\";\n-    private static final String DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS =\n-            \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\";\n-    public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n-\n-    private static final MockMaker mockMaker = findPlatformMockMaker();\n-    private static final StackTraceCleanerProvider stackTraceCleanerProvider =\n-            findPlatformStackTraceCleanerProvider();\n-\n-    /**\n-     * @return configuration loaded from classpath or null\n-     */\n-    @SuppressWarnings({\"unchecked\"})\n-    public IMockitoConfiguration loadConfiguration() {\n-        //Trying to get config from classpath\n-        Class configClass;\n-        try {\n-            configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n-        } catch (ClassNotFoundException e) {\n-            //that's ok, it means there is no global config, using default one.\n-            return null;\n-        }\n-\n-        try {\n-            return (IMockitoConfiguration) configClass.newInstance();\n-        } catch (ClassCastException e) {\n-            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n-        } catch (Exception e) {\n-            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n-        }\n-    }\n-\n-    /**\n-     * Returns the implementation of the mock maker available for the current runtime.\n-     *\n-     * <p>Returns {@link org.mockito.internal.creation.CglibMockMaker} if no\n-     * {@link MockMaker} extension exists or is visible in the current classpath.</p>\n-     */\n-    public static MockMaker getMockMaker() {\n-        return mockMaker;\n-    }\n-\n-    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n-        //TODO we should throw some sensible exception if this is null.\n-        return stackTraceCleanerProvider;\n-    }\n-\n-    /**\n-     * Scans the classpath to find a mock maker plugin if one is available,\n-     * allowing mockito to run on alternative platforms like Android.\n-     */\n-    static MockMaker findPlatformMockMaker() {\n-        return findPluginImplementation(MockMaker.class, DEFAULT_MOCK_MAKER_CLASS);\n-    }\n-\n-    static StackTraceCleanerProvider findPlatformStackTraceCleanerProvider() {\n-        return findPluginImplementation(\n-                StackTraceCleanerProvider.class, DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS);\n-    }\n-\n-    static <T> T findPluginImplementation(Class<T> pluginType, String defaultPluginClassName) {\n-        for (T plugin : loadImplementations(pluginType)) {\n-            return plugin; // return the first one service loader finds (if any)\n-        }\n-\n-        try {\n-            // Default implementation. Use our own ClassLoader instead of the context\n-            // ClassLoader, as the default implementation is assumed to be part of\n-            // Mockito and may not be available via the context ClassLoader.\n-            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n-        } catch (Exception e) {\n-            throw new MockitoException(\"Failed to load default \" + pluginType, e);\n-        }\n-    }\n-\n-    /**\n-     * Equivalent to {@link java.util.ServiceLoader#load} but without requiring\n-     * Java 6 / Android 2.3 (Gingerbread).\n-     */\n-    static <T> List<T> loadImplementations(Class<T> service) {\n-        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-        if (loader == null) {\n-            loader = ClassLoader.getSystemClassLoader();\n-        }\n-\n-        Enumeration<URL> resources;\n-        try {\n-            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n-        } catch (IOException e) {\n-            throw new MockitoException(\"Failed to load \" + service, e);\n-        }\n-\n-        List<T> result = new ArrayList<T>();\n-        for (URL resource : Collections.list(resources)) {\n-            InputStream in = null;\n-            try {\n-                in = resource.openStream();\n-                for (String line : readerToLines(new InputStreamReader(in, \"UTF-8\"))) {\n-                    String name = stripCommentAndWhitespace(line);\n-                    if (name.length() != 0) {\n-                        result.add(service.cast(loader.loadClass(name).newInstance()));\n-                    }\n-                }\n-            } catch (Exception e) {\n-                throw new MockitoConfigurationException(\n-                        \"Failed to load \" + service + \" using \" + resource, e);\n-            } finally {\n-                closeQuietly(in);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    static List<String> readerToLines(Reader reader) throws IOException {\n-        List<String> result = new ArrayList<String>();\n-        BufferedReader lineReader = new BufferedReader(reader);\n-        String line;\n-        while ((line = lineReader.readLine()) != null) {\n-            result.add(line);\n-        }\n-        return result;\n-    }\n-\n-    static String stripCommentAndWhitespace(String line) {\n-        int hash = line.indexOf('#');\n-        if (hash != -1) {\n-            line = line.substring(0, hash);\n-        }\n-        return line.trim();\n-    }\n-\n-    private static void closeQuietly(InputStream in) {\n-        if (in != null) {\n-            try {\n-                in.close();\n-            } catch (IOException ignored) {\n-            }\n-        }\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.plugins.StackTraceCleanerProvider;\n+\n+import java.io.*;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+\n+/**\n+ * Loads configuration or extension points available in the classpath.\n+ *\n+ * <p>\n+ * <ul>\n+ *     <li>\n+ *         Can load the mockito configuration. The user who want to provide his own mockito configuration\n+ *         should write the class <code>org.mockito.configuration.MockitoConfiguration</code> that implements\n+ *         {@link IMockitoConfiguration}. For example :\n+ *         <pre class=\"code\"><code class=\"java\">\n+ * package org.mockito.configuration;\n+ *\n+ * //...\n+ *\n+ * public class MockitoConfiguration implements IMockitoConfiguration {\n+ *     boolean enableClassCache() { return false; }\n+ *\n+ *     // ...\n+ * }\n+ *     </code></pre>\n+ *     </li>\n+ *     <li>\n+ *         Can load available mockito extensions. Currently Mockito only have one extension point the\n+ *         {@link MockMaker}. This extension point allows a user to provide his own bytecode engine to build mocks.\n+ *         <br>Suppose you wrote an extension to create mocks with some <em>Awesome</em> library, in order to tell\n+ *         Mockito to use it you need to put in your classpath\n+ *         <ol style=\"list-style-type: lower-alpha\">\n+ *             <li>The implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *             <li>A file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n+ *             <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n+ *             the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *         </ol>\n+ *     </li>\n+ * </ul>\n+ * </p>\n+ */\n+public class ClassPathLoader {\n+    private static final String DEFAULT_MOCK_MAKER_CLASS =\n+            \"org.mockito.internal.creation.CglibMockMaker\";\n+    private static final String DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS =\n+            \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\";\n+    public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n+\n+    private static final MockMaker mockMaker = findPlatformMockMaker();\n+    private static final StackTraceCleanerProvider stackTraceCleanerProvider =\n+            findPlatformStackTraceCleanerProvider();\n+\n+    /**\n+     * @return configuration loaded from classpath or null\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    public IMockitoConfiguration loadConfiguration() {\n+        //Trying to get config from classpath\n+        Class configClass;\n+        try {\n+            configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n+        } catch (ClassNotFoundException e) {\n+            //that's ok, it means there is no global config, using default one.\n+            return null;\n+        }\n+\n+        try {\n+            return (IMockitoConfiguration) configClass.newInstance();\n+        } catch (ClassCastException e) {\n+            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n+        } catch (Exception e) {\n+            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation of the mock maker available for the current runtime.\n+     *\n+     * <p>Returns {@link org.mockito.internal.creation.CglibMockMaker} if no\n+     * {@link MockMaker} extension exists or is visible in the current classpath.</p>\n+     */\n+    public static MockMaker getMockMaker() {\n+        return mockMaker;\n+    }\n+\n+    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n+        //TODO we should throw some sensible exception if this is null.\n+        return stackTraceCleanerProvider;\n+    }\n+\n+    /**\n+     * Scans the classpath to find a mock maker plugin if one is available,\n+     * allowing mockito to run on alternative platforms like Android.\n+     */\n+    static MockMaker findPlatformMockMaker() {\n+        return findPluginImplementation(MockMaker.class, DEFAULT_MOCK_MAKER_CLASS);\n+    }\n+\n+    static StackTraceCleanerProvider findPlatformStackTraceCleanerProvider() {\n+        return findPluginImplementation(\n+                StackTraceCleanerProvider.class, DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS);\n+    }\n+\n+    static <T> T findPluginImplementation(Class<T> pluginType, String defaultPluginClassName) {\n+        for (T plugin : loadImplementations(pluginType)) {\n+            return plugin; // return the first one service loader finds (if any)\n+        }\n+\n+        try {\n+            // Default implementation. Use our own ClassLoader instead of the context\n+            // ClassLoader, as the default implementation is assumed to be part of\n+            // Mockito and may not be available via the context ClassLoader.\n+            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n+        } catch (Exception e) {\n+            throw new MockitoException(\"Internal problem occurred, please report it. \" +\n+                    \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" +\n+                    \"Failed to load \" + pluginType, e);\n+        }\n+    }\n+\n+    /**\n+     * Equivalent to {@link java.util.ServiceLoader#load} but without requiring\n+     * Java 6 / Android 2.3 (Gingerbread).\n+     */\n+    static <T> List<T> loadImplementations(Class<T> service) {\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        if (loader == null) {\n+            loader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> resources;\n+        try {\n+            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n+        } catch (IOException e) {\n+            throw new MockitoException(\"Failed to load \" + service, e);\n+        }\n+\n+        List<T> result = new ArrayList<T>();\n+        for (URL resource : Collections.list(resources)) {\n+            InputStream in = null;\n+            try {\n+                in = resource.openStream();\n+                for (String line : readerToLines(new InputStreamReader(in, \"UTF-8\"))) {\n+                    String name = stripCommentAndWhitespace(line);\n+                    if (name.length() != 0) {\n+                        result.add(service.cast(loader.loadClass(name).newInstance()));\n+                    }\n+                }\n+            } catch (Exception e) {\n+                throw new MockitoConfigurationException(\n+                        \"Failed to load \" + service + \" using \" + resource, e);\n+            } finally {\n+                closeQuietly(in);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    static List<String> readerToLines(Reader reader) throws IOException {\n+        List<String> result = new ArrayList<String>();\n+        BufferedReader lineReader = new BufferedReader(reader);\n+        String line;\n+        while ((line = lineReader.readLine()) != null) {\n+            result.add(line);\n+        }\n+        return result;\n+    }\n+\n+    static String stripCommentAndWhitespace(String line) {\n+        int hash = line.indexOf('#');\n+        if (hash != -1) {\n+            line = line.substring(0, hash);\n+        }\n+        return line.trim();\n+    }\n+\n+    private static void closeQuietly(InputStream in) {\n+        if (in != null) {\n+            try {\n+                in.close();\n+            } catch (IOException ignored) {\n+            }\n+        }\n+    }\n }", "timestamp": 1354952904, "metainfo": ""}