{"sha": "a825919a81dffd8b586a2f5ad9c7b3d434d9f414", "log": "Added more tests. Cleaned up a bit. Fixed the warning code so that it only reports truly unused stubs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401122", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.MockitoStubber;\n import org.mockito.internal.stubbing.Returns;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n             //it is a return-value interaction but not stubbed. This *might* be a problem\n             mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n         }\n-            \n+        \n         if (answer != null) {\n+            mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n             return answer.answer(invocation);\n         } else if (MockUtil.isMock(instance)) {\n             return returnValues.valueFor(invocation);\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n \n public class DebuggingInfo {\n \n-    private final List<Invocation> stubbedInvocations = new LinkedList<Invocation>();\n-    private final List<InvocationMatcher> potentiallyUnstubbedInvocations = new LinkedList<InvocationMatcher>();\n-    //TODO this code is crap. Use different field to maintain unusedInvocations\n-    private final List<InvocationMatcher> unusedInvocations = new LinkedList<InvocationMatcher>();\n+    private final List<Invocation> unusedStubs = new LinkedList<Invocation>();\n+    private final List<InvocationMatcher> unstubbedInvocations = new LinkedList<InvocationMatcher>();\n+\n     private boolean collectingData;\n \n     public void addStubbedInvocation(Invocation invocation) {\n             return;\n         }\n         \n-        //TODO test \n-        //this is required because we don't know if unstubbedInvocation was really stubbed later...\n-        Iterator<InvocationMatcher> unstubbedIterator = potentiallyUnstubbedInvocations.iterator();\n+        Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations.iterator();\n         while(unstubbedIterator.hasNext()) {\n             InvocationMatcher unstubbed = unstubbedIterator.next();\n             if (unstubbed.getInvocation().equals(invocation)) {\n                 unstubbedIterator.remove();\n             }\n         }\n-\n-        stubbedInvocations.add(invocation);\n+        \n+        unusedStubs.add(invocation);\n     }\n \n     public void addPotentiallyUnstubbed(InvocationMatcher invocationMatcher) {\n         if (!collectingData) {\n             return;\n         }\n-        potentiallyUnstubbedInvocations.add(invocationMatcher);\n+        unstubbedInvocations.add(invocationMatcher);\n+    }\n+    \n+    public void reportUsedStub(InvocationMatcher invocationMatcher) {\n+        Iterator<Invocation> i = unusedStubs.iterator();\n+        while(i.hasNext()) {\n+            Invocation invocation = i.next();\n+            if (invocationMatcher.matches(invocation)) {\n+                i.remove();\n+            }\n+        }\n     }\n \n     public void collectData() {\n \n     public void clearData() {\n         collectingData = false;\n-        potentiallyUnstubbedInvocations.clear();\n-        stubbedInvocations.clear();\n+        unstubbedInvocations.clear();\n+        unusedStubs.clear();\n     }\n \n     public void printWarnings(MockitoLogger logger) {\n         if (hasData()) {\n-            WarningsPrinter warningsPrinter = new WarningsPrinter(stubbedInvocations, potentiallyUnstubbedInvocations);\n+            //TODO should only pass those that really wasn't called...\n+            WarningsPrinter warningsPrinter = new WarningsPrinter(unusedStubs, unstubbedInvocations);\n             warningsPrinter.print(logger);\n         }\n     }\n \n     public boolean hasData() {\n-        return !stubbedInvocations.isEmpty() || !potentiallyUnstubbedInvocations.isEmpty();\n-    }\n-    \n-    @Override\n-    public String toString() {\n-        return \"unusedInvocations: \" + stubbedInvocations + \"\\nunstubbed invocations:\" + potentiallyUnstubbedInvocations;\n+        return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n     }\n }\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n         return findAnswerFor(invocation).answer(invocation);\n     }\n \n-    public Answer findAnswerFor(Invocation invocation) {\n+    public Answer<?> findAnswerFor(Invocation invocation) {\n         for (StubbedInvocationMatcher s : stubbed) {\n             if (s.matches(invocation)) {\n                 return s;\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n     }\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n+        //TODO is synchronized here necessary?\n         synchronized(answers) {\n             return answers.size() == 1 ? answers.peek().answer(invocation) : answers.poll().answer(invocation);\n         }\n--- a/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerTest.java\n+++ b/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerTest.java\n             }\n         });\n     }\n-    \n+\n     @Test\n     public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n         runner.run(notifier, new SimpleRunner() {\n         runner.run(notifier, new SimpleRunner() {\n             public void run(RunNotifier notifier) {\n                 someStubbing();\n-                callStubbedMethodCorrectly();\n+                //TODO below should be different test method\n+//                callStubbedMethodCorrectly();\n                 callStubbedMethodWithDifferentArgs();\n                 notifier.fireTestFailure(null);\n                 \n             }\n         });\n     }\n+    \n+    @Test\n+    public void shouldNotLogUsedStubbingWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new SimpleRunner() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod()).thenReturn(\"foo\");\n+                mock.simpleMethod();\n+                \n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = logger.getLoggedInfo();\n+                assertEquals(\"\", loggedInfo);\n+            }\n+        });\n+    }\n+    \n     \n     public void shouldClearDebuggingDataAfterwards() throws Exception {\n         final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n         \n         public void log(Object what) {\n //            can be uncommented when debugging this test\n-//            super.println(what);\n+//            super.log(what);\n             loggedInfo.append(what);\n         }\n ", "timestamp": 1230848243, "metainfo": ""}