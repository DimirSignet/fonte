{"sha": "4b81c5d36e1ab63412c9a55d982cf5c6df238dab", "log": "Renamed ReturnsIdentity by ReturnsArgumentAt  --HG-- rename : src/org/mockito/stubbing/answers/ReturnsIdentity.java => src/org/mockito/stubbing/answers/ReturnsArgumentAt.java rename : test/org/mockito/stubbing/answers/ReturnsIdentityTest.java => test/org/mockito/stubbing/answers/ReturnsArgumentAtTest.java", "commit": "\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n package org.mockito;\n \n import org.mockito.stubbing.Answer;\n-import org.mockito.stubbing.answers.ReturnsIdentity;\n+import org.mockito.stubbing.answers.ReturnsArgumentAt;\n \n /**\n  * Additional answers provides factory methods for less common answers.\n  */\n @SuppressWarnings(\"unchecked\")\n public class AdditionalAnswers {\n-    private static final ReturnsIdentity RETURNS_FIRST_ARGUMENT = new ReturnsIdentity(0);\n-    private static final ReturnsIdentity RETURNS_SECOND_ARGUMENT = new ReturnsIdentity(1);\n-    private static final ReturnsIdentity RETURNS_LAST_ARGUMENT = new ReturnsIdentity(-1);\n+    private static final ReturnsArgumentAt RETURNS_FIRST_ARGUMENT = new ReturnsArgumentAt(0);\n+    private static final ReturnsArgumentAt RETURNS_SECOND_ARGUMENT = new ReturnsArgumentAt(1);\n+    private static final ReturnsArgumentAt RETURNS_LAST_ARGUMENT = new ReturnsArgumentAt(-1);\n \n     /**\n      * Returns the first parameter of an invocation.\n      * @since 1.9.5\n      */\n     public static <T> Answer<T> returnsArgAtPosition(int position) {\n-        return (Answer<T>) new ReturnsIdentity(position);\n+        return (Answer<T>) new ReturnsArgumentAt(position);\n     }\n \n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                                         \"returned.\"));\n     }\n \n-    public int invalidArgumentIndexRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n+    public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n         throw new MockitoException(\n                 join(\"Invalid argument index for the current invocation of method : \",\n                      \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n-import org.mockito.stubbing.answers.ReturnsIdentity;\n+import org.mockito.stubbing.answers.ReturnsArgumentAt;\n \n public class AnswersValidator {\n \n             validateMockingConcreteClass((CallsRealMethods) answer, methodInfo);\n         }\n \n-        if (answer instanceof ReturnsIdentity) {\n-            ReturnsIdentity returnsIdentity = (ReturnsIdentity) answer;\n-            validateReturnArgIdentity(returnsIdentity, invocation);\n+        if (answer instanceof ReturnsArgumentAt) {\n+            ReturnsArgumentAt returnsArgumentAt = (ReturnsArgumentAt) answer;\n+            validateReturnArgIdentity(returnsArgumentAt, invocation);\n         }\n     }\n \n-    private void validateReturnArgIdentity(ReturnsIdentity returnsIdentity, Invocation invocation) {\n-        returnsIdentity.validateIndexWithinInvocationRange(invocation);\n+    private void validateReturnArgIdentity(ReturnsArgumentAt returnsArgumentAt, Invocation invocation) {\n+        returnsArgumentAt.validateIndexWithinInvocationRange(invocation);\n \n         MethodInfo methodInfo = new MethodInfo(invocation);\n-        if (!methodInfo.isValidReturnType(returnsIdentity.returnedTypeOnSignature(invocation))) {\n+        if (!methodInfo.isValidReturnType(returnsArgumentAt.returnedTypeOnSignature(invocation))) {\n             new Reporter().wrongTypeOfArgumentToReturn(invocation, methodInfo.printMethodReturnType(),\n-                                                       returnsIdentity.returnedTypeOnSignature(invocation),\n-                                                       returnsIdentity.wantedArgumentIndex());\n+                                                       returnsArgumentAt.returnedTypeOnSignature(invocation),\n+                                                       returnsArgumentAt.wantedArgumentPosition());\n         }\n \n     }\n--- /dev/null\n+++ b/src/org/mockito/stubbing/answers/ReturnsArgumentAt.java\n+package org.mockito.stubbing.answers;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Returns the passed parameter identity at specified index.\n+ *\n+ * <p>The <code>argumentIndex</code> represents the index in the argument array of the invocation.</p>\n+ * <p>If this number equals -1 then the last argument is returned.</p>\n+ *\n+ * @see org.mockito.AdditionalAnswers\n+ * @since 1.9.5\n+ */\n+public class ReturnsArgumentAt implements Answer<Object>, Serializable {\n+\n+    private static final long serialVersionUID = -589315085166295101L;\n+\n+    public static final int LAST_ARGUMENT = -1;\n+\n+    private final int wantedArgumentPosition;\n+\n+    /**\n+     * Build the identity answer to return the argument at the given position in the argument array.\n+     *\n+     * @param wantedArgumentPosition The position of the argument identity to return in the invocation.\n+     *                      Using <code>-1</code> indicates the last argument.\n+     */\n+    public ReturnsArgumentAt(int wantedArgumentPosition) {\n+        this.wantedArgumentPosition = checkWithinAllowedRange(wantedArgumentPosition);\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        validateIndexWithinInvocationRange(invocation);\n+        return invocation.getArguments()[actualArgumentPosition(invocation)];\n+    }\n+\n+\n+    private int actualArgumentPosition(InvocationOnMock invocation) {\n+        return returningLastArg() ?\n+                lastArgumentIndexOf(invocation) :\n+                argumentIndexOf(invocation);\n+    }\n+\n+    private boolean returningLastArg() {\n+        return wantedArgumentPosition == LAST_ARGUMENT;\n+    }\n+\n+    private int argumentIndexOf(InvocationOnMock invocation) {\n+        return wantedArgumentPosition;\n+    }\n+\n+    private int lastArgumentIndexOf(InvocationOnMock invocation) {\n+        return invocation.getArguments().length - 1;\n+    }\n+\n+    private int checkWithinAllowedRange(int argumentPosition) {\n+        if (argumentPosition != LAST_ARGUMENT && argumentPosition < 0) {\n+            new Reporter().invalidArgumentRangeAtIdentityAnswerCreationTime();\n+        }\n+        return argumentPosition;\n+    }\n+\n+    public int wantedArgumentPosition() {\n+        return wantedArgumentPosition;\n+    }\n+\n+    public void validateIndexWithinInvocationRange(InvocationOnMock invocation) {\n+        if (!argumentPositionInRange(invocation)) {\n+            new Reporter().invalidArgumentPositionRangeAtInvocationTime(invocation,\n+                                                                        returningLastArg(),\n+                                                                        wantedArgumentPosition);\n+        }\n+    }\n+\n+    private boolean argumentPositionInRange(InvocationOnMock invocation) {\n+        int actualArgumentPosition = actualArgumentPosition(invocation);\n+        if (actualArgumentPosition < 0) {\n+            return false;\n+        }\n+        if (!invocation.getMethod().isVarArgs()) {\n+            return invocation.getArguments().length > actualArgumentPosition;\n+        }\n+        // for all varargs accepts positive ranges\n+        return true;\n+    }\n+\n+    public Class returnedTypeOnSignature(InvocationOnMock invocation) {\n+        int actualArgumentPosition = actualArgumentPosition(invocation);\n+\n+        if(!invocation.getMethod().isVarArgs()) {\n+            return invocation.getMethod().getParameterTypes()[actualArgumentPosition];\n+        }\n+\n+        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n+        int varargPosition = parameterTypes.length - 1;\n+\n+        if(actualArgumentPosition < varargPosition) {\n+            return parameterTypes[actualArgumentPosition];\n+        } else {\n+            return parameterTypes[varargPosition].getComponentType();\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.invocation.Invocation;\n-import org.mockito.stubbing.answers.ReturnsIdentity;\n+import org.mockito.stubbing.answers.ReturnsArgumentAt;\n \n import java.io.IOException;\n import java.nio.charset.CharacterCodingException;\n     @Test\n     public void should_allow_possible_argument_types() throws Exception {\n         validator.validate(\n-                new ReturnsIdentity(0),\n+                new ReturnsArgumentAt(0),\n                 new InvocationBuilder().method(\"intArgumentReturningInt\").argTypes(int.class).arg(1000).toInvocation()\n         );\n         validator.validate(\n-                new ReturnsIdentity(0),\n+                new ReturnsArgumentAt(0),\n                 new InvocationBuilder().method(\"toString\").argTypes(String.class).arg(\"whatever\").toInvocation()\n         );\n         validator.validate(\n-                new ReturnsIdentity(2),\n+                new ReturnsArgumentAt(2),\n                 new InvocationBuilder().method(\"varargsObject\")\n                                        .argTypes(int.class, Object[].class)\n                                        .args(1000, \"Object\", \"Object\")\n                                        .toInvocation()\n         );\n         validator.validate(\n-                new ReturnsIdentity(1),\n+                new ReturnsArgumentAt(1),\n                 new InvocationBuilder().method(\"threeArgumentMethod\")\n                                        .argTypes(int.class, Object.class, String.class)\n                                        .args(1000, \"Object\", \"String\")\n     @Test\n     public void should_fail_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {\n         try {\n-            validator.validate(new ReturnsIdentity(30), new InvocationBuilder().method(\"oneArg\").arg(\"A\").toInvocation());\n+            validator.validate(new ReturnsArgumentAt(30), new InvocationBuilder().method(\"oneArg\").arg(\"A\").toInvocation());\n             fail();\n         } catch (MockitoException e) {\n             assertThat(e.getMessage())\n     public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation() throws Throwable {\n         try {\n             validator.validate(\n-                    new ReturnsIdentity(ReturnsIdentity.LAST_ARGUMENT),\n+                    new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT),\n                     new InvocationBuilder().simpleMethod().toInvocation()\n             );\n             fail();\n     public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type() throws Throwable {\n         try {\n             validator.validate(\n-                    new ReturnsIdentity(2),\n+                    new ReturnsArgumentAt(2),\n                     new InvocationBuilder().method(\"varargsReturningString\")\n                                            .argTypes(Object[].class)\n                                            .args(\"anyString\", new Object(), \"anyString\")\n--- /dev/null\n+++ b/test/org/mockito/stubbing/answers/ReturnsArgumentAtTest.java\n+package org.mockito.stubbing.answers;\n+\n+import org.junit.Test;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockitousage.IMethods;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class ReturnsArgumentAtTest {\n+\t@Test\n+\tpublic void should_be_able_to_return_the_first_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(0).answer(invocationWith(\"A\", \"B\"))).isEqualTo(\"A\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_second_parameter()\n+\t\t\tthrows Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(1).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"B\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_last_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(-1).answer(invocationWith(\"A\"))).isEqualTo(\"A\");\n+\t\tassertThat(new ReturnsArgumentAt(-1).answer(invocationWith(\"A\", \"B\"))).isEqualTo(\"B\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_specified_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsArgumentAt(0).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"A\");\n+\t\tassertThat(new ReturnsArgumentAt(1).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"B\");\n+\t\tassertThat(new ReturnsArgumentAt(2).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"C\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time() throws Throwable {\n+        try {\n+            new ReturnsArgumentAt(-30);\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"argument index\")\n+                    .containsIgnoringCase(\"positive number\")\n+                    .contains(\"1\")\n+                    .containsIgnoringCase(\"last argument\");\n+        }\n+    }\n+\n+\tprivate static InvocationOnMock invocationWith(final String... parameters) {\n+        return new InvocationOnMock() {\n+\n+            public Object getMock() {\n+                return null;\n+            }\n+\n+            public Method getMethod() {\n+                try {\n+                    return IMethods.class.getDeclaredMethod(\"varargsReturningString\", Object[].class);\n+                } catch (NoSuchMethodException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            public Object[] getArguments() {\n+                return parameters;\n+            }\n+\n+            public Object callRealMethod() throws Throwable {\n+                return null;\n+            }\n+        };\n+    }\n+\n+}", "timestamp": 1333888088, "metainfo": ""}