{"sha": "f6d3fdae07e95483f6969ae04dc2c1925d4b53c0", "log": "got rid of 'in order' in favor of 'strictly' to make everything consistent  --HG-- rename : test/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java => test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java rename : test/org/mockitousage/verification/VerificationInOrderTest.java => test/org/mockitousage/verification/StrictVerificationTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40184", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n         StrictOrderVerifier strictOrderVerifier = new StrictOrderVerifier();\n         for (Object mock : mocks) {\n             MockUtil.validateMock(mock);\n-            strictOrderVerifier.addMockToBeVerifiedInOrder(mock);\n+            strictOrderVerifier.addMockToBeVerifiedStrictly(mock);\n         }\n         return strictOrderVerifier;\n     }\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n \n class StrictOrderVerifier implements Strictly {\n     \n-    List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n+    List<Object> mocksToBeVerifiedSrictly = new LinkedList<Object>();\n     \n     public <T> T verify(T mock) {\n         return this.verify(mock, 1);\n     //TODO VerificationMode should be interfaced so that 'ongoing' bit is hidden\n     //TODO get rid of interface with int\n     public <T> T verify(T mock, int wantedNumberOfInvocations) {\n-        return this.verify(mock, VerificationMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n+        return this.verify(mock, VerificationMode.strict(wantedNumberOfInvocations, mocksToBeVerifiedSrictly));\n     }\n     \n     public <T> T verify(T mock, VerificationMode verificationMode) {\n-        if (!mocksToBeVerifiedInOrder.contains(mock)) {\n+        if (!mocksToBeVerifiedSrictly.contains(mock)) {\n             Exceptions.strictlyRequiresFamiliarMock();\n         }\n-        return Mockito.verify(mock, VerificationMode.inOrder(verificationMode.wantedCount(), mocksToBeVerifiedInOrder));\n+        return Mockito.verify(mock, VerificationMode.strict(verificationMode.wantedCount(), mocksToBeVerifiedSrictly));\n     }\n \n-    public void addMockToBeVerifiedInOrder(Object mock) {\n-        mocksToBeVerifiedInOrder.add(mock);\n+    public void addMockToBeVerifiedStrictly(Object mock) {\n+        mocksToBeVerifiedSrictly.add(mock);\n     }\n }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n \n public class Invocation {\n \n-    private boolean verified;\n-    \n     private final int sequenceNumber;\n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n+    private final HasStackTrace stackTrace;\n \n-    private boolean verifiedInOrder;\n-\n-    private HasStackTrace stackTrace;\n+    private boolean verified;\n+    private boolean verifiedStrictly;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n         this.mock = mock;\n         return sequenceNumber;\n     }\n \n-    public void markVerifiedInOrder() {\n+    public void markVerifiedStrictly() {\n         this.markVerified();\n-        this.verifiedInOrder = true;\n+        this.verifiedStrictly = true;\n     }\n \n-    public boolean isVerifiedInOrder() {\n-        return verifiedInOrder;\n+    public boolean isVerifiedStrictly() {\n+        return verifiedStrictly;\n     }\n     \n     public HasStackTrace getStackTrace() {\n--- a/src/org/mockito/internal/invocation/InvocationsChunker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsChunker.java\n import java.util.Set;\n import java.util.TreeSet;\n \n-\n public class InvocationsChunker {\n \n     private final InvocationsFinder finder;\n         this.finder = invocationsFinder;\n     }\n \n+    //TODO too big\n     public List<Invocation> getFirstUnverifiedInvocationChunk(List<Object> mocks) {\n         Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n                 new Comparator<Invocation>() {\n         \n         LinkedList<Invocation> chunk = new LinkedList<Invocation>();\n         for (Invocation i : allInvocationsInOrder) {\n-            if (i.isVerifiedInOrder()) {\n+            if (i.isVerifiedStrictly()) {\n                 continue;\n             }\n             \n--- a/src/org/mockito/internal/invocation/InvocationsMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsMarker.java\n             return;\n         }\n \n-        if (mode.orderOfInvocationsMatters()) {\n-            markVerifiedInOrder(invocations);\n+        if (mode.isStrict()) {\n+            markVerifiedStrictly(invocations);\n         } else {\n             markVerified(wanted, invocations);\n         }\n         }\n     }\n \n-    private void markVerifiedInOrder(List<Invocation> invocations) {\n+    private void markVerifiedStrictly(List<Invocation> invocations) {\n         for (Invocation i : invocations) {\n-            i.markVerifiedInOrder();\n+            i.markVerifiedStrictly();\n         }\n     }\n-\n }\n--- a/src/org/mockito/internal/progress/VerificationMode.java\n+++ b/src/org/mockito/internal/progress/VerificationMode.java\n \n     private final Integer wantedInvocationCount;\n     private final List<Object> mocksToBeVerifiedInSequence;\n+    \n+    //TODO messy\n \n     private VerificationMode(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n         if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n      */\n     public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n     \n-    public static VerificationMode inOrder(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n-        return new VerificationMode(wantedNumberOfInvocations, mocksToBeVerifiedInOrder);\n+    public static VerificationMode strict(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedStrictly) {\n+        return new VerificationMode(wantedNumberOfInvocations, mocksToBeVerifiedStrictly);\n     }\n \n     public boolean atLeastOnceMode() {\n         return mocksToBeVerifiedInSequence;\n     }\n \n-//TODO name    \n-    public boolean orderOfInvocationsMatters() {\n+    public boolean isStrict() {\n         return !mocksToBeVerifiedInSequence.isEmpty();\n     }\n \n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n     }\n     \n     private List<Invocation> getInvocationsForEvaluation(VerificationMode mode) {\n-        if (mode.orderOfInvocationsMatters()) {\n+        if (mode.isStrict()) {\n             return chunker.getFirstUnverifiedInvocationChunk(mode.getAllMocksToBeVerifiedInSequence());\n         } else {\n             return registeredInvocations;\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     }\n     \n     @Test\n-    public void shouldMarkVerifiedWhenMarkedVerifiedInOrder() throws Exception {\n+    public void shouldMarkVerifiedWhenMarkingVerifiedStrictly() throws Exception {\n         assertFalse(invocation.isVerified());\n-        assertFalse(invocation.isVerifiedInOrder());\n+        assertFalse(invocation.isVerifiedStrictly());\n         \n-        invocation.markVerifiedInOrder();\n+        invocation.markVerifiedStrictly();\n         \n         assertTrue(invocation.isVerified());\n-        assertTrue(invocation.isVerifiedInOrder());\n+        assertTrue(invocation.isVerifiedStrictly());\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n     \n     @Test\n     public void shouldGetSecondUnverifiedInvocationChunk() throws Exception {\n-        simpleMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n+        simpleMethodInvocation.markVerifiedStrictly();\n+        simpleMethodInvocationTwo.markVerifiedStrictly();\n         \n         List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         \n     \n     @Test\n     public void shouldGetThirdUnverifiedInvocationChunk() throws Exception {\n-        simpleMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n-        differentMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocation.markVerifiedStrictly();\n+        simpleMethodInvocationTwo.markVerifiedStrictly();\n+        differentMethodInvocation.markVerifiedStrictly();\n         \n         List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         \n     \n     @Test\n     public void shouldNotGetInvocationsChunk() throws Exception {\n-        simpleMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n-        differentMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationThree.markVerifiedInOrder();\n+        simpleMethodInvocation.markVerifiedStrictly();\n+        simpleMethodInvocationTwo.markVerifiedStrictly();\n+        differentMethodInvocation.markVerifiedStrictly();\n+        simpleMethodInvocationThree.markVerifiedStrictly();\n         \n         List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         \n--- a/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n-import static org.mockito.internal.progress.VerificationMode.inOrder;\n+import static org.mockito.internal.progress.VerificationMode.strict;\n import static org.mockito.internal.progress.VerificationMode.times;\n \n import java.util.Arrays;\n     }\n     \n     @Test\n-    public void shouldMarkAsVerifiedInOrderWhenVerificationIsNotInOrder() throws Exception {\n+    public void shouldNotMarkAsVerifiedStrictlyWhenVerificationIsStrict() throws Exception {\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertEquals(false, simpleMethodInvocation.isVerifiedInOrder());\n+        assertEquals(false, simpleMethodInvocation.isVerifiedStrictly());\n     }\n     \n     @Test\n     }\n     \n     @Test\n-    public void shouldMarkAsVerifedInOrderAllInvocationsFromChunk() throws Exception {\n-        VerificationMode mode = inOrder(null, Arrays.asList(new Object()));\n+    public void shouldMarkAsVerifedStrictlyAllInvocationsFromChunk() throws Exception {\n+        VerificationMode mode = strict(null, Arrays.asList(new Object()));\n         Invocation doesntMatter = null;\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n         \n-        assertEquals(true, simpleMethodInvocation.isVerifiedInOrder());\n-        assertEquals(true, simpleMethodInvocationTwo.isVerifiedInOrder());\n-        assertEquals(true, differentMethodInvocation.isVerifiedInOrder());\n-        assertEquals(true, simpleMethodInvocationThree.isVerifiedInOrder());\n+        assertEquals(true, simpleMethodInvocation.isVerifiedStrictly());\n+        assertEquals(true, simpleMethodInvocationTwo.isVerifiedStrictly());\n+        assertEquals(true, differentMethodInvocation.isVerifiedStrictly());\n+        assertEquals(true, simpleMethodInvocationThree.isVerifiedStrictly());\n     }\n     \n     @Test\n     public void shouldMarkAsVerifedAllInvocationsFromThirdChunk() throws Exception {\n-        VerificationMode mode = inOrder(null, Arrays.asList(new Object()));\n+        VerificationMode mode = strict(null, Arrays.asList(new Object()));\n         \n         Invocation doesntMatter = null;\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n         \n-        assertEquals(true, simpleMethodInvocationThree.isVerifiedInOrder());\n+        assertEquals(true, simpleMethodInvocationThree.isVerifiedStrictly());\n     }\n }\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n \n     private NumberOfInvocationsVerifier verifier;\n+    //TODO other tests\n     \n     @Before\n     public void setup() {\n \n     @Test\n     public void shouldNotCheckForWrongNumberOfModificationsWhenAtLeastOnceVerification() throws Exception {\n-        VerificationMode inOrder = VerificationMode.atLeastOnce();\n-        \n-        verifier.verify(null, null, inOrder);\n+        verifier.verify(null, null, VerificationMode.atLeastOnce());\n     }\n }\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n     }\n     \n     @Test\n-    public void shouldVerifyInOrder() {\n+    public void shouldVerifyStrictly() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        VerificationMode mode = VerificationMode.inOrder(10, Arrays.<Object>asList(\"mock\"));\n+        VerificationMode mode = VerificationMode.strict(10, Arrays.<Object>asList(\"mock\"));\n         recorder.verify(differentMethod, mode);\n         \n         assertEquals(verifier.mode, mode);\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderTest;\n+import org.mockitousage.verification.StrictVerificationMixedWithOrdiraryVerificationTest;\n+import org.mockitousage.verification.StrictVerificationTest;\n import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n import org.mockitousage.verification.VerificationUsingMatchersTest;\n \n                     ExactNumberOfTimesVerificationTest.class, \n                     DescriptiveMessagesWhenVerificationFailsTest.class, \n                     NoMoreInteractionsVerificationTest.class, \n-                    VerificationInOrderMixedWithOrdiraryVerificationTest.class, \n-                    VerificationInOrderTest.class, \n+                    StrictVerificationMixedWithOrdiraryVerificationTest.class, \n+                    StrictVerificationTest.class, \n                     VerificationOnMultipleMocksUsingMatchersTest.class, \n                     VerificationUsingMatchersTest.class, \n                     MatchersTest.class,\n--- /dev/null\n+++ b/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.exceptions.verification.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class StrictVerificationMixedWithOrdiraryVerificationTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+\n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockThree.simpleMethod(4);\n+\n+        strictly = createStrictOrderVerifier(mockOne, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldMixStrictVerificationAndNormalVerification() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowOrdinarilyVerifyingStrictlyControlledMock() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowRedundantVerifications() {\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        \n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractions() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractionsOnStrictlyControlledMock() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrder() {\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        try {\n+            strictly.verify(mockThree).simpleMethod(3);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrderForLastInvocationIsTooEarly() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            strictly.verify(mockThree).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldScreamWhenNotStrictMockPassedToStrictly() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(1);\n+    } \n+    \n+    @Test\n+    public void shouldUseEqualsToVerifyMethodArguments() {\n+        mockOne = mock(IMethods.class);\n+        \n+        String textOne = \"test\";\n+        String textTwo = new String(textOne);\n+        \n+        assertEquals(textOne, textTwo);\n+        assertNotSame(textOne, textTwo);\n+        \n+        mockOne.simpleMethod(textOne);\n+        mockOne.simpleMethod(textTwo);\n+        \n+        verify(mockOne, 2).simpleMethod(textOne);\n+        \n+        strictly = createStrictOrderVerifier(mockOne);\n+        strictly.verify(mockOne, 2).simpleMethod(textOne);\n+    } \n+    \n+    @Test\n+    public void shouldUseEqualsToVerifyMethodVarargs() {\n+        mockOne = mock(IMethods.class);\n+        \n+        String textOne = \"test\";\n+        String textTwo = new String(textOne);\n+        \n+        assertEquals(textOne, textTwo);\n+        assertNotSame(textOne, textTwo);\n+        \n+        mockOne.varargsObject(1, textOne, textOne);\n+        mockOne.varargsObject(1, textTwo, textTwo);\n+        \n+        verify(mockOne, 2).varargsObject(1, textOne, textOne);\n+        \n+        strictly = createStrictOrderVerifier(mockOne);\n+        strictly.verify(mockOne, 2).varargsObject(1, textOne, textOne);\n+    } \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/StrictVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class StrictVerificationTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyUsingAtLeastOnce() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n+        strictly.verify(mockOne, 0).oneArg(false);\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockTwo, 0).simpleMethod(22);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        strictly.verify(mockThree, 0).oneArg(false);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldFailWhenFirstMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test(expected=TooManyActualInvocationsError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n+        strictly.verify(mockOne, 0).simpleMethod(1);\n+    }\n+    \n+    @Test(expected=TooLittleActualInvocationsError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n+        strictly.verify(mockOne, 2).simpleMethod(1);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWanted() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 3).simpleMethod(2);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 0).simpleMethod(2);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, 0).simpleMethod(4);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, 2).simpleMethod(4);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }    \n+    \n+    /* ------------- */\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(100);\n+    }\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne).oneArg(true);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 2).simpleMethod(-999);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 2).oneArg(true);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(-666);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).oneArg(false);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }    \n+    \n+    /* -------------- */\n+    \n+    @Test(expected = VerificationError.class)\n+    public void shouldFailWhenLastMethodCalledFirst() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test(expected = TooLittleActualInvocationsError.class)\n+    public void shouldFailWhenSecondMethodCalledFirst() {\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMethodCalledToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoIsToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        try {\n+            strictly.verify(mockTwo, 1).simpleMethod(2);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockIsToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnVerifyNoMoreInteractions() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnVerifyZeroInteractions() {\n+        verifyZeroInteractions(mockOne);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySingleMockStrictly() {\n+        mockOne = mock(IMethods.class);\n+        strictly = createStrictOrderVerifier(mockOne);\n+        \n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(2);\n+        \n+        verify(mockOne).simpleMethod(2);\n+        verify(mockOne).simpleMethod(1);\n+        \n+        try {\n+            strictly.verify(mockOne).simpleMethod(2);\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n+}", "timestamp": 1197641293, "metainfo": ""}