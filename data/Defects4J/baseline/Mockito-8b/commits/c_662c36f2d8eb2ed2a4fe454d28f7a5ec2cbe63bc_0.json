{"sha": "662c36f2d8eb2ed2a4fe454d28f7a5ec2cbe63bc", "log": "In order to allow mocking/spying anonymous classes. I know it's rare but well... why not...  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401715", "commit": "\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n     };\n     \n     public boolean canImposterise(Class<?> type) {\n-        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers()) && !type.isAnonymousClass();\n+        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n     }\n     \n     public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n         }\n     }\n     \n-    private <T> Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\n+    private Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\n         if (mockedType == Object.class) {\n             mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n         }\n--- a/src/org/mockito/internal/util/MockName.java\n+++ b/src/org/mockito/internal/util/MockName.java\n \n     private static String toInstanceName(Class<?> clazz) {\n         String className = clazz.getSimpleName();\n+        if (className.length() == 0) {\n+            //it's an anonymous class, let's get name from the parent\n+            className = clazz.getSuperclass().getSimpleName();\n+        }\n         //lower case first letter\n         return className.substring(0, 1).toLowerCase() + className.substring(1);\n     }\n--- a/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n+++ b/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n         \n         assertThat(mock, is(instanceOf(SomeInterface.class)));\n     }\n+\n+    final class FinalClass {}\n+    class SomeClass {}\n+    interface SomeInterface {}\n+\n+    @Test\n+    public void shouldKnowIfCanImposterize() throws Exception {\n+        assertFalse(ClassImposterizer.INSTANCE.canImposterise(FinalClass.class));\n+        assertFalse(ClassImposterizer.INSTANCE.canImposterise(int.class));\n+\n+        assertTrue(ClassImposterizer.INSTANCE.canImposterise(SomeClass.class));\n+        assertTrue(ClassImposterizer.INSTANCE.canImposterise(SomeInterface.class));\n+    } \n     \n-    private interface SomeInterface {};\n+    private class ClassWithoutConstructor {}\n \n-    private class SomeClass {};\n-    private class ClassWithoutConstructor {};\n-    \n     private class ClassWithDodgyConstructor {\n         public ClassWithDodgyConstructor() {\n             throw new RuntimeException();\n         }\n-    };\n-    \n+    }\n+\n     private final class MethodInterceptorStub implements MethodInterceptor {\n \n         public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n--- /dev/null\n+++ b/test/org/mockito/internal/util/MockNameTest.java\n+package org.mockito.internal.util;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class MockNameTest extends TestBase {\n+\n+    @Test\n+    public void shouldProvideTheNameForClass() throws Exception {\n+        //when\n+        String name = new MockName(null, SomeClass.class).toString();\n+        //then\n+        assertEquals(\"someClass\", name);\n+    }\n+\n+    @Test\n+    public void shouldProvideTheNameForAnonymousClass() throws Exception {\n+        //given\n+        SomeInterface anonymousInstance = new SomeInterface() {};\n+        //when\n+        String name = new MockName(null, anonymousInstance.getClass()).toString();\n+        //then\n+        assertEquals(\"someInterface\", name);\n+    }\n+\n+    @Test\n+    public void shouldProvideTheGivenName() throws Exception {\n+        //when\n+        String name = new MockName(\"The Hulk\", SomeClass.class).toString();\n+        //then\n+        assertEquals(\"The Hulk\", name);\n+    }\n+\n+    private class SomeClass {}\n+    private class SomeInterface {}\n+}\n--- a/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n+++ b/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n         assertEquals(\"[foo]\" , spy.toString());\n     }\n     \n-    interface Foo {}\n+    interface Foo {\n+        String print();\n+    }\n     \n     @Test\n-    public void shouldDealWithAnonymousClasses() {\n-        try {\n-            spy(new Foo() {});\n-            fail();\n-        } catch (MockitoException e) {\n-            assertContains(\"cannot mock\", e.getMessage());\n-        }\n+    public void shouldAllowSpyingAnonymousClasses() {\n+        //when\n+        Foo spy = spy(new Foo() {\n+            public String print() {\n+                return \"foo\";\n+            }\n+        });\n+\n+        //then\n+        assertEquals(\"foo\", spy.print());\n     }\n     \n     @Test\n     public void shouldSayNiceMessageWhenSpyingOnPrivateClass() throws Exception {\n-        List real = Arrays.asList(new String[] {\"first\", \"second\"});\n+        List real = Arrays.asList(\"first\", \"second\");\n         try {\n             spy(real);\n             fail();", "timestamp": 1258052137, "metainfo": ""}