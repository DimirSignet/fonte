{"sha": "4c4cbac535daca69be0baba84be77b2dd0662d84", "log": "Issue 453 : Introduced a simple classloader builder for loading some classes in isolation also explained why we need different classpaths for this test  This last part could be abbreviate if we can load our test classes in memory.", "commit": "\n--- a/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n+++ b/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n \n package org.mockitousage.basicapi;\n \n-import static org.hamcrest.CoreMatchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockitoutil.ClassLoaders.isolatedClassLoader;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+// See issue 453\n public class MockingMultipleInterfacesTest extends TestBase {\n \n     class Foo {}\n     interface IBar {}\n     \n     @Test\n-    public void shouldAllowMultipleInterfaces() {\n+    public void should_allow_multiple_interfaces() {\n         //when\n         Foo mock = mock(Foo.class, withSettings().extraInterfaces(IFoo.class, IBar.class));\n         \n     }\n     \n     @Test\n-    public void shouldScreamWhenNullPassedInsteadOfAnInterface() {\n+    public void should_scream_when_null_passed_instead_of_an_interface() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces(IFoo.class, null));\n     }\n     \n     @Test\n-    public void shouldScreamWhenNoArgsPassed() {\n+    public void should_scream_when_no_args_passed() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces());\n     }\n     \n     @Test\n-    public void shouldScreamWhenNullPassedInsteadOfAnArray() {\n+    public void should_scream_when_null_passed_instead_of_an_array() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces((Class[]) null));\n     }\n     \n     @Test\n-    public void shouldScreamWhenNonInterfacePassed() {\n+    public void should_scream_when_non_interface_passed() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces(Foo.class));\n     }\n     \n     @Test\n-    public void shouldScreamWhenTheSameInterfacesPassed() {\n+    public void should_scream_when_the_same_interfaces_passed() {\n         try {\n             //when\n             mock(IMethods.class, withSettings().extraInterfaces(IMethods.class));\n             assertContains(\"You mocked following type: IMethods\", e.getMessage());\n         }\n     }\n-    \n-\t@Test\n-\tpublic void shouldMockClassWithInterfacesOfDifferentClassloader()\n-\t\t\tthrows ClassNotFoundException {\n-\t\t// from test-resources/multiple-interfaces/\n-\t\tClass<?> interface1 = new ClassLoader1().loadClass(\"test.TestedClass1\");\n-\t\tClass<?> interface2 = new Classloader2().loadClass(\"test.TestedClass2\");\n \n-\t\ttry {\n-\t\t\tObject mocked = Mockito.mock(interface1, Mockito.withSettings()\n-\t\t\t\t\t.extraInterfaces(interface2));\n-\t\t\tassertTrue(interface2.isInstance(mocked));\n-\t\t} catch (MockitoException e) {\n-\t\t\tfail(\"Cannot mock interfaces with different classloaders\");\n-\t\t}\n \n-\t}\n+    @Test\n+    public void should_mock_class_with_interfaces_of_different_class_loader_AND_different_classpaths() throws ClassNotFoundException {\n+        // Note : if classes are in the same classpath, SearchingClassLoader can find the class/classes and load them in the first matching classloader\n+        Class<?> interface1 = isolatedClassLoader()\n+                .withCodeSourceUrls(\"test-resources/multiple-classpaths/cp1\")\n+                .withPrivateCopyOf(\"test.TestedClass1\")\n+                .build()\n+                .loadClass(\"test.TestedClass1\");\n+        Class<?> interface2 = isolatedClassLoader()\n+                .withCodeSourceUrls(\"test-resources/multiple-classpaths/cp2\")\n+                .withPrivateCopyOf(\"test.TestedClass2\")\n+                .build()\n+                .loadClass(\"test.TestedClass2\");\n \n-\tfinal class ClassLoader1 extends ClassLoader {\n-\t\t@Override\n-\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n-\t\t\tif (name.equals(\"test.TestedClass1\")) {\n-\t\t\t\ttry {\n-\t\t\t\t\tFile file = new File(\n-\t\t\t\t\t\t\t\"test-resources/multiple-interfaces/TestedClass1.class\");\n-\t\t\t\t\tbyte[] bytes = new byte[(int) file.length()];\n-\t\t\t\t\tFileInputStream fileInputStream = new FileInputStream(file);\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tfileInputStream.read(bytes);\n-\t\t\t\t\t\treturn defineClass(\"test.TestedClass1\", bytes, 0,\n-\t\t\t\t\t\t\t\tbytes.length);\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\tfileInputStream.close();\n-\t\t\t\t\t}\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new ClassNotFoundException(\"Cannot create class: TestedClass1.class\", e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn super.loadClass(name);\n-\t\t}\n-\t}\n-\n-\tfinal class Classloader2 extends ClassLoader {\n-\t\t@Override\n-\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n-\t\t\tif (name.equals(\"test.TestedClass2\")) {\n-\t\t\t\ttry {\n-\t\t\t\t\tFile file = new File(\n-\t\t\t\t\t\t\t\"test-resources/multiple-interfaces/TestedClass2.class\");\n-\t\t\t\t\tbyte[] bytes = new byte[(int) file.length()];\n-\t\t\t\t\tFileInputStream fileInputStream = new FileInputStream(file);\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tfileInputStream.read(bytes);\n-\t\t\t\t\t\treturn defineClass(\"test.TestedClass2\", bytes, 0,\n-\t\t\t\t\t\t\t\tbytes.length);\n-\t\t\t\t\t} finally {\n-\t\t\t\t\t\tfileInputStream.close();\n-\t\t\t\t\t}\n-\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tthrow new ClassNotFoundException(\"Cannot create class: TestedClass1.class\", e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn super.loadClass(name);\n-\t\t}\n-\t}\n+        try {\n+            Object mocked = mock(interface1, withSettings().extraInterfaces(interface2));\n+            assertTrue(\"mock should be assignable from interface2 type\", interface2.isInstance(mocked));\n+        } catch (MockitoException e) {\n+            fail(\"Couldn't mock interfaces with different class loaders and different classpaths\");\n+        }\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitoutil/ClassLoaders.java\n+package org.mockitoutil;\n+\n+import static java.util.Arrays.asList;\n+import java.io.File;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class ClassLoaders {\n+    private final ArrayList<String> privateCopyPrefixes = new ArrayList<String>();\n+    private final ArrayList<URL> codeSourceUrls = new ArrayList<URL>();\n+\n+    public static ClassLoaders isolatedClassLoader() {\n+        return new ClassLoaders();\n+    }\n+\n+    public ClassLoaders withPrivateCopyOf(String... privatePrefixes) {\n+        privateCopyPrefixes.addAll(asList(privatePrefixes));\n+        return this;\n+    }\n+\n+    public ClassLoaders withCodeSourceUrls(String... urls) {\n+        codeSourceUrls.addAll(pathsToURLs(urls));\n+        return this;\n+    }\n+\n+    public ClassLoaders withCurrentCodeSourceUrls() {\n+        codeSourceUrls.add(obtainClassPathOF(ClassLoaders.class.getName()));\n+        return this;\n+    }\n+\n+\n+    private static URL obtainClassPathOF(String className) {\n+        String path = className.replace('.', '/') + \".class\";\n+        String url = ClassLoaders.class.getClassLoader().getResource(path).toExternalForm();\n+\n+        try {\n+            return new URL(url.substring(0, url.length() - path.length()));\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n+        }\n+    }\n+\n+    public ClassLoader build() {\n+        return new LocalIsolatedURLClassLoader(\n+                codeSourceUrls.toArray(new URL[codeSourceUrls.size()]),\n+                privateCopyPrefixes\n+        );\n+    }\n+\n+    static class LocalIsolatedURLClassLoader extends URLClassLoader {\n+        private final ArrayList<String> privateCopyPrefixes;\n+\n+        public LocalIsolatedURLClassLoader(URL[] urls, ArrayList<String> privateCopyPrefixes) {\n+            super(urls, null);\n+            this.privateCopyPrefixes = privateCopyPrefixes;\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if(classShouldBePrivate(name)) return super.findClass(name);\n+            throw new ClassNotFoundException(\"Can only load classes with prefix : \" + privateCopyPrefixes);\n+        }\n+\n+        private boolean classShouldBePrivate(String name) {\n+            for (String prefix : privateCopyPrefixes) {\n+                if (name.startsWith(prefix)) return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private List<URL> pathsToURLs(String... codeSourceUrls) {\n+        return pathsToURLs(Arrays.asList(codeSourceUrls));\n+    }\n+    private List<URL> pathsToURLs(List<String> codeSourceUrls) {\n+        ArrayList<URL> urls = new ArrayList<URL>(codeSourceUrls.size());\n+        for (String codeSourceUrl : codeSourceUrls) {\n+            URL url = pathToUrl(codeSourceUrl);\n+            urls.add(url);\n+        }\n+        return urls;\n+    }\n+\n+    private URL pathToUrl(String path) {\n+        try {\n+            return new File(path).getAbsoluteFile().toURI().toURL();\n+        } catch (MalformedURLException e) {\n+            throw new IllegalArgumentException(\"Path is malformed\", e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitoutil/ClassLoadersTest.java\n+package org.mockitoutil;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockitoutil.ClassLoaders.isolatedClassLoader;\n+import org.junit.Test;\n+\n+public class ClassLoadersTest {\n+\n+    @Test(expected = ClassNotFoundException.class)\n+    public void isolated_class_loader_cannot_load_classes_when_no_given_prefix() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader().build();\n+\n+        // when\n+        cl.loadClass(\"org.mockito.Mockito\");\n+\n+        // then raises CNFE\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_cannot_load_classes_If_no_code_source_path() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .build();\n+\n+        // when\n+        try {\n+            cl.loadClass(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+        } catch (ClassNotFoundException e) {\n+            // then\n+            assertThat(e.getMessage()).contains(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+        }\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_cannot_load_classes_that_require_other_non_declared_classes() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader()\n+                .withCurrentCodeSourceUrls()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .build();\n+\n+        // when\n+        try {\n+            cl.loadClass(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+        } catch (NoClassDefFoundError e) {\n+            // then\n+            assertThat(e.getMessage()).contains(\"org/mockitoutil/IsolatedClassLoaderBuilderTest$Interface1\");\n+        }\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_can_load_all_classes_if_all_prefixes_correct() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader()\n+                .withCurrentCodeSourceUrls()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$Interface1\")\n+                .build();\n+\n+        // when\n+        Class<?> aClass = cl.loadClass(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+\n+        // then\n+        assertThat(aClass).isNotNull();\n+        assertThat(aClass.getClassLoader()).isEqualTo(cl);\n+        assertThat(aClass.getInterfaces()[0].getClassLoader()).isEqualTo(cl);\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_has_no_parent() throws Exception {\n+        ClassLoader cl = isolatedClassLoader()\n+                .withCurrentCodeSourceUrls()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$Interface1\")\n+                .build();\n+\n+        assertThat(cl.getParent()).isNull();\n+    }\n+\n+\n+    static class ClassUsingInterface1 implements Interface1 { }\n+    interface Interface1 { }\n+}", "timestamp": 1386114511, "metainfo": ""}