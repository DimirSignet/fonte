{"sha": "824fbd728fe0379f9b7b7f5c17530632d7beab69", "log": "added refEq matcher based on reflectionEquals from apache commons lang  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40330", "commit": "\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n import org.mockito.internal.matchers.Null;\n import org.mockito.internal.matchers.Same;\n import org.mockito.internal.matchers.StartsWith;\n+import org.mockito.internal.matchers.apachecommons.ReflectionEquals;\n import org.mockito.internal.progress.LastArguments;\n import org.mockito.internal.progress.ReturnValues;\n \n     }\n \n     /**\n+     * Object argument that is reflection-equal to the given value.\n+     * <p>\n+     * This matcher can be used when equals() is not implemented on compared objects.\n+     * Matcher uses java reflection API to compare fields of wanted and actual object.\n+     * <p>\n+     * Works similarly to EqualsBuilder.reflectionEquals(this, other) from apache commons library.\n+     * <p>\n+     * See examples in javadoc for {@link Matchers}\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T refEq(T value) {\n+        return reportMatcher(new ReflectionEquals(value)).<T>returnNull();\n+    }\n+    \n+    /**\n      * Object argument that is the same as the given value.\n      * <p>\n      * See examples in javadoc for {@link Matchers}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+//Class comes from Apache Commons Lang, added some tiny changes  \n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.internal.matchers.apachecommons;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n+ *\n+ * <p> This class provides methods to build a good equals method for any\n+ * class. It follows rules laid out in\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\n+ * <code>floats</code>, and arrays can be tricky. Also, making sure that\n+ * <code>equals()</code> and <code>hashCode()</code> are consistent can be\n+ * difficult.</p>\n+ *\n+ * <p>Two Objects that compare as equals must generate the same hash code,\n+ * but two Objects with the same hash code do not have to be equal.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of equals.\n+ * Derived fields may be ignored. In particular, any field used in\n+ * generating a hash code must be used in the equals method, and vice\n+ * versa.</p>\n+ *\n+ * <p>Typical use for the code is as follows:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   if (obj == null) { return false; }\n+ *   if (obj == this) { return true; }\n+ *   if (obj.getClass() != getClass()) {\n+ *     return false;\n+ *   }\n+ *   MyClass rhs = (MyClass) obj;\n+ *   return new EqualsBuilder()\n+ *                 .appendSuper(super.equals(obj))\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .append(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </pre>\n+ *\n+ * <p> Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly. It is\n+ * also slower than testing explicitly.</p>\n+ *\n+ * <p> A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </pre>\n+ *\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Stephen Colebourne\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Arun Mammen Thomas\n+ * @since 1.0\n+ * @version $Id: EqualsBuilder.java 611543 2008-01-13 07:00:22Z bayard $\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class EqualsBuilder {\n+    \n+    /**\n+     * If the fields tested are equals.\n+     * The default value is <code>true</code>.\n+     */\n+    private boolean isEquals = true;\n+\n+    /**\n+     * <p>Constructor for EqualsBuilder.</p>\n+     *\n+     * <p>Starts off assuming that equals is <code>true</code>.</p>\n+     * @see Object#equals(Object)\n+     */\n+    public EqualsBuilder() {\n+        // do nothing for now.\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs) {\n+        return reflectionEquals(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n+        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,\n+            String[] excludeFields) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        // Find the leaf class since there may be transients in the leaf \n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars, \n+        // then a subclass can test equals to a superclass.\n+        Class lhsClass = lhs.getClass();\n+        Class rhsClass = rhs.getClass();\n+        Class testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            return false;\n+        }\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and \n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given Class.</p>\n+     * \n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class clazz,\n+        EqualsBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        List excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n+     *\n+     * @param superEquals  the result of calling <code>super.equals()</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     * @since 2.0\n+     */\n+    public EqualsBuilder appendSuper(boolean superEquals) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = superEquals;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Test if two <code>Object</code>s are equal using their\n+     * <code>equals</code> method.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        Class lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            if (lhs instanceof java.math.BigDecimal && rhs instanceof java.math.BigDecimal) {\n+                isEquals = (((java.math.BigDecimal) lhs).compareTo((java.math.BigDecimal) rhs) == 0);\n+            } else {\n+                // The simple case, not an array, just test the element\n+                isEquals = lhs.equals(rhs);\n+            }\n+        } else if (lhs.getClass() != rhs.getClass()) {\n+            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n+            this.setEquals(false);\n+        \n+        // 'Switch' on type of array, to dispatch to the correct handler\n+        // This handles multi dimensional arrays of the same depth\n+        } else if (lhs instanceof long[]) {\n+            append((long[]) lhs, (long[]) rhs);\n+        } else if (lhs instanceof int[]) {\n+            append((int[]) lhs, (int[]) rhs);\n+        } else if (lhs instanceof short[]) {\n+            append((short[]) lhs, (short[]) rhs);\n+        } else if (lhs instanceof char[]) {\n+            append((char[]) lhs, (char[]) rhs);\n+        } else if (lhs instanceof byte[]) {\n+            append((byte[]) lhs, (byte[]) rhs);\n+        } else if (lhs instanceof double[]) {\n+            append((double[]) lhs, (double[]) rhs);\n+        } else if (lhs instanceof float[]) {\n+            append((float[]) lhs, (float[]) rhs);\n+        } else if (lhs instanceof boolean[]) {\n+            append((boolean[]) lhs, (boolean[]) rhs);\n+        } else {\n+            // Not an array of primitives\n+            append((Object[]) lhs, (Object[]) rhs);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Test if two <code>long</code> s are equal.\n+     * </p>\n+     * \n+     * @param lhs\n+     *                  the left hand <code>long</code>\n+     * @param rhs\n+     *                  the right hand <code>long</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>int</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>int</code>\n+     * @param rhs  the right hand <code>int</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>short</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>short</code>\n+     * @param rhs  the right hand <code>short</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>char</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>char</code>\n+     * @param rhs  the right hand <code>char</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>byte</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>byte</code>\n+     * @param rhs  the right hand <code>byte</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>double</code>s are equal by testing that the\n+     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>double</code>\n+     * @param rhs  the right hand <code>double</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>float</code>s are equal byt testing that the\n+     * pattern of bits returned by doubleToLong are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>float</code>\n+     * @param rhs  the right hand <code>float</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>booleans</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean</code>\n+     * @param rhs  the right hand <code>boolean</code>\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n+     *\n+     * <p>This also will be called for the top level of\n+     * multi-dimensional, ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  the left hand <code>Object[]</code>\n+     * @param rhs  the right hand <code>Object[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>long</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(long, long)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>long[]</code>\n+     * @param rhs  the right hand <code>long[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>int</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(int, int)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>int[]</code>\n+     * @param rhs  the right hand <code>int[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>short</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(short, short)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>short[]</code>\n+     * @param rhs  the right hand <code>short[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>char</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(char, char)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>char[]</code>\n+     * @param rhs  the right hand <code>char[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>byte</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(byte, byte)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>byte[]</code>\n+     * @param rhs  the right hand <code>byte[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>double</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(double, double)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>double[]</code>\n+     * @param rhs  the right hand <code>double[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>float</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(float, float)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>float[]</code>\n+     * @param rhs  the right hand <code>float[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean[]</code>\n+     * @param rhs  the right hand <code>boolean[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return this.isEquals;\n+    }\n+\n+    /**\n+     * Sets the <code>isEquals</code> value.\n+     * \n+     * @param isEquals The value to set.\n+     * @since 2.1\n+     */\n+    protected void setEquals(boolean isEquals) {\n+        this.isEquals = isEquals;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.matchers.apachecommons;\n+\n+import org.mockito.internal.matchers.ArgumentMatcher;\n+\n+\n+public class ReflectionEquals implements ArgumentMatcher<Object>{\n+    private final Object wanted;\n+\n+    public ReflectionEquals(Object wanted) {\n+        this.wanted = wanted;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return EqualsBuilder.reflectionEquals(wanted, actual);\n+    }\n+\n+    public void appendTo(StringBuilder buffer) {\n+        buffer.append(\"refEq(\" + wanted + \")\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/matchers/apachecommons/EqualsBuilderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+//Class comes from Apache Commons Lang, added some tiny changes  \n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.internal.matchers.apachecommons;\n+\n+import static org.junit.Assert.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+\n+/**\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Maarten Coene\n+ * @version $Id: EqualsBuilderTest.java 611543 2008-01-13 07:00:22Z bayard $\n+ */\n+public class EqualsBuilderTest extends RequiresValidState {\n+    \n+    @Test\n+    public void testname() throws Exception {\n+        \n+    }\n+\n+    static class TestObject {\n+        private int a;\n+        public TestObject() {\n+        }\n+        public TestObject(int a) {\n+            this.a = a;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == null) { return false; }\n+            if (o == this) { return true; }\n+            if (o.getClass() != getClass()) {\n+                return false;\n+            }\n+\n+            TestObject rhs = (TestObject) o;\n+            return (a == rhs.a);\n+        }\n+        public int hashCode() {\n+            return super.hashCode();\n+        }\n+\n+        public void setA(int a) {\n+            this.a = a;\n+        }\n+\n+        public int getA() {\n+            return a;\n+        }\n+    }\n+\n+    static class TestSubObject extends TestObject {\n+        private int b;\n+        public TestSubObject() {\n+            super(0);\n+        }\n+        public TestSubObject(int a, int b) {\n+            super(a);\n+            this.b = b;\n+        }\n+        public boolean equals(Object o) {\n+            if (o == null) { return false; }\n+            if (o == this) { return true; }\n+            if (o.getClass() != getClass()) {\n+                return false;\n+            }\n+\n+            TestSubObject rhs = (TestSubObject) o;\n+            return super.equals(o) && (b == rhs.b);\n+        }\n+        public int hashCode() {\n+            return 1;\n+        }\n+\n+        public void setB(int b) {\n+            this.b = b;\n+        }\n+\n+        public int getB() {\n+            return b;\n+        }\n+    }\n+    \n+    static class TestEmptySubObject extends TestObject {\n+        public TestEmptySubObject(int a) {\n+            super(a);\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unused\")\n+    static class TestTSubObject extends TestObject {\n+        private transient int t;\n+        public TestTSubObject(int a, int t) {\n+            super(a);\n+            this.t = t;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    static class TestTTSubObject extends TestTSubObject {\n+        private transient int tt;\n+        public TestTTSubObject(int a, int t, int tt) {\n+            super(a, t);\n+            this.tt = tt;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    static class TestTTLeafObject extends TestTTSubObject {\n+        private int leafValue;\n+        public TestTTLeafObject(int a, int t, int tt, int leafValue) {\n+            super(a, t, tt);\n+            this.leafValue = leafValue;\n+        }\n+    }\n+\n+    static class TestTSubObject2 extends TestObject {\n+        private transient int t;\n+        public TestTSubObject2(int a, int t) {\n+            super(a);\n+        }\n+        public int getT() {\n+            return t;\n+        }\n+        public void setT(int t) {\n+            this.t = t;\n+        }\n+    }\n+\n+    @Test public void testReflectionEquals() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(EqualsBuilder.reflectionEquals(o1, o1));\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));\n+        o2.setA(4);\n+        assertTrue(EqualsBuilder.reflectionEquals(o1, o2));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, this));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(o1, null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, o2));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));\n+    }\n+    \n+    @Test public void testReflectionHierarchyEquals() {\n+        testReflectionHierarchyEquals(false);\n+        testReflectionHierarchyEquals(true);\n+        // Transients\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));\n+    }\n+\n+  private void testReflectionHierarchyEquals(boolean testTransients) {\n+        TestObject to1 = new TestObject(4);\n+        TestObject to1Bis = new TestObject(4);\n+        TestObject to1Ter = new TestObject(4);\n+        TestObject to2 = new TestObject(5);\n+        TestEmptySubObject teso = new TestEmptySubObject(4);\n+        TestTSubObject ttso = new TestTSubObject(4, 1);\n+        TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);\n+        TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);\n+        TestSubObject tso1 = new TestSubObject(1, 4);\n+        TestSubObject tso1bis = new TestSubObject(1, 4);\n+        TestSubObject tso1ter = new TestSubObject(1, 4);\n+        TestSubObject tso2 = new TestSubObject(2, 5);\n+\n+        testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);\n+        testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);\n+\n+        // More sanity checks:\n+\n+        // same values\n+        assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));\n+        // same super values, diff sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));\n+        // diff super values, same sub values\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));\n+\n+        // mix super and sub types: equals\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert\n+\n+        assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert\n+        assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert\n+\n+        // mix super and sub types: NOT equals\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));\n+\n+        assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));\n+        assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));\n+    }\n+\n+    /**\n+     * Equivalence relationship tests inspired by \"Effective Java\":\n+     * <ul>\n+     * <li>reflection</li>\n+     * <li>symmetry</li>\n+     * <li>transitive</li>\n+     * <li>consistency</li>\n+     * <li>non-null reference</li>\n+     * </ul>\n+     * @param to a TestObject\n+     * @param toBis a TestObject, equal to to and toTer\n+     * @param toTer Left hand side, equal to to and toBis\n+     * @param to2 a different TestObject\n+     * @param oToChange a TestObject that will be changed\n+     */\n+    private void testReflectionEqualsEquivalenceRelationship(\n+        TestObject to,\n+        TestObject toBis,\n+        TestObject toTer,\n+        TestObject to2,\n+        TestObject oToChange,\n+        boolean testTransients) {\n+\n+        // reflection test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));\n+\n+        // symmetry test\n+        assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));\n+\n+        // transitive test\n+        assertTrue(\n+            EqualsBuilder.reflectionEquals(to, toBis, testTransients)\n+                && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)\n+                && EqualsBuilder.reflectionEquals(to, toTer, testTransients));\n+\n+        // consistency test\n+        oToChange.setA(to.getA());\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());\n+        }\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        oToChange.setA(to.getA() + 1);\n+        if (oToChange instanceof TestSubObject) {\n+            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);\n+        }\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));\n+\n+        // non-null reference test\n+        assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients));\n+        assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients));\n+        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));\n+    }\n+\n+    @Test public void testSuper() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertEquals(true, new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());\n+        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testObject() {\n+        TestObject o1 = new TestObject(4);\n+        TestObject o2 = new TestObject(5);\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        o2.setA(4);\n+        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());\n+\n+        assertTrue(!new EqualsBuilder().append(o1, this).isEquals());\n+        \n+        assertTrue(!new EqualsBuilder().append(o1, null).isEquals());\n+        assertTrue(!new EqualsBuilder().append(null, o2).isEquals());\n+        assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());\n+    }\n+\n+    @Test public void testLong() {\n+        long o1 = 1L;\n+        long o2 = 2L;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testInt() {\n+        int o1 = 1;\n+        int o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testShort() {\n+        short o1 = 1;\n+        short o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testChar() {\n+        char o1 = 1;\n+        char o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testByte() {\n+        byte o1 = 1;\n+        byte o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testDouble() {\n+        double o1 = 1;\n+        double o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());\n+    }\n+\n+    @Test public void testFloat() {\n+        float o1 = 1;\n+        float o2 = 2;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());\n+        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());\n+    }\n+\n+    // https://issues.apache.org/jira/browse/LANG-393\n+    @Test public void testBigDecimal() {\n+        BigDecimal o1 = new BigDecimal(\"2.0\");\n+        BigDecimal o2 = new BigDecimal(\"2.00\");\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testAccessors() {\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        assertTrue(equalsBuilder.isEquals());\n+        equalsBuilder.setEquals(true);\n+        assertTrue(equalsBuilder.isEquals());\n+        equalsBuilder.setEquals(false);\n+        assertFalse(equalsBuilder.isEquals());\n+    }\n+    \n+    @Test public void testBoolean() {\n+        boolean o1 = true;\n+        boolean o2 = false;\n+        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());\n+        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());\n+    }\n+\n+    @Test public void testObjectArray() {\n+        TestObject[] obj1 = new TestObject[3];\n+        obj1[0] = new TestObject(4);\n+        obj1[1] = new TestObject(5);\n+        obj1[2] = null;\n+        TestObject[] obj2 = new TestObject[3];\n+        obj2[0] = new TestObject(4);\n+        obj2[1] = new TestObject(5);\n+        obj2[2] = null;\n+        \n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj2, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1].setA(6);\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1].setA(5);\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[2] = obj1[1];\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[2] = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+                       \n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testLongArray() {\n+        long[] obj1 = new long[2];\n+        obj1[0] = 5L;\n+        obj1[1] = 6L;\n+        long[] obj2 = new long[2];\n+        obj2[0] = 5L;\n+        obj2[1] = 6L;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testIntArray() {\n+        int[] obj1 = new int[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        int[] obj2 = new int[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testShortArray() {\n+        short[] obj1 = new short[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        short[] obj2 = new short[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testCharArray() {\n+        char[] obj1 = new char[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        char[] obj2 = new char[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testByteArray() {\n+        byte[] obj1 = new byte[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        byte[] obj2 = new byte[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testDoubleArray() {\n+        double[] obj1 = new double[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        double[] obj2 = new double[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testFloatArray() {\n+        float[] obj1 = new float[2];\n+        obj1[0] = 5;\n+        obj1[1] = 6;\n+        float[] obj2 = new float[2];\n+        obj2[0] = 5;\n+        obj2[1] = 6;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testBooleanArray() {\n+        boolean[] obj1 = new boolean[2];\n+        obj1[0] = true;\n+        obj1[1] = false;\n+        boolean[] obj2 = new boolean[2];\n+        obj2[0] = true;\n+        obj2[1] = false;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1[1] = true;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+\n+        obj2 = null;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+        obj1 = null;\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testMultiLongArray() {\n+        long[][] array1 = new long[2][2];\n+        long[][] array2 = new long[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMultiIntArray() {\n+        int[][] array1 = new int[2][2];\n+        int[][] array2 = new int[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMultiShortArray() {\n+        short[][] array1 = new short[2][2];\n+        short[][] array2 = new short[2][2];\n+        for (short i = 0; i < array1.length; ++i) {\n+            for (short j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMultiCharArray() {\n+        char[][] array1 = new char[2][2];\n+        char[][] array2 = new char[2][2];\n+        for (char i = 0; i < array1.length; ++i) {\n+            for (char j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMultiByteArray() {\n+        byte[][] array1 = new byte[2][2];\n+        byte[][] array2 = new byte[2][2];\n+        for (byte i = 0; i < array1.length; ++i) {\n+            for (byte j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = i;\n+                array2[i][j] = i;\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+    @Test public void testMultiFloatArray() {\n+        float[][] array1 = new float[2][2];\n+        float[][] array2 = new float[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMultiDoubleArray() {\n+        double[][] array1 = new double[2][2];\n+        double[][] array2 = new double[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMultiBooleanArray() {\n+        boolean[][] array1 = new boolean[2][2];\n+        boolean[][] array2 = new boolean[2][2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            for (int j = 0; j < array1[0].length; j++) {\n+                array1[i][j] = (i == 1) || (j == 1);\n+                array2[i][j] = (i == 1) || (j == 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = false;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+        \n+        // compare 1 dim to 2.\n+        boolean[] array3 = new boolean[]{true, true};\n+        assertFalse(new EqualsBuilder().append(array1, array3).isEquals());\n+        assertFalse(new EqualsBuilder().append(array3, array1).isEquals());\n+        assertFalse(new EqualsBuilder().append(array2, array3).isEquals());\n+        assertFalse(new EqualsBuilder().append(array3, array2).isEquals());\n+    }\n+\n+    @Test public void testRaggedArray() {\n+        long[][] array1 = new long[2][];\n+        long[][] array2 = new long[2][];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            for (int j = 0; j < array1[i].length; ++j) {\n+                array1[i][j] = (i + 1) * (j + 1);\n+                array2[i][j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        array1[1][1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testMixedArray() {\n+        Object[] array1 = new Object[2];\n+        Object[] array2 = new Object[2];\n+        for (int i = 0; i < array1.length; ++i) {\n+            array1[i] = new long[2];\n+            array2[i] = new long[2];\n+            for (int j = 0; j < 2; ++j) {\n+                ((long[]) array1[i])[j] = (i + 1) * (j + 1);\n+                ((long[]) array2[i])[j] = (i + 1) * (j + 1);\n+            }\n+        }\n+        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());\n+        ((long[]) array1[1])[1] = 0;\n+        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());\n+    }\n+\n+    @Test public void testObjectArrayHiddenByObject() {\n+        TestObject[] array1 = new TestObject[2];\n+        array1[0] = new TestObject(4);\n+        array1[1] = new TestObject(5);\n+        TestObject[] array2 = new TestObject[2];\n+        array2[0] = new TestObject(4);\n+        array2[1] = new TestObject(5);\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1].setA(6);\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testLongArrayHiddenByObject() {\n+        long[] array1 = new long[2];\n+        array1[0] = 5L;\n+        array1[1] = 6L;\n+        long[] array2 = new long[2];\n+        array2[0] = 5L;\n+        array2[1] = 6L;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testIntArrayHiddenByObject() {\n+        int[] array1 = new int[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        int[] array2 = new int[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testShortArrayHiddenByObject() {\n+        short[] array1 = new short[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        short[] array2 = new short[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testCharArrayHiddenByObject() {\n+        char[] array1 = new char[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        char[] array2 = new char[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testByteArrayHiddenByObject() {\n+        byte[] array1 = new byte[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        byte[] array2 = new byte[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testDoubleArrayHiddenByObject() {\n+        double[] array1 = new double[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        double[] array2 = new double[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testFloatArrayHiddenByObject() {\n+        float[] array1 = new float[2];\n+        array1[0] = 5;\n+        array1[1] = 6;\n+        float[] array2 = new float[2];\n+        array2[0] = 5;\n+        array2[1] = 6;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = 7;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+\n+    @Test public void testBooleanArrayHiddenByObject() {\n+        boolean[] array1 = new boolean[2];\n+        array1[0] = true;\n+        array1[1] = false;\n+        boolean[] array2 = new boolean[2];\n+        array2[0] = true;\n+        array2[1] = false;\n+        Object obj1 = array1;\n+        Object obj2 = array2;\n+        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());\n+        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());\n+        array1[1] = true;\n+        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());\n+    }\n+    \n+    public static class TestACanEqualB {\n+        private int a;\n+\n+        public TestACanEqualB(int a) {\n+            this.a = a;\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (o instanceof TestACanEqualB) {\n+                return this.a == ((TestACanEqualB) o).getA();\n+            }\n+            if (o instanceof TestBCanEqualA) {\n+                return this.a == ((TestBCanEqualA) o).getB();\n+            }\n+            return false;\n+        }\n+        public int hashCode() {\n+            return 1;\n+        }\n+\n+        public int getA() {\n+            return this.a;\n+        }\n+    }\n+\n+    public static class TestBCanEqualA {\n+        private int b;\n+\n+        public TestBCanEqualA(int b) {\n+            this.b = b;\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (o instanceof TestACanEqualB) {\n+                return this.b == ((TestACanEqualB) o).getA();\n+            }\n+            if (o instanceof TestBCanEqualA) {\n+                return this.b == ((TestBCanEqualA) o).getB();\n+            }\n+            return false;\n+        }\n+        public int hashCode() {\n+            return 1;\n+        }        \n+\n+        public int getB() {\n+            return this.b;\n+        }\n+    }\n+    \n+    /**\n+     * Tests two instances of classes that can be equal and that are not \"related\". The two classes are not subclasses\n+     * of each other and do not share a parent aside from Object.\n+     * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069\n+     */\n+    @Test public void testUnrelatedClasses() {\n+        Object[] x = new Object[]{new TestACanEqualB(1)};\n+        Object[] y = new Object[]{new TestBCanEqualA(1)};\n+\n+        // sanity checks:\n+        assertTrue(Arrays.equals(x, x));\n+        assertTrue(Arrays.equals(y, y));\n+        assertTrue(Arrays.equals(x, y));\n+        assertTrue(Arrays.equals(y, x));\n+        // real tests:\n+        assertTrue(x[0].equals(x[0]));\n+        assertTrue(y[0].equals(y[0]));\n+        assertTrue(x[0].equals(y[0]));\n+        assertTrue(y[0].equals(x[0]));\n+        assertTrue(new EqualsBuilder().append(x, x).isEquals());\n+        assertTrue(new EqualsBuilder().append(y, y).isEquals());\n+        assertTrue(new EqualsBuilder().append(x, y).isEquals());\n+        assertTrue(new EqualsBuilder().append(y, x).isEquals());\n+    }\n+    \n+    /**\n+     * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n+     */\n+    @Test public void testNpeForNullElement() {\n+        Object[] x1 = new Object[] { new Integer(1), null, new Integer(3) };\n+        Object[] x2 = new Object[] { new Integer(1), new Integer(2), new Integer(3) };\n+\n+        // causes an NPE in 2.0 according to:\n+        // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067\n+        new EqualsBuilder().append(x1, x2);\n+    }\n+\n+    @Test public void testReflectionEqualsExcludeFields() throws Exception {\n+        TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);\n+        TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);\n+\n+        // not equal when including all fields\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2));\n+\n+        // doesn't barf on null, empty array, or non-existent field, but still tests as not equal\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, (String[]) null));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"xxx\"}));\n+\n+        // not equal if only one of the differing fields excluded\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\"}));\n+        assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"three\"}));\n+\n+        // equal if both differing fields excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"two\", \"three\"}));\n+\n+        // still equal as long as both differing fields are among excluded\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\"}));\n+        assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {\"one\", \"two\", \"three\", \"xxx\"}));\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    static class TestObjectWithMultipleFields {\n+        private TestObject one;\n+        private TestObject two;\n+        private TestObject three;\n+\n+        public TestObjectWithMultipleFields(int one, int two, int three) {\n+            this.one = new TestObject(one);\n+            this.two = new TestObject(two);\n+            this.three = new TestObject(three);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/ReflectionMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+\n+@SuppressWarnings(\"all\")\n+public class ReflectionMatchersTest extends RequiresValidState {\n+\n+    class Parent {\n+        private int parentField;\n+        protected String protectedParentField;\n+        public Parent(int parentField, String protectedParentField) {\n+            this.parentField = parentField;\n+            this.protectedParentField = protectedParentField;\n+        }\n+    }\n+    \n+    class Child extends Parent {\n+        private int childFieldOne;\n+        private Object childFieldTwo;\n+        public Child(int parentField, String protectedParentField, int childFieldOne, Object childFieldTwo) {\n+            super(parentField, protectedParentField);\n+            this.childFieldOne = childFieldOne;\n+            this.childFieldTwo = childFieldTwo;\n+        } \n+    }\n+    \n+    interface MockMe {\n+        void run(Child child);\n+    }\n+    \n+    MockMe mock;\n+    \n+    @Before\n+    public void setup() {\n+        mock = mock(MockMe.class);\n+        \n+        Child actual = new Child(1, \"foo\", 2, \"bar\");\n+        mock.run(actual);\n+    }\n+    \n+    @Test\n+    public void shouldMatchWhenFieldValuesEqual() throws Exception {\n+        Child wanted = new Child(1, \"foo\", 2, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=InvocationDiffersFromActual.class)\n+    public void shouldNotMatchWhenFieldValuesDiffer() throws Exception {\n+        Child wanted = new Child(1, \"foo\", 2, \"bar XXX\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=InvocationDiffersFromActual.class)\n+    public void shouldNotMatchAgain() throws Exception {\n+        Child wanted = new Child(1, \"foo\", 999, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=InvocationDiffersFromActual.class)\n+    public void shouldNotMatchYetAgain() throws Exception {\n+        Child wanted = new Child(1, \"XXXXX\", 2, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=InvocationDiffersFromActual.class)\n+    public void shouldNotMatch() throws Exception {\n+        Child wanted = new Child(234234, \"foo\", 2, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+}", "timestamp": 1201477444, "metainfo": ""}