{"sha": "5f141c7133f8cc31b4b9f4a2cd394bb4aeced76c", "log": "Added tests for invocations that result in exceptions.  --HG-- branch : issue148 extra : transplant_source : %C6%B1%C3%B3.%1E/%C3%AB%A6%28%92c%EA%2C%C1%EAP%B5Q", "commit": "\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n import org.mockito.stubbing.Answer;\n import org.mockito.verification.VerificationMode;\n import org.mockitoutil.TestBase;\n-@SuppressWarnings({\"unchecked\",\"serial\"})\n+\n+@SuppressWarnings({ \"unchecked\", \"serial\" })\n public class MockHandlerTest extends TestBase {\n-    \n+\n+\tprivate static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();\n+\tprivate static final RuntimeException SOME_EXCEPTION = new RuntimeException();\n \tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n \tprivate static final String SOME_LOCATION = \"some location\";\n \t@SuppressWarnings(\"rawtypes\")\n \tprivate static final Answer SOME_ANSWER = mock(Answer.class);\n \tprivate static final StubbedInvocationMatcher SOME_INVOCATION_MATCHER = mock(StubbedInvocationMatcher.class);\n \tprivate static final Invocation SOME_INVOCATION = mock(Invocation.class);\n-\t@Mock private InvocationListener listener1;\n-\t@Mock private InvocationListener listener2;\n-\n-\t@Test\n-    public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n-        //given\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n-        @SuppressWarnings(\"rawtypes\")\n+\t@Mock\n+\tprivate InvocationListener listener1;\n+\t@Mock\n+\tprivate InvocationListener listener2;\n+\n+\t@Test\n+\tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+\t\t// given\n+\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\t@SuppressWarnings(\"rawtypes\")\n \t\tMockHandler<?> handler = new MockHandler();\n-        handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n-        handler.matchersBinder = new MatchersBinder() {\n-            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n-                throw new InvalidUseOfMatchersException();\n-            }\n-        };\n-        \n-        try {\n-            //when\n-            handler.handle(invocation);\n-            \n-            //then\n-            fail();\n-        } catch (InvalidUseOfMatchersException e) {}\n-        \n-        assertNull(handler.mockingProgress.pullVerificationMode());\n-    }\n-\t\n-\t// TODO test exception\n-\t// TODO listener are not notified of error \n-    \n-    @Test\n-    public void shouldNotifyInvocationHandlerDuringStubVoid() throws Throwable {\n-    \t// given\n-    \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-    \tstubWithInvocationDuringStubVoid(handler);\n-    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-    \t\n-    \t\n-\t\thandler.handle(invocation);\n-    \t\n-    \t// then\n-    \tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-    \tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-    }\n+\t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+\t\thandler.matchersBinder = new MatchersBinder() {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\t\tthrow new InvalidUseOfMatchersException();\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\thandler.handle(invocation);\n+\n+\t\t\t// then\n+\t\t\tfail();\n+\t\t} catch (InvalidUseOfMatchersException e) {\n+\t\t}\n+\n+\t\tassertNull(handler.mockingProgress.pullVerificationMode());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotifyInvocationHandlerDuringStubVoid() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubWithInvocationDuringStubVoid(handler);\n+\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+\n+\t\thandler.handle(invocation);\n+\n+\t\t// then\n+\t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t}\n \n \tprivate Invocation createInvocationWithStubbingLocation(String stubbingLocation) {\n \t\tInvocation invocation = mock(Invocation.class);\n-\t\t\n+\n \t\tStubInfo stubInfo = mock(StubInfo.class);\n \t\tgiven(invocation.stubInfo()).willReturn(stubInfo);\n-\t\t\n+\n \t\tgiven(stubInfo.stubbedAt()).willReturn(stubbingLocation);\n-\t\t\n+\n \t\treturn invocation;\n \t}\n \n \t@Test\n-    public void shouldNotifyInvocationHandlerDuringVerification() throws Throwable {\n-    \t// given\n-    \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-    \tstubProgressWithVerification(handler);\n-    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-    \t\n-    \t// when\n-\t\thandler.handle(invocation);\n-    \t\n-    \t// then\n-    \tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-    \tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-    }\n-    \n-\t@Test\n-    public void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithGivenReturnValue() throws Throwable {\n-    \t// given\n-    \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-    \tstubOrdinaryInvocationWithReturnValue(handler, SOME_RETURN_VALUE);\n-    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-    \t\n-    \t// when\n-\t\thandler.handle(invocation);\n-    \t\n-    \t// then\n-    \tverify(listener1).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n-    \tverify(listener2).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n-    }\n-\n-\t@Test\n-\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithDefaultReturnValue() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubOrdinaryInvocationWithDefaultReturnValue(handler);\n-    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-\t\t\n-\t\t// when\n-\t\thandler.handle(invocation);\n-\t\t\n+\tpublic void shouldNotifyInvocationHandlerDuringVerification() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubProgressWithVerification(handler);\n+\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\n \t\t// then\n \t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n \t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n \t}\n+\n+\t@Test\n+\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithGivenReturnValue() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubOrdinaryInvocationWithReturnValue(handler, SOME_RETURN_VALUE);\n+\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\n+\t\t// then\n+\t\tverify(listener1).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n+\t\tverify(listener2).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationResultingInException() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubOrdinaryInvocationWithThrowable(handler, SOME_EXCEPTION);\n+\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+\n+\t\t// when\n+\t\ttry {\n+\t\t\thandler.handle(invocation);\n+\t\t\tfail(\"Exception was not rethrown.\");\n+\t\t} catch (RuntimeException e) {\n+\t\t\t// then\n+\t\t\tverify(listener1).invokingWithException(invocation, SOME_EXCEPTION, SOME_LOCATION);\n+\t\t\tverify(listener2).invokingWithException(invocation, SOME_EXCEPTION, SOME_LOCATION);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotNotifyInvocationHandlerDuringOrdinaryInvocationResultingInError() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubOrdinaryInvocationWithThrowable(handler, SOME_ERROR);\n+\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+\t\t\n+\t\t// when\n+\t\ttry {\n+\t\t\thandler.handle(invocation);\n+\t\t\tfail(\"Error was not rethrown.\");\n+\t\t} catch (Error e) {\n+\t\t\t// then\n+\t\t\tverifyZeroInteractions(listener1, listener2);\n+\t\t}\n+\t}\n \t\n-\t@Test(expected=MockitoException.class)\n-    public void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n-    \t// given\n+\t@Test\n+\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithDefaultReturnValue() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubOrdinaryInvocationWithDefaultReturnValue(handler);\n+\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\n+\t\t// then\n+\t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t}\n+\n+\t@Test(expected = MockitoException.class)\n+\tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n+\t\t// given\n \t\tInvocationListener throwingListener = mock(InvocationListener.class);\n-\t\tdoThrow(new RuntimeException()).when(throwingListener).invokingWithReturnValue(any(Invocation.class), any(String.class), any(String.class));\n-    \tMockHandler<?> handler = createCorrectlyStubbedHandler(throwingListener);\n-    \t\n-    \t// when\n+\t\tdoThrow(SOME_EXCEPTION).when(throwingListener).invokingWithReturnValue(any(Invocation.class),\n+\t\t\t\tany(String.class), any(String.class));\n+\t\tMockHandler<?> handler = createCorrectlyStubbedHandler(throwingListener);\n+\n+\t\t// when\n \t\thandler.handle(SOME_INVOCATION);\n-    }\n-\n-\tprivate MockHandler<?> createCorrectlyStubbedHandler(\n-\t\t\tInvocationListener throwingListener) {\n+\t}\n+\n+\tprivate MockHandler<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n \t\tMockHandler<?> handler = createHandlerWithListeners(throwingListener);\n-    \tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+\t\tstubOrdinaryInvocationWithGivenReturnValue(handler);\n \t\treturn handler;\n \t}\n \n \tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandler<?> handler) {\n \t\tstubOrdinaryInvocationWithInvocationMatcher(handler, SOME_INVOCATION_MATCHER);\n \t}\n-\t\n+\n \tprivate void stubOrdinaryInvocationWithReturnValue(MockHandler<?> handler, Object returnValue) throws Throwable {\n \t\tStubbedInvocationMatcher matcher = mock(StubbedInvocationMatcher.class);\n \t\tgiven(matcher.answer(any(InvocationOnMock.class))).willReturn(returnValue);\n \t\tstubOrdinaryInvocationWithInvocationMatcher(handler, matcher);\n \t}\n-\t\n+\n+\tprivate void stubOrdinaryInvocationWithThrowable(MockHandler<?> handler, Throwable throwable) throws Throwable {\n+\t\tStubbedInvocationMatcher matcher = mock(StubbedInvocationMatcher.class);\n+\t\tgiven(matcher.answer(any(InvocationOnMock.class))).willThrow(throwable);\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, matcher);\n+\t}\n+\n \tprivate void stubOrdinaryInvocationWithDefaultReturnValue(MockHandler<?> handler) {\n \t\tgiven(handler.getMockSettings().getDefaultAnswer()).willReturn(SOME_ANSWER);\n \t\tstubOrdinaryInvocationWithInvocationMatcher(handler, null);\n \t}\n \n-\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandler<?> handler,\n-\t\t\tStubbedInvocationMatcher value) {\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandler<?> handler, StubbedInvocationMatcher value) {\n \t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n \t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(Invocation.class))).willReturn(value);\n \t}\n-\t\n-    private void stubProgressWithVerification(MockHandler<?> handler) {\n-    \thandler.mockingProgress = mock(MockingProgress.class);\n-\n-    \t// Needs to be unequal to null.\n-    \tVerificationMode mode = mock(MockAwareVerificationMode.class);\n-    \tgiven(handler.mockingProgress.pullVerificationMode()).willReturn(mode);\n-\t}\n-\n-    @SuppressWarnings(\"rawtypes\") \n+\n+\tprivate void stubProgressWithVerification(MockHandler<?> handler) {\n+\t\thandler.mockingProgress = mock(MockingProgress.class);\n+\n+\t\t// Needs to be unequal to null.\n+\t\tVerificationMode mode = mock(MockAwareVerificationMode.class);\n+\t\tgiven(handler.mockingProgress.pullVerificationMode()).willReturn(mode);\n+\t}\n+\n+\t@SuppressWarnings(\"rawtypes\")\n \tprivate void stubWithInvocationDuringStubVoid(MockHandler handler) {\n \t\tstubWithPreviouslySetVoidAnswer(handler);\n-    \tstubHandlerStateWithPreviousStubVoidInvocation(handler);\n+\t\tstubHandlerStateWithPreviousStubVoidInvocation(handler);\n \t}\n \n \tprivate void stubHandlerStateWithPreviousStubVoidInvocation(MockHandler<?> handler) {\n \t\tStubbedInvocationMatcher invocationContainer = mock(StubbedInvocationMatcher.class);\n-\t\tgiven(handler.matchersBinder.bindMatchers(any(ArgumentMatcherStorage.class), any(Invocation.class))).willReturn(invocationContainer);\n-\t\t\n+\t\tgiven(handler.matchersBinder.bindMatchers(any(ArgumentMatcherStorage.class), any(Invocation.class)))\n+\t\t\t\t.willReturn(invocationContainer);\n+\n \t\tInvocation invocation = mock(Invocation.class);\n \t\tgiven(invocationContainer.getInvocation()).willReturn(invocation);\n-\t\t\n+\n \t\tgiven(invocation.isVoid()).willReturn(true);\n \t}\n \n \t@SuppressWarnings(\"rawtypes\")\n \tprivate void stubWithPreviouslySetVoidAnswer(MockHandler handler) {\n \t\tList<Answer<?>> answers = new ArrayList<Answer<?>>();\n-    \tanswers.add(new DoesNothing());\n-    \thandler.setAnswersForStubbing(answers);\n-\t}\n-    \n+\t\tanswers.add(new DoesNothing());\n+\t\thandler.setAnswersForStubbing(answers);\n+\t}\n+\n \tprivate MockHandler<?> createHandlerWithListeners(InvocationListener... listener) {\n \t\t@SuppressWarnings(\"rawtypes\")\n \t\tMockHandler<?> handler = new MockHandler(mock(MockSettingsImpl.class));", "timestamp": 1298483555, "metainfo": ""}