{"sha": "ad7afcacb03f13d4eff507fb9cab5f2ed3e4a0e4", "log": "refactorings around strict verifiers  --HG-- rename : src/org/mockito/internal/verification/StrictVerifier.java => src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40238", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.verification.StrictlyMissingInvocationVerifier;\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n-import org.mockito.internal.verification.StrictVerifier;\n+import org.mockito.internal.verification.StrictlyNumberOfInvocationsVerifier;\n import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n \n     \n     private VerifyingRecorder createRecorder() {\n         List<Verifier> verifiers = Arrays.asList(\n-                new StrictVerifier(),\n+                new StrictlyMissingInvocationVerifier(),\n+                new StrictlyNumberOfInvocationsVerifier(),\n                 new MissingInvocationVerifier(),\n                 new NumberOfInvocationsVerifier(),\n                 new NoMoreInvocationsVerifier());\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n /**\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/StrictlyMissingInvocationVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsPrinter;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+public class StrictlyMissingInvocationVerifier implements Verifier {\n+    \n+    private final Reporter reporter;\n+    private final ActualInvocationsFinder finder;\n+    \n+    public StrictlyMissingInvocationVerifier() {\n+        this(new ActualInvocationsFinder(), new Reporter());\n+    }\n+    \n+    public StrictlyMissingInvocationVerifier(ActualInvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+\n+    //TODO tests! - do you like the message?\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        //TODO push to mode\n+        if (!mode.strictMode() || mode.wantedCountIsZero()) {\n+            return;\n+        }\n+        \n+        List<Invocation> chunk = finder.findFirstStrictlyUnverified(invocations, wanted);\n+        \n+        if (chunk.size() == 0) {\n+            reporter.strictlyWantedButNotInvoked(wanted.toString());\n+        }\n+        \n+        if (!wanted.matches(chunk.get(0))) {\n+            Invocation actual = chunk.get(0);\n+            InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n+            reporter.strictVerificationFailed(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+public class StrictlyNumberOfInvocationsVerifier implements Verifier {\n+    \n+    private final Reporter reporter;\n+    private final ActualInvocationsFinder finder;\n+    \n+    public StrictlyNumberOfInvocationsVerifier() {\n+        this(new ActualInvocationsFinder(), new Reporter());\n+    }\n+    \n+    public StrictlyNumberOfInvocationsVerifier(ActualInvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+\n+    //TODO tests! - do you like the message?\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        if (!mode.strictMode()) {\n+            return;\n+        }\n+        \n+        List<Invocation> chunk = finder.findFirstStrictlyUnverified(invocations, wanted);\n+        \n+        boolean noMatchFound = chunk.size() == 0 || !wanted.matches(chunk.get(0));\n+        if (mode.wantedCountIsZero() && noMatchFound) {\n+            return;\n+        }\n+        \n+        int actualCount = chunk.size();\n+        \n+        if (mode.tooLittleActualInvocations(actualCount)) {\n+            HasStackTrace lastInvocation = getLastSafely(chunk);\n+            reporter.strictlyTooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n+        }\n+        \n+        if (mode.tooManyActualInvocations(actualCount)) {\n+            HasStackTrace firstUndesired = chunk.get(mode.wantedCount()).getStackTrace();\n+            reporter.strictlyTooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n+        }\n+        \n+        for (Invocation i : chunk) {\n+            i.markVerifiedStrictly();\n+        }\n+    }\n+    \n+    private HasStackTrace getLastSafely(List<Invocation> actualInvocations) {\n+        if (actualInvocations.isEmpty()) {\n+            return null;\n+        } else {\n+            Invocation last = actualInvocations.get(actualInvocations.size() - 1);\n+            return last.getStackTrace();\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.internal.progress.VerificationModeImpl;\n \n public class InvocationsAnalyzerTest extends RequiresValidState {\n     ", "timestamp": 1198701285, "metainfo": ""}