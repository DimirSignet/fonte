{"sha": "ad15fcaab92ea77b75b5829b615ab4a45a869896", "log": "Renamed for consistency", "commit": "\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegateTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitousage.MethodsImpl;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithDelegateTest {\n+   public class FakeList<T> {\n+        private T value;\n+        \n+        public T get(int i) {\n+            return value;\n+        }\n+        \n+        public T set(int i, T value) {\n+            T oldValue = value;\n+            this.value = value;\n+            return oldValue;\n+        }\n+        \n+        public int size() {\n+            return 10;\n+        }\n+        \n+        public ArrayList<T> subList(int fromIndex, int toIndex) {\n+            return new ArrayList<T>();\n+        }\n+    }\n+    \n+    public class FakeListWithWrongMethods<T> {\n+        public double size() {\n+            return 10;\n+        }\n+        \n+        public Collection<T> subList(int fromIndex, int toIndex) {\n+            return new ArrayList<T>();\n+        }\n+    }\n+\t\n+\t@Test\n+\tpublic void when_not_stubbed_delegate_should_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tmock.add(\"two\") ;\n+\n+        assertEquals(2, mock.size());\n+\t}\n+\n+\t@Test\n+\tpublic void when_stubbed_the_delegate_should_not_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tdoReturn(10).when(mock).size();\n+\n+\t\tmock.add(\"two\") ;\n+\n+\t\tassertEquals(10, mock.size());\n+        assertEquals(2, delegatedList.size());\n+\t}\n+\n+\t@Test\n+\tpublic void delegate_should_not_be_called_when_stubbed2() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mockedList = mock(List.class, delegatesTo(delegatedList)) ;\n+\n+\t\tdoReturn(false).when(mockedList).add(Mockito.anyString()) ;\n+\n+        mockedList.add(\"two\") ;\n+\n+\t\tassertEquals(1, mockedList.size()) ;\n+\t\tassertEquals(1, delegatedList.size()) ;\n+\t}\n+\n+    @Test\n+    public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {\n+        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl()));\n+\n+        try {\n+            byte b = methods.byteObjectReturningMethod(); // real method returns null\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.toString()).doesNotContain(\"org.mockito\");\n+        }\n+    }\n+    \n+    @Test\n+    public void instance_of_different_class_can_be_called() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));\n+        \n+        mock.set(1, \"1\");\n+        assertThat(mock.get(1).equals(\"1\"));\n+    }\n+    \n+    @Test\n+    public void method_with_subtype_return_can_be_called() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));\n+        \n+        List<String> subList = mock.subList(0, 0);\n+        assertThat(subList.isEmpty());\n+    }\n+    \n+    @Test\n+    public void calling_missing_method_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));\n+        \n+        try {\n+            mock.isEmpty();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Methods called on mock must exist\");\n+        }\n+    }\n+    \n+    @Test\n+    public void calling_method_with_wrong_primitive_return_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<String>()));\n+        \n+        try {\n+            mock.size();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Methods called on delegated instance must have compatible return type\");\n+        }\n+    }\n+    \n+    @Test\n+    public void calling_method_with_wrong_reference_return_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<String>()));\n+        \n+        try {\n+            mock.subList(0, 0);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Methods called on delegated instance must have compatible return type\");\n+        }\n+    }\n+\n+    @Test\n+    public void exception_should_be_propagated_from_delegate() throws Exception {\n+        final RuntimeException failure = new RuntimeException(\"angry-method\");\n+        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl() {\n+            @Override\n+            public String simpleMethod() {\n+                throw failure;\n+            }\n+        }));\n+\n+        try {\n+            methods.simpleMethod(); // delegate throws an exception\n+            fail();\n+        } catch (RuntimeException e) {\n+            assertThat(e).isEqualTo(failure);\n+        }\n+    }\n+}", "timestamp": 1416072808, "metainfo": ""}