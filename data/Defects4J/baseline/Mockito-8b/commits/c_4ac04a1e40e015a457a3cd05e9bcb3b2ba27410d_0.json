{"sha": "4ac04a1e40e015a457a3cd05e9bcb3b2ba27410d", "log": "- added verify as alternative to should in BddMockito.Then - added tests for new feature, added fluent tests for both options", "commit": "\n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n          * @see #verify(Object)\n          */\n         public T should() {\n-            return verify(mock);\n+            return Mockito.verify(mock);\n         }\n \n         /**\n          * @see #verify(Object, VerificationMode)\n          */\n         public T should(VerificationMode mode) {\n-            return verify(mock, mode);\n+            return Mockito.verify(mock, mode);\n+        }\n+\n+        /**\n+         * @see #verify(Object)\n+         */\n+        public T verify() {\n+            return Mockito.verify(mock);\n+        }\n+\n+        /**\n+         * @see #verify(Object, VerificationMode)\n+         */\n+        public T verify(VerificationMode mode) {\n+            return Mockito.verify(mock, mode);\n         }\n     }\n     \n--- a/test/org/mockitousage/customization/BDDMockitoTest.java\n+++ b/test/org/mockitousage/customization/BDDMockitoTest.java\n import static org.mockito.BDDMockito.*;\n \n public class BDDMockitoTest extends TestBase {\n-    \n+\n     @Mock IMethods mock;\n-    \n+\n     @Test\n     public void shouldStub() throws Exception {\n         given(mock.simpleMethod(\"foo\")).willReturn(\"bar\");\n-        \n+\n         assertEquals(\"bar\", mock.simpleMethod(\"foo\"));\n         assertEquals(null, mock.simpleMethod(\"whatever\"));\n     }\n-    \n+\n     @Test\n     public void shouldStubWithThrowable() throws Exception {\n         given(mock.simpleMethod(\"foo\")).willThrow(new RuntimeException());\n             fail();\n         } catch(RuntimeException e) {}\n     }\n-    \n+\n     @Test\n     public void shouldStubWithAnswer() throws Exception {\n         given(mock.simpleMethod(anyString())).willAnswer(new Answer<String>() {\n             public String answer(InvocationOnMock invocation) throws Throwable {\n                 return (String) invocation.getArguments()[0];\n             }});\n-        \n+\n         assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n     }\n \n        given(mock.simpleMethod(anyString()))\n            .willReturn(\"foo\")\n            .willReturn(\"bar\");\n-       \n+\n        assertEquals(\"foo\", mock.simpleMethod(\"whatever\"));\n        assertEquals(\"bar\", mock.simpleMethod(\"whatever\"));\n     }\n        assertEquals(\"foo\", mock.simpleMethod());\n        assertEquals(null, mock.simpleMethod());\n     }\n-    \n+\n     @Test\n     public void shouldStubVoid() throws Exception {\n         willThrow(new RuntimeException()).given(mock).voidMethod();\n-        \n+\n         try {\n             mock.voidMethod();\n             fail();\n         willDoNothing()\n         .willThrow(new RuntimeException())\n         .given(mock).voidMethod();\n-        \n+\n         mock.voidMethod();\n         try {\n             mock.voidMethod();\n             fail();\n         } catch(IllegalArgumentException e) {}\n     }\n-    \n+\n     @Test\n     public void shouldStubUsingDoReturnStyle() throws Exception {\n         willReturn(\"foo\").given(mock).simpleMethod(\"bar\");\n-        \n+\n         assertEquals(null, mock.simpleMethod(\"boooo\"));\n         assertEquals(\"foo\", mock.simpleMethod(\"bar\"));\n     }\n-    \n+\n     @Test\n     public void shouldStubUsingDoAnswerStyle() throws Exception {\n         willAnswer(new Answer<String>() {\n                 return (String) invocation.getArguments()[0];\n             }})\n         .given(mock).simpleMethod(anyString());\n-        \n+\n         assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n     }\n-    \n+\n     class Dog {\n         public String bark() {\n             return \"woof\";\n         //then\n         assertEquals(\"woof\", dog.bark());\n     }\n-    \n+\n     @Test\n     public void shouldStubByDelegatingToRealMethodUsingTypicalStubbingSyntax() throws Exception {\n         //given\n \n         then(mock).should().booleanObjectReturningMethod();\n     }\n+\n+    @Test(expected = WantedButNotInvoked.class)\n+    public void shouldFailForExpectedBehaviorThatDidNotHappenWithVerify() {\n+\n+        then(mock).verify().booleanObjectReturningMethod();\n+    }\n+\n+    @Test\n+    public void shouldPassForExpectedBehaviorThatHappenedWithVerify() {\n+\n+        mock.booleanObjectReturningMethod();\n+\n+        then(mock).verify().booleanObjectReturningMethod();\n+    }\n+\n+    @Test\n+    public void shouldPassFluentBddScenario() {\n+\n+        Bike bike = new Bike();\n+        Person person = mock(Person.class);\n+\n+        person.ride(bike);\n+        person.ride(bike);\n+\n+        then(person).should(times(2)).ride(bike);\n+    }\n+\n+    @Test\n+    public void shouldPassFluentBddScenarioWithVerify() {\n+\n+        Bike bike = new Bike();\n+        Person person = mock(Person.class);\n+\n+        person.ride(bike);\n+        person.ride(bike);\n+\n+        then(person).verify(times(2)).ride(bike);\n+    }\n+\n+    static class Person {\n+\n+        void ride(Bike bike) {}\n+    }\n+\n+    static class Bike {\n+\n+    }\n }", "timestamp": 1394739648, "metainfo": ""}