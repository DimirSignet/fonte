{"sha": "909a64e6e87ee0fb03ea67ddfcecb3b8f0d701fc", "log": "Mockito goes multithreaded  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40131", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     \n     public static <T> T mock(Class<T> classToMock) {\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n-        MockControl<T> mockControl = new MockControl<T>(MockitoState.instance(), LastArguments.instance());\n+        MockControl<T> mockControl = new MockControl<T>();\n         return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n                 classToMock, mockControl));\n     }\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n     private List<IArgumentMatcher> argumentsToMatchers() {\n         List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n         for (Object arg : this.arguments) {\n-            if (arg.getClass().isArray()) {\n+            //TODO cover the arg == null scenario\n+            if (arg != null && arg.getClass().isArray()) {\n                 matchers.add(new ArrayEquals(arg));\n             } else {\n                 matchers.add(new Equals(arg));\n--- a/src/org/mockito/internal/LastArguments.java\n+++ b/src/org/mockito/internal/LastArguments.java\n \n import java.util.*;\n \n-import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.exceptions.*;\n import org.mockito.internal.matchers.*;\n \n public class LastArguments {\n     \n     private final ThreadLocal<Stack<IArgumentMatcher>> threadToArgumentMatcherStack = new ThreadLocal<Stack<IArgumentMatcher>>();\n \n-    public static LastArguments instance() {\n+    //does everything needs to be synchronized\n+    public static synchronized LastArguments instance() {\n         return INSTANCE;\n     }\n     \n \n     private void assertState(boolean toAssert, String message) {\n         if (!toAssert) {\n-            threadToArgumentMatcherStack.remove();\n+            if (threadToArgumentMatcherStack.get() != null) \n+                threadToArgumentMatcherStack.get().clear();\n             throw new InvalidUseOfMatchersException(message);\n         }\n     }\n \n-    public void reportOr(int count) {\n+    public synchronized void reportOr(int count) {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n         assertState(stack != null, missingMatchers());\n         stack.push(new Or(popLastArgumentMatchers(count)));\n     }\n+\n+    static synchronized void setInstance(LastArguments lastArguments) {\n+        INSTANCE = lastArguments;\n+    }\n+\n+    public synchronized void validateState() {\n+        if (threadToArgumentMatcherStack.get() != null && !threadToArgumentMatcherStack.get().isEmpty()) {\n+            threadToArgumentMatcherStack.get().clear();\n+            throw new MockitoException(\"invalid arguments state\");\n+        }\n+    }\n+\n+    //TODO crap, needs to be TL singleton\n+    synchronized void reset() {\n+        if (threadToArgumentMatcherStack.get() != null) {\n+            threadToArgumentMatcherStack.get().clear();\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n     private final MockitoBehavior<T> behavior = new MockitoBehavior<T>();\n-    private final MockitoState mockitoState;\n-    private final LastArguments lastArguments;\n \n     private Throwable throwableToBeSetOnVoidMethod;\n-    \n-    public MockControl(MockitoState mockitoState, LastArguments lastArguments) {\n-        this.mockitoState = mockitoState;\n-        this.lastArguments = lastArguments;\n-    }\n     \n     /**\n      * if user passed bare arguments then create EqualsMatcher for every argument\n             return null;\n         }\n         \n-        VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n-        mockitoState.validateState();\n+        VerifyingMode verifyingMode = MockitoState.instance().pullVerifyingMode();\n+        MockitoState.instance().validateState();\n         \n         ExpectedInvocation invocationWithMatchers = expectedInvocation(proxy, method, args);\n         \n         \n         behavior.addInvocation(invocationWithMatchers);\n \n-        mockitoState.reportControlForStubbing(this);\n+        MockitoState.instance().reportControlForStubbing(this);\n         \n         return behavior.resultFor(invocationWithMatchers.getInvocation());\n     }\n \n     private ExpectedInvocation expectedInvocation(Object proxy, Method method, Object[] args) {\n-        Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n+        Invocation invocation = new Invocation(proxy, method, args, MockitoState.instance().nextSequenceNumber());\n         \n-        List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n+        List<IArgumentMatcher> lastMatchers = LastArguments.instance().pullMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n         List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n     }\n \n     public void andReturn(T value) {\n-        mockitoState.stubbingCompleted();\n+        MockitoState.instance().stubbingCompleted();\n         behavior.addResult(Result.createReturnResult(value));\n     }\n \n     public void andThrows(Throwable throwable) {\n-        mockitoState.stubbingCompleted();\n+        MockitoState.instance().stubbingCompleted();\n         validateThrowable(throwable);\n         behavior.addResult(Result.createThrowResult(throwable));\n     }\n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n public class MockitoState {\n     \n     //TODO this has to be thready singleton\n-    static MockitoState INSTANCE = new MockitoState();\n+    //look how many synchronized stuff we can get rid off\n+    private static MockitoState INSTANCE = new MockitoState();\n     \n     private final ThreadLocal<MockControl> lastControl = new ThreadLocal<MockControl>();\n     private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n \n     MockitoState() {}\n     \n-    public static MockitoState instance() {\n+    public static synchronized MockitoState instance() {\n         return INSTANCE;\n     }\n     \n                 \", invocationSequenceNumber: \" + invocationSequenceNumber.get() +\n                 \", stubbingModeLocal: \" + stubbingModeLocal.get();\n     }\n+\n+    synchronized static void setInstance(MockitoState mockitoState) {\n+        INSTANCE = mockitoState;\n+    }\n+\n+    synchronized void reset() {\n+        stubbingModeLocal.set(null);\n+        verifyingModeLocal.set(null);\n+        invocationSequenceNumber.set(null);\n+    }\n }\n--- a/src/org/mockito/internal/StubbedInvocation.java\n+++ b/src/org/mockito/internal/StubbedInvocation.java\n     public Result getResult() {\n         return result;\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return super.toString() + \" stubbed with: \" + result.toString();\n+    }\n }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoTest extends RequiresValidState {\n \n-    private String notMock;\n-\n-    @Before\n+    @Before @After\n     public void setup() {\n-        StateResetter.reset();\n-        notMock = \"i'm not a notMock\";\n-    }\n-    \n-    @After\n-    public void resetState() {\n         StateResetter.reset();\n     }\n     \n     @Test\n     public void shouldRemoveStubbedControlFromStateWhenStubbing() {\n         List mock = Mockito.mock(List.class);\n+//        System.out.println(\"[\" + Thread.currentThread().getId() + \"] - stubbing...\");\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n         assertNull(MockitoState.instance().pullControlToBeStubbed());\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenVerifying() {\n-        Mockito.verify(notMock);\n+        Mockito.verify(\"notMock\");\n     }\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {\n-        Mockito.verify(notMock, 19);\n+        Mockito.verify(\"notMock\", 19);\n     }\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenVerifyingNoMoreInteractions() {\n-        Mockito.verifyNoMoreInteractions(notMock);\n+        Mockito.verifyNoMoreInteractions(\"notMock\");\n     }\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenVerifyingZeroInteractions() {\n-        Mockito.verifyZeroInteractions(notMock);\n+        Mockito.verifyZeroInteractions(\"notMock\");\n     }\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenStubbingVoid() {\n-        Mockito.stubVoid(notMock);\n+        Mockito.stubVoid(\"notMock\");\n     }\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenGettingStrictVerifier() {\n-        Mockito.createStrictOrderVerifier(notMock);\n+        Mockito.createStrictOrderVerifier(\"notMock\");\n     }\n }\n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n     \n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n-        MockitoState state = MockitoState.instance(); \n-        LastArguments lastArguments = LastArguments.instance();\n+        LastArguments.instance().reportMatcher(new Equals(\"test\"));\n+        MockitoState.instance().verifyingStarted(VerifyingMode.atLeastOnce());\n         \n-        lastArguments.reportMatcher(new Equals(\"test\"));\n-        state.verifyingStarted(VerifyingMode.atLeastOnce());\n-        \n-        MockControl control = new MockControl(state, lastArguments);\n+        MockControl control = new MockControl();\n \n         try {\n             control.invoke(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{});\n             fail();\n-        } catch (InvalidUseOfMatchersException e) {\n-        }\n+        } catch (InvalidUseOfMatchersException e) {}\n         \n-        assertNull(state.pullVerifyingMode());\n+        assertNull(MockitoState.instance().pullVerifyingMode());\n     }\n }\n--- a/test/org/mockito/internal/StateResetter.java\n+++ b/test/org/mockito/internal/StateResetter.java\n public class StateResetter {\n     \n     public static void reset() {\n-        MockitoState.INSTANCE = new MockitoState();\n-        LastArguments.INSTANCE = new LastArguments();\n+        MockitoState.instance().reset();\n+        LastArguments.instance().reset();\n     }\n }\n--- a/test/org/mockito/util/RequiresValidState.java\n+++ b/test/org/mockito/util/RequiresValidState.java\n package org.mockito.util;\n \n import org.junit.Before;\n-import org.mockito.internal.MockitoState;\n+import org.mockito.internal.*;\n \n public class RequiresValidState {\n \n-    @Before public void requireValidState() {\n+    @Before public void requiresValidState() {\n         MockitoState.instance().validateState();\n+        LastArguments.instance().validateState();\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/MultiThreadedRun.java\n+package org.mockitousage;\n+import java.util.*;\n+\n+import org.junit.runner.*;\n+import org.junit.runner.Result;\n+import org.junit.runner.notification.Failure;\n+import org.mockito.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.*;\n+import org.mockito.internal.matchers.EqualsTest;\n+import org.mockito.sample.MockitoSampleTest;\n+import org.mockitousage.binding.*;\n+import org.mockitousage.matchers.*;\n+import org.mockitousage.stubbing.*;\n+import org.mockitousage.verification.*;\n+\n+public class MultiThreadedRun {\n+    \n+    private static class AllTestsRunner implements Runnable {\n+        \n+        public void run() {\n+            Result result = JUnitCore.runClasses(\n+                    MockitoSampleTest.class, \n+                    EqualsTest.class, \n+                    CglibTest.class, \n+                    ExpectedInvocationTest.class, \n+                    InvocationChunkTest.class, \n+                    MockFactoryTest.class, \n+                    MockitoBehaviorTest.class, \n+                    MockitoStateTest.class, \n+                    RegisteredInvocationsTest.class, \n+                    ToTypeMappingsTest.class, \n+                    VerifyingModeTest.class, \n+                    InvocationTest.class, \n+                    MockUtilTest.class, \n+                    MockitoAssertionErrorTest.class, \n+                    MockitoErrorTest.class, \n+                    BridgeMethodPuzzleTest.class, \n+                    IncorectBindingPuzzleFixedTest.class, \n+                    UsingVarargsTest.class, \n+                    ComparableMatchersTest.class, \n+                    MatchersToStringTest.class, \n+                    VerificationAndStubbingUsingMatchersTest.class, \n+                    BasicStubbingTest.class, \n+                    ReturningDefaultValuesTest.class, \n+                    StubbingWithThrowablesTest.class, \n+                    AtLeastOnceVerificationTest.class, \n+                    BasicVerificationTest.class, \n+                    ExactNumberOfTimesVerificationTest.class, \n+                    NiceMessagesWhenVerificationFailsTest.class, \n+                    NoMoreInteractionsVerificationTest.class, \n+                    VerificationInOrderMixedWithOrdiraryVerificationTest.class, \n+                    VerificationInOrderTest.class, \n+                    VerificationOnMultipleMocksUsingMatchersTest.class, \n+                    VerificationUsingMatchersTest.class, \n+                    MatchersTest.class,\n+                    ReplacingObjectMethodsTest.class,\n+                    //below are tests that mess up the state\n+                    MockControlTest.class,\n+                    MockitoTest.class,\n+                    InvalidUsageTest.class,\n+                    InvalidUseOfMatchersTest.class,\n+                    NiceMessagesOnStrictOrderErrorsTest.class,\n+                    InvalidStateDetectionTest.class,\n+                    StackTrackeFilteringTest.class\n+                );\n+                \n+                if (!result.wasSuccessful()) {\n+                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n+                    List<Failure> failures = result.getFailures();\n+                    System.err.println(failures.size());\n+                    for (Failure failure : failures) {\n+                        System.err.println(failure.getTrace());\n+                    }\n+                }\n+        }\n+    }\n+    \n+    public static void main(String[] args) throws Exception {\n+        List<Thread> threads = new LinkedList<Thread>();\n+        for(int i = 1 ; i <= 30 ; i++) {\n+            threads.add(new Thread(new AllTestsRunner()));\n+        }\n+        \n+        for (Thread t : threads) {\n+            t.start();\n+        }\n+        \n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+        \n+        System.out.println(\"Finished!\");\n+    }\n+}", "timestamp": 1196809840, "metainfo": ""}