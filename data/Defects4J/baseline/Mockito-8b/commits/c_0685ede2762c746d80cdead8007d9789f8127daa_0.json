{"sha": "0685ede2762c746d80cdead8007d9789f8127daa", "log": "Pushed out complexity to separate class  Moved plugin loading mechanism out of the ClassPathLoader which should be renamed later on into ConfigurationLoader", "commit": "\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n  * </p>\n  */\n public class ClassPathLoader {\n-    private static final String DEFAULT_MOCK_MAKER_CLASS =\n-            \"org.mockito.internal.creation.cglib.CglibMockMaker\";\n-    private static final String DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS =\n-            \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\";\n+\n     public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n-\n-    private static final MockMaker mockMaker = findPlatformMockMaker();\n-    private static final StackTraceCleanerProvider stackTraceCleanerProvider =\n-            findPlatformStackTraceCleanerProvider();\n \n     /**\n      * @return configuration loaded from classpath or null\n             throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n         }\n     }\n-\n-    /**\n-     * Returns the implementation of the mock maker available for the current runtime.\n-     *\n-     * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n-     * {@link MockMaker} extension exists or is visible in the current classpath.</p>\n-     */\n-    public static MockMaker getMockMaker() {\n-        return mockMaker;\n-    }\n-\n-    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n-        //TODO we should throw some sensible exception if this is null.\n-        return stackTraceCleanerProvider;\n-    }\n-\n-    /**\n-     * Scans the classpath to find a mock maker plugin if one is available,\n-     * allowing mockito to run on alternative platforms like Android.\n-     */\n-    static MockMaker findPlatformMockMaker() {\n-        return findPluginImplementation(MockMaker.class, DEFAULT_MOCK_MAKER_CLASS);\n-    }\n-\n-    static StackTraceCleanerProvider findPlatformStackTraceCleanerProvider() {\n-        return findPluginImplementation(\n-                StackTraceCleanerProvider.class, DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS);\n-    }\n-\n-    static <T> T findPluginImplementation(Class<T> pluginType, String defaultPluginClassName) {\n-        for (T plugin : loadImplementations(pluginType)) {\n-            return plugin; // return the first one service loader finds (if any)\n-        }\n-\n-        try {\n-            // Default implementation. Use our own ClassLoader instead of the context\n-            // ClassLoader, as the default implementation is assumed to be part of\n-            // Mockito and may not be available via the context ClassLoader.\n-            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n-        } catch (Exception e) {\n-            throw new MockitoException(\"Internal problem occurred, please report it. \" +\n-                    \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" +\n-                    \"Failed to load \" + pluginType, e);\n-        }\n-    }\n-\n-    /**\n-     * Equivalent to {@link java.util.ServiceLoader#load} but without requiring\n-     * Java 6 / Android 2.3 (Gingerbread).\n-     */\n-    static <T> List<T> loadImplementations(Class<T> service) {\n-        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-        if (loader == null) {\n-            loader = ClassLoader.getSystemClassLoader();\n-        }\n-        Enumeration<URL> resources;\n-        try {\n-            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n-        } catch (IOException e) {\n-            throw new MockitoException(\"Failed to load \" + service, e);\n-        }\n-\n-        List<T> result = new ArrayList<T>();\n-        for (URL resource : Collections.list(resources)) {\n-            InputStream in = null;\n-            try {\n-                in = resource.openStream();\n-                for (String line : readerToLines(new InputStreamReader(in, \"UTF-8\"))) {\n-                    String name = stripCommentAndWhitespace(line);\n-                    if (name.length() != 0) {\n-                        result.add(service.cast(loader.loadClass(name).newInstance()));\n-                    }\n-                }\n-            } catch (Exception e) {\n-                throw new MockitoConfigurationException(\n-                        \"Failed to load \" + service + \" using \" + resource, e);\n-            } finally {\n-                closeQuietly(in);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    static List<String> readerToLines(Reader reader) throws IOException {\n-        List<String> result = new ArrayList<String>();\n-        BufferedReader lineReader = new BufferedReader(reader);\n-        String line;\n-        while ((line = lineReader.readLine()) != null) {\n-            result.add(line);\n-        }\n-        return result;\n-    }\n-\n-    static String stripCommentAndWhitespace(String line) {\n-        int hash = line.indexOf('#');\n-        if (hash != -1) {\n-            line = line.substring(0, hash);\n-        }\n-        return line.trim();\n-    }\n-\n-    private static void closeQuietly(InputStream in) {\n-        if (in != null) {\n-            try {\n-                in.close();\n-            } catch (IOException ignored) {\n-            }\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/plugins/PluginLoader.java\n+package org.mockito.internal.configuration.plugins;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+\n+import java.io.*;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+\n+public class PluginLoader {\n+\n+    /**\n+     * Scans the classpath for given pluginType. If not found, default class is used.\n+     */\n+    static <T> T plugin(Class<T> pluginType, String defaultPluginClassName) {\n+        for (T plugin : loadImplementations(pluginType)) {\n+            return plugin; // return the first one service loader finds (if any)\n+        }\n+\n+        try {\n+            // Default implementation. Use our own ClassLoader instead of the context\n+            // ClassLoader, as the default implementation is assumed to be part of\n+            // Mockito and may not be available via the context ClassLoader.\n+            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n+        } catch (Exception e) {\n+            throw new MockitoException(\"Internal problem occurred, please report it. \" +\n+                    \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" +\n+                    \"Failed to load \" + pluginType, e);\n+        }\n+    }\n+\n+    /**\n+     * Equivalent to {@link java.util.ServiceLoader#load} but without requiring\n+     * Java 6 / Android 2.3 (Gingerbread).\n+     */\n+    static <T> List<T> loadImplementations(Class<T> service) {\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        if (loader == null) {\n+            loader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> resources;\n+        try {\n+            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n+        } catch (IOException e) {\n+            throw new MockitoException(\"Failed to load \" + service, e);\n+        }\n+\n+        List<T> result = new ArrayList<T>();\n+        for (URL resource : Collections.list(resources)) {\n+            InputStream in = null;\n+            try {\n+                in = resource.openStream();\n+                for (String line : readerToLines(new InputStreamReader(in, \"UTF-8\"))) {\n+                    String name = stripCommentAndWhitespace(line);\n+                    if (name.length() != 0) {\n+                        result.add(service.cast(loader.loadClass(name).newInstance()));\n+                    }\n+                }\n+            } catch (Exception e) {\n+                throw new MockitoConfigurationException(\n+                        \"Failed to load \" + service + \" using \" + resource, e);\n+            } finally {\n+                closeQuietly(in);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    static List<String> readerToLines(Reader reader) throws IOException {\n+        List<String> result = new ArrayList<String>();\n+        BufferedReader lineReader = new BufferedReader(reader);\n+        String line;\n+        while ((line = lineReader.readLine()) != null) {\n+            result.add(line);\n+        }\n+        return result;\n+    }\n+\n+    static String stripCommentAndWhitespace(String line) {\n+        int hash = line.indexOf('#');\n+        if (hash != -1) {\n+            line = line.substring(0, hash);\n+        }\n+        return line.trim();\n+    }\n+\n+    private static void closeQuietly(InputStream in) {\n+        if (in != null) {\n+            try {\n+                in.close();\n+            } catch (IOException ignored) {\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/plugins/PluginRegistry.java\n+package org.mockito.internal.configuration.plugins;\n+\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.plugins.StackTraceCleanerProvider;\n+\n+/**\n+ * Access to Mockito behavior that can be reconfigured by plugins\n+ */\n+public class PluginRegistry {\n+\n+    private static final MockMaker mockMaker\n+            = PluginLoader.plugin(MockMaker.class, \"org.mockito.internal.creation.cglib.CglibMockMaker\");\n+\n+    private static final StackTraceCleanerProvider stackTraceCleanerProvider\n+            = PluginLoader.plugin(StackTraceCleanerProvider.class, \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\");\n+\n+    /**\n+     * The implementation of the stack trace cleaner\n+     */\n+    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n+        //TODO we should throw some sensible exception if this is null.\n+        return stackTraceCleanerProvider;\n+    }\n+\n+    /**\n+     * Returns the implementation of the mock maker available for the current runtime.\n+     *\n+     * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n+     * {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p>\n+     */\n+    public static MockMaker getMockMaker() {\n+        return mockMaker;\n+    }\n+}\n--- a/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n+++ b/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n \n import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n import org.mockito.internal.configuration.ClassPathLoader;\n+import org.mockito.internal.configuration.plugins.PluginRegistry;\n \n import java.io.Serializable;\n import java.util.ArrayList;\n     static final long serialVersionUID = -5499819791513105700L;\n \n     private static final StackTraceCleaner CLEANER =\n-            ClassPathLoader.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());\n+            PluginRegistry.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());\n     \n     /**\n      * Example how the filter works (+/- means good/bad):\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.configuration.ClassPathLoader;\n+import org.mockito.internal.configuration.plugins.PluginRegistry;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.handler.MockHandlerFactory;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n \n-    private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n+    private static final MockMaker mockMaker = PluginRegistry.getMockMaker();\n \n     public boolean isTypeMockable(Class<?> type) {\n       return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/ClassPathLoaderTest.java\n+package org.mockito.internal.configuration;\n+\n+import org.junit.Test;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+\n+public class ClassPathLoaderTest {\n+\n+    @Test\n+    public void shouldReadConfigurationClassFromClassPath() {\n+        ConfigurationAccess.getConfig().overrideDefaultAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) {\n+                return \"foo\";\n+            }});\n+\n+        IMethods mock = mock(IMethods.class);\n+        assertEquals(\"foo\", mock.simpleMethod());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/plugins/PluginLoaderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration.plugins;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import static org.mockito.Mockito.*;\n+\n+import junit.framework.Assert;\n+import org.junit.Test;\n+import org.mockito.internal.configuration.ClassPathLoader;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class PluginLoaderTest extends TestBase {\n+\n+    @Test\n+    public void readerToLinesEmptyString() throws IOException {\n+        assertEquals(Collections.emptyList(), PluginLoader.readerToLines(new StringReader(\"\")));\n+    }\n+\n+    @Test\n+    public void readerToLinesNoLineBreaks() throws IOException {\n+        assertEquals(Arrays.asList(\"a\"), PluginLoader.readerToLines(new StringReader(\"a\")));\n+    }\n+\n+    @Test\n+    public void readerToLinesWithLineBreaks() throws IOException {\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"),\n+                PluginLoader.readerToLines(new StringReader(\"a\\nb\\nc\")));\n+    }\n+\n+    @Test\n+    public void readerToLinesWithEmptyLines() throws IOException {\n+        assertEquals(Arrays.asList(\"a\", \"\", \"c\"),\n+                PluginLoader.readerToLines(new StringReader(\"a\\n\\nc\")));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceEmptyInput() throws IOException {\n+        assertEquals(\"\", PluginLoader.stripCommentAndWhitespace(\"\"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceWhitespaceInput() throws IOException {\n+        assertEquals(\"\", PluginLoader.stripCommentAndWhitespace(\" \"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceCommentInInput() throws IOException {\n+        assertEquals(\"a\", PluginLoader.stripCommentAndWhitespace(\"a#b\"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceMultipleHashes() throws IOException {\n+        assertEquals(\"a\", PluginLoader.stripCommentAndWhitespace(\"a#b#c\"));\n+    }\n+\n+    @Test\n+    public void stripCommentsAndWhitespaceWithWhitespaceAndComments() throws IOException {\n+        assertEquals(\"a\", PluginLoader.stripCommentAndWhitespace(\" a #b\"));\n+    }\n+}", "timestamp": 1418426971, "metainfo": ""}