{"sha": "ccb377aaa7ff9a755e10cc83dd4c73e98c559e1c", "log": "first hacky version of verifying strictly  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4061", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     }\n     \n     public static <T> T verify(T mock) {\n-        MockUtil.validateMock(mock);\n-        MockitoState.instance().verifyingStarted(VerifyingMode.anyTimes());\n-        return mock; \n+        return verify(mock, VerifyingMode.anyTimes());\n     }\n     \n     public static <T> T verify(T mock, int exactNumberOfInvocations) {\n+        return verify(mock, VerifyingMode.times(exactNumberOfInvocations));\n+    }\n+    \n+    //TODO should not be public\n+    public static <T> T verify(T mock, VerifyingMode mode) {\n         MockUtil.validateMock(mock);\n-        MockitoState.instance().verifyingStarted(VerifyingMode.times(exactNumberOfInvocations));\n+        MockitoState.instance().verifyingStarted(mode);\n         return mock;\n     }\n \n     }\n \n     public static StrictOrderVerifier strictOrderVerifier(Object ... mocks) {\n+        StrictOrderVerifier strictOrderVerifier = new StrictOrderVerifier();\n         for (Object mock : mocks) {\n             MockUtil.validateMock(mock);\n+            strictOrderVerifier.addMock(mock);\n         }\n-        return new StrictOrderVerifier();\n+        return strictOrderVerifier;\n     }\n }\n--- a/src/org/mockito/exceptions/MockitoStackTraceFilter.java\n+++ b/src/org/mockito/exceptions/MockitoStackTraceFilter.java\n \n     public void filterStackTrace(HasFilterableStackTrace hasFilterableStackTrace) {\n         List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasFilterableStackTrace.getStackTrace());\n+        \n         int lastToRemove = -1;\n         int i = 0;\n         for (StackTraceElement trace : unfilteredStackTrace) {\n             if (this.isLastStackElementToRemove(trace)) {\n                 lastToRemove = i;\n-                break;\n             }\n             i++;\n         }\n--- a/src/org/mockito/internal/InvocationWithMatchers.java\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n \n     protected final Invocation invocation;\n     private final List<IArgumentMatcher> matchers;\n+    private int sequenceNumber;\n \n     public InvocationWithMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n         this.invocation = invocation;\n         this.matchers = matchers;\n     }\n-\n+    \n     public boolean equals(Object o) {\n         if (o == null || !this.getClass().equals(o.getClass()))\n             return false;\n         }\n         return result.toString().replaceFirst(\", \", \"\").concat(\")\");\n     }\n-}\n+\n+    public Integer getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    public void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n         validateMatchers(invocation, lastMatchers);\n \n         List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n+        \n         InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, processedMatchers);\n         \n         if (verifyingMode != null) {\n+            //TODO shouldn't verify take only invocationWithMatchers.getInvocation(); ?\n             behavior.verify(invocationWithMatchers, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n         }\n //        }\n         \n         mockitoState.reportLastControl(this);\n+        \n+        invocationWithMatchers.setSequenceNumber(mockitoState.nextSequenceNumber());\n         \n         behavior.addInvocation(invocationWithMatchers);\n         \n     public void setMock(T mock) {\n         behavior.setMock(mock);\n     }\n+\n+    public List<InvocationWithMatchers> getRegisteredInvocations() {\n+        return behavior.getRegisteredInvocations();\n+    }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n                 \n                 throw new VerificationAssertionError(message);\n             }\n+        }\n+        \n+        if (verifyingMode.orderOfInvocationsMatters()) {\n+            checkOrderOfInvocations(invocation, verifyingMode);\n+        }\n+    }\n+\n+    private void checkOrderOfInvocations(InvocationWithMatchers actualInvocation, VerifyingMode verifyingMode) {\n+        Set<InvocationWithMatchers> allInvocationsInOrder = new TreeSet<InvocationWithMatchers>(\n+                new Comparator<InvocationWithMatchers>(){\n+                    public int compare(InvocationWithMatchers o1, InvocationWithMatchers o2) {\n+                        int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n+                        assert comparison != 0;\n+                        return comparison;\n+                    }});\n+        \n+        List<Object> allMocksToBeVerifiedInOrder = verifyingMode.getAllMocksToBeVerifiedInSequence();\n+        for (Object mock : allMocksToBeVerifiedInOrder) {\n+            List<InvocationWithMatchers> invocations = MockUtil.getControl(mock).getRegisteredInvocations();\n+            allInvocationsInOrder.addAll(invocations);\n+        }\n+        \n+        InvocationWithMatchers lastVerifiedInvocation = null;\n+        for (InvocationWithMatchers registeredInvocation : allInvocationsInOrder) {\n+            if (registeredInvocation.getInvocation().isVerified()) {\n+                lastVerifiedInvocation = registeredInvocation;\n+            } else {\n+                break;\n+            }\n+        }\n+        assert lastVerifiedInvocation != null;\n+        \n+        if (!lastVerifiedInvocation.matches(actualInvocation.getInvocation())) {\n+            throw new StrictVerificationError();\n         }\n     }\n \n     public void setMock(T mock) {\n         this.mock = mock;\n     }\n+\n+    public List<InvocationWithMatchers> getRegisteredInvocations() {\n+        return registeredInvocations;\n+    }\n }\n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoState {\n     \n+    //TODO this has to be threaddy singleton\n     static MockitoState INSTANCE = new MockitoState();\n     \n     private final ThreadLocal<MockControl> lastControl = new ThreadLocal<MockControl>();\n     private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n-//    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n+    private final ThreadLocal<Integer> invocationSequenceNumber = new ThreadLocal<Integer>();\n+//    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLoca<Object>();\n \n     MockitoState() {}\n     \n         verifyingModeLocal.set(verify);\n     }\n \n-    public void checkForUnfinishedVerification() {\n+    public synchronized void checkForUnfinishedVerification() {\n         if (verifyingModeLocal.get() != null) {\n             throw new UnfinishedVerificationException();\n         }\n         VerifyingMode verifyingMode = verifyingModeLocal.get();\n         verifyingModeLocal.set(null);\n         return verifyingMode;\n+    }\n+\n+    public synchronized int nextSequenceNumber() {\n+        if (invocationSequenceNumber.get() == null) {\n+            invocationSequenceNumber.set(1);\n+            return 1;\n+        } else {\n+            int next = invocationSequenceNumber.get() + 1;\n+            invocationSequenceNumber.set(next);\n+            return next;\n+        }\n     }\n \n //    public void stubbingStarted() {\n--- /dev/null\n+++ b/src/org/mockito/internal/SequenceNumberProvider.java\n+package org.mockito.internal;\n+\n+public class SequenceNumberProvider {\n+\n+    private int sequence = 1;\n+    \n+    public Integer sequenceNumber() {\n+        return sequence++;\n+    }\n+}\n--- a/src/org/mockito/internal/StrictOrderVerifier.java\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n package org.mockito.internal;\n+\n+import java.util.*;\n \n import org.mockito.Mockito;\n \n public class StrictOrderVerifier {\n+    \n+    List<Object> mocks = new LinkedList<Object>();\n     \n     public <T> T verify(T mock) {\n         return Mockito.verify(mock);\n     }\n     \n     public <T> T verify(T mock, int exactNumberOfInvocations) {\n-        return Mockito.verify(mock, exactNumberOfInvocations);\n+        return Mockito.verify(mock, VerifyingMode.inSequence(exactNumberOfInvocations, mocks));\n     }\n \n     public void verifyNoMoreInteractions() {\n         MockitoState.instance().checkForUnfinishedVerification();\n     }\n+\n+    public void addMock(Object mock) {\n+        mocks.add(mock);\n+    }\n }\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n package org.mockito.internal;\n+\n+import java.util.*;\n \n import org.mockito.exceptions.MockitoException;\n \n public class VerifyingMode {\n \n-    private static final int ANY_NUMBER_OF_TIMES = -1;\n-    private final int exactNumberOfInvocations;\n+    private final Integer exactNumberOfInvocations;\n+    private final List<Object> mocksToBeVerifiedInSequence;\n \n-    public VerifyingMode(int exactNumberOfTimes) {\n-        this.exactNumberOfInvocations = exactNumberOfTimes;\n+    private VerifyingMode(Integer exactNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n+        if (exactNumberOfInvocations != null && exactNumberOfInvocations.intValue() < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        this.exactNumberOfInvocations = exactNumberOfInvocations;\n+        this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n     }\n     \n     public static VerifyingMode anyTimes() {\n-        return new VerifyingMode(ANY_NUMBER_OF_TIMES);\n+        return new VerifyingMode(null, Collections.emptyList());\n     }\n \n     public static VerifyingMode times(int exactNumberOfInvocations) {\n-        if (exactNumberOfInvocations < 0) {\n-            throw new MockitoException(\"Negative value is not allowed here\");\n-        }\n-        return new VerifyingMode(exactNumberOfInvocations);\n+        return new VerifyingMode(exactNumberOfInvocations, Collections.emptyList());\n     }\n \n     public boolean numberOfInvocationsMatters() {\n-        return exactNumberOfInvocations != ANY_NUMBER_OF_TIMES;\n+        return exactNumberOfInvocations != null;\n     }\n \n     public int getExactNumberOfInvocations() {\n         return exactNumberOfInvocations;\n     }\n+\n+    public List<Object> getAllMocksToBeVerifiedInSequence() {\n+        return mocksToBeVerifiedInSequence;\n+    }\n+\n+    public static VerifyingMode inSequence(int exactNumberOfInvocations, List<Object> mocks) {\n+        return new VerifyingMode(exactNumberOfInvocations, mocks);\n+    }\n+\n+    public boolean orderOfInvocationsMatters() {\n+        return !mocksToBeVerifiedInSequence.isEmpty();\n+    }\n }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n     }\n     \n     @Test(expected=NotAMockException.class)\n-    public void shouldValidateMockWhenEnablingStrictChecking() {\n+    public void shouldValidateMockWhenGettingStrictVerifier() {\n         Mockito.strictOrderVerifier(notMock);\n     }\n     \n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n         strictly.verify(list, 2).add(\"xxx\");\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldFailOnWrongOrder() {\n         strictly.verify(list, 1).add(\"one\");", "timestamp": 1195931266, "metainfo": ""}