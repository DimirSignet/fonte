{"sha": "1beeae39ac9f79d6a0db285dec311b78025ac062", "log": "Merge pull request #103 from mockito/fixes-issue-99  Fixes issue #99", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import static org.mockito.Mockito.withSettings;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n import org.mockito.MockSettings;\n import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n  * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n  */\n public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n-    \n+\n     private static final long serialVersionUID = -7105341425736035847L;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n     }\n \n     private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n-    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n-    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n+        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n         // matches invocation for verification\n         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n-    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n-    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n-    \t\t}\n-\t\t}\n+            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n+                return stubbedInvocationMatcher.answer(invocation);\n+            }\n+        }\n \n         // record deep stub answer\n-        return recordDeepStubAnswer(newDeepStubMock(returnTypeGenericMetadata), container);\n+        return recordDeepStubAnswer(\n+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),\n+                container\n+        );\n     }\n \n     /**\n      * {@link ReturnsDeepStubs} answer in which we will store the returned type generic metadata.\n      *\n      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n+     * @param parentMock The parent of the current deep stub mock.\n      * @return The mock\n      */\n-    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {\n+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);\n         return mockitoCore().mock(\n                 returnTypeGenericMetadata.rawType(),\n-                withSettingsUsing(returnTypeGenericMetadata)\n+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)\n         );\n     }\n \n-    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                 : withSettings();\n \n-        return mockSettings\n-\t\t        .serializable()\n+        return propagateSerializationSettings(mockSettings, parentMockSettings)\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n+    }\n+\n+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {\n+        return mockSettings.serializable(parentMockSettings.getSerializableMode());\n     }\n \n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/DeepStubsWronglyReportsSerializationProblemsTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * In GH issue 99 : https://github.com/mockito/mockito/issues/99\n+ */\n+public class DeepStubsWronglyReportsSerializationProblemsTest {\n+\n+    @Test\n+    public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {\n+        NotSerializableShouldBeMocked the_deep_stub = mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething();\n+        assertThat(the_deep_stub).isNotNull();\n+    }\n+\n+    public static class ToBeDeepStubbed {\n+        public ToBeDeepStubbed() { }\n+\n+        public NotSerializableShouldBeMocked getSomething() {\n+            return null;\n+        }\n+    }\n+\n+    public static class NotSerializableShouldBeMocked {\n+        NotSerializableShouldBeMocked(String mandatory_param) { }\n+    }\n+\n+}", "timestamp": 1412901883, "metainfo": ""}