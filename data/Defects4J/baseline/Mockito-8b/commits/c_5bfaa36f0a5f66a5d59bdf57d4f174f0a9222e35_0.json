{"sha": "5bfaa36f0a5f66a5d59bdf57d4f174f0a9222e35", "log": "Finished the MockMaker interface and other related APIs to the shape that is good enough for the release. There're still some things pending for refactoring but at least I'm happy with the API. I dropped a tiny bit of unit testing coverage (it's still covered in integ tests).", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n package org.mockito;\n \n import org.mockito.listeners.InvocationListener;\n-import org.mockito.mock.MockSettingsInfo;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n  * Firstly, to make it easy to add another mock setting when the demand comes.\n  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n  */\n-public interface MockSettings extends Serializable, MockSettingsInfo {\n+public interface MockSettings extends Serializable {\n \n     /**\n      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n import org.mockito.invocation.Invocation;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.invocation.MockitoInvocationHandler;\n-import org.mockito.mock.MockSettingsInfo;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n     private List<InvocationListener> invocationListeners;\n     private MockHandler<T> mockHandler;\n \n-    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsInfo settings) {\n+    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockCreationSettings settings) {\n         this.mockHandler = mockHandler;\n         this.invocationListeners = settings.getInvocationListeners();\n     }\n         }\n \t}\n \n-    public MockSettingsInfo getMockSettings() {\n+    public MockCreationSettings getMockSettings() {\n         return mockHandler.getMockSettings();\n     }\n \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.invocation.Invocation;\n-import org.mockito.mock.MockSettingsInfo;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n     MatchersBinder matchersBinder = new MatchersBinder();\n     MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n \n-    private final MockSettingsInfo mockSettings;\n+    private final MockCreationSettings mockSettings;\n \n-    public MockHandler(MockSettingsInfo mockSettings) {\n+    public MockHandler(MockCreationSettings mockSettings) {\n         this.mockSettings = mockSettings;\n         this.mockingProgress = new ThreadSafeMockingProgress();\n         this.matchersBinder = new MatchersBinder();\n         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n     }\n \n-    public MockSettingsInfo getMockSettings() {\n+    public MockCreationSettings getMockSettings() {\n         return mockSettings;\n     }\n \n--- a/src/org/mockito/internal/MockHandlerInterface.java\n+++ b/src/org/mockito/internal/MockHandlerInterface.java\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.invocation.Invocation;\n import org.mockito.invocation.MockitoInvocationHandler;\n-import org.mockito.mock.MockSettingsInfo;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n @SuppressWarnings(\"unchecked\")\n public interface MockHandlerInterface<T> extends MockitoInvocationHandler {\n \n-    MockSettingsInfo getMockSettings();\n+    MockCreationSettings getMockSettings();\n \n     VoidMethodStubbable<T> voidMethodStubbable(T mock);\n     \n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n import org.mockito.InOrder;\n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.stubbing.*;\n import org.mockito.verification.VerificationMode;\n \n     private final MockUtil mockUtil = new MockUtil();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n-    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n-        T mock = mockUtil.createMock(classToMock, mockSettings);\n-        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n+    public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n+        if (!MockSettingsImpl.class.isInstance(settings)) {\n+            throw new IllegalArgumentException(\n+                    \"Unexpected implementation of '\" + settings.getClass().getCanonicalName() + \"'\\n\"\n+                    + \"At the moment, you cannot provide your own implementations that class.\");\n+        }\n+        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);\n+        MockCreationSettings<T> creationSettings = impl.confirm(typeToMock);\n+        T mock = mockUtil.createMock(creationSettings);\n+        mockingProgress.mockingStarted(mock, typeToMock, settings); //TODO SF review if we need to pass it\n         return mock;\n     }\n     \n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n import org.mockito.cglib.proxy.Factory;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.MockHandlerInterface;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.plugins.MockMaker;\n import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n-import org.mockito.mock.MockSettingsInfo;\n \n import java.util.Set;\n \n  */\n public final class CglibMockMaker implements MockMaker {\n \n-    public <T> T createMock(Class<T> typeToMock, Set<Class> extraInterfaces,\n-            MockitoInvocationHandler handler, MockSettingsInfo settings) {\n+    public <T> T createMock(MockCreationSettings<T> settings, MockitoInvocationHandler handler) {\n         MockHandlerInterface mockitoHandler = cast(handler);\n         return ClassImposterizer.INSTANCE.imposterise(\n-                new MethodInterceptorFilter(mockitoHandler, settings), typeToMock, extraInterfaces);\n+                new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n     }\n \n     private MockHandlerInterface cast(MockitoInvocationHandler handler) {\n         return (MockHandlerInterface) handler;\n     }\n \n-    public void resetMock(Object mock, MockitoInvocationHandler newHandler, MockSettingsInfo settings) {\n+    public void resetMock(Object mock, MockitoInvocationHandler newHandler, MockCreationSettings settings) {\n         ((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));\n     }\n \n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.util.ObjectMethodsGuru;\n-import org.mockito.mock.MockSettingsInfo;\n+import org.mockito.mock.MockCreationSettings;\n \n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private final MockHandlerInterface handler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n-    private final MockSettingsInfo mockSettings;\n+    private final MockCreationSettings mockSettings;\n \n-    public MethodInterceptorFilter(MockHandlerInterface handler, MockSettingsInfo mockSettings) {\n+    public MethodInterceptorFilter(MockHandlerInterface handler, MockCreationSettings mockSettings) {\n         this.handler = handler;\n         this.mockSettings = mockSettings;\n     }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n-import org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations;\n+import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockNameImpl;\n+import org.mockito.internal.util.MockitoSpy;\n import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n import org.mockito.stubbing.Answer;\n \n-import java.util.ArrayList;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.io.Serializable;\n+import java.util.*;\n \n import static org.mockito.internal.util.collections.Sets.newSet;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockSettingsImpl implements MockSettings {\n+public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSettings, MockCreationSettings<T> {\n \n     private static final long serialVersionUID = 4475297236197939568L;\n-    private Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n-    private String name;\n-    private Object spiedInstance;\n-    private Answer<Object> defaultAnswer;\n-    private MockName mockName;\n-    private boolean serializable;\n-    private List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public MockSettings serializable() {\n         this.serializable = true;\n     }\n \n     public MockName getMockName() {\n-        return mockName;\n-    }\n-\n-    public MockName mockName() {\n         return mockName;\n     }\n \n \n     public boolean isSerializable() {\n         return serializable;\n-    }\n-\n-    public void initiateMockName(Class classToMock) {\n-        mockName = new MockNameImpl(name, classToMock);\n     }\n \n \tpublic MockSettings verboseLogging() {\n         return this.invocationListeners;\n     }\n \n-    public boolean containsInvocationListener(InvocationListener invocationListener) {\n-        return invocationListeners.contains(invocationListener);\n-    }\n-\n     public boolean hasInvocationListeners() {\n         return !invocationListeners.isEmpty();\n     }\n \n-    public void redefineMockName(String newName) {\n-        mockName = new MockNameImpl(newName);\n+    public Class<T> getTypeToMock() {\n+        return typeToMock;\n+    }\n+\n+    public MockCreationSettings<T> confirm(Class<T> typeToMock) {\n+        return validatedSettings(typeToMock, this);\n+    }\n+\n+    private static <T> CreationSettings<T> validatedSettings(Class<T> typeToMock, CreationSettings<T> source) {\n+        MockCreationValidator validator = new MockCreationValidator();\n+\n+        validator.validateType(typeToMock);\n+        validator.validateExtraInterfaces(typeToMock, source.getExtraInterfaces());\n+        validator.validateMockedType(typeToMock, source.getSpiedInstance());\n+\n+        //TODO SF - add this validation and also add missing coverage\n+//        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n+\n+        CreationSettings<T> settings = new CreationSettings<T>(source);\n+        settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n+        settings.setTypeToMock(typeToMock);\n+        settings.setExtraInterfaces(prepareExtraInterfaces(source));\n+        return settings;\n+    }\n+\n+    private static Set<Class> prepareExtraInterfaces(CreationSettings settings) {\n+        Set<Class> interfaces = new HashSet<Class>(settings.getExtraInterfaces());\n+        if(settings.isSerializable()) {\n+            interfaces.add(Serializable.class);\n+        }\n+        if (settings.getSpiedInstance() != null) {\n+            interfaces.add(MockitoSpy.class);\n+        }\n+        return interfaces;\n     }\n }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n+package org.mockito.internal.creation.settings;\n+\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * by Szczepan Faber, created at: 4/9/12\n+ */\n+public class CreationSettings<T> implements MockCreationSettings<T>, Serializable {\n+\n+    protected Class<T> typeToMock;\n+    protected Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n+    protected String name;\n+    protected Object spiedInstance;\n+    protected Answer<Object> defaultAnswer;\n+    protected MockName mockName;\n+    protected boolean serializable;\n+    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n+\n+    public CreationSettings() {}\n+\n+    public CreationSettings(CreationSettings copy) {\n+        this.typeToMock = copy.typeToMock;\n+        this.extraInterfaces = copy.extraInterfaces;\n+        this.name = copy.name;\n+        this.spiedInstance = copy.spiedInstance;\n+        this.defaultAnswer = copy.defaultAnswer;\n+        this.mockName = copy.mockName;\n+        this.serializable = copy.serializable;\n+        this.invocationListeners = copy.invocationListeners;\n+    }\n+\n+    public Class<T> getTypeToMock() {\n+        return typeToMock;\n+    }\n+\n+    public CreationSettings<T> setTypeToMock(Class<T> typeToMock) {\n+        this.typeToMock = typeToMock;\n+        return this;\n+    }\n+\n+    public Set<Class> getExtraInterfaces() {\n+        return extraInterfaces;\n+    }\n+\n+    public CreationSettings<T> setExtraInterfaces(Set<Class> extraInterfaces) {\n+        this.extraInterfaces = extraInterfaces;\n+        return this;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Object getSpiedInstance() {\n+        return spiedInstance;\n+    }\n+\n+    public Answer<Object> getDefaultAnswer() {\n+        return defaultAnswer;\n+    }\n+\n+    public MockName getMockName() {\n+        return mockName;\n+    }\n+\n+    public CreationSettings<T> setMockName(MockName mockName) {\n+        this.mockName = mockName;\n+        return this;\n+    }\n+\n+    public boolean isSerializable() {\n+        return serializable;\n+    }\n+\n+    public List<InvocationListener> getInvocationListeners() {\n+        return invocationListeners;\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n-import org.mockito.mock.MockSettingsInfo;\n import org.mockito.plugins.MockMaker;\n \n import java.io.Serializable;\n public class MockUtil {\n \n     private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n-    private final MockCreationValidator creationValidator;\n \n-    public MockUtil(MockCreationValidator creationValidator) {\n-        this.creationValidator = creationValidator;\n-    }\n-\n-    public MockUtil() {\n-        this(new MockCreationValidator());\n-    }\n-\n-    public <T> T createMock(Class<T> classToMock, MockSettingsInfo settingsInfo) {\n-        MockSettingsImpl settings = (MockSettingsImpl) settingsInfo;\n-        creationValidator.validateType(classToMock);\n-        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n-        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n-        //TODO SF - add this validation and also add missing coverage\n-//        creationValidator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance()) ;\n-\n-        settings.initiateMockName(classToMock);\n-\n+    public <T> T createMock(MockCreationSettings<T> settings) {\n         InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n                 new MockHandler<T>(settings), settings);\n-        Set<Class> extraInterfaces = prepareAncillaryTypes(settings);\n-        T mock = mockMaker.createMock(classToMock, extraInterfaces, mockHandler, settings);\n+        T mock = mockMaker.createMock(settings, mockHandler);\n \n         Object spiedInstance = settings.getSpiedInstance();\n         if (spiedInstance != null) {\n         return mock;\n     }\n \n-    private Set<Class> prepareAncillaryTypes(MockSettingsImpl settings) {\n-        Set<Class> interfaces = settings.getExtraInterfaces();\n-\n-        Set<Class> ancillaryTypes = new HashSet<Class>(interfaces);\n-        if(settings.isSerializable()) {\n-            ancillaryTypes.add(Serializable.class);\n-        }\n-        if (settings.getSpiedInstance() != null) {\n-            ancillaryTypes.add(MockitoSpy.class);\n-        }\n-        return ancillaryTypes;\n-    }\n-\n     public <T> void resetMock(T mock) {\n         InvocationNotifierHandler oldHandler = (InvocationNotifierHandler) getMockHandler(mock);\n-        MockSettingsInfo settings = oldHandler.getMockSettings();\n+        MockCreationSettings settings = oldHandler.getMockSettings();\n         InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n                 new MockHandler<T>(settings), settings);\n         mockMaker.resetMock(mock, newHandler, settings);\n     }\n \n     public void maybeRedefineMockName(Object mock, String newName) {\n-        if (getMockName(mock).isDefault()) {\n-            getMockHandler(mock).getMockSettings().redefineMockName(newName);\n+        MockName mockName = getMockName(mock);\n+        //TODO SF hacky...\n+        if (mockName.isDefault() && getMockHandler(mock).getMockSettings() instanceof CreationSettings) {\n+            ((CreationSettings) getMockHandler(mock).getMockSettings()).setMockName(new MockNameImpl(newName));\n         }\n     }\n }\n--- a/src/org/mockito/invocation/MockitoInvocationHandler.java\n+++ b/src/org/mockito/invocation/MockitoInvocationHandler.java\n  * Mockito handler of an invocation on a mock. This is a core part of the API, the heart of Mockito.\n  * See also the {@link org.mockito.plugins.MockMaker}.\n  * <p>\n- * This api is work in progress, hence a marker interface.\n+ * This api is work in progress, hence a marker interface. Do not provide your own implementations.\n+ * Mockito will provide you with the implementation via other {@link org.mockito.plugins.MockMaker} methods.\n  */\n @Incubating\n public interface MockitoInvocationHandler extends Serializable {}\n--- /dev/null\n+++ b/src/org/mockito/mock/MockCreationSettings.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.mock;\n+\n+import org.mockito.Incubating;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Informs about the mock settings. An immutable view of {@link org.mockito.MockSettings}.\n+ */\n+@Incubating\n+public interface MockCreationSettings<T> {\n+\n+    /**\n+     * Mocked type. An interface or class the mock should implement / extend.\n+     */\n+    Class<T> getTypeToMock();\n+\n+    /**\n+     * the extra interfaces the mock object should implement.\n+     */\n+    Set<Class> getExtraInterfaces();\n+\n+    /**\n+     * the name of this mock, as printed on verification errors; see {@link org.mockito.MockSettings#name}.\n+     */\n+    MockName getMockName();\n+\n+    /**\n+     * the default answer for this mock, see {@link org.mockito.MockSettings#defaultAnswer}.\n+     */\n+    Answer getDefaultAnswer();\n+\n+    /**\n+     * the spied instance - needed for spies.\n+     */\n+    Object getSpiedInstance();\n+\n+    /**\n+     * if the mock is serializable, see {@link org.mockito.MockSettings#serializable}.\n+     */\n+    boolean isSerializable();\n+\n+    /**\n+     * the invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n+     */\n+    List<InvocationListener> getInvocationListeners();\n+}\n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n \n import org.mockito.Incubating;\n import org.mockito.invocation.MockitoInvocationHandler;\n-import org.mockito.mock.MockSettingsInfo;\n+import org.mockito.mock.MockCreationSettings;\n \n import java.util.Set;\n \n  * <p>Note that if several <code>mockito-extensions/org.mockito.plugins.MockMaker</code> files exists in the classpath\n  * Mockito will only use the first returned by the standard {@link ClassLoader#getResource} mechanism.\n  *\n- * @see org.mockito.mock.MockSettingsInfo\n+ * @see org.mockito.mock.MockCreationSettings\n  * @see org.mockito.invocation.MockitoInvocationHandler\n  * @since 1.9.5\n  */\n     /**\n      * If you want to provide your own implementation of {@code MockMaker} this method should:\n      * <ul>\n-     *     <li>Create a proxy object that implements {@code typeToMock} and potentially also {@code extraInterfaces}.</li>\n-     *     <li>You may use the information from {@code settings} to configure your proxy object.</li>\n+     *     <li>Create a proxy object that implements {@code settings.typeToMock} and potentially also {@code settings.extraInterfaces}.</li>\n+     *     <li>You may use the information from {@code settings} to create/configure your proxy object.</li>\n      *     <li>Your proxy object should carry the {@code hander} with it. For example, if you generate byte code\n      *     to create the proxy you could generate an extra field to keep the {@code hanlder} with the generated object.\n      *     Your implementation of {@code MockHandler} is required to provide this instance of {@code handler} when\n      *     </li>\n      * </ul>\n      *\n-     * @param typeToMock The type of the mock, could be a <strong>class</strong> or an <strong>interface</strong>.\n-     * @param extraInterfaces Interfaces the mock should implements as well,\n-     *                        never <code>null</code>, interfaces only (no classes).\n+     * @param settings - mock creation settings like type to mock, extra interfaces and so on.\n      * @param handler See {@link MockitoInvocationHandler}.\n      *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of\n      *                {@link #getHandler(Object)} will return this instance.\n-     * @param settings Mock creation settings.\n-     * @param <T> Type of the mock to return, actually the <code>typeToMock</code>.\n+     * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.\n      * @return The mock instance.\n      * @since 1.9.5\n      */\n     <T> T createMock(\n-            Class<T> typeToMock,\n-            Set<Class> extraInterfaces,\n-            MockitoInvocationHandler handler,\n-            MockSettingsInfo settings\n+            MockCreationSettings<T> settings,\n+            MockitoInvocationHandler handler\n     );\n \n     /**\n     void resetMock(\n             Object mock,\n             MockitoInvocationHandler newHandler,\n-            MockSettingsInfo settings\n+            MockCreationSettings settings\n     );\n }\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n             Assertions.assertThat(e.getMessage()).contains(\"does not accept null\");\n         }\n     }\n-\n-    @Test\n-    public void should_redefine_mockName() throws Exception {\n-        mockSettingsImpl.redefineMockName(\"my name is ...\");\n-\n-        assertEquals(\"my name is ...\", mockSettingsImpl.getMockName().toString());\n-    }\n-\n-    private InvocationListener getListener(MockSettingsImpl settings) {\n-    \treturn settings.getInvocationListeners().iterator().next();\n-    }\n-    \n }\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n     \n-    public class CreationValidatorStub extends MockCreationValidator {\n-        private boolean extraInterfacesValidated;\n-        private boolean typeValidated;\n-        public void validateType(Class classToMock) {\n-            typeValidated = true;\n-        }\n-        public void validateExtraInterfaces(Class classToMock, Collection<Class> interfaces) {\n-            extraInterfacesValidated = true;\n-        }\n-    }\n+    private MockUtil mockUtil = new MockUtil();\n \n-    private CreationValidatorStub creationValidator = new CreationValidatorStub();\n-    private MockUtil mockUtil = new MockUtil(creationValidator);\n-\n-    @Test \n-    public void shouldValidate() {\n-        //given\n-        assertFalse(creationValidator.extraInterfacesValidated);\n-        assertFalse(creationValidator.typeValidated);\n-\n-        //when\n-        mockUtil.createMock(IMethods.class, new MockSettingsImpl());\n-        \n-        //then\n-        assertTrue(creationValidator.extraInterfacesValidated);\n-        assertTrue(creationValidator.typeValidated);\n-    }\n-\n-    @Test \n+    @Test\n     public void shouldGetHandler() {\n         List mock = Mockito.mock(List.class);\n         assertNotNull(mockUtil.getMockHandler(mock));", "timestamp": 1334523171, "metainfo": ""}