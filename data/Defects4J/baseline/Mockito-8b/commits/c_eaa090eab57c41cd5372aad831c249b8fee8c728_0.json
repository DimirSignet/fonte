{"sha": "eaa090eab57c41cd5372aad831c249b8fee8c728", "log": "tweaked javadoc + renamed \"from\" static factory to \"inferFrom\"", "commit": "\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n \n     public GenericMetadataSupport getMockitoGenericMetadata() {\n         if (mockitoGenericMetadata == null) {\n-            this.mockitoGenericMetadata = GenericMetadataSupport.from(typeToMock);\n+            this.mockitoGenericMetadata = GenericMetadataSupport.inferFrom(typeToMock);\n         }\n         return mockitoGenericMetadata;\n     }\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n  * <p>\n  *     Hence :\n  *     <ul>\n- *         <li>the metadata is created using the {@link #from(Type)} method from a real\n+ *         <li>the metadata is created using the {@link #inferFrom(Type)} method from a real\n  *         Class or from a ParameterizedType, other types are not yet supported.</li>\n  *\n  *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n  * }\n  * </code></pre>\n  *\n- * @see #from(Type)\n+ * @see #inferFrom(Type)\n  * @see #resolveGenericReturnType(Method)\n  * @see #toMock(Answer)\n  * @see org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubs\n     }\n \n     /**\n-     * Create an new GenericMetadataSupport from a {@link Type}.\n+     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n      *\n      * <p>\n-     *     Supports only {@link Class} and {@link ParameterizedType}, otherwise throw a {@link MockitoException}.\n+     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n+     *     it'll throw a {@link MockitoException}.\n      * </p>\n      *\n      * @param type The class from which the {@link GenericMetadataSupport} should be built.\n      * @return The new {@link GenericMetadataSupport}.\n      * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n      */\n-    public static GenericMetadataSupport from(Type type) {\n+    public static GenericMetadataSupport inferFrom(Type type) {\n         Checks.checkNotNull(type, \"type\");\n         if (type instanceof Class) {\n             return new FromClassGenericMetadataSupport((Class<?>) type);\n     }\n \n \n-    /**\n-     * Metadata for source {@link Class}\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Generic metadata implementation for {@link Class}.\n+     *\n+     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n+     * the class and its ancestors and interfaces.\n      */\n     private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n         private Class<?> clazz;\n \n \n     /**\n-     * Metadata for source {@link ParameterizedType}.\n-     * Don't work with ParameterizedType returned in {@link Method#getGenericReturnType()}.\n+     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n+     *\n+     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\n+     * the related raw type and declared type variable of this parameterized type.\n+     *\n+     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\n+     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\n+     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n+     * Instead use {@link ParameterizedReturnType}.\n      */\n     private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n         private ParameterizedType parameterizedType;\n \n \n     /**\n-     * Metadata specific to {@link ParameterizedType} generic return types.\n+     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n      */\n     private static class ParameterizedReturnType extends GenericMetadataSupport {\n         private final ParameterizedType parameterizedType;\n \n \n     /**\n-     * Metadata specific to {@link TypeVariable} generic return type.\n+     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n      */\n     private static class TypeVariableReturnType extends GenericMetadataSupport {\n         private final TypeVariable typeVariable;\n \n \n     /**\n-     * Metadata specific to {@link Class} return type.\n+     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\n      */\n     private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n         private final Class<?> returnType;\n--- a/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.fail;\n import static org.mockito.Mockito.RETURNS_DEFAULTS;\n-import static org.mockito.internal.util.reflection.GenericMetadataSupport.from;\n+import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;\n \n @SuppressWarnings(\"unused\")\n public class GenericMetadataSupportTest {\n \n     @Test\n     public void can_get_raw_type_from_Class() throws Exception {\n-        assertThat(from(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n-        assertThat(from(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n-        assertThat(from(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+        assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n+        assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n+        assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n     }\n \n \n     @Test\n     public void can_get_raw_type_from_ParameterizedType() throws Exception {\n-        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n-        assertThat(from(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n-        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n     }\n \n     @Test\n     public void can_get_type_variables_from_Class() throws Exception {\n-        assertThat(from(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"K\");\n-        assertThat(from(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();\n-        assertThat(from(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n-        assertThat(from(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n-        assertThat(from(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"K\");\n+        assertThat(inferFrom(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n+        assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n     }\n \n     @Test\n     public void can_get_type_variables_from_ParameterizedType() throws Exception {\n-        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n-        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n-        assertThat(from(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n-        assertThat(from(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n+        assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n+        assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n     }\n \n     @Test\n     public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n         assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n \n     @Test\n     public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n-        GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));\n         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n     }\n \n     @Test\n     public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n         assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n \n     @Test\n     public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);\n-        GenericMetadataSupport fromTypeVariableE = from(typeVariableValue(genericMetadata.actualTypeArguments(), \"E\"));\n+        GenericMetadataSupport fromTypeVariableE = inferFrom(typeVariableValue(genericMetadata.actualTypeArguments(), \"E\"));\n         assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);\n         assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);\n     }\n \n     @Test\n     public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramType_with_type_params\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramType_with_type_params\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n         Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n-        assertThat(from(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n+        assertThat(inferFrom(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n     }\n \n     @Test\n     public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVar_with_type_params\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVar_with_type_params\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n-        GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));\n         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n     }\n \n     @Test\n     public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n         assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n \n     @Test\n     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n         GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n \n     @Test\n     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_lower_bound\", GenericsNest.class));\n-\n-        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n-\n-        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n         assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }\n \n     @Test\n     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_upper_bound\", GenericsNest.class));\n-\n-        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n-\n-        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_upper_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n         assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);\n     }\n \n \n     @Test(expected = MockitoException.class)\n     public void toMock_propagate_MockitoException_if_type_unmockable() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n-\n-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n-\n-        from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        inferFrom(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);\n     }\n \n     @Test\n     public void toMock_returns_mock_of_correct_type() throws Exception {\n-        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n \n         assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Comparable.class);\n         assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Cloneable.class);", "timestamp": 1351119144, "metainfo": ""}