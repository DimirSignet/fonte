{"sha": "b64e775eadf52a3f3881d39a963fcb23adde4fa8", "log": "An even better javadoc, with syntax highlighting where applicable (transplanted from 0176ba6b37f5790f18652d49a34be047177c7c63)  --HG-- branch : 1.9-rc1 rename : img/logo.jpg => javadoc/img/logo.jpg extra : transplant_source : %01v%BAk7%F5y%0F%18e-I%A3K%E0G%17%7C%7Cc", "commit": "\n--- a/src/org/mockito/AdditionalMatchers.java\n+++ b/src/org/mockito/AdditionalMatchers.java\n  * <p>\n  * Example of using logical and(), not(), or() matchers: \n  *  \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   //anything but not \"ejb\"\n  *   mock.someMethod(not(eq(\"ejb\")));\n  *   \n  *   \n  *   //1 or 10\n  *   mock.someMethod(or(eq(1), eq(10)));\n- * </pre>\n+ * </code></pre>\n  * \n  * Scroll down to see all methods - full list of matchers.\n  */\n--- a/src/org/mockito/Answers.java\n+++ b/src/org/mockito/Answers.java\n  * You can use it to pass extra parameters to &#064;Mock annotation, see more info here: {@link Mock}\n  * <p>\n  * Example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   &#064;Mock(answer = RETURNS_DEEP_STUBS) UserProvider userProvider;\n- * </pre>\n+ * </code></pre>\n  * <b>This is not the full list</b> of Answers available in Mockito. Some interesting answers can be found in org.mockito.stubbing.answers package.\n  */\n public enum Answers {\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n  * For example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n  *   verify(mock).doSomething(argument.capture());\n  *   assertEquals(\"John\", argument.getValue().getName());\n- * </pre>\n+ * </code></pre>\n  *\n  * <p>\n  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n      * See issue 99.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n      *   verify(mock).doSomething(argument.capture());\n      *   assertEquals(\"John\", argument.getValue().getName());\n-     * </pre>\n+     * </code></pre>\n      */\n     @Deprecated\n     public ArgumentCaptor() {\n      * Returns all captured values. Use it in case the verified method was called multiple times.\n      * <p>\n      * Example: \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   ArgumentCaptor&lt;Person&gt; peopleCaptor = ArgumentCaptor.forClass(Person.class);\n      *   verify(mock, times(2)).doSomething(peopleCaptor.capture());\n      *   \n      *   List&lt;Person&gt; capturedPeople = peopleCaptor.getAllValues();\n      *   assertEquals(\"John\", capturedPeople.get(0).getName());\n      *   assertEquals(\"Jane\", capturedPeople.get(1).getName());\n-     * </pre>\n+     * </code></pre>\n      * See more examples in javadoc for {@link ArgumentCaptor} class.\n      * \n      * @return captured argument value\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n  * <p>\n  * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}, e.g:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n  *     public boolean matches(Object list) {\n  *         return ((List) list).size() == 2;\n  * mock.addAll(Arrays.asList(&quot;one&quot;, &quot;two&quot;));\n  * \n  * verify(mock).addAll(argThat(new IsListOfTwoElements()));\n- * </pre>\n+ * </code></pre>\n  * \n  * To keep it readable you may want to extract method, e.g:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n  *   //becomes\n  *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n- * </pre>\n+ * </code></pre>\n  *\n  * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n  * Sometimes it's better to implement equals() for arguments that are passed to mocks \n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!    \n  * <p>\n  * Here is how the test might look like: \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * import static org.mockito.BDDMockito.*;\n  * \n  * Seller seller = mock(Seller.class);\n  *   //then\n  *   assertThat(goods, containBread());\n  * }  \n- * </pre>\n+ * </code></pre>\n  * \n  * Stubbing voids with throwables:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   //given\n  *   willThrow(new RuntimeException(\"boo\")).given(mock).foo();\n  *   \n  *   \n  *   //then\n  *   assertEquals(failure, result);\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * One of the purposes of BDDMockito is also to show how to tailor the mocking syntax to a different programming style. \n  */\n--- a/src/org/mockito/Captor.java\n+++ b/src/org/mockito/Captor.java\n /**\n  * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n  * <p>Example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * public class Test{\n  *\n  *    &#64;Captor ArgumentCaptor&lt;AsyncCallback&lt;Foo&gt;&gt; captor;\n  *       assertEquals(\"foo\", captor.getValue());\n  *    }\n  * }\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n  */\n--- a/src/org/mockito/InOrder.java\n+++ b/src/org/mockito/InOrder.java\n /**\n  * Allows verification in order. E.g:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * InOrder inOrder = inOrder(firstMock, secondMock);\n  * \n  * inOrder.verify(firstMock).add(\"was called first\");\n  * inOrder.verify(secondMock).add(\"was called second\");\n- * </pre>\n+ * </code></pre>\n  * \n  * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}\n  * <p>\n      * Alias to <code>inOrder.verify(mock, times(1))</code>\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * InOrder inOrder = inOrder(firstMock, secondMock);\n      * \n      * inOrder.verify(firstMock).someMethod(\"was called first\");\n      * inOrder.verify(secondMock).someMethod(\"was called second\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n     /**\n      * Verifies interaction in order. E.g:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * InOrder inOrder = inOrder(firstMock, secondMock);\n      * \n      * inOrder.verify(firstMock, times(2)).someMethod(\"was called first two times\");\n      * inOrder.verify(secondMock, atLeastOnce()).someMethod(\"was called second at least once\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * Different from {@link Mockito#verifyNoMoreInteractions(Object...)} because the order of verification matters.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * mock.foo(); //1st\n      * mock.bar(); //2nd\n      * mock.baz(); //3rd\n      * \n      * //however this fails because 1st method was not verified:\n      * Mockito.verifyNoMoreInteractions(mock);\n-     * </pre>\n+     * </code></pre>\n      */\n     void verifyNoMoreInteractions();\n }\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  *\n  * <p>\n  * Example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManagerTest extends SampleBaseTestCase {\n  *\n  *       &#064;Mock private ArticleCalculator calculator;\n  *           MockitoAnnotations.initMocks(this);\n  *       }\n  *   }\n- * </pre>\n+ * </code></pre>\n  * </p>\n  *\n  * <p>\n  * However fields that are static or final will be ignored.</p>\n  *\n  * <p>So on the field that needs injection, for example constructor injection will happen here :</p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManager {\n  *       ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {\n  *           // parameterized constructor\n  *       }\n  *   }\n- * </pre>\n+ * </code></pre>\n  *\n  * <p>Property setter injection will happen here :</p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManager {\n  *       ArticleManager() {\n  *           // no-arg constructor\n  *           // setter\n  *       }\n  *   }\n- * </pre>\n+ * </code></pre>\n  *\n  * <p>Field injection will be used here :</p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManager {\n  *       private ArticleDatabase database;\n  *       private ArticleCalculator calculator;\n  *   }\n- * </pre>\n+ * </code></pre>\n  * </p>\n  *\n  * <p>And finally, no injection will happen on the type in this case:</p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManager {\n  *       private ArticleDatabase database;\n  *       private ArticleCalculator calculator;\n  *           // flag is not mockable anyway\n  *       }\n  *   }\n- * </pre>\n+ * </code></pre>\n  * </p>\n  *\n  *\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n  * <p>\n  * {@link Mockito} extends Matchers so to get access to all matchers just import Mockito class statically.\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *  //stubbing using anyInt() argument matcher\n  *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n  *  \n  *  \n  *  //you can also verify using argument matcher\n  *  verify(mockedList).get(anyInt());\n- * </pre>\n+ * </code></pre>\n  * Scroll down to see all methods - full list of matchers.\n  * <p>\n  * <b>Warning:</b>\n  * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n  * <p>\n  * E.g: (example shows verification but the same applies to stubbing):\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n  *   //above is correct - eq() is also an argument matcher\n  *   \n  *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n  *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n  * Internally, they record a matcher on a stack and return a dummy value (usually null).\n  * <p>\n  * Example:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   class IsListOfTwoElements extends ArgumentMatcher&lt;List&gt; {\n  *      public boolean matches(Object list) {\n  *          return ((List) list).size() == 2;\n  *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n  *   \n  *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n- * </pre>\n+ * </code></pre>\n  * \n  * To keep it readable you may want to extract method, e.g:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   verify(mock).addAll(<b>argThat(new IsListOfTwoElements())</b>);\n  *   //becomes\n  *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n- * </pre>\n+ * </code></pre>\n  *\n  * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n  * Sometimes it's better to implement equals() for arguments that are passed to mocks \n      * Any vararg, meaning any number and values of arguments.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   //verification:\n      *   mock.foo(1, 2);\n      *   mock.foo(1, 2, 3, 4);\n      *   System.out.println(mock.foo(1, 2));\n      *   //also prints 100\n      *   System.out.println(mock.foo(1, 2, 3, 4));\n-     * </pre>\n+     * </code></pre>\n      * See examples in javadoc for {@link Matchers} class\n      *\n      * @return <code>null</code>.\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n  * <li>Makes the verification error easier to read because the <b>field name</b> is used to identify the mock.</li>\n  * </ul>\n  *\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManagerTest extends SampleBaseTestCase {\n  *\n  *       &#064;Mock private ArticleCalculator calculator;\n  *           MockitoAnnotations.initMocks(this);\n  *       }\n  *   }\n- * </pre>\n+ * </code></pre>\n  *\n  * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated mocks.\n  * <p>\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n  * If you cannot write a test in a simple way - refactor the code under test.\n  * <p>\n  * Examples of mock settings:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   //Creates mock with different default answer & name\n  *   Foo mock = mock(Foo.class, withSettings()\n  *       .defaultAnswer(RETURNS_SMART_NULLS)\n  *       .defaultAnswer(RETURNS_SMART_NULLS)\n  *       .name(\"cool mockie\")\n  *       .extraInterfaces(Bar.class));    \n- * </pre>\n+ * </code></pre>\n  * {@link MockSettings} has been introduced for two reasons. \n  * Firstly, to make it easy to add another mock setting when the demand comes.\n  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n      * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n      * <p>   \n      * Examples:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n      *   \n      *   //now, the mock implements extra interfaces, so following casting is possible:\n      *   Bar bar = (Bar) foo;\n      *   Baz baz = (Baz) foo;\n-     * </pre>\n+     * </code></pre>\n      * \n      * @param interfaces extra interfaces the should implement.\n      * @return settings instance so that you can fluently specify other settings\n      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n      * <p>\n      * Examples:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n      *   \n      *   //Below does exactly the same:\n      *   Foo foo = mock(Foo.class, \"foo\");\n-     * </pre>\n+     * </code></pre>\n      * @param name the name of the mock, later used in all verification errors\n      * @return settings instance so that you can fluently specify other settings\n      */\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Enough warnings about partial mocks, see an example how spiedInstance() works:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, spiedInstance(fooInstance));\n      *   \n      *   //Below does exactly the same:\n      *   Foo foo = spy(fooInstance);\n-     * </pre>\n+     * </code></pre>\n      * \n      * @param instance to spy on\n      * @return settings instance so that you can fluently specify other settings\n      * <p>\n      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n      *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n      *   \n      *   //Below does exactly the same:\n      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n-     * </pre>\n+     * </code></pre>\n      * \n      * @param defaultAnswer default answer to be used by mock when not stubbed\n      * @return settings instance so that you can fluently specify other settings\n      * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   List serializableMock = mock(List.class, withSettings().serializable());\n-     * </pre>\n+     * </code></pre>\n      *\n      * @return settings instance so that you can fluently specify other settings\n      */\n      * Calling this method multiple times makes no difference.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n-     * </pre>\n+     * </code></pre>\n      * \n      * @return settings instance so that you can fluently specify other settings\n      */\n      * order in which the listeners are notified. \n      * \n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n-     * </pre>\n+     * </code></pre>\n      * \n      * See the {@link InvocationListener listener interface} for more details.\n      * \n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * \n  * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //Let's import Mockito statically so that the code looks clearer\n  * import static org.mockito.Mockito.*;\n  * \n  * //verification\n  * verify(mockedList).add(\"one\");\n  * verify(mockedList).clear();\n- * </pre>\n+ * </code></pre>\n  * \n  * <p>\n  * Once created, mock will remember all interactions. Then you can selectively\n  * \n  * <h3 id=\"2\">2. How about some stubbing?</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //You can mock concrete classes, not only interfaces\n  * LinkedList mockedList = mock(LinkedList.class);\n  * \n  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n  * verify(mockedList).get(0);\n- * </pre>\n+ * </code></pre>\n  * \n  * <ul>\n  * <li> By default, for all methods that return value, mock returns null, an\n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n  * Sometimes, when extra flexibility is required then you might use argument matchers:  \n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //stubbing using built-in anyInt() argument matcher\n  * when(mockedList.get(anyInt())).thenReturn(\"element\");\n  * \n  * \n  * //<b>you can also verify using an argument matcher</b>\n  * verify(mockedList).get(anyInt());\n- * </pre>\n+ * </code></pre>\n  * \n  * <p>\n  * Argument matchers allow flexible verification or stubbing. \n  * <p>\n  * E.g: (example shows verification but the same applies to stubbing):\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n  *   //above is correct - eq() is also an argument matcher\n  *   \n  *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n- * </pre>\n+ * </code></pre>\n  * \n  * <p>\n  * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n  * \n  * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //using mock \n  * mockedList.add(\"once\");\n  * \n  * verify(mockedList, atLeast(2)).add(\"five times\");\n  * verify(mockedList, atMost(5)).add(\"three times\");\n  * \n- * </pre>\n+ * </code></pre>\n  * \n  * <p>\n  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n  * \n  * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n  *   \n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n- * </pre>\n+ * </code></pre>\n  * \n  * Read more about doThrow|doAnswer family of methods in paragraph 12.\n  * <p>\n  * \n  * <h3 id=\"6\">6. Verification in order</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * // A. Single mock whose methods must be invoked in a particular order\n  * List singleMock = mock(List.class);\n  *\n  * inOrder.verify(secondMock).add(\"was called second\");\n  *\n  * // Oh, and A + B can be mixed together at will\n- * </pre>\n+ * </code></pre>\n  * \n  * Verification in order is flexible - <b>you don't have to verify all\n  * interactions</b> one-by-one but only those that you are interested in\n  * \n  * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //using mocks - only mockOne is interacted\n  * mockOne.add(\"one\");\n  * \n  * //verify that other mocks were not interacted\n  * verifyZeroInteractions(mockTwo, mockThree);\n  * \n- * </pre>\n+ * </code></pre>\n  * \n  * <h3 id=\"8\">8. Finding redundant invocations</h3>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //using mocks\n  * mockedList.add(\"one\");\n  * mockedList.add(\"two\");\n  * \n  * //following verification will fail \n  * verifyNoMoreInteractions(mockedList);\n- * </pre>\n+ * </code></pre>\n  * \n  * A word of <b>warning</b>: \n  * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.\n  * is used to identify the mock.</li>\n  * </ul>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManagerTest { \n  *     \n  *       &#064;Mock private ArticleCalculator calculator;\n  *       &#064;Mock private UserProvider userProvider;\n  *     \n  *       private ArticleManager manager;\n- * </pre>\n+ * </code></pre>\n  * \n  * <b>Important!</b> This needs to be somewhere in the base class or a test\n  * runner:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * MockitoAnnotations.initMocks(testClass);\n- * </pre>\n+ * </code></pre>\n  * \n  * You can use built-in runner: {@link MockitoJUnitRunner}.\n  * <p>\n  * though:\n  * <p>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(\"some arg\"))\n  *   .thenThrow(new RuntimeException())\n  *   .thenReturn(\"foo\");\n  * \n  * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n  * System.out.println(mock.someMethod(\"some arg\"));\n- * </pre>\n+ * </code></pre>\n  * \n  * Alternative, shorter version of consecutive stubbing:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(\"some arg\"))\n  *   .thenReturn(\"one\", \"two\", \"three\");\n- * </pre>\n+ * </code></pre>\n  * \n  * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n  * \n  * <code>thenThrow()</code> only. Those two should be <b>just enough</b> to test/test-drive\n  * any clean & simple code.\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n  *     Object answer(InvocationOnMock invocation) {\n  *         Object[] args = invocation.getArguments();\n  * \n  * //Following prints \"called with arguments: foo\"\n  * System.out.println(mock.someMethod(\"foo\"));\n- * </pre>\n+ * </code></pre>\n  * \n  * <h3 id=\"12\"> 12. <code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doReturn()</code> family of methods for stubbing voids (mostly)</h3>\n  * \n  * The main reason is improved readability and consistency with the family of <code>doAnswer()</code> methods.\n  * <p>\n  * Use <code>doThrow()</code> when you want to stub a void method with an exception:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n  *   \n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n- * </pre>\n+ * </code></pre>\n  * \n  * Read more about other methods:\n  * <p>\n  * >here</a>)\n  * <p>\n  *\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   List list = new LinkedList();\n  *   List spy = spy(list);\n  * \n  *   //optionally, you can verify\n  *   verify(spy).add(\"one\");\n  *   verify(spy).add(\"two\");\n- * </pre>\n+ * </code></pre>\n  * \n  * <h4>Important gotcha on spying real objects!</h4>\n  * <ol>\n  * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n  * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of methods for stubbing. Example:\n  *\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   List list = new LinkedList();\n  *   List spy = spy(list);\n  *\n  *\n  *   //You have to use doReturn() for stubbing\n  *   doReturn(\"foo\").when(spy).get(0);\n- * </pre>\n+ * </code></pre>\n  * </li>\n  *\n  * <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n  * <p>\n  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n  *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n- * </pre>\n+ * </code></pre>\n  * \n  * <p>\n  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n  * For example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n  *   verify(mock).doSomething(argument.c<code>apture()</code>);\n  *   assertEquals(\"John\", argument.g<code>etValue()</code>.g<code>etName()</code>);\n- * </pre>\n+ * </code></pre>\n  * \n  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n  *  <b>Before release 1.8</b> <code>spy()</code> was not producing real partial mocks and it was confusing for some users.\n  *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n  *  <p>\n- *  <pre>\n+ *  <pre class=\"code\"><code class=\"java\">\n  *    //you can create partial mock with spy() method:    \n  *    List list = spy(new LinkedList());\n  *    \n  *    //Be sure the real implementation is 'safe'.\n  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n  *    when(mock.someMethod()).thenCallRealMethod();\n- *  </pre>\n+ *  </code></pre>\n  *  \n  * As usual you are going to read <b>the partial mock warning</b>:\n  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n  * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n  * <p>\n  * <b>Don't harm yourself.</b> <code>reset()</code> in the middle of the test method is a code smell (you're probably testing too much).\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   List mock = mock(List.class);\n  *   when(mock.size()).thenReturn(10);\n  *   mock.add(1);\n  *   \n  *   reset(mock);\n  *   //at this point the mock forgot any interactions & stubbing\n- * </pre>\n+ * </code></pre>\n  *  \n  * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n  * \n  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \n  * <p>\n  * Here is how the test might look like: \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * import static org.mockito.BDDMockito.*;\n  * \n  * Seller seller = mock(Seller.class);\n  *   //then\n  *   assertThat(goods, containBread());\n  * }  \n- * </pre>\n+ * </code></pre>\n  * \n  * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n  * \n  * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \n  * <p>\n  * To create serializable mock use {@link MockSettings#serializable()}:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   List serializableMock = mock(List.class, withSettings().serializable());\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\n  * serialization requirements</a> are met by the class.\n  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \n  * which accepts MockSettings. No worries, you will hardly ever use it.\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();\n  * List&lt;Object&gt; spy = mock(ArrayList.class, withSettings()\n  *                 .spiedInstance(list)\n  *                 .defaultAnswer(CALLS_REAL_METHODS)\n  *                 .serializable());\n- * </pre>\n+ * </code></pre>\n  * \n  * <h3 id=\"21\">21. (**New**) New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </h3>\n  * <p>\n  * <p>\n  * Examples:\n  * <p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   //passes when someMethod() is called within given time span \n  *   verify(mock, timeout(100)).someMethod();\n  *   //above is an alias to:\n  *   //verifies someMethod() within given time span using given verification mode\n  *   //useful only if you have your own custom verification modes.\n  *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n- * </pre>\n+ * </code></pre>\n  *\n  * <h3 id=\"23\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9)</h3>\n  * <p>\n  * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)} or {@link MockitoJUnitRunner}.\n  * <p>\n  * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //instead:\n  * &#064;Spy BeerDrinker drinker = new BeerDrinker();\n  * //you can write:\n  *\n  * //same applies to &#064;InjectMocks annotation:\n  * &#064;InjectMocks LocalPub;\n- * </pre>\n+ * </code></pre>\n  *\n  * <h3 id=\"24\">24. (**New**) One-liner stubs (Since 1.9)</h3>\n  * <p>\n  * Basically, it allows to create a stub in one line of code.\n  * This can be helpful to keep test code clean.\n  * For example, some boring stub can be created & stubbed at field initialization in a test:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * public class CarTest {\n  *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();\n  *\n  *   &#064;Test public void should... {}\n- * </pre>\n+ * </code></pre>\n  *\n  * <h3 id=\"25\">25. Verification ignoring stubs (Since 1.9)</h3>\n  * <p>\n  * Bear in mind that Mockito does not recommend bombarding every test with <code>verifyNoMoreInteractions()</code>\n  * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}\n  * <p>Some examples:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * verify(mock).foo();\n  * verify(mockTwo).bar();\n  *\n  * inOrder.verify(mock).foo();\n  * inOrder.verify(mockTwo).bar();\n  * inOrder.verifyNoMoreInteractions();\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * Advanced examples and more details can be found in javadoc for {@link Mockito#ignoreStubs(Object...)}\n  */\n      * <code>ReturnsSmartNulls</code> will be probably the default return values strategy in Mockito 2.0.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\n      *   \n      *   //calling unstubbed method here:\n      *   //Above doesn't yield NullPointerException this time!\n      *   //Instead, SmartNullPointerException is thrown. \n      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n-     * </pre>\n+     * </code></pre>\n      */\n     public static final Answer<Object> RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS.get();\n     \n      * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}.\n      * <p>\n      * Example that shows how deep stub works:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);\n      *\n      *   // note that we're stubbing a chain of methods here: getBar().getName()\n      *\n      *   // note that we're chaining method calls: getBar().getName()\n      *   assertEquals(\"deep\", mock.getBar().getName());\n-     * </pre>\n+     * </code></pre>\n      * \n      * <strong>Verification API does not support 'chaining'</strong> so deep stub doesn't change how you do verification.\n      * <p>\n      * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>. \n      * <p>\n      * How deep stub work internally?\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   //this:\n      *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);\n      *   when(mock.getBar().getName(), \"deep\");\n      *   Bar bar = mock(Bar.class);\n      *   when(foo.getBar()).thenReturn(bar);\n      *   when(bar.getName()).thenReturn(\"deep\");\n-     * </pre>\n+     * </code></pre>\n      * <p>\n      * This feature will not work when any return type of methods included in the chain cannot be mocked\n      * (for example: is a primitive or a final class). This is because of java type system.   \n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);\n      *\n      * // this calls the real implementation of Foo.getSomething()\n      *\n      * // now fakeValue is returned\n      * value = mock.getSomething();\n-     * </pre>\n+     * </code></pre>\n      */\n     public static final Answer<Object> CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS.get();\n \n      * <p>\n      * Obviously return values are used only when you don't stub the method call.\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n      *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n-     * </pre>\n+     * </code></pre>\n      * \n      * <p>See examples in javadoc for {@link Mockito} class</p>\n      * \n      * <p>\n      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n-     * </pre>\n+     * </code></pre>\n      * \n      * <p>See examples in javadoc for {@link Mockito} class</p>\n      * \n      * The number of configuration points for a mock grows \n      * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \n      * Hence {@link MockSettings}.\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Listener mock = mock(Listener.class, withSettings()\n      *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n      *   );  \n-     * </pre>\n+     * </code></pre>\n      * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? \n      * Is the code under test so complicated that it requires non-standard mocks? \n      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n      * <p>\n      * Example:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n      * \n      *   //optionally, you can verify\n      *   verify(spy).add(\"one\");\n      *   verify(spy).add(\"two\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * <h4>Important gotcha on spying real objects!</h4>\n      * <ol>\n      * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n      * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of methods for stubbing. Example:\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n      *\n      *\n      *   //You have to use doReturn() for stubbing\n      *   doReturn(\"foo\").when(spy).get(0);\n-     * </pre>\n+     * </code></pre>\n      * </li>\n      *\n      * <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n     /**\n      * Stubs a method call with return value or an exception. E.g:\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stub(mock.someMethod()).toReturn(10);\n      *\n      * //you can use flexible argument matchers, e.g:\n      * stub(mock.someMethod(\"some arg\"))\n      *  .toThrow(new RuntimeException())\n      *  .toReturn(\"foo\");\n-     * </pre>\n+     * </code></pre>\n      * <p>\n      * Some users find stub() confusing therefore {@link Mockito#when(Object)} is recommended over stub()\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   //Instead of:\n      *   stub(mock.count()).toReturn(10);\n      * \n      *   //You can do:\n      *   when(mock.count()).thenReturn(10);\n-     * </pre> \n+     * </code></pre>\n      * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n      * <p>\n      * Stubbing can be overridden: for example common stubbing can go to fixture\n      * <p>\n      * Examples:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n      *\n      * //you can use flexible argument matchers, e.g:\n      * when(mock.someMethod(\"some arg\"))\n      *  .thenThrow(new RuntimeException(), new NullPointerException();\n      *   \n-     * </pre>\n+     * </code></pre>\n      * \n      * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n      * <p>\n      * Verifies certain behavior <b>happened once</b>.\n      * <p>\n      * Alias to <code>verify(mock, times(1))</code> E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * Above is equivalent to:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, times(1)).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * <p>\n      * Arguments passed are compared using <code>equals()</code> method.\n      * Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed.\n \n     /**\n      * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, times(5)).someMethod(\"was called five times\");\n      *\n      *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n      *\n      *   //you can use flexible argument matchers, e.g:\n      *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n-     * </pre>\n+     * </code></pre>\n      *\n      * <b>times(1) is the default</b> and can be omitted\n      * <p>\n      * or FAQ (<a href=\"http://code.google.com/p/mockito/wiki/FAQ\">here</a>).\n      * <p>\n      * <b>Don't harm yourself.</b> <code>reset()</code> in the middle of the test method is a code smell (you're probably testing too much).\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   List mock = mock(List.class);\n      *   when(mock.size()).thenReturn(10);\n      *   mock.add(1);\n      *\n      *   reset(mock);\n      *   //at this point the mock forgot any interactions & stubbing\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param <T>\n      * @param mocks to be reset\n      * <p>\n      * Example:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * //interactions\n      * mock.doSomething();\n      * mock.doSomethingUnexpected();\n      * //following will fail because 'doSomethingUnexpected()' is unexpected\n      * verifyNoMoreInteractions(mock);\n      * \n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n \n     /**\n      * Verifies that no interactions happened on given mocks.\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verifyZeroInteractions(mockOne, mockTwo);\n-     * </pre>\n+     * </code></pre>\n      * This method will also detect invocations \n      * that occurred before the test method, for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.\n      * Consider writing nice code that makes interactions only in test methods.  \n     }\n \n     /**\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   //Instead of:\n      *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n      * \n      *   //Please do:\n      *   doThrow(e).when(mock).someVoidMethod();\n-     * </pre> \n+     * </code></pre>\n      * \n      * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n      * <p>\n      * Originally, <code>stubVoid()</code> was used for stubbing void methods with exceptions. E.g:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n      * \n      * //you can stub with different behavior for consecutive calls.\n      *   .toThrow(new RuntimeException())\n      *   .toReturn()\n      *   .on().someMethod();\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * <p>\n      * Example:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * \n      * @param toBeThrown to be thrown when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      * <p>\n      * Example:\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(RuntimeException.class).when(mock).someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param toBeThrown to be thrown when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class);\n      *   doCallRealMethod().when(mock).someVoidMethod();\n      *\n      *   // this will call the real implementation of Foo.someVoidMethod()\n      *   mock.someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      *\n      * <p>\n      * Example:\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *  doAnswer(new Answer() {\n      *      public Object answer(InvocationOnMock invocation) {\n      *          Object[] args = invocation.getArguments();\n      *          return null;\n      *      }})\n      *  .when(mock).someMethod();\n-     * </pre>\n+     * </code></pre>\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * \n      * <p>\n      * <ol>\n      * <li>Stubbing consecutive calls on a void method:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doNothing().\n      *   doThrow(new RuntimeException())\n      *   .when(mock).someVoidMethod();\n      *\n      *   //throws RuntimeException the next time:\n      *   mock.someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * </li>\n      * <li>When you spy real objects and you want the void method to do nothing:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n      *\n      *\n      *   //clear() does nothing, so the list still contains \"one\"\n      *   spy.clear();\n-     * </pre>\n+     * </code></pre>\n      * </li>\n      * </ol>\n      * <p>\n      * <ol>\n      * <li>When spying real objects and calling real methods on a spy brings side effects\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n      *\n      *\n      *   //You have to use doReturn() for stubbing:\n      *   doReturn(\"foo\").when(spy).get(0);\n-     * </pre>\n+     * </code></pre>\n      * </li>\n      *\n      * <li>Overriding a previous exception-stubbing:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   when(mock.foo()).thenThrow(new RuntimeException());\n      *\n      *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.\n      *\n      *   //You have to use doReturn() for stubbing:\n      *   doReturn(\"bar\").when(mock).foo();\n-     * </pre>\n+     * </code></pre>\n      * </li>\n      * </ol>\n      *\n     /**\n      * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.\n      * \n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   InOrder inOrder = inOrder(firstMock, secondMock);\n      *   \n      *   inOrder.verify(firstMock).add(\"was called first\");\n      *   inOrder.verify(secondMock).add(\"was called second\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n      * but only those that you are interested in testing in order.\n      * See the second example.\n      * <p>\n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)\n      *  List mock1 = mock(List.class), mock2 = mock(List.class);\n      *\n      *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));\n      *\n      *  //Remember that ignoreStubs() <b>*changes*</b> the input mocks and returns them for convenience.\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * Ignoring stubs can be used with <b>verification in order</b>:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *  List list = mock(List.class);\n      *  when(mock.get(0)).thenReturn(\"foo\");\n      *\n      *  inOrder.verify(list).add(0);\n      *  inOrder.verify(list).clear();\n      *  inOrder.verifyNoMoreInteractions();\n-     * </pre>\n+     * </code></pre>\n      *\n      * @since 1.9\n      * @param mocks input mocks that will be changed\n \n     /**\n      * Allows verifying exact number of invocations. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, times(2)).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * Alias to <code>times(0)</code>, see {@link Mockito#times(int)}\n      * <p>\n      * Verifies that interaction did not happen. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, never()).someMethod();\n-     * </pre>\n+     * </code></pre>\n      * \n      * <p>\n      * If you want to verify there were NO interactions with the mock \n     \n     /**\n      * Allows at-least-once verification. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * Alias to <code>atLeast(1)</code>.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n \n     /**\n      * Allows at-least-x verification. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n \n     /**\n      * Allows at-most-x verification. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, atMost(3)).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n \n     /**\n      * Allows checking if given method was the only one invoked. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, only()).someMethod();\n      *   //above is a shorthand for following 2 lines of code:\n      *   verify(mock).someMethod();\n      *   verifyNoMoreInvocations(mock);\n-     * </pre>\n+     * </code></pre>\n      * \n      * <p>\n      * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n      * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n      * <p>\n      * Not yet implemented to work with InOrder verification.\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   //passes when someMethod() is called within given time span \n      *   verify(mock, timeout(100)).someMethod();\n      *   //above is an alias to:\n      *   //verifies someMethod() within given time span using given verification mode\n      *   //useful only if you have your own custom verification modes.\n      *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.\n      * <p>\n      * Examples of incorrect use:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * //Oups, someone forgot thenReturn() part:\n      * when(mock.get());\n      * \n      * \n      * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:\n      * verify(mock);\n-     * </pre>\n+     * </code></pre>\n      * \n      * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly. \n      * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.). \n      * If you cannot write a test in a simple way - refactor the code under test.\n      * <p>\n      * Examples of mock settings:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   //Creates mock with different default answer & name\n      *   Foo mock = mock(Foo.class, withSettings()\n      *       .defaultAnswer(RETURNS_SMART_NULLS)\n      *       .defaultAnswer(RETURNS_SMART_NULLS)\n      *       .name(\"cool mockie\")\n      *       .extraInterfaces(Bar.class));    \n-     * </pre>\n+     * </code></pre>\n      * {@link MockSettings} has been introduced for two reasons. \n      * Firstly, to make it easy to add another mock settings when the demand comes.\n      * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n  * <li>Makes the verification error easier to read because <b>field name</b> is used to identify the mock.</li>\n  * </ul>\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManagerTest extends SampleBaseTestCase { \n  *     \n  *       &#064;Mock private ArticleCalculator calculator;\n  *           MockitoAnnotations.initMocks(this);\n  *       }\n  *   }\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * Read also about other annotations &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}\n  * <p>\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n  * <p>\n  * Example:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * public class Test{\n  *    //Instance for spying is created by calling constructor explicitly:\n  *    &#64;Spy Foo spyOnFoo = new Foo(\"argument\");\n  *    }\n  *    ...\n  * }\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * Same as doing:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * Foo spyOnFoo = Mockito.spy(new Foo(\"argument\"));\n  * Bar spyOnFoo = Mockito.spy(new Bar());\n- * </pre>\n+ * </code></pre>\n  *\n  * <b>The field annotated with &#064;Spy can be initialized by Mockito if a zero argument constructor\n  * can be found in the type (even private). <u>But Mockito cannot instantiate inner classes, local classes,\n  * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></b>\n  *\n  * For example this class can be instantiated by Mockito :\n- * <pre>public class Bar {\n+ * <pre class=\"code\"><code class=\"java\">public class Bar {\n  *    private Bar() {}\n  *    public Bar(String publicConstructorWithOneArg) {}\n- * }</pre>\n+ * }</code></pre>\n  * </p>\n  * \n  * <p>\n--- a/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java\n+++ b/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java\n  * versa.</p>\n  *\n  * <p>Typical use for the code is as follows:</p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * public boolean equals(Object obj) {\n  *   if (obj == null) { return false; }\n  *   if (obj == this) { return true; }\n  *                 .append(field3, rhs.field3)\n  *                 .isEquals();\n  *  }\n- * </pre>\n+ * </code></pre>\n  *\n  * <p> Alternatively, there is a method that uses reflection to determine\n  * the fields to test. Because these fields are usually private, the method,\n  * also slower than testing explicitly.</p>\n  *\n  * <p> A typical invocation for this method would look like:</p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * public boolean equals(Object obj) {\n  *   return EqualsBuilder.reflectionEquals(this, obj);\n  * }\n- * </pre>\n+ * </code></pre>\n  *\n  * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n  * @author Stephen Colebourne\n--- a/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n  * <p> \n  * Let's say your test fails on assertion. \n  * Let's say the underlying reason is a stubbed method that was called with different arguments:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * //test:\n  * Dictionary dictionary = new Dictionary(translator);\n  * when(translator.translate(\"Mockito\")).thenReturn(\"cool framework\");\n  *     ...\n  *     return translator.translate(\"oups\");\n  *\n- * </pre>\n+ * </code></pre>\n  * On standard output you'll see something like that:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * [Mockito] Warning - stubbed method called with different arguments.\n  * Stubbed this way:\n  * translator.translate(\"Mockito\");\n  * But called with different arguments:\n  * translator.translate(\"oups\");\n  * org.dictionary.SmartDictionary.search(SmartDictionary.java:15)\n- * </pre>\n+ * </code></pre>\n  * <p>\n  * Note that it is just a warning, not an assertion. \n  * The test fails on assertion because it's the assertion's duty to document what the test stands for and what behavior it proves. \n--- a/src/org/mockito/runners/MockitoJUnit44Runner.java\n+++ b/src/org/mockito/runners/MockitoJUnit44Runner.java\n  * Read more about &#064;Mock annotation in javadoc for {@link MockitoAnnotations}\n  * <p>\n  * Example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * &#064;RunWith(MockitoJUnitRunner.class)\n  * public class ExampleTest {\n  * \n  * }\n  * <p>\n  * \n- * </pre>\n+ * </code></pre>\n  */\n @Deprecated\n public class MockitoJUnit44Runner extends MockitoJUnitRunner {\n--- a/src/org/mockito/runners/MockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/MockitoJUnitRunner.java\n  * See javadoc for {@link Mockito#validateMockitoUsage()}.\n  * <p>\n  * Read more about &#064;Mock annotation in javadoc for {@link MockitoAnnotations}\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * <b>&#064;RunWith(MockitoJUnitRunner.class)</b>\n  * public class ExampleTest {\n  * \n  *         list.add(100);\n  *     }\n  * }\n- * </pre>\n+ * </code></pre>\n  */\n public class MockitoJUnitRunner extends Runner implements Filterable {\n \n--- a/src/org/mockito/stubbing/Answer.java\n+++ b/src/org/mockito/stubbing/Answer.java\n  * <p>\n  * Example of stubbing a mock with custom answer: \n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n  *     Object answer(InvocationOnMock invocation) {\n  *         Object[] args = invocation.getArguments();\n  * \n  * //Following prints \"called with arguments: foo\"\n  * System.out.println(mock.someMethod(\"foo\"));\n- * </pre>\n+ * </code></pre>\n  * \n  * @param <T> the type to return.\n  */\n--- a/src/org/mockito/stubbing/DeprecatedOngoingStubbing.java\n+++ b/src/org/mockito/stubbing/DeprecatedOngoingStubbing.java\n /**\n  * Stubs a method call with return value or an exception. E.g:\n  *\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * stub(mock.someMethod()).toReturn(10);\n  *\n  * //you can use flexible argument matchers, e.g:\n  *  .toThrow(new RuntimeException())\n  *  .toReturn(\"foo\");\n  *\n- * </pre>\n+ * </code></pre>\n  *\n  * See examples in javadoc for {@link Mockito#stub}\n  */\n \n     /**\n      * Set a return value for the stubbed method. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stub(mock.someMethod()).toReturn(10);\n-     * </pre>\n+     * </code></pre>\n      *\n      * See examples in javadoc for {@link Mockito#stub}\n      *\n \n     /**\n      * Set a Throwable to be thrown when the stubbed method is called. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stub(mock.someMethod()).toThrow(new RuntimeException());\n-     * </pre>\n+     * </code></pre>\n      *\n      * If throwable is a checked exception then it has to\n      * match one of the checked exceptions of method signature.\n \n     /**\n      * Set a generic Answer for the stubbed method. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stub(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n      *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n      *         return (Integer) invocation.getArguments()[0];\n      *     }\n      * }\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param answer the custom answer to execute.\n      *\n--- a/src/org/mockito/stubbing/OngoingStubbing.java\n+++ b/src/org/mockito/stubbing/OngoingStubbing.java\n /**\n  * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\". E.g:\n  *\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n  *\n  * //you can use flexible argument matchers, e.g:\n  * //There is a shorter way of consecutive stubbing:\n  * when(mock.someMethod()).thenReturn(1,2,3);\n  * when(mock.otherMethod()).thenThrow(exc1, exc2);\n- * </pre>\n+ * </code></pre>\n  *\n  * See examples in javadoc for {@link Mockito#when}\n  */\n \n     /**\n      * Sets a return value to be returned when the method is called. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * when(mock.someMethod()).thenReturn(10);\n-     * </pre>\n+     * </code></pre>\n      *\n      * See examples in javadoc for {@link Mockito#when}\n      *\n \n     /**\n      * Sets consecutive return values to be returned when the method is called. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * when(mock.someMethod()).thenReturn(1, 2, 3);\n-     * </pre>\n+     * </code></pre>\n      *\n      * Last return value in the sequence (in example: 3) determines the behavior of further consecutive calls.\n      * <p>\n \n     /**\n      * Sets Throwable objects to be thrown when the method is called. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * when(mock.someMethod()).thenThrow(new RuntimeException());\n-     * </pre>\n+     * </code></pre>\n      *\n      * If throwables contain a checked exception then it has to\n      * match one of the checked exceptions of method signature.\n \n     /**\n      * Sets Throwable classes to be thrown when the method is called. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * when(mock.someMethod()).thenThrow(RuntimeException.class);\n-     * </pre>\n+     * </code></pre>\n      *\n      * <p>\n      * Each throwable class will be instantiated for each method invocation.\n      * However, there are rare cases when partial mocks come handy: \n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   // someMethod() must be safe (e.g. doesn't throw, doesn't have dependencies to the object state, etc.)\n      *   // if it isn't safe then you will have trouble stubbing it using this api. Use Mockito.doCallRealMethod() instead. \n      *   when(mock.someMethod()).thenCallRealMethod();\n      *   // calls real method:\n      *   mock.someMethod();\n      *   \n-     * </pre>\n+     * </code></pre>\n      * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n      * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n      * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n \n     /**\n      * Sets a generic Answer for the method. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * when(mock.someMethod(10)).thenAnswer(new Answer&lt;Integer&gt;() {\n      *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n      *         return (Integer) invocation.getArguments()[0];\n      *     }\n      * }\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param answer the custom answer to execute.\n      *\n      *\n      * This method is an alias of {@link #thenAnswer(Answer)}. This alias allows\n      * more readable tests on occasion, for example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * //using 'then' alias:\n      * when(mock.foo()).then(returnCoolValue());\n      *\n      * //versus good old 'thenAnswer:\n      * when(mock.foo()).thenAnswer(byReturningCoolValue());\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param answer the custom answer to execute.\n      * @return iOngoingStubbing object that allows stubbing consecutive calls\n      * It allows to create a stub in one line of code.\n      * This can be helpful to keep test code clean.\n      * For example, some boring stub can be created & stubbed at field initialization in a test:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * public class CarTest {\n      *   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();\n      *\n      *   &#064;Test public void should... {}\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param <M> The mock type given by the variable type.\n      * @return Mock used in this ongoing stubbing.\n--- a/src/org/mockito/stubbing/Stubber.java\n+++ b/src/org/mockito/stubbing/Stubber.java\n  * Allows to choose a method when stubbing in doThrow()|doAnswer()|doNothing()|doReturn() style\n  * <p> \n  * Example:\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n  *   \n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n- * </pre>\n+ * </code></pre>\n  * \n  * Also useful when stubbing consecutive calls:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException(\"one\")).\n  *   doThrow(new RuntimeException(\"two\"))\n  *   .when(mock).someVoidMethod();\n- * </pre>\n+ * </code></pre>\n  * \n  * Read more about those methods:\n  * <p>\n      * Allows to choose a method when stubbing in doThrow()|doAnswer()|doNothing()|doReturn() style\n      * <p> \n      * Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(new RuntimeException())\n      *   .when(mockedList).clear();\n      *   \n      *   //following throws RuntimeException:\n      *   mockedList.clear();\n-     * </pre>\n+     * </code></pre>\n      * \n      * Read more about those methods:\n      * <p>\n \n     /**\n      * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Throwable)} style:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(new RuntimeException(\"one\")).\n      *   doThrow(new RuntimeException(\"two\"))\n      *   .when(mock).someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * See javadoc for {@link Mockito#doThrow(Throwable)}\n      * \n      * @param toBeThrown to be thrown when the stubbed method is called\n \n     /**\n      * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class<? extends Throwable>)} style:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(RuntimeException.class).\n      *   doThrow(IllegalArgumentException.class)\n      *   .when(mock).someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * See javadoc for {@link Mockito#doThrow(Class)}\n      *\n      * @param toBeThrown exception class to be thrown when the stubbed method is called\n \n     /**\n      * Use it for stubbing consecutive calls in {@link Mockito#doAnswer(Answer)} style:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doAnswer(answerOne).\n      *   doAnswer(answerTwo)\n      *   .when(mock).someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * See javadoc for {@link Mockito#doAnswer(Answer)}\n      * \n      * @param answer to answer when the stubbed method is called\n     \n     /**\n      * Use it for stubbing consecutive calls in {@link Mockito#doNothing()} style:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   doNothing().\n      *   doThrow(new RuntimeException(\"two\"))\n      *   .when(mock).someVoidMethod();\n-     * </pre>\n+     * </code></pre>\n      * See javadoc for {@link Mockito#doNothing()}\n      * \n      * @return stubber - to select a method for stubbing\n--- a/src/org/mockito/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/stubbing/VoidMethodStubbable.java\n /**\n  * Stubs void method with an exception. E.g:\n  *\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n  *\n  * //you can stub with different behavior for consecutive method calls.\n  *  .toThrow(new RuntimeException())\n  *  .toReturn()\n  *  .on().someMethod();\n- * </pre>\n+ * </code></pre>\n  *\n  * See examples in javadoc for {@link Mockito#stubVoid}\n  */\n     /**\n      * Stubs void method with an exception. E.g:\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n-     * </pre>\n+     * </code></pre>\n      *\n      * If throwable is a checked exception then it has to\n      * match one of the checked exceptions of method signature.\n      * <b>Only use this method if you're stubbing consecutive calls.</b>\n      * <p>\n      * For example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stubVoid(mock)\n      *   .toReturn()\n      *   .toThrow(new RuntimeException())\n      *   .on().foo(10);\n-     * </pre>\n+     * </code></pre>\n      * <ul>\n      * <li>first time foo(10) is called the mock will 'just return' (e.g. don't throw any exception)</li>\n      * <li>second time foo(10) is called the mock will throw RuntimeException</li>\n      * Stubs a void method with generic {@link Answer}\n      * <p>\n      * For Example:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stubVoid(mock)\n      *   .toAnswer(new Answer() {\n      *                 public Object answer(InvocationOnMOck invocation) {\n      *                 }\n      *             })\n      *    .on().accept(any());\n-     * </pre>\n+     * </code></pre>\n      *\n      * @param answer the custom answer to execute.\n      *\n     /**\n      * Choose void method for stubbing. E.g:\n      *\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      *\n      * See examples in javadoc for {@link Mockito#stubVoid}\n      *\n--- a/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n+++ b/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n  * Returns elements of the collection. Keeps returning the last element forever.\n  * Might be useful on occasion when you have a collection of elements to return.\n  * <p>\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  *   //this:\n  *   when(mock.foo()).thenReturn(1, 2, 3);\n  *   //is equivalent to:\n  *   when(mock.foo()).thenReturn(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));\n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  */\n @SuppressWarnings(\"unchecked\")\n public class ReturnsElementsOf implements Answer {\n--- a/src/org/mockito/verification/VerificationMode.java\n+++ b/src/org/mockito/verification/VerificationMode.java\n  * Allows verifying that certain behavior happened at least once / exact number\n  * of times / never. E.g:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * verify(mock, times(5)).someMethod(&quot;was called five times&quot;);\n  * \n  * verify(mock, never()).someMethod(&quot;was never called&quot;);\n  * \n  * verify(mock, atMost(3)).someMethod(&quot;was called at most 3 times&quot;);\n  * \n- * </pre>\n+ * </code></pre>\n  * \n  * <b>times(1) is the default</b> and can be omitted\n  * <p>\n--- a/src/org/mockito/verification/VerificationWithTimeout.java\n+++ b/src/org/mockito/verification/VerificationWithTimeout.java\n /**\n  * VerificationWithTimeout is a {@link VerificationMode} that allows combining existing verification modes with 'timeout'. E.g:\n  * \n- * <pre>\n+ * <pre class=\"code\"><code class=\"java\">\n  * verify(mock, timeout(100).times(5)).foo();\n  * \n  * verify(mock, timeout(100).never()).bar();\n  * \n  * verify(mock, timeout(200).atLeastOnce()).baz();\n- * </pre>\n+ * </code></pre>\n  * \n  * <p>\n  * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n         \n     /**\n      * Allows verifying exact number of invocations within given timeout\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, timeout(100).times(2)).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * Alias to times(0), see {@link #times(int)}\n      * <p>\n      * Verifies that interaction did not happen within given timeout. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, timeout(100).never()).someMethod();\n-     * </pre>\n+     * </code></pre>\n      * \n      * <p>\n      * If you want to verify there were NO interactions with the mock \n     \n     /**\n      * Allows at-least-once verification withing given timeout. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, timeout(100).atLeastOnce()).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * Alias to atLeast(1)\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n \n     /**\n      * Allows at-least-x verification withing given timeout. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, timeout(100).atLeast(3)).someMethod(\"some arg\");\n-     * </pre>\n+     * </code></pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n \n     /**\n      * Allows checking if given method was the only one invoked. E.g:\n-     * <pre>\n+     * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, only()).someMethod();\n      *   //above is a shorthand for following 2 lines of code:\n      *   verify(mock).someMethod();\n      *   verifyNoMoreInvocations(mock);\n-     * </pre>\n+     * </code></pre>\n      * \n      * <p>\n      * See also {@link Mockito#verifyNoMoreInteractions(Object...)}", "timestamp": 1322076222, "metainfo": ""}