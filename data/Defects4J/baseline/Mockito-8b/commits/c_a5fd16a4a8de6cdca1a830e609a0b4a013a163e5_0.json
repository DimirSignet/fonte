{"sha": "a5fd16a4a8de6cdca1a830e609a0b4a013a163e5", "log": "Merged from issue296", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     }\n \n     /**\n+     * Allows non-greedy verification in order.  For example\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   inOrder.verify( mock, calls( 2 )).someMethod( \"some arg\" );\n+     * </code></pre>\n+     * <ul>\n+     * <li>will not fail if the method is called 3 times, unlike times( 2 )</li>\n+     * <li>will not mark the third invocation as verified, unlike atLeast( 2 )</li>\n+     * </ul>\n+     * This verification mode can only be used with in order verification.\n+     * @param wantedNumberOfInvocations number of invocations to verify\n+     * @return  verification mode\n+     */\n+    public static VerificationMode calls( int wantedNumberOfInvocations ){\n+        return VerificationModeFactory.calls( wantedNumberOfInvocations );\n+    }\n+    \n+    /**\n      * Allows checking if given method was the only one invoked. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, only()).someMethod();\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n             }\n         }\n         return firstChunk;\n+    }\n+    \n+    public Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){\n+        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){\n+            if( wanted.matches( invocation )){\n+                return invocation;\n+            }\n+        }\n+        return null;\n     }\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/Calls.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrder;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.checkers.*;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+public class Calls implements VerificationMode, VerificationInOrderMode {\n+\n+    final int wantedCount;\n+\n+    public Calls(int wantedNumberOfInvocations) {\n+        if( wantedNumberOfInvocations <= 0 ) {\n+            throw new MockitoException( \"Negative and zero values are not allowed here\" );\n+        }\n+        this.wantedCount = wantedNumberOfInvocations;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        throw new MockitoException( \"calls is only intended to work with InOrder\" );\n+    }\n+\n+    public void verifyInOrder(VerificationDataInOrder data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        missingInvocation.check( allInvocations, wanted, this, data.getOrderingContext());\n+        NonGreedyNumberOfInvocationsInOrderChecker numberOfCalls = new NonGreedyNumberOfInvocationsInOrderChecker();\n+        numberOfCalls.check( allInvocations, wanted, wantedCount, data.getOrderingContext());\n+    }    \n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count (non-greedy): \" + wantedCount;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n         return new Times(wantedNumberOfInvocations);\n     }\n \n+    public static Calls calls(int wantedNumberOfInvocations) {\n+        return new Calls( wantedNumberOfInvocations );\n+    }\n+\n     public static NoMoreInteractions noMoreInteractions() {\n         return new NoMoreInteractions();\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification.checkers;\n+\n+import org.mockito.exceptions.Discrepancy;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMarker;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.verification.api.InOrderContext;\n+\n+import java.util.List;\n+\n+public class NonGreedyNumberOfInvocationsInOrderChecker {\n+\n+    private final InvocationsFinder finder;\n+    private final Reporter reporter;\n+    private final InvocationMarker marker;\n+\n+    public NonGreedyNumberOfInvocationsInOrderChecker() {\n+        this(new InvocationsFinder(), new Reporter(), new InvocationMarker());\n+    }\n+\n+    NonGreedyNumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter, InvocationMarker marker ) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+        this.marker = marker;\n+    }\n+    \n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        int actualCount = 0;\n+        Location lastLocation = null;\n+        while( actualCount < wantedCount ){\n+            Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n+            if( next == null ){\n+                reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );\n+            }\n+            marker.markVerified( next, wanted );\n+            context.markVerified( next );\n+            lastLocation = next.getLocation();\n+            actualCount++;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderWithCallsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class VerificationInOrderWithCallsTest extends TestBase {\n+\n+    @Mock private IMethods mockOne;\n+    @Mock private IMethods mockTwo;\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    @Test\n+    public void shouldFailWhenMethodNotCalled(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCalledTooFewTimes(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+        exceptionRule.expectMessage( \"Wanted 2 times\" );\n+        exceptionRule.expectMessage( \"But was 1 time\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.voidMethod()\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+    \n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg(1);\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(2)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifyNoMoreInteractions(mockOne);\n+        verifyNoMoreInteractions(mockTwo);\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+    \n+    \n+    @Test\n+    public void shouldAllowFewerCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        \n+        exceptionRule.expect( NoInteractionsWanted.class );\n+\n+        // When\n+        verifyNoMoreInteractions( mockOne );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+\n+        // When\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( NoInteractionsWanted.class );\n+\n+        // When\n+        verifyNoMoreInteractions( mockOne );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+\n+        // When\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect(NoInteractionsWanted.class);\n+\n+        // When\n+        verifyNoMoreInteractions( mockTwo );\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){\n+        // Given\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+\n+        // When\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithCallsAfterUseOfTimes(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, times(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithCallsAfterUseOfAtLeast(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithTimesAfterUseOfCalls(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, times(2)).oneArg( 2 );\n+        verifier.verify( mockOne, times(1)).oneArg( 1 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithAtLeastAfterUseOfCalls(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 2 );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithTimesAfterCallsInSameChunk(){\n+        // Given\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+\n+        // When\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, times(2)).oneArg( 1 );\n+        verifier.verifyNoMoreInteractions();\n+\n+        // Then - no exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsWithZeroArgument(){\n+        // Given\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(0)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsWithNegativeArgument(){\n+        // Given\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+\n+        // When\n+        verifier.verify( mockOne, calls(-1)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsForNonInOrderVerification(){\n+        // Given\n+        mockOne.voidMethod();\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"calls is only intended to work with InOrder\" );\n+\n+        // When\n+        verify( mockOne, calls(1)).voidMethod();\n+\n+        // Then - expected exception thrown\n+    }\n+}\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n package org.mockito;\n \n import org.mockito.listeners.InvocationListener;\n+import org.mockito.plugins.MockSettingsInfo;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n  * Firstly, to make it easy to add another mock setting when the demand comes.\n  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n  */\n-public interface MockSettings extends Serializable {\n+public interface MockSettings extends Serializable, MockSettingsInfo {\n     \n     /**\n      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n--- /dev/null\n+++ b/src/org/mockito/internal/Incubating.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+/**\n+ * Indicates the type or method is work in progress and might chagnge.\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Incubating {\n+}\n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.listeners.InvocationListener;\n+import org.mockito.plugins.MockitoInvocationHandler;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.stubbing.*;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.plugins.MockitoInvocationHandler;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n+import java.util.ServiceLoader;\n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.internal.creation.CglibMockMaker;\n \n public class ClassPathLoader {\n     \n                     \"Unable to instantiate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n         }\n     }\n+\n+    /**\n+     * Returns the best mock maker available for the current runtime. This scans\n+     * the classpath to find a mock maker plugin if one is available, allowing\n+     * mockito to run on alternative platforms like Android.\n+     */\n+    public static MockMaker getMockMaker() {\n+        for (MockMaker mockMaker : ServiceLoader.load(MockMaker.class)) {\n+            return mockMaker; // return the first one service loader finds (if any)\n+        }\n+        return new CglibMockMaker(); // default implementation\n+    }\n }\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n  * <p>\n  * The {@link #process(Class, Object)} method implementation <strong>does not</strong> process super classes!\n  *\n- * @see {@link MockitoAnnotations}\n+ * @see MockitoAnnotations\n  */\n @SuppressWarnings(\"unchecked\")\n public class DefaultAnnotationEngine implements AnnotationEngine {\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n+/*\n+ * Copyright (c) 2012 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.plugins.MockitoInvocationHandler;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.plugins.MockSettingsInfo;\n+\n+/**\n+ * A MockMaker that uses cglib to generate mocks on a JVM.\n+ */\n+public final class CglibMockMaker implements MockMaker {\n+\n+    public <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n+            MockitoInvocationHandler handler, MockSettingsInfo settings) {\n+        return ClassImposterizer.INSTANCE.imposterise(\n+                new MethodInterceptorFilter(handler, settings), typeToMock, extraInterfaces);\n+    }\n+    \n+    public void resetMock(Object mock, MockitoInvocationHandler newHandler, MockSettingsInfo settings) {\n+        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(newHandler, settings));\n+    }\n+\n+    public MockitoInvocationHandler getHandler(Object mock) {\n+        if (!(mock instanceof Factory)) {\n+            return null;\n+        }\n+        Factory factory = (Factory) mock;\n+        Callback callback = factory.getCallback(0);\n+        if (!(callback instanceof MethodInterceptorFilter)) {\n+            return null;\n+        }\n+        return ((MethodInterceptorFilter) callback).getHandler();\n+    }\n+}\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n \n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.MockitoInvocationHandler;\n+import org.mockito.plugins.MockitoInvocationHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n import org.mockito.internal.invocation.*;\n import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.plugins.MockSettingsInfo;\n \n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private final MockitoInvocationHandler handler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n-    private final MockSettingsImpl mockSettings;\n+    private final MockSettingsInfo mockSettings;\n \n-    public MethodInterceptorFilter(MockitoInvocationHandler handler, MockSettingsImpl mockSettings) {\n+    public MethodInterceptorFilter(MockitoInvocationHandler handler, MockSettingsInfo mockSettings) {\n         this.handler = handler;\n         this.mockSettings = mockSettings;\n     }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import java.io.Serializable;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n+import java.lang.reflect.Modifier;\n \n import org.mockito.Mockito;\n-import org.mockito.cglib.proxy.MethodInterceptor;\n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.internal.configuration.ClassPathLoader;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.plugins.MockitoInvocationHandler;\n import org.mockito.stubbing.Answer;\n \n /**\n public class ReturnsSmartNulls implements Answer<Object>, Serializable {\n \n     private static final long serialVersionUID = 7618312406617949441L;\n+    private static MockMaker mockMaker = ClassPathLoader.getMockMaker();\n \n-    private final class ThrowingInterceptor implements MethodInterceptor {\n+    private final class ThrowingInterceptor implements MockitoInvocationHandler {\n         private final InvocationOnMock invocation;\n         private final Location location = new Location();\n \n             this.invocation = invocation;\n         }\n \n-        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n-            if (new ObjectMethodsGuru().isToString(method)) {\n+        public Object handle(Invocation nullDereference) throws Throwable {\n+            if (new ObjectMethodsGuru().isToString(nullDereference.getMethod())) {\n                 return \"SmartNull returned by this unstubbed method call on a mock:\\n\" +\n                         invocation.toString();\n             }\n             return defaultReturnValue;\n         }\n         Class<?> type = invocation.getMethod().getReturnType();\n-        if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n-            return ClassImposterizer.INSTANCE.imposterise(new ThrowingInterceptor(invocation), type);\n+        if (!type.isPrimitive() && !Modifier.isFinal(type.getModifiers())) {\n+            ThrowingInterceptor handler = new ThrowingInterceptor(invocation);\n+            return mockMaker.createMock(type, new Class[0], handler, new MockSettingsImpl());\n         }\n         return null;\n     }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import org.mockito.cglib.proxy.Callback;\n-import org.mockito.cglib.proxy.Factory;\n+import java.io.Serializable;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.plugins.MockMaker;\n import org.mockito.internal.InvocationNotifierHandler;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockHandlerInterface;\n-import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n-\n-import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n-    \n+\n+    private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n     private final MockCreationValidator creationValidator;\n \n     public MockUtil(MockCreationValidator creationValidator) {\n \n         settings.initiateMockName(classToMock);\n \n-        MethodInterceptorFilter filter = newMethodInterceptorFilter(settings);\n-        Class<?>[] ancillaryTypes = prepareAncillaryTypes(settings);\n-\n-\n-        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n+        InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n+                new MockHandler<T>(settings), settings);\n+        Class<?>[] extraInterfaces = prepareAncillaryTypes(settings);\n+        T mock = mockMaker.createMock(classToMock, extraInterfaces, mockHandler, settings);\n \n         Object spiedInstance = settings.getSpiedInstance();\n         if (spiedInstance != null) {\n     }\n \n     public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n-\n-    private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n-        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n-        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n-        return new MethodInterceptorFilter(invocationNotifierHandler, settings);\n+        InvocationNotifierHandler oldHandler\n+                = (InvocationNotifierHandler) mockMaker.getHandler(mock);\n+        MockSettingsImpl settings = oldHandler.getMockSettings();\n+        InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n+                new MockHandler<T>(settings), settings);\n+        mockMaker.resetMock(mock, newHandler, settings);\n     }\n \n     public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n         }\n \n         if (isMockitoMock(mock)) {\n-            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n+            return (MockHandlerInterface) mockMaker.getHandler(mock);\n         } else {\n             throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n         }\n     }\n \n     private <T> boolean isMockitoMock(T mock) {\n-        return getInterceptor(mock) != null;\n-    }\n-\n-    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n-        if (!(mock instanceof Factory)) {\n-            return null;\n-        }\n-        Factory factory = (Factory) mock;\n-        Callback callback = factory.getCallback(0);\n-        if (callback instanceof MethodInterceptorFilter) {\n-            return (MethodInterceptorFilter) callback;\n-        }\n-        return null;\n+        return mockMaker.getHandler(mock) != null;\n     }\n \n     public MockName getMockName(Object mock) {\n--- /dev/null\n+++ b/src/org/mockito/plugins/MockMaker.java\n+/*\n+ * Copyright (c) 2012 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.plugins;\n+\n+import org.mockito.internal.Incubating;\n+\n+/**\n+ * The facility to create mocks. By default, a cglib/asm based implementation is used.\n+ * It is possible to configure your own mock maker so that dynamic proxies are created without cglib/asm.\n+ * For example, the android users can use a MockMaker that can work with Dalvik virtual machine\n+ * and hence bring Mockito to android apps developers.\n+ *\n+ * TODO: way more documentation and examples.\n+ */\n+@Incubating\n+public interface MockMaker {\n+\n+    /**\n+     * Returns a new instance of {@code typeToMock} that implements the\n+     * interfaces of {@code extraInterfaces}. Invocations to the methods of the\n+     * returned instance will be delegated to {@code handler}.\n+     */\n+    <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n+            MockitoInvocationHandler handler, MockSettingsInfo settings);\n+\n+    /**\n+     * Returns the handler for the {@code mock}, or null if {@code mock} was not\n+     * a mock object created by {@link #createMock}.\n+     */\n+    MockitoInvocationHandler getHandler(Object mock);\n+\n+    /**\n+     * Replaces the existing handler on {@code mock} with {@code newHandler}.\n+     */\n+    void resetMock(Object mock, MockitoInvocationHandler newHandler,\n+                          MockSettingsInfo settings);\n+}\n--- /dev/null\n+++ b/src/org/mockito/plugins/MockSettingsInfo.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.plugins;\n+\n+import org.mockito.internal.Incubating;\n+\n+/**\n+ * Informs about the mock settings\n+ */\n+@Incubating\n+public interface MockSettingsInfo {\n+\n+    /**\n+     * if the mock is serializable\n+     */\n+    boolean isSerializable();\n+}\n--- /dev/null\n+++ b/src/org/mockito/plugins/MockitoInvocationHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.plugins;\n+\n+import java.io.Serializable;\n+\n+import org.mockito.internal.Incubating;\n+import org.mockito.internal.invocation.Invocation;\n+\n+/**\n+ * Handles the invocation on a mock\n+ *\n+ * TODO - should it extend serializable?\n+ */\n+@Incubating\n+public interface MockitoInvocationHandler extends Serializable {\n+\n+    @Incubating\n+    Object handle(Invocation invocation) throws Throwable;\n+\n+}\n--- a/src/org/mockito/stubbing/Stubber.java\n+++ b/src/org/mockito/stubbing/Stubber.java\n     Stubber doThrow(Throwable toBeThrown);\n \n     /**\n-     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class<? extends Throwable>)} style:\n+     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class)} style:\n      * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(RuntimeException.class).\n      *   doThrow(IllegalArgumentException.class)\n--- a/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n+++ b/src/org/mockito/stubbing/answers/ReturnsElementsOf.java\n  *   when(mock.foo()).thenReturn(1, 2, 3);\n  *   //is equivalent to:\n  *   when(mock.foo()).thenReturn(new ReturnsElementsOf(Arrays.asList(1, 2, 3)));\n- * <pre class=\"code\"><code class=\"java\">\n+ * </code></pre>\n  */\n-@SuppressWarnings(\"unchecked\")\n-public class ReturnsElementsOf implements Answer {\n+public class ReturnsElementsOf implements Answer<Object> {\n \n-    final LinkedList elements;\n+    private final LinkedList<Object> elements;\n \n-    public ReturnsElementsOf(Collection elements) {\n+    public ReturnsElementsOf(Collection<?> elements) {\n         if (elements == null) {\n             throw new MockitoException(\"ReturnsElementsOf does not accept null as constructor argument.\\n\" +\n             \t\t\"Please pass a collection instance\");\n         }\n-        this.elements = new LinkedList(elements);\n+        this.elements = new LinkedList<Object>(elements);\n     }\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n--- /dev/null\n+++ b/src/org/mockito/stubbing/answers/ReturnsFirstArgument.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.stubbing.answers;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+/**\n+ * Returns first argument of a method (useful for mocking chains).\n+ * Throws exception if method has no arguments.\n+ * <p>\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   //using constructor:\n+ *   when(mock.foo()).then(new ReturnsFirstArgument());\n+ *   //or static method:\n+ *   when(mock.foo()).then(returnFirstArgument());\n+ * <pre class=\"code\"><code class=\"java\">\n+ */\n+public class ReturnsFirstArgument implements Answer<Object> {\n+\n+\t@Override\n+\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\n+\t\tObject[] arguments = invocation.getArguments();\n+\t\tif (arguments.length == 0) {\n+\t\t\tthrow new MockitoException(\n+\t\t\t\t\t\"Wrong usage of ReturnsFirstArgument. No arguments were passed to the mocked method.\");\n+\t\t}\n+\t\treturn arguments[0];\n+\t}\n+\n+\tpublic static ReturnsFirstArgument returnFirstArgument() {\n+\t\treturn new ReturnsFirstArgument();\n+\t}\n+}\n--- a/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import static org.hamcrest.core.IsInstanceOf.*;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.MockitoInvocationHandler;\n+import org.mockito.plugins.MockitoInvocationHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n--- a/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n+++ b/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import static org.mockito.Matchers.*;\n         private String privateInherited = \"private\";\n     }\n     \n-    static class SomeObject extends InheritMe {\n+    public static class SomeObject extends InheritMe {\n         @SuppressWarnings(\"unused\")\n         // required because static fields needs to be excluded from copying\n         private static int staticField = -100;\n         }\n     }\n \n-    static class SomeOtherObject {\n+    public static class SomeOtherObject {\n     }\n \n     private SomeObject from = new SomeObject(100);\n--- /dev/null\n+++ b/test/org/mockito/stubbing/answers/ReturnsFirstArgumentTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.stubbing.answers;\n+\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.stubbing.answers.ReturnsFirstArgument.returnFirstArgument;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+public class ReturnsFirstArgumentTest extends TestBase {\n+\n+\tinterface Chain {\n+\t\tString process();\n+\t\t\n+\t\tString process(String arg);\n+\t\t\n+\t\tString process(String arg1, String arg2, String arg3);\n+\t}\n+\n+\t@Mock\n+\tprivate Chain chain;\n+\n+\t@Test\n+\tpublic void shouldReturnFirstArgumentForOneArgumentMethod() throws Exception {\n+\t\t// given\n+\t\twhen(chain.process(anyString())).then(returnFirstArgument());\n+\n+\t\t// when\n+\t\tString result = chain.process(\"test\");\n+\n+\t\t// then\n+\t\tassertEquals(\"test\", result);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldReturnFirstArgumentForMultipleArgumentsMethod() throws Exception {\n+\t\t// given\n+\t\twhen(chain.process(anyString(), anyString(), anyString())).then(returnFirstArgument());\n+\n+\t\t// when\n+\t\tString result = chain.process(\"test\", \"other\", \"other\");\n+\n+\t\t// then\n+\t\tassertEquals(\"test\", result);\n+\t}\n+\t\n+\t@Test(expected=MockitoException.class)\n+\tpublic void shouldScreamForMethodWithoutArguments() throws Exception {\n+\t\t// given\n+\t\twhen(chain.process()).then(returnFirstArgument());\n+\t\t\n+\t\t// when\n+\t\tchain.process();\n+\t}\n+\n+}\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n import java.io.IOException;\n import java.util.Map;\n import java.util.Set;\n \n-import javax.swing.text.ChangedCharSetException;\n-\n public interface IMethods {\n \n     boolean booleanReturningMethod();\n \n     String oneArray(Object[] array);\n     \n-    String canThrowException() throws ChangedCharSetException, CharacterCodingException; \n+    String canThrowException() throws CharacterCodingException; \n \n     String oneArray(String[] array);\n \n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n-import javax.swing.text.ChangedCharSetException;\n import java.io.IOException;\n-import java.util.*;\n import java.nio.charset.CharacterCodingException;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n public class MethodsImpl implements IMethods {\n     public boolean booleanReturningMethod() {\n         return null;\n     }\n \n-    public String canThrowException() throws ChangedCharSetException, CharacterCodingException {\n+    public String canThrowException() throws CharacterCodingException {\n         return null;\n     }\n ", "timestamp": 1327870939, "metainfo": ""}