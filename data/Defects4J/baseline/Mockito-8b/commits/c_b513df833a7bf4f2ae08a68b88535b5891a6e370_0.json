{"sha": "b513df833a7bf4f2ae08a68b88535b5891a6e370", "log": "got rid of some todos, added more testing  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4034", "commit": "\n--- a/src/org/mockito/internal/MockitoControl.java\n+++ b/src/org/mockito/internal/MockitoControl.java\n \n public class MockitoControl<T> implements MockAwareInvocationHandler<T>, InvocationHandler, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n-    private MockitoBehavior behavior = new MockitoBehavior();\n-    private T mock;\n+    private final MockitoBehavior behavior = new MockitoBehavior();\n     private final MockitoState mockitoState;\n     private final LastArguments lastArguments;\n+\n+    private T mock;\n+    private Throwable throwableToBeSetOnVoidMethod;\n     \n     public MockitoControl(MockitoState mockitoState, LastArguments lastArguments) {\n         this.mockitoState = mockitoState;\n         \n         behavior.addInvocation(invocationWithMatchers);\n         \n-        Throwable throwable = mockitoState.pullThrowableToBeSetOnVoidMethod();\n-        if (throwable != null) {\n-            andThrows(throwable);\n+        if (throwableToBeSetOnVoidMethod != null) {\n+            andThrows(throwableToBeSetOnVoidMethod);\n+            throwableToBeSetOnVoidMethod = null;\n             return null;\n         }\n \n     }\n \n     public MethodSelector<T> toThrow(Throwable throwable) {\n-        mockitoState.reportThrowableToBeSetOnVoidMethod(throwable);\n+        throwableToBeSetOnVoidMethod = throwable;\n         return this;\n     }\n \n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n     \n     static MockitoState INSTANCE = new MockitoState();\n     \n-    private final ThreadLocal<MockitoControl> controlForStubbing = new ThreadLocal<MockitoControl>();\n+    private final ThreadLocal<MockitoControl> lastControl = new ThreadLocal<MockitoControl>();\n     private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n-    private final ThreadLocal<Throwable> throwableToBeSetOnVoidMethod = new ThreadLocal<Throwable>();\n //    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n \n     MockitoState() {}\n     }\n     \n     public synchronized void reportLastControl(MockitoControl mockitoControl) {\n-        controlForStubbing.set(mockitoControl);\n+        lastControl.set(mockitoControl);\n     }\n \n     public synchronized MockitoExpectation pullControlToBeStubbed() {\n-        MockitoControl control = controlForStubbing.get();\n-        controlForStubbing.set(null);\n+        MockitoControl control = lastControl.get();\n+        lastControl.set(null);\n         return control;\n     }\n     \n         return verifyingMode;\n     }\n \n-    public synchronized void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n-        //TODO refactor so we don't use static state to keep the throwable. we \n-        //can set it directly to mockcontrol or something and keep this pseudo static class thinner\n-        \n-        throwableToBeSetOnVoidMethod.set(throwable);\n-    }\n-\n-    public synchronized Throwable pullThrowableToBeSetOnVoidMethod() {\n-        Throwable throwable = throwableToBeSetOnVoidMethod.get();\n-        throwableToBeSetOnVoidMethod.set(null);\n-        return throwable;\n-    }\n-\n //    public void stubbingStarted() {\n //        stubbingModeLocal.set(new Object());\n //    }\n--- a/test/org/mockito/usage/IMethods.java\n+++ b/test/org/mockito/usage/IMethods.java\n \n public interface IMethods {\n \n-    //TODO kill the index, kill not used methods\n     boolean booleanReturningMethod(int index);\n \n     byte byteReturningMethod(int index);\n--- a/test/org/mockito/usage/UsingVarargsTest.java\n+++ b/test/org/mockito/usage/UsingVarargsTest.java\n \n     private interface IVarArgs {\n         public void withStringVarargs(int value, String... s);\n+        public String withStringVarargsReturningString(int value, String... s);\n         public void withObjectVarargs(int value, Object... o);\n-        public void withBooleanVarargs(int value, boolean... b);\n+        public boolean withBooleanVarargs(int value, boolean... b);\n     }\n     \n     IVarArgs mock;\n     @Before\n     public void setup() {\n         mock = Mockito.mock(IVarArgs.class);\n+    }\n+    \n+    @Test\n+    public void shouldStubStringVarargs() {\n+        stub(mock.withStringVarargsReturningString(1)).andReturn(\"1\");\n+        stub(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).andReturn(\"2\");\n+        \n+        RuntimeException expected = new RuntimeException();\n+        stubVoid(mock).toThrow(expected).on().withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+\n+        assertEquals(\"1\", mock.withStringVarargsReturningString(1));\n+        assertEquals(null, mock.withStringVarargsReturningString(2));\n+        \n+        assertEquals(\"2\", mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\", \"4\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"9999\"));\n+        \n+        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"9999\");\n+        mock.withStringVarargs(9999, \"1\", \"2\", \"3\", \"4\");\n+        \n+        try {\n+            mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(expected, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldStubBooleanVarargs() {\n+        stub(mock.withBooleanVarargs(1)).andReturn(true);\n+        stub(mock.withBooleanVarargs(1, true, false)).andReturn(true);\n+        \n+        assertEquals(true, mock.withBooleanVarargs(1));\n+        assertEquals(false, mock.withBooleanVarargs(9999));\n+        \n+        assertEquals(true, mock.withBooleanVarargs(1, true, false));\n+        assertEquals(false, mock.withBooleanVarargs(1, true, false, true));\n+        assertEquals(false, mock.withBooleanVarargs(2, true, false));\n+        assertEquals(false, mock.withBooleanVarargs(1, true));\n+        assertEquals(false, mock.withBooleanVarargs(1, false, false));\n     }\n     \n     @Test\n--- a/test/org/mockito/usage/matchers/MatchersTest.java\n+++ b/test/org/mockito/usage/matchers/MatchersTest.java\n  */\n package org.mockito.usage.matchers;\n \n-import static org.mockito.Mockito.*;\n import static org.junit.Assert.*;\n+import static org.mockito.CrazyMatchers.*;\n+import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.stub;\n \n import java.math.BigDecimal;\n import org.junit.*;\n import org.mockito.*;\n import org.mockito.usage.IMethods;\n-\n-import static org.mockito.CrazyMatchers.*;\n \n @SuppressWarnings(\"unchecked\")  \n public class MatchersTest {\n     }\n \n     @Test\n-    //TODO how different is this one from matchesMatcher?\n     public void findMatcher() {\n         stub(mock.oneArg(CrazyMatchers.find(\"([a-z]+)\\\\d\"))).andReturn(\"1\");\n \n         assertEquals(\"1\", mock.oneArg(\"ab12\"));\n         assertEquals(null, mock.oneArg(\"12345\"));\n     }\n-\n+    \n     @Test\n     public void matchesMatcher() {\n         stub(mock.oneArg(matches(\"[a-z]+\\\\d\\\\d\"))).andReturn(\"1\");", "timestamp": 1195481692, "metainfo": ""}