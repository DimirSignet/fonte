{"sha": "56b350361e2c67a9caa8fe52939e45672cf9a57a", "log": "mean checkin (worked offline). Made anyX matchers allow nulls Added few handy matchers: anyList(), anyMap(), anyCollection() made printing of invocations slightly nicer: if one is printed in multiline-style the other one will be printed in multi lines as well  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40626", "commit": "\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.Any;\n import org.mockito.internal.matchers.Same;\n import org.mockito.internal.matchers.StartsWith;\n import org.mockito.internal.matchers.apachecommons.ReflectionEquals;\n+import org.mockito.internal.progress.EmptyReturnValues;\n import org.mockito.internal.progress.LastArguments;\n-import org.mockito.internal.progress.EmptyReturnValues;\n \n /**\n  * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n  * (Mockito naturally uses equals() for argument matching). \n  * This can make the test cleaner.\n  */\n+@SuppressWarnings(\"unchecked\")\n public class Matchers {\n \n     /**\n      * @return <code>null</code>.\n      */\n     public static String anyString() {\n-        return isA(String.class);\n-    }\n+        return (String) anyObject();\n+    }\n+    \n+    /**\n+     * any List argument.\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     * \n+     * @return <code>null</code>.\n+     */\n+    public static List anyList() {\n+        return (List) anyObject();\n+    }    \n+    \n+    /**\n+     * any Map argument.\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     * \n+     * @return <code>null</code>.\n+     */\n+    public static Map anyMap() {\n+        return (Map) anyObject();\n+    }    \n+    \n+    /**\n+     * any Collection argument.\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     * \n+     * @return <code>null</code>.\n+     */\n+    public static Collection anyCollection() {\n+        return (Collection) anyObject();\n+    }    \n \n     /**\n      * Object argument that implements the given class. \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         if (stubber.hasThrowableForVoidMethod()) {\n             Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n-            //TODO ideally we should get matchers first so that invocation doesn't have to expand varargs\n-            //matchersBinder then would become argumentsBinder\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n             stubber.addVoidMethodForThrowable(invocationMatcher);\n             return null;\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     }\n     \n     public String toString() {\n-        return toString(argumentsToMatchers());\n+        return toString(argumentsToMatchers(), false);\n     }\n \n-    protected String toString(List<Matcher> matchers) {\n+    public boolean hasMultiLinePrint() {\n+        return toString().contains(\"\\n\");\n+    }\n+\n+    public String toMultilineString() {\n+        return toString(argumentsToMatchers(), true);\n+    }    \n+\n+    protected String toString(List<Matcher> matchers, boolean forceMultiline) {\n         String method = qualifiedMethodName();\n         String invocation = method + getArgumentsLine(matchers);\n-        if (invocation.length() <= MAX_LINE_LENGTH) {\n+        if (forceMultiline || invocation.length() > MAX_LINE_LENGTH) {\n+            return method + getArgumentsBlock(matchers);\n+        } else {\n             return invocation;\n-        } else {\n-            return method + getArgumentsBlock(matchers);\n         }\n     }\n \n             && invocation.getMethod().getParameterTypes().length == 0 \n             && invocation.getMethod().getName().equals(\"toString\");\n     }\n+\n+    public boolean isValidException(Throwable throwable) {\n+        Class<?>[] exceptions = this.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n     }\n     \n     public String toString() {\n-        return invocation.toString(matchers);\n+        return invocation.toString(matchers, false);\n     }\n+\n+    public boolean hasMultilinePrint() {        \n+        return toString().contains(\"\\n\");\n+    }\n+\n+    public String toMultilineString() {\n+        return invocation.toString(matchers, true);\n+    }    \n \n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n--- a/src/org/mockito/internal/stubbing/AnswerFactory.java\n+++ b/src/org/mockito/internal/stubbing/AnswerFactory.java\n  */\n package org.mockito.internal.stubbing;\n \n+import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTraceThrowableWrapper;\n import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.invocation.Invocation;\n \n @SuppressWarnings(\"unchecked\")\n public class AnswerFactory {\n \n-    public static Answer createThrowingAnswer(final Throwable throwable, final StackTraceFilter filter) {\n+    private final StackTraceFilter filter;\n+    private final Reporter reporter;\n+    \n+    public AnswerFactory(StackTraceFilter filter) {\n+        this.filter = filter;\n+        this.reporter = new Reporter();\n+    }\n+    \n+    public Answer createReturningAnswer(final Object value) {\n+        return new Answer<Object>() {\n+            public Object answer() throws Throwable {\n+                return value;\n+            }\n+        };\n+    }\n+    \n+    public Answer createThrowingAnswer(final Throwable throwable, Invocation invocation) {\n+        validateThrowable(throwable, invocation);\n         return new Answer<Object>() {\n             public Object answer() throws Throwable {\n                 if (throwable == DontThrow.DONT_THROW) {\n         };\n     }\n     \n-    public static Answer createReturningAnswer(final Object value) {\n-        return new Answer<Object>() {\n-            public Object answer() throws Throwable {\n-                return value;\n-            }\n-        };\n+    private void validateThrowable(Throwable throwable, Invocation invocation) {\n+        if (throwable == null) {\n+            reporter.cannotStubWithNullThrowable();\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+    \n+        if (!invocation.isValidException(throwable)) {\n+            reporter.checkedExceptionInvalid(throwable);\n+        }\n     }\n }\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.StackTraceFilter;\n import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.invocation.Invocation;\n public class Stubber {\n \n     private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n-    private final Reporter reporter = new Reporter();\n     private final MockingProgress mockingProgress;\n     private final List<Throwable> throwablesForVoidMethod = new ArrayList<Throwable>();\n+    private final AnswerFactory answerFactory = new AnswerFactory(new StackTraceFilter());\n     \n     private InvocationMatcher invocationForStubbing;\n     \n     \n     public void addReturnValue(Object value) {\n         mockingProgress.stubbingCompleted();\n-        Answer answer = AnswerFactory.createReturningAnswer(value);\n+        Answer answer = answerFactory.createReturningAnswer(value);\n         stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n     }\n     \n     public void addThrowable(Throwable throwable) {\n         mockingProgress.stubbingCompleted();\n-        validateThrowable(throwable);\n-        Answer answer = AnswerFactory.createThrowingAnswer(throwable, new StackTraceFilter());\n+        Answer answer = answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation());\n         stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n     }\n     \n     public void addConsecutiveReturnValue(Object value) {\n-        stubbed.getFirst().addAnswer(AnswerFactory.createReturningAnswer(value));\n+        stubbed.getFirst().addAnswer(answerFactory.createReturningAnswer(value));\n     }\n \n     public void addConsecutiveThrowable(Throwable throwable) {\n-        //TODO move validation of throwable to createThrowResult\n-        validateThrowable(throwable);\n-        stubbed.getFirst().addAnswer(AnswerFactory.createThrowingAnswer(throwable, new StackTraceFilter()));\n+        stubbed.getFirst().addAnswer(answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation()));\n     }    \n \n     public Object resultFor(Invocation invocation) throws Throwable {\n         }\n         throwablesForVoidMethod.clear();\n     }\n-    \n-    private void validateThrowable(Throwable throwable) {\n-        if (throwable == null) {\n-            reporter.cannotStubWithNullThrowable();\n-        }\n-\n-        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n-            return;\n-        }\n-    \n-        if (!isValidCheckedException(throwable)) {\n-            reporter.checkedExceptionInvalid(throwable);\n-        }\n-    }\n-\n-    private boolean isValidCheckedException(Throwable throwable) {\n-        Invocation lastInvocation = invocationForStubbing.getInvocation();\n-\n-        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n-        Class<?> throwableClass = throwable.getClass();\n-        for (Class<?> exception : exceptions) {\n-            if (exception.isAssignableFrom(throwableClass)) {\n-                return true;\n-            }\n-        }\n-        \n-        return false;\n-    }\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n \n     private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n         if (similar != null) {\n-            reporter.argumentsAreDifferent(wanted, similar, similar.getStackTrace());\n+            SyncingPrinter syncingPrinter = new SyncingPrinter(wanted, similar);\n+            reporter.argumentsAreDifferent(syncingPrinter.getWanted(), syncingPrinter.getActual(), similar.getStackTrace());\n         } else {\n             reporter.wantedButNotInvoked(wanted);\n         }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/SyncingPrinter.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+public class SyncingPrinter {\n+\n+    private final String wanted;\n+    private final String actual;\n+\n+    public SyncingPrinter(InvocationMatcher wanted, Invocation actual) {\n+        if (wanted.hasMultilinePrint() || actual.hasMultiLinePrint()) {\n+            this.wanted = wanted.toMultilineString();\n+            this.actual = actual.toMultilineString();\n+        } else {\n+            this.wanted = wanted.toString();\n+            this.actual = actual.toString();\n+        }\n+    }\n+    \n+    public PrintableInvocation getWanted() {\n+        return new PrintableInvocation() {\n+            public String toString() {\n+                return wanted;\n+            }\n+        };\n+    }\n+    \n+    public PrintableInvocation getActual() {\n+        return new PrintableInvocation() {\n+            public String toString() {\n+                return actual;\n+            }\n+        };\n+    }\n+}\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n     }\n     \n     //TODO add initMocks that allows to send own annotation/own implementation of creation logic\n-    //TODO stack trace remover does not work when it comes to threads\n+    //TODO stack trace remover does not work very well when it comes to threads\n }\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n package org.mockito.internal.invocation;\n \n import java.lang.reflect.Method;\n+import java.nio.charset.CharacterCodingException;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n         Invocation notToString = new InvocationBuilder().method(\"toString\").arg(\"foo\").toInvocation();\n         assertFalse(Invocation.isToString(notToString));\n     }\n+    \n+    @Test\n+    public void shouldKnowValidThrowables() throws Exception {\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        assertFalse(invocation.isValidException(new Exception()));\n+        assertTrue(invocation.isValidException(new CharacterCodingException()));\n+    }\n }\n--- a/test/org/mockito/internal/stubbing/AnswerFactoryTest.java\n+++ b/test/org/mockito/internal/stubbing/AnswerFactoryTest.java\n \n import static org.mockito.util.ExtraMatchers.*;\n \n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n import java.util.Arrays;\n \n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n \n @SuppressWarnings(\"unchecked\")\n public class AnswerFactoryTest extends TestBase {\n \n+    private StackTraceFilterStub filterStub;\n+    private AnswerFactory factory;\n+\n+    @Before\n+    public void setup() {\n+        this.filterStub = new StackTraceFilterStub();\n+        this.factory = new AnswerFactory(filterStub);\n+    }\n+    \n     @Test\n     public void shouldCreateReturnResult() throws Throwable {\n-        Answer result = AnswerFactory.createReturningAnswer(\"lol\");\n+        Answer result = factory.createReturningAnswer(\"lol\");\n         assertEquals(\"lol\", result.answer());\n     }\n     \n     @Test(expected=RuntimeException.class)\n     public void shouldCreateThrowResult() throws Throwable {\n-        AnswerFactory.createThrowingAnswer(new RuntimeException(), new StackTraceFilter()).answer();\n+        factory.createThrowingAnswer(new RuntimeException(), null).answer();\n     }\n     \n     @Test\n     public void shouldFilterStackTraceWhenCreatingThrowResult() throws Throwable {\n-        StackTraceFilterStub filterStub = new StackTraceFilterStub();\n-        Answer result = AnswerFactory.createThrowingAnswer(new RuntimeException(), filterStub);\n+        Answer result = factory.createThrowingAnswer(new RuntimeException(), null);\n         try {\n             result.answer(); \n             fail();\n         }\n     }\n     \n+    @Test\n+    public void shouldValidateNullThrowable() throws Throwable {\n+        try {\n+            factory.createThrowingAnswer(null, null);\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowSettingProperCheckedException() throws Throwable {\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        factory.createThrowingAnswer(new CharacterCodingException(), invocation);\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldValidateCheckedException() throws Throwable {\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        factory.createThrowingAnswer(new IOException(), invocation);\n+    }\n+\n     class StackTraceFilterStub extends StackTraceFilter {\n         HasStackTrace hasStackTrace;\n         @Override public void filterStackTrace(HasStackTrace hasStackTrace) {\n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing;\n-\n-import java.nio.charset.CharacterCodingException;\n \n import org.junit.Before;\n import org.junit.Test;\n     }\n \n     @Test\n-    public void shouldFinishStubbingBeforeValidatingThrowable() throws Exception {\n+    public void shouldFinishStubbingWhenWrongThrowableIsSet() throws Exception {\n         state.stubbingStarted();\n         try {\n             stubber.addThrowable(new Exception());\n     }\n     \n     @Test\n-    public void shouldValidateNullThrowable() throws Throwable {\n+    public void shouldValidateThrowable() throws Throwable {\n         try {\n             stubber.addThrowable(null);\n             fail();\n         } catch (MockitoException e) {}\n     }\n     \n-    @Test\n-    public void shouldLetSettingProperCheckedException() throws Throwable {\n-        stubber.setInvocationForPotentialStubbing(new InvocationBuilder().method(\"canThrowException\").toInvocationMatcher());\n-        stubber.addThrowable(new CharacterCodingException());\n-    }\n-    \n     @SuppressWarnings(\"serial\") class MyException extends RuntimeException {};\n }\n--- a/test/org/mockitousage/AnnotationsTest.java\n+++ b/test/org/mockitousage/AnnotationsTest.java\n     @Mock List list;\n     @Mock final Map map = new HashMap();\n     //TODO shall I bother deprecating @MockitoAnnotations.Mock and refactor annotation to own file?\n-    //TODO don't use cglib-nodep, have all jars separate\n     \n     @Before\n     public void setup() {\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n import java.nio.charset.CharacterCodingException;\n import java.util.Collection;\n import java.util.List;\n+import java.util.Map;\n \n import javax.swing.text.ChangedCharSetException;\n \n     \n     String oneArg(Boolean value);\n \n+    String forBoolean(Boolean value);\n+\n     String oneArg(byte value);\n     \n     String oneArg(Byte value);\n \n+    String forByte(Byte value);\n+    \n     String oneArg(short value);\n \n     String oneArg(Short value);\n     \n+    String forShort(Short value);\n+    \n     String oneArg(char value);\n     \n     String oneArg(Character value);\n+    \n+    String forCharacter(Character value);\n \n     String oneArg(int value);\n     \n     String oneArg(Integer value);\n+    \n+    String forInteger(Integer value);\n \n     String oneArg(long value);\n \n     String oneArg(Long value);\n     \n+    String forLong(Long value);\n+    \n     String oneArg(float value);\n \n     String oneArg(Float value);\n     \n+    String forFloat(Float value);\n+    \n     String oneArg(double value);\n \n     String oneArg(Double value);\n+    \n+    String forDouble(Double value);\n     \n     String oneArg(Object value);\n \n     String toString(String foo);\n \n     void voidMethod();\n+\n+    String forList(List<String> list);\n+    \n+    String forMap(Map<String, String> map);\n+    \n+    String forCollection(Collection<String> collection);\n }\n--- a/test/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java\n+++ b/test/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n         mock = Mockito.mock(IMethods.class);\n     }\n \n-    @Ignore\n     @Test\n     public void shouldAnyXMatchersAcceptNull() {\n         stub(mock.oneArg(anyObject())).toReturn(\"0\");\n         stub(mock.oneArg(anyString())).toReturn(\"1\");\n-        stub(mock.oneArg(anyInt())).toReturn(\"2\");\n+        stub(mock.forList(anyList())).toReturn(\"2\");\n+        stub(mock.forMap(anyMap())).toReturn(\"3\");\n+        stub(mock.forCollection(anyCollection())).toReturn(\"4\");\n         \n         assertEquals(\"0\", mock.oneArg((Object) null));\n         assertEquals(\"1\", mock.oneArg((String) null));\n-        assertEquals(\"2\", mock.oneArg((Integer) null));\n+        assertEquals(\"2\", mock.forList(null));\n+        assertEquals(\"3\", mock.forMap(null));\n+        assertEquals(\"4\", mock.forCollection(null));\n     }\n     \n-    \n-    \n-//        TODO add anyList()       matcher\n-//        TODO add anyMap()        matcher\n-//        TODO add anyCollection() matcher\n-//        TODO add anySet() matcher\n-    \n+    @Test\n+    public void shouldAnyPrimiteWraperMatchersAcceptNull() {\n+        stub(mock.forInteger(anyInt())).toReturn(\"0\");\n+        stub(mock.forCharacter(anyChar())).toReturn(\"1\");\n+        stub(mock.forShort(anyShort())).toReturn(\"2\");\n+        stub(mock.forByte(anyByte())).toReturn(\"3\");\n+        stub(mock.forBoolean(anyBoolean())).toReturn(\"4\");\n+        stub(mock.forLong(anyLong())).toReturn(\"5\");\n+        stub(mock.forFloat(anyFloat())).toReturn(\"6\");\n+        stub(mock.forDouble(anyDouble())).toReturn(\"7\");\n+        \n+        assertEquals(\"0\", mock.forInteger(null));\n+        assertEquals(\"1\", mock.forCharacter(null));\n+        assertEquals(\"2\", mock.forShort(null));\n+        assertEquals(\"3\", mock.forByte(null));\n+        assertEquals(\"4\", mock.forBoolean(null));\n+        assertEquals(\"5\", mock.forLong(null));\n+        assertEquals(\"6\", mock.forFloat(null));\n+        assertEquals(\"7\", mock.forDouble(null));\n+    }\n }\n--- a/test/org/mockitousage/matchers/CustomMatchersTest.java\n+++ b/test/org/mockitousage/matchers/CustomMatchersTest.java\n             verify(mock).simpleMethod(containsTest());\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"simpleMethod(\\n    <String that contains xxx>\\n);\"));\n+            assertThat(e, messageContains(\"<String that contains xxx>\"));\n         }\n     }\n \n                 }}));\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"simpleMethod(\\n    <custom argument matcher>\\n);\"));\n+            assertThat(e, messageContains(\"<custom argument matcher>\"));\n             assertThat(e, causeMessageContains(\"foo\"));\n         }\n     }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n         mock.varargs(\"this is very long string\", \"this is another very long string\");\n \n         try {\n-            verify(mock).varargs(\"this is very long string\", \"this is another very long string\", \"this is yet another very long string\");\n-            fail();\n-        } catch (ArgumentsAreDifferent e) {\n-            //TODO for every case when wanted and actual are shown, the arg list has to be consistently printed\n-            //(e.g. if one invocation is multiline, the the other one has to to be printed in multilines as well)\n+            verify(mock).varargs(\"x\", \"y\", \"z\");\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n             String expected =\n                     \"\\n\" +\n                     \"Argument(s) are different! Wanted:\" +\n                     \"\\n\" +\n                     \"iMethods.varargs(\" +\n                     \"\\n\" +\n-                    \"    \\\"this is very long string\\\",\" +\n-                    \"\\n\" +\n-                    \"    \\\"this is another very long string\\\",\" +\n-                    \"\\n\" +\n-                    \"    \\\"this is yet another very long string\\\"\" +\n+                    \"    \\\"x\\\",\" +\n+                    \"\\n\" +\n+                    \"    \\\"y\\\",\" +\n+                    \"\\n\" +\n+                    \"    \\\"z\\\"\" +\n                     \"\\n\" +\n                     \");\";\n ", "timestamp": 1213637071, "metainfo": ""}