{"sha": "cf7f7cc55e979ed70bae92e77e08b0de301ba65f", "log": "Fixed issue 149 Added new feature: 'deep stubbing' that can be useful for more complex stubbing (mostly in the ase of legacy code)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401816", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n      * <p>\n      * {@link Answer} can be used to define the return values of unstubbed invocations.\n      * <p>\n+     * ReturnsDeepStubs returns reusable deep stubbing.  If the return type\n+     * cannot be mocked (e.g. is final) then plain null is returned.\n+     *\n+     * TODO: Explain how this is different from RETURNS_MOCKS\n+     * <p>\n+     * Example:\n+     * <pre>\n+     *    Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);\n+     *\n+     *    // stub here\n+     *    when(mock.getBar().getName(), \"DeepStub\");\n+     *\n+     *    // verify\n+     *    assertEquals(\"DeepStub\", mock.getBar().getName());\n+     * </pre>\n+     * <p>\n+     */\n+    public static final Answer<Object> RETURNS_DEEP_STUBS = new ReturnsDeepStubs();\n+\n+    /**\n+     * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n+     * <p>\n+     * {@link Answer} can be used to define the return values of unstubbed invocations.\n+     * <p>\n      * This implementation can be helpful when working with legacy code.\n      * When this implementation is used, unstubbed methods will delegate to the real implementation.\n      * This is a way to create a partial mock object that calls real methods by default.\n     public static MockitoDebugger debug() {\n         return new MockitoDebuggerImpl();\n     }\n-}\n+}\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n         addAnswer(answer, true);\n     }\n \n-    private void addAnswer(Answer answer, boolean isConsecutive) {\n+    public void addAnswer(Answer answer, boolean isConsecutive) {\n         Invocation invocation = invocationForStubbing.getInvocation();\n         mockingProgress.stubbingCompleted(invocation);\n         AnswersValidator answersValidator = new AnswersValidator();\n     public List<StubbedInvocationMatcher> getStubbedInvocations() {\n         return stubbed;\n     }\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+/*\n+ * Copyright (c) 2009 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.Mockito;\n+import org.mockito.internal.MockHandlerInterface;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n+    private static final long serialVersionUID = -6926328908792880098L;\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        //TODO: cover also unmockable & final classes\n+        Class<?> clz = invocation.getMethod().getReturnType();\n+        if (clz.isPrimitive())\n+            return null;\n+        return getMock(invocation);\n+    }\n+\n+    private Object getMock(InvocationOnMock invocation) {\n+        Class<?> clz = invocation.getMethod().getReturnType();\n+        final Object mock = Mockito.mock(clz, this);\n+\n+        MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+        InvocationContainerImpl container = (InvocationContainerImpl)handler.getInvocationContainer();\n+        container.addAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return mock;\n+            }\n+        }, false);\n+\n+        return mock;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+/*\n+ * Copyright (c) 2009 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+\n+import javax.net.SocketFactory;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+\n+public class DeepStubbingTest extends TestBase {\n+\n+    @Test\n+    public void myTest() throws Exception {\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), eq(80))).thenReturn(null);\n+        sf.createSocket(\"what\", 80);\n+    }\n+\n+    @Test\n+    public void simpleCase() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+        Socket socket = mock(Socket.class);\n+        when(socket.getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, socket.getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing works for one intermediate level\n+     */\n+    @Test\n+    public void oneLevelDeep() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+\n+        SocketFactory socketFactory = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(socketFactory.createSocket().getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, socketFactory.createSocket().getOutputStream());\n+    }\n+\n+    /**\n+     * Test that stubbing of two mocks stubs don't interfere\n+     */\n+    @Test\n+    public void interactions() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf1 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf1.createSocket().getOutputStream()).thenReturn(out1);\n+\n+        SocketFactory sf2 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf2.createSocket().getOutputStream()).thenReturn(out2);\n+\n+        assertSame(out1, sf1.createSocket().getOutputStream());\n+        assertSame(out2, sf2.createSocket().getOutputStream());\n+    }\n+\n+    /**\n+     * Test that stubbing of methods of different arguments don't interfere\n+     */\n+    @Test\n+    public void withArguments() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+        OutputStream out3 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket().getOutputStream()).thenReturn(out1);\n+        when(sf.createSocket(\"google.com\", 80).getOutputStream()).thenReturn(out2);\n+        when(sf.createSocket(\"stackoverflow.com\", 80).getOutputStream()).thenReturn(out3);\n+\n+        assertSame(out1, sf.createSocket().getOutputStream());\n+        assertSame(out2, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out3, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with argument patterns\n+     */\n+    @Test\n+    public void withAnyPatternArguments() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with argument patterns\n+     */\n+    @Test\n+    public void withComplexPatternArguments() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), eq(80)).getOutputStream()).thenReturn(out1);\n+        when(sf.createSocket(anyString(), eq(8080)).getOutputStream()).thenReturn(out2);\n+\n+        assertSame(out2, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n+        assertSame(out1, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out2, sf.createSocket(\"google.com\", 8080).getOutputStream());\n+        assertSame(out1, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with primitive expected values\n+     */\n+    @Test\n+    public void withSimplePrimitive() throws Exception {\n+        int a = 32;\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket().getPort()).thenReturn(a);\n+\n+        assertEquals(a, sf.createSocket().getPort());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with primitive expected values with\n+     * pattern method arguments\n+     */\n+    @Test\n+    public void withPatternPrimitive() throws Exception {\n+        int a = 12, b = 23, c = 34;\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(80)).getPort()).thenReturn(a);\n+        when(sf.createSocket(eq(\"google.com\"), anyInt()).getPort()).thenReturn(b);\n+        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(8080)).getPort()).thenReturn(c);\n+\n+        assertEquals(b, sf.createSocket(\"google.com\", 80).getPort());\n+        assertEquals(c, sf.createSocket(\"stackoverflow.com\", 8080).getPort());\n+        assertEquals(a, sf.createSocket(\"stackoverflow.com\", 80).getPort());\n+    }\n+}", "timestamp": 1262363850, "metainfo": ""}