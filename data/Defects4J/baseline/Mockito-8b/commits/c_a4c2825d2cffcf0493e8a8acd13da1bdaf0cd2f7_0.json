{"sha": "a4c2825d2cffcf0493e8a8acd13da1bdaf0cd2f7", "log": "Extract an IMockMaker interface to encapsulate the cglib dependency.  http://code.google.com/p/mockito/issues/detail?id=308  --HG-- extra : transplant_source : %28e%EF%9C%B3%96%D4%1D3m%E93%40%E6%E0%12%F2%83s5", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/IMockMaker.java\n+/*\n+ * Copyright (c) 2012 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import org.mockito.internal.creation.MockSettingsImpl;\n+\n+public interface IMockMaker {\n+\n+    /**\n+     * Returns a new instance of {@code typeToMock} that implements the\n+     * interfaces of {@code extraInterfaces}. Invocations to the methods of the\n+     * returned instance will be delegated to {@code handler}.\n+     */\n+    <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n+            MockitoInvocationHandler handler, MockSettingsImpl settings);\n+\n+    /**\n+     * Returns the handler for the {@code mock}, or null if {@code mock} was not\n+     * a mock object created by {@link #createMock}.\n+     */\n+    public MockitoInvocationHandler getHandler(Object mock);\n+\n+    /**\n+     * Replaces the existing handler on {@code mock} with {@code newHandler}.\n+     */\n+    public void resetMock(Object mock, MockitoInvocationHandler newHandler,\n+            MockSettingsImpl settings);\n+}\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n+import java.util.ServiceLoader;\n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+import org.mockito.internal.IMockMaker;\n+import org.mockito.internal.creation.CglibMockMaker;\n \n public class ClassPathLoader {\n     \n                     \"Unable to instantiate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n         }\n     }\n+\n+    /**\n+     * Returns the best mock maker available for the current runtime. This scans\n+     * the classpath to find a mock maker plugin if one is available, allowing\n+     * mockito to run on alternative platforms like Android.\n+     */\n+    public static IMockMaker getMockMaker() {\n+        for (IMockMaker mockMaker : ServiceLoader.load(IMockMaker.class)) {\n+            return mockMaker; // return the first one service loader finds (if any)\n+        }\n+        return new CglibMockMaker(); // default implementation\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n+/*\n+ * Copyright (c) 2012 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.internal.IMockMaker;\n+import org.mockito.internal.MockitoInvocationHandler;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+\n+/**\n+ * A MockMaker that uses cglib to generate mocks on a JVM.\n+ */\n+public final class CglibMockMaker implements IMockMaker {\n+\n+    public <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n+            MockitoInvocationHandler handler, MockSettingsImpl settings) {\n+        settings.initiateMockName(typeToMock);\n+        return ClassImposterizer.INSTANCE.imposterise(\n+                new MethodInterceptorFilter(handler, settings), typeToMock, extraInterfaces);\n+    }\n+    \n+    public void resetMock(Object mock, MockitoInvocationHandler newHandler, MockSettingsImpl settings) {\n+        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(newHandler, settings));\n+    }\n+\n+    public MockitoInvocationHandler getHandler(Object mock) {\n+        if (!(mock instanceof Factory)) {\n+            return null;\n+        }\n+        Factory factory = (Factory) mock;\n+        Callback callback = factory.getCallback(0);\n+        if (!(callback instanceof MethodInterceptorFilter)) {\n+            return null;\n+        }\n+        return ((MethodInterceptorFilter) callback).getHandler();\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import org.mockito.cglib.proxy.Callback;\n-import org.mockito.cglib.proxy.Factory;\n+import java.io.Serializable;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.IMockMaker;\n import org.mockito.internal.InvocationNotifierHandler;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockHandlerInterface;\n-import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n-\n-import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n-    \n+\n+    private static final IMockMaker mockMaker = ClassPathLoader.getMockMaker();\n     private final MockCreationValidator creationValidator;\n \n     public MockUtil(MockCreationValidator creationValidator) {\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n         creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n \n-        settings.initiateMockName(classToMock);\n-\n-        MethodInterceptorFilter filter = newMethodInterceptorFilter(settings);\n-        Class<?>[] ancillaryTypes = prepareAncillaryTypes(settings);\n-\n-\n-        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n+        InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n+                new MockHandler<T>(settings), settings);\n+        Class<?>[] extraInterfaces = prepareAncillaryTypes(settings);\n+        T mock = mockMaker.createMock(classToMock, extraInterfaces, mockHandler, settings);\n \n         Object spiedInstance = settings.getSpiedInstance();\n         if (spiedInstance != null) {\n     }\n \n     public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n-\n-    private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n-        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n-        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n-        return new MethodInterceptorFilter(invocationNotifierHandler, settings);\n+        InvocationNotifierHandler oldHandler\n+                = (InvocationNotifierHandler) mockMaker.getHandler(mock);\n+        MockSettingsImpl settings = oldHandler.getMockSettings();\n+        InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n+                new MockHandler<T>(settings), settings);\n+        mockMaker.resetMock(mock, newHandler, settings);\n     }\n \n     public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n         }\n \n         if (isMockitoMock(mock)) {\n-            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n+            return (MockHandlerInterface) mockMaker.getHandler(mock);\n         } else {\n             throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n         }\n     }\n \n     private <T> boolean isMockitoMock(T mock) {\n-        return getInterceptor(mock) != null;\n-    }\n-\n-    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n-        if (!(mock instanceof Factory)) {\n-            return null;\n-        }\n-        Factory factory = (Factory) mock;\n-        Callback callback = factory.getCallback(0);\n-        if (callback instanceof MethodInterceptorFilter) {\n-            return (MethodInterceptorFilter) callback;\n-        }\n-        return null;\n+        return mockMaker.getHandler(mock) != null;\n     }\n \n     public MockName getMockName(Object mock) {\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n import java.io.IOException;\n import java.util.Map;\n import java.util.Set;\n \n-import javax.swing.text.ChangedCharSetException;\n-\n public interface IMethods {\n \n     boolean booleanReturningMethod();\n \n     String oneArray(Object[] array);\n     \n-    String canThrowException() throws ChangedCharSetException, CharacterCodingException; \n+    String canThrowException() throws CharacterCodingException; \n \n     String oneArray(String[] array);\n \n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n-import javax.swing.text.ChangedCharSetException;\n import java.io.IOException;\n-import java.util.*;\n import java.nio.charset.CharacterCodingException;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n public class MethodsImpl implements IMethods {\n     public boolean booleanReturningMethod() {\n         return null;\n     }\n \n-    public String canThrowException() throws ChangedCharSetException, CharacterCodingException {\n+    public String canThrowException() throws CharacterCodingException {\n         return null;\n     }\n ", "timestamp": 1326745697, "metainfo": ""}