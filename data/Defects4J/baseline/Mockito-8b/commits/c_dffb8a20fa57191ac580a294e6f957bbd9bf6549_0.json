{"sha": "dffb8a20fa57191ac580a294e6f957bbd9bf6549", "log": "sorted out verification error messages so that they are not the same in some special cases  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40172", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n             && argumentsMatch(actual.getArguments());\n     }\n     \n-    public boolean matchesButNotMethodDeclaredClass(Invocation actual) {\n+    public boolean matchesMockArgsAndMethodNameButMethodNotEqual(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n             && argumentsMatch(actual.getArguments())\n             && invocation.getMethod().getName().equals(actual.getMethod().getName())\n-            && invocation.getMethod().getDeclaringClass() != actual.getMethod().getDeclaringClass();\n+            && !invocation.getMethod().equals(actual.getMethod());\n     }\n \n     private boolean argumentsMatch(Object[] arguments) {\n--- a/src/org/mockito/internal/invocation/InvocationsPrinter.java\n+++ b/src/org/mockito/internal/invocation/InvocationsPrinter.java\n     private final String actual;\n \n     public InvocationsPrinter(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n-        if (wantedInvocation.matchesButNotMethodDeclaredClass(actualInvocation)) {\n+        if (wantedInvocation.matchesButMocksAreDifferent(actualInvocation)) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber(); \n+        } else if (wantedInvocation.matchesMockArgsAndMethodNameButMethodNotEqual(actualInvocation)) {\n             wanted = wantedInvocation.toStringWithArgumentTypes();\n             actual = actualInvocation.toStringWithArgumentTypes();\n-        } else if (wantedInvocation.matchesButMocksAreDifferent(actualInvocation)) {\n-            wanted = wantedInvocation.toStringWithSequenceNumber();\n-            actual = actualInvocation.toStringWithSequenceNumber();\n         } else {\n             wanted = wantedInvocation.toString();\n             actual = actualInvocation.toString();\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n         this.args = args;\n         return this;\n     }\n+    \n+    public InvocationBuilder arg(Object o) {\n+        this.args = new Object[] {o};\n+        return this;\n+    }\n \n     public InvocationBuilder mock(Object mock) {\n         this.mock = mock;\n--- a/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n \n     @Before\n     public void setup() throws Exception {\n-        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n-        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n-        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n         calculator = new InvocationsCalculator(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n     }\n     \n--- a/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n \n     @Before\n     public void setup() throws Exception {\n-        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n-        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n-        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n-        simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n+        simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().simpleMethod().seq(4).toInvocation();\n         \n         chunker = new InvocationsChunker(new InvocationsFinder() {\n             public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n--- a/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n \n     @Before\n     public void setup() throws Exception {\n-        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n-        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n-        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n-        simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n+        simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().simpleMethod().seq(4).toInvocation();\n         \n         invocations = Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation, simpleMethodInvocationThree);\n         \n--- a/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n package org.mockito.internal.invocation;\n \n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n \n-import org.junit.Ignore;\n+import java.lang.reflect.Method;\n+\n import org.junit.Test;\n \n public class InvocationsPrinterTest {\n         assertEquals(\"Object#2.simpleMethod()\", printer.printActual());\n     }\n     \n-    @Ignore\n+    class Super {\n+        void test(Object o) {};\n+    }\n+    \n+    class Sub extends Super {\n+        void test(String s) {};\n+    }\n+\n     @Test\n-    public void shouldPrintTypesWantedAndActualWhenInvocationIsTheSame() throws Exception {\n-        fail(\"todo\");\n-        InvocationMatcher mockOneMethod = new InvocationBuilder().mock(\"mockOne\").seq(1).toInvocationMatcher();\n-        Invocation mockTwoMethod = new InvocationBuilder().mock(\"mockTwo\").seq(2).toInvocation();\n-        InvocationsPrinter printer = new InvocationsPrinter(mockOneMethod, mockTwoMethod);\n+    public void shouldPrintSequenceNumbersWhenMatchesButMocksDifferent() throws Exception {\n+        Method methodOne = Super.class.getDeclaredMethod(\"test\", Object.class);\n+        Method methodTwo = Sub.class.getDeclaredMethod(\"test\", String.class);\n         \n-        assertEquals(\"Object#1.simpleMethod()\", printer.printWanted());\n-        assertEquals(\"Object#2.simpleMethod()\", printer.printActual());\n+        InvocationMatcher invocationOne = new InvocationBuilder().method(methodOne).toInvocationMatcher();\n+        Invocation invocationTwo = new InvocationBuilder().method(methodTwo).toInvocation();\n+        InvocationsPrinter printer = new InvocationsPrinter(invocationOne, invocationTwo);\n+        \n+        assertEquals(invocationOne.toString(), invocationTwo.toString());\n+        \n+        assertEquals(\"Object.test(class java.lang.Object)\", printer.printWanted());\n+        assertEquals(\"Object.test(class java.lang.String)\", printer.printActual());\n+    }\n+    \n+    class Dummy {\n+        void test(String ... s) {};\n+        void test(Object ... o) {};\n+    }\n+    \n+    @Test\n+    public void shouldPrintTypesWhenMockArgsAndMethodNameMatchButMethodNotEqual() throws Exception {\n+        Method methodOne = Dummy.class.getDeclaredMethod(\"test\", new Object[]{}.getClass());\n+        Method methodTwo = Dummy.class.getDeclaredMethod(\"test\", new String[]{}.getClass());\n+        \n+        InvocationMatcher invocationOne = new InvocationBuilder().method(methodOne).arg(new Object[]{}).toInvocationMatcher();\n+        Invocation invocationTwo = new InvocationBuilder().method(methodTwo).arg(new String[]{}).toInvocation();\n+        InvocationsPrinter printer = new InvocationsPrinter(invocationOne, invocationTwo);\n+        \n+        assertEquals(invocationOne.toString(), invocationTwo.toString());\n+        \n+        assertEquals(\"Object.test(class [Ljava.lang.Object;)\", printer.printWanted());\n+        assertEquals(\"Object.test(class [Ljava.lang.String;)\", printer.printActual());\n     }\n }\n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n         stubber = new Stubber(state);\n         stubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n         \n-        simpleMethod = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n     }\n \n     @Test\n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n         stubber.addReturnValue(\"simpleMethod\");\n         \n-        Invocation differentMethod = new InvocationBuilder().method(\"differentMethod\").toInvocation();\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n         stubber.addThrowable(new MyException());\n         \n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n         stubber.addReturnValue(\"simpleMethod\");\n         \n-        Invocation differentMethod = new InvocationBuilder().method(\"differentMethod\").toInvocation();\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n         \n         assertEquals(null, stubber.resultFor(differentMethod));\n     }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     void varargsString(int i, String... string);\n \n     Object varargsObject(int i, Object... object);\n+    \n+    void varargs(Object ... object);\n+    \n+    void varargs(String ... string);\n \n     List<String> listReturningMethod(Object ... objects);\n }\n--- a/test/org/mockitousage/binding/BridgeMethodPuzzleTest.java\n+++ b/test/org/mockitousage/binding/BridgeMethodPuzzleTest.java\n     private class Sub extends Super<String> {\n         @Override\n         public String say(String t)  {\n-            return \"Sub says: \" + t;\n+            return \"Dummy says: \" + t;\n         }\n     }\n \n     public void shouldHaveBridgeMethod() throws Exception {\n         Super s = new Sub();\n         \n-        assertEquals(\"Sub says: Hello\", s.say(\"Hello\"));\n+        assertEquals(\"Dummy says: Hello\", s.say(\"Hello\"));\n         \n         assertThat(Sub.class, hasBridgeMethod(\"say\"));\n         assertThat(s, hasBridgeMethod(\"say\"));\n     \n     @Test\n     public void shouldVerifyCorrectlyWhenBridgeMethodCalled() throws Exception {\n-        //Super has following erasure: say(Object) which differs from Sub.say(String)\n+        //Super has following erasure: say(Object) which differs from Dummy.say(String)\n         //mock has to detect it and do the super.say()\n         //see MockFactory.java\n         Sub s = mock(Sub.class);\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n import static org.mockito.CrazyMatchers.aryEq;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-import static org.mockito.util.ExtraMatchers.*;\n-\n-import org.junit.*;\n-import org.mockito.*;\n-import org.mockito.exceptions.cause.*;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.matches;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.util.ExtraMatchers.causeMessageContains;\n+import static org.mockito.util.ExtraMatchers.messageContains;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.cause.UndesiredInvocation;\n+import org.mockito.exceptions.cause.WantedDiffersFromActual;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n \n             assertThat(e, causeMessageContains(\"simpleMethod(null, null)\"));\n         }\n     }\n+    \n+    @Test\n+    public void shouldPrintTypesWhenMethodSupposablyTheSame() throws Exception {\n+        mock.varargs((Object[]) new Object[] {});\n+        try {\n+            verify(mock).varargs((String[]) new String[] {});\n+            fail();\n+        } catch(VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.varargs(class [Ljava.lang.String;)\"));\n+            assertThat(e, causeMessageContains(\"IMethods.varargs(class [Ljava.lang.Object;)\"));\n+        }\n+    }\n }", "timestamp": 1197586797, "metainfo": ""}