{"sha": "3f9ad60102e69b886e097cec8fbe6e621b7e00e0", "log": "Fixed the transient problem that caused test failures.  Ensure the state is reset correctly after a test run. Enabled back the test that was disabled previously.", "commit": "\n--- a/test/org/mockito/StateMaster.java\n+++ b/test/org/mockito/StateMaster.java\n \n     public void reset() {\n         mockingProgress.reset();\n+        mockingProgress.resetOngoingStubbing();\n     }\n     \n     public void validate() {\n--- a/test/org/mockitousage/bugs/ParentClassNotPublicVeryWeirdBugTest.java\n+++ b/test/org/mockitousage/bugs/ParentClassNotPublicVeryWeirdBugTest.java\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockitoutil.TestBase;\n \n-import static org.fest.assertions.Assertions.assertThat;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n \n //see bug 212\n // @Ignore(\"needs fixing\")\n         Mockito.when(clazzMock.isValid()).thenReturn(true);\n     }\n \n-    //this code here (let's call it LEO) is only needed to reproduce the issue with concurrency. Start:\n-    class Foo {\n-        int blah(String a, String b, Object ... c) {\n-            return 1;\n-        }\n-    }\n-\n     @Test\n-    public void leo() throws Exception {\n-        Foo foo = mock(Foo.class);\n-\n-        when(foo.blah(anyString(), anyString())).thenCallRealMethod();\n-\n-        assertEquals(1, foo.blah(\"foo\", \"bar\"));\n-    }\n-    //end of the code that should not be included in this test.\n-\n-    @Test\n-    @Ignore\n-    //This test fails consistently when leo runs before. Find out why, write proper test, get rid of leo\n-    //@Before method in the TestBase should clear all the dodgy state after leo so it's intriguing why it does not work\n     public void report_why_this_exception_happen() throws Exception {\n         ClassForMocking clazzMock = mock(ClassForMocking.class);\n         try {\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.Invocation;\n \n-import java.io.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n import java.util.Collection;\n \n import static org.mockito.Mockito.mock;\n     public void cleanUpConfigInAnyCase() {\n         ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n         ConfigurationAccess.getConfig().overrideDefaultAnswer(null);\n-        new StateMaster().validate();\n+        StateMaster state = new StateMaster();\n+        //catch any invalid state left over after test case run\n+        //this way we can catch early if some Mockito operations leave weird state afterwards\n+        state.validate();\n+        //reset the state, especially, reset any ongoing stubbing for correct error messages of tests that assert unhappy paths\n+        state.reset();\n     }\n \n     @Before", "timestamp": 1411925290, "metainfo": ""}