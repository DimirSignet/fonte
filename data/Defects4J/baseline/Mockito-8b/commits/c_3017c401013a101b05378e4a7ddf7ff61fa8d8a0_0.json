{"sha": "3017c401013a101b05378e4a7ddf7ff61fa8d8a0", "log": "added nice message when the same mocks / same methods fail in strict verification  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40100", "commit": "\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n  */\n public class Exceptions {\n     \n-    public static final String STRICT_DISCREPANCY = \"Strict order verification failed\";\n-    public static final String REGULAR_DISCREPANCY = \"Invocation differs from actual\";\n-\n     private static String join(String ... linesToBreak) {\n         StringBuilder out = new StringBuilder(\"\\n\");\n         for (String line : linesToBreak) {\n         \n     }\n     \n-    public static void wantedInvocationDiffersFromActual(String wanted, String actual, String message) {\n+    public static void wantedInvocationDiffersFromActual(String wanted, String actual) {\n         throw new VerificationError(join(\n-                    message,\n-                    \"Wanted: \" + wanted,\n-                    \"Actual: \" + actual\n-                ));\n+                \"Invocation differs from actual\",\n+                \"Wanted: \" + wanted,\n+                \"Actual: \" + actual\n+            ));\n+    }\n+    \n+\n+    public static void strictlyWantedInvocationDiffersFromActual(String wanted, String actual) {\n+        throw new VerificationError(join(\n+                \"Strict order verification failed\",\n+                \"Wanted: \" + wanted,\n+                \"Actual: \" + actual\n+            ));\n+        \n     }\n \n     public static void wantedButNotInvoked(String wanted) {\n--- a/src/org/mockito/internal/ExpectedInvocation.java\n+++ b/src/org/mockito/internal/ExpectedInvocation.java\n         }\n         return true;\n     }\n-\n+    \n+    public String toStringWithSequenceNumber() {\n+        return this.invocation.toStringWithSequenceNumber(matchers);\n+    }\n+    \n     public String toString() {\n         return invocation.toString(matchers);\n     }\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n         return parameterTypes[parameterPosition].isPrimitive();\n     }\n \n-    public String getMockAndMethodName() {\n-        String mockName = Namer.nameForMock(mock);\n-        return mockName + \".\" + method.getName();\n+    private String getMockAndMethodName() {\n+        return Namer.nameForMock(mock) + \".\" + method.getName();\n     }\n     \n+    private String getMockAndMethodNameWithSeqenceNumber() {\n+        return Namer.nameForMock(mock) + \"#\" + sequenceNumber + \".\" + method.getName();\n+    }\n+\n     public String toString() {\n+        List<IArgumentMatcher> matchers = argumentsToMatchers();\n+        return toString(matchers);\n+    }\n+\n+    private List<IArgumentMatcher> argumentsToMatchers() {\n         List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n         for (Object arg : this.arguments) {\n             matchers.add(new Equals(arg));\n         }\n-        return toString(matchers);\n+        return matchers;\n     }\n     \n+    public String toString(List<IArgumentMatcher> matchers) {\n+        return getMockAndMethodName() + getArgumentsString(matchers);\n+    }\n+\n     //TODO don't use matchers to do printing args. there should be separate thing to print that stuff\n-    public String toString(List<IArgumentMatcher> matchers) {\n+    private String getArgumentsString(List<IArgumentMatcher> matchers) {\n+        //TODO all StringBuffers need to be StringBuilders...\n         StringBuffer result = new StringBuffer();\n-        result.append(getMockAndMethodName());\n         result.append(\"(\");\n         for (IArgumentMatcher matcher : matchers) {\n             matcher.appendTo(result);\n         } \n         return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n     }\n-\n+    \n     public void markVerified() {\n         verified = true;\n     }\n     public boolean isVerifiedInOrder() {\n         return verifiedInOrder;\n     }\n+\n+    public String toStringWithSequenceNumber() {\n+        return toStringWithSequenceNumber(argumentsToMatchers());\n+    }\n+\n+    public String toStringWithSequenceNumber(List<IArgumentMatcher> matchers) {\n+        return getMockAndMethodNameWithSeqenceNumber() + getArgumentsString(matchers);\n+    }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n         Invocation actual = registeredInvocations.findSimilarInvocation(wanted);\n         \n         if (actual != null) {\n-            reportDiscrepancy(wanted, actual, Exceptions.REGULAR_DISCREPANCY);\n+            reportDiscrepancy(wanted, actual);\n         } else {\n             Exceptions.wantedButNotInvoked(wanted.toString());\n         }\n     }\n \n-    private void reportDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation, String message) {\n+    private void reportDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation) {\n         String wanted = wantedInvocation.toString();\n         String actual = actualInvocation.toString();\n         if (wanted.equals(actual)) {\n             actual = actualInvocation.toStringWithArgumentTypes();\n         }\n         \n-        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, message);\n+        Exceptions.wantedInvocationDiffersFromActual(wanted, actual);\n+    }\n+    \n+    private void reportStrictOrderDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        boolean sameMocks = wantedInvocation.getInvocation().getMock().equals(actualInvocation.getMock());\n+        boolean sameMethods = wanted.equals(actual);\n+        if (sameMethods && !sameMocks) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber();\n+        } else if (sameMethods) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.strictlyWantedInvocationDiffersFromActual(wanted, actual);\n     }\n \n     private void checkOrderOfInvocations(ExpectedInvocation wanted, VerifyingMode mode) {\n         }\n         \n         if (!wanted.matches(chunks.get(0).getInvocation())) {\n-            reportDiscrepancy(wanted, chunks.get(0).getInvocation(), Exceptions.STRICT_DISCREPANCY);\n+            reportStrictOrderDiscrepancy(wanted, chunks.get(0).getInvocation());\n         }\n         \n         if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.wantedCount()) {\n--- a/test/org/mockito/usage/verification/NiceMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesOnStrictOrderErrorsTest.java\n import org.junit.*;\n import org.mockito.*;\n import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n import org.mockito.usage.IMethods;\n \n public class NiceMessagesOnStrictOrderErrorsTest {\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }  \n+    \n+    @Test\n+    public void shouldPrintSequenceNumberWhenMocksAndMethodsAreTheSame() {\n+        StateResetter.reset();\n+        one = mock(IMethods.class);\n+        two = mock(IMethods.class);\n+        \n+        one.simpleMethod();\n+        two.simpleMethod();\n+        \n+        strictly = createStrictOrderVerifier(one, two);\n+        \n+        try {\n+            strictly.verify(two).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +    \n+                    \"Strict order verification failed\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods#3.simpleMethod()\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods#1.simpleMethod()\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n }\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n     public void shouldFailOnVerifyZeroInteractions() {\n         verifyZeroInteractions(mockOne);\n     }\n+    \n+    @Test\n+    public void shouldVerifySingleMockStrictly() {\n+        mockOne = mock(IMethods.class);\n+        strictly = createStrictOrderVerifier(mockOne);\n+        \n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(2);\n+        \n+        verify(mockOne).simpleMethod(2);\n+        verify(mockOne).simpleMethod(1);\n+        \n+        try {\n+            strictly.verify(mockOne).simpleMethod(2);\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n }", "timestamp": 1196423795, "metainfo": ""}