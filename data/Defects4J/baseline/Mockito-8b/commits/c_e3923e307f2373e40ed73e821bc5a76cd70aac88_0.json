{"sha": "e3923e307f2373e40ed73e821bc5a76cd70aac88", "log": "Load default plugins dynamically", "commit": "\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n-import org.mockito.internal.creation.CglibMockMaker;\n-import org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider;\n import org.mockito.plugins.MockMaker;\n import org.mockito.plugins.StackTraceCleanerProvider;\n \n  * </p>\n  */\n public class ClassPathLoader {\n+    private static final String DEFAULT_MOCK_MAKER_CLASS =\n+            \"org.mockito.internal.creation.CglibMockMaker\";\n+    private static final String DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS =\n+            \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\";\n+    public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n+\n     private static final MockMaker mockMaker = findPlatformMockMaker();\n     private static final StackTraceCleanerProvider stackTraceCleanerProvider =\n-            findPluginImplementation(StackTraceCleanerProvider.class, new DefaultStackTraceCleanerProvider());\n-    public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n+            findPlatformStackTraceCleanerProvider();\n \n     /**\n      * @return configuration loaded from classpath or null\n     /**\n      * Returns the implementation of the mock maker available for the current runtime.\n      *\n-     * <p>Returns {@link CglibMockMaker} if no {@link MockMaker} extension exists\n-     * or is visible in the current classpath.</p>\n+     * <p>Returns {@link org.mockito.internal.creation.CglibMockMaker} if no\n+     * {@link MockMaker} extension exists or is visible in the current classpath.</p>\n      */\n     public static MockMaker getMockMaker() {\n         return mockMaker;\n      * allowing mockito to run on alternative platforms like Android.\n      */\n     static MockMaker findPlatformMockMaker() {\n-        return findPluginImplementation(MockMaker.class, new CglibMockMaker());\n+        return findPluginImplementation(MockMaker.class, DEFAULT_MOCK_MAKER_CLASS);\n     }\n \n-    static <T> T findPluginImplementation(Class<T> pluginType, T defaultPlugin) {\n+    static StackTraceCleanerProvider findPlatformStackTraceCleanerProvider() {\n+        return findPluginImplementation(\n+                StackTraceCleanerProvider.class, DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS);\n+    }\n+\n+    static <T> T findPluginImplementation(Class<T> pluginType, String defaultPluginClassName) {\n         for (T plugin : loadImplementations(pluginType)) {\n             return plugin; // return the first one service loader finds (if any)\n         }\n-        return defaultPlugin; // default implementation\n+\n+        try {\n+            // Default implementation. Use our own ClassLoader instead of the context\n+            // ClassLoader, as the default implementation is assumed to be part of\n+            // Mockito and may not be available via the context ClassLoader.\n+            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n+        } catch (Exception e) {\n+            throw new MockitoException(\"Failed to load default \" + pluginType, e);\n+        }\n     }\n \n     /**", "timestamp": 1354198285, "metainfo": ""}