{"sha": "78621206cd311054c14895b9f966e819ea63c9ec", "log": "fixed sources according to checkstyle  --HG-- rename : pmd-rules.xml => conf/pmd-rules.xml extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40201", "commit": "\n--- a/src/org/mockito/CrazyMatchers.java\n+++ b/src/org/mockito/CrazyMatchers.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.CompareEqual;\n+import org.mockito.internal.matchers.Contains;\n+import org.mockito.internal.matchers.EndsWith;\n+import org.mockito.internal.matchers.Find;\n+import org.mockito.internal.matchers.GreaterOrEqual;\n+import org.mockito.internal.matchers.GreaterThan;\n+import org.mockito.internal.matchers.LessOrEqual;\n+import org.mockito.internal.matchers.LessThan;\n+import org.mockito.internal.matchers.Same;\n+import org.mockito.internal.matchers.StartsWith;\n import org.mockito.internal.progress.LastArguments;\n \n public class CrazyMatchers {\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.Any;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.EqualsWithDelta;\n+import org.mockito.internal.matchers.InstanceOf;\n+import org.mockito.internal.matchers.Matches;\n+import org.mockito.internal.matchers.NotNull;\n+import org.mockito.internal.matchers.Null;\n import org.mockito.internal.progress.LastArguments;\n \n public class Matchers {\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n \n-import org.mockito.exceptions.*;\n-import org.mockito.internal.*;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.MockControl;\n+import org.mockito.internal.MockUtil;\n import org.mockito.internal.creation.MockFactory;\n import org.mockito.internal.creation.ObjectMethodsFilter;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.*;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.stubbing.VoidMethodStubable;\n \n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n-    \n-    private static final Reporter reporter = new Reporter();\n-    static final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n-    \n+\n+    private static final Reporter REPORTER = new Reporter();\n+    static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n+\n     public static <T> T mock(Class<T> classToMock) {\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n-        MockControl<T> mockControl = new MockControl<T>(mockingProgress, new MatchersBinder());\n+        MockControl<T> mockControl = new MockControl<T>(MOCKING_PROGRESS, new MatchersBinder());\n         return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n                 classToMock, mockControl));\n     }\n \n     public static <T> OngoingStubbing<T> stub(T methodCallToStub) {\n-        mockingProgress.stubbingStarted();\n-        \n-        OngoingStubbing stubable = mockingProgress.pullStubable();\n+        MOCKING_PROGRESS.stubbingStarted();\n+\n+        OngoingStubbing stubable = MOCKING_PROGRESS.pullStubable();\n         if (stubable == null) {\n-            reporter.missingMethodInvocation();\n+            REPORTER.missingMethodInvocation();\n         }\n         return stubable;\n     }\n-    \n+\n     public static <T> T verify(T mock) {\n         return verify(mock, times(1));\n     }\n-    \n+\n     public static <T> T verify(T mock, VerificationMode mode) {\n         MockUtil.validateMock(mock);\n-        mockingProgress.verificationStarted(mode);\n+        MOCKING_PROGRESS.verificationStarted(mode);\n         return mock;\n     }\n \n-\t/**\n-\t * Throws an AssertionError if any of given mocks has any unverified interaction.\n+    /**\n+     * Throws an AssertionError if any of given mocks has any unverified interaction.\n      * <p>\n-     * Use this method after you verified all your mocks - to make sure that nothing \n+     * Use this method after you verified all your mocks - to make sure that nothing\n      * else was invoked on your mocks.\n      * <p>\n      * It's a good pattern not to use this method in every test method.\n-     * Test methods should focus on different behavior/interaction \n+     * Test methods should focus on different behavior/interaction\n      * and it's not necessary to call verifyNoMoreInteractions() all the time\n      * <p>\n      * Stubbed invocations are also treated as interactions.\n      *     //interactions\n      *     mock.doSomething();\n      *     mock.doSomethingUnexpected();\n-     *     \n+     *\n      *     //verification\n      *     verify(mock).doSomething();\n-     *     \n+     *\n      *     verifyNoMoreInteractions(mock);\n      *     //oups: 'doSomethingUnexpected()' is unexpected\n-\t *</pre>\n-\t *\n-\t * @param mocks\n-\t */\n-\tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n-\t    assertMocksNotEmpty(mocks);\n-\t    mockingProgress.validateState();\n-\t    for (Object mock : mocks) {\n+     *</pre>\n+     *\n+     * @param mocks\n+     */\n+    public static void verifyNoMoreInteractions(Object ... mocks) {\n+        assertMocksNotEmpty(mocks);\n+        MOCKING_PROGRESS.validateState();\n+        for (Object mock : mocks) {\n             MockUtil.getControl(mock).verifyNoMoreInteractions();\n         }\n-\t}\n+    }\n \n     public static void verifyZeroInteractions(Object ... mocks) {\n         verifyNoMoreInteractions(mocks);\n     }\n-    \n+\n     private static void assertMocksNotEmpty(Object[] mocks) {\n         if (mocks.length == 0) {\n-            reporter.mocksHaveToBePassedAsArguments();\n+            REPORTER.mocksHaveToBePassedAsArguments();\n         }\n     }\n-    \n+\n     public static <T> VoidMethodStubable<T> stubVoid(T mock) {\n         MockControl<T> control = MockUtil.getControl(mock);\n-        mockingProgress.stubbingStarted();\n+        MOCKING_PROGRESS.stubbingStarted();\n         return control;\n     }\n \n     public static Strictly createStrictOrderVerifier(Object ... mocks) {\n         if (mocks.length == 0) {\n-            reporter.mocksHaveToBePassedWhenCreatingStrictly();\n+            REPORTER.mocksHaveToBePassedWhenCreatingStrictly();\n         }\n         StrictOrderVerifier strictOrderVerifier = new StrictOrderVerifier();\n         for (Object mock : mocks) {\n         }\n         return strictOrderVerifier;\n     }\n-    \n+\n     public static VerificationMode atLeastOnce() {\n         return VerificationMode.atLeastOnce();\n     }\n-    \n+\n     public static VerificationMode times(int wantedNumberOfInvocations) {\n         return VerificationMode.times(wantedNumberOfInvocations);\n     }\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n  */\n package org.mockito;\n \n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.progress.VerificationMode;\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions;\n \n import static org.mockito.exceptions.StringJoiner.join;\n \n-import org.mockito.exceptions.cause.*;\n-import org.mockito.exceptions.misusing.*;\n-import org.mockito.exceptions.parents.*;\n-import org.mockito.exceptions.verification.*;\n+import org.mockito.exceptions.cause.FirstUndesiredInvocation;\n+import org.mockito.exceptions.cause.TooLittleInvocations;\n+import org.mockito.exceptions.cause.UndesiredInvocation;\n+import org.mockito.exceptions.cause.WantedDiffersFromActual;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.exceptions.verification.NumberOfInvocationsError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n \n /**\n  * One of the key points of mocking library is proper verification/exception\n  * messages. All messages in one place makes it easier to tune and amend.\n  */\n public class Reporter {\n-    \n+\n     private String pluralize(int number) {\n         return number == 1 ? \"1 time\" : number + \" times\";\n     }\n \n     public void checkedExceptionInvalid(Throwable t) {\n         throw new MockitoException(join(\n-        \t\t\"Checked exception is invalid for this method\",\n-        \t\t\"Invalid: \" + t\n-        \t\t));\n+                \"Checked exception is invalid for this method\",\n+                \"Invalid: \" + t\n+                ));\n     }\n \n     public void cannotStubWithNullThrowable() {\n         throw new MockitoException(join(\n                 \"Cannot stub with null throwable\"\n                 ));\n-        \n+\n     }\n-    \n+\n     public void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n         WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n                 \"Actual invocation:\",\n                 actual\n             ));\n-            \n+\n         cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n-        \n+\n         throw new VerificationError(join(\n                 \"Invocation differs from actual\",\n                 \"Wanted invocation:\",\n                 wanted\n             ), cause);\n     }\n-    \n+\n     public void wantedButNotInvoked(String wanted) {\n         throw new VerificationError(join(\n                     \"Wanted but not invoked:\",\n-                    wanted        \n+                    wanted\n         ));\n     }\n-    \n+\n     public void numberOfInvocationsDiffers(int wantedCount, int actualCount, String wanted) {\n         throw new NumberOfInvocationsError(join(\n                 wanted,\n     public void tooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n         FirstUndesiredInvocation cause = new FirstUndesiredInvocation(join(\"First undesired invocation:\"));\n         cause.setStackTrace(firstUndesired.getStackTrace());\n-        \n+\n         throw new TooManyActualInvocationsError(join(\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n     }\n-    \n+\n     public void tooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n         TooLittleInvocations cause = null;\n         if (lastActualInvocationStackTrace != null) {\n             cause = new TooLittleInvocations(join(\"Too little invocations:\"));\n             cause.setStackTrace(lastActualInvocationStackTrace.getStackTrace());\n         }\n-        \n+\n         throw new TooLittleActualInvocationsError(join(\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n-        ), cause);  \n+        ), cause);\n     }\n \n     public void noMoreInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n         UndesiredInvocation cause = buildUndesiredInvocationCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n         throw new VerificationError(join(\"No interactions wanted\"), cause);\n     }\n-    \n+\n     private UndesiredInvocation buildUndesiredInvocationCause(HasStackTrace actualInvocationStackTrace, String ... messageLines) {\n         UndesiredInvocation cause = new UndesiredInvocation(join(messageLines));\n         cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n--- a/src/org/mockito/exceptions/parents/CommonStackTraceRemover.java\n+++ b/src/org/mockito/exceptions/parents/CommonStackTraceRemover.java\n  */\n package org.mockito.exceptions.parents;\n \n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n \n \n public class CommonStackTraceRemover {\n         List<StackTraceElement> exceptionsPart = null;\n         List<StackTraceElement> exceptionsTrace = Arrays.asList(hasStackTrace.getStackTrace());\n         int length = exceptionsTrace.size();\n-        for(int i=0 ; i<length; i++) {\n+        for (int i = 0; i < length; i++) {\n             List<StackTraceElement> subList = exceptionsTrace.subList(i, length);\n             int lastStartingIndexOfSubList = Collections.lastIndexOfSubList(causeStackTrace, subList);\n             if (lastStartingIndexOfSubList == -1) {\n--- a/src/org/mockito/exceptions/parents/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/parents/MockitoAssertionError.java\n public class MockitoAssertionError extends AssertionError implements HasStackTrace {\n \n     private static final long serialVersionUID = 1L;\n-    protected StackTraceElement[] unfilteredStackTrace;\n+    private StackTraceElement[] unfilteredStackTrace;\n \n     public MockitoAssertionError(String message) {\n         super(message);\n--- a/src/org/mockito/exceptions/parents/MockitoException.java\n+++ b/src/org/mockito/exceptions/parents/MockitoException.java\n \n     private static final long serialVersionUID = 1L;\n \n-    protected StackTraceElement[] unfilteredStackTrace;\n+    private StackTraceElement[] unfilteredStackTrace;\n \n     public MockitoException(String message) {\n         super(message);\n--- a/src/org/mockito/exceptions/parents/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/parents/StackTraceFilter.java\n  */\n package org.mockito.exceptions.parents;\n \n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.List;\n \n \n public class StackTraceFilter {\n--- a/src/org/mockito/internal/creation/MockFactory.java\n+++ b/src/org/mockito/internal/creation/MockFactory.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.creation;\n                         sc, true));\n             }\n         };\n-        \n+\n         if (toMock.isInterface()) {\n-\t\t\tenhancer.setInterfaces(new Class[] { toMock });\n-\t\t} else {\n-\t\t\tenhancer.setSuperclass(toMock);\n-\t\t}\n-        \n+            enhancer.setInterfaces(new Class[] { toMock });\n+        } else {\n+            enhancer.setSuperclass(toMock);\n+        }\n+\n         enhancer.setCallbackType(interceptor.getClass());\n \n         Class mockClass = enhancer.createClass();\n         // allow class instantiation without calling a constructor.\n         // Fortunatly, the \"magic code\" is also called in getCallback which is\n         // why I'm calling it here mock.getCallback(0);\n-        \n+\n         mock.getCallback(0);\n \n         handler.setMock(mock);\n--- a/src/org/mockito/internal/creation/MockNamer.java\n+++ b/src/org/mockito/internal/creation/MockNamer.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.creation;\n public class MockNamer {\n \n     public static String nameForMock(Object mock) {\n-    \tif (mock.getClass().getInterfaces().length == 2) {\n-    \t\treturn mock.getClass().getInterfaces()[0].getSimpleName();\n-    \t} else {\n-    \t\treturn mock.getClass().getSuperclass().getSimpleName();\n-    \t}\n+        if (mock.getClass().getInterfaces().length == 2) {\n+            return mock.getClass().getInterfaces()[0].getSimpleName();\n+        } else {\n+            return mock.getClass().getSuperclass().getSimpleName();\n+        }\n     }\n }\n--- a/src/org/mockito/internal/creation/ObjenesisClassInstantiator.java\n+++ b/src/org/mockito/internal/creation/ObjenesisClassInstantiator.java\n \n public class ObjenesisClassInstantiator {\n \n-    public static Object newInstance(Class<?> clazz) throws InstantiationException {\n+    @SuppressWarnings(\"unchecked\")\n+    public static Object newInstance(Class clazz) throws InstantiationException {\n         return ObjenesisHelper.newInstance(clazz);\n     }\n }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     }\n \n     public boolean equals(Object o) {\n-        if (o == null || !o.getClass().equals(this.getClass()))\n+        if (o == null || !o.getClass().equals(this.getClass())) {\n             return false;\n+        }\n \n         Invocation other = (Invocation) o;\n \n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n \n public class InvocationMatcher {\n \n-    protected final Invocation invocation;\n-    protected final List<IArgumentMatcher> matchers;\n+    private final Invocation invocation;\n+    private final List<IArgumentMatcher> matchers;\n \n     public InvocationMatcher(Invocation invocation, List<IArgumentMatcher> matchers) {\n         if (matchers == null) {\n--- a/src/org/mockito/internal/invocation/InvocationsCalculator.java\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculator.java\n //TODO refactor to an object that holds Invocations and exposes some calculations\n public class InvocationsCalculator {\n \n-    public InvocationsCalculator() {}\n-    \n     public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n         int actual = 0;\n         for (Invocation registeredInvocation : invocations) {\n--- a/src/org/mockito/internal/invocation/InvocationsChunker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsChunker.java\n \n     /**\n      * chunk maybe empty, may have single invocation (usal case), or have\n-     * multiple the same invocations\n+     * multiple the same invocations.\n      * \n      * @param mocks\n      * @return\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n \n public class MatchersBinder {\n \n-    public InvocationMatcher bindMatchers(Invocation invocation) throws InvalidUseOfMatchersException {\n+    public InvocationMatcher bindMatchers(Invocation invocation) {\n         List<IArgumentMatcher> lastMatchers = LastArguments.instance().pullMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n         return invocationWithMatchers;\n     }\n \n-    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) throws InvalidUseOfMatchersException {\n+    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n         if (matchers != null) {\n             if (matchers.size() != invocation.getArguments().length) {\n                 throw new InvalidUseOfMatchersException(\n-                        + invocation.getArguments().length\n+                        invocation.getArguments().length\n                         + \" matchers expected, \" + matchers.size()\n                         + \" recorded.\");\n             }\n     }\n     \n     /**\n-     * if user passed bare arguments then create EqualsMatcher for every argument\n+     * if user passed bare arguments then create EqualsMatcher for every argument.\n      */\n     private List<IArgumentMatcher> createEqualsMatchers(Invocation invocation,\n             List<IArgumentMatcher> matchers) {\n--- a/src/org/mockito/internal/matchers/Any.java\n+++ b/src/org/mockito/internal/matchers/Any.java\n \n     public static final Any ANY = new Any();    \n     \n-    private Any() {\n-        \n-    }\n+    private Any() {}\n     \n     public boolean matches(Object actual) {\n         return true;\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n \n     @Override\n     public boolean equals(Object o) {\n-        if (o == null || !this.getClass().equals(o.getClass()))\n+        if (o == null || !this.getClass().equals(o.getClass())) {\n             return false;\n+        }\n         Equals other = (Equals) o;\n         return this.wanted == null && other.wanted == null\n                 || this.wanted != null\n--- a/src/org/mockito/internal/progress/LastArguments.java\n+++ b/src/org/mockito/internal/progress/LastArguments.java\n \n public class LastArguments {\n     \n-    private static ThreadLocal<LastArguments> INSTANCE = new ThreadLocal<LastArguments>();\n+    private static final ThreadLocal<LastArguments> INSTANCE = new ThreadLocal<LastArguments>();\n     \n     private Stack<IArgumentMatcher> matcherStack = new Stack<IArgumentMatcher>();\n \n--- a/src/org/mockito/internal/stubbing/EmptyReturnValues.java\n+++ b/src/org/mockito/internal/stubbing/EmptyReturnValues.java\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n-    protected static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n+    private static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n     \n     static {\n         emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());\n--- a/src/org/mockito/internal/verification/Verifier.java\n+++ b/src/org/mockito/internal/verification/Verifier.java\n import org.mockito.internal.progress.VerificationMode;\n \n public interface Verifier {\n-\n-    abstract void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode);\n-    \n+    void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode);\n }\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n  */\n package org.mockito;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.internal.MockUtil.*;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n+import static org.mockito.internal.MockUtil.getControl;\n+import static org.mockito.internal.MockUtil.validateMock;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.List;\n \n-import net.sf.cglib.proxy.*;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.NoOp;\n \n import org.junit.Test;\n import org.mockito.exceptions.misusing.NotAMockException;\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         List mock = Mockito.mock(List.class);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n-        assertNull(Mockito.mockingProgress.pullStubable());\n+        assertNull(Mockito.MOCKING_PROGRESS.pullStubable());\n     }\n     \n     @Test(expected=NotAMockException.class)\n--- a/test/org/mockito/RequiresValidState.java\n+++ b/test/org/mockito/RequiresValidState.java\n \n /**\n  * the easiest way to make sure that tests clean up invalid state is to require\n- * valid state for all tests\n+ * valid state for all tests.\n  */\n public class RequiresValidState {\n \n     @Before\n     public void requiresValidState() {\n-        Mockito.mockingProgress.validateState();\n+        Mockito.MOCKING_PROGRESS.validateState();\n     }\n }\n--- a/test/org/mockito/StateResetter.java\n+++ b/test/org/mockito/StateResetter.java\n public class StateResetter {\n     \n     public static void reset() {\n-        Mockito.mockingProgress.reset();\n+        Mockito.MOCKING_PROGRESS.reset();\n     }\n }\n--- a/test/org/mockito/exceptions/parents/MockitoAssertionErrorTest.java\n+++ b/test/org/mockito/exceptions/parents/MockitoAssertionErrorTest.java\n  */\n package org.mockito.exceptions.parents;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n--- a/test/org/mockito/exceptions/parents/MockitoExceptionTest.java\n+++ b/test/org/mockito/exceptions/parents/MockitoExceptionTest.java\n  */\n package org.mockito.exceptions.parents;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n--- a/test/org/mockito/exceptions/parents/StackTraceBuilder.java\n+++ b/test/org/mockito/exceptions/parents/StackTraceBuilder.java\n  */\n package org.mockito.exceptions.parents;\n \n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.List;\n \n public class StackTraceBuilder {\n     \n     public StackTraceElement[] toStackTrace() {\n         StackTraceElement[] trace = new StackTraceElement[methods.length];\n         \n-        for (int i = 0 ; i < methods.length ; i++) {\n+        for (int i = 0; i < methods.length; i++) {\n             trace[i] = new StackTraceElement(\"DummyClass\", methods[i], \"DummyClass.java\", 100);\n         }\n         \n--- a/test/org/mockito/exceptions/parents/StackTraceRemoverTest.java\n+++ b/test/org/mockito/exceptions/parents/StackTraceRemoverTest.java\n import static org.junit.Assert.assertThat;\n import static org.mockito.util.ExtraMatchers.collectionHasExactlyInOrder;\n \n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n  */\n package org.mockito.internal;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.*;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.progress.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n public class MockControlTest extends RequiresValidState {\n     \n     private class ExceptionThrowingBinder extends MatchersBinder {\n         @Override\n-        public InvocationMatcher bindMatchers(Invocation invocation)\n-                throws InvalidUseOfMatchersException {\n+        public InvocationMatcher bindMatchers(Invocation invocation) {\n             throw new InvalidUseOfMatchersException(\"\");\n         }\n     }\n--- a/test/org/mockito/internal/creation/CglibTest.java\n+++ b/test/org/mockito/internal/creation/CglibTest.java\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n \n-import net.sf.cglib.proxy.*;\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.creation.ObjenesisClassInstantiator;\n \n /**\n- * This test case is used to make sure that the way cglib is used is providing the expected behavior\n+ * This test case is used to make sure that the way cglib is used is providing the expected behavior.\n  */\n public class CglibTest extends RequiresValidState {\n \n     /**\n      * Check that an interceptor is used by only one instance of a class\n-     * @throws Exception\n+     * @throws Exception.\n      */\n     @Test \n     public void shouldCallbacksBeDifferent() throws Exception {\n--- a/test/org/mockito/internal/creation/MockFactoryTest.java\n+++ b/test/org/mockito/internal/creation/MockFactoryTest.java\n  */\n package org.mockito.internal.creation;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n import net.sf.cglib.proxy.Factory;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.creation.MockFactory;\n-import org.mockito.internal.creation.ObjectMethodsFilter;\n \n @SuppressWarnings(\"unchecked\")\n public class MockFactoryTest extends RequiresValidState {\n         try {\n             new ClassWithDodgyConstructor();\n             fail();\n-        } catch (Exception e) {};\n+        } catch (Exception e) {}\n         \n         MockFactory<ClassWithDodgyConstructor> factory = new MockFactory<ClassWithDodgyConstructor>();\n         ClassWithDodgyConstructor mock = factory.createMock(ClassWithDodgyConstructor.class, new MockAwareStub());\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n package org.mockito.internal.invocation;\n \n import java.lang.reflect.Method;\n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n \n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n package org.mockito.internal.invocation;\n \n import static java.util.Arrays.asList;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n \n-import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.internal.matchers.NotNull;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcherTest extends RequiresValidState {\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     private Invocation invocation;\n \n     @Before\n-    public void setup() throws SecurityException, NoSuchMethodException {\n+    public void setup() throws Exception {\n         invocation = new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n     }\n \n     \n     @Test\n     public void shouldPrintNull() {\n-        invocation = new InvocationBuilder().args((String)null).toInvocation();\n+        invocation = new InvocationBuilder().args((String) null).toInvocation();\n         assertEquals(\"Object.simpleMethod(null)\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintArray() {\n-        invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] {1,2,3}).toInvocation();\n+        invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] { 1, 2, 3 }).toInvocation();\n         assertEquals(\"Object.oneArray([1, 2, 3])\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintNullIfArrayIsNull() throws Exception {\n         Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n-        invocation = new InvocationBuilder().method(m).args((Object)null).toInvocation();\n+        invocation = new InvocationBuilder().method(m).args((Object) null).toInvocation();\n         assertEquals(\"Object.oneArray(null)\", invocation.toString());\n     }\n     \n--- a/test/org/mockito/internal/matchers/EqualsTest.java\n+++ b/test/org/mockito/internal/matchers/EqualsTest.java\n  */\n package org.mockito.internal.matchers;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.fail;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n--- a/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.parents.MockitoException;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.MockingProgressImpl;\n-import org.mockito.internal.progress.VerificationMode;\n \n public class MockingProgressImplTest extends RequiresValidState {\n \n--- a/test/org/mockito/internal/progress/VerificationModeTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeTest.java\n  */\n package org.mockito.internal.progress;\n \n+import static java.util.Arrays.asList;\n import static org.junit.Assert.assertEquals;\n-import static java.util.Arrays.*;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assert.fail;\n import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n import static org.mockito.internal.progress.VerificationMode.noMoreInteractions;\n-import static org.mockito.internal.progress.VerificationMode.*;\n+import static org.mockito.internal.progress.VerificationMode.strict;\n+import static org.mockito.internal.progress.VerificationMode.times;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n--- a/test/org/mockito/internal/stubbing/EmptyReturnValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/EmptyReturnValuesTest.java\n  */\n package org.mockito.internal.stubbing;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.stubbing.EmptyReturnValues;\n \n public class EmptyReturnValuesTest extends RequiresValidState {\n     \n     @SuppressWarnings(\"unchecked\")\n     @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n-        assertTrue(((Collection)EmptyReturnValues.emptyValueFor(Collection.class)).isEmpty());\n-        \n-        assertTrue(((Set)EmptyReturnValues.emptyValueFor(Set.class)).isEmpty());\n-        assertTrue(((SortedSet)EmptyReturnValues.emptyValueFor(SortedSet.class)).isEmpty());\n-        assertTrue(((HashSet)EmptyReturnValues.emptyValueFor(HashSet.class)).isEmpty());\n-        assertTrue(((TreeSet)EmptyReturnValues.emptyValueFor(TreeSet.class)).isEmpty());\n-        assertTrue(((LinkedHashSet)EmptyReturnValues.emptyValueFor(LinkedHashSet.class)).isEmpty());        \n+        assertTrue(((Collection) EmptyReturnValues.emptyValueFor(Collection.class)).isEmpty());\n \n-        assertTrue(((List)EmptyReturnValues.emptyValueFor(List.class)).isEmpty());\n-        assertTrue(((ArrayList)EmptyReturnValues.emptyValueFor(ArrayList.class)).isEmpty());\n-        assertTrue(((LinkedList)EmptyReturnValues.emptyValueFor(LinkedList.class)).isEmpty());\n-        \n-        assertTrue(((Map)EmptyReturnValues.emptyValueFor(Map.class)).isEmpty());\n-        assertTrue(((SortedMap)EmptyReturnValues.emptyValueFor(SortedMap.class)).isEmpty());\n-        assertTrue(((HashMap)EmptyReturnValues.emptyValueFor(HashMap.class)).isEmpty());\n-        assertTrue(((TreeMap)EmptyReturnValues.emptyValueFor(TreeMap.class)).isEmpty());\n-        assertTrue(((LinkedHashMap)EmptyReturnValues.emptyValueFor(LinkedHashMap.class)).isEmpty());\n+        assertTrue(((Set) EmptyReturnValues.emptyValueFor(Set.class)).isEmpty());\n+        assertTrue(((SortedSet) EmptyReturnValues.emptyValueFor(SortedSet.class)).isEmpty());\n+        assertTrue(((HashSet) EmptyReturnValues.emptyValueFor(HashSet.class)).isEmpty());\n+        assertTrue(((TreeSet) EmptyReturnValues.emptyValueFor(TreeSet.class)).isEmpty());\n+        assertTrue(((LinkedHashSet) EmptyReturnValues.emptyValueFor(LinkedHashSet.class)).isEmpty());\n+\n+        assertTrue(((List) EmptyReturnValues.emptyValueFor(List.class)).isEmpty());\n+        assertTrue(((ArrayList) EmptyReturnValues.emptyValueFor(ArrayList.class)).isEmpty());\n+        assertTrue(((LinkedList) EmptyReturnValues.emptyValueFor(LinkedList.class)).isEmpty());\n+\n+        assertTrue(((Map) EmptyReturnValues.emptyValueFor(Map.class)).isEmpty());\n+        assertTrue(((SortedMap) EmptyReturnValues.emptyValueFor(SortedMap.class)).isEmpty());\n+        assertTrue(((HashMap) EmptyReturnValues.emptyValueFor(HashMap.class)).isEmpty());\n+        assertTrue(((TreeMap) EmptyReturnValues.emptyValueFor(TreeMap.class)).isEmpty());\n+        assertTrue(((LinkedHashMap) EmptyReturnValues.emptyValueFor(LinkedHashMap.class)).isEmpty());\n         \n         assertNull(EmptyReturnValues.emptyValueFor(String.class));\n     }\n--- a/test/org/mockito/internal/stubbing/ResultTest.java\n+++ b/test/org/mockito/internal/stubbing/ResultTest.java\n package org.mockito.internal.stubbing;\n \n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.*;\n-import static org.mockito.util.ExtraMatchers.*;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;\n \n import java.util.Arrays;\n \n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n  */\n package org.mockito.internal.stubbing;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n import java.nio.charset.CharacterCodingException;\n \n-import org.junit.*;\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgressImpl;\n-import org.mockito.internal.stubbing.Stubber;\n \n public class StubberTest extends RequiresValidState{\n \n         try {\n             stubber.resultFor(simpleMethod);\n             fail();\n-        } catch (MyException e) {};\n+        } catch (MyException e) {}\n     }\n     \n     @Test\n         try {\n             stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));\n             fail();\n-        } catch (MockitoException e) {};\n+        } catch (MockitoException e) {}\n     }\n     \n     @Test\n         try {\n             stubber.addThrowable(null);\n             fail();\n-        } catch (MockitoException e) {};\n+        } catch (MockitoException e) {}\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.asList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n \n import java.util.List;\n \n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n-import static org.junit.Assert.*;\n \n public class NoMoreInvocationsVerifierTest extends RequiresValidState {\n \n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n package org.mockito.util;\n \n import java.lang.reflect.Method;\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n \n-import org.hamcrest.*;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.CoreMatchers;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n \n @SuppressWarnings(\"unchecked\")\n public class ExtraMatchers extends CoreMatchers {\n     public static <T> Matcher<String> containsString(final String text) {\n         return new BaseMatcher<String>() {\n             public boolean matches(Object string) {\n-                return ((String)string).contains(text); \n+                return ((String) string).contains(text); \n             }\n             public void describeTo(Description desc) {\n                 desc.appendText(\"string doesn't contain \" + text);\n     public static <T> Matcher<Throwable> messageContains(final String text) {\n         return new BaseMatcher<Throwable>() {\n             public boolean matches(Object throwable) {\n-                return ((Throwable)throwable).getMessage().contains(text); \n+                return ((Throwable) throwable).getMessage().contains(text);\n             }\n             public void describeTo(Description desc) {\n                 desc.appendText(\"exception's message doesn't contain \" + text);\n     public static <T> Matcher<Throwable> causeMessageContains(final String text) {\n         return new BaseMatcher<Throwable>() {\n             public boolean matches(Object throwable) {\n-                Throwable cause = ((Throwable)throwable).getCause();\n-                return cause == null? false : cause.getMessage().contains(text); \n+                Throwable cause = ((Throwable) throwable).getCause();\n+                return cause == null ? false : cause.getMessage().contains(text);\n             }\n             public void describeTo(Description desc) {\n                 desc.appendText(\"exception cause's message is not \" + text);\n \n             public boolean matches(Object collection) {\n                 for (T element : elements) {\n-                    if (((Collection)collection).contains(element) == false) {\n+                    if (((Collection) collection).contains(element) == false) {\n                         return false;\n                     }\n                 }\n         return new BaseMatcher<Collection>() {\n \n             public boolean matches(Object collection) {\n-                Collection actual = (Collection)collection;\n+                Collection actual = (Collection) collection;\n                 if (actual.size() != elements.length) {\n                     return false;\n                 }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n \n     String oneArg(String value);\n \n-    public String throwsNothing(boolean value);\n+    String throwsNothing(boolean value);\n \n-    public String throwsIOException(int count) throws IOException;\n+    String throwsIOException(int count) throws IOException;\n \n-    public String throwsError(int count) throws Error;\n+    String throwsError(int count);\n \n     String simpleMethod();\n     \n--- a/test/org/mockitousage/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/InvalidStateDetectionTest.java\n  */\n package org.mockitousage;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n-\n-import org.junit.*;\n-import org.mockito.*;\n-import org.mockito.exceptions.misusing.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.stubVoid;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.StateResetter;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n \n /**\n  * invalid state happens if:\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n     \n     public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n         List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n-        for(int i = 1 ; i <= numberOfThreads ; i++) {\n+        for (int i = 1; i <= numberOfThreads; i++) {\n             threads.add(new AllTestsRunner());\n         }\n-        \n+\n         for (Thread t : threads) {\n             t.start();\n         }\n-        \n-        boolean failed = false;        \n+\n+        boolean failed = false;\n         for (AllTestsRunner t : threads) {\n             t.join();\n-            failed = failed? true : t.isFailed();\n+            failed = failed ? true : t.isFailed();\n         }\n         \n         return failed;\n--- a/test/org/mockitousage/ReplacingObjectMethodsTest.java\n+++ b/test/org/mockitousage/ReplacingObjectMethodsTest.java\n  */\n package org.mockitousage;\n \n-import static org.hamcrest.CoreMatchers.*;\n-import static org.junit.Assert.*;\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n \n import org.junit.Test;\n-import org.mockito.*;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n \n public class ReplacingObjectMethodsTest extends RequiresValidState {\n \n--- a/test/org/mockitousage/StackTrackeChangingTest.java\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n  */\n package org.mockitousage;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n import static org.mockito.Mockito.verify;\n import static org.mockito.util.ExtraMatchers.hasMethodInStackTraceAt;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n \n public class StackTrackeChangingTest extends RequiresValidState {\n--- a/test/org/mockitousage/StackTrackeFilteringTest.java\n+++ b/test/org/mockitousage/StackTrackeFilteringTest.java\n  */\n package org.mockitousage;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.StateResetter;\n+import org.mockito.Strictly;\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.exceptions.verification.VerificationError;\n \n--- a/test/org/mockitousage/UsingVarargsTest.java\n+++ b/test/org/mockitousage/UsingVarargsTest.java\n  */\n package org.mockitousage;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.stubVoid;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n import java.util.ArrayList;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n \n public class UsingVarargsTest extends RequiresValidState {\n \n     private interface IVarArgs {\n-        public void withStringVarargs(int value, String... s);\n-        public String withStringVarargsReturningString(int value, String... s);\n-        public void withObjectVarargs(int value, Object... o);\n-        public boolean withBooleanVarargs(int value, boolean... b);\n+        void withStringVarargs(int value, String... s);\n+        String withStringVarargsReturningString(int value, String... s);\n+        void withObjectVarargs(int value, Object... o);\n+        boolean withBooleanVarargs(int value, boolean... b);\n     }\n     \n     IVarArgs mock;\n--- a/test/org/mockitousage/binding/BridgeMethodPuzzleTest.java\n+++ b/test/org/mockitousage/binding/BridgeMethodPuzzleTest.java\n  */\n package org.mockitousage.binding;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n import static org.mockito.util.ExtraMatchers.hasBridgeMethod;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.binding;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.util.ExtraMatchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.util.ExtraMatchers.causeMessageContains;\n+import static org.mockito.util.ExtraMatchers.messageContains;\n \n import org.junit.Test;\n-import org.mockito.*;\n+import org.mockito.CrazyMatchers;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n import org.mockito.exceptions.verification.VerificationError;\n \n public class IncorectBindingPuzzleFixedTest extends RequiresValidState {\n \n     private Super mock;\n-    \n+\n     private void setMockWithDowncast(Super mock) {\n         this.mock = mock;\n     }\n \n     private interface Super {\n-        public void say(Object message);\n+        void say(Object message);\n     }\n \n     private interface Sub extends Super {\n-        public void say(String message);\n+        void say(String message);\n     }\n \n     private void say(Object message) {\n             verify(sub).say(\"Hello\");\n             fail();\n         } catch (VerificationError error) {\n-            String expected = \n+            String expected =\n                 \"\\n\" +\n-        \t\t\"Invocation differs from actual\" +\n-        \t\t\"\\n\" +\n+                \"Invocation differs from actual\" +\n+                \"\\n\" +\n                 \"Wanted invocation:\" +\n                 \"\\n\" +\n                 \"Sub.say(class java.lang.String)\";\n-            \n+\n             assertEquals(expected, error.getMessage());\n-            \n-            String expectedCause = \n+\n+            String expectedCause =\n                 \"\\n\" +\n                 \"Actual invocation:\" +\n                 \"\\n\" +\n             assertEquals(expectedCause, error.getCause().getMessage());\n         }\n     }\n-    \n+\n     @Test\n     public void shouldUseArgumentTypeWhenOverloadingPuzzleDetectedByStrictly() throws Exception {\n         Sub sub = mock(Sub.class);\n             assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldUseArgumentTypeWhenMatcherUsed() throws Exception {\n         Sub sub = mock(Sub.class);\n--- a/test/org/mockitousage/matchers/ComparableMatchersTest.java\n+++ b/test/org/mockitousage/matchers/ComparableMatchersTest.java\n  */\n package org.mockitousage.matchers;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n import java.math.BigDecimal;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.CompareEqual;\n+import org.mockito.internal.matchers.CompareTo;\n+import org.mockito.internal.matchers.GreaterOrEqual;\n+import org.mockito.internal.matchers.GreaterThan;\n+import org.mockito.internal.matchers.LessOrEqual;\n+import org.mockito.internal.matchers.LessThan;\n \n public class ComparableMatchersTest extends RequiresValidState {\n \n--- a/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.matchers;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n import static org.mockito.Matchers.eq;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.CrazyMatchers;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.StateResetter;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class InvalidUseOfMatchersTest extends RequiresValidState {\n-    \n+\n     private IMethods mock;\n-    \n+\n     @Before\n     public void setUp() {\n         StateResetter.reset();\n         mock = Mockito.mock(IMethods.class);\n     }\n-    \n+\n     @After\n     public void resetState() {\n         StateResetter.reset();\n             fail();\n         } catch (InvalidUseOfMatchersException e) {}\n     }\n-    \n+\n     @Test\n     public void shouldDetectStupidUseOfMatchersWhenVerifying() {\n         mock.oneArg(true);\n             fail();\n         } catch (InvalidUseOfMatchersException e) {}\n     }\n-    \n+\n     @Test\n     public void shouldScreamWhenMatchersAreInvalid() {\n         mock.simpleMethod(CrazyMatchers.not(eq(\"asd\")));\n         } catch (InvalidUseOfMatchersException e) {\n             assertEquals(\n                     \"\\n\" +\n-            \t\t\"No matchers found for Not(?).\" +\n-            \t\t\"\\n\" +\n+                    \"No matchers found for Not(?).\" +\n+                    \"\\n\" +\n                     \"Read more: http://code.google.com/p/mockito/matchers\"\n-            \t\t, e.getMessage());\n+                    , e.getMessage());\n         }\n-        \n+\n         try {\n             mock.simpleMethod(CrazyMatchers.or(eq(\"jkl\"), \"asd\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n             assertEquals(\n                     \"\\n\" +\n-            \t\t\"2 matchers expected, 1 recorded.\" +\n+                    \"2 matchers expected, 1 recorded.\" +\n                     \"\\n\" +\n                     \"Read more: http://code.google.com/p/mockito/matchers\"\n                     , e.getMessage());\n         }\n-        \n+\n         try {\n             mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n             fail();\n--- a/test/org/mockitousage/matchers/MatchersTest.java\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.matchers;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.CrazyMatchers.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+import static org.mockito.CrazyMatchers.and;\n+import static org.mockito.CrazyMatchers.aryEq;\n+import static org.mockito.CrazyMatchers.cmpEq;\n+import static org.mockito.CrazyMatchers.contains;\n+import static org.mockito.CrazyMatchers.endsWith;\n+import static org.mockito.CrazyMatchers.find;\n+import static org.mockito.CrazyMatchers.geq;\n+import static org.mockito.CrazyMatchers.gt;\n+import static org.mockito.CrazyMatchers.leq;\n+import static org.mockito.CrazyMatchers.lt;\n+import static org.mockito.CrazyMatchers.not;\n+import static org.mockito.CrazyMatchers.or;\n+import static org.mockito.CrazyMatchers.same;\n+import static org.mockito.CrazyMatchers.startsWith;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyByte;\n+import static org.mockito.Matchers.anyChar;\n+import static org.mockito.Matchers.anyDouble;\n+import static org.mockito.Matchers.anyFloat;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.anyShort;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.isA;\n+import static org.mockito.Matchers.isNull;\n+import static org.mockito.Matchers.matches;\n+import static org.mockito.Matchers.notNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.verify;\n \n import java.math.BigDecimal;\n import java.util.HashMap;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n \n-@SuppressWarnings(\"unchecked\")  \n+@SuppressWarnings(\"unchecked\")\n public class MatchersTest extends RequiresValidState {\n     private IMethods mock;\n \n     public void setUp() {\n         mock = Mockito.mock(IMethods.class);\n     }\n-    \n+\n     @Test\n     public void andOverloaded() {\n         stub(mock.oneArg(and(eq(false), eq(false)))).andReturn(\"0\");\n \n         assertEquals(\"0\", mock.oneArg(false));\n         assertEquals(null, mock.oneArg(true));\n-        \n+\n         assertEquals(\"1\", mock.oneArg((byte) 1));\n         assertEquals(\"2\", mock.oneArg('a'));\n         assertEquals(\"3\", mock.oneArg((double) 1));\n         assertEquals(\"5\", mock.oneArg((int) 1));\n         assertEquals(\"6\", mock.oneArg((long) 1));\n         assertEquals(\"7\", mock.oneArg((short) 1));\n-        \n+\n         assertEquals(\"8\", mock.oneArg(\"abcde\"));\n         assertEquals(null, mock.oneArg(\"aaaaa\"));\n-        \n+\n         assertEquals(\"9\", mock.oneArg(Object.class));\n-        \n+\n     }\n \n     @Test\n \n         assertEquals(\"0\", mock.oneArg(true));\n         assertEquals(\"0\", mock.oneArg(false));\n-        \n+\n         assertEquals(\"1\", mock.oneArg((byte) 2));\n         assertEquals(\"2\", mock.oneArg((char) 1));\n         assertEquals(\"3\", mock.oneArg((double) 2));\n         assertEquals(\"5\", mock.oneArg((int) 2));\n         assertEquals(\"6\", mock.oneArg((long) 1));\n         assertEquals(\"7\", mock.oneArg((short) 1));\n-        \n+\n         assertEquals(\"8\", mock.oneArg(\"jkl\"));\n         assertEquals(\"8\", mock.oneArg(\"asd\"));\n         assertEquals(null, mock.oneArg(\"asdjkl\"));\n-        \n+\n         assertEquals(\"9\", mock.oneArg(Object.class));\n         assertEquals(null, mock.oneArg(String.class));\n     }\n \n         assertEquals(\"0\", mock.oneArg(true));\n         assertEquals(null, mock.oneArg(false));\n-        \n+\n         assertEquals(\"1\", mock.oneArg((byte) 2));\n         assertEquals(\"2\", mock.oneArg('b'));\n         assertEquals(\"3\", mock.oneArg((double) 2));\n         assertEquals(\"6\", mock.oneArg((long) 2));\n         assertEquals(\"7\", mock.oneArg((short) 2));\n         assertEquals(\"8\", mock.oneArg(\"bcde\"));\n-        \n+\n         assertEquals(\"9\", mock.oneArg(new Object()));\n         assertEquals(null, mock.oneArg(Class.class));\n     }\n \n         assertEquals(\"1\", mock.oneArg((byte) 1));\n         assertEquals(null, mock.oneArg((byte) 2));\n-        \n+\n         assertEquals(\"3\", mock.oneArg((double) 1));\n         assertEquals(\"7\", mock.oneArg((short) 0));\n         assertEquals(\"4\", mock.oneArg((float) -5));\n         assertEquals(\"5\", mock.oneArg((int) -2));\n         assertEquals(\"6\", mock.oneArg((long) -3));\n-        \n+\n         assertEquals(\"8\", mock.oneArg(new BigDecimal(\"0.5\")));\n         assertEquals(null, mock.oneArg(new BigDecimal(\"1.1\")));\n     }\n \n         assertEquals(\"1\", mock.oneArg((byte) 0));\n         assertEquals(null, mock.oneArg((byte) 1));\n-        \n+\n         assertEquals(\"3\", mock.oneArg((double) 0));\n         assertEquals(\"7\", mock.oneArg((short) 0));\n         assertEquals(\"4\", mock.oneArg((float) -4));\n         assertEquals(\"5\", mock.oneArg((int) -34));\n         assertEquals(\"6\", mock.oneArg((long) -6));\n-        \n+\n         assertEquals(\"8\", mock.oneArg(new BigDecimal(\"0.5\")));\n         assertEquals(null, mock.oneArg(new BigDecimal(\"23\")));\n     }\n \n         assertEquals(\"1\", mock.oneArg((byte) 2));\n         assertEquals(null, mock.oneArg((byte) 0));\n-        \n+\n         assertEquals(\"3\", mock.oneArg((double) 1));\n         assertEquals(\"7\", mock.oneArg((short) 2));\n         assertEquals(\"4\", mock.oneArg((float) 3));\n         assertEquals(\"5\", mock.oneArg((int) 4));\n         assertEquals(\"6\", mock.oneArg((long) 5));\n-        \n+\n         assertEquals(\"8\", mock.oneArg(new BigDecimal(\"1.00\")));\n         assertEquals(null, mock.oneArg(new BigDecimal(\"0.9\")));\n     }\n \n         assertEquals(\"1\", mock.oneArg((byte) 2));\n         assertEquals(null, mock.oneArg((byte) 1));\n-        \n+\n         assertEquals(\"3\", mock.oneArg((double) 2));\n         assertEquals(\"7\", mock.oneArg((short) 2));\n         assertEquals(\"4\", mock.oneArg((float) 3));\n         assertEquals(\"5\", mock.oneArg((int) 2));\n         assertEquals(\"6\", mock.oneArg((long) 5));\n-        \n+\n         assertEquals(\"8\", mock.oneArg(new BigDecimal(\"1.5\")));\n         assertEquals(null, mock.oneArg(new BigDecimal(\"0.9\")));\n     }\n \n         assertEquals(\"0\", mock.oneArg(true));\n         assertEquals(\"0\", mock.oneArg(false));\n-        \n+\n         assertEquals(\"1\", mock.oneArg((byte) 1));\n         assertEquals(\"2\", mock.oneArg((char) 1));\n         assertEquals(\"3\", mock.oneArg((double) 1));\n         assertEquals(\"6\", mock.oneArg((long) 1));\n         assertEquals(\"7\", mock.oneArg((short) 1));\n         assertEquals(\"8\", mock.oneArg(\"Test\"));\n-        \n+\n         assertEquals(\"9\", mock.oneArg(new Object()));\n         assertEquals(\"9\", mock.oneArg(new HashMap()));\n     }\n     public void shouldArrayEqualsDealWithNullArray() throws Exception {\n         Object[] nullArray = null;\n         stub(mock.oneArray(aryEq(nullArray))).andReturn(\"null\");\n-        \n+\n         assertEquals(\"null\", mock.oneArray(nullArray));\n-        \n+\n         mock = mock(IMethods.class);\n-        \n+\n         try {\n             verify(mock).oneArray(aryEq(nullArray));\n             fail();\n         } catch (VerificationError e) {\n             String expected = \"\\n\" +\n-            \t\t\"Wanted but not invoked:\" +\n-            \t\t\"\\n\" +\n-            \t\t\"IMethods.oneArray(null)\";\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.oneArray(null)\";\n             assertEquals(expected, e.getMessage());\n         }\n     }\n-    \n+\n     @Test\n     public void arrayEqualsMatcher() {\n         stub(mock.oneArray(aryEq(new boolean[] { true, false, false }))).andReturn(\"0\");\n         stub(mock.oneArray(aryEq(new short[] { 1 }))).andReturn(\"7\");\n         stub(mock.oneArray(aryEq(new String[] { \"Test\" }))).andReturn(\"8\");\n         stub(mock.oneArray(aryEq(new Object[] { \"Test\", new Integer(4) }))).andReturn(\"9\");\n-        \n+\n         assertEquals(\"0\", mock.oneArray(new boolean[] { true, false, false }));\n         assertEquals(\"1\", mock.oneArray(new byte[] { 1 }));\n         assertEquals(\"2\", mock.oneArray(new char[] { 1 }));\n         assertEquals(\"7\", mock.oneArray(new short[] { 1 }));\n         assertEquals(\"8\", mock.oneArray(new String[] { \"Test\" }));\n         assertEquals(\"9\", mock.oneArray(new Object[] { \"Test\", new Integer(4) }));\n-        \n+\n         assertEquals(null, mock.oneArray(new Object[] { \"Test\", new Integer(999) }));\n         assertEquals(null, mock.oneArray(new Object[] { \"Test\", new Integer(4), \"x\" }));\n-        \n+\n         assertEquals(null, mock.oneArray(new boolean[] { true, false }));\n         assertEquals(null, mock.oneArray(new boolean[] { true, true, false }));\n     }\n-    \n+\n     @Test\n     public void greaterOrEqualMatcher() {\n         stub(mock.oneArg(geq(7))).andReturn(\">= 7\");\n         assertEquals(\"1\", mock.oneArg(\"ab12\"));\n         assertEquals(null, mock.oneArg(\"12345\"));\n     }\n-    \n+\n     @Test\n     public void matchesMatcher() {\n         stub(mock.oneArg(matches(\"[a-z]+\\\\d\\\\d\"))).andReturn(\"1\");\n         assertEquals(\"3\", mock.oneArg(0.91F));\n         assertEquals(\"3\", mock.oneArg(1.09F));\n         assertEquals(\"4\", mock.oneArg(2.1F));\n-        \n+\n         assertEquals(null, mock.oneArg(2.2F));\n     }\n \n--- a/test/org/mockitousage/matchers/MatchersToStringTest.java\n+++ b/test/org/mockitousage/matchers/MatchersToStringTest.java\n \n import static org.junit.Assert.assertEquals;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.List;\n \n-import org.junit.*;\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.And;\n+import org.mockito.internal.matchers.Any;\n+import org.mockito.internal.matchers.Contains;\n+import org.mockito.internal.matchers.EndsWith;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.Find;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.internal.matchers.Matches;\n+import org.mockito.internal.matchers.Not;\n+import org.mockito.internal.matchers.NotNull;\n+import org.mockito.internal.matchers.Null;\n+import org.mockito.internal.matchers.Or;\n+import org.mockito.internal.matchers.Same;\n+import org.mockito.internal.matchers.StartsWith;\n \n public class MatchersToStringTest extends RequiresValidState {\n     private StringBuilder buffer;\n--- a/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n+++ b/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n  */\n package org.mockitousage.matchers;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n import static org.mockito.CrazyMatchers.startsWith;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.stubVoid;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n-import org.junit.*;\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n         try {\n             three.simpleMethod(\"test three again\");\n             fail();\n-        } catch (RuntimeException e) {};\n+        } catch (RuntimeException e) {}\n     }\n     \n     @Test\n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.sample;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n import java.util.Arrays;\n \n import org.junit.Test;\n-import org.mockito.*;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n \n public class MockitoSampleTest extends RequiresValidState {\n     \n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n  */\n package org.mockitousage.stubbing;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n import static org.mockito.Matchers.isA;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.stubVoid;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n \n-import org.junit.*;\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n--- a/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n+++ b/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n  */\n package org.mockitousage.stubbing;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n \n import org.junit.Test;\n-import org.mockito.*;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n         //this is mainly to prove that cglib-enchanted-thing works properly \n         //and returns primitive value rather than throw NullPointerException\n         //If we used java.lang.reflect.Proxy NullPointerException will bang\n-        assertEquals((byte)0, mock.byteReturningMethod(12));\n-        assertEquals((short)0, mock.shortReturningMethod(12));\n+        assertEquals((byte) 0, mock.byteReturningMethod(12));\n+        assertEquals((short) 0, mock.shortReturningMethod(12));\n         assertEquals(0, mock.intReturningMethod(12));\n         assertEquals(0L, mock.intReturningMethod(12));\n         assertEquals(0.0F, mock.floatReturningMethod(12), 0.0F);\n--- a/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n  */\n package org.mockitousage.stubbing;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import org.junit.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.stubVoid;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.exceptions.verification.VerificationError;\n--- a/test/org/mockitousage/verification/AtLeastOnceVerificationTest.java\n+++ b/test/org/mockitousage/verification/AtLeastOnceVerificationTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.verify;\n \n import java.util.List;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n--- a/test/org/mockitousage/verification/BasicVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n import java.util.List;\n \n-import org.junit.*;\n-import org.mockito.*;\n-import org.mockito.exceptions.verification.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicVerificationTest extends RequiresValidState {\n         try {\n             verify(mock).add(\"bar\");\n             fail();\n-        } catch (VerificationError expected) {};\n+        } catch (VerificationError expected) {}\n     }\n \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationError expected) {};\n+        } catch (VerificationError expected) {}\n     }\n     \n     @Test\n         try {\n             verify(mock).clear();\n             fail();\n-        } catch (TooManyActualInvocationsError e) {};\n+        } catch (TooManyActualInvocationsError e) {}\n     }\n \n     @Test\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.util.ExtraMatchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.util.ExtraMatchers.causeMessageContains;\n+import static org.mockito.util.ExtraMatchers.messageContains;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.StateResetter;\n+import org.mockito.Strictly;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n-import org.mockito.exceptions.verification.*;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n \n public class DescriptiveMessagesOnStrictOrderErrorsTest extends RequiresValidState {\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.verification;\n import org.mockitousage.IMethods;\n \n public class DescriptiveMessagesWhenVerificationFailsTest extends RequiresValidState {\n-    \n+\n     private IMethods mock;\n \n     @Before\n     public void setup() {\n         mock = Mockito.mock(IMethods.class);\n     }\n-    \n+\n     @Test\n     public void shouldPrintMethodName() {\n         try {\n             fail();\n         } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                    \"\\n\" +\n-            \t\t\"Wanted but not invoked:\" +\n-            \t\t\"\\n\" +\n-            \t\t\"IMethods.simpleMethod()\";\n-            assertEquals(expectedMessage, actualMessage);         \n-        }\n-    }\n-    \n+            String expectedMessage =\n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod()\";\n+            assertEquals(expectedMessage, actualMessage);\n+        }\n+    }\n+\n     private class SomeClass {\n         public String toString() {\n             return \"SomeClass instance\";\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintMethodNameAndArguments() {\n         try {\n             assertThat(e, messageContains(\"IMethods.threeArgumentMethod(12, SomeClass instance, \\\"xx\\\")\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintActualAndWantedWhenTheDifferenceIsAboutArguments() {\n         mock.oneArg(true);\n         mock.twoArgumentMethod(1, 2);\n-        \n+\n         verify(mock).oneArg(true);\n         try {\n             verify(mock).twoArgumentMethod(1, 1000);\n             fail();\n         } catch (VerificationError e) {\n-            String expected = \n+            String expected =\n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n                     \"\\n\" +\n                     \"Wanted invocation:\" +\n                     \"\\n\" +\n                     \"IMethods.twoArgumentMethod(1, 1000)\";\n-            \n+\n             assertEquals(expected, e.getMessage());\n-            \n+\n             assertEquals(e.getCause().getClass(), WantedDiffersFromActual.class);\n-            \n+\n             String expectedCause =\n                     \"\\n\" +\n                     \"Actual invocation:\" +\n                     \"\\n\" +\n                     \"IMethods.twoArgumentMethod(1, 2)\";\n-            \n-            assertEquals(expectedCause, e.getCause().getMessage());      \n-        }\n-    }\n-    \n+\n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }\n+\n     @Test\n     public void shouldPrintActualAndWantedWhenActualMethodNameAndWantedMethodNameAreTheSame() {\n         mock.simpleMethod();\n-        \n+\n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n             assertThat(e, messageContains(\"IMethods.simpleMethod(\\\"test\\\")\"));\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n         }\n-    }    \n-    \n+    }\n+\n     @Test\n     public void shouldTreatFirstUnverifiedInvocationAsActualInvocation() {\n         mock.oneArg(true);\n         mock.simpleMethod();\n         mock.differentMethod();\n         mock.twoArgumentMethod(1, 2);\n-        \n+\n         try {\n             verify(mock).oneArg(true);\n             verify(mock).differentMethod();\n             assertThat(e, messageContains(\"IMethods.threeArgumentMethod(1, \\\"2\\\", \\\"3\\\")\"));\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n         }\n-    }  \n-    \n+    }\n+\n     @Test\n     public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments() {\n         mock.twoArgumentMethod(1, 1);\n         mock.twoArgumentMethod(2, 2);\n         mock.twoArgumentMethod(3, 3);\n-        \n+\n         verify(mock).twoArgumentMethod(1, 1);\n         verify(mock).twoArgumentMethod(2, 2);\n         try {\n             assertThat(e, messageContains(\"IMethods.twoArgumentMethod(3, 1000)\"));\n             assertThat(e, causeMessageContains(\"IMethods.twoArgumentMethod(3, 3)\"));\n         }\n-    }  \n-    \n+    }\n+\n     @Test\n     public void shouldPrintFirstUnexpectedInvocation() {\n         mock.oneArg(true);\n         mock.oneArg(false);\n         mock.threeArgumentMethod(1, \"2\", \"3\");\n-        \n+\n         verify(mock).oneArg(true);\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n         } catch (VerificationError e) {\n-            String expectedMessage = \n-                    \"\\n\" +\n-            \t\t\"No interactions wanted\";\n-            assertEquals(expectedMessage, e.getMessage());         \n+            String expectedMessage =\n+                    \"\\n\" +\n+                    \"No interactions wanted\";\n+            assertEquals(expectedMessage, e.getMessage());\n \n             assertEquals(e.getCause().getClass(), UndesiredInvocation.class);\n-            \n+\n             String expectedCause =\n-            \t\t\"\\n\" +\n-            \t\t\"Undesired invocation:\" +\n-            \t\t\"\\n\" +\n-            \t\t\"IMethods.oneArg(false)\";\n+                    \"\\n\" +\n+                    \"Undesired invocation:\" +\n+                    \"\\n\" +\n+                    \"IMethods.oneArg(false)\";\n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintFirstUnexpectedInvocationWhenVerifyingZeroInteractions() {\n         mock.twoArgumentMethod(1, 2);\n         mock.threeArgumentMethod(1, \"2\", \"3\");\n-        \n+\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n         } catch (VerificationError e) {\n-            String expected = \n+            String expected =\n                     \"\\n\" +\n                     \"No interactions wanted\";\n \n             assertEquals(e.getMessage(), expected);\n-            \n-            String expectedCause = \n+\n+            String expectedCause =\n                 \"\\n\" +\n                 \"Undesired invocation:\" +\n                 \"\\n\" +\n                 \"IMethods.twoArgumentMethod(1, 2)\";\n-            \n-            assertEquals(e.getCause().getMessage(), expectedCause);         \n-        }\n-    }\n-    \n+\n+            assertEquals(e.getCause().getMessage(), expectedCause);\n+        }\n+    }\n+\n     @Test\n     public void shouldPrintMethodNameWhenVerifyingAtLeastOnce() throws Exception {\n         try {\n             assertThat(e, messageContains(\"IMethods.twoArgumentMethod(1, 2)\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintMethodWhenMatcherUsed() throws Exception {\n         try {\n             fail();\n         } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n-            String expectedMessage = \n+            String expectedMessage =\n                 \"\\n\" +\n                 \"Wanted but not invoked:\" +\n                 \"\\n\" +\n                 \"IMethods.twoArgumentMethod(<any>, 100)\";\n-            assertEquals(expectedMessage, actualMessage);         \n-        }\n-    }\n-    \n+            assertEquals(expectedMessage, actualMessage);\n+        }\n+    }\n+\n     @Test\n     public void shouldPrintMethodWhenMissingInvocationWithArrayMatcher() {\n         mock.oneArray(new boolean[] { true, false, false });\n-        \n+\n         try {\n             verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));\n             fail();\n             assertThat(e, causeMessageContains(\"IMethods.oneArray([true, false, false])\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintMethodWhenMissingInvocationWithVarargMatcher() {\n         mock.varargsString(10, \"one\", \"two\");\n-        \n+\n         try {\n             verify(mock).varargsString(10, \"two\", \"one\");\n             fail();\n             assertThat(e, causeMessageContains(\"IMethods.varargsString(10, \\\"one\\\", \\\"two\\\")\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintMethodWhenMissingInvocationWithMatcher() {\n         mock.simpleMethod(\"foo\");\n-        \n+\n         try {\n             verify(mock).simpleMethod(matches(\"burrito\"));\n             fail();\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod(\\\"foo\\\")\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintNullArguments() throws Exception {\n         mock.simpleMethod(null, null);\n             assertThat(e, causeMessageContains(\"simpleMethod(null, null)\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldPrintTypesWhenMethodSupposablyTheSame() throws Exception {\n         mock.varargs((Object[]) new Object[] {});\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n /*\n- * Copyright (c) 2007 Mockito contributors \n+ * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.verification;\n public class ExactNumberOfTimesVerificationTest extends RequiresValidState {\n \n     private LinkedList mock;\n-    \n+\n     @Before\n     public void setup() {\n-        mock = Mockito.mock(LinkedList.class); \n+        mock = Mockito.mock(LinkedList.class);\n     }\n-    \n+\n     @Test\n     public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted() throws Exception {\n         mock.clear();\n             Mockito.verify(mock, times(100)).clear();\n             fail();\n         } catch (TooLittleActualInvocationsError e) {\n-            String expected = \n+            String expected =\n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n-        \t\t\"\\n\" +\n-        \t\t\"Wanted 100 times but was 3\";\n+                \"\\n\" +\n+                \"Wanted 100 times but was 3\";\n             assertEquals(expected, e.getMessage());\n-            \n+\n             assertEquals(TooLittleInvocations.class, e.getCause().getClass());\n-            \n-            String expectedCause = \n+\n+            String expectedCause =\n                 \"\\n\" +\n                 \"Too little invocations:\";\n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n-    \n+\n     @Test\n     public void shouldVerifyActualNumberOfInvocationsLargerThanWanted() throws Exception {\n         mock.clear();\n             Mockito.verify(mock, times(1)).clear();\n             fail();\n         } catch (TooManyActualInvocationsError e) {\n-            String expected = \n+            String expected =\n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n                 \"\\n\" +\n                 \"Wanted 1 time but was 4\";\n             assertEquals(expected, e.getMessage());\n-            \n+\n             assertEquals(FirstUndesiredInvocation.class, e.getCause().getClass());\n-            \n-            String expectedCause = \n+\n+            String expectedCause =\n                 \"\\n\" +\n                 \"First undesired invocation:\";\n-            \n+\n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n-    \n+\n     @Test\n     public void shouldVerifyProperlyIfMethodWasNotInvoked() throws Exception {\n         Mockito.verify(mock, times(0)).clear();\n             assertThat(e, messageContains(\"Wanted 15 times but was 0\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldVerifyProperlyIfMethodWasInvokedOnce() throws Exception {\n         mock.clear();\n-        \n+\n         Mockito.verify(mock, times(1)).clear();\n         try {\n             Mockito.verify(mock, times(15)).clear();\n             assertThat(e, messageContains(\"Wanted 15 times but was 1\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldFailWhenWantedNumberOfInvocationIsZero() throws Exception {\n         mock.clear();\n-        \n+\n         try {\n             Mockito.verify(mock, times(0)).clear();\n             fail();\n             assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n         }\n     }\n-    \n+\n     @Test\n     public void shouldVerifyWhenWantedNumberOfInvocationIsZero() throws Exception {\n         Mockito.verify(mock, times(0)).clear();\n     }\n-    \n+\n     @Test\n     public void shouldNotCountInStubbedInvocations() throws Exception {\n         Mockito.stub(mock.add(\"test\")).andReturn(false);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n-        \n+\n         mock.add(\"test\");\n         mock.add(\"test\");\n-        \n+\n         Mockito.verify(mock, times(2)).add(\"test\");\n     }\n }\n--- a/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stub;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n \n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n \n-import org.junit.*;\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerificationError;\n \n--- a/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n \n-import org.junit.*;\n-import org.mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n--- a/test/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java\n+++ b/test/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n \n-import java.util.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n import org.junit.Test;\n-import org.mockito.*;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n \n @SuppressWarnings(\"unchecked\")\n public class VerificationOnMultipleMocksUsingMatchersTest extends RequiresValidState {", "timestamp": 1197680021, "metainfo": ""}