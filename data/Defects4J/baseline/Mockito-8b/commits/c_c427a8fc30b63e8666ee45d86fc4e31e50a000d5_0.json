{"sha": "c427a8fc30b63e8666ee45d86fc4e31e50a000d5", "log": "- in order to clean up separation of serializable from non-serializable mocks -- removed DelegatingMockitoMethod (not needed. more complication without enough value) Serializable version is not very dangerous. -- removed the createMockitoMethod from IMockHandler and MockHandler  - in order to clean up separation of serializable from non-serializable mocks -- removed DelegatingMockitoMethod (not needed. more complication without enough value) Serializable version is not very dangerous. -- moved the createMockitoMethodProxy from IMockHandler to MethodInterceptorFilter -- injected MethodInterceptorFilter with MockSettings  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401656", "commit": "\n--- a/src/org/mockito/internal/IMockHandler.java\n+++ b/src/org/mockito/internal/IMockHandler.java\n package org.mockito.internal;\n \n import java.io.Serializable;\n-import java.lang.reflect.Method;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.MockitoMethod;\n \n public interface IMockHandler extends Serializable {\n \n     Object handle(Invocation invocation) throws Throwable;\n-    \n-    MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy);\n \n-    MockitoMethod createMockitoMethod(Method method);\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  */\n package org.mockito.internal;\n \n-import java.lang.reflect.Method;\n import java.util.List;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.creation.*;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.*;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n     }\n-\n-    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n-        if (mockSettings.isSerializable())\n-            return new SerializableMockitoMethodProxy(methodProxy);\n-        return new DelegatingMockitoMethodProxy(methodProxy);\n-    }\n-\n-    public MockitoMethod createMockitoMethod(Method method) {\n-        if (mockSettings.isSerializable())\n-            return new SerializableMockitoMethod(method);\n-        return new DelegatingMockitoMethod(method);\n-    }\n }\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n  */\n package org.mockito.internal.creation;\n \n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+\n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.IMockHandler;\n-import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.*;\n import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.Method;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n \n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private final IMockHandler mockHandler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n+    private final MockSettingsImpl mockSettings;\n \n-    public MethodInterceptorFilter(IMockHandler mockHandler) {\n+    public MethodInterceptorFilter(IMockHandler mockHandler, MockSettingsImpl mockSettings) {\n         this.mockHandler = mockHandler;\n+        this.mockSettings = mockSettings;\n     }\n \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n             return hashCodeForMock(proxy);\n         }\n         \n-        MockitoMethodProxy mockitoMethodProxy = mockHandler.createMockitoMethodProxy(methodProxy);\n+        MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n         \n         cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n         \n         FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n-        MockitoMethod mockitoMethod = mockHandler.createMockitoMethod(method);\n+        MockitoMethod mockitoMethod = new SerializableMockitoMethod(method);\n         Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n         return mockHandler.handle(invocation);\n     }\n     private int hashCodeForMock(Object mock) {\n         return System.identityHashCode(mock);\n     }\n+\n+    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n+        if (mockSettings.isSerializable())\n+            return new SerializableMockitoMethodProxy(methodProxy);\n+        return new DelegatingMockitoMethodProxy(methodProxy);\n+    }\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util;\n+\n+import static org.mockito.Mockito.*;\n \n import org.mockito.cglib.proxy.Callback;\n import org.mockito.cglib.proxy.Enhancer;\n         \n         MockName mockName = new MockName(settings.getMockName(), classToMock);\n         MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings);\n-        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler);\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n         Class<?>[] interfaces = settings.getExtraInterfaces();\n         Class<?>[] ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n         Object spiedInstance = settings.getSpiedInstance();\n     public <T> void resetMock(T mock) {\n         MockHandler<T> oldMockHandler = getMockHandler(mock);\n         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler);\n+        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n+                        (MockSettingsImpl) withSettings().defaultAnswer(RETURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n--- a/src/org/mockito/internal/util/ObjectMethodsGuru.java\n+++ b/src/org/mockito/internal/util/ObjectMethodsGuru.java\n package org.mockito.internal.util;\n \n+import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.io.Serializable;\n \n-import org.mockito.internal.invocation.DelegatingMockitoMethod;\n import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMockitoMethod;\n \n public class ObjectMethodsGuru implements Serializable {\n \n     private static final long serialVersionUID = -1286718569065470494L;\n \n     public boolean isToString(Method method) {\n-        return isToString(new DelegatingMockitoMethod(method));\n+        return isToString(new SerializableMockitoMethod(method));\n     }\n \n     public boolean isToString(MockitoMethod method) {\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n  */\n package org.mockito.internal;\n \n-import static org.hamcrest.core.IsInstanceOf.instanceOf;\n-import static org.mockito.Mockito.withSettings;\n-\n-import java.lang.reflect.Method;\n-\n import org.junit.Test;\n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.internal.creation.*;\n import org.mockito.internal.invocation.*;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n import org.mockito.internal.verification.VerificationModeFactory;\n         \n         assertNull(handler.mockingProgress.pullVerificationMode());\n     }\n-    \n-    @Test\n-    public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {\n-        MockSettingsImpl mockSettings = (MockSettingsImpl) withSettings().serializable();\n-        MockHandler handler = new MockHandler(null, null, null, mockSettings);\n-        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n-        \n-        // when\n-        MockitoMethodProxy mockitoMethodProxy = handler.createMockitoMethodProxy(methodProxy);\n-        \n-        // then\n-        assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));\n-    }\n-    \n-    @Test\n-    public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {\n-        MockHandler handler = new MockHandler(null, null, null, (MockSettingsImpl) withSettings());\n-        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n-        \n-        // when\n-        MockitoMethodProxy mockitoMethodProxy = handler.createMockitoMethodProxy(methodProxy);\n-        \n-        // then\n-        assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));\n-    }\n-    \n-    @Test\n-    public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {\n-        // given\n-        MockSettingsImpl mockSettings = (MockSettingsImpl) withSettings().serializable();\n-        MockHandler handler = new MockHandler(null, null, null, mockSettings);\n-        Method method = getClass().getMethod(\"toString\", new Class<?>[0]);\n-        \n-        // when\n-        MockitoMethod mockitoMethod = handler.createMockitoMethod(method);\n-        \n-        // then\n-        assertThat(mockitoMethod, instanceOf(SerializableMockitoMethod.class));\n-    }\n-    \n-    @Test\n-    public void shouldCreateNONSerializableMethodIfIsNotSerializableMock() throws Exception {\n-        // given\n-        MockSettingsImpl mockSettings = (MockSettingsImpl) withSettings();\n-        MockHandler handler = new MockHandler(null, null, null, mockSettings);\n-        Method method = getClass().getMethod(\"toString\", new Class<?>[0]);\n-        \n-        // when\n-        MockitoMethod mockitoMethod = handler.createMockitoMethod(method);\n-        \n-        // then\n-        assertThat(mockitoMethod, instanceOf(DelegatingMockitoMethod.class));\n-    }\n }\n--- a/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n package org.mockito.internal.creation;\n+\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n \n import org.junit.Before;\n import org.junit.Test;\n-import static org.mockito.Matchers.any;\n import org.mockito.Mockito;\n-import static org.mockito.Mockito.never;\n+import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.IMockHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n import org.mockito.internal.invocation.Invocation;\n import org.mockitousage.MethodsImpl;\n import org.mockitoutil.TestBase;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n-\n public class MethodInterceptorFilterTest extends TestBase {\n \n     IMockHandler mockHanlder = Mockito.mock(IMockHandler.class);\n-    MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHanlder);\n+    MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHanlder, (MockSettingsImpl) withSettings());\n \n     @Before\n     public void setUp() {\n \n     @Test\n     public void shouldBeSerializable() throws Exception {\n-        new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null));\n+        new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null, null));\n     }\n \n     @Test\n         assertTrue((Boolean) ret);\n         Mockito.verify(mockHanlder, never()).handle(any(Invocation.class));\n     }\n+    \n+    @Test\n+    public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHanlder, (MockSettingsImpl) withSettings().serializable());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHanlder, (MockSettingsImpl) withSettings());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));\n+    }\n }\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n             }\n         }\n         \n-        Invocation i = new Invocation(mock, new DelegatingMockitoMethod(method), args, sequenceNumber, null);\n+        Invocation i = new Invocation(mock, new SerializableMockitoMethod(method), args, sequenceNumber, null);\n         if (verified) {\n             i.markVerified();\n         }\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n-        return new Invocation(new Object(), new DelegatingMockitoMethod(type.getMethod(methodName,\n+        return new Invocation(new Object(), new SerializableMockitoMethod(type.getMethod(methodName,\n                 new Class[0])), args, 1, null);\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n-        return new Invocation(new Object(), new DelegatingMockitoMethod(type.getMethod(methodName,\n+        return new Invocation(new Object(), new SerializableMockitoMethod(type.getMethod(methodName,\n                 new Class[0])), new Object[0], 1, realMethod);\n     }\n ", "timestamp": 1257432230, "metainfo": ""}