{"sha": "ffdd1411d5deb263f9bea2a8dcadc7881eb2211c", "log": "massive checkin (worked offline), refactorings around the way verification is done  --HG-- rename : src/org/mockito/internal/verification/MissingInvocationVerifier.java => src/org/mockito/internal/verification/MissingInvocationChecker.java rename : src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java => src/org/mockito/internal/verification/MissingInvocationInOrderChecker.java rename : src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java => src/org/mockito/internal/verification/NumberOfInvocationsChecker.java rename : src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java => src/org/mockito/internal/verification/NumberOfInvocationsInOrderChecker.java rename : test/org/mockito/internal/verification/MissingInvocationVerifierTest.java => test/org/mockito/internal/verification/MissingInvocationCheckerTest.java rename : test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java => test/org/mockito/internal/verification/MissingInvocationInOrderCheckerTest.java rename : test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java => test/org/mockito/internal/verification/NumberOfInvocationsCheckerTest.java rename : test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java => test/org/mockito/internal/verification/NumberOfInvocationsInOrderCheckerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40945", "commit": "\n--- a/src/org/mockito/InOrderVerifier.java\n+++ b/src/org/mockito/InOrderVerifier.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.verification.MockitoInOrderVerificationMode;\n-import org.mockito.internal.verification.MockitoVerificationMode;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.verification.InOrderVerificationModeWrapper;\n import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.verification.VerificationInOrderMode;\n import org.mockito.verification.VerificationMode;\n \n /**\n     public <T> T verify(T mock, VerificationMode mode) {\n         if (!mocksToBeVerifiedInOrder.contains(mock)) {\n             reporter.inOrderRequiresFamiliarMock();\n+        } else if (!(mode instanceof VerificationInOrderMode)) {\n+            throw new MockitoException(\"VerificationMode is not implmented to work with InOrder\");\n         }\n-        if (mode instanceof MockitoVerificationMode) {\n-            return Mockito.verify(mock, new MockitoInOrderVerificationMode((MockitoVerificationMode) mode, mocksToBeVerifiedInOrder));\n-        }\n-        throw new RuntimeException(\"nothing else is yet implemented\");\n-//        if (!(mode instanceof InOrderVerificationMode) {\n-//            //TODO fail nicely here\n-//        }\n-//        return Mockito.verify(mock, mode);\n+        return Mockito.verify(mock, new InOrderVerificationModeWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));\n     }\n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n+    static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n     private static final Reporter REPORTER = new Reporter();\n-    static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n \n     /**\n      * Creates mock object of given class or interface.\n     public static VerificationMode atLeast(int minNumberOfInvocations) {\n         return VerificationModeFactory.atLeast(minNumberOfInvocations);\n     }\n+    \n+    /**\n+     * Allows at-most-x verification. E.g:\n+     * <pre>\n+     *   verify(mock, atMost(3)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param minNumberOfInvocations minimum number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode atMost(int maxNumberOfInvocations) {\n+        return VerificationModeFactory.atMost(maxNumberOfInvocations);\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n \n public class InvocationsFinder {\n \n-    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n         return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/verification/AtMostXVerificationMode.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.verification.VerificationData;\n+import org.mockito.verification.VerificationMode;\n+\n+public class AtMostXVerificationMode implements VerificationMode {\n+\n+    private final int maxNumberOfInvocations;\n+\n+    public AtMostXVerificationMode(int maxNumberOfInvocations) {\n+        if (maxNumberOfInvocations < 0) {\n+            throw new MockitoException(\"maxNumberOfInvocations cannot be negative\");\n+        }\n+        this.maxNumberOfInvocations = maxNumberOfInvocations;\n+    }\n+\n+    @Override\n+    public void verify(VerificationData data) {\n+        List<Invocation> invocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        InvocationsFinder finder = new InvocationsFinder();\n+        List<Invocation> found = finder.findInvocations(invocations, wanted);\n+        int foundSize = found.size();\n+        if (foundSize > maxNumberOfInvocations) {\n+            throw new MockitoAssertionError(\"Wanted at most \" + maxNumberOfInvocations + \" but found: \" + foundSize);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/InOrderVerificationModeWrapper.java\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.AllInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.verification.VerificationData;\n+import org.mockito.verification.VerificationInOrderMode;\n+import org.mockito.verification.VerificationMode;\n+\n+public class InOrderVerificationModeWrapper implements VerificationMode {\n+\n+    private final VerificationInOrderMode mode;\n+    private final List<Object> mocksToBeVerifiedInOrder;\n+\n+    public InOrderVerificationModeWrapper(VerificationInOrderMode mode, List<Object> mocksToBeVerifiedInOrder) {\n+        this.mode = mode;\n+        this.mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder;\n+    }\n+\n+    @Override\n+    public void verify(VerificationData data) {\n+        List<Invocation> allInvocations = new AllInvocationsFinder().getAllInvocations(mocksToBeVerifiedInOrder);\n+        mode.verifyInOrder(new VerificationDataImpl(allInvocations, data.getWanted()));\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/MissingInvocationChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.verification.VerificationMode;\n+\n+public class MissingInvocationChecker {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+    \n+    public MissingInvocationChecker() {\n+        this(new InvocationsFinder(), new Reporter());\n+    }\n+    \n+    public MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+        \n+        if (actualInvocations.isEmpty()) {\n+            Invocation similar = finder.findSimilarInvocation(invocations, wanted, mode);\n+            reportMissingInvocationError(wanted, similar);\n+        }\n+    }\n+\n+    private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n+        if (similar != null) {\n+            SyncingPrinter syncingPrinter = new SyncingPrinter(wanted, similar);\n+            reporter.argumentsAreDifferent(syncingPrinter.getWanted(), syncingPrinter.getActual(), similar.getStackTrace());\n+        } else {\n+            reporter.wantedButNotInvoked(wanted);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/MissingInvocationInOrderChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.verification.VerificationMode;\n+\n+public class MissingInvocationInOrderChecker {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+    \n+    public MissingInvocationInOrderChecker() {\n+        this(new InvocationsFinder(), new Reporter());\n+    }\n+    \n+    public MissingInvocationInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n+        \n+        if (!chunk.isEmpty()) {\n+            return;\n+        }\n+        \n+        Invocation previousInOrder = finder.findPreviousVerifiedInOrder(invocations);\n+        if (previousInOrder == null) {\n+            reporter.wantedButNotInvoked(wanted);\n+        } else {\n+            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getStackTrace());\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MockitoVerificationMode.java\n+++ b/src/org/mockito/internal/verification/MockitoVerificationMode.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.verification.VerificationData;\n+import org.mockito.verification.VerificationInOrderMode;\n import org.mockito.verification.VerificationMode;\n \n /**\n  * <p> \n  * Implements marking interface which hides details from Mockito users. \n  */\n-public class MockitoVerificationMode implements VerificationMode {\n+public class MockitoVerificationMode implements VerificationInOrderMode, VerificationMode {\n     \n     public enum Verification { EXPLICIT, NO_MORE_WANTED, AT_LEAST };\n     \n+    private List<Object> mocksToBeVerifiedInOrder;\n+\n     final int wantedInvocationCount;\n     final Verification verification;\n     \n         this.verification = verification;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted) {\n-        MissingInvocationVerifier missingInvocation = new MissingInvocationVerifier();\n-        NumberOfInvocationsVerifier numberOfInvocations = new NumberOfInvocationsVerifier();\n+    public void verify(VerificationData data) {\n+        if (mocksToBeVerifiedInOrder != null) {\n+            verifyInOrder(data);\n+            return;\n+        }\n+        \n+        MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n+        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();\n         \n         //TODO duplicated\n         if (wantedInvocationCount > 0 || (verification == Verification.AT_LEAST && wantedInvocationCount == 1)) {\n-            missingInvocation.verify(invocations, wanted, this);\n+            missingInvocation.verify(data.getAllInvocations(), data.getWanted(), this);\n         }\n-        numberOfInvocations.verify(invocations, wanted, this);\n+        numberOfInvocations.verify(data.getAllInvocations(), data.getWanted(), this);\n     }\n+    \n+    public void verifyInOrder(VerificationData data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();\n+        \n+        if (wantedCount() > 0 || (verification == Verification.AT_LEAST && wantedCount() == 1)) {\n+            missingInvocation.verify(allInvocations, wanted, this);\n+        }\n+        \n+        numberOfCalls.verify(allInvocations, wanted, this);\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: \" + wantedCount() + \", Mocks to verify in order: \" + mocksToBeVerifiedInOrder;\n+    }    \n \n     public int wantedCount() {\n         return wantedInvocationCount;\n         return verification;\n     }\n     \n-    @Override\n-    public String toString() {\n-        return \"Wanted invocations count: \" + wantedInvocationCount;\n+    public void setMocksToVerifiedInOrder(List<Object> mocksToBeVerifiedInOrder) {\n+        this.mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder;\n     }\n }\n--- a/src/org/mockito/internal/verification/NoMoreInteractionsMode.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractionsMode.java\n  */\n package org.mockito.internal.verification;\n \n-import java.util.List;\n-\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.verification.VerificationData;\n import org.mockito.verification.VerificationMode;\n \n public class NoMoreInteractionsMode implements VerificationMode {\n \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted) {\n-        Invocation unverified = new InvocationsFinder().findFirstUnverified(invocations);\n+    public void verify(VerificationData data) {\n+        Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n         \n         if (unverified != null) {\n             new Reporter().noMoreInteractionsWanted(unverified, unverified.getStackTrace());\n         }\n     }\n-\n-    public void setMocksToBeVerifiedInOrder(List<Object> mocks) {\n-        //do nothing\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+\n+public class NumberOfInvocationsChecker {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+\n+    public NumberOfInvocationsChecker() {\n+        this(new Reporter(), new InvocationsFinder());\n+    }\n+    \n+    NumberOfInvocationsChecker(Reporter reporter, InvocationsFinder finder) {\n+        this.reporter = reporter;\n+        this.finder = finder;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+        VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+        \n+        int actualCount = actualInvocations.size();\n+        if (decoder.tooLittleActualInvocations(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n+            reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (decoder.tooLittleActualInvocationsInAtLeastMode(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n+            reporter.tooLittleActualInvocationsInAtLeastMode(mode.wantedCount(), actualCount, wanted, lastInvocation);        \n+        } else if (decoder.neverWantedButInvoked(actualCount)) {\n+            HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n+            reporter.neverWantedButInvoked(wanted, firstUndesired); \n+        } else if (decoder.tooManyActualInvocations(actualCount)) {\n+            HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n+            reporter.tooManyActualInvocations(mode.wantedCount(), actualCount, wanted, firstUndesired);\n+        }\n+        \n+        for (Invocation i : actualInvocations) {\n+            i.markVerified();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+\n+public class NumberOfInvocationsInOrderChecker {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+    \n+    public NumberOfInvocationsInOrderChecker() {\n+        this(new InvocationsFinder(), new Reporter());\n+    }\n+    \n+    public NumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+        VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode);\n+        \n+        boolean noMatchFound = chunk.size() == 0;\n+        if (decoder.neverWanted() && noMatchFound) {\n+            return;\n+        }\n+        \n+        int actualCount = chunk.size();\n+        \n+        if (decoder.tooLittleActualInvocations(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n+            reporter.tooLittleActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (decoder.tooLittleActualInvocationsInAtLeastMode(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n+            reporter.tooLittleActualInvocationsInOrderInAtLeastMode(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (decoder.tooManyActualInvocations(actualCount)) {\n+            HasStackTrace firstUndesired = chunk.get(mode.wantedCount()).getStackTrace();\n+            reporter.tooManyActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted, firstUndesired);\n+        }\n+        \n+        for (Invocation i : chunk) {\n+            i.markVerifiedInOrder();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.verification.VerificationData;\n+\n+public class VerificationDataImpl implements VerificationData {\n+\n+    private final List<Invocation> allInvocations;\n+    private final InvocationMatcher wanted;\n+\n+    public VerificationDataImpl(List<Invocation> allInvocations, InvocationMatcher wanted) {\n+        this.allInvocations = allInvocations;\n+        this.wanted = wanted;\n+    }\n+\n+    @Override\n+    public List<Invocation> getAllInvocations() {\n+        return allInvocations;\n+    }\n+\n+    @Override\n+    public InvocationMatcher getWanted() {\n+        return wanted;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.verification.MockitoVerificationMode.Verification;\n+import org.mockito.verification.VerificationMode;\n \n /**\n  * Holds additional information regarding verification.\n     public static NoMoreInteractionsMode noMoreInteractions() {\n         return new NoMoreInteractionsMode();\n     }\n+\n+    public static VerificationMode atMost(int maxNumberOfInvocations) {\n+        return new AtMostXVerificationMode(maxNumberOfInvocations);\n+    }\n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n     }\n \n     public void verify(InvocationMatcher wanted, VerificationMode mode) {\n-        mode.verify(getRegisteredInvocations(), wanted);\n+        mode.verify(new VerificationDataImpl(getRegisteredInvocations(), wanted));\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/verification/VerificationData.java\n+package org.mockito.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+public interface VerificationData {\n+\n+    List<Invocation> getAllInvocations();\n+\n+    InvocationMatcher getWanted();   \n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/verification/VerificationInOrderMode.java\n+package org.mockito.verification;\n+\n+public interface VerificationInOrderMode {\n+\n+    void verifyInOrder(VerificationData data);\n+    \n+}\n--- a/src/org/mockito/verification/VerificationMode.java\n+++ b/src/org/mockito/verification/VerificationMode.java\n  */\n package org.mockito.verification;\n \n-import java.util.List;\n-\n import org.mockito.Mockito;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n \n /**\n  * Allows verifying that certain behavior happened at least once / exact number\n  */\n public interface VerificationMode {\n     \n-    void verify(List<Invocation> invocations, InvocationMatcher wanted);\n+    void verify(VerificationData data);\n     \n }\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.progress.MockitoVerificationModeTest;\n import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n-import org.mockito.internal.verification.MissingInvocationInOrderVerifierTest;\n-import org.mockito.internal.verification.MissingInvocationVerifierTest;\n+import org.mockito.internal.verification.MissingInvocationCheckerTest;\n+import org.mockito.internal.verification.MissingInvocationInOrderCheckerTest;\n import org.mockito.internal.verification.NoMoreInvocationsVerifierTest;\n-import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifierTest;\n-import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n+import org.mockito.internal.verification.NumberOfInvocationsCheckerTest;\n+import org.mockito.internal.verification.NumberOfInvocationsInOrderCheckerTest;\n import org.mockito.internal.verification.VerifyingRecorderTest;\n import org.mockitousage.ReplacingObjectMethodsTest;\n import org.mockitousage.UsingVarargsTest;\n                     MockHandlerTest.class,\n                     AllInvocationsFinderTest.class,\n                     DefaultReturnValuesTest.class,\n-                    NumberOfInvocationsVerifierTest.class,\n+                    NumberOfInvocationsCheckerTest.class,\n                     VerifyingRecorderTest.class,\n-                    MissingInvocationVerifierTest.class,\n+                    MissingInvocationCheckerTest.class,\n                     NoMoreInvocationsVerifierTest.class,\n-                    NumberOfInvocationsInOrderVerifierTest.class,\n-                    MissingInvocationInOrderVerifierTest.class,\n+                    NumberOfInvocationsInOrderCheckerTest.class,\n+                    MissingInvocationInOrderCheckerTest.class,\n                     ClassImposterizerTest.class,\n                     CglibTest.class,\n                     InvocationMatcherTest.class,\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n \n     @Test\n     public void shouldFindActualInvocations() throws Exception {\n-        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeFactory.atLeastOnce());\n+        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));\n         assertThat(actual, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n-        actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation), VerificationModeFactory.atLeastOnce());\n+        actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));\n         assertThat(actual, hasExactlyInOrder(differentMethodInvocation));\n     }\n     \n--- a/test/org/mockito/internal/verification/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/InvocationsFinderStub.java\n         return validMatchingChunkToReturn;\n     }\n \n-    @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n-            VerificationMode mode) {\n+    @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n         this.invocations = invocations;\n         return actualToReturn;\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/MissingInvocationCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.verification.VerificationMode;\n+import org.mockitoutil.TestBase;\n+\n+public class MissingInvocationCheckerTest extends TestBase {\n+\n+    private MissingInvocationChecker verifier;\n+    \n+    private InvocationsFinderStub finderStub;\n+    private ReporterStub reporterStub;\n+    \n+    private InvocationMatcher wanted;\n+    private List<Invocation> invocations;\n+\n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new MissingInvocationChecker(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = asList(new InvocationBuilder().toInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldAskFinderForActualInvocations() {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        VerificationMode mode = VerificationModeFactory.atLeastOnce();\n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(invocations, finderStub.invocations);\n+    }\n+    \n+    @Test\n+    public void shouldPassBecauseActualInvocationFound() {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n+    }\n+    \n+    @Test\n+    public void shouldAskAnalyzerForSimilarInvocation() {\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n+        \n+        assertSame(invocations, finderStub.invocations);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() {\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        finderStub.similarToReturn = null;\n+        \n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+        assertNull(reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedInvocationDiffersFromActual() {\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        Invocation actualInvocation = new InvocationBuilder().toInvocation();\n+        finderStub.similarToReturn = actualInvocation;\n+        \n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n+        \n+        assertNotNull(reporterStub.wanted);\n+        assertNotNull(reporterStub.actual);\n+        \n+        assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private PrintableInvocation wanted;\n+        private PrintableInvocation actual;\n+        private HasStackTrace actualInvocationStackTrace;\n+        @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n+            this.wanted = wanted;\n+        }\n+        \n+        @Override public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, HasStackTrace actualInvocationStackTrace) {\n+                    this.wanted = wanted;\n+                    this.actual = actual;\n+                    this.actualInvocationStackTrace = actualInvocationStackTrace;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/MissingInvocationInOrderCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+import org.mockitoutil.TestBase;\n+\n+public class MissingInvocationInOrderCheckerTest extends TestBase {\n+\n+    private MissingInvocationInOrderChecker verifier;\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new MissingInvocationInOrderChecker(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }                                                                    \n+\n+    @Test\n+    public void shouldPassWhenMatchingInteractionFound() throws Exception {\n+        Invocation actual = new InvocationBuilder().toInvocation();\n+        finderStub.allMatchingUnverifiedChunksToReturn.add(actual);\n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() throws Exception {\n+        assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedDiffersFromActual() throws Exception {\n+        Invocation previous = new InvocationBuilder().toInvocation();\n+        finderStub.previousInOrderToReturn = previous;\n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+        assertEquals(previous, reporterStub.previous);\n+        assertSame(previous.getStackTrace(), reporterStub.previousStackTrace);\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private PrintableInvocation wanted;\n+        private PrintableInvocation previous;\n+        private HasStackTrace previousStackTrace;\n+        \n+        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, HasStackTrace previousStackTrace) {\n+            this.wanted = wanted;\n+            this.previous = previous;\n+            this.previousStackTrace = previousStackTrace;\n+        }\n+        \n+        @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n+            this.wanted = wanted;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockitoutil.TestBase;\n+\n+public class NumberOfInvocationsCheckerTest extends TestBase {\n+\n+    private NumberOfInvocationsChecker verifier;\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new NumberOfInvocationsChecker(reporterStub, finderStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }\n+\n+    @Test\n+    public void shouldReportTooLittleActual() throws Exception {\n+        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertEquals(1, reporterStub.actualCount);\n+        assertEquals(100, reporterStub.wantedCount);\n+        assertEquals(wanted, reporterStub.wanted);\n+    }\n+\n+    @Test\n+    public void shouldReportWithLastInvocationStackTrace() throws Exception {\n+        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        \n+        finderStub.actualToReturn.addAll(asList(first, second));\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(second.getStackTrace(), reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {\n+        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n+        \n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertNull(reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n+        MockitoVerificationMode mode = VerificationModeFactory.times(2);\n+\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        Invocation third = new InvocationBuilder().toInvocation();\n+        \n+        finderStub.actualToReturn.addAll(asList(first, second, third));\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(third.getStackTrace(), reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyActual() throws Exception {\n+        MockitoVerificationMode mode = VerificationModeFactory.times(1);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertEquals(2, reporterStub.actualCount);\n+        assertEquals(1, reporterStub.wantedCount);\n+        assertEquals(wanted, reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportNeverWantedButInvoked() throws Exception {\n+        MockitoVerificationMode mode = VerificationModeFactory.times(0);\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        finderStub.actualToReturn.add(invocation);\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+        assertEquals(invocation.getStackTrace(), reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldMarkInvocationsAsVerified() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        finderStub.actualToReturn.add(invocation);\n+        assertFalse(invocation.isVerified());\n+        \n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n+        \n+        assertTrue(invocation.isVerified());\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private int wantedCount;\n+        private int actualCount;\n+        private PrintableInvocation wanted;\n+        private HasStackTrace stackTrace;\n+        @Override public void tooLittleActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace lastActualInvocationStackTrace) {\n+                    this.wantedCount = wantedCount;\n+                    this.actualCount = actualCount;\n+                    this.wanted = wanted;\n+                    this.stackTrace = lastActualInvocationStackTrace;\n+        }\n+        \n+        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+                    this.wantedCount = wantedCount;\n+                    this.actualCount = actualCount;\n+                    this.wanted = wanted;\n+                    this.stackTrace = firstUndesired;\n+        }\n+        \n+        @Override\n+        public void neverWantedButInvoked(PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+            this.wanted = wanted;\n+            this.stackTrace = firstUndesired;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsInOrderCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+import org.mockitoutil.TestBase;\n+\n+public class NumberOfInvocationsInOrderCheckerTest extends TestBase {\n+\n+    private NumberOfInvocationsInOrderChecker verifier;\n+    private Reporter reporter;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporter = new Reporter();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new NumberOfInvocationsInOrderChecker(finderStub, reporter);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }\n+    \n+    @Test\n+    public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {\n+        assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).inOrder());\n+    }\n+    \n+    @Test\n+    public void shouldPassIfChunkMatches() throws Exception {\n+        finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());\n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+    }\n+    \n+    @Test\n+    public void shouldReportTooLittleInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n+        \n+        try {\n+            verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).inOrder());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e, messageContains(\"Wanted 4 times but was 2\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n+        \n+        try {\n+            verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifiedInOrder() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        assertFalse(invocation.isVerifiedInOrder());\n+        finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+        \n+        assertTrue(invocation.isVerifiedInOrder());\n+    }\n+}\n--- a/test/org/mockitousage/verification/AtLeastXVerificationTest.java\n+++ b/test/org/mockitousage/verification/AtLeastXVerificationTest.java\n \n import java.util.List;\n \n-import org.junit.Before;\n import org.junit.Test;\n import org.mockito.InOrder;\n-import org.mockito.Mockito;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n public class AtLeastXVerificationTest extends TestBase {\n \n-    private List mock;\n-    private List mockTwo;\n+    @Mock private List mock;\n     \n-    @Before public void setup() {\n-        mock = Mockito.mock(List.class);\n-        mockTwo = Mockito.mock(List.class);\n-    }\n-\n     @Test\n-    public void shouldVerifyAtLeastOnce() throws Exception {\n+    public void shouldVerifyAtMostXTimes() throws Exception {\n         mock.clear();\n         mock.clear();\n         \n-        mockTwo.add(\"add\");\n-\n-        verify(mock, atLeastOnce()).clear();\n-        verify(mockTwo, atLeastOnce()).add(\"add\");\n+        verify(mock, atMost(2)).clear();\n+        verify(mock, atMost(3)).clear();\n+        \n         try {\n-            verify(mockTwo, atLeastOnce()).add(\"foo\");\n+            verify(mock, atMost(1)).clear();\n             fail();\n-        } catch (WantedButNotInvoked e) {}\n-    }\n-    \n-    @Test(expected=WantedButNotInvoked.class)\n-    public void shouldFailIfMethodWasNotCalledAtAll() throws Exception {\n-        verify(mock, atLeastOnce()).add(\"foo\");\n+        } catch (MockitoAssertionError e) {}\n     }\n     \n     @Test\n-    public void shouldVerifyAtLeastXTimes() throws Exception {\n-        mock.add(\"foo\");\n-        mock.add(\"foo\");\n-        mock.add(\"foo\");\n+    public void shouldWorkWithArgumentMatchers() throws Exception {\n+        mock.add(\"one\");\n+        verify(mock, atMost(5)).add(anyString());\n         \n-        verify(mock, atLeast(1)).add(\"foo\");\n-        verify(mock, atLeast(2)).add(\"foo\");\n-        verify(mock, atLeast(3)).add(\"foo\");\n-    }\n-    \n-    @Test(expected=TooLittleActualInvocations.class)\n-    public void shouldFailOnVerifyAtLeast10WhenMethodWasInvokedOnce() throws Exception {\n-        mock.add(\"foo\");\n-\n-        verify(mock, atLeast(2)).add(\"foo\");\n+        try {\n+            verify(mock, atMost(0)).add(anyString());\n+            fail();\n+        } catch (MockitoAssertionError e) {}\n     }\n     \n     @Test\n-    public void shouldVerifyInOrder() throws Exception {\n-        mock.add(\"one\");\n-        mock.add(\"two\");\n-        mock.add(\"three\");\n-        \n-        mock.clear();\n-  \n-        InOrder inOrder = inOrder(mock);\n-        \n-        inOrder.verify(mock, atLeast(2)).add(anyString());\n-        inOrder.verify(mock).clear();\n-        verifyNoMoreInteractions(mock);\n+    public void shouldNotAllowNegativeNumber() throws Exception {\n+        try {\n+            verify(mock, atMost(-1)).clear();\n+            fail();\n+        } catch (MockitoException e) {\n+            //TODO assert message\n+        }\n     }\n     \n     @Test\n-    public void shouldFailVerificationInOrder() throws Exception {\n+    public void shouldPrintDecentMessage() throws Exception {\n         mock.clear();\n-\n-        mock.add(\"one\");\n-        mock.add(\"two\");\n-        mock.add(\"three\");\n-  \n+        mock.clear();\n+        \n+        try {\n+            verify(mock, atMost(1)).clear();\n+            fail();\n+        } catch (MockitoAssertionError e) {\n+            //TODO assert message\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowInOrderMode() throws Exception {\n+        mock.clear();\n         InOrder inOrder = inOrder(mock);\n         \n-        inOrder.verify(mock, atLeastOnce()).clear();\n-\n         try {\n-            inOrder.verify(mock, atLeast(4)).add(anyString());\n+            inOrder.verify(mock, atMost(1)).clear();\n             fail();\n-        } catch (VerifcationInOrderFailure e) {}\n+        } catch (MockitoException e) {\n+            //TODO assert message\n+        }\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/verification/AtMostXVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AtMostXVerificationTest extends TestBase {\n+\n+    private List mock;\n+    private List mockTwo;\n+    \n+    @Before public void setup() {\n+        mock = Mockito.mock(List.class);\n+        mockTwo = Mockito.mock(List.class);\n+    }\n+\n+    @Test\n+    public void shouldVerifyAtLeastOnce() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        \n+        mockTwo.add(\"add\");\n+\n+        verify(mock, atLeastOnce()).clear();\n+        verify(mockTwo, atLeastOnce()).add(\"add\");\n+        try {\n+            verify(mockTwo, atLeastOnce()).add(\"foo\");\n+            fail();\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+    \n+    @Test(expected=WantedButNotInvoked.class)\n+    public void shouldFailIfMethodWasNotCalledAtAll() throws Exception {\n+        verify(mock, atLeastOnce()).add(\"foo\");\n+    }\n+    \n+    @Test\n+    public void shouldVerifyAtLeastXTimes() throws Exception {\n+        mock.add(\"foo\");\n+        mock.add(\"foo\");\n+        mock.add(\"foo\");\n+        \n+        verify(mock, atLeast(1)).add(\"foo\");\n+        verify(mock, atLeast(2)).add(\"foo\");\n+        verify(mock, atLeast(3)).add(\"foo\");\n+    }\n+    \n+    @Test(expected=TooLittleActualInvocations.class)\n+    public void shouldFailOnVerifyAtLeast10WhenMethodWasInvokedOnce() throws Exception {\n+        mock.add(\"foo\");\n+\n+        verify(mock, atLeast(2)).add(\"foo\");\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrder() throws Exception {\n+        mock.add(\"one\");\n+        mock.add(\"two\");\n+        mock.add(\"three\");\n+        \n+        mock.clear();\n+  \n+        InOrder inOrder = inOrder(mock);\n+        \n+        inOrder.verify(mock, atLeast(2)).add(anyString());\n+        inOrder.verify(mock).clear();\n+        verifyNoMoreInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldFailVerificationInOrder() throws Exception {\n+        mock.clear();\n+\n+        mock.add(\"one\");\n+        mock.add(\"two\");\n+        mock.add(\"three\");\n+  \n+        InOrder inOrder = inOrder(mock);\n+        \n+        inOrder.verify(mock, atLeastOnce()).clear();\n+\n+        try {\n+            inOrder.verify(mock, atLeast(4)).add(anyString());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {}\n+    }\n+}", "timestamp": 1223805250, "metainfo": ""}