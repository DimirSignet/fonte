{"sha": "bc4a76c83eee655989238025d70de91b71376ebd", "log": "added some tests, added some documentation added filling in stack trace when stubbed throwable is thrown  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40114", "commit": "\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         if (throwableToBeSetOnVoidMethod != null) {\n-            Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n-            ExpectedInvocation invocationWithMatchers = expectedInvocation(invocation);\n+            ExpectedInvocation invocationWithMatchers = expectedInvocation(proxy, method, args);\n             //TODO this is a bit dodgy, we should set result directly on behavior and behavior should validate exception\n             behavior.addInvocation(invocationWithMatchers);\n             andThrows(throwableToBeSetOnVoidMethod);\n         VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n         mockitoState.validateState();\n         \n-        Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n-        ExpectedInvocation invocationWithMatchers = expectedInvocation(invocation);\n+        ExpectedInvocation invocationWithMatchers = expectedInvocation(proxy, method, args);\n         \n         if (verifyingMode != null) {\n             behavior.verify(invocationWithMatchers, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n         } \n         \n+        behavior.addInvocation(invocationWithMatchers);\n+\n         mockitoState.reportControlForStubbing(this);\n-\n-        behavior.addInvocation(invocationWithMatchers);\n         \n-        if (throwableToBeSetOnVoidMethod != null) {\n-            andThrows(throwableToBeSetOnVoidMethod);\n-            throwableToBeSetOnVoidMethod = null;\n-            return null;\n-        }\n-        \n-        return behavior.resultFor(invocation);\n+        return behavior.resultFor(invocationWithMatchers.getInvocation());\n     }\n \n-    private ExpectedInvocation expectedInvocation(Invocation invocation) {\n+    private ExpectedInvocation expectedInvocation(Object proxy, Method method, Object[] args) {\n+        Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n+        \n         List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n--- a/src/org/mockito/internal/Result.java\n+++ b/src/org/mockito/internal/Result.java\n     public static Result createThrowResult(final Throwable throwable) {\n         return new Result(new IAnswer<Object>() {\n             public Object answer() throws Throwable {\n-                throw throwable;\n+                throw throwable.fillInStackTrace();\n             }\n         });\n     }\n--- a/test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java\n \n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.firstMethodOnStackEqualsTo;\n \n import java.io.*;\n-import java.util.LinkedList;\n+import java.util.*;\n \n import org.junit.*;\n import org.mockito.exceptions.MockitoException;\n \n-@SuppressWarnings(\"unchecked\")\n+@SuppressWarnings({\"serial\", \"unchecked\"})\n public class StubbingWithThrowablesTest {\n \n     private LinkedList mock;\n+    private Map mockTwo;\n \n     @Before \n     public void setup() {\n         mock = mock(LinkedList.class);\n+        mockTwo = mock(HashMap.class);\n     }\n     \n     @Test\n         } catch (Exception e) {\n             assertEquals(expected, e);\n         }\n+    } \n+    \n+    @Test\n+    public void shouldLastStubbingVoidBeImportant() throws Exception {\n+        stubVoid(mock).toThrow(new ExceptionOne()).on().clear();\n+        stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();\n+        \n+        try {\n+            mock.clear();\n+            fail();\n+        } catch (ExceptionTwo e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {\n+        stub(mock.get(1)).andThrows(new ExceptionOne());\n+        \n+        try {\n+            stub(mock.get(1)).andThrows(new ExceptionTwo());\n+            fail();\n+        } catch (ExceptionOne e) {}\n     }   \n     \n     @Test\n         stub(mock.add(\"monkey island\")).andThrows(null);\n     }    \n     \n+    @Test\n+    public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n+        stub(mock.add(\"ExceptionOne\")).andThrows(new ExceptionOne());\n+        stub(mock.getLast()).andReturn(\"last\");\n+        stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();\n+        \n+        stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();\n+        stub(mockTwo.containsValue(\"ExceptionFour\")).andThrows(new ExceptionFour());\n+        stub(mockTwo.get(\"Are you there?\")).andReturn(\"Yes!\");\n+\n+        assertNull(mockTwo.get(\"foo\"));\n+        assertTrue(mockTwo.keySet().isEmpty());\n+        assertEquals(\"Yes!\", mockTwo.get(\"Are you there?\"));\n+        try {\n+            mockTwo.clear();\n+        } catch (ExceptionThree e) {}\n+        try {\n+            mockTwo.containsKey(\"ExceptionFour\");\n+        } catch (ExceptionFour e) {}\n+        \n+        assertNull(mock.getFirst());\n+        assertEquals(\"last\", mock.getLast());\n+        try {\n+            mock.add(\"ExceptionOne\");\n+        } catch (ExceptionOne e) {}\n+        try {\n+            mock.clear();\n+        } catch (ExceptionTwo e) {}\n+    }\n+    \n     @Ignore\n     @Test\n-    public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n-        \n+    public void shouldDoTheStackTraceProperly() throws Exception {\n+        stub(mock.add(\"ExceptionOne\")).andThrows(new ExceptionOne());\n+\n+        try {\n+            addObjectToMockedList(\"ExceptionOne\");\n+            fail();\n+        } catch (ExceptionOne e) {\n+            assertThat(e, firstMethodOnStackEqualsTo(\"addObjectToMockedList\"));\n+        }\n     }\n     \n+    private void addObjectToMockedList(String string) {\n+        mock.add(\"ExceptionOne\");\n+    }\n+\n     @Ignore\n     @Test\n     public void shouldVerifyWhenStubbedWithThrowable() throws Exception {\n         \n     }\n+    \n+    private class ExceptionOne extends RuntimeException {};\n+    private class ExceptionTwo extends RuntimeException {};\n+    private class ExceptionThree extends RuntimeException {};\n+    private class ExceptionFour extends RuntimeException {};\n }\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n import org.hamcrest.*;\n \n @SuppressWarnings(\"unchecked\")\n-public class ExtraMatchers {\n+public class ExtraMatchers extends CoreMatchers {\n \n     public static <T> Matcher<Throwable> firstMethodOnStackEqualsTo(final String method) {\n         return new BaseMatcher<Throwable>() {", "timestamp": 1196531463, "metainfo": ""}