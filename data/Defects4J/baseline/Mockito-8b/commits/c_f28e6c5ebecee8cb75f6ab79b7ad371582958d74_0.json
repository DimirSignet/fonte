{"sha": "f28e6c5ebecee8cb75f6ab79b7ad371582958d74", "log": "added some experimental stuff that can filter stack trace: the developer clicks on first stack trace element and sees what's up  --HG-- rename : src/org/mockito/exceptions/MockVerificationAssertionError.java => src/org/mockito/exceptions/VerificationAssertionError.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4037", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n public class Mockito extends Matchers {\n \n     public static <T> T mock(Class<T> classToMock) {\n-        try {\n-            MockFactory<T> proxyFactory = new MockFactory<T>();\n-            MockControl<T> mockControl = new MockControl<T>(MockitoState.instance(), LastArguments.instance());\n-            return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n-                    classToMock, mockControl));\n-        } catch (RuntimeExceptionWrapper e) {\n-            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n-        }\n+        MockFactory<T> proxyFactory = new MockFactory<T>();\n+        MockControl<T> mockControl = new MockControl<T>(MockitoState.instance(), LastArguments.instance());\n+        return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n+                classToMock, mockControl));\n     }\n \n     public static <T> MockitoExpectation<T> stub(T methodCallToStub) {\n     }\n     \n     public static <T> T verify(T mock) {\n-        MockUtil.validateMock(mock);\n-        MockitoState.instance().verifyingStarted(VerifyingMode.anyTimes());\n-        return mock;\n+        try {\n+            MockUtil.validateMock(mock);\n+            MockitoState.instance().verifyingStarted(VerifyingMode.anyTimes());\n+            return mock; \n+        } catch (RuntimeException e) {\n+            throw filterStackTrace(e);\n+        } catch (Error e) {\n+            throw filterStackTrace(e);\n+        }\n     }\n     \n+    private static Error filterStackTrace(Error e) {\n+        return (Error) e.fillInStackTrace();\n+    }\n+\n+    private static RuntimeException filterStackTrace(RuntimeException e) {\n+        return (RuntimeException) e.fillInStackTrace();\n+    }\n+\n     public static <T> T verify(T mock, int exactNumberOfInvocations) {\n         MockUtil.validateMock(mock);\n         MockitoState.instance().verifyingStarted(VerifyingMode.times(exactNumberOfInvocations));\n--- a/src/org/mockito/exceptions/InvalidUseOfMatchersException.java\n+++ b/src/org/mockito/exceptions/InvalidUseOfMatchersException.java\n package org.mockito.exceptions;\n \n-public class InvalidUseOfMatchersException extends IllegalStateException {\n+public class InvalidUseOfMatchersException extends MockitoException {\n \n     private static final long serialVersionUID = 1L;\n \n--- a/src/org/mockito/exceptions/MissingMethodInvocationException.java\n+++ b/src/org/mockito/exceptions/MissingMethodInvocationException.java\n package org.mockito.exceptions;\n \n-public class MissingMethodInvocationException extends RuntimeException {\n+public class MissingMethodInvocationException extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n \n     public MissingMethodInvocationException() {\n         super(\"stub() requires an argument which has to be a proper method call on a mock object\");\n--- /dev/null\n+++ b/src/org/mockito/exceptions/MockitoAssertionError.java\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+import org.mockito.exceptions.stacktrace.StackTraceFilter;\n+\n+public class MockitoAssertionError extends AssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+    protected List<StackTraceElement> unfilteredStackTrace;\n+\n+    public MockitoAssertionError(String message, StackTraceFilter filter) {\n+        super(message);\n+        \n+        unfilteredStackTrace = Arrays.asList(getStackTrace());\n+        int lastToRemove = -1;\n+        int i = 0;\n+        for (StackTraceElement trace : unfilteredStackTrace) {\n+            if (filter.isLastStackElementToRemove(trace)) {\n+                lastToRemove = i;\n+                break;\n+            }\n+            i++;\n+        }\n+        \n+        List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove+1, unfilteredStackTrace.size() - 1);\n+        setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+    }\n+    \n+    public StackTraceElement[] getUnfilteredStackTrace() {\n+        return unfilteredStackTrace.toArray(new StackTraceElement[]{});\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/MockitoException.java\n+package org.mockito.exceptions;\n+\n+public class MockitoException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public MockitoException(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/exceptions/NotAMockException.java\n+++ b/src/org/mockito/exceptions/NotAMockException.java\n package org.mockito.exceptions;\n \n-public class NotAMockException extends RuntimeException {\n+public class NotAMockException extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n \n     public NotAMockException(Object object) {\n         super(\"Not a mock: \" + object.getClass().getName());\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n package org.mockito.exceptions;\n \n-public class NumberOfInvocationsAssertionError extends AssertionError {\n+import org.mockito.exceptions.stacktrace.LastClassIsCglibEnchantedFilter;\n+\n+public class NumberOfInvocationsAssertionError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n \n     public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked) {\n-        super(\"Expected to be invoked \" + expectedInvoked + \" times but was \" + actuallyInvoked);\n+        super(\"Expected to be invoked \" + expectedInvoked + \" times but was \" + actuallyInvoked, new LastClassIsCglibEnchantedFilter());\n     }\n }\n--- a/src/org/mockito/exceptions/UnfinishedStubbingException.java\n+++ b/src/org/mockito/exceptions/UnfinishedStubbingException.java\n package org.mockito.exceptions;\n \n-public class UnfinishedStubbingException extends RuntimeException {\n+public class UnfinishedStubbingException extends MockitoException {\n \n+    private static final long serialVersionUID = 1L;\n+\n+    public UnfinishedStubbingException(String message) {\n+        super(\"bollox\");\n+    }\n }\n--- a/src/org/mockito/exceptions/UnfinishedVerificationException.java\n+++ b/src/org/mockito/exceptions/UnfinishedVerificationException.java\n package org.mockito.exceptions;\n \n-public class UnfinishedVerificationException extends RuntimeException {\n+public class UnfinishedVerificationException extends MockitoException {\n     \n+    private static final long serialVersionUID = 1L;\n+\n     public UnfinishedVerificationException() {\n         super(  \"\\n\" +\n         \t\t\"Previous verify(mock) doesn't have a method call.\" +\n--- /dev/null\n+++ b/src/org/mockito/exceptions/VerificationAssertionError.java\n+package org.mockito.exceptions;\n+\n+import org.mockito.exceptions.stacktrace.*;\n+\n+\n+public class VerificationAssertionError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private VerificationAssertionError(String message, StackTraceFilter filter) {\n+        super(message, filter);\n+    }\n+    \n+    public static VerificationAssertionError createNotInvokedError(String message) {\n+        return new VerificationAssertionError(message, new LastClassIsCglibEnchantedFilter());\n+    }\n+\n+    public static VerificationAssertionError createNoMoreInteractionsError(String message) {\n+        return new VerificationAssertionError(message, new LastClassIsMockitoFilter());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/stacktrace/LastClassIsCglibEnchantedFilter.java\n+/*\n+ * Copyright (c) 2007, Szczepan Faber. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.stacktrace;\n+\n+public class LastClassIsCglibEnchantedFilter implements StackTraceFilter {\n+    public boolean isLastStackElementToRemove(StackTraceElement e) {\n+        return e.getClassName().contains(\"$$EnhancerByCGLIB$$\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/stacktrace/LastClassIsMockitoFilter.java\n+/*\n+ * Copyright (c) 2007, Szczepan Faber. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.stacktrace;\n+\n+\n+public class LastClassIsMockitoFilter implements StackTraceFilter {\n+    public boolean isLastStackElementToRemove(StackTraceElement e) {\n+        return e.getClassName().equals(\"org.mockito.Mockito\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/stacktrace/StackTraceFilter.java\n+package org.mockito.exceptions.stacktrace;\n+\n+public interface StackTraceFilter {\n+\n+    public boolean isLastStackElementToRemove(StackTraceElement e);\n+\n+}\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal;\n-\n-import static java.lang.Character.*;\n \n import java.lang.reflect.Method;\n \n     }\n \n     public String getMockAndMethodName() {\n-        String mockName = mock.toString();\n-        String methodName = method.getName();\n-        if (toStringIsDefined(mock) && isJavaIdentifier(mockName)) {\n-            return mockName + \".\" + methodName;\n-        } else {\n-            return methodName;\n-        }\n+        String mockName = Namer.nameForMock(mock);\n+        return mockName + \".\" + method.getName();\n     }\n \n-    private boolean toStringIsDefined(Object o) {\n-        try {\n-            o.getClass().getDeclaredMethod(\"toString\", (Class[]) null)\n-                    .getModifiers();\n-            return true;\n-        } catch (SecurityException ignored) {\n-            \n-            return false;\n-            \n-        } catch (NoSuchMethodException shouldNeverHappen) {\n-            \n-            throw new RuntimeException(\"The toString() method could not be found!\");\n-            \n-        }\n-    }\n-\n-    public static boolean isJavaIdentifier(String mockName) {\n-        if (mockName.length() == 0 || mockName.indexOf(' ') > -1\n-                || !Character.isJavaIdentifierStart(mockName.charAt(0))) {\n-            return false;\n-        }\n-        for (char c : mockName.substring(1).toCharArray()) {\n-            if (!isJavaIdentifierPart(c)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-    \n     public void markVerified() {\n         verified = true;\n     }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n package org.mockito.internal;\n \n-import java.lang.reflect.*;\n+import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.exceptions.*;\n import org.mockito.internal.matchers.*;\n \n public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n     \n     private void validateThrowable(Throwable throwable) {\n         if (throwable == null) {\n-            throw new IllegalArgumentException(\"Cannot set null throwable\");\n+            throw new MockitoException(\"Cannot set null throwable\");\n         }\n \n         if (throwable instanceof RuntimeException || throwable instanceof Error) {\n             return;\n         }\n     \n-        if (! isValidCheckedException(throwable)) {\n-            throw new IllegalArgumentException(\"Given checked exception is invalid for this method\"); \n+        if (!isValidCheckedException(throwable)) {\n+            throw new MockitoException(\"Given checked exception is invalid for this method\"); \n         }\n     }\n \n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n \n import net.sf.cglib.proxy.*;\n \n-import org.mockito.exceptions.NotAMockException;\n+import org.mockito.exceptions.*;\n import org.mockito.internal.MockFactory.MockMethodInterceptor;\n \n public class MockUtil {\n     @SuppressWarnings(\"unchecked\")\n     public static <T> MockControl<T> getControl(T mock) {\n         if (mock == null) {\n-            throw new IllegalArgumentException(\"Mock cannot be null\");\n+            throw new MockitoException(\"Mock cannot be null\");\n         }\n         \n         ObjectMethodsFilter<MockControl<T>> handler;\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n             } \n         } else {\n             if (actuallyInvoked == 0) {\n-                throw new MockVerificationAssertionError(\n+                throw VerificationAssertionError.createNotInvokedError(\n                         \"\\n\" +\n-                        \"Not invoked: \" + ObjectMethodsFilter.simpleName(mock) + \".\" + invocation.toString());\n+                        \"Not invoked: \" + invocation.toString());\n             }\n         }\n     }\n     private void verifyNoMoreInteractions(String verificationErrorMessage) {\n         for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n             if (!registeredInvocation.getInvocation().isVerified()) {\n-                String mockName = ObjectMethodsFilter.simpleName(mock);\n-                throw new MockVerificationAssertionError(\n+                String mockName = Namer.nameForMock(mock);\n+                throw VerificationAssertionError.createNoMoreInteractionsError(\n                         \"\\n\" +\n-                        verificationErrorMessage + \" on \" + mockName + \" but found: \" + mockName + \".\" + registeredInvocation.toString());\n+                        verificationErrorMessage + \" on \" + mockName + \" but found: \" + registeredInvocation.toString());\n             }\n         }\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/Namer.java\n+package org.mockito.internal;\n+\n+public class Namer {\n+\n+    public static String nameForMock(Object mock) {\n+    \tif (mock.getClass().getInterfaces().length == 2) {\n+    \t\treturn mock.getClass().getInterfaces()[0].getSimpleName();\n+    \t} else {\n+    \t\treturn mock.getClass().getSuperclass().getSimpleName();\n+    \t}\n+    }\n+}\n--- a/src/org/mockito/internal/ObjectMethodsFilter.java\n+++ b/src/org/mockito/internal/ObjectMethodsFilter.java\n     }\n \n     private String mockToString(Object mock) {\n-        return \"Mock for \" + simpleName(mock);\n+        return \"Mock for \" + Namer.nameForMock(mock);\n     }\n-\n-    public static String simpleName(Object mock) {\n-\t\tif (mock.getClass().getInterfaces().length == 2) {\n-\t\t\treturn mock.getClass().getInterfaces()[0].getSimpleName();\n-\t\t} else {\n-\t\t\treturn mock.getClass().getSuperclass().getSimpleName();\n-\t\t}\n-\t}\n \n     public T getDelegate() {\n         return delegate;\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n package org.mockito.internal;\n \n-import org.mockito.exceptions.MockVerificationAssertionError;\n+import org.mockito.exceptions.MockitoException;\n \n public class VerifyingMode {\n \n \n     public static VerifyingMode times(int exactNumberOfInvocations) {\n         if (exactNumberOfInvocations < 0) {\n-            throw new IllegalArgumentException(\"Negative value is not allowed here\");\n+            throw new MockitoException(\"Negative value is not allowed here\");\n         }\n         return new VerifyingMode(exactNumberOfInvocations);\n     }\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n import net.sf.cglib.proxy.*;\n \n import org.junit.Test;\n-import org.mockito.exceptions.NotAMockException;\n+import org.mockito.exceptions.*;\n \n public class MockUtilTest {\n \n         getControl(\"\");\n     }\n     \n-    @Test (expected=IllegalArgumentException.class)\n+    @Test (expected=MockitoException.class)\n     public void shouldScreamWhenNullPassed() {\n         getControl(null);\n     }\n         validateMock(\"\");\n     }\n     \n-    @Test (expected=IllegalArgumentException.class)\n+    @Test (expected=MockitoException.class)\n     public void shouldScreamWhenNullPassedToValidation() {\n         validateMock(null);\n     }\n--- a/test/org/mockito/VerifyingModeTest.java\n+++ b/test/org/mockito/VerifyingModeTest.java\n package org.mockito;\n \n import org.junit.Test;\n+import org.mockito.exceptions.MockitoException;\n import org.mockito.internal.VerifyingMode;\n \n import static org.junit.Assert.*;\n         try {\n             VerifyingMode.times(-50);\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (MockitoException e) {\n             assertEquals(\"Negative value is not allowed here\", e.getMessage());\n         }\n     }\n--- a/test/org/mockito/usage/UsingVarargsTest.java\n+++ b/test/org/mockito/usage/UsingVarargsTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.MockVerificationAssertionError;\n+import org.mockito.exceptions.VerificationAssertionError;\n \n public class UsingVarargsTest {\n \n         try {\n             verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n     }\n \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n     }\n \n     @Test\n         try {\n             verify(mock).withBooleanVarargs(3, true, true, true, true);\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n     }\n }\n--- a/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n         try {\n             mock.simpleMethodWithArgument(CrazyMatchers.or(eq(\"jkl\"), \"asd\"));\n             fail();\n-        } catch (IllegalStateException e) {\n+        } catch (InvalidUseOfMatchersException e) {\n             assertEquals(\n                     \"\\n\" +\n             \t\t\"2 matchers expected, 1 recorded.\" +\n         try {\n             mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n             fail();\n-        } catch (IllegalStateException e) {\n+        } catch (InvalidUseOfMatchersException e) {\n             assertEquals(\n                     \"\\n\" +\n                     \"3 matchers expected, 1 recorded.\" +\n--- a/test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java\n import java.io.*;\n import java.util.LinkedList;\n \n-import org.junit.Test;\n+import org.junit.*;\n+import org.mockito.exceptions.MockitoException;\n \n @SuppressWarnings(\"unchecked\")\n public class StubbingWithThrowablesTest {\n         try {\n             stub(list.add(\"monkey island\")).andThrows(checkedException);\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (MockitoException e) {\n             assertEquals(\"Given checked exception is invalid for this method\", e.getMessage());\n         }\n     }\n         try {\n             stub(list.add(\"monkey island\")).andThrows(null);\n             fail();\n-        } catch (IllegalArgumentException e) {\n+        } catch (MockitoException e) {\n             assertEquals(\"Cannot set null throwable\", e.getMessage());\n         }\n     }    \n     \n+    @Ignore\n     @Test\n     public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n         \n     }\n     \n+    @Ignore\n     @Test\n     public void shouldVerifyWhenStubbedWithThrowable() throws Exception {\n         \n--- a/test/org/mockito/usage/verification/BasicVerificationTest.java\n+++ b/test/org/mockito/usage/verification/BasicVerificationTest.java\n package org.mockito.usage.verification;\n \n-import static org.hamcrest.CoreMatchers.equalTo;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.fail;\n \n import java.util.*;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.MockVerificationAssertionError;\n+import org.mockito.exceptions.VerificationAssertionError;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicVerificationTest {\n         try {\n             Mockito.verify(mock).clear();\n             fail();\n-        } catch (MockVerificationAssertionError expected) {};\n+        } catch (VerificationAssertionError expected) {};\n     }\n \n     @Test\n         try {\n             Mockito.verify(mock).add(\"bar\");\n             fail();\n-        } catch (MockVerificationAssertionError expected) {};\n+        } catch (VerificationAssertionError expected) {};\n     }\n \n     @Test\n         try {\n             Mockito.verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (MockVerificationAssertionError expected) {};\n+        } catch (VerificationAssertionError expected) {};\n     }\n     \n     @Test\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.MockVerificationAssertionError;\n+import org.mockito.exceptions.VerificationAssertionError;\n import org.mockito.usage.IMethods;\n \n public class NiceMessagesWhenVerificationFailsTest {\n     public void shouldPrintMethodName() {\n         try {\n             verify(mock).simpleMethod();\n-        } catch (MockVerificationAssertionError expected) {\n+        } catch (VerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n     public void shouldPrintMethodNameAndArguments() {\n         try {\n             verify(mock).threeArgumentMethod(12, new SomeClass(), \"some string\");\n-        } catch (MockVerificationAssertionError expected) {\n+        } catch (VerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n         verify(mock).oneArg(true);\n         try {\n             verifyNoMoreInteractions(mock);\n-        } catch (MockVerificationAssertionError expected) {\n+        } catch (VerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n         \n         try {\n             verifyZeroInteractions(mock);\n-        } catch (MockVerificationAssertionError expected) {\n+        } catch (VerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n--- a/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n import java.util.*;\n \n import org.junit.Test;\n-import org.mockito.exceptions.MockVerificationAssertionError;\n+import org.mockito.exceptions.VerificationAssertionError;\n \n @SuppressWarnings(\"unchecked\")\n public class NoMoreInteractionsVerificationTest {\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (MockVerificationAssertionError e) {\n+        } catch (VerificationAssertionError e) {\n             //cool\n         }\n     }\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (MockVerificationAssertionError e) {\n+        } catch (VerificationAssertionError e) {\n             //cool\n         }\n     }\n         try {\n             verifyZeroInteractions(map);\n             fail();\n-        } catch (MockVerificationAssertionError e) {\n+        } catch (VerificationAssertionError e) {\n             //cool\n         }\n     }\n--- /dev/null\n+++ b/test/org/mockito/usage/verification/StackTrackeFilteringWhenVerificationFailsTest.java\n+package org.mockito.usage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.usage.IMethods;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+public class StackTrackeFilteringWhenVerificationFailsTest {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerify() {\n+        try {\n+            verify(mock).simpleMethod();\n+        } catch (VerificationAssertionError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerify\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"createNotInvokedError\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyNoMoreInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+        } catch (VerificationAssertionError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"createNoMoreInteractionsError\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyZeroInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyZeroInteractions(mock);\n+        } catch (VerificationAssertionError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"createNoMoreInteractionsError\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+}\n--- a/test/org/mockito/usage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockito/usage/verification/VerificationUsingMatchersTest.java\n \n import org.junit.*;\n import org.mockito.*;\n-import org.mockito.exceptions.MockVerificationAssertionError;\n+import org.mockito.exceptions.VerificationAssertionError;\n import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             verify(mock).oneArg(CrazyMatchers.same(three));\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n     }  \n     \n     @Test\n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n \n         mock.threeArgumentMethod(8, new Object(), \"01234\");\n         \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"no match\");\n \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (MockVerificationAssertionError e) {}\n+        } catch (VerificationAssertionError e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"123\");\n         \n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n package org.mockito.util;\n \n import java.util.*;\n-import java.util.regex.Pattern;\n \n import org.hamcrest.*;\n \n @SuppressWarnings(\"unchecked\")\n public class ExtraMatchers {\n \n+    public static <T> Matcher<Throwable> firstMethodOnStackEqualsTo(final String method) {\n+        return new BaseMatcher<Throwable>() {\n+\n+            private String firstMethodOnStack;\n+\n+            public boolean matches(Object throwable) {\n+                firstMethodOnStack = ((Throwable) throwable).getStackTrace()[0].getMethodName();\n+                return  firstMethodOnStack.equals(method);\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"first method expected to be: \" + method + \" but is: \" + firstMethodOnStack);\n+            }\n+        };\n+    }\n+    \n     public static <T> Matcher<Collection> collectionContaining(final T ... elements) {\n         return new BaseMatcher<Collection>() {\n ", "timestamp": 1195514607, "metainfo": ""}