{"sha": "7b715326a38a70933f27cd688cd0346cd6a0cd89", "log": "Fields unit test  --HG-- branch : issue 304 : TestNG integration", "commit": "\n--- a/src/org/mockito/internal/util/reflection/Fields.java\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n package org.mockito.internal.util.reflection;\n \n+import org.mockito.internal.Incubating;\n import org.mockito.internal.util.Checks;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n import java.util.List;\n \n /**\n- * Small fluent reflection tools to work with fields\n+ * Small fluent reflection tools to work with fields.\n+ *\n+ * Code is very new and might need rework.\n  */\n+@Incubating\n public abstract class Fields {\n \n-\n-    public static InstanceFields allFieldsInHierarchy(Object instance) {\n+    /**\n+     * Instance fields declared in thes class and superclasses of the given instance.\n+     *\n+     * @param instance Instance from which declared fields will be retrieved.\n+     * @return InstanceFields of this object instance.\n+     */\n+    public static InstanceFields allDeclaredFieldsOf(Object instance) {\n         List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n         for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\n-            instanceFields.addAll(instanceFieldsIn(instance, clazz));\n+            instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));\n         }\n         return new InstanceFields(instance, instanceFields);\n     }\n \n-    public static Filter<InstanceField> notAnnotatedBy(final Class<? extends Annotation>... annotations) {\n+    /**\n+     * Instance fields declared in the of the given instance.\n+     *\n+     * @param instance Instance from which declared fields will be retrieved.\n+     * @return InstanceFields of this object instance.\n+     */\n+    public static InstanceFields declaredFieldsOf(Object instance) {\n+        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n+        instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));\n+        return new InstanceFields(instance, instanceFields);\n+    }\n+\n+    private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {\n+        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();\n+        for (Field field : fields) {\n+            InstanceField instanceField = new InstanceField(field, instance);\n+            instanceDeclaredFields.add(instanceField);\n+        }\n+        return instanceDeclaredFields;\n+    }\n+\n+    /**\n+     * Accept fields annotated by the given annotations.\n+     *\n+     * @param annotations Annotation types to check.\n+     * @return The filter.\n+     */\n+    public static Filter<InstanceField> annotatedBy(final Class<? extends Annotation>... annotations) {\n         return new Filter<InstanceField>() {\n             public boolean isOut(InstanceField instanceField) {\n                 Checks.checkNotNull(annotations, \"Provide at least one annotation class\");\n         };\n     }\n \n+    /**\n+     * Accept fields with non null value.\n+     *\n+     * @return The filter.\n+     */\n     private static Filter<InstanceField> nullField() {\n         return new Filter<InstanceField>() {\n             public boolean isOut(InstanceField instanceField) {\n-                return instanceField.isNotNull();\n+                return instanceField.isNull();\n             }\n         };\n     }\n \n-    private static List<InstanceField> instanceFieldsIn(Object instance, Class<?> clazz) {\n-        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();\n-        Field[] declaredFields = clazz.getDeclaredFields();\n-        for (Field declaredField : declaredFields) {\n-            InstanceField instanceField = new InstanceField(declaredField, instance);\n-            instanceDeclaredFields.add(instanceField);\n-        }\n-        return instanceDeclaredFields;\n-    }\n     public static class InstanceFields {\n         private final Object instance;\n \n             return values;\n         }\n \n+        public List<String> names() {\n+            List<String> fieldNames = new ArrayList<String>(instanceFields.size());\n+            for (InstanceField instanceField : instanceFields) {\n+                fieldNames.add(instanceField.name());\n+            }\n+            return fieldNames;\n+        }\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/InstanceField.java\n+++ b/src/org/mockito/internal/util/reflection/InstanceField.java\n package org.mockito.internal.util.reflection;\n+\n+import org.mockito.internal.util.Checks;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n \n /**\n-*\n-*/\n+ * Represents an accessible instance field.\n+ *\n+ * Contains the instance reference on which the field can be read adn write.\n+ */\n public class InstanceField {\n     private final Field field;\n     private final Object instance;\n     private FieldReader fieldReader;\n \n+    /**\n+     * Create a new InstanceField.\n+     *\n+     * @param field The field that should be accessed, note that no checks are performed to ensure\n+     *              the field belong to this instance class.\n+     * @param instance The instance from which the field shall be accessed.\n+     */\n     public InstanceField(Field field, Object instance) {\n-        this.field = field;\n-        this.instance = instance;\n+        this.field = Checks.checkNotNull(field, \"field\");\n+        this.instance = Checks.checkNotNull(instance, \"instance\");\n     }\n \n+    /**\n+     * Safely read the field.\n+     *\n+     * @return the field value.\n+     * @see FieldReader\n+     */\n     public Object read() {\n         return reader().read();\n     }\n \n+    /**\n+     * Set the given value to the field of this instance.\n+     *\n+     * @param value The value that should be written to the field.\n+     * @see FieldSetter\n+     */\n     public void set(Object value) {\n         new FieldSetter(instance, field).set(value);\n     }\n \n-    public boolean isNotNull() {\n+    /**\n+     * Check that the field is not null.\n+     *\n+     * @return <code>true</code> if <code>null</code>, else <code>false</code>.\n+     */\n+    public boolean isNull() {\n         return reader().isNull();\n     }\n \n-    public boolean isAnnotatedBy(Class<? extends Annotation> annotation) {\n-        return field.isAnnotationPresent(annotation);\n+    /**\n+     * Check if the field is annotated by the given annotation.\n+     *\n+     * @param annotationClass The annotation type to check.\n+     * @return <code>true</code> if the field is annotated by this annotation, else <code>false</code>.\n+     */\n+    public boolean isAnnotatedBy(Class<? extends Annotation> annotationClass) {\n+        return field.isAnnotationPresent(annotationClass);\n     }\n \n+    /**\n+     * Returns the annotation instance for the given annotation type.\n+     *\n+     * @param annotationClass Tha annotation type to retrieve.\n+     * @param <A> Type of the annotation.\n+     * @return The annotation instance.\n+     */\n     public <A extends Annotation> A annotation(Class<A> annotationClass) {\n         return field.getAnnotation(annotationClass);\n     }\n \n+    /**\n+     * Returns the JDK {@link Field} instance.\n+     *\n+     * @return The actual {@link Field} instance.\n+     */\n     public Field jdkField() {\n         return field;\n     }\n         }\n         return fieldReader;\n     }\n+\n+    /**\n+     * Returns the name of the field.\n+     *\n+     * @return Name of the field.\n+     */\n+    public String name() {\n+        return field.getName();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        InstanceField that = (InstanceField) o;\n+\n+        if (!field.equals(that.field)) return false;\n+        if (!instance.equals(that.instance)) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = field.hashCode();\n+        result = 31 * result + instance.hashCode();\n+        return result;\n+    }\n }\n--- a/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n import java.util.HashSet;\n import java.util.Set;\n \n-import static org.mockito.internal.util.reflection.Fields.notAnnotatedBy;\n+import static org.mockito.internal.util.reflection.Fields.annotatedBy;\n \n public class MockitoAfterTestNGMethod {\n \n     }\n \n     private Collection<Object> instanceMocksOf(Object instance) {\n-        return Fields.allFieldsInHierarchy(instance)\n-                                            .filter(notAnnotatedBy(Mock.class,\n-                                                                   Spy.class,\n-                                                                   MockitoAnnotations.Mock.class))\n+        return Fields.allDeclaredFieldsOf(instance)\n+                                            .filter(annotatedBy(Mock.class,\n+                                                                Spy.class,\n+                                                                MockitoAnnotations.Mock.class))\n                                             .notNull()\n                                             .assignedValues();\n     }\n--- a/subprojects/testng/src/main/java/org/mockito/testng/MockitoBeforeTestNGMethod.java\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoBeforeTestNGMethod.java\n import java.util.List;\n import java.util.WeakHashMap;\n \n-import static org.mockito.internal.util.reflection.Fields.notAnnotatedBy;\n+import static org.mockito.internal.util.reflection.Fields.annotatedBy;\n \n public class MockitoBeforeTestNGMethod {\n \n     }\n \n     private void initializeCaptors(Object instance) {\n-        List<InstanceField> instanceFields = Fields.allFieldsInHierarchy(instance).filter(notAnnotatedBy(Captor.class)).instanceFields();\n+        List<InstanceField> instanceFields = Fields.allDeclaredFieldsOf(instance).filter(annotatedBy(Captor.class)).instanceFields();\n         for (InstanceField instanceField : instanceFields) {\n             new CaptorAnnotationProcessor().process(instanceField.annotation(Captor.class), instanceField.jdkField());\n         }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/FieldsTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+\n+import java.lang.reflect.Field;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class FieldsTest {\n+\n+    @Test\n+    public void fields_should_return_all_declared_fields_in_hierarchy() throws Exception {\n+        assertThat(Fields.allDeclaredFieldsOf(new HierarchyOfClasses()).names())\n+                .containsOnly(\"a\", \"b\", \"static_a\", \"static_b\");\n+    }\n+\n+    @Test\n+    public void fields_should_return_declared_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new HierarchyOfClasses()).names())\n+                .containsOnly(\"b\", \"static_b\");\n+    }\n+\n+    @Test\n+    public void can_filter_not_null_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new NullOrNotNullFields()).notNull().names())\n+                .containsOnly(\"c\");\n+    }\n+\n+    @Test\n+    public void can_get_values_of_instance_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new ValuedFields()).assignedValues())\n+                .containsOnly(\"a\", \"b\");\n+    }\n+\n+\n+    @Test\n+    public void can_get_list_of_InstanceField() throws Exception {\n+        ValuedFields instance = new ValuedFields();\n+\n+        assertThat(Fields.declaredFieldsOf(instance).instanceFields())\n+                .containsOnly(new InstanceField(field(\"a\", instance), instance),\n+                              new InstanceField(field(\"b\", instance), instance)\n+                );\n+    }\n+\n+    private Field field(String name, Object instance) throws NoSuchFieldException {\n+        return instance.getClass().getDeclaredField(name);\n+    }\n+\n+\n+    interface AnInterface {\n+        int someStaticInInterface = 0;\n+\n+    }\n+    public static class ParentClass implements AnInterface {\n+        static int static_a;\n+        int a;\n+\n+    }\n+    public static class HierarchyOfClasses extends ParentClass {\n+        static int static_b;\n+        int b = 1;\n+\n+    }\n+    public static class NullOrNotNullFields {\n+        static Object static_b;\n+        Object b;\n+        Object c = new Object();\n+    }\n+\n+    public static class ValuedFields {\n+        String a = \"a\";\n+        String b = \"b\";\n+    }\n+}", "timestamp": 1332866733, "metainfo": ""}