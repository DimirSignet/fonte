{"sha": "a183ba71fd0f803a8db820084ed799b55a0c69aa", "log": "issue 277 : better documentation + added some tests to document the feature", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.MockitoCore;\n      *   // note that we're chaining method calls: getBar().getName()\n      *   assertEquals(\"deep\", mock.getBar().getName());\n      * </pre>\n-     * \n-     * <strong>Verification API does not support 'chaining'</strong> so deep stub doesn't change how you do verification.\n+     * </p>\n+     * \n      * <p>\n      * <strong>WARNING: </strong>\n      * This feature should rarely be required for regular clean code! Leave it for legacy code.\n      * Mocking a mock to return a mock, to return a mock, (...), to return something meaningful\n      * hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).\n-     * <p>\n-     * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>. \n+     * </p>\n+     *\n+     * <p>\n+     * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>.\n+     * </p>\n+     *\n+     * <p>\n+     * Please note that this answer will return existing mocks that matches the stub. This\n+     * behavior is ok with deep stubs and allows verification to work on the last mock of the chain.\n+     * <pre>\n+     *   when(mock.getBar(anyString()).getThingy().getName()).thenReturn(\"deep\");\n+     *\n+     *   mock.getBar(\"candy bar\").getThingy().getName();\n+     *\n+     *   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());\n+     *   verify(mock.getBar(\"candy bar\").getThingy()).getName();\n+     *   verify(mock.getBar(anyString()).getThingy()).getName();\n+     * </pre>\n+     * </p>\n+     *\n+     * <p>\n+     * Verification only works with the last mock in the chain. You can use verification modes.\n+     * <pre>\n+     *   when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+     *   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(\"deep\");\n+     *   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(\"deep\");\n+     *\n+     *   person.getAddress(\"the docks\").getStreet().getName();\n+     *   person.getAddress(\"the docks\").getStreet().getLongName();\n+     *   person.getAddress(\"the docks\").getStreet(Locale.ITALIAN).getName();\n+     *   person.getAddress(\"the docks\").getStreet(Locale.CHINESE).getName();\n+     *\n+     *   // note that we are actually referring to the very last mock in the stubbing chain.\n+     *   InOrder inOrder = inOrder(\n+     *       person.getAddress(\"the docks\").getStreet(),\n+     *       person.getAddress(\"the docks\").getStreet(Locale.CHINESE),\n+     *       person.getAddress(\"the docks\").getStreet(Locale.ITALIAN)\n+     *   );\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet(), times(1)).getName();\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet()).getLongName();\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.ITALIAN), atLeast(1)).getName();\n+     *   inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.CHINESE)).getName();\n+     * </pre>\n+     * </p>\n+     *\n      * <p>\n      * How deep stub work internally?\n      * <pre>\n      *   when(foo.getBar()).thenReturn(bar);\n      *   when(bar.getName()).thenReturn(\"deep\");\n      * </pre>\n+     * </p>\n+     *\n      * <p>\n      * This feature will not work when any return type of methods included in the chain cannot be mocked\n-     * (for example: is a primitive or a final class). This is because of java type system.   \n+     * (for example: is a primitive or a final class). This is because of java type system.\n+     * </p>\n      */\n     public static final Answer<Object> RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS.get();\n \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * @param methodCall method to be stubbed\n+     * @return OngoingStubbing object used to stub fluently.\n+     *         <strong>Do not</strong> create a reference to this returned object.\n      */\n     public static <T> OngoingStubbing<T> when(T methodCall) {\n         return MOCKITO_CORE.when(methodCall);\n      *   //at this point the mock forgot any interactions & stubbing\n      * </pre>\n      *\n-     * @param <T>\n+     * @param <T> The Type of the mocks\n      * @param mocks to be reset\n      */\n     public static <T> void reset(T ... mocks) {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n-\n-import java.io.Serializable;\n \n import org.mockito.Mockito;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n+import java.io.Serializable;\n+\n+/**\n+ * Returning deep stub implementation.\n+ *\n+ * Will return previously created mock if the invocation matches.\n+ *\n+ * @see Mockito#RETURNS_DEEP_STUBS\n+ * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n+ */\n public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n     \n     private static final long serialVersionUID = -6926328908792880098L;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         Class<?> clz = invocation.getMethod().getReturnType();\n-        if (!new MockCreationValidator().isTypeMockable(clz))\n+\n+        if (!new MockCreationValidator().isTypeMockable(clz)) {\n             return delegate.answer(invocation);\n+        }\n+\n         return getMock(invocation);\n     }\n \n--- a/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.stubbing;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockitoutil.TestBase;\n+\n+import javax.net.SocketFactory;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.util.Locale;\n \n import static org.mockito.BDDMockito.given;\n import static org.mockito.Matchers.anyInt;\n import static org.mockito.Matchers.eq;\n import static org.mockito.Mockito.*;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.OutputStream;\n-import java.net.Socket;\n-import java.util.Locale;\n-\n-import javax.net.SocketFactory;\n-\n-import org.junit.Test;\n-import org.mockitoutil.TestBase;\n-\n \n public class DeepStubbingTest extends TestBase {\n \n         public String getName() {\n             return name;\n         }\n+\n+        public String getLongName() {\n+            return name;\n+        }\n     }    \n     \n-    static final class FinalClass {};    \n+    static final class FinalClass {}\n     \n     @Test\n     public void myTest() throws Exception {\n     }\n     \n     @Test\n-\tpublic void shouldVerificationWorkWithArgumentMatchersInNestedCalls() throws Exception {\n+\tpublic void verification_work_with_argument_Matchers_in_nested_calls() throws Exception {\n \t\t//given\n     \tperson.getAddress(\"111 Mock Lane\").getStreet();\n     \tperson.getAddress(\"111 Mock Lane\").getStreet(Locale.ITALIAN).getName();\n     \tverify(person.getAddress(anyString()).getStreet(Locale.CHINESE), never()).getName();\n     \tverify(person.getAddress(anyString()).getStreet(eq(Locale.ITALIAN))).getName();\n \t}\n-    \n+\n+    @Test\n+    public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() throws Exception {\n+        when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+\n+        person.getAddress(\"the docks\").getStreet().getName();\n+\n+        assertSame(person.getAddress(\"the docks\").getStreet(), person.getAddress(anyString()).getStreet());\n+        assertSame(person.getAddress(anyString()).getStreet(), person.getAddress(anyString()).getStreet());\n+        assertSame(person.getAddress(\"the docks\").getStreet(), person.getAddress(\"the docks\").getStreet());\n+        assertSame(person.getAddress(anyString()).getStreet(), person.getAddress(\"the docks\").getStreet());\n+        assertSame(person.getAddress(\"111 Mock Lane\").getStreet(), person.getAddress(\"the docks\").getStreet());\n+    }\n+\n+    @Test\n+    public void times_never_atLeast_atMost_verificationModes_should_work() throws Exception {\n+        when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet(Locale.ITALIAN).getName();\n+\n+        verify(person.getAddress(\"the docks\").getStreet(), times(3)).getName();\n+        verify(person.getAddress(\"the docks\").getStreet(Locale.CHINESE), never()).getName();\n+        verify(person.getAddress(\"the docks\").getStreet(Locale.ITALIAN), atMost(1)).getName();\n+    }\n+\n+\n+    @Test\n+    public void inOrder_only_work_on_the_very_last_mock_but_it_works() throws Exception {\n+        when(person.getAddress(anyString()).getStreet().getName()).thenReturn(\"deep\");\n+        when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn(\"deep\");\n+        when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn(\"deep\");\n+\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        person.getAddress(\"the docks\").getStreet().getLongName();\n+        person.getAddress(\"the docks\").getStreet(Locale.ITALIAN).getName();\n+        person.getAddress(\"the docks\").getStreet(Locale.CHINESE).getName();\n+\n+        InOrder inOrder = inOrder(\n+                person.getAddress(\"the docks\").getStreet(),\n+                person.getAddress(\"the docks\").getStreet(Locale.CHINESE),\n+                person.getAddress(\"the docks\").getStreet(Locale.ITALIAN)\n+        );\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet(), times(1)).getName();\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet()).getLongName();\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.ITALIAN), atLeast(1)).getName();\n+        inOrder.verify(person.getAddress(\"the docks\").getStreet(Locale.CHINESE)).getName();\n+    }\n+\n+    @Test\n+    public void verificationMode_only_work_on_the_last_returned_mock() throws Exception {\n+        // 1st invocation on Address mock (stubbing)\n+        when(person.getAddress(\"the docks\").getStreet().getName()).thenReturn(\"deep\");\n+\n+        // 2nd invocation on Address mock (real)\n+        person.getAddress(\"the docks\").getStreet().getName();\n+        // 3rd invocation on Address mock (verification)\n+        // (Address mock is not in verification mode)\n+        verify(person.getAddress(\"the docks\").getStreet()).getName();\n+\n+        try {\n+            verify(person.getAddress(\"the docks\"), times(1)).getStreet();\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            Assertions.assertThat(e.getMessage())\n+                    .contains(\"Wanted 1 time\")\n+                    .contains(\"But was 3 times\");\n+        }\n+    }\n+\n     @Test\n     public void shouldFailGracefullyWhenClassIsFinal() throws Exception {\n         //when        ", "timestamp": 1319726684, "metainfo": ""}