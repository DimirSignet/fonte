{"sha": "5cb37751c0aba81d025dc5fe4f2f9a3bf86cc958", "log": "Fixed issue 200 For some weird reason when we had inherited generics sometimes the cglib proxy does not behave like java proxy would. Fixed in Mockito code.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%402022", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n         return !overloadedButSameArgs;\n     }\n \n-    public boolean hasSameMethod(Invocation candidate) {\n-        return invocation.getMethod().equals(candidate.getMethod());\n+    public boolean hasSameMethod(Invocation candidate) {        \n+        //not using method.equals() for 1 good reason:\n+        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n+        Method m1 = invocation.getMethod();\n+        Method m2 = candidate.getMethod();\n+        \n+        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n+        \t/* Avoid unnecessary cloning */\n+        \tClass[] params1 = m1.getParameterTypes();\n+        \tClass[] params2 = m2.getParameterTypes();\n+        \tif (params1.length == params2.length) {\n+        \t    for (int i = 0; i < params1.length; i++) {\n+        \t\tif (params1[i] != params2[i])\n+        \t\t    return false;\n+        \t    }\n+        \t    return true;\n+        \t}\n+        }\n+        return false;\n     }\n     \n     public Location getLocation() {\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/InheritedGenericsPolimorphicCallTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+//see issue 200\n+public class InheritedGenericsPolimorphicCallTest extends TestBase {\n+\n+    protected interface MyIterable<T> extends Iterable<T> {\n+        public MyIterator<T> iterator();\n+    }\n+\n+    protected interface MyIterator<T> extends Iterator<T> {\n+        // adds nothing here\n+    }\n+\n+    MyIterator<String> myIterator = Mockito.mock(MyIterator.class);\n+    MyIterable<String> iterable = Mockito.mock(MyIterable.class);\n+\n+    @Test\n+    public void shouldStubbingWork() {\n+        Mockito.when(iterable.iterator()).thenReturn(myIterator);\n+        Assert.assertNotNull(((Iterable) iterable).iterator());\n+        Assert.assertNotNull(iterable.iterator());\n+    }\n+    \n+    @Test\n+    public void shouldVerificationWorks() {\n+        iterable.iterator();\n+        \n+        verify(iterable).iterator();\n+        verify((Iterable) iterable).iterator();\n+    }\n+    \n+    @Test\n+    public void shouldWorkExactlyAsJavaProxyWould() {\n+        //given\n+        final List<Method> methods = new LinkedList<Method>();\n+        InvocationHandler handler = new InvocationHandler() {\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            methods.add(method);\n+            return null;\n+        }};\n+            \n+        iterable = (MyIterable) Proxy.newProxyInstance(\n+                this.getClass().getClassLoader(),\n+                new Class[] { MyIterable.class },\n+                handler);\n+\n+        //when\n+        iterable.iterator();\n+        ((Iterable) iterable).iterator();\n+        \n+        //then\n+        assertEquals(2, methods.size());\n+        assertEquals(methods.get(0), methods.get(1));\n+    }  \n+}", "timestamp": 1277184733, "metainfo": ""}