{"sha": "8bc5850f720002ed89b70ea90e6a979cfd5d67ac", "log": "issue 327 : replace HashSet by a safe set that don't use Mock hashCode and equals method as they might be unreliable if not stubbable. Created an internal collection utils package.", "commit": "\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n import java.lang.reflect.Field;\n import java.util.HashSet;\n import java.util.Set;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * See {@link MockitoAnnotations}\n     public void injectMocks(final Object testClassInstance) {\n         Class<?> clazz = testClassInstance.getClass();\n         Set<Field> mockDependentFields = new HashSet<Field>();\n-        Set<Object> mocks = new HashSet<Object>();\n+        Set<Object> mocks = newMockSafeHashSet();\n         \n         while (clazz != Object.class) {\n             new InjectMocksScanner(clazz).addTo(mockDependentFields);\n--- a/src/org/mockito/internal/configuration/injection/MockInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n \n import static org.mockito.internal.util.Checks.checkItemsNotNull;\n import static org.mockito.internal.util.Checks.checkNotNull;\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Internal injection configuration utility.\n      */\n     public static class OngoingMockInjection {\n         private Set<Field> fields = new HashSet<Field>();\n-        private Set<Object> mocks = new HashSet<Object>();\n+        private Set<Object> mocks = newMockSafeHashSet();\n         private Object fieldOwner;\n         private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n         private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.injection.filter.*;\n-import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n import java.util.*;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Inject mocks using first setters then fields, if no setters available.\n         Class<?> fieldClass = report.fieldClass();\n         Object fieldInstanceNeedingInjection = report.fieldInstance();\n         while (fieldClass != Object.class) {\n-            injectionOccurred |= injectMockCandidate(fieldClass, new HashSet<Object>(mockCandidates), fieldInstanceNeedingInjection);\n+            injectionOccurred |= injectMockCandidate(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n             fieldClass = fieldClass.getSuperclass();\n         }\n         return injectionOccurred;\n     }\n+\n \n \n     private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n--- a/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n import org.mockito.internal.util.reflection.FieldReader;\n \n import java.lang.reflect.Field;\n-import java.util.HashSet;\n import java.util.Set;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Scan mocks, and prepare them if needed.\n      * @return A prepared set of mock\n      */\n     private Set<Object> scan() {\n-        Set<Object> mocks = new HashSet<Object>();\n+        Set<Object> mocks = newMockSafeHashSet();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n             FieldReader fieldReader = new FieldReader(instance, field);\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.List;\n \n import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.util.ListUtil;\n-import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.internal.verification.api.InOrderContext;\n \n public class InvocationsFinder {\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n package org.mockito.internal.invocation.finder;\n \n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil;\n \n import java.util.List;\n \n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n+package org.mockito.internal.util.collections;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+/**\n+ * hashCode and equals safe mock wrapper.\n+ *\n+ * <p>\n+ *     It doesn't use the actual mock {@link Object#hashCode} and {@link Object#equals} method as they might\n+ *     throw an NPE if those method cannot be stubbed <em>even internally</em>.\n+ * </p>\n+ *\n+ * <p>\n+ *     Instead the strategy is :\n+ *     <ul>\n+ *         <li>For hashCode : <strong>use {@link System#identityHashCode}</strong></li>\n+ *         <li>For equals : <strong>use the object reference equality</strong></li>\n+ *     </ul>\n+ * </p>\n+ *\n+ * @see HashCodeAndEqualsSafeSet\n+ */\n+public class HashCodeAndEqualsMockWrapper {\n+\n+    private Object mockInstance;\n+\n+    public HashCodeAndEqualsMockWrapper(Object mockInstance) {\n+        this.mockInstance = mockInstance;\n+    }\n+\n+    public Object get() {\n+        return mockInstance;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof HashCodeAndEqualsMockWrapper)) return false;\n+\n+        HashCodeAndEqualsMockWrapper that = (HashCodeAndEqualsMockWrapper) o;\n+\n+        return mockInstance == that.mockInstance;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(mockInstance);\n+    }\n+\n+    public static HashCodeAndEqualsMockWrapper of(Object mock) {\n+        return new HashCodeAndEqualsMockWrapper(mock);\n+    }\n+\n+    @Override public String toString() {\n+        MockUtil mockUtil = new MockUtil();\n+        return \"HashCodeAndEqualsMockWrapper{\" +\n+                \"mockInstance=\" + (mockUtil.isMock(mockInstance) ? mockUtil.getMockName(mockInstance) : typeInstanceString()) +\n+                '}';\n+    }\n+\n+    private String typeInstanceString() {\n+        return mockInstance.getClass().getSimpleName() + \"(\" + System.identityHashCode(mockInstance) + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n+package org.mockito.internal.util.collections;\n+\n+import org.mockito.internal.util.Checks;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import static java.lang.reflect.Array.*;\n+\n+/**\n+ * hashCode and equals safe hash based set.\n+ *\n+ * <p>\n+ *     Useful for holding mocks that have un-stubbable hashCode or equals method,\n+ *     meaning that in this scenario the real code is always called and will most probably\n+ *     cause an {@link NullPointerException}.\n+ * </p>\n+ * <p>\n+ *     This collection wraps the mock in an augmented type {@link HashCodeAndEqualsMockWrapper}\n+ *     that have his own implementation.\n+ * </p>\n+ *\n+ * @see HashCodeAndEqualsMockWrapper\n+ */\n+public class HashCodeAndEqualsSafeSet implements Set<Object> {\n+\n+    private HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+\n+    public Iterator<Object> iterator() {\n+        return new Iterator<Object>() {\n+            private Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n+\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            public Object next() {\n+                return iterator.next().get();\n+            }\n+\n+            public void remove() {\n+                iterator.remove();\n+            }\n+        };\n+    }\n+\n+    public int size() {\n+        return backingHashSet.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return backingHashSet.isEmpty();\n+    }\n+\n+    public boolean contains(Object mock) {\n+        return backingHashSet.contains(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public boolean add(Object mock) {\n+        return backingHashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public boolean remove(Object mock) {\n+        return backingHashSet.remove(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public void clear() {\n+        backingHashSet.clear();\n+    }\n+\n+    @Override public Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+        if (!(o instanceof HashCodeAndEqualsSafeSet)) {\n+            return false;\n+        }\n+        HashCodeAndEqualsSafeSet that = (HashCodeAndEqualsSafeSet) o;\n+        return backingHashSet.equals(that.backingHashSet);\n+    }\n+\n+    @Override public int hashCode() {\n+        return backingHashSet.hashCode();\n+    }\n+\n+    public Object[] toArray() {\n+        return unwrapTo(new Object[size()]);\n+    }\n+\n+    private <T> T[] unwrapTo(T[] array) {\n+        Iterator<Object> iterator = iterator();\n+        for (int i = 0, objectsLength = array.length; i < objectsLength; i++) {\n+            if (iterator.hasNext()) {\n+                array[i] = (T) iterator.next();\n+            }\n+        }\n+        return array;\n+    }\n+\n+\n+    public <T> T[] toArray(T[] typedArray) {\n+        T[] array = typedArray.length >= size() ? typedArray :\n+                (T[]) newInstance(typedArray.getClass().getComponentType(), size());\n+        return unwrapTo(array);\n+    }\n+\n+    public boolean removeAll(Collection<?> mocks) {\n+        return backingHashSet.removeAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean containsAll(Collection<?> mocks) {\n+        return backingHashSet.containsAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean addAll(Collection<?> mocks) {\n+        return backingHashSet.addAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean retainAll(Collection<?> mocks) {\n+        return backingHashSet.retainAll(asWrappedMocks(mocks));\n+    }\n+\n+    private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {\n+        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n+        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+        for (Object mock : mocks) {\n+            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n+            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n+        }\n+        return hashSet;\n+    }\n+\n+    @Override public String toString() {\n+        return backingHashSet.toString();\n+    }\n+\n+    public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n+        return of(Arrays.asList(mocks));\n+    }\n+\n+    public static HashCodeAndEqualsSafeSet of(Iterable<Object> objects) {\n+        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet = new HashCodeAndEqualsSafeSet();\n+        if (objects != null) {\n+            for (Object mock : objects) {\n+                hashCodeAndEqualsSafeSet.add(mock);\n+            }\n+        }\n+        return hashCodeAndEqualsSafeSet;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/IdentitySet.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import java.util.LinkedList;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class IdentitySet {\n+\n+    LinkedList list = new LinkedList();\n+    \n+    public boolean contains(Object o) {\n+        for(Object existing:list) {\n+            if (existing == o) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void add(Object o) {\n+        list.add(o);        \n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/ListUtil.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.util.collections;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+public class ListUtil {\n+\n+    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n+        LinkedList<T> filtered = new LinkedList<T>();\n+        for (T t : collection) {\n+            if (!filter.isOut(t)) {\n+                filtered.add(t);\n+            }\n+        }\n+        return filtered;\n+    }\n+    \n+    public static interface Filter<T> {\n+        boolean isOut(T object);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/Sets.java\n+package org.mockito.internal.util.collections;\n+\n+\n+import java.util.Set;\n+\n+public abstract class Sets {\n+    public static Set<Object> newMockSafeHashSet(Iterable<Object> mocks) {\n+        return HashCodeAndEqualsSafeSet.of(mocks);\n+    }\n+\n+    public static Set<Object> newMockSafeHashSet(Object... mocks) {\n+        return HashCodeAndEqualsSafeSet.of(mocks);\n+    }\n+\n+    public static IdentitySet newIdentitySet() {\n+        return new IdentitySet();\n+    }\n+}\n--- a/src/org/mockito/internal/verification/InOrderContextImpl.java\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.IdentitySet;\n+import org.mockito.internal.util.collections.IdentitySet;\n import org.mockito.internal.verification.api.InOrderContext;\n \n public class InOrderContextImpl implements InOrderContext {\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.ListUtil;\n-import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n \n import java.io.Serializable;\n import java.util.Collections;\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.concurrentmockito;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n import org.junit.runner.Result;\n import org.mockito.internal.progress.MockingProgressImplTest;\n import org.mockito.internal.progress.TimesTest;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n-import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.util.collections.ListUtilTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;\n import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n import org.mockitousage.verification.VerificationUsingMatchersTest;\n import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n \n public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n     \n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Observer;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+public class HashCodeAndEqualsSafeSetTest {\n+\n+    @Test\n+    public void can_add_mock_that_have_failing_hashCode_method() throws Exception {\n+        new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));\n+    }\n+\n+    @Test\n+    public void mock_with_failing_hashCode_method_can_be_added() throws Exception {\n+        new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));\n+    }\n+\n+    @Test\n+    public void mock_with_failing_equals_method_can_be_used() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();\n+        UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);\n+        mocks.add(mock);\n+\n+        assertThat(mocks.contains(mock)).isTrue();\n+        assertThat(mocks.contains(mock(UnmockableHashCodeAndEquals.class))).isFalse();\n+    }\n+\n+    @Test\n+    public void can_remove() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();\n+        UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);\n+        mocks.add(mock);\n+        mocks.remove(mock);\n+\n+        assertThat(mocks.isEmpty()).isTrue();\n+    }\n+\n+\n+    @Test\n+    public void can_add_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+\n+        assertThat(workingSet.containsAll(mocks)).isTrue();\n+    }\n+\n+    @Test\n+    public void can_retain_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+        workingSet.add(mock(List.class));\n+\n+        assertThat(workingSet.retainAll(mocks)).isTrue();\n+        assertThat(workingSet.containsAll(mocks)).isTrue();\n+    }\n+\n+    @Test\n+    public void can_remove_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+        workingSet.add(mock(List.class));\n+\n+        assertThat(workingSet.removeAll(mocks)).isTrue();\n+        assertThat(workingSet.containsAll(mocks)).isFalse();\n+    }\n+\n+    @Test\n+    public void can_iterate() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        LinkedList<Object> accumulator = new LinkedList<Object>();\n+        for (Object mock : mocks) {\n+            accumulator.add(mock);\n+        }\n+        assertThat(accumulator).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void toArray_just_work() throws Exception {\n+        UnmockableHashCodeAndEquals mock1 = mock(UnmockableHashCodeAndEquals.class);\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1);\n+\n+        assertThat(mocks.toArray()[0]).isSameAs(mock1);\n+\n+        assertThat(mocks.toArray(new UnmockableHashCodeAndEquals[0])[0]).isSameAs(mock1);\n+    }\n+\n+    private static class UnmockableHashCodeAndEquals {\n+        @Override public final int hashCode() {\n+            throw new NullPointerException(\"I'm failing on hashCode and I don't care\");\n+        }\n+\n+        @Override public final boolean equals(Object obj) {\n+            throw new NullPointerException(\"I'm failing on equals and I don't care\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/IdentitySetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+public class IdentitySetTest {\n+    \n+    IdentitySet set = new IdentitySet();\n+    \n+    @Test\n+    public void shouldWork() throws Exception {\n+        //when\n+        Object o = new Object();\n+        set.add(o);\n+\n+        //then\n+        assertTrue(set.contains(o));\n+        assertFalse(set.contains(new Object()));\n+    }\n+    \n+    class Fake {\n+        @Override\n+        public boolean equals(Object obj) {\n+            return true;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldWorkEvenIfEqualsTheSame() throws Exception {\n+        //given\n+        assertEquals(new Fake(), new Fake());\n+        Fake fake = new Fake();\n+        \n+        //when\n+        set.add(fake);\n+\n+        //then\n+        assertTrue(set.contains(fake));\n+        assertFalse(set.contains(new Fake()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/ListUtilTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.mockitoutil.ExtraMatchers.hasExactlyInOrder;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ListUtilTest extends TestBase {\n+\n+    @Test\n+    public void shouldFilterList() throws Exception {\n+        List list = asList(\"one\", \"x\", \"two\", \"x\", \"three\");\n+        List filtered = ListUtil.filter(list, new Filter() {\n+            public boolean isOut(Object object) {\n+                return object == \"x\";\n+            }\n+        });\n+        \n+        assertThat(filtered, hasExactlyInOrder(\"one\", \"two\", \"three\"));\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyIfEmptyListGiven() throws Exception {\n+        List list = new LinkedList();\n+        List filtered = ListUtil.filter(list, null);\n+        assertTrue(filtered.isEmpty());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.nio.charset.Charset;\n+\n+// issue 327\n+public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {\n+    @Mock private Charset charset;\n+    @InjectMocks private FieldCharsetHolder fieldCharsetHolder;\n+    @InjectMocks private ConstructorCharsetHolder constructorCharsetHolder;\n+\n+    @Test\n+    public void dont_raise_NullPointerException() throws Exception {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    private static class FieldCharsetHolder {\n+        private Charset charset;\n+    }\n+\n+    private static class ConstructorCharsetHolder {\n+        public ConstructorCharsetHolder(Charset charset) {\n+        }\n+    }\n+}", "timestamp": 1331428090, "metainfo": ""}