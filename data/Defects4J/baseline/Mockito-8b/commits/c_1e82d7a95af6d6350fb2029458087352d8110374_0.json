{"sha": "1e82d7a95af6d6350fb2029458087352d8110374", "log": "Merged Brice work, head 1967, Hopefully all is ok :)", "commit": "\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n \n package org.mockito;\n \n-import org.hamcrest.*;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n import org.mockito.internal.util.Decamelizer;\n \n /**\n      */\n     public abstract boolean matches(Object argument);\n \n-    /* \n-     * By default this method decamlizes matchers name to promote meaningful names for matchers.\n+    /**\n+     * By default this method decamelizes matchers name to promote meaningful names for matchers.\n      * <p>\n      * For example <b>StringWithStrongLanguage</b> matcher will generate 'String with strong language' description in case of failure.\n      * <p>\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.Documented;\n  *\n  *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n  *     then, if there is several property of the same type, by the match of the property name and the mock name.\n- *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n+ *     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock\n+ *     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>\n+ *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  *\n  *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n  *     then, if there is several property of the same type, by the match of the field name and the mock name.\n- *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n+ *     <p><u>Note 1:</u> If you have fields with the same type (or same erasure), it's better to name all &#064;Mock\n+ *     annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.</p>\n+ *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  * </ol>\n  * </p>\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.configuration.injection.filter.*;\n+import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n  * <u>Algorithm :<br></u>\n  * for each field annotated by @InjectMocks\n  *   <ul>\n- *   <li>copy mocks set\n  *   <li>initialize field annotated by @InjectMocks\n- *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n+ *   <li>for each fields of a class in @InjectMocks type hierarchy\n  *     <ul>\n- *     <li>find mock candidate by type\n- *     <li>if more than <b>*one*</b> candidate find mock candidate on name\n- *     <li>if one mock candidate then\n- *       <ul>\n- *       <li>set mock by property setter if possible\n- *       <li>else set mock by field injection\n- *       </ul>\n- *     <li>remove mock from mocks copy (mocks are just injected once)\n+ *     <li>make a copy of mock candidates\n+ *     <li>order fields rom sub-type to super-type, then by field name\n+ *     <li>for the list of fields in a class try two passes of :\n+ *         <ul>\n+ *             <li>find mock candidate by type\n+ *             <li>if more than <b>*one*</b> candidate find mock candidate on name\n+ *             <li>if one mock candidate then\n+ *                 <ul>\n+ *                     <li>set mock by property setter if possible\n+ *                     <li>else set mock by field injection\n+ *                 </ul>\n+ *             <li>remove mock from mocks copy (mocks are just injected once in a class)\n+ *             <li>remove injected field from list of class fields\n+ *         </ul>\n  *     <li>else don't fail, user will then provide dependencies\n  *     </ul>\n  *   </ul>\n public class PropertyAndSetterInjection extends MockInjectionStrategy {\n \n     private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n-    private Comparator<Field> superTypesLast = new Comparator<Field>() {\n-        public int compare(Field field1, Field field2) {\n-            Class<?> field1Type = field1.getType();\n-            Class<?> field2Type = field2.getType();\n-\n-            if(field1Type.isAssignableFrom(field2Type)) {\n-                return 1;\n-            }\n-            if(field2Type.isAssignableFrom(field1Type)) {\n-                return -1;\n-            }\n-            return 0;\n-        }\n-    };\n+    private Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();\n \n     private ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n         public boolean isOut(Field object) {\n     };\n \n \n-    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+    public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {\n         // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n+        FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);\n+\n+        // for each field in the class hierarchy\n+        boolean injectionOccurred = false;\n+        Class<?> fieldClass = report.fieldClass();\n+        Object fieldInstanceNeedingInjection = report.fieldInstance();\n+        while (fieldClass != Object.class) {\n+            injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n+            fieldClass = fieldClass.getSuperclass();\n+        }\n+        return injectionOccurred;\n+    }\n+\n+    private FieldInitializationReport initializeInjectMocksField(Field field, Object fieldOwner) {\n         FieldInitializationReport report = null;\n         try {\n             report = new FieldInitializer(fieldOwner, field).initialize();\n             }\n             new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n         }\n+        return report; // never null\n+    }\n \n \n-        // for each field in the class hierarchy\n+    private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n         boolean injectionOccurred = false;\n-        Class<?> fieldClass = report.fieldClass();\n-        Object fieldInstanceNeedingInjection = report.fieldInstance();\n-        while (fieldClass != Object.class) {\n-            injectionOccurred |= injectMockCandidate(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n-            fieldClass = fieldClass.getSuperclass();\n-        }\n+        List<Field> orderedInstanceFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n+        // pass 1\n+        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n+        // pass 2\n+        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n         return injectionOccurred;\n     }\n \n-\n-\n-    private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n-        boolean injectionOccurred = false;\n-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n+        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n+            Field field = it.next();\n             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n-            if(injected != null) {\n+            if (injected != null) {\n                 injectionOccurred |= true;\n                 mocks.remove(injected);\n+                it.remove();\n             }\n         }\n         return injectionOccurred;\n         return declaredFields;\n     }\n \n+    static class FieldTypeAndNameComparator implements Comparator<Field> {\n+        public int compare(Field field1, Field field2) {\n+            Class<?> field1Type = field1.getType();\n+            Class<?> field2Type = field2.getType();\n+\n+            // if same type, compares on field name\n+            if (field1Type == field2Type) {\n+                return field1.getName().compareTo(field2.getName());\n+            }\n+            if(field1Type.isAssignableFrom(field2Type)) {\n+                return 1;\n+            }\n+            if(field2Type.isAssignableFrom(field1Type)) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n \n package org.mockito.internal.matchers;\n \n-import java.io.Serializable;\n-\n import org.hamcrest.Description;\n import org.mockito.ArgumentMatcher;\n+\n+import java.io.Serializable;\n \n \n public class EqualsWithDelta extends ArgumentMatcher<Number> implements Serializable {\n \n     public boolean matches(Object actual) {\n         Number actualNumber = (Number) actual;\n+        if (wanted == null ^ actual == null) {\n+            return false;\n+        }\n+\n+        if (wanted == null && actual == null) {\n+            return true;\n+        }\n+\n         return wanted.doubleValue() - delta.doubleValue() <= actualNumber.doubleValue()\n                 && actualNumber.doubleValue() <= wanted.doubleValue()\n                         + delta.doubleValue();\n--- a/src/org/mockito/internal/progress/HandyReturnValues.java\n+++ b/src/org/mockito/internal/progress/HandyReturnValues.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n-import static org.mockito.internal.util.Primitives.*;\n+import java.util.*;\n \n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import static org.mockito.internal.util.Primitives.defaultValueForPrimitiveOrWrapper;\n+import static org.mockito.internal.util.Primitives.isPrimitiveOrWrapper;\n \n @SuppressWarnings(\"unchecked\")\n public class HandyReturnValues {\n     }\n \n     public <T> T returnFor(Class<T> clazz) {\n-        if (isPrimitiveWrapper(clazz)) {\n-            return primitiveWrapperOf(clazz);\n+        // explicitly return null if type is not a primitive or a wrapper\n+        if (isPrimitiveOrWrapper(clazz)) {\n+            return defaultValueForPrimitiveOrWrapper(clazz);\n         } \n-        return primitiveValueOrNullFor(clazz);\n+        return null;\n     }\n \n     public Map returnMap() {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n  */\n \n package org.mockito.internal.stubbing.defaultanswers;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.SortedMap;\n-import java.util.SortedSet;\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n \n import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.mock.MockName;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.*;\n \n /**\n  * Default answer of every Mockito mock.\n     }\n     \n     Object returnValueFor(Class<?> type) {\n-        if (type.isPrimitive()) {\n-            return primitiveOf(type);\n-        } else if (Primitives.isPrimitiveWrapper(type)) {\n-            return Primitives.primitiveWrapperOf(type);\n+        if (Primitives.isPrimitiveOrWrapper(type)) {\n+            return Primitives.defaultValueForPrimitiveOrWrapper(type);\n         //new instances are used instead of Collections.emptyList(), etc.\n         //to avoid UnsupportedOperationException if code under test modifies returned collection\n         } else if (type == Collection.class) {\n             return new TreeMap<Object, Object>();\n         } else if (type == LinkedHashMap.class) {\n             return new LinkedHashMap<Object, Object>();\n-        }       \n+        }\n+        // TODO return empty Iterable ; see issue 175\n+\n         //Let's not care about the rest of collections.\n         return null;\n     }\n \n-    private Object primitiveOf(Class<?> type) {\n-        if (type == Boolean.TYPE) {\n-            return false;\n-        } else if (type == Character.TYPE) {\n-            return (char) 0;\n-        } else {\n-            return 0;\n-        } \n-    }\n }\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import java.util.HashMap;\n \n @SuppressWarnings(\"unchecked\")\n public class Primitives {\n-    \n+\n+    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n+    private static Map<Class<?>, Object> primitiveOrWrapperDefaultValues = new HashMap<Class<?>, Object>();\n+\n+\n+    /**\n+     * Returns the primitive type of the given class.\n+     * <p/>\n+     * The passed class can be any class : <code>boolean.class</code>, <code>Integer.class</code>\n+     * in witch case this method will return <code>boolean.class</code>, even <code>SomeObject.class</code>\n+     * in which case <code>null</code> will be returned.\n+     *\n+     * @param clazz The class from which primitive type has to be retrieved\n+     * @param <T>   The type\n+     * @return The primitive type if relevant, otherwise <code>null</code>\n+     */\n     public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n-        if(clazz.isPrimitive()) {\n+        if (clazz.isPrimitive()) {\n             return clazz;\n         }\n         return (Class<T>) primitiveTypes.get(clazz);\n     }\n \n-    public static boolean isPrimitiveWrapper(Class<?> type) {\n-        return wrapperReturnValues.containsKey(type);\n+    /**\n+     * Indicates if the given class is primitive type or a primitive wrapper.\n+     *\n+     * @param type The type to check\n+     * @return <code>true</code> if primitive or wrapper, <code>false</code> otherwise.\n+     */\n+    public static boolean isPrimitiveOrWrapper(Class<?> type) {\n+        return primitiveOrWrapperDefaultValues.containsKey(type);\n     }\n \n-    public static <T> T primitiveWrapperOf(Class<T> type) {\n-        return (T) wrapperReturnValues.get(type);\n+    /**\n+     * Returns the boxed default value for a primitive or a primitive wrapper.\n+     *\n+     * @param primitiveOrWrapperType The type to lookup the default value\n+     * @return The boxed default values as defined in Java Language Specification,\n+     *         <code>null</code> if the type is neither a primitive nor a wrapper\n+     */\n+    public static <T> T defaultValueForPrimitiveOrWrapper(Class<T> primitiveOrWrapperType) {\n+        return (T) primitiveOrWrapperDefaultValues.get(primitiveOrWrapperType);\n     }\n \n-    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n-        return (T) primitiveValues.get(primitiveType);\n-    }\n-    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n-    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n-    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n-    private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n \n     static {\n         primitiveTypes.put(Boolean.class, Boolean.TYPE);\n     }\n \n     static {\n-        wrapperReturnValues.put(Boolean.class, Boolean.FALSE);\n-        wrapperReturnValues.put(Character.class, new Character((char) 0));\n-        wrapperReturnValues.put(Byte.class, new Byte((byte) 0));\n-        wrapperReturnValues.put(Short.class, new Short((short) 0));\n-        wrapperReturnValues.put(Integer.class, new Integer(0));\n-        wrapperReturnValues.put(Long.class, new Long(0));\n-        wrapperReturnValues.put(Float.class, new Float(0));\n-        wrapperReturnValues.put(Double.class, new Double(0));\n-    }\n+        primitiveOrWrapperDefaultValues.put(Boolean.class, false);\n+        primitiveOrWrapperDefaultValues.put(Character.class, '\\u0000');\n+        primitiveOrWrapperDefaultValues.put(Byte.class, (byte) 0);\n+        primitiveOrWrapperDefaultValues.put(Short.class, (short) 0);\n+        primitiveOrWrapperDefaultValues.put(Integer.class, 0);\n+        primitiveOrWrapperDefaultValues.put(Long.class, 0L);\n+        primitiveOrWrapperDefaultValues.put(Float.class, 0F);\n+        primitiveOrWrapperDefaultValues.put(Double.class, 0D);\n \n-    static {\n-        primitiveValues.put(boolean.class, false);\n-        primitiveValues.put(char.class, 0);\n-        primitiveValues.put(byte.class, 0);\n-        primitiveValues.put(short.class, 0);\n-        primitiveValues.put(int.class, 0);\n-        primitiveValues.put(long.class, 0);\n-        primitiveValues.put(float.class, 0);\n-        primitiveValues.put(double.class, 0);\n+        primitiveOrWrapperDefaultValues.put(boolean.class, false);\n+        primitiveOrWrapperDefaultValues.put(char.class, '\\u0000');\n+        primitiveOrWrapperDefaultValues.put(byte.class, (byte) 0);\n+        primitiveOrWrapperDefaultValues.put(short.class, (short) 0);\n+        primitiveOrWrapperDefaultValues.put(int.class, 0);\n+        primitiveOrWrapperDefaultValues.put(long.class, 0L);\n+        primitiveOrWrapperDefaultValues.put(float.class, 0F);\n+        primitiveOrWrapperDefaultValues.put(double.class, 0D);\n     }\n }\n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n      * <ul>\n      *     <li>Create a proxy object that implements {@code settings.typeToMock} and potentially also {@code settings.extraInterfaces}.</li>\n      *     <li>You may use the information from {@code settings} to create/configure your proxy object.</li>\n-     *     <li>Your proxy object should carry the {@code hander} with it. For example, if you generate byte code\n+     *     <li>Your proxy object should carry the {@code handler} with it. For example, if you generate byte code\n      *     to create the proxy you could generate an extra field to keep the {@code handler} with the generated object.\n      *     Your implementation of {@code MockMaker} is required to provide this instance of {@code handler} when\n      *     {@link #getHandler(Object)} is called.\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/injection/FieldTypeAndNameComparatorTest.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.junit.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@SuppressWarnings(\"unused\")\n+public class FieldTypeAndNameComparatorTest {\n+\n+    private Object objectA;\n+    private Object objectB;\n+\n+    private Number numberA;\n+    private Number numberB;\n+\n+    private Integer integerA;\n+    private Integer integerB;\n+\n+    @Test\n+    public void when_same_type_the_order_is_based_on_field_name() throws Exception {\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectA\"), field(\"objectB\"))).isEqualTo(-1);\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectB\"), field(\"objectA\"))).isEqualTo(1);\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectB\"), field(\"objectB\"))).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void when_type_is_different_the_supertype_comes_last() throws Exception {\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"numberA\"), field(\"objectB\"))).isEqualTo(-1);\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectB\"), field(\"numberA\"))).isEqualTo(1);\n+    }\n+\n+    @Test\n+    public void using_Collections_dot_sort() throws Exception {\n+        List<Field> unsortedFields = Arrays.asList(\n+                field(\"objectB\"),\n+                field(\"integerB\"),\n+                field(\"numberA\"),\n+                field(\"numberB\"),\n+                field(\"objectA\"),\n+                field(\"integerA\")\n+        );\n+\n+        Collections.sort(unsortedFields, new PropertyAndSetterInjection.FieldTypeAndNameComparator());\n+\n+        assertThat(unsortedFields).containsSequence(\n+                field(\"integerA\"),\n+                field(\"integerB\"),\n+                field(\"numberA\"),\n+                field(\"numberB\"),\n+                field(\"objectA\"),\n+                field(\"objectB\")\n+        );\n+    }\n+\n+\n+    @Test\n+    public void issue_352_order_was_different_between_JDK6_and_JDK7() throws Exception {\n+        List<Field> unsortedFields = Arrays.asList(\n+                field(\"objectB\"),\n+                field(\"objectA\")\n+        );\n+\n+        Collections.sort(unsortedFields, new PropertyAndSetterInjection.FieldTypeAndNameComparator());\n+\n+        assertThat(unsortedFields).containsSequence(\n+                field(\"objectA\"),\n+                field(\"objectB\")\n+        );\n+    }\n+\n+    private Field field(String field) throws NoSuchFieldException {\n+        return getClass().getDeclaredField(field);\n+    }\n+}\n--- a/test/org/mockito/internal/progress/HandyReturnValuesTest.java\n+++ b/test/org/mockito/internal/progress/HandyReturnValuesTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n import org.junit.Test;\n-import org.mockitoutil.TestBase;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n \n \n-public class HandyReturnValuesTest extends TestBase {\n+public class HandyReturnValuesTest {\n \n     private HandyReturnValues h = new HandyReturnValues();\n \n     @Test\n-    public void shouldNotReturnNullForPrimitivesWprappers() throws Exception {\n+    public void should_not_return_null_for_primitives_wrappers() throws Exception {\n         assertNotNull(h.returnFor(Boolean.class));\n         assertNotNull(h.returnFor(Character.class));\n         assertNotNull(h.returnFor(Byte.class));\n         assertNotNull(h.returnFor(Integer.class));\n         assertNotNull(h.returnFor(Long.class));\n         assertNotNull(h.returnFor(Float.class));\n-        assertNotNull(h.returnFor(Double.class));        \n+        assertNotNull(h.returnFor(Double.class));\n     }\n \n     @Test\n-    public void shouldNotReturnNullForPrimitives() throws Exception {\n+    public void should_not_return_null_for_primitives() throws Exception {\n         assertNotNull(h.returnFor(boolean.class));\n         assertNotNull(h.returnFor(char.class));\n         assertNotNull(h.returnFor(byte.class));\n         assertNotNull(h.returnFor(double.class));\n     }\n \n+    @Test public void should_default_values_for_primitive() {\n+        assertThat(h.returnFor(boolean.class)).isFalse();\n+        assertThat(h.returnFor(char.class)).isEqualTo('\\u0000');\n+        assertThat(h.returnFor(byte.class)).isEqualTo((byte) 0);\n+        assertThat(h.returnFor(short.class)).isEqualTo((short) 0);\n+        assertThat(h.returnFor(int.class)).isEqualTo(0);\n+        assertThat(h.returnFor(long.class)).isEqualTo(0L);\n+        assertThat(h.returnFor(float.class)).isEqualTo(0.0F);\n+        assertThat(h.returnFor(double.class)).isEqualTo(0.0D);\n+    }\n+\n     @Test\n-    public void shouldReturnNullForEverythingElse() throws Exception {\n+    public void should_return_null_for_everything_else() throws Exception {\n         assertNull(h.returnFor(Object.class));\n         assertNull(h.returnFor(String.class));\n         assertNull(h.returnFor(null));\n     }\n \n     @Test\n-    public void shouldReturnHandyValueForInstances() throws Exception {\n+    public void should_return_handy_value_for_instances() throws Exception {\n         assertNull(h.returnFor(new Object()));\n         assertNull(h.returnFor((Object) null));\n         \n--- a/test/org/mockito/internal/stubbing/defaultanswers/HasPrimitiveMethods.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/HasPrimitiveMethods.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n+@SuppressWarnings(\"unused\")\n interface HasPrimitiveMethods {\n     boolean booleanMethod();\n     char charMethod();\n+    byte byteMethod();\n+    short shortMethod();\n     int intMethod();\n     long longMethod();\n     float floatMethod();\n     double doubleMethod();\n-}\n+}\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n \n package org.mockito.internal.stubbing.defaultanswers;\n \n-import java.util.*;\n-\n import org.junit.Test;\n import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n \n import static org.mockito.Mockito.mock;\n \n \n     ReturnsEmptyValues values = new ReturnsEmptyValues();\n \n-    @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n+    @Test public void should_return_empty_collections_or_null_for_non_collections() {\n         assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty());\n \n         assertTrue(((Set) values.returnValueFor(Set.class)).isEmpty());\n         assertNull(values.returnValueFor(String.class));\n     }\n \n-    @Test public void shouldReturnPrimitive() {\n+    @Test public void should_return_primitive() {\n         assertEquals(false, values.returnValueFor(Boolean.TYPE));\n         assertEquals((char) 0, values.returnValueFor(Character.TYPE));\n-        assertEquals(0, values.returnValueFor(Byte.TYPE));\n-        assertEquals(0, values.returnValueFor(Short.TYPE));\n+        assertEquals((byte) 0, values.returnValueFor(Byte.TYPE));\n+        assertEquals((short) 0, values.returnValueFor(Short.TYPE));\n         assertEquals(0, values.returnValueFor(Integer.TYPE));\n-        assertEquals(0, values.returnValueFor(Long.TYPE));\n-        assertEquals(0, values.returnValueFor(Float.TYPE));\n-        assertEquals(0, values.returnValueFor(Double.TYPE));\n+        assertEquals(0L, values.returnValueFor(Long.TYPE));\n+        assertEquals(0F, values.returnValueFor(Float.TYPE));\n+        assertEquals(0D, values.returnValueFor(Double.TYPE));\n     }\n \n-    @Test public void shouldReturnNonZeroForCompareToMethod() {\n+    @Test public void should_return_non_zero_for_compareTo_method() {\n         //given\n         Date d = mock(Date.class);\n         d.compareTo(new Date());\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.junit.Test;\n \n     @Test\n     //TODO split into separate\n-    public void shouldReturnMockValueForInterface() throws Exception {\n+    public void should_return_mock_value_for_interface() throws Exception {\n         Object interfaceMock = values.returnValueFor(FooInterface.class);\n         assertTrue(new MockUtil().isMock(interfaceMock));\n     }\n \n-    public void shouldReturnMockValueForClass() throws Exception {\n+    @Test\n+    public void should_return_mock_value_for_class() throws Exception {\n         Object classMock = values.returnValueFor(BarClass.class);\n         assertTrue(new MockUtil().isMock(classMock));\n     }\n \n     @Test\n-    public void shouldReturnNullForFinalClass() throws Exception {\n+    public void should_return_null_for_final_class() throws Exception {\n         assertNull(values.returnValueFor(Baz.class));\n     }\n \n     @Test\n-    public void shouldReturnTheUsualDefaultValuesForPrimitives()\n-            throws Throwable {\n+    public void should_return_the_usual_default_values_for_primitives() throws Throwable {\n         ReturnsMocks answer = new ReturnsMocks();\n         assertEquals(false, answer.answer(invocationOf(HasPrimitiveMethods.class, \"booleanMethod\")));\n         assertEquals((char) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"charMethod\")));\n+        assertEquals((byte) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"byteMethod\")));\n+        assertEquals((short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"shortMethod\")));\n         assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"intMethod\")));\n-        assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"longMethod\")));\n-        assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"floatMethod\")));\n-        assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"doubleMethod\")));\n+        assertEquals(0L, answer.answer(invocationOf(HasPrimitiveMethods.class, \"longMethod\")));\n+        assertEquals(0f, answer.answer(invocationOf(HasPrimitiveMethods.class, \"floatMethod\")));\n+        assertEquals(0d, answer.answer(invocationOf(HasPrimitiveMethods.class, \"doubleMethod\")));\n     }\n-    \n+\n+    @SuppressWarnings(\"unused\")\n     interface StringMethods {\n         String stringMethod();\n         String[] stringArrayMethod();\n     }\n     \n     @Test\n-    public void shouldReturnEmptyArray() throws Throwable {\n+    public void should_return_empty_array() throws Throwable {\n         String[] ret = (String[]) values.answer(invocationOf(StringMethods.class, \"stringArrayMethod\"));\n         \n         assertTrue(ret.getClass().isArray());\n     }\n     \n     @Test\n-    public void shouldReturnEmptyString() throws Throwable {\n+    public void should_return_empty_string() throws Throwable {\n         assertEquals(\"\", values.answer(invocationOf(StringMethods.class, \"stringMethod\")));\n     }\n-}\n+}\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.junit.Test;\n public class ReturnsSmartNullsTest extends TestBase {\n \n     @Test\n-    public void shouldReturnTheUsualDefaultValuesForPrimitives() throws Throwable {\n+    public void should_return_the_usual_default_values_for_primitives() throws Throwable {\n         Answer<Object> answer = new ReturnsSmartNulls();\n         assertEquals(false  ,   answer.answer(invocationOf(HasPrimitiveMethods.class, \"booleanMethod\")));\n         assertEquals((char) 0,  answer.answer(invocationOf(HasPrimitiveMethods.class, \"charMethod\")));\n+        assertEquals((byte) 0,  answer.answer(invocationOf(HasPrimitiveMethods.class, \"byteMethod\")));\n+        assertEquals((short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, \"shortMethod\")));\n         assertEquals(0,         answer.answer(invocationOf(HasPrimitiveMethods.class, \"intMethod\")));\n-        assertEquals(0,         answer.answer(invocationOf(HasPrimitiveMethods.class, \"longMethod\")));\n-        assertEquals(0,         answer.answer(invocationOf(HasPrimitiveMethods.class, \"floatMethod\")));\n-        assertEquals(0,         answer.answer(invocationOf(HasPrimitiveMethods.class, \"doubleMethod\")));\n+        assertEquals(0L,        answer.answer(invocationOf(HasPrimitiveMethods.class, \"longMethod\")));\n+        assertEquals(0f,        answer.answer(invocationOf(HasPrimitiveMethods.class, \"floatMethod\")));\n+        assertEquals(0d,        answer.answer(invocationOf(HasPrimitiveMethods.class, \"doubleMethod\")));\n     }\n \n+    @SuppressWarnings(\"unused\")\n     interface Foo {\n         Foo get();\n         Foo withArgs(String oneArg, String otherArg);\n     }\n \n     @Test\n-    public void shouldReturnAnObjectThatFailsOnAnyMethodInvocationForNonPrimitives() throws Throwable {\n+    public void should_return_an_object_that_fails_on_any_method_invocation_for_non_primitives() throws Throwable {\n         Answer<Object> answer = new ReturnsSmartNulls();\n \n         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"get\"));\n     }\n \n     @Test\n-    public void shouldReturnAnObjectThatAllowsObjectMethods() throws Throwable {\n+    public void should_return_an_object_that_allows_object_methods() throws Throwable {\n         Answer<Object> answer = new ReturnsSmartNulls();\n \n         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"get\"));\n     }\n \n     @Test\n-    public void shouldPrintTheParametersWhenCallingAMethodWithArgs() throws Throwable {\n+    public void should_print_the_parameters_when_calling_a_method_with_args() throws Throwable {\n     \tAnswer<Object> answer = new ReturnsSmartNulls();\n \n     \tFoo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n     }\n \n     @Test\n-\tpublic void shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable {\n+\tpublic void should_print_the_parameters_on_SmartNullPointerException_message() throws Throwable {\n     \tAnswer<Object> answer = new ReturnsSmartNulls();\n \n         Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/EqualsWithDeltaTest.java\n+package org.mockitousage.bugs;\n+\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+import org.mockito.internal.matchers.EqualsWithDelta;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class EqualsWithDeltaTest {\n+\n+\t@Test\n+\tpublic void testEqualsWithDelta_NullExpected() throws Exception {\n+\t\tMatcher<Number> matcher = equalsWithDelta(null);\n+\t\tassertThat(matcher.matches(1.0)).isFalse();\n+\t}\n+\n+\t@Test\n+\tpublic void testEqualsWithDelta_NullActual() throws Exception {\n+\t\tMatcher<Number> matcher = equalsWithDelta(1.0);\n+\t\tassertThat(matcher.matches(null)).isFalse();\n+\t}\n+\n+    @Test\n+    public void testEqualsWithDelta_NullActualAndExpected() throws Exception {\n+        Matcher<Number> matcher = equalsWithDelta(null);\n+        assertThat(matcher.matches(null)).isTrue();\n+    }\n+\n+\tpublic Matcher<Number> equalsWithDelta(final Double expected) {\n+\t\treturn new EqualsWithDelta(expected, .000001);\n+\t}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/Issue353InjectionMightNotHappenInCertainConfigurationTest.java\n+package org.mockitousage.bugs;\n+\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.assertSame;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class Issue353InjectionMightNotHappenInCertainConfigurationTest {\n+    @Mock Map<String, String> stringString_that_matches_field;\n+    @Mock Map<String, Integer> mockStringInteger_was_not_injected;\n+    @InjectMocks FooService fooService;\n+\n+    @Test\n+    public void when_identical_types_and_the_correct_mock_name_is_greater_than_the_non_matching_name_then_injection_occurs_only_on_the_named_one() {\n+        assertThat(\"stringString_that_matches_field\".compareTo(\"mockStringInteger_was_not_injected\")).isGreaterThanOrEqualTo(1);\n+\n+        assertSame(stringString_that_matches_field, fooService.stringString_that_matches_field);\n+        assertSame(mockStringInteger_was_not_injected, fooService.stringInteger_field);\n+    }\n+\n+    public static class FooService {\n+        Map<String, Integer> stringInteger_field = new HashMap<String, Integer>();\n+        Map<String, String> stringString_that_matches_field = new HashMap<String, String>();\n+    }\n+\n+}\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n \n package org.mockito;\n \n-import org.hamcrest.*;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n import org.mockito.internal.util.Decamelizer;\n \n /**\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.configuration.injection.filter.*;\n+import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n--- a/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n \n package org.mockito.internal.matchers;\n \n-import java.io.Serializable;\n-\n import org.hamcrest.Description;\n import org.mockito.ArgumentMatcher;\n+\n+import java.io.Serializable;\n \n \n public class EqualsWithDelta extends ArgumentMatcher<Number> implements Serializable {\n--- a/src/org/mockito/internal/progress/HandyReturnValues.java\n+++ b/src/org/mockito/internal/progress/HandyReturnValues.java\n  */\n package org.mockito.internal.progress;\n \n-import static org.mockito.internal.util.Primitives.*;\n+import java.util.*;\n \n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import static org.mockito.internal.util.Primitives.defaultValueForPrimitiveOrWrapper;\n+import static org.mockito.internal.util.Primitives.isPrimitiveOrWrapper;\n \n @SuppressWarnings(\"unchecked\")\n public class HandyReturnValues {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n  */\n \n package org.mockito.internal.stubbing.defaultanswers;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.SortedMap;\n-import java.util.SortedSet;\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n \n import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.mock.MockName;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.*;\n \n /**\n  * Default answer of every Mockito mock.\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n \n package org.mockito.internal.stubbing.defaultanswers;\n \n-import java.util.*;\n-\n import org.junit.Test;\n import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n \n import static org.mockito.Mockito.mock;\n \n--- a/test/org/mockitousage/bugs/Issue353InjectionMightNotHappenInCertainConfigurationTest.java\n+++ b/test/org/mockitousage/bugs/Issue353InjectionMightNotHappenInCertainConfigurationTest.java\n import org.mockito.Mock;\n import org.mockito.runners.MockitoJUnitRunner;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+\n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.assertSame;\n-\n-import java.util.*;\n \n @RunWith(MockitoJUnitRunner.class)\n public class Issue353InjectionMightNotHappenInCertainConfigurationTest {", "timestamp": 1343915938, "metainfo": ""}