{"sha": "078216699ba90f9582bd3133d6dbfca96763a63d", "log": "started coding on warnings when stubs not used or misused  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401115", "commit": "\n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n     public boolean isLastStackElementToRemove(StackTraceElement e) {\n         boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n         boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n-        return fromMockObject || fromOrgMockito;\n+        boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n+        return fromMockObject || fromOrgMockito && !isRunner;\n     }\n \n     public void filterStackTrace(HasStackTrace hasStackTrace) {\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n \n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n+        if (!invocation.isVoid() && answer == null) {\n+            //it is a return-value interaction but not stubbed. This *might* be a problem\n+            mockingProgress.getDebuggingHelper().addUnstubbedInvocation(invocation);\n+        }\n+            \n         if (answer != null) {\n             return answer.answer(invocation);\n         } else if (MockUtil.isMock(instance)) {\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n import java.util.List;\n \n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.MockitoLogger;\n \n public class DebuggingInfo {\n \n     private final List<Invocation> unusedStubs = new LinkedList<Invocation>();\n+    private List<Invocation> unstubbedInvocations = new LinkedList<Invocation>();\n     private final String testName;\n \n     public DebuggingInfo(String testName) {\n         this.unusedStubs.add(invocation);\n     }\n \n-    public void printInfo() {\n+    public void printInfo(MockitoLogger logger) {\n         if (!shouldPrint()) {\n             return;\n         }\n //        print(test);\n         \n         for (Invocation i : unusedStubs) {\n-            print(\"Warning - unused stub detected:\");\n-            print(i.getStackTrace().getStackTrace()[0]);\n+            logger.print(\"Warning - unused stub detected here:\");\n+            logger.print(i.getStackTrace().getStackTrace()[0]);\n+        }\n+        \n+        for (Invocation i : unstubbedInvocations) {\n+            logger.print(\"Warning - unstubbed method invoked here:\");\n+            logger.print(i.getStackTrace().getStackTrace()[0]);\n         }\n     }\n \n-    private void print(Object text) {\n-        System.out.println(\"[Mockito] \" + text.toString());\n+    private boolean shouldPrint() {\n+        //TODO test, include unstubbedInvocations...\n+        return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n     }\n \n-    private boolean shouldPrint() {\n-        return !unusedStubs.isEmpty();\n+    public void addUnstubbedInvocation(Invocation invocation) {\n+        unstubbedInvocations.add(invocation);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/DebuggingHelper.java\n+package org.mockito.internal.progress;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+\n+//hate the name but I couldn't figure out the better way of doing it\n+public class DebuggingHelper {\n+\n+    private final List<Invocation> stubbedInvocations = new LinkedList<Invocation>();\n+    private final List<Invocation> unstubbedInvocations = new LinkedList<Invocation>();\n+\n+    public void addStubbedInvocation(Invocation invocation) {\n+        unstubbedInvocations.remove(invocation);\n+        stubbedInvocations.add(invocation);\n+    }\n+\n+    public void addUnstubbedInvocation(Invocation invocation) {\n+        unstubbedInvocations.add(invocation);\n+    }\n+\n+    public List<Invocation> pullStubbedInvocations() {\n+        List<Invocation> ret = new LinkedList<Invocation>(stubbedInvocations);\n+        stubbedInvocations.clear();\n+        return ret;\n+    }\n+\n+    public List<Invocation> pullUnstubbedInvocations() {\n+        List<Invocation> ret = new LinkedList<Invocation>(unstubbedInvocations);\n+        unstubbedInvocations.clear();\n+        return ret;\n+    }\n+\n+    public void collectData() {\n+        // TODO Auto-generated method stub\n+        \n+    }\n+\n+    public void clearData() {\n+        // TODO Auto-generated method stub\n+        \n+    }\n+}\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.progress;\n-\n-import java.util.List;\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n      */\n     void resetOngoingStubbing();\n \n-    List<Invocation> pullStubbedInvocations();\n+    ArgumentMatcherStorage getArgumentMatcherStorage();\n \n-    ArgumentMatcherStorage getArgumentMatcherStorage();\n+    DebuggingHelper getDebuggingHelper();\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n     private final Reporter reporter = new Reporter();\n     private final ArgumentMatcherStorage argumentMatcherStorage = new ArgumentMatcherStorageImpl();\n     \n+    private final DebuggingHelper debuggingHelper = new DebuggingHelper();\n+\n     OngoingStubbing ongoingStubbing;\n     private VerificationMode verificationMode;\n     private boolean stubbingInProgress = false;\n-\n-    private List<Invocation> stubbedInvocations = new LinkedList<Invocation>();\n \n     public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n         this.ongoingStubbing = ongoingStubbing;\n     }\n \n     public void stubbingCompleted(Invocation invocation) {\n-        stubbedInvocations.add(invocation);        \n+        debuggingHelper.addStubbedInvocation(invocation);        \n         stubbingInProgress = false;\n     }\n     \n         getArgumentMatcherStorage().reset();\n     }\n \n-    public List<Invocation> pullStubbedInvocations() {\n-        List<Invocation> ret = new LinkedList<Invocation>(stubbedInvocations);\n-        stubbedInvocations.clear();\n-        return ret;\n-    }\n-\n     public ArgumentMatcherStorage getArgumentMatcherStorage() {\n         return argumentMatcherStorage;\n     }\n+\n+    public DebuggingHelper getDebuggingHelper() {\n+        return debuggingHelper;\n+    }\n }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.progress;\n-\n-import java.util.List;\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n         threadSafely().resetOngoingStubbing();\n     }\n \n-    public List<Invocation> pullStubbedInvocations() {\n-        return threadSafely().pullStubbedInvocations();\n-    }\n-\n     public ArgumentMatcherStorage getArgumentMatcherStorage() {\n         return threadSafely().getArgumentMatcherStorage();\n     }\n+\n+    public DebuggingHelper getDebuggingHelper() {\n+        return threadSafely().getDebuggingHelper();\n+    }\n }\n--- a/src/org/mockito/internal/returnvalues/SmartNullReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/SmartNullReturnValues.java\n     private final ReturnValues delegate = new DefaultReturnValues();\n \n     public Object valueFor(InvocationOnMock invocation) {\n+        //TODO add more NullObjects\n         Object defaultReturnValue = delegate.valueFor(invocation);\n         if (defaultReturnValue != null) {\n             return defaultReturnValue;\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockitoLogger.java\n+package org.mockito.internal.util;\n+\n+public interface MockitoLogger {\n+\n+    void print(Object what);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockitoLoggerImpl.java\n+package org.mockito.internal.util;\n+\n+public class MockitoLoggerImpl implements MockitoLogger {\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n+     */\n+    public void print(Object what) {\n+        System.out.println(\"[Mockito] \" + what.toString());\n+    }\n+}\n--- a/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n import org.mockito.MockitoAnnotations;\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.progress.DebuggingHelper;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n \n /**\n  * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n  */\n public class ExperimentalMockitoJUnitRunner extends BlockJUnit4ClassRunner {\n \n+    MockitoLogger logger; \n+    \n     public ExperimentalMockitoJUnitRunner(Class<?> klass) throws InitializationError {\n         super(klass);\n+        logger = new MockitoLoggerImpl();\n     }\n \n     @Override\n     \n     class MockitoListener extends RunListener {\n         \n-        private MockingProgress progress;\n+        private final DebuggingHelper debuggingHelper;\n \n-        public MockitoListener(MockingProgress progress) {\n-            super();\n-            this.progress = progress;\n+        public MockitoListener(DebuggingHelper debuggingHelper) {\n+            this.debuggingHelper = debuggingHelper;\n         }\n \n         @Override\n         public void testFailure(Failure failure) throws Exception {\n+            //TODO DebuggingInfo should be produced by DebuggingHelper\n             DebuggingInfo debuggingInfo = new DebuggingInfo(failure.getTestHeader());\n-            List<Invocation> stubbedInvocations = progress.pullStubbedInvocations();\n+            \n+            List<Invocation> stubbedInvocations = debuggingHelper.pullStubbedInvocations();\n             for (Invocation invocation : stubbedInvocations) {\n                 if (!invocation.isVerified()) {\n                     //TODO this requires some refactoring, it's just a dummy implementation\n                     break;\n                 }\n             }\n-            debuggingInfo.printInfo();\n+            \n+            List<Invocation> unstubbedInvocations = debuggingHelper.pullUnstubbedInvocations();\n+            for (Invocation invocation : unstubbedInvocations) {\n+                debuggingInfo.addUnstubbedInvocation(invocation);\n+            }\n+            \n+            debuggingInfo.printInfo(logger);\n             super.testFailure(failure);\n         }\n     }\n     @Override\n     public void run(RunNotifier notifier) {\n         MockingProgress progress = new ThreadSafeMockingProgress();\n-        MockitoListener listener = new MockitoListener(progress);\n+        DebuggingHelper debuggingHelper = progress.getDebuggingHelper();\n+        debuggingHelper.collectData();\n+        \n+        MockitoListener listener = new MockitoListener(debuggingHelper);\n         notifier.addListener(listener);\n         super.run(notifier);\n-        //TODO pull should be done by the listener\n-        progress.pullStubbedInvocations();\n+        \n+        debuggingHelper.clearData();\n     }\n-}\n+}\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n  */\n package org.mockitousage;\n \n-import static org.mockito.Mockito.*;\n-\n-import org.junit.Ignore;\n import org.junit.Test;\n-import org.junit.runner.RunWith;\n import org.mockito.Mock;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n-@RunWith(ExperimentalMockitoJUnitRunner.class)\n public class PlaygroundTest extends TestBase {\n \n-    public class SomeController {\n-\n-        private final ReadFromSomeFileSystem reader;\n-\n-        public SomeController(ReadFromSomeFileSystem reader, Object object) {\n-            this.reader = reader;\n-        }\n-\n-        public byte[] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue(String filename) {\n-            return this.reader.readFromFile(\"filename\");\n-        }\n-    }\n-\n-    public interface ReadFromSomeFileSystem {\n-\n-        byte[] readFromFile(String filename);\n-\n-    }\n-\n-    @Mock\n-    IMethods mock;\n+    @Mock IMethods mock;\n \n     @Test\n-    public void testSomething() {\n-    }\n-\n-    @Ignore\n-    @Test\n-    public void shouldFailButOnlyWhenIAssertReturnValueAndIWantToKnowWhy() throws Throwable {\n-        ReadFromSomeFileSystem reader = mock(ReadFromSomeFileSystem.class);\n-\n-        SomeController controller = new SomeController(reader, null);\n-\n-        final String filename = \"/some/non/random/path\";\n-        final String message = \"this is my message to you\";\n-        when(reader.readFromFile(filename)).thenReturn(message.getBytes(\"UTF8\"));\n-\n-        byte[] bytes = controller.naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue(filename);\n-\n-//        try {\n-        assertNotNull(\"Should have returned some bytes, i am HUNGRY!\", bytes);\n-//        } catch (Error ex) {\n-//            verify(reader).readFromFile(filename);\n-//            // i want to replace this bit with something like \"verifyAllTheThingsIStubbed(mock)\"\n-//            throw ex;\n-//        }\n-    }\n+    public void testSomething() {}\n }\n--- a/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n             doReturn(\"foo\").when(mock).voidMethod();\n             fail();\n         } catch (MockitoException e) {\n-            //TODO could the message be clearer?\n             assertThat(e.getMessage(), contains(\"Cannot stub a void method with a return value\"));\n         }\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/warnings/WarningAboutStubsNotUsedTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.warnings;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+@RunWith(ExperimentalMockitoJUnitRunner.class)\n+public class WarningAboutStubsNotUsedTest extends TestBase {\n+\n+    public class SomeController {\n+\n+        private final ReadFromSomeFileSystem reader;\n+\n+        public SomeController(ReadFromSomeFileSystem reader, Object object) {\n+            this.reader = reader;\n+        }\n+\n+        public byte[] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue(String filename) {\n+            return this.reader.readFromFile(\"filename\");\n+        }\n+    }\n+\n+    public interface ReadFromSomeFileSystem {\n+\n+        byte[] readFromFile(String filename);\n+\n+    }\n+\n+    @Mock\n+    IMethods mock;\n+\n+    @Ignore\n+    @Test\n+    public void shouldFailButOnlyWhenIAssertReturnValueAndIWantToKnowWhy() throws Throwable {\n+        ReadFromSomeFileSystem reader = mock(ReadFromSomeFileSystem.class);\n+\n+        SomeController controller = new SomeController(reader, null);\n+\n+        final String filename = \"/some/non/random/path\";\n+        final String message = \"this is my message to you\";\n+        when(reader.readFromFile(filename)).thenReturn(message.getBytes(\"UTF8\"));\n+\n+        byte[] bytes = controller.naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue(filename);\n+\n+//        try {\n+        assertNotNull(\"Should have returned some bytes, i am HUNGRY!\", bytes);\n+//        } catch (Error ex) {\n+//            verify(reader).readFromFile(filename);\n+//            // i want to replace this bit with something like \"verifyAllTheThingsIStubbed(mock)\"\n+//            throw ex;\n+//        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/warnings/WarningAboutUnstubbedMethodsInvokedTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.warnings;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+@RunWith(ExperimentalMockitoJUnitRunner.class)\n+public class WarningAboutUnstubbedMethodsInvokedTest extends TestBase {\n+\n+    public class SomeController {\n+\n+        private final IMethods methods;\n+\n+        public SomeController(IMethods methods) {\n+            this.methods = methods;\n+        }\n+\n+        public void control(String what) {\n+            String value = methods.simpleMethod(what);\n+            if (!\"foo\".equals(value)) {\n+                throw new IllegalArgumentException(\"I control only foo\");\n+            }\n+        }\n+    }\n+\n+    @Mock IMethods mock;\n+\n+    @Ignore\n+    @Test\n+    public void shouldFailButPrintAWarning() throws Throwable {\n+        SomeController controller = new SomeController(mock);\n+        controller.control(\"foo\");\n+    }\n+}", "timestamp": 1230505027, "metainfo": ""}