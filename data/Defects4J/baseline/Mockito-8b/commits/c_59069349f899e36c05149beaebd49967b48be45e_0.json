{"sha": "59069349f899e36c05149beaebd49967b48be45e", "log": "name refactoring  --HG-- rename : src/org/mockito/internal/state/MockitoState.java => src/org/mockito/internal/state/MockingProgress.java rename : src/org/mockito/internal/state/MockitoStateImpl.java => src/org/mockito/internal/state/MockingProgressImpl.java rename : src/org/mockito/internal/state/ThreadSafeMockitoState.java => src/org/mockito/internal/state/ThreadSafeMockingProgress.java rename : test/org/mockito/internal/state/MockitoStateImplTest.java => test/org/mockito/internal/state/MockingProgressImplTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40164", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n-    static MockitoState mockitoState = new ThreadSafeMockitoState();\n+    static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n     public static OngoingVerifyingMode atLeastOnce() {\n         return OngoingVerifyingMode.atLeastOnce();\n     \n     public static <T> T mock(Class<T> classToMock) {\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n-        MockControl<T> mockControl = new MockControl<T>(mockitoState, new MatchersBinder());\n+        MockControl<T> mockControl = new MockControl<T>(mockingProgress, new MatchersBinder());\n         return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n                 classToMock, mockControl));\n     }\n \n     public static <T> OngoingStubbing<T> stub(T methodCallToStub) {\n-        mockitoState.stubbingStarted();\n+        mockingProgress.stubbingStarted();\n         \n-        OngoingStubbing controlToStub = mockitoState.pullStubable();\n+        OngoingStubbing controlToStub = mockingProgress.pullStubable();\n         if (controlToStub == null) {\n             Exceptions.missingMethodInvocation();\n         }\n     \n     public static <T> T verify(T mock, OngoingVerifyingMode mode) {\n         MockUtil.validateMock(mock);\n-        mockitoState.verifyingStarted(mode);\n+        mockingProgress.verifyingStarted(mode);\n         return mock;\n     }\n \n \t */\n \tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n \t    assertMocksNotEmpty(mocks);\n-\t    mockitoState.validateState();\n+\t    mockingProgress.validateState();\n \t    for (Object mock : mocks) {\n             MockUtil.getControl(mock).verifyNoMoreInteractions();\n         }\n \n     public static void verifyZeroInteractions(Object ... mocks) {\n         assertMocksNotEmpty(mocks);\n-        mockitoState.validateState();\n+        mockingProgress.validateState();\n         for (Object mock : mocks) {\n             MockUtil.getControl(mock).verifyZeroInteractions();\n         }\n     \n     public static <T> VoidMethodStubable<T> stubVoid(T mock) {\n         MockControl<T> control = MockUtil.getControl(mock);\n-        mockitoState.stubbingStarted();\n+        mockingProgress.stubbingStarted();\n         return control;\n     }\n \n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.state.MockitoState;\n+import org.mockito.internal.state.MockingProgress;\n import org.mockito.internal.state.OngoingStubbing;\n import org.mockito.internal.state.OngoingVerifyingMode;\n import org.mockito.internal.stubbing.EmptyReturnValues;\n     private final VerifyingRecorder<T> verifyingRecorder;\n     private final Stubber stubber;\n     private final MatchersBinder matchersBinder;\n-    private final MockitoState mockitoState;\n+    private final MockingProgress mockingProgress;\n     \n     private T mock;\n     \n-    public MockControl(MockitoState mockitoState, MatchersBinder matchersBinder) {\n-        this.mockitoState = mockitoState;\n+    public MockControl(MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n+        this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n-        stubber = new Stubber(mockitoState);\n+        stubber = new Stubber(mockingProgress);\n         verifyingRecorder = new VerifyingRecorder<T>(new AllInvocationsFinder());\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         if (stubber.hasThrowableForVoidMethod()) {\n-            Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n+            Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n             stubber.addVoidMethodForThrowable(invocationMatcher);\n             return null;\n         }\n         \n-        OngoingVerifyingMode ongoingVerifyingMode = mockitoState.pullVerifyingMode();\n-        mockitoState.validateState();\n+        OngoingVerifyingMode ongoingVerifyingMode = mockingProgress.pullVerifyingMode();\n+        mockingProgress.validateState();\n         \n-        Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n+        Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n         \n         if (ongoingVerifyingMode != null) {\n         stubber.setInvocationForPotentialStubbing(invocationMatcher);\n         verifyingRecorder.recordInvocation(invocationMatcher);\n \n-        mockitoState.reportStubable(this);\n+        mockingProgress.reportStubable(this);\n         \n         return stubber.resultFor(invocationMatcher.getInvocation());\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/state/MockingProgress.java\n+package org.mockito.internal.state;\n+\n+\n+\n+//TODO name should be something like that: MockingState\n+//TODO verificationMode instead verifying\n+@SuppressWarnings(\"unchecked\")\n+public interface MockingProgress {\n+\n+    void reportStubable(OngoingStubbing ongoingStubbing);\n+\n+    OngoingStubbing pullStubable();\n+\n+    void verifyingStarted(OngoingVerifyingMode verifyingMode);\n+\n+    OngoingVerifyingMode pullVerifyingMode();\n+\n+    void stubbingStarted();\n+\n+    void stubbingCompleted();\n+    \n+    int nextSequenceNumber();\n+\n+    void validateState();\n+\n+    void reset();\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/MockingProgressImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import org.mockito.exceptions.Exceptions;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockingProgressImpl implements MockingProgress {\n+    \n+    private OngoingStubbing ongoingStubbing;\n+    private OngoingVerifyingMode ongoingVerifyingMode;\n+    private int invocationSequenceNumber = 1;\n+    private boolean stubbingInProgress = false;\n+\n+    public void reportStubable(OngoingStubbing ongoingStubbing) {\n+        this.ongoingStubbing = ongoingStubbing;\n+    }\n+\n+    public OngoingStubbing pullStubable() {\n+        OngoingStubbing temp = ongoingStubbing;\n+        ongoingStubbing = null;\n+        return temp;\n+    }\n+    \n+    public void verifyingStarted(OngoingVerifyingMode verify) {\n+        validateState();\n+        ongoingVerifyingMode = verify;\n+    }\n+\n+    public OngoingVerifyingMode pullVerifyingMode() {\n+        OngoingVerifyingMode temp = ongoingVerifyingMode;\n+        ongoingVerifyingMode = null;\n+        return temp;\n+    }\n+\n+    public int nextSequenceNumber() {\n+        return invocationSequenceNumber++;\n+    }\n+\n+    public void stubbingStarted() {\n+        validateState();\n+        stubbingInProgress = true;\n+    }\n+\n+    public void validateState() {\n+        if (ongoingVerifyingMode != null) {\n+            ongoingVerifyingMode = null;\n+            Exceptions.unfinishedVerificationException();\n+        }\n+        \n+        if (stubbingInProgress) {\n+            stubbingInProgress = false;\n+            Exceptions.unfinishedStubbing();\n+        }\n+    }\n+\n+    public void stubbingCompleted() {\n+        stubbingInProgress = false;\n+    }\n+    \n+    public String toString() {\n+        return  \"ongoingStubbing: \" + ongoingStubbing + \n+        \", ongoingVerifyingMode: \" + ongoingVerifyingMode +\n+        \", invocationSequenceNumber: \" + invocationSequenceNumber +\n+        \", stubbingInProgress: \" + stubbingInProgress;\n+    }\n+\n+    public void reset() {\n+        stubbingInProgress = false;\n+        ongoingVerifyingMode = null;\n+        invocationSequenceNumber = 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/ThreadSafeMockingProgress.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ThreadSafeMockingProgress implements MockingProgress {\n+    \n+    private static ThreadLocal<MockingProgress> mockingProgress = new ThreadLocal<MockingProgress>();\n+\n+    static MockingProgress threadSafely() {\n+        if (mockingProgress.get() == null) {\n+            mockingProgress.set(new MockingProgressImpl());\n+        }\n+        return mockingProgress.get();\n+    }\n+    \n+    public void reportStubable(OngoingStubbing ongoingStubbing) {\n+        threadSafely().reportStubable(ongoingStubbing);\n+    }\n+\n+    public OngoingStubbing pullStubable() {\n+        return threadSafely().pullStubable();\n+    }\n+    \n+    public void verifyingStarted(OngoingVerifyingMode verify) {\n+        threadSafely().verifyingStarted(verify);\n+    }\n+\n+    public OngoingVerifyingMode pullVerifyingMode() {\n+        return threadSafely().pullVerifyingMode();\n+    }\n+\n+    public int nextSequenceNumber() {\n+        return threadSafely().nextSequenceNumber();\n+    }\n+\n+    public void stubbingStarted() {\n+        threadSafely().stubbingStarted();\n+    }\n+\n+    public void validateState() {\n+        threadSafely().validateState();\n+    }\n+\n+    public void stubbingCompleted() {\n+        threadSafely().stubbingCompleted();\n+    }\n+    \n+    public String toString() {\n+        return threadSafely().toString();\n+    }\n+\n+    public void reset() {\n+        threadSafely().reset();\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n import org.mockito.exceptions.Exceptions;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.MockitoState;\n+import org.mockito.internal.state.MockingProgress;\n \n public class Stubber {\n \n     private InvocationMatcher invocationForStubbing;\n     private LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private Throwable throwableForVoidMethod;\n-    private final MockitoState mockitoState;\n+    private final MockingProgress mockingProgress;\n     \n-    public Stubber(MockitoState mockitoState) {\n-        this.mockitoState = mockitoState;\n+    public Stubber(MockingProgress mockingProgress) {\n+        this.mockingProgress = mockingProgress;\n     }\n \n     public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n     }\n     \n     public void addReturnValue(Object value) {\n-        mockitoState.stubbingCompleted();\n+        mockingProgress.stubbingCompleted();\n         addResult(Result.createReturnResult(value));\n     }\n     \n     public void addThrowable(Throwable throwable) {\n-        mockitoState.stubbingCompleted();\n+        mockingProgress.stubbingCompleted();\n         validateThrowable(throwable);\n         addResult(Result.createThrowResult(throwable));\n     }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         List mock = Mockito.mock(List.class);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n-        assertNull(Mockito.mockitoState.pullStubable());\n+        assertNull(Mockito.mockingProgress.pullStubable());\n     }\n     \n     @Test(expected=NotAMockException.class)\n--- a/test/org/mockito/RequiresValidState.java\n+++ b/test/org/mockito/RequiresValidState.java\n \n     @Before\n     public void requiresValidState() {\n-        Mockito.mockitoState.validateState();\n+        Mockito.mockingProgress.validateState();\n     }\n }\n--- a/test/org/mockito/StateResetter.java\n+++ b/test/org/mockito/StateResetter.java\n public class StateResetter {\n     \n     public static void reset() {\n-        Mockito.mockitoState.reset();\n+        Mockito.mockingProgress.reset();\n     }\n }\n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n     \n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n-        MockitoStateImpl state = new MockitoStateImpl();\n+        MockingProgressImpl state = new MockingProgressImpl();\n         state.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n         MockControl control = new MockControl(state, new ExceptionThrowingBinder());\n         \n--- /dev/null\n+++ b/test/org/mockito/internal/state/MockingProgressImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+\n+public class MockingProgressImplTest extends RequiresValidState {\n+\n+    private MockingProgress mockingProgress;\n+\n+    @Before\n+    public void setup() {\n+        mockingProgress = new MockingProgressImpl();\n+    }\n+    \n+    @Test\n+    public void shouldSwitchVerifyingMode() throws Exception {\n+        assertNull(mockingProgress.pullVerifyingMode());\n+        \n+        OngoingVerifyingMode mode = OngoingVerifyingMode.times(19);\n+        \n+        mockingProgress.verifyingStarted(mode);\n+        \n+        assertSame(mode, mockingProgress.pullVerifyingMode());\n+    }\n+    \n+    @Test\n+    public void shouldCheckIfVerificationWasFinished() throws Exception {\n+        mockingProgress.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+        try {\n+            mockingProgress.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.MockitoStateImpl;\n+import org.mockito.internal.state.MockingProgressImpl;\n import org.mockito.internal.stubbing.Stubber;\n \n public class StubberTest extends RequiresValidState{\n \n     private Stubber stubber;\n-    private MockitoStateImpl state;\n+    private MockingProgressImpl state;\n     private Invocation simpleMethod;\n     \n     @Before\n     public void setup() {\n-        state = new MockitoStateImpl();\n+        state = new MockingProgressImpl();\n         \n         stubber = new Stubber(state);\n         stubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n package org.mockitousage;\n import static org.junit.Assert.assertFalse;\n \n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.junit.Test;\n-import org.junit.runner.*;\n+import org.junit.runner.JUnitCore;\n+import org.junit.runner.Result;\n import org.junit.runner.notification.Failure;\n-import org.mockito.*;\n-import org.mockito.exceptions.parents.*;\n-import org.mockito.internal.*;\n+import org.mockito.MockUtilTest;\n+import org.mockito.MockitoTest;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoAssertionErrorTest;\n+import org.mockito.exceptions.parents.MockitoExceptionTest;\n+import org.mockito.internal.MockControlTest;\n import org.mockito.internal.creation.CglibTest;\n import org.mockito.internal.creation.MockFactoryTest;\n import org.mockito.internal.invocation.InvocationChunkTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n-import org.mockito.internal.state.MockitoStateImplTest;\n+import org.mockito.internal.state.MockingProgressImplTest;\n import org.mockito.internal.state.OngoingVerifyingModeTest;\n import org.mockito.internal.stubbing.EmptyReturnValuesTest;\n import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;\n-import org.mockitousage.binding.*;\n-import org.mockitousage.matchers.*;\n+import org.mockitousage.binding.BridgeMethodPuzzleTest;\n+import org.mockitousage.binding.IncorectBindingPuzzleFixedTest;\n+import org.mockitousage.matchers.ComparableMatchersTest;\n+import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n+import org.mockitousage.matchers.MatchersTest;\n+import org.mockitousage.matchers.MatchersToStringTest;\n+import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n import org.mockitousage.sample.MockitoSampleTest;\n-import org.mockitousage.stubbing.*;\n-import org.mockitousage.verification.*;\n+import org.mockitousage.stubbing.BasicStubbingTest;\n+import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n+import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n+import org.mockitousage.verification.AtLeastOnceVerificationTest;\n+import org.mockitousage.verification.BasicVerificationTest;\n+import org.mockitousage.verification.DescriptiveMessagesOnStrictOrderErrorsTest;\n+import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n+import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n+import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderTest;\n+import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n+import org.mockitousage.verification.VerificationUsingMatchersTest;\n \n public class MultiThreadedTest extends RequiresValidState {\n     \n                     InvocationChunkTest.class, \n                     MockFactoryTest.class, \n                     NumberOfInvocationsVerifierTest.class, \n-                    MockitoStateImplTest.class, \n+                    MockingProgressImplTest.class, \n                     RegisteredInvocationsTest.class, \n                     EmptyReturnValuesTest.class, \n                     OngoingVerifyingModeTest.class, ", "timestamp": 1197407395, "metainfo": ""}