{"sha": "c304868a35db154c82db10403f0d23cedecadf1e", "log": "javadoc fixes  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40694", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * <li> By default, for all methods that return value, mock returns null, an\n  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n  * false, ... for int/Integer, boolean/Boolean, ...). </li>\n+ * \n  * <li> Stubbing can be overridden: for example common stubbing can go to\n  * fixture setup but test methods can override it. </li>\n+ * \n  * <li> Once stubbed, mocked method will always return stubbed value regardless\n  * of how many times it is called. </li>\n+ * \n  * <li> Last stubbing is more important - when you stubbed the same method with\n  * the same arguments many times. </li>\n- * <li> Although it is possible to verify a stubbed invocation, in majority of\n- * cases <b>it's not necessary</b>. Stubbed invocations <b>are verified\n- * implicitly</b>. The execution flow of your own code does it completely\n- * <b>for free</b>. </li>\n+ * \n+ * <li> \n+ * Although it is possible to verify a stubbed invocation, in majority\n+ * of cases it's not necessary. Let's say you've stubbed foo.bar()\n+ * method. If your code cares what value foo.bar() returns, something\n+ * else will fail if you forget to call foo.bar(). Hence you don't have\n+ * to verify() it (e.g. it's just redundant). Not convinced? See  \n+ * <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a></li>\n  * </ul>\n  * \n  * <h3>3. Argument matchers</h3>\n  * //verify that other mocks were not interacted\n  * verifyZeroInteractions(mockTwo, mockThree);\n  * \n- * //following works exactly the same as above\n- * verifyNoMoreInteractions(mockTwo, mockThree);\n- * </pre>\n- * \n- * See more {@link Mockito#verifyNoMoreInteractions}\n+ * </pre>\n  * \n  * <p>\n  * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions()\n  * verifyNoMoreInteractions(mockedList);\n  * </pre>\n  * \n- * Remember that usually it's not necessary to call verifyNoMoreInteractions()\n- * all the time. See also {@link Mockito#never()} - it is more explicit and\n+ * verifyNoMoreInteractions() should not be used in every method. \n+ * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n+ * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+ * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n+ * \n+ * <p>   \n+ * \n+ *  See also {@link Mockito#never()} - it is more explicit and\n  * communicates an intent well.\n  * <p>\n  * \n  *   verify(spy).add(\"two\");\n  * </pre>\n  * \n- * <h3>IMPORTANT</h3>\n+ * <h4>Important gotcha on spying real objects!</h4>\n  * \n  * Sometimes it's impossible to use {@link Mockito#stub(Object)} for stubbing spies. Example:\n  * \n      * Last stubbing is more important - when you stubbed the same method with\n      * the same arguments many times.\n      * <p>\n-     * Although it's possible to verify stubbed methods, bear in mind that\n-     * <b>are verified for free</b>.\n+     * Although it is possible to verify a stubbed invocation, in majority\n+     * of cases it's not necessary. Let's say you've stubbed foo.bar()\n+     * method. If your code cares what value foo.bar() returns, something\n+     * else will fail if you forget to call foo.bar(). Hence you don't have\n+     * to verify() it (e.g. it's just redundant). Not convinced? See  \n+     * <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>. \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * \n      *            method call\n      * @return OngoingStubbing object to set stubbed value/exception\n      */\n-    //TODO change the javadoc to what was said on the mailing list\n     @SuppressWarnings(\"unchecked\")\n     public static <T> OngoingStubbing<T> stub(T methodCall) {\n         MOCKING_PROGRESS.stubbingStarted();\n      * <pre>\n      *   verify(mock, times(1)).someMethod(\"some arg\");\n      * </pre>\n+     * \n+     * <p>\n+     * Although it is possible to verify a stubbed invocation, in majority\n+     * of cases it's not necessary. Let's say you've stubbed foo.bar()\n+     * method. If your code cares what value foo.bar() returns, something\n+     * else will fail if you forget to call foo.bar(). Hence you don't have\n+     * to verify() it (e.g. it's just redundant). Not convinced? See  \n+     * <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n      *  \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * You can use this method after you verified your mocks - to make sure that nothing\n      * else was invoked on your mocks.\n      * <p>\n-     * Usually it's not necessary to call verifyNoMoreInteractions() all the time.\n      * See also {@link Mockito#never()} - it is more explicit and communicates an intent well.\n      * <p>\n      * Stubbed invocations (if called) are also treated as interactions.\n+     * <p>\n+     * verifyNoMoreInteractions() should not be used in every method. \n+     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n+     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n+     * \n      * <p>\n      * Example:\n      * ", "timestamp": 1216306598, "metainfo": ""}