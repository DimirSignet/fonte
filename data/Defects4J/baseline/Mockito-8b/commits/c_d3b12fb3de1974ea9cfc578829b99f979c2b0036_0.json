{"sha": "d3b12fb3de1974ea9cfc578829b99f979c2b0036", "log": "In order to kill of dodgy debuggingInfo class (and remove it from MockingProgress). In the middle of refactoring  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401831", "commit": "\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n     public boolean hasData() {\n         return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n     }\n-\n-    public String getWarnings(boolean warnAboutUnstubbed) {\n-        final StringBuilder sb = new StringBuilder();\n-        if (hasData()) {\n-            new WarningsPrinterImpl(unusedStubs, unstubbedInvocations, warnAboutUnstubbed).print(new MockitoLogger() {\n-                public void log(Object what) {\n-                    sb.append(what);\n-                }});\n-        }\n-        return sb.toString();\n-    }\n }\n--- a/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n     }\n \n     private String thisStubWasNotUsed(Invocation i) {\n-        return \"This stubbing was never used \" + i.getLocation() + \"\\n\";\n+        return \"This stubbing was never used:   \" + i.getLocation() + \"\\n\";\n     }\n \n     private String thisMethodWasNotStubbed(InvocationMatcher i) {\n \n     private String stubbedMethodCalledWithDifferentArguments(Invocation unused, InvocationMatcher unstubbed) {\n         return join(\n-                \" *** Verbose stubbing warnings from Mockito *** \",\n-                \"stubbed here \" + unused.getLocation(),\n-                \"BUT called with different arguments here \" + unstubbed.getInvocation().getLocation(),\n+                \" *** Stubbing warnings from Mockito: *** \",\n+                \"\",\n+                \"stubbed with those args here:   \" + unused.getLocation(),\n+                \"BUT called with different args: \" + unstubbed.getInvocation().getLocation(),\n                 \"\");\n     }\n+\n+    public String print() {\n+        //TODO: test and figure out if it is the best place for it\n+        final StringBuilder sb = new StringBuilder();\n+        this.print(new MockitoLogger() {\n+            public void log(Object what) {\n+                sb.append(what);\n+            }\n+        });\n+        return sb.toString();\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/ExceptionIncludingMockitoWarnings.java\n+package org.mockito.internal.exceptions;\n+\n+public class ExceptionIncludingMockitoWarnings extends RuntimeException {\n+    public ExceptionIncludingMockitoWarnings(String message, Throwable throwable) {\n+        super(message, throwable);\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockitoLoggerImpl.java\n+++ b/src/org/mockito/internal/util/MockitoLoggerImpl.java\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n     public void log(Object what) {\n-        System.out.println(what.toString());\n+        System.out.print(what.toString());\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/LenientCopyTool.java\n+++ b/src/org/mockito/internal/util/reflection/LenientCopyTool.java\n     }\n \n     private <T> void copy(T from, T to, Class fromClazz, Class toClass) {\n-        assert toClass == fromClazz \n-            : \"Classes must have the same type: class of the object from: \" + fromClazz + \", mock super class: \" + toClass;\n-\n         while (fromClazz != Object.class) {\n             copyValues(from, to, fromClazz);\n             fromClazz = fromClazz.getSuperclass();\n--- a/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n import org.junit.runner.notification.Failure;\n import org.junit.runner.notification.RunListener;\n import org.junit.runner.notification.RunNotifier;\n-import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.MockSettings;\n+import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;\n+import org.mockito.internal.debugging.WarningsPrinterImpl;\n+import org.mockito.internal.invocation.AllInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.UnusedStubsFinder;\n+import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.runners.RunnerFactory;\n import org.mockito.internal.util.reflection.Whitebox;\n \n import java.lang.reflect.InvocationTargetException;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Experimental implementation that suppose to improve tdd/testing experience. \n     @Override\n     public void run(RunNotifier notifier) {\n         MockingProgress progress = new ThreadSafeMockingProgress();\n-        //TODO this class should work like ConsoleSpammingRunner and we should kill off debuggingInfo\n-        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n-        \n-        beforeRun(notifier, debuggingInfo);\n-        \n-        runner.run(notifier);\n-        \n-        afterRun(debuggingInfo);\n-    }\n-\n-    private void afterRun(final DebuggingInfo debuggingInfo) {\n-        debuggingInfo.clearData();\n-    }\n-\n-    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n-        debuggingInfo.collectData();\n+        final List createdMocks = new LinkedList();\n+        progress.setListener(new MockingStartedListener() {\n+            public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n+                createdMocks.add(mock);\n+            }\n+        });\n \n         //a listener that changes the failure's exception in a very hacky way...\n         RunListener listener = new RunListener() {\n             @Override public void testFailure(final Failure failure) throws Exception {\n+                //TODO: this has to protect the use in case jUnit changes and this internal state logic fails\n                 Throwable throwable = (Throwable) Whitebox.getInternalState(failure, \"fThrownException\");\n-                \n+\n+                List< Invocation > unused = new UnusedStubsFinder().find(createdMocks);\n+                List<Invocation> all = new AllInvocationsFinder().find(createdMocks);\n+                List<InvocationMatcher> allMatchers = new LinkedList<InvocationMatcher>();\n+                //TODO: this is dodgy, I shouldn't be forced to change the type into InvocationMatcher just to enable using has similar method!!!\n+                for (Invocation i : all) {\n+                    allMatchers.add(new InvocationMatcher(i));\n+                }\n+                //TODO: warnings printer is not consistent with debug().printInvocations()\n+                String warnings = new WarningsPrinterImpl(unused, allMatchers, false).print();\n+\n                 String newMessage = throwable.getMessage();\n-                newMessage += \"\\n\" + debuggingInfo.getWarnings(false) + \"\\n*** The actual failure is because of: ***\\n\";\n-                \n-                Whitebox.setInternalState(throwable, \"detailMessage\", newMessage);\n+                newMessage += warnings + \"\\n*** The actual failure is because of: ***\\n\";\n+\n+                newMessage = \"contains both: actual test failure *and* Mockito warnings.\\n\" +\n+                        warnings + \"\\n *** The actual failure is because of: ***\\n\";\n+\n+                ExceptionIncludingMockitoWarnings e = new ExceptionIncludingMockitoWarnings(newMessage, throwable);\n+                e.setStackTrace(throwable.getStackTrace());\n+                Whitebox.setInternalState(failure, \"fThrownException\", e);\n             }\n         };\n-        \n+\n         notifier.addFirstListener(listener);\n+\n+        runner.run(notifier);\n     }\n \n     @Override\n--- a/test/org/mockito/internal/debugging/WarningsPrinterImplTest.java\n+++ b/test/org/mockito/internal/debugging/WarningsPrinterImplTest.java\n         p.print(logger);\n \n         // then\n-        assertContains(\"different arguments\", logger.getLoggedInfo());\n+        assertContains(\"different arg\", logger.getLoggedInfo());\n     }\n \n     @Test\n--- a/test/org/mockitousage/junitrunner/ModellingVerboseMockitoTest.java\n+++ b/test/org/mockitousage/junitrunner/ModellingVerboseMockitoTest.java\n \n import static org.mockito.Mockito.*;\n \n+import org.junit.After;\n import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n+import org.mockito.runners.ConsoleSpammingMockitoJUnitRunner;\n import org.mockito.runners.VerboseMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+//@RunWith(ConsoleSpammingMockitoJUnitRunner.class)\n+@RunWith(VerboseMockitoJUnitRunner.class)\n @Ignore\n-@RunWith(VerboseMockitoJUnitRunner.class)\n public class ModellingVerboseMockitoTest extends TestBase {\n     \n     @Mock private IMethods mock;\n         when(mock.simpleMethod(1)).thenReturn(\"foo\");\n         when(mock.otherMethod()).thenReturn(\"foo\");\n         when(mock.booleanObjectReturningMethod()).thenReturn(false);\n-        \n+\n         String ret = mock.simpleMethod(2);\n-        \n+\n         assertEquals(\"foo\", ret);\n     }\n+\n+    @Test\n+    public void shouldNotLogAnythingWhenNoWarnings() throws Exception {\n+        String ret = mock.simpleMethod(2);\n+\n+        assertEquals(\"foo\", ret);\n+    }\n+\n+//    @After\n+//    public void checkStubs() {\n+////        stubsUsedIn(mock);\n+//    }\n+//\n+//    private void stubsUsed(Object ... mocks) {\n+//\n+//    }\n+//\n+//    private void stubsUsed(Object testCaseOrMock) {\n+//\n+//    }\n }\n--- a/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n+++ b/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n     public void shouldVerify() {\n         spy.add(\"one\");\n         spy.add(\"two\");\n-        \n+\n         assertEquals(\"one\", spy.get(0));\n         assertEquals(\"two\", spy.get(1));\n-        \n+\n         verify(spy).add(\"one\");\n         verify(spy).add(\"two\");\n+    }\n+\n+    @Test\n+    public void shouldBeAbleToMockObjectBecauseWhyNot() {\n+        spy(new Object());\n     }\n     \n     @Test", "timestamp": 1266178776, "metainfo": ""}