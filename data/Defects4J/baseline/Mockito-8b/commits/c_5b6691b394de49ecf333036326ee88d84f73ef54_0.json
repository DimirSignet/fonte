{"sha": "5b6691b394de49ecf333036326ee88d84f73ef54", "log": "Fixed the name of the test and refactored it a little bit  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%402055", "commit": "\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java\n+package org.mockitousage.bugs;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+//see bug 190\n+public class ShouldNotDeadlockAnswerExecutionTest {\n+\n+    @Test\n+    public void failIfMockIsSharedBetweenThreads() throws Exception {\n+        Service service = Mockito.mock(Service.class);\n+        ExecutorService threads = Executors.newCachedThreadPool();\n+        AtomicInteger counter = new AtomicInteger(2);\n+\n+        // registed answer on verySlowMethod\n+\n+        Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));\n+\n+        // execute verySlowMethod twice in separate threads\n+\n+        threads.execute(new ServiceRunner(service));\n+        threads.execute(new ServiceRunner(service));\n+\n+        // waiting for threads to finish\n+\n+        threads.shutdown();\n+\n+        if (!threads.awaitTermination(1000, TimeUnit.MILLISECONDS)) {\n+            // threads were timed-out\n+            Assert.fail();\n+        }\n+    }\n+\n+    @Test\n+    public void successIfEveryThreadHasItsOwnMock() throws Exception {\n+        Service service1 = Mockito.mock(Service.class);\n+        Service service2 = Mockito.mock(Service.class);\n+        ExecutorService threads = Executors.newCachedThreadPool();\n+        AtomicInteger counter = new AtomicInteger(2);\n+\n+        // registed answer on verySlowMethod\n+\n+        Mockito.when(service1.verySlowMethod()).thenAnswer(new LockingAnswer(counter));\n+        Mockito.when(service2.verySlowMethod()).thenAnswer(new LockingAnswer(counter));\n+\n+        // execute verySlowMethod twice in separate threads\n+\n+        threads.execute(new ServiceRunner(service1));\n+        threads.execute(new ServiceRunner(service2));\n+\n+        // waiting for threads to finish\n+\n+        threads.shutdown();\n+\n+        if (!threads.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n+            // threads were timed-out\n+            Assert.fail();\n+        }\n+    }\n+\n+    static class LockingAnswer implements Answer<String> {\n+\n+        private AtomicInteger counter;\n+\n+        public LockingAnswer(AtomicInteger counter) {\n+            this.counter = counter;\n+        }\n+\n+        /**\n+         * Decrement counter and wait until counter has value 0\n+         */\n+        public String answer(InvocationOnMock invocation) throws Throwable {\n+            counter.decrementAndGet();\n+\n+            while (counter.get() != 0) {\n+                Thread.sleep(10);\n+            }\n+\n+            return null;\n+        }\n+\n+    }\n+\n+    static class ServiceRunner implements Runnable {\n+\n+        private Service service;\n+\n+        public ServiceRunner(Service service) {\n+            this.service = service;\n+        }\n+\n+        public void run() {\n+            service.verySlowMethod();\n+        }\n+\n+    }\n+\n+    static interface Service {\n+\n+        String verySlowMethod();\n+\n+    }\n+\n+}\n+", "timestamp": 1282078255, "metainfo": ""}