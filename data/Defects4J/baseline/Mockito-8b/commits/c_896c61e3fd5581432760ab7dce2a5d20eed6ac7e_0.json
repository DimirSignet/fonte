{"sha": "896c61e3fd5581432760ab7dce2a5d20eed6ac7e", "log": "Fixed issue 166 Added @Captor annotation that makes easier to create ArgumentCaptors  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401855", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/Captor.java\n+/*\n+ * Copyright (c) 2010 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n+ * <p>Example:\n+ * <pre>\n+ * public class Test{\n+ *\n+ *    &#64;Captor ArgumentCaptor&lt;AsyncCallback&lt;Foo&gt;&gt; captor;\n+ *\n+ *    &#64;Before\n+ *    public void init(){\n+ *       MockitoAnnotations.init(this);\n+ *    }\n+ *\n+ *    ...\n+ * }\n+ * </pre>\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+@Documented\n+public @interface Captor {}\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n \n import static java.lang.annotation.ElementType.*;\n \n+import java.lang.annotation.Documented;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n  */\n @Target( { FIELD })\n @Retention(RetentionPolicy.RUNTIME)\n+@Documented\n public @interface Mock {}\n \n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n         AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n+            boolean alreadyAssigned = false;\n             for(Annotation annotation : field.getAnnotations()) {\n                 Object mock = annotationEngine.createMockFor(annotation, field);\n                 if (mock != null) {\n+                    throwIfAlreadyAssigned(field, alreadyAssigned);\n+                    alreadyAssigned = true;\n                     boolean wasAccessible = field.isAccessible();\n                     field.setAccessible(true);\n                     try {\n                         field.set(testClass, mock);\n                     } catch (IllegalAccessException e) {\n-                        throw new MockitoException(\"Problems initiating mocks annotated with \" + annotation, e);\n+                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n+                                + annotation, e);\n                     } finally {\n                         field.setAccessible(wasAccessible);\n                     }    \n             }\n         }\n     }\n+\n+    private static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n+        if (alreadyAssigned) {\n+            throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n+            \t\t\"The field '\" + field.getName() + \"' has multiple Mockito annotations.\\n\" +\n+            \t\t\"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/Spy.java\n+package org.mockito;\n+\n+import java.lang.annotation.*;\n+\n+/**\n+ * Allows shorthand wrapping of field instances in an spy object. <b>Warning</b> if you call\n+ * <code>MockitoAnnotations.init(this)</code> in a super class this will not work. Since\n+ *  fields in subclass are only instantiated after super class constructor has returned.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * public class Test{\n+ *\n+ *    &#64;Spy Foo spyOnFoo = new Foo();\n+ *\n+ *    &#64;Before\n+ *    public void init(){\n+ *       MockitoAnnotations.init(this);\n+ *    }\n+ *    ...\n+ * }\n+ * </pre>\n+ * <p>Same as doing:\n+ * <pre>\n+ *    Foo spyOnFoo = Mockito.spy(new Foo());\n+ * </pre>\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+@Documented\n+public @interface Spy {\n+}\n--- a/src/org/mockito/configuration/AnnotationEngine.java\n+++ b/src/org/mockito/configuration/AnnotationEngine.java\n import org.mockito.MockitoAnnotations;\n \n /**\n- * Configures mock creation logic behind &#064;Mock annotations\n+ * Configures mock creation logic behind &#064;Mock, &#064;Captor and &#064;Spy annotations\n  * <p>\n  * If you are interested then see implementations or source code of {@link MockitoAnnotations#initMocks(Object)}\n  */\n public interface AnnotationEngine {\n \n     /**\n-     * Usually the implementation checks the annotation  \n-     * and then creates a mock object for specified field.\n-     * <p>\n-     * You don't need to set the mock on the field. Mockito does it for you. \n-     * If in doubts look for implementations of this interface.\n-     * <p>\n-     * For annotations that you don't care about just return null - then Mockito will not initialize this field\n-     * \n-     * @param annotation annotation on the field, for example &#064;Mock\n-     * @param field field to create mock object for\n-     * @return mock created for specified field. Can be null - then Mockito will not initialize the field\n+     * Creates mock, ArgumentCaptor or wraps field instance in spy object.\n+     * Only if of correct annotation type.\n+     *\n+     * @param annotation\n+     * @param field\n+     * @return\n      */\n     Object createMockFor(Annotation annotation, Field field);\n \n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n+import org.mockito.*;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.base.MockitoException;\n+\n import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-\n-import org.mockito.Mock;\n-import org.mockito.Mockito;\n-import org.mockito.MockitoAnnotations;\n-import org.mockito.configuration.AnnotationEngine;\n+import java.lang.reflect.*;\n \n /**\n- * Initializes fields annotated with &#064;Mock\n- * <p>\n+ * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n+ * <p/>\n  * See {@link MockitoAnnotations}\n  */\n public class DefaultAnnotationEngine implements AnnotationEngine {\n-    \n+\n     /* (non-Javadoc)\n-     * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n-     */\n+    * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n+    */\n+\n     @SuppressWarnings(\"deprecation\")\n     public Object createMockFor(Annotation annotation, Field field) {\n         if (annotation instanceof Mock || annotation instanceof org.mockito.MockitoAnnotations.Mock) {\n             return Mockito.mock(field.getType(), field.getName());\n-        } else {\n-            return null;\n         }\n+\n+        if (annotation instanceof Captor) {\n+            Class<?> type = field.getType();\n+            if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n+                throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" +\n+                \t\t\"Field: '\" + field.getName() + \"' has wrong type\\n\" +\n+                \t\t//TODO add javadocs\n+                \t\t\"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n+            }\n+\n+            return ArgumentCaptor.forClass(Object.class);\n+        }\n+\n+        if (annotation instanceof Spy) {\n+            throw new IllegalArgumentException(\"@Spy is not yet supported.\");\n+        }\n+\n+        return null;\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/CaptorAnnotationBasicTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CaptorAnnotationBasicTest extends TestBase {\n+\n+    public class Person {\n+        private final String name;\n+        private final String surname;\n+\n+        public Person(String name, String surname) {\n+            this.name = name;\n+            this.surname = surname;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+        \n+        public String getSurname() {\n+            return surname;\n+        }\n+    }\n+\n+    public interface PeopleRepository {\n+        public void save(Person capture);\n+    }\n+    \n+    @Mock PeopleRepository peopleRepository;           \n+    \n+    private void createPerson(String name, String surname) {\n+        peopleRepository.save(new Person(name, surname));\n+    }      \n+    \n+    @Test\n+    public void shouldUseCaptorInOrdinaryWay() {\n+        //when\n+        createPerson(\"Wes\", \"Williams\");\n+        \n+        //then\n+        ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);\n+        verify(peopleRepository).save(captor.capture());\n+        assertEquals(\"Wes\", captor.getValue().getName());\n+        assertEquals(\"Williams\", captor.getValue().getSurname());\n+    }\n+    \n+    @Captor ArgumentCaptor<Person> captor;\n+    \n+    @Test\n+    public void shouldUseAnnotatedCaptor() {\n+        //when\n+        createPerson(\"Wes\", \"Williams\");\n+        \n+        //then\n+        verify(peopleRepository).save(captor.capture());\n+        assertEquals(\"Wes\", captor.getValue().getName());\n+        assertEquals(\"Williams\", captor.getValue().getSurname());\n+    }\n+        \n+    @Captor ArgumentCaptor genericLessCaptor;\n+    \n+    @Test\n+    public void shouldUseGenericlessAnnotatedCaptor() {\n+        //when\n+        createPerson(\"Wes\", \"Williams\");\n+        \n+        //then\n+        verify(peopleRepository).save((Person) genericLessCaptor.capture());\n+        assertEquals(\"Wes\", ((Person) genericLessCaptor.getValue()).getName());\n+        assertEquals(\"Williams\", ((Person) genericLessCaptor.getValue()).getSurname());\n+    }  \n+    \n+    @Captor ArgumentCaptor<List<String>> genericListCaptor;\n+    @Mock IMethods mock;\n+    \n+    @Test\n+    public void shouldCaptureGenericList() {\n+        //given\n+        List<String> list = new LinkedList<String>();\n+        mock.listArgMethod(list);\n+                \n+        //when\n+        verify(mock).listArgMethod(genericListCaptor.capture());\n+        \n+        //then\n+        assertSame(list, genericListCaptor.getValue());\n+    } \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/CaptorAnnotationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CaptorAnnotationTest extends TestBase {\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NotAMock {\n+    }\n+\n+    @Captor\n+    final ArgumentCaptor<String> finalCaptor = ArgumentCaptor.forClass(String.class);\n+\n+    @Captor\n+    ArgumentCaptor<List<List<String>>> genericsCaptor;\n+\n+    @Captor\n+    ArgumentCaptor nonGenericCaptorIsAllowed;\n+\n+    @Mock\n+    MockInterface mockInterface;\n+\n+    @NotAMock\n+    Set notAMock;\n+\n+    public interface MockInterface {\n+        void testMe(String simple, List<List<String>> genericList);\n+    }\n+\n+    @Test\n+    public void testNormalUsage() {\n+\n+        MockitoAnnotations.initMocks(this);\n+\n+        // check if assigned correctly\n+        assertNotNull(finalCaptor);\n+        assertNotNull(genericsCaptor);\n+        assertNotNull(nonGenericCaptorIsAllowed);\n+        assertNull(notAMock);\n+\n+        // use captors in the field to be sure they are cool\n+        String argForFinalCaptor = \"Hello\";\n+        ArrayList<List<String>> argForGenericsCaptor = new ArrayList<List<String>>();\n+\n+        mockInterface.testMe(argForFinalCaptor, argForGenericsCaptor);\n+\n+        Mockito.verify(mockInterface).testMe(finalCaptor.capture(), genericsCaptor.capture());\n+\n+        assertEquals(argForFinalCaptor, finalCaptor.getValue());\n+        assertEquals(argForGenericsCaptor, genericsCaptor.getValue());\n+\n+    }\n+\n+    public static class WrongType {\n+        @Captor\n+        List wrongType;\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenWrongTypeForCaptor() {\n+        try {\n+            MockitoAnnotations.initMocks(new WrongType());\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+//TODO: do we need this? Asked the author of the patch if he doesn't come back we will delete it (17-02-2010)    \n+//    public static class WrongWildcardGenerics {\n+//        @Captor\n+//        ArgumentCaptor<? extends List> wrongType;\n+//    }\n+//\n+//    @Test\n+//    public void shouldScreamWhenWildCardGenericsAreUsedWrong() {\n+//        MockitoAnnotations.initMocks(new WrongWildcardGenerics());        \n+//    }\n+\n+    public static class ToManyAnnotations {\n+        @Captor\n+        @Mock\n+        ArgumentCaptor<List> missingGenerics;\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {\n+        try {\n+            MockitoAnnotations.initMocks(new ToManyAnnotations());\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\n+                    \"Cannot have more than one Mockito annotation on field. For info how to use annotations see examples in javadoc for MockitoAnnotations class.\",\n+                    e.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenInitializingCaptorsForNullClass() throws Exception {\n+        try {\n+            MockitoAnnotations.initMocks(null);\n+            fail();\n+        } catch (MockitoException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void shouldLookForAnnotatedCaptorsInSuperClasses() throws Exception {\n+        Sub sub = new Sub();\n+        MockitoAnnotations.initMocks(sub);\n+\n+        assertNotNull(sub.getCaptor());\n+        assertNotNull(sub.getBaseCaptor());\n+        assertNotNull(sub.getSuperBaseCaptor());\n+    }\n+\n+    class SuperBase {\n+        @Captor\n+        private ArgumentCaptor<IMethods> mock;\n+\n+        public ArgumentCaptor<IMethods> getSuperBaseCaptor() {\n+            return mock;\n+        }\n+    }\n+\n+    class Base extends SuperBase {\n+        @Captor\n+        private ArgumentCaptor<IMethods> mock;\n+\n+        public ArgumentCaptor<IMethods> getBaseCaptor() {\n+            return mock;\n+        }\n+    }\n+\n+    class Sub extends Base {\n+        @Captor\n+        private ArgumentCaptor<IMethods> mock;\n+\n+        public ArgumentCaptor<IMethods> getCaptor() {\n+            return mock;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/CaptorAnnotationUnhappyPathTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Captor;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CaptorAnnotationUnhappyPathTest extends TestBase {\n+    \n+    @Captor List notACaptorField;\n+\n+    @Before\n+    @Override\n+    public void init() {\n+        //we need to get rid of parent implementation this time\n+    }\n+    \n+    @Test\n+    public void shouldFailIfCaptorHasWrongType() throws Exception {\n+        try {\n+            //when\n+            MockitoAnnotations.initMocks(this);\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"notACaptorField\", e.getMessage());\n+            assertContains(\"wrong type\", e.getMessage());\n+        }\n+    }\n+}", "timestamp": 1266437608, "metainfo": ""}