{"sha": "2da88f01bc21e5a66a2a8414856edb78792cd176", "log": "In order to prepare Mockito for new feature: printing invocations for debugging In the middle of refactoring  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401719", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n     MatchersBinder matchersBinder;\n     MockingProgress mockingProgress;\n \n-    private final RegisteredInvocations registeredInvocations;\n     private final MockName mockName;\n     private final MockSettingsImpl mockSettings;\n \n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n         this.mockSettings = mockSettings;\n-        this.mockitoStubber = new MockitoStubber(mockingProgress);\n-        this.registeredInvocations = new RegisteredInvocations();\n+        this.mockitoStubber = new MockitoStubber(mockingProgress);        \n     }\n \n     public MockHandler(MockHandler<T> oldMockHandler) {\n         mockingProgress.validateState();\n \n         if (verificationMode != null) {\n-            VerificationDataImpl data = new VerificationDataImpl(registeredInvocations.getAll(), invocationMatcher);\n+            VerificationDataImpl data = new VerificationDataImpl(mockitoStubber.getInvocations(), invocationMatcher);\n             verificationMode.verify(data);\n             return null;\n         }\n-\n-        registeredInvocations.add(invocationMatcher.getInvocation());\n+        \n         mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, mockitoStubber.getRegisteredInvocations());\n         mockingProgress.reportOngoingStubbing(ongoingStubbing);\n \n         StubbedInvocationMatcher stubbedInvocation = mockitoStubber.findAnswerFor(invocation);\n             // Without it, the real method inside 'when' might have delegated\n             // to other self method and overwrite the intended stubbed method\n             // with a different one.\n-            mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n+            mockitoStubber.resetInvocationForPotentialStubbing(invocationMatcher);\n             return ret;\n         }\n     }\n \n     public void verifyNoMoreInteractions() {\n-        VerificationDataImpl data = new VerificationDataImpl(registeredInvocations.getAll(), null);\n+        VerificationDataImpl data = new VerificationDataImpl(mockitoStubber.getInvocations(), null);\n         VerificationModeFactory.noMoreInteractions().verify(data);\n     }\n \n     }\n \n     public List<Invocation> getRegisteredInvocations() {\n-        return registeredInvocations.getAll();\n+        return mockitoStubber.getInvocations();\n     }\n \n     public MockName getMockName() {\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.answers.AnswersValidator;\n+import org.mockito.internal.verification.RegisteredInvocations;\n import org.mockito.stubbing.Answer;\n+\n+import javax.management.openmbean.CompositeData;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoStubber implements Serializable {\n     private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private final MockingProgress mockingProgress;\n     private final List<Answer> answersForStubbing = new ArrayList<Answer>();\n+    private final RegisteredInvocations registeredInvocations = new RegisteredInvocations();\n \n     private InvocationMatcher invocationForStubbing;\n \n     }\n \n     public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        registeredInvocations.add(invocation.getInvocation());\n         this.invocationForStubbing = invocation;\n+    }\n+\n+    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n+        this.invocationForStubbing = invocationMatcher;\n     }\n \n     public void addAnswer(Answer answer) {\n     public void addConsecutiveAnswer(Answer answer) {\n         addAnswer(answer, true);\n     }\n-    \n+\n     private void addAnswer(Answer answer, boolean isConsecutive) {\n         Invocation invocation = invocationForStubbing.getInvocation();\n         mockingProgress.stubbingCompleted(invocation);\n         AnswersValidator answersValidator = new AnswersValidator();\n         answersValidator.validate(answer, invocation);\n-        \n+\n         if (isConsecutive) {\n             stubbed.getFirst().addAnswer(answer);\n         } else {\n             stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n         }\n-    } \n-    \n+    }\n+\n     Object answerTo(Invocation invocation) throws Throwable {\n         return findAnswerFor(invocation).answer(invocation);\n     }\n                 return s;\n             }\n         }\n-        \n+\n         return null;\n     }\n \n     public void addAnswerForVoidMethod(Answer answer) {\n         answersForStubbing.add(answer);\n     }\n-    \n+\n     public void setAnswersForStubbing(List<Answer> answers) {\n         answersForStubbing.addAll(answers);\n     }\n         }\n         answersForStubbing.clear();\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return \"invocationForStubbing: \" + invocationForStubbing;\n     }\n+\n+    public List<Invocation> getInvocations() {\n+        return registeredInvocations.getAll();\n+    }\n+\n+    public RegisteredInvocations getRegisteredInvocations() {\n+        return registeredInvocations;\n+    }\n }", "timestamp": 1258316227, "metainfo": ""}