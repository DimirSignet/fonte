{"sha": "2cacf84fbea1d836c720013aad824ebacdbcd87d", "log": "In order to kill of dodgy debuggingInfo class (and remove it from MockingProgress). In the middle of refactoring  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401830", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n     public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n-        mockingProgress.validateState();\n-        return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n+        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n+        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n+        return mock;\n     }\n     \n     public IOngoingStubbing stub() {\n--- /dev/null\n+++ b/src/org/mockito/internal/listeners/MockingProgressListener.java\n+package org.mockito.internal.listeners;\n+\n+public interface MockingProgressListener {\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/listeners/MockingStartedListener.java\n+package org.mockito.internal.listeners;\n+\n+import org.mockito.MockSettings;\n+\n+//TODO: shitty name\n+public interface MockingStartedListener extends MockingProgressListener {\n+    void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings);\n+}\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n+import org.mockito.MockSettings;\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.MockingProgressListener;\n+import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.internal.verification.api.VerificationMode;\n \n public interface MockingProgress {\n     ArgumentMatcherStorage getArgumentMatcherStorage();\n \n     DebuggingInfo getDebuggingInfo();\n+\n+    void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings);\n+\n+    void setListener(MockingProgressListener listener);\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n  */\n package org.mockito.internal.progress;\n \n+import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.debugging.Localized;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.MockingProgressListener;\n+import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.internal.verification.api.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n     IOngoingStubbing iOngoingStubbing;\n     private Localized<VerificationMode> verificationMode;\n     private Location stubbingInProgress = null;\n+    private MockingProgressListener listener;\n \n     public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n         this.iOngoingStubbing = iOngoingStubbing;\n     public DebuggingInfo getDebuggingInfo() {\n         return debuggingInfo;\n     }\n+\n+    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n+        if (listener != null && listener instanceof MockingStartedListener) {\n+            ((MockingStartedListener) listener).mockingStarted(mock, classToMock, mockSettings);\n+        }\n+        validateState();\n+    }\n+\n+    public void setListener(MockingProgressListener listener) {\n+        this.listener = listener;\n+    }\n }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n \n import java.io.Serializable;\n \n+import org.mockito.MockSettings;\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.internal.verification.api.VerificationMode;\n \n public class ThreadSafeMockingProgress implements MockingProgress, Serializable {\n     public DebuggingInfo getDebuggingInfo() {\n         return threadSafely().getDebuggingInfo();\n     }\n+\n+    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n+        threadSafely().mockingStarted(mock, classToMock, mockSettings);\n+    }\n+\n+    public void setListener(MockingProgressListener listener) {\n+        threadSafely().setListener(listener);\n+    }\n }\n--- a/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n import org.junit.runner.notification.RunListener;\n import org.junit.runner.notification.RunNotifier;\n import org.junit.runners.BlockJUnit4ClassRunner;\n-import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.MockSettings;\n+import org.mockito.internal.debugging.WarningsPrinterImpl;\n+import org.mockito.internal.invocation.AllInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.UnusedStubsFinder;\n+import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.runners.RunnerFactory;\n import org.mockito.internal.util.MockitoLoggerImpl;\n \n import java.lang.reflect.InvocationTargetException;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static java.util.Collections.emptyList;\n \n /**\n  * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n     @Override\n     public void run(RunNotifier notifier) {\n         MockingProgress progress = new ThreadSafeMockingProgress();\n-        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n-        \n-        beforeRun(notifier, debuggingInfo);\n-        \n-        runner.run(notifier);\n-        \n-        afterRun(debuggingInfo);\n-    }\n-\n-    private void afterRun(final DebuggingInfo debuggingInfo) {\n-        debuggingInfo.clearData();\n-    }\n-\n-    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n-        debuggingInfo.collectData();\n+        final List createdMocks = new LinkedList();\n+        progress.setListener(new MockingStartedListener() {\n+            public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n+                createdMocks.add(mock);\n+            }\n+        });\n \n         RunListener listener = new RunListener() {\n             @Override public void testFailure(Failure failure) throws Exception {\n-                debuggingInfo.printWarnings(logger);\n+                //debuggingInfo.printWarnings(logger);\n+                //Print warnings here!\n+                List<Invocation> unused = new UnusedStubsFinder().find(createdMocks);\n+                List<Invocation> all = new AllInvocationsFinder().find(createdMocks);\n+                List<InvocationMatcher> allMatchers = new LinkedList<InvocationMatcher>();\n+                //TODO: this is dodgy, I shouldn't be forced to change the type into InvocationMatcher just to enable using has similar method!!!\n+                for (Invocation i : all) {\n+                    allMatchers.add(new InvocationMatcher(i));\n+                }\n+                //TODO: warnings printer is not consistent with debug().printInvocations()\n+                new WarningsPrinterImpl(unused, allMatchers, false).print(logger);\n             }\n         };\n-        \n+\n         notifier.addListener(listener);\n+\n+        runner.run(notifier);\n     }\n \n     @Override\n--- a/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n     @Override\n     public void run(RunNotifier notifier) {\n         MockingProgress progress = new ThreadSafeMockingProgress();\n+        //TODO this class should work like ConsoleSpammingRunner and we should kill off debuggingInfo\n         DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n         \n         beforeRun(notifier, debuggingInfo);\n--- a/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.api.VerificationMode;\n import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.notNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n \n public class MockingProgressImplTest extends TestBase {\n \n             fail();\n         } catch (MockitoException e) {}\n     }\n+\n+    @Test\n+    public void shouldNotifyListenerWhenMockingStarted() throws Exception {\n+        //given\n+        MockingStartedListener listener = mock(MockingStartedListener.class);\n+        mockingProgress.setListener(listener);\n+\n+        //when\n+        mockingProgress.mockingStarted(\"foo\", List.class, new MockSettingsImpl());\n+\n+        //then\n+        verify(listener).mockingStarted(eq(\"foo\"), eq(List.class), (MockSettingsImpl) notNull());\n+    }\n+\n+    @Test\n+    public void shouldNotifyListenerSafely() throws Exception {\n+        //when\n+        mockingProgress.setListener(null);\n+\n+        //then no exception is thrown:\n+        mockingProgress.mockingStarted(null, null, null);\n+    }\n }\n--- a/test/org/mockito/runners/ConsoleSpammingMockitoJUnitRunnerTest.java\n+++ b/test/org/mockito/runners/ConsoleSpammingMockitoJUnitRunnerTest.java\n \n public class ConsoleSpammingMockitoJUnitRunnerTest extends TestBase {\n     \n-    @Mock private IMethods mock;\n+    private IMethods mock;\n \n     private ConsoleSpammingMockitoJUnitRunner runner;\n     private MockitoLoggerStub loggerStub;\n         loggerStub = new MockitoLoggerStub();\n         notifier = new RunNotifier();\n     }\n-    \n-    @Test\n-    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {\n-            @Override\n-            public void run(RunNotifier notifier) {\n-                //this is what happens when the test runs:\n-                //first, unused stubbing:\n-                unusedStubbingThatQualifiesForWarning();\n-                //then, let's make the test fail so that warnings are printed\n-                notifier.fireTestFailure(null);\n-                //assert\n-                String loggedInfo = loggerStub.getLoggedInfo();\n-                assertContains(\".unusedStubbingThatQualifiesForWarning(\", loggedInfo);\n-            }\n-        });\n-        \n-        runner.run(notifier);\n-    }\n \n-    @Ignore\n-    @Test\n-    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {\n-            @Override\n-            public void run(RunNotifier notifier) {\n-                callUnstubbedMethodThatQualifiesForWarning();\n-                notifier.fireTestFailure(null);\n-\n-                String loggedInfo = loggerStub.getLoggedInfo();\n-                assertContains(\"method was not stubbed\", loggedInfo);\n-                assertContains(\"mock.simpleMethod(456);\", loggedInfo);\n-                assertContains(\".callUnstubbedMethodThatQualifiesForWarning(\", loggedInfo);\n-            }\n-        });\n-        \n-        runner.run(notifier);\n-    }\n-    \n-    @Test\n-    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {\n-            @Override\n-            public void run(RunNotifier notifier) {\n-                someStubbing();\n-                callStubbedMethodWithDifferentArgs();\n-                notifier.fireTestFailure(null);\n-                \n-                String loggedInfo = loggerStub.getLoggedInfo();\n-                assertContains(\"with different arguments\", loggedInfo);\n-                assertContains(\".someStubbing(\", loggedInfo);\n-                assertContains(\".callStubbedMethodWithDifferentArgs(\", loggedInfo);\n-            }\n-        });\n-        \n-        runner.run(notifier);\n-    }\n-    \n-    @Test\n-    public void shouldNotLogAnythingWhenStubCalledCorrectly() throws Exception {\n-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {\n-            @Override\n-            public void run(RunNotifier notifier) {\n-                when(mock.simpleMethod(1)).thenReturn(\"foo\");\n-                mock.simpleMethod(1);\n-\n-                notifier.fireTestFailure(null);\n-                \n-                assertEquals(\"\", loggerStub.getLoggedInfo());\n-            }\n-        });\n-        \n-        runner.run(notifier);\n-    }\n-    \n-    @Test\n-    public void shouldNotLogWhenTestPasses() throws Exception {\n-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {\n-            @Override\n-            public void run(RunNotifier notifier) {\n-                when(mock.simpleMethod()).thenReturn(\"foo\");\n-                \n-                notifier.fireTestFinished(null);\n-                \n-                assertEquals(\"\", loggerStub.getLoggedInfo());\n-            }\n-        });\n-        \n-        runner.run(notifier);\n-    }\n-    \n-    public void shouldClearDebuggingDataAfterwards() throws Exception {\n-        //given\n-        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n-\n-        runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {\n-            @Override\n-            public void run(RunNotifier notifier) {\n-                unusedStubbingThatQualifiesForWarning();\n-                notifier.fireTestFailure(null);\n-                assertTrue(debuggingInfo.hasData());\n-            }\n-        });\n-        \n-        //when\n-        runner.run(notifier);\n-        \n-        //then\n-        assertFalse(debuggingInfo.hasData());\n-    }    \n-    \n+    //TODO add sensible tests\n+       \n     @Test\n     public void shouldDelegateToGetDescription() throws Exception {\n         //given\n         assertEquals(expectedDescription, description);\n     }\n \n-    private void unusedStubbingThatQualifiesForWarning() {\n-        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n-    }\n-\n-    private void callUnstubbedMethodThatQualifiesForWarning() {\n-        mock.simpleMethod(456);\n-    }\n-    \n-    private void someStubbing() {\n-        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n-    }\n-    \n-    private void callStubbedMethodWithDifferentArgs() {\n-        mock.simpleMethod(10);\n-    }\n-    \n     public class MockitoLoggerStub extends MockitoLoggerImpl {\n         \n         StringBuilder loggedInfo = new StringBuilder();\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n \n     public static void assertContains(String sub, String string) {\n         assertTrue(\"\\n\" +\n-                \"This substing:\" +\n+                \"This substing:[\" +\n                 sub +\n-                \"\\n\" +\n-                \"should be inside of:\" +\n+                \"]\\n\" +\n+                \"should be inside of:[\" +\n                 string +\n-                \"\\n\"\n+                \"]\\n\"\n                 , string.contains(sub));\n     }\n ", "timestamp": 1266178753, "metainfo": ""}