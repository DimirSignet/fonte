{"sha": "d8b18f2e77c3f352677a6993225c4333b98d0481", "log": "add a new attribute to Mock annotation for serialization purpose and test it  Signed-off-by: Brice Dutheil <brice.dutheil@gmail.com>", "commit": "\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n \n     String name() default \"\";\n \n-    Class<?>[] extraInterfaces() default {};\n+    Class<?>[] extraInterfaces() default {};\n+    \n+    boolean serializable() default false;\n }\n--- a/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n+++ b/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n         } else {\n             mockSettings.name(annotation.name());\n         }\n+        if(annotation.serializable()){\n+        \tmockSettings.serializable();\n+        }\n \n         // see @Mock answer default value\n         mockSettings.defaultAnswer(annotation.answer().get());\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.matchers.Any;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings({\"unchecked\", \"serial\"})\n+public class MocksSerializationForAnnotationTest extends TestBase implements Serializable {\n+\n+    private static final long serialVersionUID = 6160482220413048624L;\n+\n+    @Mock Any any;\n+    @Mock(serializable=true) Bar barMock;\n+    @Mock(serializable=true) IMethods imethodsMock;\n+    @Mock(serializable=true) IMethods imethodsMock2;\n+    @Mock(serializable=true) Any anyMock;\n+    @Mock(serializable=true) AlreadySerializable alreadySerializableMock;\n+    @Mock(extraInterfaces={List.class},serializable=true) IMethods imethodsWithExtraInterfacesMock;\n+    \n+    @Test\n+    public void should_allow_throws_exception_to_be_serializable() throws Exception {\n+        // given\n+        when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));\n+\n+        //when-serialize then-deserialize\n+        serializeAndBack(barMock);\n+    }\n+    \n+    @Test\n+    public void should_allow_mock_to_be_serializable() throws Exception {\n+        // when-serialize then-deserialize\n+        serializeAndBack(imethodsMock);\n+    }\n+\n+    @Test\n+    public void should_allow_mock_and_boolean_value_to_serializable() throws Exception {\n+        // given\n+        when(imethodsMock.booleanReturningMethod()).thenReturn(true);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertTrue(readObject.booleanReturningMethod());\n+    }\n+\n+    @Test\n+    public void should_allow_mock_and_string_value_to_be_serializable() throws Exception {\n+        // given\n+        String value = \"value\";\n+        when(imethodsMock.stringReturningMethod()).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.stringReturningMethod());\n+    }\n+\n+    @Test\n+    public void should_all_mock_and_serializable_value_to_be_serialized() throws Exception {\n+        // given\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectReturningMethodNoArgs()).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectReturningMethodNoArgs());\n+    }\n+\n+    @Test\n+    public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(value)).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectArgMethod(value));\n+    }\n+\n+    @Test\n+    public void should_serialize_method_calls_using_any_string_matcher() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectArgMethod(\"\"));\n+    }\n+\n+    @Test\n+    public void should_verify_called_n_times_for_serialized_mock() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);\n+        imethodsMock.objectArgMethod(\"\");\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        verify(readObject, times(1)).objectArgMethod(\"\");\n+    }\n+\n+    @Test\n+    public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {\n+\n+        // when\n+    \timethodsMock.simpleMethod(1);\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        readObject.simpleMethod(1);\n+\n+        // then\n+        verify(readObject, times(2)).simpleMethod(1);\n+\n+        //this test is working because it seems that java serialization mechanism replaces all instances\n+        //of serialized object in the object graph (if there are any)\n+    }\n+\n+    class Bar implements Serializable {\n+        Foo foo;\n+\n+        public Foo doSomething() {\n+            return foo;\n+        }\n+    }\n+\n+    class Foo implements Serializable {\n+        Bar bar;\n+        Foo() {\n+            bar = new Bar();\n+            bar.foo = this;\n+        }\n+    }\n+\n+    @Test\n+    public void should_serialization_work() throws Exception {\n+        //given\n+        Foo foo = new Foo();\n+        //when\n+        foo = serializeAndBack(foo);\n+        //then\n+        assertSame(foo, foo.bar.foo);\n+    }\n+\n+    @Test\n+    public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {\n+        //given\n+        // when\n+        when(imethodsMock.simpleMethod(1)).thenReturn(\"foo\");\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        when(readObject.simpleMethod(2)).thenReturn(\"bar\");\n+\n+        // then\n+        assertEquals(\"foo\", readObject.simpleMethod(1));\n+        assertEquals(\"bar\", readObject.simpleMethod(2));\n+    }\n+\n+    @Test\n+    public void should_verify_call_order_for_serialized_mock() throws Exception {\n+        imethodsMock.arrayReturningMethod();\n+        imethodsMock2.arrayReturningMethod();\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+        ByteArrayOutputStream serialized2 = serializeMock(imethodsMock2);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        IMethods readObject2 = deserializeMock(serialized2, IMethods.class);\n+        InOrder inOrder = inOrder(readObject, readObject2);\n+        inOrder.verify(readObject).arrayReturningMethod();\n+        inOrder.verify(readObject2).arrayReturningMethod();\n+    }\n+\n+    @Test\n+    public void should_remember_interactions_for_serialized_mock() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);\n+        imethodsMock.objectArgMethod(\"happened\");\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        verify(readObject, never()).objectArgMethod(\"never happened\");\n+    }\n+\n+    @Test\n+    public void should_serialize_with_stubbing_callback() throws Exception {\n+\n+        // given\n+        CustomAnswersMustImplementSerializableForSerializationToWork answer = \n+            new CustomAnswersMustImplementSerializableForSerializationToWork();\n+        answer.string = \"return value\";\n+        when(imethodsMock.objectArgMethod(anyString())).thenAnswer(answer);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(answer.string, readObject.objectArgMethod(\"\"));\n+    }\n+\n+    class CustomAnswersMustImplementSerializableForSerializationToWork \n+        implements Answer<Object>, Serializable {\n+        private String string;\n+        public Object answer(InvocationOnMock invocation) throws Throwable {\n+            invocation.getArguments();\n+            invocation.getMock();\n+            return string;\n+        }\n+    }\n+    \n+    public void should_serialize_with_real_object_spy() throws Exception {\n+        // given\n+        List<Object> list = new ArrayList<Object>();\n+        List<Object> spy = mock(ArrayList.class, withSettings()\n+                        .spiedInstance(list)\n+                        .defaultAnswer(CALLS_REAL_METHODS)\n+                        .serializable());\n+        when(spy.size()).thenReturn(100);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(spy);\n+\n+        // then\n+        List<?> readObject = deserializeMock(serialized, List.class);\n+        assertEquals(100, readObject.size());\n+    }\n+\n+    @Test\n+    public void should_serialize_object_mock() throws Exception {\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(any);\n+\n+        // then\n+        deserializeMock(serialized, Any.class);\n+    }\n+    \n+    @Test\n+    public void should_serialize_real_partial_mock() throws Exception {\n+        // given\n+        when(anyMock.matches(anyObject())).thenCallRealMethod();\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(anyMock);\n+\n+        // then\n+        Any readObject = deserializeMock(serialized, Any.class);\n+        readObject.matches(\"\");\n+    }\n+\n+    class AlreadySerializable implements Serializable {}\n+\n+    @Test\n+    public void should_serialize_already_serializable_class() throws Exception {\n+        // given\n+        when(alreadySerializableMock.toString()).thenReturn(\"foo\");\n+\n+        // when\n+        alreadySerializableMock = serializeAndBack(alreadySerializableMock);\n+\n+        // then\n+        assertEquals(\"foo\", alreadySerializableMock.toString());\n+    }\n+    \n+    @Test\n+    public void should_be_serialize_and_have_extra_interfaces() throws Exception {\n+        //then\n+        serializeAndBack((List) imethodsWithExtraInterfacesMock);\n+    }\n+    \n+    public static class FailTestClass{\n+    \t@Mock(serializable=true) Observable observable;\n+    }\n+    \n+    @Test\n+    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+        try {\n+        \tMockitoAnnotations.initMocks(new FailTestClass());\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(Observable.class.getSimpleName()).contains(\"serializable()\").contains(\"implement Serializable\");\n+        }\n+    }\n+}", "timestamp": 1350984733, "metainfo": ""}