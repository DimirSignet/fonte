{"sha": "6c0209f4208d8db935e760835bc8d064b23d97fc", "log": "More work on javadocs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401455", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n import org.mockito.stubbing.Answer;\n \n /**\n- * @author SG0897539\n- *\n+ * Allows mock creation with additional mock settings. \n+ * <p>\n+ * Don't use it too often. \n+ * Consider writing simple tests that use simple mocks. \n+ * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n+ * If you cannot write a test in a simple way - refactor the code under test.\n+ * <p>\n+ * Examples of mock settings:\n+ * <pre>\n+ *   //Creates mock with different default answer & name\n+ *   Foo mock = mock(Foo.class, withSettings()\n+ *       .defaultAnswer(RETURNS_SMART_NULLS)\n+ *       .name(\"cool mockie\"));\n+ *       \n+ *   //Creates mock with different default answer, descriptive name and extra interfaces\n+ *   Foo mock = mock(Foo.class, withSettings()\n+ *       .defaultAnswer(RETURNS_SMART_NULLS)\n+ *       .name(\"cool mockie\")\n+ *       .extraInterfaces(Bar.class));    \n+ * </pre>\n+ * {@link MockSettings} has been introduced for two reasons. \n+ * Firstly, to make it easy to add another mock setting when the demand comes.\n+ * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n  */\n public interface MockSettings {\n-    //TODO: validate javadoc\n     \n     /**\n      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n      *   Baz baz = (Baz) foo;\n      * </pre>\n      * \n-     * \n      * @param interfaces extra interfaces the should implement.\n-     * @return settings instance so that you can fluently specify other settings \n+     * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings extraInterfaces(Class<?>... interfaces);\n \n      */\n     MockSettings name(String name);\n \n-    MockSettings spiedInstance(Object object);\n+    /**\n+     * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n+     * <p>\n+     * As usual you are going to read the partial mock warning:\n+     * Object oriented programming is more less tackling complexity by dividing the complexity and moving it to specific objects.\n+     * Partial mock is a sign that the code is not well designed. \n+     * It usually means that the complexity has been moved to a different method on the same object.\n+     * Partial mocks are useful when dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * I wouldn't use them for new code.\n+     * <p>\n+     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n+     * <pre>\n+     *   Foo foo = mock(Foo.class, spiedInstance(fooInstance));\n+     *   \n+     *   //Below does exactly the same:\n+     *   Foo foo = spy(fooInstance);\n+     * </pre>\n+     * \n+     * @param instance to spy on\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings spiedInstance(Object instance);\n \n+    /**\n+     * Specifies default answers to interactions. \n+     * It's quite advanced feature and typically you don't need it to write decent tests.\n+     * However it can be helpful when working with legacy systems.\n+     * <p>\n+     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n+     *\n+     * <pre>\n+     *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n+     *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n+     *   \n+     *   //Below does exactly the same:\n+     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n+     * </pre>\n+     * \n+     * @param defaultAnswer default answer to be used by mock when not stubbed\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n     @SuppressWarnings(\"unchecked\")\n-    //it's ok to supress it because having raw Answer here it makes nicer for clients \n     MockSettings defaultAnswer(Answer defaultAnswer);\n-    \n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n-\n \n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.MockSettingsImpl;\n  * It's quite advanced feature and typically you don't need it to write decent tests.\n  * However, it can be helpful for working with <b>legacy systems</b>.\n  * <p>\n- * Obviously those return values are used <b>only</b> when you don't stub the method call.\n+ * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n  * \n  * <pre>\n  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n      * The default Answer of every mock <b>if</b> the mock was not stubbed. \n      * Typically it just returns some empty value. \n      * <p>\n-     * {@link Answer} cab be used to define the return values of unstubbed invocations. \n+     * {@link Answer} can be used to define the return values of unstubbed invocations. \n      * <p>\n      * This implementation first tries the global configuration. \n      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * <p>\n-     * {@link Answer} cab be used to define the return values of unstubbed invocations.\n+     * {@link Answer} can be used to define the return values of unstubbed invocations.\n      * <p>\n      * This implementation can be helpful when working with legacy code.\n      * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * <p>\n-     * {@link Answer} cab be used to define the return values of unstubbed invocations.\n+     * {@link Answer} can be used to define the return values of unstubbed invocations.\n      * <p>\n      * This implementation can be helpful when working with legacy code. \n      * <p>\n      * \n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * <p>\n-     * {@link Answer} cab be used to define the return values of unstubbed invocations.\n+     * {@link Answer} can be used to define the return values of unstubbed invocations.\n      * <p>\n      * This implementation can be helpful when working with legacy code.\n      * When this implementation is used, unstubbed methods will delegate to the real implementation.\n      * <p>\n      * Creates mock with a specified strategy for its return values. \n      * It's quite advanced feature and typically you don't need it to write decent tests.\n-     * However it can be helpful for working with legacy systems.\n+     * However it can be helpful when working with legacy systems.\n      * <p>\n      * Obviously return values are used only when you don't stub the method call.\n      *\n     /**\n      * Creates mock with a specified strategy for its answers to interactions. \n      * It's quite advanced feature and typically you don't need it to write decent tests.\n-     * However it can be helpful for working with legacy systems.\n-     * <p>\n-     * Obviously the answer is used only when you <b>don't</b> stub the method call.\n+     * However it can be helpful when working with legacy systems.\n+     * <p>\n+     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n      *\n      * <pre>\n      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n      * <p>See examples in javadoc for {@link Mockito} class</p>\n      * \n      * @param classToMock class or interface to mock\n-     * @param defaultAnswer default return values for unstubbed methods\n+     * @param defaultAnswer default answer for unstubbed methods\n      *\n      * @return mock object\n      */\n--- a/src/org/mockito/configuration/IMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/IMockitoConfiguration.java\n     ReturnValues getReturnValues();\n     \n     /**\n-     * Allows configuring the default return values of unstubbed invocations\n+     * Allows configuring the default answers of unstubbed invocations\n      * <p>\n      * See javadoc for {@link IMockitoConfiguration}\n      */    \n--- a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n+/**\n+ * Optional Answer that adds partial mocking support\n+ * <p>\n+ * {@link Answer} can be used to define the return values of unstubbed invocations.\n+ * <p>\n+ * This implementation can be helpful when working with legacy code.\n+ * When this implementation is used, unstubbed methods will delegate to the real implementation.\n+ * This is a way to create a partial mock object that calls real methods by default.\n+ * <p>\n+ */\n public class CallsRealMethods implements Answer<Object> {\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return invocation.callRealMethod();\n     }\n-}\n+}", "timestamp": 1243288865, "metainfo": ""}