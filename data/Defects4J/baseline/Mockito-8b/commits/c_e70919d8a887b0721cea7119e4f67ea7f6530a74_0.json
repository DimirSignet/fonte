{"sha": "e70919d8a887b0721cea7119e4f67ea7f6530a74", "log": "Allow delegateTo to delegate to any class that has the required methods  Fixes #112, Pull request: #116", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.stubbing.Answer;\n-\n import java.io.Serializable;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n \n /**\n  * Internal answer to forward invocations on a real instance.\n  * @since 1.9.5\n  */\n public class ForwardsInvocations implements Answer<Object>, Serializable {\n+    private static final long serialVersionUID = -8343690268123254910L;\n \n-\tprivate static final long serialVersionUID = -8343690268123254910L;\n+    private Object delegatedObject = null ;\n \n-\tprivate Object delegatedObject = null ;\n+    public ForwardsInvocations(Object delegatedObject) {\n+        this.delegatedObject = delegatedObject ;\n+    }\n \n-\tpublic ForwardsInvocations(Object delegatedObject) {\n-\t\tthis.delegatedObject = delegatedObject ;\n-\t}\n-\n-\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\n-\t\tMethod method = invocation.getMethod() ;\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        Method mockMethod = invocation.getMethod();\n \n         try {\n-            return method.invoke(delegatedObject, invocation.getArguments());\n+            Method delegateMethod = getDelegateMethod(mockMethod);\n+            \n+            if (!compatibleReturnTypes(mockMethod.getReturnType(), delegateMethod.getReturnType())) {\n+                throw new MockitoException(\"Incompatible return type on delegate method: \" + delegateMethod);\n+            }\n+            \n+            return delegateMethod.invoke(delegatedObject, invocation.getArguments());\n+        } catch (NoSuchMethodException e) {\n+            throw new MockitoException(\"Method not found on delegate: \" + mockMethod, e);\n         } catch (InvocationTargetException e) {\n             // propagate the original exception from the delegate\n             throw e.getCause();\n         }\n     }\n-}\n+\n+    private Method getDelegateMethod(Method mockMethod) throws NoSuchMethodException {\n+        if (mockMethod.getDeclaringClass().isAssignableFrom(delegatedObject.getClass())) {\n+            // Compatible class. Return original method.\n+            return mockMethod;\n+        } else {\n+            // Return method of delegate object with the same signature as mockMethod.\n+            return delegatedObject.getClass().getMethod(mockMethod.getName(), mockMethod.getParameterTypes());\n+        }\n+    }\n+\n+    private static boolean compatibleReturnTypes(Class<?> superType, Class<?> subType) {\n+        return superType.equals(subType) || superType.isAssignableFrom(subType);\n+    }\n+}\n--- a/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n \n import org.junit.Test;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitousage.MethodsImpl;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n \n import static junit.framework.Assert.assertEquals;\n \n @SuppressWarnings(\"unchecked\")\n public class StubbingWithDelegate {\n-\n+   public class FakeList<T> {\n+        private T value;\n+        \n+        public T get(int i) {\n+            return value;\n+        }\n+        \n+        public T set(int i, T value) {\n+            T oldValue = value;\n+            this.value = value;\n+            return oldValue;\n+        }\n+        \n+        public int size() {\n+            return 10;\n+        }\n+        \n+        public ArrayList<T> subList(int fromIndex, int toIndex) {\n+            return new ArrayList<>();\n+        }\n+    }\n+    \n+    public class FakeListWithWrongMethods<T> {\n+        public double size() {\n+            return 10;\n+        }\n+        \n+        public Collection<T> subList(int fromIndex, int toIndex) {\n+            return new ArrayList<>();\n+        }\n+    }\n+\t\n \t@Test\n \tpublic void when_not_stubbed_delegate_should_be_called() {\n \t\tList<String> delegatedList = new ArrayList<String>();\n             assertThat(e.toString()).doesNotContain(\"org.mockito\");\n         }\n     }\n+    \n+    @Test\n+    public void instance_of_different_class_can_be_called() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<>()));\n+        \n+        mock.set(1, \"1\");\n+        assertThat(mock.get(1).equals(\"1\"));\n+    }\n+    \n+    @Test\n+    public void method_with_subtype_return_can_be_called() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<>()));\n+        \n+        List<String> subList = mock.subList(0, 0);\n+        assertThat(subList.isEmpty());\n+    }\n+    \n+    @Test\n+    public void calling_missing_method_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeList<>()));\n+        \n+        try {\n+            mock.isEmpty();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Method not found on delegate\");\n+        }\n+    }\n+    \n+    @Test\n+    public void calling_method_with_wrong_primitive_return_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<>()));\n+        \n+        try {\n+            mock.size();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Incompatible return type on delegate method\");\n+        }\n+    }\n+    \n+    @Test\n+    public void calling_method_with_wrong_reference_return_should_throw_exception() {\n+        List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<>()));\n+        \n+        try {\n+            mock.subList(0, 0);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.toString()).contains(\"Incompatible return type on delegate method\");\n+        }\n+\t}\n \n     @Test\n     public void exception_should_be_propagated_from_delegate() throws Exception {", "timestamp": 1416072679, "metainfo": ""}