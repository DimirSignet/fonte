{"sha": "913b4982da55113eba0f67d334cefa7e29a4c4d2", "log": "Fixed issue 163 It is possible now to have multiple InOrders. BTW. you should not have multiple InOrders  because most likely you are doing something wrong in the code. However, in order to keep the api consistent I had to fix it.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401921", "commit": "\n--- a/src/org/mockito/internal/InOrderImpl.java\n+++ b/src/org/mockito/internal/InOrderImpl.java\n import org.mockito.InOrder;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.InOrderWrapper;\n import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n import org.mockito.verification.VerificationMode;\n \n /**\n  * Allows verifying in order. This class should not be exposed, hence default access.\n  */\n-class InOrderImpl implements InOrder {\n+public class InOrderImpl implements InOrder, InOrderContext {\n     \n     private final MockitoCore mockitoCore = new MockitoCore();\n     private final Reporter reporter = new Reporter();\n     private final List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n+    private final InOrderContext inOrderContext = new InOrderContextImpl();\n     \n+    public List<Object> getMocksToBeVerifiedInOrder() {\n+        return mocksToBeVerifiedInOrder;\n+    }\n+\n     public InOrderImpl(List<Object> mocksToBeVerifiedInOrder) {\n         this.mocksToBeVerifiedInOrder.addAll(mocksToBeVerifiedInOrder);\n     }\n         } else if (!(mode instanceof VerificationInOrderMode)) {\n             throw new MockitoException(mode.getClass().getSimpleName() + \" is not implemented to work with InOrder\");\n         }\n-        return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));\n+        return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));\n+    }\n+\n+    @Override\n+    public boolean isVerified(Invocation i) {\n+        return inOrderContext.isVerified(i);\n+    }\n+\n+    @Override\n+    public void markVerified(Invocation i) {        \n+        inOrderContext.markVerified(i);\n     }\n }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n \n     private final Location location;\n     private boolean verified;\n-    private boolean verifiedInOrder;\n \n     final RealMethod realMethod;\n     private StubInfo stubInfo;\n         return sequenceNumber;\n     }\n \n-    public boolean isVerifiedInOrder() {\n-        return verifiedInOrder;\n-    }\n-\n     public boolean equals(Object o) {\n         if (o == null || !o.getClass().equals(this.getClass())) {\n             return false;\n         return Arrays.equals(arguments, this.arguments);\n     }\n \n+    @Override\n     public int hashCode() {\n-        throw new RuntimeException(\"hashCode() is not implemented\");\n+        return 1;\n     }\n \n     public String toString() {\n         this.verified = true;\n     }\n \n-    void markVerifiedInOrder() {\n-        markVerified();\n-        this.verifiedInOrder = true;\n-    }\n-\n     public StubInfo stubInfo() {\n         return stubInfo;\n     }\n--- a/src/org/mockito/internal/invocation/InvocationMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationMarker.java\n package org.mockito.internal.invocation;\n \n import java.util.List;\n+\n+import org.mockito.internal.verification.api.InOrderContext;\n \n public class InvocationMarker {\n \n \t\twanted.captureArgumentsFrom(invocation);\n \t}\n \n-    public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted) {\n+    public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {\n         markVerified(chunk, wanted);\n         \n         for (Invocation i : chunk) {\n-            i.markVerifiedInOrder();\n+            context.markVerified(i);\n         }\n     }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.verification.api.InOrderContext;\n \n public class InvocationsFinder {\n \n         return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n     }\n \n-    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {\n-        List<Invocation> unverified = removeVerifiedInOrder(invocations);\n+    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {\n+        List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);\n         return ListUtil.filter(unverified, new RemoveNotMatching(wanted));\n     }\n \n      * \n      * if wanted is 1 and mode is times(x), where x != 2 then returns\n      * 1,1,1\n+     * @param data \n      */\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<Invocation> unverified = removeVerifiedInOrder(invocations);\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        List<Invocation> unverified = removeVerifiedInOrder(invocations, context);\n         List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n         \n         if (wantedCount != firstChunk.size()) {\n-            return this.findAllMatchingUnverifiedChunks(invocations, wanted);\n+            return this.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n         } else {\n             return firstChunk;\n         }\n         }\n     }\n     \n-    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations) {\n-        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder());\n+    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n+        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));\n         \n         if (verifiedOnly.isEmpty()) {\n             return null;\n         }\n     }\n     \n-    private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations) {\n+    private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {\n         List<Invocation> unverified = new LinkedList<Invocation>();\n         for (Invocation i : invocations) {\n-            if (i.isVerifiedInOrder()) {\n+            if (orderingContext.isVerified(i)) {\n                 unverified.clear();\n             } else {\n                 unverified.add(i);\n     }\n \n     private class RemoveUnverifiedInOrder implements Filter<Invocation> {\n+        private final InOrderContext orderingContext;\n+\n+        public RemoveUnverifiedInOrder(InOrderContext orderingContext) {\n+            this.orderingContext = orderingContext;\n+        }\n+\n         public boolean isOut(Invocation invocation) {\n-            return !invocation.isVerifiedInOrder();\n+            return !orderingContext.isVerified(invocation);\n         }\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/IdentitySet.java\n+package org.mockito.internal.util;\n+\n+import java.util.LinkedList;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class IdentitySet {\n+\n+    LinkedList list = new LinkedList();\n+    \n+    public boolean contains(Object o) {\n+        for(Object existing:list) {\n+            if (existing == o) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void add(Object o) {\n+        list.add(o);        \n+    }\n+}\n--- a/src/org/mockito/internal/verification/AtLeast.java\n+++ b/src/org/mockito/internal/verification/AtLeast.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n import org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsChecker;\n import org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker;\n         numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n     }\n     \n-    public void verifyInOrder(VerificationData data) {\n+    public void verifyInOrder(VerificationDataInOrder data) {\n         List<Invocation> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n-        AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker();\n+        AtLeastXNumberOfInvocationsInOrderChecker numberOfCalls = new AtLeastXNumberOfInvocationsInOrderChecker(data.getOrderingContext());\n         \n         if (wantedCount == 1) {\n-            missingInvocation.check(allInvocations, wanted, this);\n+            missingInvocation.check(allInvocations, wanted, this, data.getOrderingContext());\n         }\n         \n         numberOfCalls.check(allInvocations, wanted, wantedCount);\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return \"Wanted invocations count: at least \" + wantedCount;\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.IdentitySet;\n+import org.mockito.internal.verification.api.InOrderContext;\n+\n+public class InOrderContextImpl implements InOrderContext {\n+    \n+    final IdentitySet verified = new IdentitySet();\n+\n+    @Override\n+    public boolean isVerified(Invocation invocation) {\n+        return verified.contains(invocation);\n+    }\n+\n+    @Override\n+    public void markVerified(Invocation i) {\n+        verified.add(i);\n+    }\n+}\n--- a/src/org/mockito/internal/verification/InOrderWrapper.java\n+++ b/src/org/mockito/internal/verification/InOrderWrapper.java\n \n import java.util.List;\n \n+import org.mockito.internal.InOrderImpl;\n import org.mockito.internal.invocation.AllInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n import org.mockito.verification.VerificationMode;\n \n public class InOrderWrapper implements VerificationMode {\n \n     private final VerificationInOrderMode mode;\n-    private final List<Object> mocksToBeVerifiedInOrder;\n+    private final InOrderImpl inOrder;\n \n-    public InOrderWrapper(VerificationInOrderMode mode, List<Object> mocksToBeVerifiedInOrder) {\n+    public InOrderWrapper(VerificationInOrderMode mode, InOrderImpl inOrder) {\n         this.mode = mode;\n-        this.mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder;\n+        this.inOrder = inOrder;        \n     }\n \n     public void verify(VerificationData data) {\n-        List<Invocation> allInvocations = new AllInvocationsFinder().find(mocksToBeVerifiedInOrder);\n-        mode.verifyInOrder(new VerificationDataImpl(allInvocations, data.getWanted()));\n+        List<Invocation> allInvocations = new AllInvocationsFinder().find(inOrder.getMocksToBeVerifiedInOrder());\n+        VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl(inOrder, allInvocations, data.getWanted());\n+        mode.verifyInOrder(dataInOrder);\n     }\n-}\n+}\n--- a/src/org/mockito/internal/verification/Times.java\n+++ b/src/org/mockito/internal/verification/Times.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n import org.mockito.internal.verification.checkers.MissingInvocationChecker;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker;\n         numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n     }\n     \n-    public void verifyInOrder(VerificationData data) {\n+    public void verifyInOrder(VerificationDataInOrder data) {\n         List<Invocation> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         if (wantedCount > 0) {\n             MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n-            missingInvocation.check(allInvocations, wanted, this);\n+            missingInvocation.check(allInvocations, wanted, this, data.getOrderingContext());\n         }\n         NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();\n-        numberOfCalls.check(allInvocations, wanted, wantedCount);\n-    }\n+        numberOfCalls.check(allInvocations, wanted, wantedCount, data.getOrderingContext());\n+    }    \n     \n     @Override\n     public String toString() {\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/api/InOrderContext.java\n+package org.mockito.internal.verification.api;\n+\n+import org.mockito.internal.invocation.Invocation;\n+\n+public interface InOrderContext {\n+\n+    boolean isVerified(Invocation invocation);\n+\n+    void markVerified(Invocation i);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification.api;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+public interface VerificationDataInOrder {\n+\n+    List<Invocation> getAllInvocations();\n+\n+    InvocationMatcher getWanted();   \n+    \n+    InOrderContext getOrderingContext(); \n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n+package org.mockito.internal.verification.api;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+public class VerificationDataInOrderImpl implements VerificationDataInOrder {\n+\n+    private final InOrderContext inOrder;\n+    private final List<Invocation> allInvocations;\n+    private final InvocationMatcher wanted;\n+\n+    public VerificationDataInOrderImpl(InOrderContext inOrder, List<Invocation> allInvocations, InvocationMatcher wanted) {\n+        this.inOrder = inOrder;\n+        this.allInvocations = allInvocations;\n+        this.wanted = wanted;        \n+    }\n+\n+    @Override\n+    public List<Invocation> getAllInvocations() {\n+        return allInvocations;\n+    }\n+\n+    @Override\n+    public InOrderContext getOrderingContext() {\n+        return inOrder;\n+    }\n+\n+    @Override\n+    public InvocationMatcher getWanted() {\n+        return wanted;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/verification/api/VerificationInOrderMode.java\n+++ b/src/org/mockito/internal/verification/api/VerificationInOrderMode.java\n package org.mockito.internal.verification.api;\n \n public interface VerificationInOrderMode {\n-\n-    void verifyInOrder(VerificationData data);\n     \n+    void verifyInOrder(VerificationDataInOrder data);    \n }\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.verification.api.InOrderContext;\n \n public class AtLeastXNumberOfInvocationsInOrderChecker {\n     \n     private final Reporter reporter = new Reporter();\n     private final InvocationsFinder finder = new InvocationsFinder();\n     private final InvocationMarker invocationMarker = new InvocationMarker();\n+    private final InOrderContext orderingContext;\n     \n+    public AtLeastXNumberOfInvocationsInOrderChecker(InOrderContext orderingContext) {\n+        this.orderingContext = orderingContext;\n+    }\n+\n     public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n+        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);\n         \n         int actualCount = chunk.size();\n         \n             reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n         }\n         \n-        invocationMarker.markVerifiedInOrder(chunk, wanted);\n+        invocationMarker.markVerifiedInOrder(chunk, wanted, orderingContext);\n     }\n }\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.reporting.SmartPrinter;\n+import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool;\n import org.mockito.verification.VerificationMode;\n \n         this.reporter = reporter;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n-        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode, InOrderContext context) {\n+        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n         \n         if (!chunk.isEmpty()) {\n             return;\n         }\n         \n-        Invocation previousInOrder = finder.findPreviousVerifiedInOrder(invocations);\n+        Invocation previousInOrder = finder.findPreviousVerifiedInOrder(invocations, context);\n         if (previousInOrder == null) {\n             /**\n-             * It is ofcourse possible to have an issue where the arguments are different\n+             * It is of course possible to have an issue where the arguments are different\n              * rather that not invoked in order. Issue related to\n              * http://code.google.com/p/mockito/issues/detail?id=27. If the previous order\n              * is missing, then this method checks if the arguments are different or if the order\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.verification.api.InOrderContext;\n \n public class NumberOfInvocationsInOrderChecker {\n     \n         this.reporter = reporter;\n     }\n     \n-    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount, context);\n         \n         int actualCount = chunk.size();\n         \n             reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n-        invocationMarker.markVerifiedInOrder(chunk, wanted);\n+        invocationMarker.markVerifiedInOrder(chunk, wanted, context);\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/InOrderImplTest.java\n+package org.mockito.internal;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InOrderImplTest extends TestBase {\n+    \n+    @Mock IMethods mock;\n+    \n+    @Test\n+    public void shouldMarkVerifiedInOrder() throws Exception {\n+        //given\n+        InOrderImpl impl = new InOrderImpl((List) asList(mock));\n+        Invocation i = new InvocationBuilder().toInvocation();\n+        assertFalse(impl.isVerified(i));\n+        \n+        //when\n+        impl.markVerified(i);\n+        \n+        //then\n+        assertTrue(impl.isVerified(i));\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n \n import org.junit.Test;\n import org.mockito.internal.util.ObjectBox;\n+import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockitoutil.TestBase;\n \n public class InvocationMarkerTest extends TestBase {\n         //then\n         assertEquals(i, box.getObject());\n     }\n-\n+    \n     @Test\n     public void shouldMarkInvocationsAsVerifiedInOrder() {\n         //given\n+        InOrderContextImpl context = new InOrderContextImpl();\n         InvocationMarker marker = new InvocationMarker();\n         Invocation i = new InvocationBuilder().toInvocation();\n         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n-        assertFalse(i.isVerifiedInOrder());\n+        assertFalse(context.isVerified(i));\n         assertFalse(i.isVerified());\n         \n         //when\n-        marker.markVerifiedInOrder(Arrays.asList(i), im);\n+        marker.markVerifiedInOrder(Arrays.asList(i), im, context);\n         \n         //then\n-        assertTrue(i.isVerifiedInOrder());\n+        assertTrue(context.isVerified(i));\n         assertTrue(i.isVerified());\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     }\n     \n     @Test\n-    public void shouldNotBeACitizenOfHashes() {\n+    public void shouldBeACitizenOfHashes() {\n         Map map = new HashMap();\n-        try {\n-            map.put(invocation, \"one\");\n-            fail();\n-        } catch (RuntimeException e) {\n-            assertEquals(\"hashCode() is not implemented\", e.getMessage());\n-        }\n+        map.put(invocation, \"one\");\n+        assertEquals(\"one\", map.get(invocation));\n     }\n     \n     @Test\n                 \"    1\" +\n                 \"\\n\" +\n                 \");\"));\n-    }\n-    \n-    @Test\n-    public void shouldMarkVerifiedWhenMarkingVerifiedInOrder() throws Exception {\n-        assertFalse(invocation.isVerified());\n-        assertFalse(invocation.isVerifiedInOrder());\n-        \n-        invocation.markVerifiedInOrder();\n-        \n-        assertTrue(invocation.isVerified());\n-        assertTrue(invocation.isVerifiedInOrder());\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.verification.InOrderContextImpl;\n+import org.mockito.internal.verification.api.InOrderContext;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     private Invocation simpleMethodInvocationTwo;\n     private Invocation differentMethodInvocation;\n     private InvocationsFinder finder;\n+    InOrderContext context = new InOrderContextImpl();\n     \n     @Mock private IMethods mock;\n \n     \n     @Test\n     public void shouldFindAllMatchingUnverifiedChunks() throws Exception {\n-        List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n         assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n-        simpleMethodInvocation.markVerifiedInOrder();\n-        allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        context.markVerified(simpleMethodInvocation);\n+        allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n         assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocationTwo));\n         \n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n-        allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        context.markVerified(simpleMethodInvocationTwo);\n+        allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n         assertTrue(allMatching.isEmpty());\n     }\n     \n     @Test\n     public void shouldFindMatchingChunk() throws Exception {\n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n     \n         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n     public void shouldFindPreviousInOrder() throws Exception {\n-        Invocation previous = finder.findPreviousVerifiedInOrder(invocations);\n+        Invocation previous = finder.findPreviousVerifiedInOrder(invocations, context);\n         assertNull(previous);\n         \n-        simpleMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n+        context.markVerified(simpleMethodInvocation);\n+        context.markVerified(simpleMethodInvocationTwo);\n         \n-        previous = finder.findPreviousVerifiedInOrder(invocations);\n+        previous = finder.findPreviousVerifiedInOrder(invocations, context);\n         assertSame(simpleMethodInvocationTwo, previous);\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/IdentitySetTest.java\n+package org.mockito.internal.util;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+\n+\n+public class IdentitySetTest {\n+    \n+    IdentitySet set = new IdentitySet();\n+    \n+    @Test\n+    public void shouldWork() throws Exception {\n+        //when\n+        Object o = new Object();\n+        set.add(o);\n+\n+        //then\n+        assertTrue(set.contains(o));\n+        assertFalse(set.contains(new Object()));\n+    }\n+    \n+    class Fake {\n+        @Override\n+        public boolean equals(Object obj) {\n+            return true;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldWorkEvenIfEqualsTheSame() throws Exception {\n+        //given\n+        assertEquals(new Fake(), new Fake());\n+        Fake fake = new Fake();\n+        \n+        //when\n+        set.add(fake);\n+\n+        //then\n+        assertTrue(set.contains(fake));\n+        assertFalse(set.contains(new Fake()));\n+    }\n+\n+}\n--- a/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.verification.api.InOrderContext;\n \n class InvocationsFinderStub extends InvocationsFinder {\n     \n     List<Invocation> invocations;\n     \n     @Override\n-    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {\n+    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context) {\n         return allMatchingUnverifiedChunksToReturn;\n     }\n     \n     @Override\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         return validMatchingChunkToReturn;\n     }\n \n     }\n     \n     @Override\n-    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations) {\n+    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n         return previousInOrderToReturn;\n     }\n }\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.reporting.SmartPrinter;\n+import org.mockito.internal.verification.InOrderContextImpl;\n+import org.mockito.internal.verification.api.InOrderContext;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationInOrderCheckerTest extends TestBase {\n     private InvocationMatcher wanted;\n     private LinkedList<Invocation> invocations;\n     private InvocationsFinderStub finderStub;\n+    private InOrderContext context = new InOrderContextImpl();\n     \n     @Before\n     public void setup() {\n         Invocation actual = new InvocationBuilder().toInvocation();\n         finderStub.allMatchingUnverifiedChunksToReturn.add(actual);\n         \n-        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n     }\n     \n     @Test\n     public void shouldReportWantedButNotInvoked() throws Exception {\n         assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());\n-        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n         \n         assertEquals(wanted, reporterStub.wanted);\n     }\n     public void shouldReportArgumentsAreDifferent() throws Exception {\n         assertTrue(finderStub.findInvocations(invocations, wanted).isEmpty());\n         finderStub.similarToReturn = new InvocationBuilder().toInvocation();\n-        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n         SmartPrinter printer = new SmartPrinter(wanted, finderStub.similarToReturn, 0);\n         assertEquals(printer.getWanted(), reporterStub.wantedString);\n         assertEquals(printer.getActual(), reporterStub.actual);\n         Invocation previous = new InvocationBuilder().toInvocation();\n         finderStub.previousInOrderToReturn = previous;\n         \n-        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n         \n         assertEquals(wanted, reporterStub.wanted);\n         assertEquals(previous, reporterStub.previous);\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.InOrderContextImpl;\n+import org.mockito.internal.verification.api.InOrderContext;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsInOrderCheckerTest extends TestBase {\n     private InvocationMatcher wanted;\n     private LinkedList<Invocation> invocations;\n     private InvocationsFinderStub finderStub;\n+    private InOrderContext context = new InOrderContextImpl();\n     \n     @Before\n     public void setup() {\n     }\n     \n     @Test\n-    public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {\n+    public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {        \n         assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());\n-        checker.check(invocations, wanted, 0);\n+        checker.check(invocations, wanted, 0, context);\n     }\n     \n     @Test\n     public void shouldPassIfChunkMatches() throws Exception {\n         finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());\n         \n-        checker.check(invocations, wanted, 1);\n+        checker.check(invocations, wanted, 1, context);\n     }\n     \n     @Test\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n-            checker.check(invocations, wanted, 4);\n+            checker.check(invocations, wanted, 4, context);\n             fail();\n         } catch (VerificationInOrderFailure e) {\n             assertContains(\"Wanted 4 times\", e.getMessage());\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n-            checker.check(invocations, wanted, 1);\n+            checker.check(invocations, wanted, 1, context);\n             fail();\n         } catch (VerificationInOrderFailure e) {\n             assertContains(\"Wanted 1 time\", e.getMessage());\n     @Test\n     public void shouldMarkAsVerifiedInOrder() throws Exception {\n         Invocation invocation = new InvocationBuilder().toInvocation();\n-        assertFalse(invocation.isVerifiedInOrder());\n+        assertFalse(context.isVerified(invocation));\n         finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n         \n-        checker.check(invocations, wanted, 1);\n+        checker.check(invocations, wanted, 1, context);\n         \n-        assertTrue(invocation.isVerifiedInOrder());\n+        assertTrue(context.isVerified(invocation));\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/MultipleInOrdersTest.java\n+package org.mockitousage.bugs;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MultipleInOrdersTest {\n+    \n+    @Test\n+    public void inOrderTest(){\n+        List list= mock(List.class);\n+        \n+        list.add(\"a\");\n+        list.add(\"x\");\n+        list.add(\"b\");\n+        list.add(\"y\");\n+        \n+        InOrder inOrder = inOrder(list);\n+        InOrder inAnotherOrder = inOrder(list);\n+        assertNotSame(inOrder, inAnotherOrder);\n+        \n+        inOrder.verify(list).add(\"a\");\n+        inOrder.verify(list).add(\"b\");\n+        \n+        inAnotherOrder.verify(list).add(\"x\");\n+        inAnotherOrder.verify(list).add(\"y\");\n+    }\n+}\n--- a/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n import org.mockitoutil.TestBase;\n \n public class BasicVerificationInOrderTest extends TestBase {\n-    \n+\n     private IMethods mockOne;\n     private IMethods mockTwo;\n     private IMethods mockThree;\n         mockOne = mock(IMethods.class);\n         mockTwo = mock(IMethods.class);\n         mockThree = mock(IMethods.class);\n-        \n+\n         inOrder = inOrder(mockOne, mockTwo, mockThree);\n \n         mockOne.simpleMethod(1);\n         mockTwo.simpleMethod(2);\n         mockOne.simpleMethod(4);\n     }\n-    \n+\n     @Test\n     public void shouldVerifyInOrder() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         inOrder.verify(mockTwo).simpleMethod(2);\n         inOrder.verify(mockOne).simpleMethod(4);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-    } \n-    \n+    }\n+\n     @Test\n     public void shouldVerifyInOrderUsingAtLeastOnce() {\n         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         inOrder.verify(mockTwo).simpleMethod(2);\n         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(4);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-    } \n-    \n+    }\n+\n     @Test\n     public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n         inOrder.verify(mockOne, times(0)).oneArg(false);\n         inOrder.verify(mockOne).simpleMethod(4);\n         inOrder.verify(mockThree, times(0)).oneArg(false);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-    } \n-    \n+    }\n+\n     @Test\n     public void shouldFailWhenFirstMockCalledTwice() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         try {\n             inOrder.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailWhenLastMockCalledTwice() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         try {\n             inOrder.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n-    @Test(expected=VerificationInOrderFailure.class)\n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n+    @Test(expected = VerificationInOrderFailure.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n         inOrder.verify(mockOne, times(0)).simpleMethod(1);\n     }\n-    \n-    @Test(expected=VerificationInOrderFailure.class)\n+\n+    @Test(expected = VerificationInOrderFailure.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n         inOrder.verify(mockOne, times(2)).simpleMethod(1);\n     }\n-    \n+\n     @Test\n     public void shouldFailOnSecondMethodBecauseFourInvocationsWanted() {\n         inOrder.verify(mockOne, times(1)).simpleMethod(1);\n         try {\n             inOrder.verify(mockTwo, times(4)).simpleMethod(2);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n         inOrder.verify(mockOne, times(1)).simpleMethod(1);\n         try {\n             inOrder.verify(mockTwo, times(0)).simpleMethod(2);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }    \n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         try {\n             inOrder.verify(mockOne, times(0)).simpleMethod(4);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         try {\n             inOrder.verify(mockOne, times(2)).simpleMethod(4);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }    \n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     /* ------------- */\n-    \n-    @Test(expected=ArgumentsAreDifferent.class)\n+\n+    @Test(expected = ArgumentsAreDifferent.class)\n     public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n         inOrder.verify(mockOne).simpleMethod(100);\n     }\n-    \n-    @Test(expected=WantedButNotInvoked.class)\n+\n+    @Test(expected = WantedButNotInvoked.class)\n     public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n         inOrder.verify(mockOne).oneArg(true);\n     }\n-    \n+\n     @Test\n     public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         try {\n             inOrder.verify(mockTwo, times(2)).simpleMethod(-999);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n         inOrder.verify(mockOne, times(1)).simpleMethod(1);\n         try {\n             inOrder.verify(mockTwo, times(2)).oneArg(true);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }    \n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         try {\n             inOrder.verify(mockOne).simpleMethod(-666);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         try {\n             inOrder.verify(mockOne).oneArg(false);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }    \n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     /* -------------- */\n-    \n+\n     @Test\n     public void shouldFailWhenLastMethodVerifiedFirst() {\n         inOrder.verify(mockOne).simpleMethod(4);\n         try {\n             inOrder.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailWhenMiddleMethodVerifiedFirst() {\n         inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n         try {\n             inOrder.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailWhenMiddleMethodVerifiedFirstInAtLeastOnceMode() {\n         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n         try {\n             inOrder.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationInOrderFailure e) {}\n-    }\n-    \n+        } catch (VerificationInOrderFailure e) {\n+        }\n+    }\n+\n     @Test\n     public void shouldFailOnVerifyNoMoreInteractions() {\n         inOrder.verify(mockOne).simpleMethod(1);\n         inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n         inOrder.verify(mockThree).simpleMethod(3);\n         inOrder.verify(mockTwo).simpleMethod(2);\n-        \n+\n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (NoInteractionsWanted e) {}\n-    } \n-    \n-    @Test(expected=NoInteractionsWanted.class)\n+        } catch (NoInteractionsWanted e) {\n+        }\n+    }\n+\n+    @Test(expected = NoInteractionsWanted.class)\n     public void shouldFailOnVerifyZeroInteractions() {\n         verifyZeroInteractions(mockOne);\n     }\n-    \n+\n     @SuppressWarnings(\"all\")\n-    @Test(expected=MockitoException.class)\n+    @Test(expected = MockitoException.class)\n     public void shouldScreamWhenNullPassed() {\n         inOrder(null);\n     }", "timestamp": 1268601730, "metainfo": ""}