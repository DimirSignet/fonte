{"sha": "15dbf27d9f211bf591f7c35198c833f977895964", "log": "massive checkin, did that stuff being offline for too long. Basically made strict verification lil'bit relaxed. loads of stuff left to clean up (TODOs).  --HG-- rename : src/org/mockito/internal/invocation/InvocationsChunker.java => src/org/mockito/internal/invocation/Chunker.java rename : test/org/mockito/internal/invocation/InvocationsChunkerTest.java => test/org/mockito/internal/invocation/ChunkerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40229", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.cause.FirstUndesiredInvocation;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n import org.mockito.exceptions.verification.VerificationError;\n-import org.mockito.exceptions.verification.WrongOrderVerificationError;\n \n /**\n  * Reports verification and misusing errors.\n     }\n \n     public void tooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n-        FirstUndesiredInvocation cause = new FirstUndesiredInvocation(join(\"First undesired invocation:\"));\n+        UndesiredInvocation cause = new UndesiredInvocation(join(\"Undesired invocation:\"));\n         cause.setStackTrace(firstUndesired.getStackTrace());\n \n         throw new TooManyActualInvocationsError(join(\n     }\n \n     public void noMoreInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n-        UndesiredInvocation cause = buildUndesiredInvocationCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n+        UndesiredInvocation cause = new UndesiredInvocation(join(\n+                \"Undesired invocation:\", \n+                undesired\n+        ));\n+        \n+        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n         throw new NoInteractionsWantedError(join(\"No interactions wanted\"), cause);\n-    }\n-\n-    private UndesiredInvocation buildUndesiredInvocationCause(HasStackTrace actualInvocationStackTrace, String ... messageLines) {\n-        UndesiredInvocation cause = new UndesiredInvocation(join(messageLines));\n-        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n-        return cause;\n     }\n \n     public void unfinishedStubbing() {\n                 \"Should be something like that: verify(mock).doSomething()\"\n         ));\n     }\n-\n-    public void wrongOrderOfInvocations(HasStackTrace actual) {\n-        RuntimeException cause = new RuntimeException();\n-        cause.setStackTrace(actual.getStackTrace());\n-        \n-        throw new WrongOrderVerificationError(join(\n-                \"Wrong order.\"\n-        ), cause);\n-    }\n }\n--- a/src/org/mockito/exceptions/verification/VerificationError.java\n+++ b/src/org/mockito/exceptions/verification/VerificationError.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n \n+//TODO WantedButNotInvoked\n /**\n  * Verification failed\n  */\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/WantedButNotInvokedError.java\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class WantedButNotInvokedError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public WantedButNotInvokedError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- a/src/org/mockito/internal/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n  */\n package org.mockito.internal;\n \n+import java.util.Comparator;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationsFinder;\n \n public class AllInvocationsFinder implements InvocationsFinder {\n     \n-    public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n-        List<Invocation> allInvocations = new LinkedList<Invocation>();\n+    public List<Invocation> getAllInvocations(List<? extends Object> mocks) {\n+        Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n         for (Object mock : mocks) {\n-            List<Invocation> invocationsOfSingleMock = MockUtil.getMockHandler(mock).getRegisteredInvocations();\n-            allInvocations.addAll(invocationsOfSingleMock);\n+            List<Invocation> fromSingleMock = MockUtil.getMockHandler(mock).getRegisteredInvocations();\n+            invocationsInOrder.addAll(fromSingleMock);\n         }\n-        return allInvocations;\n+        \n+        return new LinkedList<Invocation>(invocationsInOrder);\n     }\n-}\n+\n+    private final class SequenceNumberComparator implements Comparator<Invocation> {\n+        public int compare(Invocation o1, Invocation o2) {\n+            int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n+            assert comparison != 0 : \"sequence number has to be globally unique\";\n+            return comparison;\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.creation.MockAwareInterceptor;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsChunker;\n-import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n-import org.mockito.internal.verification.WrongOrderOfInvocationsVerifier;\n \n /**\n  * Invocation handler set on mock objects.\n     }\n     \n     private VerifyingRecorder createRecorder() {\n-        InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder());\n-        InvocationsMarker marker = new InvocationsMarker();\n         List<Verifier> verifiers = Arrays.asList(\n                 new MissingInvocationVerifier(),\n-                new WrongOrderOfInvocationsVerifier(),\n                 new NumberOfInvocationsVerifier(),\n                 new NoMoreInvocationsVerifier());\n-        return new VerifyingRecorder(chunker, marker, verifiers);\n+        return new VerifyingRecorder(new AllInvocationsFinder(), verifiers);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/ActualInvocationsFinder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+public class ActualInvocationsFinder {\n+\n+    private final Chunker chunker;\n+    \n+    public ActualInvocationsFinder() {\n+        this(new Chunker());\n+    }\n+    \n+    ActualInvocationsFinder(Chunker chunker) {\n+        this.chunker = chunker;\n+    }\n+\n+    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        if (mode.strictMode()) {\n+            return strictlyMatching(invocations, wanted, mode); \n+        } else {\n+            return nonStrictlyMatching(invocations, wanted);\n+        }\n+    }\n+\n+    private List<Invocation> strictlyMatching(List<Invocation> invocations, InvocationMatcher wanted,\n+            VerificationModeImpl mode) {\n+        List<ObjectsChunk<Invocation>> chunks = chunker.chunk(invocations, new MatchesWantedSeer(wanted));\n+        List<Invocation> firstMatching = new LinkedList<Invocation>(); \n+        for(ObjectsChunk<Invocation> chunk : chunks) {\n+            if (!wanted.matches(chunk.getObject())) {\n+                continue;\n+            }\n+            \n+            if (firstMatching.isEmpty()) {\n+                firstMatching.addAll(chunk.getObjects());\n+            }\n+                \n+            boolean chunkSizeMatches = mode.matchesActualCount(chunk.getSize());\n+            if (chunkSizeMatches) {\n+                return chunk.getObjects();\n+            }\n+        }\n+        return firstMatching;\n+    }\n+\n+    private List<Invocation> nonStrictlyMatching(List<Invocation> invocations, InvocationMatcher wanted) {\n+        List<Invocation> actual = new LinkedList<Invocation>();\n+        for (Invocation i : invocations) {\n+            if (wanted.matches(i)) {\n+                actual.add(i);\n+            }\n+        }\n+        return actual;\n+    }\n+    \n+    public List<Invocation> findStrictlyUnverifiedInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n+            VerificationModeImpl mode) {\n+        //TODO test or merge with strictlyMatching\n+        List<Invocation> unverified = new InvocationsAnalyzer().removeUntilLastStrictlyVerified(invocations);\n+        \n+        return this.findInvocations(unverified, wanted, mode);\n+    }\n+    \n+    private final class MatchesWantedSeer implements Chunker.ChunkSeer<Invocation> {\n+        private final InvocationMatcher wanted;\n+\n+        public MatchesWantedSeer(InvocationMatcher wanted) {\n+            this.wanted = wanted;\n+        }\n+        \n+        public boolean isSameChunk(Invocation previous, Invocation current) {\n+            return wanted.matches(previous) && wanted.matches(current);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/Chunker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class Chunker {\n+    \n+    /**\n+     * creates chunks of objects based on equality and consecutive factor, e.g:\n+     * <p>\n+     * if objects are [1,1,2,1,1] then there are 3 chunks: [1,1] [2] [1,1]\n+     */\n+    public <T> List<ObjectsChunk<T>> chunk(List<T> objects, ChunkSeer<T> chunkSeer) {\n+        LinkedList<ObjectsChunk<T>> chunks = new LinkedList<ObjectsChunk<T>>();\n+        T previous = null;\n+        for (T current : objects) {\n+            if (previous == null) {\n+                chunks.add(new ObjectsChunk<T>(current));\n+                previous = current;\n+                continue;\n+            } \n+            \n+            if (chunkSeer.isSameChunk(previous, current)) {\n+                chunks.getLast().addObject(current);\n+            } else {\n+                chunks.add(new ObjectsChunk<T>(current));\n+            }\n+\n+            previous = current;\n+        }\n+\n+        return chunks;\n+    }\n+    \n+    static interface ChunkSeer<T> {\n+        boolean isSameChunk(T previous, T current);\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         return mockName + \".\" + methodName + arguments;\n     }\n \n-    public String toStringWithSequenceNumber() {\n-        return toStringWithSequenceNumber(argumentsToMatchers());\n-    }\n-\n-    public String toStringWithSequenceNumber(List<IArgumentMatcher> matchers) {\n-        String mockName = MockNamer.nameForMock(mock);\n-        String methodName = method.getName();\n-        String arguments = getArgumentsString(matchers);\n-        \n-        return mockName + \"#\" + sequenceNumber + \".\" + methodName + arguments;\n-    }\n-    \n     public String toStringWithArgumentTypes() {\n         StringBuilder result = new StringBuilder();\n         result.append((MockNamer.nameForMock(mock) + \".\" + method.getName()));\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n         return invocation.toString(matchers);\n     }\n     \n-    public String toStringWithSequenceNumber() {\n-        return invocation.toStringWithSequenceNumber(matchers);\n-    }\n-    \n     public String toStringWithArgumentTypes() {\n         return invocation.toStringWithArgumentTypes();\n     }\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n  */\n public class InvocationsAnalyzer {\n \n-    public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n-        int actual = 0;\n-        for (Invocation invocation : invocations) {\n-            if (wanted.matches(invocation)) {\n-                actual++;\n-            }\n-        }\n-\n-        return actual;\n-    }\n-\n-    public Invocation findActualInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n-        Invocation actualbyName = null;\n-        for (Invocation invocation : invocations) {\n+    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        List<Invocation> unverified = removeUntilLastStrictlyVerified(invocations);\n+        \n+        for (Invocation invocation : unverified) {\n             String wantedMethodName = wanted.getMethod().getName();\n             String currentMethodName = invocation.getMethod().getName();\n-            if (wantedMethodName.equals(currentMethodName) && !invocation.isVerified()) {\n-                actualbyName = invocation;\n-                break;\n+            \n+            boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n+            boolean isUnverified = !invocation.isVerified();\n+            boolean mockIsTheSame = wanted.getInvocation().getMock() == invocation.getMock();\n+            \n+            if (methodNameEquals && isUnverified && mockIsTheSame ) {\n+                return invocation;\n             }\n         }\n         \n-        return actualbyName != null ? actualbyName : findFirstUnverified(invocations);\n+        return findFirstUnverified(unverified, wanted.getInvocation().getMock());\n     }\n     \n     public Invocation findFirstUnverified(List<Invocation> invocations) {\n+        return findFirstUnverified(invocations, null);\n+    }\n+    \n+    Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {\n         for (Invocation i : invocations) {\n-            if (!i.isVerified()) {\n+            boolean mockIsValid = mock == null || mock == i.getMock();\n+            if (!i.isVerified() && mockIsValid) {\n                 return i;\n             }\n         }\n         }\n         throw new IllegalArgumentException(\"There are no undesired invocations!\");\n     }\n-\n-    public List<Invocation> findFirstMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted) {\n-        List<Invocation> chunk = new LinkedList<Invocation>();\n-        \n+    \n+    List<Invocation> removeUntilLastStrictlyVerified(List<Invocation> invocations) {\n+        List<Invocation> unverified = new LinkedList<Invocation>();\n         for (Invocation i : invocations) {\n-            if (wanted.matches(i)) {\n-                chunk.add(i);\n-            } else if (!chunk.isEmpty()) {\n-                break;\n+            if (i.isVerifiedStrictly()) {\n+                unverified.clear();\n+            } else {\n+                unverified.add(i);\n             }\n         }\n-        \n-        return chunk;\n+        return unverified;\n     }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n \n public interface InvocationsFinder {\n \n-    List<Invocation> allInvocationsInOrder(List<Object> mocks);\n+    /**\n+     * gets all invocations from mocks. Invocations are ordered earlier first. \n+     * \n+     * @param mocks\n+     * @return\n+     */\n+    List<Invocation> getAllInvocations(List<? extends Object> mocks);\n }\n--- a/src/org/mockito/internal/invocation/InvocationsPrinter.java\n+++ b/src/org/mockito/internal/invocation/InvocationsPrinter.java\n     private final String wanted;\n     private final String actual;\n \n+    //TODO use it in other situations also!\n     public InvocationsPrinter(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n-        if (wantedInvocation.matchesButMocksAreDifferent(actualInvocation)) {\n-            wanted = wantedInvocation.toStringWithSequenceNumber();\n-            actual = actualInvocation.toStringWithSequenceNumber(); \n-        } else if (wantedInvocation.matchesMockArgsAndMethodNameButMethodNotEqual(actualInvocation)) {\n+        if (wantedInvocation.matchesMockArgsAndMethodNameButMethodNotEqual(actualInvocation)) {\n             wanted = wantedInvocation.toStringWithArgumentTypes();\n             actual = actualInvocation.toStringWithArgumentTypes();\n         } else {\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/ObjectsChunk.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class ObjectsChunk<T> {\n+    \n+    LinkedList<T> objects = new LinkedList<T>(); \n+\n+    public ObjectsChunk(T object) {\n+        objects.add(object);\n+    }\n+\n+    public int getSize() {\n+        return objects.size();\n+    }\n+\n+    public List<T> getObjects() {\n+        return objects;\n+    }\n+\n+    public T getObject() {\n+        return objects.getFirst();\n+    }\n+\n+    public void addObject(T object) {\n+        objects.add(object);\n+    }\n+}\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n         return wantedInvocationCount;\n     }\n \n-    public List<Object> getAllMocksToBeVerifiedStrictly() {\n+    public List<Object> getMocksToBeVerifiedStrictly() {\n         return mocksToBeVerifiedStrictly;\n     }\n \n-    public boolean wantedCountIsZero() {\n-        return wantedInvocationCount != null && wantedInvocationCount == 0;\n-    }\n+//    public boolean wantedCountIsZero() {\n+//        return wantedInvocationCount != null && wantedInvocationCount == 0;\n+//    }\n \n     public boolean atLeastOnceMode() {\n         return wantedInvocationCount == null && verification == Verification.EXPLICIT;\n         return !atLeastOnceMode() && explicitMode();\n     }\n     \n+    public boolean matchesActualCount(int actualCount) {\n+        boolean atLeastOnce = atLeastOnceMode() && actualCount > 0;\n+        boolean actualMatchesWanted = !atLeastOnceMode() && wantedInvocationCount == actualCount;\n+        \n+        return atLeastOnce || actualMatchesWanted;\n+    }\n+    \n     @Override\n     public String toString() {\n         return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedStrictly;\n     }\n+\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n     \n     private final Reporter reporter;\n     private final InvocationsAnalyzer analyzer;\n+    private final ActualInvocationsFinder finder;\n     \n     public MissingInvocationVerifier() {\n-        this(new InvocationsAnalyzer(), new Reporter());\n+        this(new InvocationsAnalyzer(), new ActualInvocationsFinder(), new Reporter());\n     }\n     \n-    public MissingInvocationVerifier(InvocationsAnalyzer analyzer, Reporter reporter) {\n+    public MissingInvocationVerifier(InvocationsAnalyzer analyzer, ActualInvocationsFinder finder, Reporter reporter) {\n         this.analyzer = analyzer;\n+        this.finder = finder;\n         this.reporter = reporter;\n     }\n \n             return;\n         }\n         \n-        //get list of actual invocations\n-        //if list is empty report\n-        //if not mark as verified\n+        List<Invocation> actualInvocations;\n+        if (mode.strictMode()) {\n+            //TODO test it\n+            //TODO push it to findInvocations\n+            actualInvocations = finder.findStrictlyUnverifiedInvocations(invocations, wanted, mode);\n+        } else {\n+            actualInvocations = finder.findInvocations(invocations, wanted, mode);\n+        }\n         \n-        int actualCount = analyzer.countActual(invocations, wanted);\n-        if (actualCount == 0) {\n-            reportMissingInvocationError(invocations, wanted);\n+        if (actualInvocations.size() == 0) {\n+            //TODO add test to check that invocations are passed here, not actual...\n+            Invocation similar = analyzer.findSimilarInvocation(invocations, wanted, mode);\n+            reportMissingInvocationError(wanted, similar);\n+        }\n+        \n+        for (Invocation invocation : actualInvocations) {\n+            invocation.markVerified();\n+            //TODO dodgy!\n+            if (mode.strictMode() && mode.atLeastOnceMode()) {\n+                invocation.markVerifiedStrictly();\n+            }\n         }\n     }\n-    \n-    private void reportMissingInvocationError(List<Invocation> invocations, InvocationMatcher wanted) {\n-        Invocation actual = analyzer.findActualInvocation(invocations, wanted);\n-        \n-        if (actual != null) {\n-            InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n-            reporter.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n+\n+    private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n+        if (similar != null) {\n+            //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n+            InvocationsPrinter printer = new InvocationsPrinter(wanted, similar);\n+            reporter.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), similar.getStackTrace());\n         } else {\n+            //TODO I really want a cause here, something like: \"wanted after...\"\n             reporter.wantedButNotInvoked(wanted.toString());\n         }\n     }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n     \n     private final Reporter reporter;\n     private final InvocationsAnalyzer analyzer;\n+    private final ActualInvocationsFinder finder;\n \n     public NumberOfInvocationsVerifier() {\n-        this(new Reporter(), new InvocationsAnalyzer());\n+        this(new Reporter(), new InvocationsAnalyzer(), new ActualInvocationsFinder());\n     }\n     \n-    NumberOfInvocationsVerifier(Reporter reporter, InvocationsAnalyzer analyzer) {\n+    NumberOfInvocationsVerifier(Reporter reporter, InvocationsAnalyzer analyzer, ActualInvocationsFinder finder) {\n         this.reporter = reporter;\n         this.analyzer = analyzer;\n+        this.finder = finder;\n     }\n     \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n             return;\n         }\n         \n-        //get list of actual invocations (first matching chunk if strictly)\n-        //if list size differs report\n-        //if not mark as verified\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted, mode);\n+        if (mode.strictMode()) {\n+            //TODO test it\n+            actualInvocations = finder.findStrictlyUnverifiedInvocations(invocations, wanted, mode);\n+        }\n         \n-        int actualCount = analyzer.countActual(invocations, wanted);\n+        int actualCount = actualInvocations.size();\n         int wantedCount = mode.wantedCount();\n         \n+        //TODO less/more methods on mode\n         if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(invocations, wanted);\n+            //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n+            HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(actualInvocations, wanted);\n             reporter.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n-            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, wanted, mode);\n+            //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n+            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(actualInvocations, wanted, mode);\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n+        }\n+        \n+        //TODO duplicated\n+        for (Invocation invocation : actualInvocations) {\n+            invocation.markVerified();\n+            if (mode.strictMode()) {\n+                invocation.markVerifiedStrictly();\n+            }\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsChunker;\n-import org.mockito.internal.invocation.InvocationsMarker;\n+import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class VerifyingRecorder {\n \n     private LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();\n-    \n-    private final InvocationsMarker marker;\n-    private final List<Verifier> verifiers;\n-    private final InvocationsChunker chunker;\n-    \n-    public VerifyingRecorder(InvocationsChunker chunker, InvocationsMarker marker, List<Verifier> verifiers) {\n-        this.chunker = chunker;\n-        this.marker = marker;  \n+\n+    private final List<? extends Verifier> verifiers;\n+    private final InvocationsFinder invocationsFinder;\n+\n+    public VerifyingRecorder(InvocationsFinder invocationsFinder, List<? extends Verifier> verifiers) {\n+        this.invocationsFinder = invocationsFinder;\n         this.verifiers = verifiers;\n     }\n-    \n+\n     public void recordInvocation(Invocation invocation) {\n         this.registeredInvocations.add(invocation);\n     }\n-    \n+\n     public void eraseLastInvocation() {\n         registeredInvocations.removeLast();\n     }\n     public List<Invocation> getRegisteredInvocations() {\n         return registeredInvocations;\n     }\n-    \n+\n     public void verify(VerificationModeImpl mode) {\n         verify(null, mode);\n     }\n-    \n+\n     public void verify(InvocationMatcher wanted, VerificationModeImpl mode) {\n-        List<Invocation> invocations = getInvocationsForEvaluation(mode);\n-        \n+        List<Invocation> invocations;\n+        if (mode.strictMode()) {\n+            invocations = invocationsFinder.getAllInvocations(mode.getMocksToBeVerifiedStrictly());\n+        } else {\n+            invocations = registeredInvocations;\n+        }\n+\n         for (Verifier verifier : verifiers) {\n             verifier.verify(invocations, wanted, mode);\n         }\n-        \n-        if (mode.explicitMode()) {\n-            marker.markInvocationsAsVerified(invocations, wanted, mode);\n-        }\n-    }\n-    \n-    private List<Invocation> getInvocationsForEvaluation(VerificationModeImpl mode) {\n-        if (mode.strictMode()) {\n-            return chunker.getFirstUnverifiedInvocationChunk(mode.getAllMocksToBeVerifiedStrictly());\n-        } else {\n-            return registeredInvocations;\n-        }\n     }\n }\n--- a/test/org/mockito/exceptions/base/StackTraceRemoverTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceRemoverTest.java\n  */\n package org.mockito.exceptions.base;\n \n-import static org.junit.Assert.assertThat;\n-import static org.mockito.util.ExtraMatchers.collectionHasExactlyInOrder;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import java.util.LinkedList;\n import java.util.List;\n         setStackTrace(\"commonOne\");\n         setCauseStackTrace(\"commonOne\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder());\n+        assertTrue(methodsOnTraceAfterRemoving.isEmpty());\n     }\n     \n     @Test\n--- /dev/null\n+++ b/test/org/mockito/internal/AllInvocationsFinderTest.java\n+package org.mockito.internal;\n+\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockitousage.IMethods;\n+\n+public class AllInvocationsFinderTest extends RequiresValidState {\n+    \n+    private AllInvocationsFinder finder;\n+    private IMethods mockTwo;\n+    private IMethods mockOne;\n+\n+    @Before\n+    public void setup() {\n+        finder = new AllInvocationsFinder();\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldGetAllInvocationsInOrder() throws Exception {\n+        mockOne.simpleMethod(100);\n+        mockTwo.simpleMethod(200);\n+        mockOne.simpleMethod(300);\n+        \n+        List<Invocation> invocations = finder.getAllInvocations(asList(mockOne, mockTwo));\n+        \n+        assertEquals(3, invocations.size());\n+        assertArgumentEquals(100, invocations.get(0));\n+        assertArgumentEquals(200, invocations.get(1));\n+        assertArgumentEquals(300, invocations.get(2));\n+    }\n+\n+    private void assertArgumentEquals(Object argumentValue, Invocation invocation) {\n+        assertEquals(argumentValue, invocation.getArguments()[0]);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/ActualInvocationsFinderTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+\n+\n+public class ActualInvocationsFinderTest extends RequiresValidState {\n+    \n+    private LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+    private ActualInvocationsFinder finder;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n+        invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n+        finder = new ActualInvocationsFinder();\n+    }\n+\n+    @Test\n+    public void shouldFindActualInvocations() throws Exception {\n+        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+        \n+        actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation), atLeastOnce());\n+        assertThat(actual, collectionHasExactlyInOrder(differentMethodInvocation));\n+    }\n+\n+    @Test\n+    public void shouldFindLastInvocationWhenModeIsOneTimeStrictly() throws Exception {\n+        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n+        invocations.add(lastSimpleMethodInvocation);\n+        \n+        List<Invocation> actual = finder.findInvocations(\n+                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().times(1).strict());\n+        assertThat(actual, collectionHasExactlyInOrder(lastSimpleMethodInvocation));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstTwoInvocationsWhenModeIsTwoTimesStrictly() throws Exception {\n+        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n+        invocations.add(lastSimpleMethodInvocation);\n+        \n+        List<Invocation> actual = finder.findInvocations(\n+                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().times(2).strict());\n+        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstMatchingChunkWhenWantedCountDoesNotMatch() throws Exception {\n+        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n+        invocations.add(lastSimpleMethodInvocation);\n+        \n+        List<Invocation> actual = finder.findInvocations(\n+                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().times(20).strict());\n+        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstTwoInvocationsWhenModeIsAtLeastOnceStrictly() throws Exception {\n+        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n+        invocations.add(lastSimpleMethodInvocation);\n+        \n+        List<Invocation> actual = finder.findInvocations(\n+                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().atLeastOnce().strict());\n+        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/ChunkerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+\n+public class ChunkerTest extends RequiresValidState {\n+\n+    private final class EqualitySeer implements Chunker.ChunkSeer<Integer> {\n+        public boolean isSameChunk(Integer previous, Integer current) {\n+            return previous.equals(current);\n+        }\n+    }\n+\n+    private Chunker chunker;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        chunker = new Chunker();\n+    }\n+\n+    @Test\n+    public void shouldChunkObjectLists() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 2, 3), new EqualitySeer());\n+        assertEquals(3, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1));\n+        assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2));\n+        assertThat(chunked.get(2).getObjects(), collectionHasExactlyInOrder(3));\n+    }\n+    \n+    @Test\n+    public void shouldChunkObjectListsAndFindDuplicates() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 1, 2, 2, 3, 3, 3, 3), new EqualitySeer());\n+        assertEquals(3, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1, 1));\n+        assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2, 2));\n+        assertThat(chunked.get(2).getObjects(), collectionHasExactlyInOrder(3, 3, 3, 3));\n+    }\n+    \n+    @Test\n+    public void shouldChunkWhenDuplicatesOnEdges() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 2, 3, 3), new EqualitySeer());\n+        assertEquals(3, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1));\n+        assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2));\n+        assertThat(chunked.get(2).getObjects(), collectionHasExactlyInOrder(3, 3));\n+    }\n+    \n+    @Test\n+    public void shouldChunkWhenDuplicatesInTheMiddle() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 2, 2, 3), new EqualitySeer());\n+        assertEquals(3, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1));\n+        assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2, 2));\n+        assertThat(chunked.get(2).getObjects(), collectionHasExactlyInOrder(3));\n+    }\n+    \n+    @Test\n+    public void shouldNotMergeDuplicatesThatAreNotConsecutive() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 2, 1, 1, 1), new EqualitySeer());\n+        assertEquals(3, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1));\n+        assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2));\n+        assertThat(chunked.get(2).getObjects(), collectionHasExactlyInOrder(1, 1, 1));\n+    }\n+    \n+    @Test\n+    public void shouldCreateSingleChunkForOneElementList() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1), new EqualitySeer());\n+        assertEquals(1, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1));\n+    }\n+    \n+    @Test\n+    public void shouldCreateSingleChunkOfSizeTwo() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1), new EqualitySeer());\n+        assertEquals(1, chunked.size());\n+        assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1));\n+    }\n+    \n+    @Test\n+    public void shouldCreateEmptyChunks() throws Exception {\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(Collections.<Integer>emptyList(), new EqualitySeer());\n+        assertEquals(0, chunked.size());\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n import java.util.Arrays;\n import java.util.LinkedList;\n-import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class InvocationsAnalyzerTest extends RequiresValidState {\n     \n-    private List<Invocation> invocations = new LinkedList<Invocation>();\n+    private LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n     private Invocation simpleMethodInvocation;\n     private Invocation simpleMethodInvocationTwo;\n     private Invocation differentMethodInvocation;\n     }\n     \n     @Test\n+    public void shouldFindFirstUnverifiedInvocationOnMock() throws Exception {\n+        assertSame(simpleMethodInvocation, analyzer.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));\n+        assertNull(analyzer.findFirstUnverified(invocations, \"different mock\"));\n+    }\n+    \n+    @Test\n     public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n         HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(0));\n         HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n-        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(2));\n+        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), times(2));\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n-        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(100));\n+        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), times(100));\n     }\n     \n     @Test\n-    public void shouldCountActualInvocations() throws Exception {\n-        int simpleInvocationCount = 2;\n-        assertEquals(simpleInvocationCount, analyzer.countActual(invocations, new InvocationMatcher(simpleMethodInvocation)));\n-        \n-        int differentInvocationCount = 1;\n-        assertEquals(differentInvocationCount, analyzer.countActual(invocations, new InvocationMatcher(differentMethodInvocation)));\n-    }\n-    \n-    @Test\n-    public void shouldFindActualInvocationByName() throws Exception {\n-        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+    public void shouldFindSimilarInvocationByName() throws Exception {\n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertSame(found, simpleMethodInvocation);\n     }\n     \n     @Test\n-    public void shouldFindActualUnverifiedInvocationByName() throws Exception {\n+    public void shouldFindSimilarUnverifiedInvocationByName() throws Exception {\n         simpleMethodInvocation.markVerified();\n-        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertSame(found, simpleMethodInvocationTwo);\n     }\n     \n     @Test\n-    public void shouldFindActualInvocationByGettingFirstUnverified() throws Exception {\n+    public void shouldFindSimilarInvocationByGettingFirstUnverified() throws Exception {\n         simpleMethodInvocation.markVerified();\n         simpleMethodInvocationTwo.markVerified();\n-        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertSame(found, differentMethodInvocation);\n     }\n     \n     @Test\n-    public void shouldNotFindActualInvocationBecauseAllAreVerified() throws Exception {\n+    public void shouldNotFindSimilarInvocationBecauseAllAreVerified() throws Exception {\n         simpleMethodInvocation.markVerified();\n         simpleMethodInvocationTwo.markVerified();\n         differentMethodInvocation.markVerified();\n         \n-        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertNull(found);\n+    }\n+    \n+    @Test\n+    public void shouldLookForSimilarInvocationsOnlyOnTheSameMock() throws Exception {\n+        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        invocations.addFirst(onDifferentMock);\n+        \n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertNotSame(onDifferentMock, found);\n+    }    \n+    \n+    @Test\n+    public void shouldReturnLastUnverifiedFromTheSameMockOnly() throws Exception {\n+        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        invocations.addFirst(onDifferentMock);\n+\n+        simpleMethodInvocation.markVerified();\n+        simpleMethodInvocationTwo.markVerified();\n+        \n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertNotSame(onDifferentMock, found);\n+    }  \n+    \n+    @Test\n+    public void shouldLookForSimilarOnlyAfterLastStrictlyVerified() throws Exception {\n+        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n+        \n+        simpleMethodInvocationTwo.markVerifiedStrictly();\n+        \n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), mode);\n+        assertSame(differentMethodInvocation, found);\n+    }\n+    \n+    @Test\n+    public void shouldFindSimilarAfterLastStrictlyVerified() throws Exception {\n+        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n+        \n+        Invocation lastInvocation = new InvocationBuilder().simpleMethod().toInvocation();\n+        invocations.add(lastInvocation);\n+        \n+        simpleMethodInvocationTwo.markVerifiedStrictly();\n+        \n+        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), mode);\n+        assertSame(found, lastInvocation);\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n         \n         assertEquals(\"Object.simpleMethod()\", printer.printWanted());\n         assertEquals(\"Object.differentMethod()\", printer.printActual());\n-    }\n-    \n-    @Test\n-    public void shouldPrintSequenceNumberWhenInvocationMatchesButMocksAreDifferent() throws Exception {\n-        InvocationMatcher mockOneMethod = new InvocationBuilder().mock(\"mockOne\").seq(1).toInvocationMatcher();\n-        Invocation mockTwoMethod = new InvocationBuilder().mock(\"mockTwo\").seq(2).toInvocation();\n-        InvocationsPrinter printer = new InvocationsPrinter(mockOneMethod, mockTwoMethod);\n-        \n-        assertEquals(\"Object#1.simpleMethod()\", printer.printWanted());\n-        assertEquals(\"Object#2.simpleMethod()\", printer.printActual());\n     }\n     \n     class Super {\n--- a/test/org/mockito/internal/progress/VerificationModeBuilder.java\n+++ b/test/org/mockito/internal/progress/VerificationModeBuilder.java\n \n public class VerificationModeBuilder {\n \n+    private Integer times;\n+\n     public VerificationModeImpl strict() {\n-        return VerificationModeImpl.strict(null, Arrays.asList(new Object()));\n+        return VerificationModeImpl.strict(times, Arrays.asList(new Object()));\n     }\n-}\n+\n+    public VerificationModeBuilder times(int times) {\n+        this.times = times;\n+        return this;\n+    }\n+\n+    public VerificationModeBuilder atLeastOnce() {\n+        times = null;\n+        return this;\n+    }\n+}\n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n         assertFalse(atLeastOnce().exactNumberOfInvocationsMode());\n     }\n     \n-    @Test\n-    public void shouldKnowIfWantedCountIsZero() throws Exception {\n-        assertTrue(times(0).wantedCountIsZero());\n-        \n-        assertFalse(times(1).wantedCountIsZero());\n-        assertFalse(times(2).wantedCountIsZero());\n-        assertFalse(atLeastOnce().wantedCountIsZero());\n-    }\n+//    @Test\n+//    public void shouldKnowIfWantedCountIsZero() throws Exception {\n+//        assertTrue(times(0).wantedCountIsZero());\n+//        \n+//        assertFalse(times(1).wantedCountIsZero());\n+//        assertFalse(times(2).wantedCountIsZero());\n+//        assertFalse(atLeastOnce().wantedCountIsZero());\n+//    }\n     \n     @Test\n     public void shouldKnowIfIsStrict() throws Exception {\n         assertFalse(times(2).atLeastOnceMode());\n         assertFalse(noMoreInteractions().atLeastOnceMode());\n     }\n+    \n+    @Test\n+    public void shouldKnowIfMatchesActualInvocationCount() throws Exception {\n+        assertFalse(times(1).matchesActualCount(0));\n+        assertFalse(times(1).matchesActualCount(2));\n+        assertFalse(times(100).matchesActualCount(200));\n+        \n+        assertTrue(times(1).matchesActualCount(1));\n+        assertTrue(times(100).matchesActualCount(100));\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfMatchesActualInvocationCountWhenAtLeastOnceMode() throws Exception {\n+        assertFalse(atLeastOnce().matchesActualCount(0));\n+        \n+        assertTrue(atLeastOnce().matchesActualCount(1));\n+        assertTrue(atLeastOnce().matchesActualCount(100));\n+    }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n  */\n package org.mockito.internal.verification;\n \n-import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertSame;\n-import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n-import static org.mockito.internal.progress.VerificationModeImpl.noMoreInteractions;\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n+import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n public class MissingInvocationVerifierTest extends RequiresValidState {\n \n     private MissingInvocationVerifier verifier;\n+    \n     private InvocationsAnalyzerStub analyzerStub;\n+    private ActualInvocationsFinderStub finderStub;\n     private ReporterStub reporterStub;\n     \n     private InvocationMatcher wanted;\n     public void setup() {\n         analyzerStub = new InvocationsAnalyzerStub();\n         reporterStub = new ReporterStub();\n-        verifier = new MissingInvocationVerifier(analyzerStub, reporterStub);\n+        finderStub = new ActualInvocationsFinderStub();\n+        verifier = new MissingInvocationVerifier(analyzerStub, finderStub, reporterStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n         invocations = asList(new InvocationBuilder().toInvocation());\n     }\n     \n     @Test\n-    public void shouldAskAnalyzerForActualNumberOfInvocations() {\n-        analyzerStub.actualCountToReturn = 1;\n-        verifier.verify(invocations, wanted, atLeastOnce());\n+    public void shouldAskFinderForActualInvocations() {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        VerificationModeImpl mode = atLeastOnce();\n+        verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, analyzerStub.invocations);\n-        assertSame(wanted, analyzerStub.wanted);\n+        assertSame(invocations, finderStub.invocations);\n     }\n     \n     @Test\n     public void shouldPassBecauseActualInvocationFound() {\n-        analyzerStub.actualCountToReturn = 1;\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         verifier.verify(invocations, wanted, atLeastOnce());\n     }\n     \n     @Test\n-    public void shouldAskAnalyzerForActualInvocationAndReportWantedButNotInvoked() {\n-        analyzerStub.actualCountToReturn = 0;\n-        analyzerStub.actualInvocationToReturn = null;\n+    public void shouldAskAnalyzerForSimilarInvocation() {\n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertSame(invocations, analyzerStub.invocations);\n-        assertSame(wanted, analyzerStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() {\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        analyzerStub.similarToReturn = null;\n+        \n+        verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertEquals(wanted.toString(), reporterStub.wanted);\n     }\n     \n     @Test\n     public void shouldReportWantedInvocationDiffersFromActual() {\n-        analyzerStub.actualCountToReturn = 0;\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n         Invocation actualInvocation = new InvocationBuilder().toInvocation();\n-        analyzerStub.actualInvocationToReturn = actualInvocation;\n+        analyzerStub.similarToReturn = actualInvocation;\n+        \n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertEquals(wanted.toString(), reporterStub.wanted);\n         assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n     }\n     \n+    @Test\n+    public void shouldMarkAsVerified() {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().toInvocation();\n+        finderStub.actualToReturn.add(invocation);\n+        finderStub.actualToReturn.add(invocationTwo);\n+        \n+        verifier.verify(invocations, wanted, atLeastOnce());\n+        assertTrue(invocation.isVerified());\n+        assertTrue(invocationTwo.isVerified());\n+    }\n+    \n+    class ActualInvocationsFinderStub extends ActualInvocationsFinder {\n+        private final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n+        private List<Invocation> invocations;\n+        @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n+                VerificationModeImpl mode) {\n+            this.invocations = invocations;\n+            return actualToReturn;\n+        }\n+    }\n+    \n     class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n+        private Invocation similarToReturn;\n         private List<Invocation> invocations;\n-        private InvocationMatcher wanted;\n-        private int actualCountToReturn;\n-        private Invocation actualInvocationToReturn;\n-        @Override public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n+\n+        @Override public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n             this.invocations = invocations;\n-            this.wanted = wanted;\n-            return actualCountToReturn;\n-        }\n-        @Override public Invocation findActualInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n-            this.invocations = invocations;\n-            this.wanted = wanted;\n-            return actualInvocationToReturn;\n+            return similarToReturn;\n         }\n     }\n     \n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n  */\n package org.mockito.internal.verification;\n \n-import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertSame;\n-import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n-import static org.mockito.internal.progress.VerificationModeImpl.times;\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n+import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n     private List<Invocation> invocations;\n+    private ActualInvocationsFinderStub finderStub;\n     \n     @Before\n     public void setup() {\n         reporterStub = new ReporterStub();\n         analyzerStub = new InvocationsAnalyzerStub();\n-        verifier = new NumberOfInvocationsVerifier(reporterStub, analyzerStub);\n+        finderStub = new ActualInvocationsFinderStub();\n+        verifier = new NumberOfInvocationsVerifier(reporterStub, analyzerStub, finderStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n         invocations = asList(new InvocationBuilder().toInvocation());\n     }\n     \n     @Test\n-    public void shouldCountActualInvocations() throws Exception {\n-        verifier.verify(invocations, wanted, times(4));\n-        assertSame(wanted, analyzerStub.wanted);\n-    }\n-    \n-    @Test\n-    public void shouldAskAnalyzerToCountActual() throws Exception {\n-        VerificationModeImpl mode = times(1);\n-        analyzerStub.actualCountToReturn = 1;\n+    public void shouldReportTooLittleActual() throws Exception {\n+        VerificationModeImpl mode = times(100);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, analyzerStub.invocations);\n-        assertSame(wanted, analyzerStub.wanted);\n+        assertEquals(1, reporterStub.actualCount);\n+        assertEquals(100, reporterStub.wantedCount);\n+        assertEquals(wanted.toString(), reporterStub.wanted);\n     }\n-    \n+\n     @Test\n-    public void shouldReportTooLittleInvocations() throws Exception {\n-        VerificationModeImpl mode = times(10);\n-        analyzerStub.actualCountToReturn = 5;\n+    public void shouldReportWithLastInvocationStackTrace() throws Exception {\n+        VerificationModeImpl mode = times(100);\n         MockitoException lastInvocation = new MockitoException(\"\");\n         analyzerStub.invocationTraceToReturn = lastInvocation;\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, analyzerStub.invocations);\n-        assertSame(wanted, analyzerStub.wanted);\n-        \n-        assertEquals(5, reporterStub.actualCount);\n-        assertEquals(10, reporterStub.wantedCount);\n-        assertEquals(wanted.toString(), reporterStub.wanted);\n-        \n         assertSame(lastInvocation, reporterStub.stackTrace);\n     }\n     \n     @Test\n-    public void shouldReportTooManyInvocations() throws Exception {\n+    public void shouldAskAnalyzerWithActualInvocationsWhenTooLittleActual() throws Exception {\n+        VerificationModeImpl mode = times(100);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(finderStub.actualToReturn, analyzerStub.invocations);\n+    }\n+    \n+    @Test\n+    public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n         VerificationModeImpl mode = times(0);\n-        analyzerStub.actualCountToReturn = 5;\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         MockitoException firstUndesiredInvocation = new MockitoException(\"\");\n         analyzerStub.invocationTraceToReturn = firstUndesiredInvocation;\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, analyzerStub.invocations);\n-        assertSame(wanted, analyzerStub.wanted);\n+        assertSame(firstUndesiredInvocation, reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldAskAnalyzerWithActualInvocationsWhenTooManyActual() throws Exception {\n+        VerificationModeImpl mode = times(0);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         \n-        assertSame(mode, analyzerStub.mode);\n+        verifier.verify(invocations, wanted, mode);\n         \n-        assertEquals(5, reporterStub.actualCount);\n+        assertSame(finderStub.actualToReturn, analyzerStub.invocations);\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyActual() throws Exception {\n+        VerificationModeImpl mode = times(0);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertEquals(1, reporterStub.actualCount);\n         assertEquals(0, reporterStub.wantedCount);\n         assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerified() {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().toInvocation();\n+        finderStub.actualToReturn.add(invocation);\n+        finderStub.actualToReturn.add(invocationTwo);\n         \n-        assertSame(firstUndesiredInvocation, reporterStub.stackTrace);\n+        verifier.verify(invocations, wanted, times(2));\n+        assertTrue(invocation.isVerified());\n+        assertTrue(invocationTwo.isVerified());\n     }\n     \n     class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private HasStackTrace invocationTraceToReturn;\n-        private int actualCountToReturn;\n-\n-        private InvocationMatcher wanted;\n-        private VerificationModeImpl mode;\n         private List<Invocation> invocations;\n-        @Override\n-        public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n+        @Override public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n             this.invocations = invocations;\n-            this.wanted = wanted;\n-            return actualCountToReturn;\n-        }\n-        \n-        @Override public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-            this.wanted = wanted;\n-            this.mode = mode;\n             return invocationTraceToReturn;\n         }\n-        \n-        @Override\n-        public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n-            this.wanted = wanted;\n+        @Override public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n+            this.invocations = invocations;\n             return invocationTraceToReturn;\n+        }\n+    }\n+    \n+    class ActualInvocationsFinderStub extends ActualInvocationsFinder {\n+        private final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n+        @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+            return actualToReturn;\n         }\n     }\n     \n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n  */\n package org.mockito.internal.verification;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertThat;\n-import static org.mockito.util.ExtraMatchers.collectionHasExactlyInOrder;\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n-import java.util.Arrays;\n import java.util.List;\n \n import org.junit.Before;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsChunker;\n-import org.mockito.internal.invocation.InvocationsMarker;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.progress.VerificationModeImpl;\n-import org.mockito.internal.progress.VerificationModeBuilder;\n \n public class VerifyingRecorderTest extends RequiresValidState {\n     \n     private VerifyingRecorder recorder;\n     private VerifierStub verifierStub;\n-    private InvocationsMarkerStub markerStub;\n-    private InvocationsChunkerStub chunkerStub;\n     \n     private Invocation simpleMethod;\n     private InvocationMatcher differentMethod;\n     @Before\n     public void setup() {\n         verifierStub = new VerifierStub();\n-        markerStub = new InvocationsMarkerStub();\n-        chunkerStub = new InvocationsChunkerStub();\n-        recorder = new VerifyingRecorder(chunkerStub, markerStub, Arrays.<Verifier>asList(verifierStub));\n+        recorder = new VerifyingRecorder(new InvocationsFinder() {\n+            public List<Invocation> getAllInvocations(List<? extends Object> mocks) {\n+                return asList(simpleMethod, differentMethod.getInvocation());\n+            }}, asList(verifierStub));\n \n         simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n         differentMethod = new InvocationBuilder().differentMethod().toInvocationMatcher();\n-    }\n-    \n-    @Test\n-    public void shouldMarkInvocationsAsVerified() {\n-        recorder.recordInvocation(simpleMethod);\n-        \n-        VerificationModeImpl mode = VerificationModeImpl.atLeastOnce();\n-        recorder.verify(differentMethod, mode);\n-        \n-        assertThat(markerStub.invocations, collectionHasExactlyInOrder(simpleMethod));\n-        assertEquals(markerStub.mode, mode);\n-        assertEquals(markerStub.wanted, differentMethod);\n     }\n     \n     @Test\n         VerificationModeImpl mode = VerificationModeImpl.atLeastOnce();\n         recorder.verify(differentMethod, mode);\n         \n-        assertEquals(verifierStub.mode, mode);\n+        assertSame(verifierStub.mode, mode);\n         assertSame(verifierStub.wanted, differentMethod);\n         assertThat(verifierStub.invocations, collectionHasExactlyInOrder(simpleMethod));\n     }\n     \n     @Test\n     public void shouldVerifyStrictly() {\n-        recorder.recordInvocation(simpleMethod);\n+        VerificationModeImpl strictMode = new VerificationModeBuilder().strict();\n+        recorder.verify(differentMethod, strictMode);\n         \n-        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n-        recorder.verify(differentMethod, mode);\n-        \n-        assertEquals(verifierStub.mode, mode);\n-        assertEquals(verifierStub.wanted, differentMethod);\n-        assertThat(verifierStub.invocations, collectionHasExactlyInOrder(differentMethod.getInvocation()));\n-    }\n-    \n-    @Test\n-    public void shouldNotMarkInvocationsAsVerifiedWhenModeIsNotExplicit() {\n-        VerificationModeImpl mode = VerificationModeImpl.noMoreInteractions();\n-        recorder.verify(mode);\n-        assertNull(markerStub.mode);\n-    }\n-    \n-    class InvocationsMarkerStub extends InvocationsMarker {\n-        private List<Invocation> invocations;\n-        private InvocationMatcher wanted;\n-        private VerificationModeImpl mode;\n-        @Override public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-            this.invocations = invocations;\n-            this.wanted = wanted;\n-            this.mode = mode;\n-            \n-            assertNotNull(\"marking should happen after verification\", verifierStub.invocations);\n-        }\n+        assertThat(verifierStub.invocations, collectionHasExactlyInOrder(simpleMethod, differentMethod.getInvocation()));\n     }\n     \n     class VerifierStub implements Verifier {\n             this.mode = mode;\n         }\n     }\n-    \n-    class InvocationsChunkerStub extends InvocationsChunker {\n-        public InvocationsChunkerStub() {\n-            super(null);\n-        }\n-        @Override public List<Invocation> getFirstUnverifiedInvocationChunk(List<Object> mocks) {\n-            return Arrays.asList(differentMethod.getInvocation());\n-        }\n-    }\n-}\n+}\n--- a/test/org/mockitousage/StackTrackeChangingTest.java\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n  */\n package org.mockitousage;\n \n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.util.ExtraMatchers.hasMethodInStackTraceAt;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n import org.junit.Test;\n--- a/test/org/mockitousage/StackTrackeFilteringTest.java\n+++ b/test/org/mockitousage/StackTrackeFilteringTest.java\n         Strictly strictly = createStrictOrderVerifier(mock);\n         mock.oneArg(true);\n         mock.oneArg(false);\n+        \n+        strictly.verify(mock).oneArg(false); \n         try {\n-            strictly.verify(mock).oneArg(false); \n+            strictly.verify(mock).oneArg(true);\n             fail();\n         } catch (VerificationError expected) {\n             assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n--- /dev/null\n+++ b/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.NoInteractionsWantedError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class BasicStrictVerificationTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyUsingAtLeastOnce() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n+        strictly.verify(mockOne, times(0)).oneArg(false);\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockTwo, times(0)).simpleMethod(22);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        strictly.verify(mockThree, times(0)).oneArg(false);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldFailWhenFirstMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test(expected=TooManyActualInvocationsError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n+        strictly.verify(mockOne, times(0)).simpleMethod(1);\n+    }\n+    \n+    @Test(expected=TooLittleActualInvocationsError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n+        strictly.verify(mockOne, times(2)).simpleMethod(1);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWanted() {\n+        strictly.verify(mockOne, times(1)).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(2);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n+        strictly.verify(mockOne, times(1)).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, times(0)).simpleMethod(2);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, times(0)).simpleMethod(4);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, times(2)).simpleMethod(4);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }    \n+    \n+    /* ------------- */\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(100);\n+    }\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne).oneArg(true);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, times(2)).simpleMethod(-999);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne, times(1)).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, times(2)).oneArg(true);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(-666);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).oneArg(false);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }    \n+    \n+    /* -------------- */\n+    \n+    @Test\n+    public void shouldPassSingleMethodFromTheMiddleOfSequence() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPassSingleMethodUsingTimesMode() {\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldPassSingleMethodUsingAtLeastOnceMode() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldPassIfSomeMethodsFromTheMiddleAreLeftOut() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPassUsingAtLeastOnceIfSomeMethodsFromTheMiddleAreLeftOut() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldAllowLastMethodEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnVerifyNoMoreInteractions() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {}\n+    } \n+    \n+    @Test(expected=NoInteractionsWantedError.class)\n+    public void shouldFailOnVerifyZeroInteractions() {\n+        verifyZeroInteractions(mockOne);\n+    }\n+}\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.createStrictOrderVerifier;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.util.ExtraMatchers.causeMessageContains;\n-import static org.mockito.util.ExtraMatchers.messageContains;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.StateResetter;\n import org.mockito.Strictly;\n+import org.mockito.exceptions.cause.TooLittleInvocations;\n+import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n         one.simpleMethod(11);\n         two.simpleMethod(2);\n         two.simpleMethod(2);\n-        three.simpleMethod();\n+        three.simpleMethod(3);\n         \n         strictly = createStrictOrderVerifier(one, two, three);\n     }\n     \n     @Test\n     public void shouldPrintStrictVerificationError() {\n+        strictly.verify(one, atLeastOnce()).simpleMethod(1);\n+        \n         try {\n             strictly.verify(one).simpleMethod(999);\n             fail();\n                 \"\\n\" +\n                 \"Actual invocation:\" +\n                 \"\\n\" +\n-                \"IMethods.simpleMethod(1)\";\n+                \"IMethods.simpleMethod(11)\";\n             \n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }  \n     \n     @Test\n-    public void shouldPrintWantedMethodWhenEverythingElseIsVerified() {\n+    public void shouldPrintMethodThatWasNotInvoked() {\n         strictly.verify(one).simpleMethod(1);\n         strictly.verify(one).simpleMethod(11);\n         strictly.verify(two, times(2)).simpleMethod(2);\n-        strictly.verify(three).simpleMethod();\n+        strictly.verify(three).simpleMethod(3);\n         try {\n             strictly.verify(three).simpleMethod(999);\n             fail();\n-        } catch (VerificationError expected) {\n-            String actualMessage = expected.getMessage();\n+        } catch (VerificationError e) {\n+            String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n                     \"IMethods.simpleMethod(999)\"; \n-            assertEquals(expectedMessage, actualMessage);         \n+            assertEquals(expectedMessage, actualMessage);     \n         }\n     }   \n     \n                     \"IMethods.simpleMethod(2)\" +\n                     \"\\n\" +\n                     \"Wanted 1 time but was 2\"; \n-            assertEquals(expectedMessage, actualMessage);         \n+            assertEquals(expectedMessage, actualMessage);      \n+            \n+            assertEquals(UndesiredInvocation.class, e.getCause().getClass());\n+\n+            String expectedCause =\n+                \"\\n\" +\n+                \"Undesired invocation:\";\n+            assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }  \n     \n     @Test\n-    public void shouldPrintSequenceNumberWhenMocksAndMethodsAreTheSame() {\n-        StateResetter.reset();\n-        one = mock(IMethods.class);\n-        two = mock(IMethods.class);\n+    public void shouldPrintThatWasNotInvokedAfter() {\n+        strictly.verify(two, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(one).simpleMethod(1);\n+            fail();\n+        } catch (VerificationError e) {\n+            //TODO refactor to WantedButNotInvoked\n+            assertThat(e, messageContains(\"Wanted but not invoked\"));\n+            //TODO what about a feature to show after which line we expect this thing:\n+//            String expectedCause = \n+//                \"\\n\" +\n+//                \"Not invoked after:\";\n+//            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintUndesiredInvocation() {\n+        two.simpleMethod(2);\n+        two.simpleMethod(2);\n+        two.simpleMethod(2);\n         \n-        one.simpleMethod();\n-        two.simpleMethod();\n-        \n-        strictly = createStrictOrderVerifier(one, two);\n+        strictly.verify(three, atLeastOnce()).simpleMethod(3);\n         \n         try {\n-            strictly.verify(two).simpleMethod();\n+            strictly.verify(two, times(2)).simpleMethod(2);\n             fail();\n-        } catch (VerificationError e) {\n-            assertThat(e, messageContains(\"IMethods#3.simpleMethod()\"));\n-            assertThat(e, causeMessageContains(\"IMethods#1.simpleMethod()\"));\n+        } catch (TooManyActualInvocationsError e) {\n+            String actualMessage = e.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 2 times but was 3\";\n+            assertEquals(expectedMessage, actualMessage);\n+            \n+            assertEquals(e.getCause().getClass(), UndesiredInvocation.class);\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Undesired invocation:\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n     \n     @Test\n-    public void shouldPrintSequenceNumberAndMatchersWhenMocksAndMethodsAreTheSame() {\n-        StateResetter.reset();\n-        one = mock(IMethods.class);\n-        two = mock(IMethods.class);\n+    public void shouldPrintTooLittleInvocations() {\n+        two.simpleMethod(2);\n         \n-        one.simpleMethod(1);\n-        two.simpleMethod(1);\n-        \n-        strictly = createStrictOrderVerifier(one, two);\n+        strictly.verify(three, atLeastOnce()).simpleMethod(3);\n         \n         try {\n-            strictly.verify(two).simpleMethod(Mockito.anyInt());\n+            strictly.verify(two, times(2)).simpleMethod(2);\n             fail();\n-        } catch (VerificationError expected) {\n-            assertThat(expected, messageContains(\"IMethods#3.simpleMethod(<any>)\"));\n-            assertThat(expected, causeMessageContains(\"IMethods#1.simpleMethod(1)\"));\n+        } catch (TooLittleActualInvocationsError e) {\n+            String actualMessage = e.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 2 times but was 1\";\n+            assertEquals(expectedMessage, actualMessage);\n+            \n+            assertEquals(e.getCause().getClass(), TooLittleInvocations.class);\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Too little invocations:\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());\n         }\n-    }\n+    }   \n }\n--- /dev/null\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.cause.TooLittleInvocations;\n+import org.mockito.exceptions.cause.UndesiredInvocation;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends RequiresValidState {\n+\n+    private LinkedList mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(LinkedList.class);\n+    }\n+\n+    @Test\n+    public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+\n+        Mockito.verify(mock, times(3)).clear();\n+        try {\n+            Mockito.verify(mock, times(100)).clear();\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {\n+            String expected =\n+                \"\\n\" +\n+                \"LinkedList.clear()\" +\n+                \"\\n\" +\n+                \"Wanted 100 times but was 3\";\n+            assertEquals(expected, e.getMessage());\n+\n+            assertEquals(TooLittleInvocations.class, e.getCause().getClass());\n+\n+            String expectedCause =\n+                \"\\n\" +\n+                \"Too little invocations:\";\n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldVerifyActualNumberOfInvocationsLargerThanWanted() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+\n+        Mockito.verify(mock, times(4)).clear();\n+        try {\n+            Mockito.verify(mock, times(1)).clear();\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {\n+            String expected =\n+                \"\\n\" +\n+                \"LinkedList.clear()\" +\n+                \"\\n\" +\n+                \"Wanted 1 time but was 4\";\n+            assertEquals(expected, e.getMessage());\n+\n+            assertEquals(UndesiredInvocation.class, e.getCause().getClass());\n+\n+            String expectedCause =\n+                \"\\n\" +\n+                \"Undesired invocation:\";\n+\n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.util.ExtraMatchers.messageContains;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import java.util.LinkedList;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.cause.FirstUndesiredInvocation;\n-import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n \n     }\n \n     @Test\n-    public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted() throws Exception {\n-        mock.clear();\n+    public void shouldDetectTooLittleActualInvocations() throws Exception {\n         mock.clear();\n         mock.clear();\n \n-        Mockito.verify(mock, times(3)).clear();\n+        Mockito.verify(mock, times(2)).clear();\n         try {\n             Mockito.verify(mock, times(100)).clear();\n             fail();\n         } catch (TooLittleActualInvocationsError e) {\n-            String expected =\n-                \"\\n\" +\n-                \"LinkedList.clear()\" +\n-                \"\\n\" +\n-                \"Wanted 100 times but was 3\";\n-            assertEquals(expected, e.getMessage());\n-\n-            assertEquals(TooLittleInvocations.class, e.getCause().getClass());\n-\n-            String expectedCause =\n-                \"\\n\" +\n-                \"Too little invocations:\";\n-            assertEquals(expectedCause, e.getCause().getMessage());\n+            assertThat(e, messageContains(\"Wanted 100 times but was 2\"));\n         }\n     }\n \n     @Test\n-    public void shouldVerifyActualNumberOfInvocationsLargerThanWanted() throws Exception {\n-        mock.clear();\n-        mock.clear();\n+    public void shouldDetectTooManyActualInvocations() throws Exception {\n         mock.clear();\n         mock.clear();\n \n-        Mockito.verify(mock, times(4)).clear();\n+        Mockito.verify(mock, times(2)).clear();\n         try {\n             Mockito.verify(mock, times(1)).clear();\n             fail();\n         } catch (TooManyActualInvocationsError e) {\n-            String expected =\n-                \"\\n\" +\n-                \"LinkedList.clear()\" +\n-                \"\\n\" +\n-                \"Wanted 1 time but was 4\";\n-            assertEquals(expected, e.getMessage());\n-\n-            assertEquals(FirstUndesiredInvocation.class, e.getCause().getClass());\n-\n-            String expectedCause =\n-                \"\\n\" +\n-                \"First undesired invocation:\";\n-\n-            assertEquals(expectedCause, e.getCause().getMessage());\n+            assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n         }\n     }\n \n     @Test\n-    public void shouldVerifyProperlyIfMethodWasNotInvoked() throws Exception {\n+    public void shouldDetectActualInvocationsCountIsMoreThanZero() throws Exception {\n         Mockito.verify(mock, times(0)).clear();\n         try {\n             Mockito.verify(mock, times(15)).clear();\n     }\n \n     @Test\n-    public void shouldVerifyProperlyIfMethodWasInvokedOnce() throws Exception {\n-        mock.clear();\n-\n-        Mockito.verify(mock, times(1)).clear();\n-        try {\n-            Mockito.verify(mock, times(15)).clear();\n-            fail();\n-        } catch (TooLittleActualInvocationsError e) {\n-            assertThat(e, messageContains(\"Wanted 15 times but was 1\"));\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailWhenWantedNumberOfInvocationIsZero() throws Exception {\n+    public void shouldDetectActuallyCalledOnce() throws Exception {\n         mock.clear();\n \n         try {\n     }\n \n     @Test\n-    public void shouldVerifyWhenWantedNumberOfInvocationIsZero() throws Exception {\n+    public void shouldPassWhenMethodsActuallyNotCalled() throws Exception {\n         Mockito.verify(mock, times(0)).clear();\n+        Mockito.verify(mock, times(0)).add(\"yes, I wasn't called\");\n     }\n \n     @Test\n \n         Mockito.verify(mock, times(2)).add(\"test\");\n     }\n-}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/RelaxedStrictVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.NoInteractionsWantedError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class RelaxedStrictVerificationTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictlyAllInvocations() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyMockTwoAndThree() {\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo, mockThree);\n+    }     \n+    \n+    @Test\n+    public void shouldVerifyStrictlyMockOneAndThree() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyOnlyTwoInvocations() {\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictlyOnlyMockTwo() {\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMockTwoCalledOnce() {\n+        strictly.verify(mockTwo).simpleMethod(2);\n+    }\n+\n+    @Test\n+    public void shouldVerifyMockTwoCalledTwice() {\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMockTwoCalledAtLeastOnce() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnWrongMethodCalledOnMockTwo() {\n+        strictly.verify(mockTwo, atLeastOnce()).differentMethod();\n+    }\n+    \n+    @Test\n+    public void shouldAllowTimesZeroButOnlyStrictly() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockOne, times(0)).simpleMethod(1);\n+        \n+        try {\n+            verify(mockOne, times(0)).simpleMethod(1);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailTimesZeroStrictly() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockThree, times(0)).simpleMethod(3);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractionsWantedForMockTwo() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            verifyNoMoreInteractions(mockTwo);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoWantedZeroTimes() {\n+        try {\n+            strictly.verify(mockTwo, times(0)).simpleMethod(2);\n+            fail();\n+        } catch(TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoWantedThreeTimes() {\n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(2);\n+            fail();\n+        } catch(TooLittleActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyLastInvocation() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyLastTwoInvocations() {\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySecondAndLastInvocation() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySecondAndLastInvocationWhenAtLeastOnceUsed() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastTwoInvocationsInWrongOrder() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockTwo).simpleMethod(2);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastAndFirstInWrongOrder() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongMethodAfterLastInvocation() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.NoInteractionsWantedError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class SelectedMocksInOrderVerificationTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictlyAllInvocations() {\n+        Strictly strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyMockTwoAndThree() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo, mockThree);\n+        \n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo, mockThree);\n+    }     \n+    \n+    @Test\n+    public void shouldVerifyStrictlyMockOneAndThree() {\n+        Strictly strictly = createStrictOrderVerifier(mockOne, mockThree);\n+        \n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyMockOne() {\n+        Strictly strictly = createStrictOrderVerifier(mockOne);\n+        \n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        \n+        verifyNoMoreInteractions(mockOne);\n+    } \n+    \n+    @Test\n+    public void shouldFailVerificationForMockOne() {\n+        Strictly strictly = createStrictOrderVerifier(mockOne);\n+        \n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).differentMethod();\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n+    \n+    @Test\n+    public void shouldFailVerificationForMockOneBecauseOfWrongOrder() {\n+        Strictly strictly = createStrictOrderVerifier(mockOne);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        \n+        try {\n+            strictly.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n+\n+    @Test\n+    public void shouldVerifyStrictlyMockTwoWhenThreeTimesUsed() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+        \n+        strictly.verify(mockTwo, times(3)).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockTwo);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyStrictlyMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+        \n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockTwo);\n+    } \n+    \n+    @Test\n+    public void shouldFailVerificationForMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+\n+        try {\n+            strictly.verify(mockTwo).simpleMethod(2);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldThrowNoMoreInvocationsForMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+\n+        try {\n+            strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldThrowTooLittleInvocationsForMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+\n+        try {\n+            strictly.verify(mockTwo, times(4)).simpleMethod(2);\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldThrowTooManyInvocationsForMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+\n+        try {\n+            strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+            fail();\n+        } catch (TooManyActualInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowThreeTimesOnMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo);\n+\n+        strictly.verify(mockTwo, times(3)).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMockTwoCompletely() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo, mockThree);\n+\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockTwo, times(1)).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo);\n+        try {\n+            verifyNoMoreInteractions(mockThree);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowTwoTimesOnMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo, mockThree);\n+\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        try {\n+            verifyNoMoreInteractions(mockTwo);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowOneTimeOnMockTwo() {\n+        Strictly strictly = createStrictOrderVerifier(mockTwo, mockThree);\n+\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            verifyNoMoreInteractions(mockTwo);\n+            fail();\n+        } catch (NoInteractionsWantedError e) {}\n+    }\n+}\n--- a/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotSame;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.createStrictOrderVerifier;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Strictly;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n     }\n     \n     @Test\n-    public void shouldFailOnWrongOrder() {\n+    public void shouldAllowOneMethodVerifiedStrictly() {\n         verify(mockTwo).simpleMethod(2);\n         verify(mockOne, atLeastOnce()).simpleMethod(1);\n \n-        try {\n-            strictly.verify(mockThree).simpleMethod(3);\n-            fail();\n-        } catch (VerificationError e) {}\n+        strictly.verify(mockThree).simpleMethod(3);\n     }\n     \n     @Test\n-    public void shouldFailOnWrongOrderForLastInvocationIsTooEarly() {\n+    public void shouldAllowLastInvocationEarly() {\n         strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         verify(mockTwo).simpleMethod(2);\n-        \n-        try {\n-            strictly.verify(mockThree).simpleMethod(4);\n-            fail();\n-        } catch (VerificationError e) {}\n+        strictly.verify(mockThree).simpleMethod(4);\n     }\n     \n     @Test(expected=MockitoException.class)\n--- a/test/org/mockitousage/verification/StrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.createStrictOrderVerifier;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n-import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n \n         mockThree = mock(IMethods.class);\n         \n         strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n-\n-        mockOne.simpleMethod(1);\n-        mockTwo.simpleMethod(2);\n-        mockTwo.simpleMethod(2);\n-        mockThree.simpleMethod(3);\n-        mockTwo.simpleMethod(2);\n-        mockOne.simpleMethod(4);\n     }\n     \n     @Test\n-    public void shouldVerifyStrictly() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        strictly.verify(mockOne).simpleMethod(4);\n-        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-    } \n-    \n-    @Test\n-    public void shouldVerifyStrictlyUsingAtLeastOnce() {\n-        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        strictly.verify(mockOne, atLeastOnce()).simpleMethod(4);\n-        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-    } \n-    \n-    @Test\n-    public void shouldVerifyStrictlyWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n-        strictly.verify(mockOne, times(0)).oneArg(false);\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockTwo, times(0)).simpleMethod(22);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        strictly.verify(mockOne).simpleMethod(4);\n-        strictly.verify(mockThree, times(0)).oneArg(false);\n-        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-    } \n-    \n-    @Test\n-    public void shouldFailWhenFirstMockCalledTwice() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        try {\n-            strictly.verify(mockOne).simpleMethod(1);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailWhenLastMockCalledTwice() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        strictly.verify(mockOne).simpleMethod(4);\n-        try {\n-            strictly.verify(mockOne).simpleMethod(4);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test(expected=TooManyActualInvocationsError.class)\n-    public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n-        strictly.verify(mockOne, times(0)).simpleMethod(1);\n-    }\n-    \n-    @Test(expected=TooLittleActualInvocationsError.class)\n-    public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n-        strictly.verify(mockOne, times(2)).simpleMethod(1);\n-    }\n-    \n-    @Test\n-    public void shouldFailOnSecondMethodBecauseTwoInvocationsWanted() {\n-        strictly.verify(mockOne, times(1)).simpleMethod(1);\n-        try {\n-            strictly.verify(mockTwo, times(3)).simpleMethod(2);\n-            fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n-        strictly.verify(mockOne, times(1)).simpleMethod(1);\n-        try {\n-            strictly.verify(mockTwo, times(0)).simpleMethod(2);\n-            fail();\n-        } catch (TooManyActualInvocationsError e) {}\n-    }    \n-    \n-    @Test\n-    public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n-        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        try {\n-            strictly.verify(mockOne, times(0)).simpleMethod(4);\n-            fail();\n-        } catch (TooManyActualInvocationsError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n-        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        try {\n-            strictly.verify(mockOne, times(2)).simpleMethod(4);\n-            fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n-    }    \n-    \n-    /* ------------- */\n-    \n-    @Test(expected=VerificationError.class)\n-    public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n-        strictly.verify(mockOne).simpleMethod(100);\n-    }\n-    \n-    @Test(expected=VerificationError.class)\n-    public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n-        strictly.verify(mockOne).oneArg(true);\n-    }\n-    \n-    @Test\n-    public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        try {\n-            strictly.verify(mockTwo, times(2)).simpleMethod(-999);\n-            fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n-        strictly.verify(mockOne, times(1)).simpleMethod(1);\n-        try {\n-            strictly.verify(mockTwo, times(2)).oneArg(true);\n-            fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n-    }    \n-    \n-    @Test\n-    public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        try {\n-            strictly.verify(mockOne).simpleMethod(-666);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        try {\n-            strictly.verify(mockOne).oneArg(false);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }    \n-    \n-    /* -------------- */\n-    \n-    @Test(expected = VerificationError.class)\n-    public void shouldFailWhenLastMethodCalledFirst() {\n-        strictly.verify(mockOne).simpleMethod(4);\n-    }\n-    \n-    @Test(expected = TooLittleActualInvocationsError.class)\n-    public void shouldFailWhenSecondMethodCalledFirst() {\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-    }\n-    \n-    @Test\n-    public void shouldFailWhenLastMethodCalledToEarly() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        try {\n-            strictly.verify(mockOne).simpleMethod(4);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailWhenMockTwoIsToEarly() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        try {\n-            strictly.verify(mockTwo, times(1)).simpleMethod(2);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailWhenLastMockIsToEarly() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        try {\n-            strictly.verify(mockOne).simpleMethod(4);\n-            fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test\n-    public void shouldFailOnVerifyNoMoreInteractions() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        \n-        try {\n-            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n-            fail();\n-        } catch (NoInteractionsWantedError e) {}\n-    } \n-    \n-    @Test(expected=NoInteractionsWantedError.class)\n-    public void shouldFailOnVerifyZeroInteractions() {\n-        verifyZeroInteractions(mockOne);\n-    }\n-    \n-    @Test\n-    public void shouldVerifySingleMockStrictly() {\n+    public void shouldVerifySingleMockStrictlyAndNotStrictly() {\n         mockOne = mock(IMethods.class);\n         strictly = createStrictOrderVerifier(mockOne);\n         \n         verify(mockOne).simpleMethod(2);\n         verify(mockOne).simpleMethod(1);\n         \n+        strictly.verify(mockOne).simpleMethod(2);\n         try {\n-            strictly.verify(mockOne).simpleMethod(2);\n+            strictly.verify(mockOne).simpleMethod(1);\n             fail();\n         } catch (VerificationError e) {}\n     } \n+    \n+    @Test\n+    public void shouldCausePointToMockOne() {\n+        mockTwo.differentMethod();\n+        mockOne.simpleMethod();\n+        \n+        try {\n+            strictly.verify(mockOne, atLeastOnce()).differentMethod();\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.differentMethod()\"));\n+            assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictlyWhenTwoChunksAreEqual() {\n+        mockOne.simpleMethod();\n+        mockOne.simpleMethod();\n+        mockTwo.differentMethod();\n+        mockOne.simpleMethod();\n+        mockOne.simpleMethod();\n+        \n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod();\n+        strictly.verify(mockOne, times(2)).simpleMethod();\n+        try {\n+            strictly.verify(mockOne, atLeastOnce()).simpleMethod();\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStrictlyUsingMatcher() {\n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(2);\n+        mockTwo.differentMethod();\n+        mockOne.simpleMethod(3);\n+        mockOne.simpleMethod(4);\n+        \n+        verify(mockOne, times(4)).simpleMethod(anyInt());\n+        \n+        strictly.verify(mockOne, times(2)).simpleMethod(anyInt());\n+        strictly.verify(mockOne, times(2)).simpleMethod(anyInt());\n+        try {\n+            strictly.verify(mockOne, times(3)).simpleMethod(anyInt());\n+            fail();\n+        } catch (TooLittleActualInvocationsError e) {}\n+    }\n }", "timestamp": 1198496745, "metainfo": ""}