{"sha": "ab19d0faf94ed0b8bf74e5a91fd2c98d74a468fc", "log": "on the way to thin down the MockitoVerificationMode  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40967", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/AtLeast.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.api.VerificationMode;\n+\n+public class AtLeast implements VerificationInOrderMode, VerificationMode {\n+    \n+    final int wantedInvocationCount;\n+    \n+    public AtLeast(int wantedNumberOfInvocations) {\n+        if (wantedNumberOfInvocations <= 0) {\n+            throw new MockitoException(\"Negative value or zero are not allowed here\");\n+        }\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+    }\n+    \n+    public void verify(VerificationData data) {\n+        MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n+        AtLeastXNumberOfInvocationsChecker numberOfInvocations = new AtLeastXNumberOfInvocationsChecker();\n+        \n+        if (wantedInvocationCount == 1) {\n+            missingInvocation.verify(data.getAllInvocations(), data.getWanted());\n+        }\n+        numberOfInvocations.verify(data.getAllInvocations(), data.getWanted(), wantedInvocationCount);\n+    }\n+    \n+    public void verifyInOrder(VerificationData data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();\n+        \n+        if (wantedInvocationCount == 1) {\n+            missingInvocation.verify(allInvocations, wanted, this);\n+        }\n+        \n+//        numberOfCalls.verify(allInvocations, wanted, this);\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: at least \" + wantedCount();\n+    }    \n+\n+    public int wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/AtLeastXNumberOfInvocationsChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+\n+public class AtLeastXNumberOfInvocationsChecker {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+\n+    //TODO remove constructors if unit test not necessary\n+    public AtLeastXNumberOfInvocationsChecker() {\n+        this(new Reporter(), new InvocationsFinder());\n+    }\n+    \n+    AtLeastXNumberOfInvocationsChecker(Reporter reporter, InvocationsFinder finder) {\n+        this.reporter = reporter;\n+        this.finder = finder;\n+    }\n+    \n+    //TODO check coverage\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n+        \n+        int actualCount = actualInvocations.size();\n+        if (wantedCount > actualCount) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n+            reporter.tooLittleActualInvocationsInAtLeastMode(wantedCount, actualCount, wanted, lastInvocation);        \n+        }\n+        \n+        for (Invocation i : actualInvocations) {\n+            i.markVerified();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/AtLeastXNumberOfInvocationsInOrderChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+\n+public class AtLeastXNumberOfInvocationsInOrderChecker {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+    \n+    public AtLeastXNumberOfInvocationsInOrderChecker() {\n+        this(new InvocationsFinder(), new Reporter());\n+    }\n+    \n+    public AtLeastXNumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+        VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode);\n+        \n+        boolean noMatchFound = chunk.size() == 0;\n+        if (decoder.neverWanted() && noMatchFound) {\n+            return;\n+        }\n+        \n+        int actualCount = chunk.size();\n+        \n+        if (decoder.tooLittleActualInvocations(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n+            reporter.tooLittleActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (decoder.tooLittleActualInvocationsInAtLeastMode(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n+            reporter.tooLittleActualInvocationsInOrderInAtLeastMode(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (decoder.tooManyActualInvocations(actualCount)) {\n+            HasStackTrace firstUndesired = chunk.get(mode.wantedCount()).getStackTrace();\n+            reporter.tooManyActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted, firstUndesired);\n+        }\n+        \n+        for (Invocation i : chunk) {\n+            i.markVerifiedInOrder();\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeDecoder.java\n+++ b/src/org/mockito/internal/verification/VerificationModeDecoder.java\n \n import org.mockito.internal.verification.MockitoVerificationMode.Verification;\n \n+//TODO verify all methods are used\n public class VerificationModeDecoder {\n \n     private final MockitoVerificationMode mode;", "timestamp": 1223980317, "metainfo": ""}