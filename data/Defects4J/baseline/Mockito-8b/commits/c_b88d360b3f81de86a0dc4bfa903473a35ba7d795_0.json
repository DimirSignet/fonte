{"sha": "b88d360b3f81de86a0dc4bfa903473a35ba7d795", "log": "In order to fix ArgumentCaptor so that it captures only when entire invocation matches. Loads of code changed for this. In order to facilitate better assertions added assertions library FEST (yeah!)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401563", "commit": "\n--- a/src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java\n+++ b/src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java\n     public InvalidUseOfMatchersException(String message) {\n         super(message);\n     }\n-}\n+\n+    public InvalidUseOfMatchersException() {\n+        super(\"\");\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  */\n package org.mockito.internal;\n \n-import java.lang.reflect.Method;\n import java.util.List;\n \n-import org.mockito.cglib.proxy.MethodInterceptor;\n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.SequenceNumber;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.stubbing.MockitoStubber;\n import org.mockito.internal.stubbing.OngoingStubbingImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n import org.mockito.internal.util.MockName;\n import org.mockito.internal.verification.RegisteredInvocations;\n  *\n  * @param <T> type of mock object to handle\n  */\n-public class MockHandler<T> implements MethodInterceptor {\n+public class MockHandler<T> {\n \n+    MockitoStubber mockitoStubber;\n+    MatchersBinder matchersBinder;\n+    MockingProgress mockingProgress;\n+    \n     private final RegisteredInvocations registeredInvocations;\n-    private final MockitoStubber mockitoStubber;\n-    private final MatchersBinder matchersBinder;\n-    private final MockingProgress mockingProgress;\n     private final MockName mockName;\n     private final MockSettingsImpl mockSettings;\n \n     public MockHandler(MockHandler<T> oldMockHandler) {\n         this(oldMockHandler.mockName, oldMockHandler.mockingProgress, oldMockHandler.matchersBinder, oldMockHandler.mockSettings);\n     }\n-\n-    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n+    \n+    //for tests\n+    MockHandler() {\n+        this(new MockName(\"mockie for tests\", MockHandler.class), new ThreadSafeMockingProgress(), new MatchersBinder(), new MockSettingsImpl());\n+    }\n+    \n+    public Object handle(Invocation invocation) throws Throwable {\n         if (mockitoStubber.hasAnswersForStubbing()) {\n             //stubbing voids with stubVoid() or doAnswer() style\n-            Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n             mockitoStubber.setMethodForStubbing(invocationMatcher);\n             return null;\n         }\n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n \n-        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n         \n         mockingProgress.validateState();\n         OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n         mockingProgress.reportOngoingStubbing(ongoingStubbing);\n \n-        Answer<?> stubbedAnswer = mockitoStubber.findAnswerFor(invocation);\n-        if (!invocation.isVoid() && stubbedAnswer == null) {\n+        StubbedInvocationMatcher stubbedInvocation = mockitoStubber.findAnswerFor(invocation);\n+        if (!invocation.isVoid() && stubbedInvocation == null) {\n             //it is a return-value interaction but not stubbed. This *might* be a problem\n             mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n         }\n         \n-        if (stubbedAnswer != null) {\n+        if (stubbedInvocation != null) {\n             mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n-            return stubbedAnswer.answer(invocation);\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n         } else {\n             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n             \n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n \n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.MockHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n+import org.mockito.internal.progress.SequenceNumber;\n \n-public class MethodInterceptorFilter<T extends MethodInterceptor> implements MethodInterceptor {\n+@SuppressWarnings(\"unchecked\")\n+public class MethodInterceptorFilter implements MethodInterceptor {\n     \n     private final Method equalsMethod;\n     private final Method hashCodeMethod;\n \n-    private final T delegate;\n+    private final MockHandler mockHandler;\n \n-    @SuppressWarnings(\"unchecked\")\n-    public MethodInterceptorFilter(Class toMock, T delegate) {\n+    public MethodInterceptorFilter(Class toMock, MockHandler mockHandler) {\n         try {\n             if (toMock.isInterface()) {\n                 toMock = Object.class;\n             throw new RuntimeException(\"\\nSomething went really wrong. Object method could not be found!\" +\n                 \"\\n please report it to the mocking mailing list at http://mockito.org\");\n         }\n-        this.delegate = delegate;\n+        this.mockHandler = mockHandler;\n     }\n \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n         \n         new CGLIBHacker().setMockitoNamingPolicy(methodProxy);\n         \n-        return delegate.intercept(proxy, method, args, methodProxy);\n+        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n+        return mockHandler.handle(invocation);\n+    }\n+    \n+    public MockHandler getMockHandler() {\n+        return mockHandler;\n     }\n \n     private int hashCodeForMock(Object mock) {\n         return new Integer(System.identityHashCode(mock));\n     }\n-\n-    public T getDelegate() {\n-        return delegate;\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n+package org.mockito.internal.invocation;\n+\n+public interface CapturesArgumensFromInvocation {\n+    \n+    void captureArgumentsFrom(Invocation i);\n+    \n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         return arguments;\n     }\n \n-    public void markVerified() {\n-        verified = true;\n-    }\n-\n     public boolean isVerified() {\n         return verified;\n     }\n \n     public Integer getSequenceNumber() {\n         return sequenceNumber;\n-    }\n-\n-    public void markVerifiedInOrder() {\n-        this.markVerified();\n-        this.verifiedInOrder = true;\n     }\n \n     public boolean isVerifiedInOrder() {\n     public String toString(PrintSettings printSettings) {\n         return toString(argumentsToMatchers(), printSettings);\n     }\n+\n+    void markVerified() {\n+        this.verified = true;\n+    }\n+\n+    void markVerifiedInOrder() {\n+        markVerified();\n+        this.verifiedInOrder = true;\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationMarker.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.List;\n+\n+public class InvocationMarker {\n+\n+    public void markVerified(List<Invocation> invocations, CapturesArgumensFromInvocation wanted) {\n+        for (Invocation invocation : invocations) {\n+            invocation.markVerified();\n+            wanted.captureArgumentsFrom(invocation);\n+        }\n+    }\n+\n+    public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted) {\n+        markVerified(chunk, wanted);\n+        \n+        for (Invocation i : chunk) {\n+            i.markVerifiedInOrder();\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.internal.reporting.PrintSettings;\n import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n \n @SuppressWarnings(\"unchecked\")\n-public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation {\n+public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation {\n \n     private final Invocation invocation;\n     private final List<Matcher> matchers;\n     public String toString(PrintSettings printSettings) {\n         return invocation.toString(matchers, printSettings);\n     }\n+\n+    public void captureArgumentsFrom(Invocation i) {\n+        int k = 0;\n+        for (Matcher m : matchers) {\n+            if (m instanceof CapturesArguments) {\n+                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n+            }\n+            k++;\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/CapturesArguments.java\n+package org.mockito.internal.matchers;\n+\n+public interface CapturesArguments {\n+\n+    void captureFrom(Object argument);\n+\n+}\n--- a/src/org/mockito/internal/matchers/CapturingMatcher.java\n+++ b/src/org/mockito/internal/matchers/CapturingMatcher.java\n import org.mockito.exceptions.Reporter;\n \n @SuppressWarnings(\"unchecked\")\n-public class CapturingMatcher<T> extends ArgumentMatcher<T> {\n+public class CapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments {\n     \n     private LinkedList<Object> arguments = new LinkedList<Object>();\n \n      * @see org.mockito.ArgumentMatcher#matches(java.lang.Object)\n      */\n     public boolean matches(Object argument) {\n-        this.arguments.add(argument);\n         return true;\n     }    \n \n     public T getLastValue() {\n         if (arguments.isEmpty()) {\n             new Reporter().noArgumentValueWasCaptured();\n+            return null;\n         } else {\n             return (T) arguments.getLast();\n         }\n-        return (T) arguments;\n     }\n \n     public List<T> getAllValues() {\n         return (List) arguments;\n     }\n+\n+    public void captureFrom(Object argument) {\n+        this.arguments.add(argument);\n+    }\n }\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation {\n+public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments {\n \n     private final Matcher actualMatcher;\n     private Location location;\n             return false;\n         }\n     }\n+\n+    public void captureFrom(Object argument) {\n+        if (actualMatcher instanceof CapturesArguments) {\n+            ((CapturesArguments) actualMatcher).captureFrom(argument);\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n         return findAnswerFor(invocation).answer(invocation);\n     }\n \n-    public Answer<?> findAnswerFor(Invocation invocation) {\n+    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n         for (StubbedInvocationMatcher s : stubbed) {\n             if (s.matches(invocation)) {\n                 return s;\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n \n+@SuppressWarnings(\"unchecked\")\n public class MockUtil {\n     \n     private final CreationValidator creationValidator;\n         \n         MockName mockName = new MockName(settings.getMockName(), classToMock);\n         MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings);\n-        MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(classToMock, mockHandler);\n         Class<?>[] interfaces = settings.getExtraInterfaces();\n         Class<?>[] ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n         Object spiedInstance = settings.getSpiedInstance();\n     public <T> void resetMock(T mock, MockingProgress progress) {\n         MockHandler<T> oldMockHandler = (MockHandler<T>) getMockHandler(mock);\n         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>>(Object.class, newMockHandler);\n+        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(Object.class, newMockHandler);\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n         }\n \n         if (isMockitoMock(mock)) {\n-            return getInterceptor(mock).getDelegate();\n+            return getInterceptor(mock).getMockHandler();\n         } else {\n             throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n         }\n         return mock != null && isMockitoMock(mock);\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n+    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n         Factory factory = (Factory) mock;\n         Callback callback = factory.getCallback(0);\n         if (callback instanceof MethodInterceptorFilter) {\n-            return (MethodInterceptorFilter<MockHandler<T>>) callback;\n+            return (MethodInterceptorFilter) callback;\n         }\n         return null;\n     }\n--- a/src/org/mockito/internal/verification/AtMost.java\n+++ b/src/org/mockito/internal/verification/AtMost.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationMode;\n public class AtMost implements VerificationMode {\n \n     private final int maxNumberOfInvocations;\n+    private final InvocationMarker invocationMarker = new InvocationMarker();\n \n     public AtMost(int maxNumberOfInvocations) {\n         if (maxNumberOfInvocations < 0) {\n             new Reporter().wantedAtMostX(maxNumberOfInvocations, foundSize);\n         }\n         \n-        for (Invocation i : found) {\n-            i.markVerified();\n-        }\n+        invocationMarker.markVerified(found, wanted);\n     }\n }\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n \n public class AtLeastXNumberOfInvocationsChecker {\n     \n     private final Reporter reporter = new Reporter();\n     private final InvocationsFinder finder = new InvocationsFinder();\n+    private final InvocationMarker invocationMarker = new InvocationMarker();\n \n     public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n             reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        \n         }\n         \n-        for (Invocation i : actualInvocations) {\n-            i.markVerified();\n-        }\n+        invocationMarker.markVerified(invocations, wanted);\n     }\n }\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n \n public class AtLeastXNumberOfInvocationsInOrderChecker {\n     \n     private final Reporter reporter = new Reporter();\n     private final InvocationsFinder finder = new InvocationsFinder();\n+    private final InvocationMarker invocationMarker = new InvocationMarker();\n     \n     public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n         List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n             reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n         }\n         \n-        for (Invocation i : chunk) {\n-            i.markVerifiedInOrder();\n-        }\n+        invocationMarker.markVerifiedInOrder(chunk, wanted);\n     }\n }\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n \n public class NumberOfInvocationsChecker {\n     \n     private final Reporter reporter;\n     private final InvocationsFinder finder;\n+    private final InvocationMarker invocationMarker = new InvocationMarker();\n \n     public NumberOfInvocationsChecker() {\n         this(new Reporter(), new InvocationsFinder());\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n-        for (Invocation i : actualInvocations) {\n-            i.markVerified();\n-        }\n+        invocationMarker.markVerified(actualInvocations, wanted);\n     }\n-}\n+}\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n \n public class NumberOfInvocationsInOrderChecker {\n     \n     private final Reporter reporter;\n     private final InvocationsFinder finder;\n+    private final InvocationMarker invocationMarker = new InvocationMarker();\n     \n     public NumberOfInvocationsInOrderChecker() {\n         this(new InvocationsFinder(), new Reporter());\n             reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n-        for (Invocation i : chunk) {\n-            i.markVerifiedInOrder();\n-        }\n+        invocationMarker.markVerifiedInOrder(chunk, wanted);\n     }\n }\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.MockingProgressImpl;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n-        MockingProgress state = new MockingProgressImpl();\n-        state.verificationStarted(VerificationModeFactory.atLeastOnce());\n-        MockHandler handler = new MockHandler(null, state, new ExceptionThrowingBinder(), null);\n+        //given\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        MockHandler handler = new MockHandler();\n+        handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+        handler.matchersBinder = new MatchersBinder() {\n+            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+                throw new InvalidUseOfMatchersException();\n+            }\n+        };\n         \n         try {\n-            handler.intercept(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{}, null);\n+            //when\n+            handler.handle(invocation);\n+            \n+            //then\n             fail();\n         } catch (InvalidUseOfMatchersException e) {}\n         \n-        assertNull(state.pullVerificationMode());\n-    }\n-    \n-    private class ExceptionThrowingBinder extends MatchersBinder {\n-        @Override\n-        public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n-            throw new InvalidUseOfMatchersException(\"\");\n-        }\n+        assertNull(handler.mockingProgress.pullVerificationMode());\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+import org.mockito.internal.util.ObjectBox;\n+import org.mockitoutil.TestBase;\n+\n+public class InvocationMarkerTest extends TestBase {\n+\n+    @Test\n+    public void shouldMarkInvocationAsVerified() {\n+        //given\n+        InvocationMarker marker = new InvocationMarker();\n+        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n+        assertFalse(i.isVerified());\n+        \n+        //when\n+        marker.markVerified(Arrays.asList(i), im);\n+        \n+        //then\n+        assertTrue(i.isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldCaptureArguments() {\n+        //given\n+        InvocationMarker marker = new InvocationMarker();\n+        Invocation i = new InvocationBuilder().toInvocation();\n+        final ObjectBox box = new ObjectBox();\n+        CapturesArgumensFromInvocation c = new CapturesArgumensFromInvocation() {\n+            public void captureArgumentsFrom(Invocation i) {\n+                box.put(i);\n+            }};\n+        \n+        //when\n+        marker.markVerified(Arrays.asList(i), c);\n+        \n+        //then\n+        assertEquals(i, box.getObject());\n+    }\n+\n+    @Test\n+    public void shouldMarkInvocationsAsVerifiedInOrder() {\n+        //given\n+        InvocationMarker marker = new InvocationMarker();\n+        Invocation i = new InvocationBuilder().toInvocation();\n+        InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n+        assertFalse(i.isVerifiedInOrder());\n+        assertFalse(i.isVerified());\n+        \n+        //when\n+        marker.markVerifiedInOrder(Arrays.asList(i), im);\n+        \n+        //then\n+        assertTrue(i.isVerifiedInOrder());\n+        assertTrue(i.isVerified());\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import static org.mockitoutil.ExtraMatchers.*;\n \n import java.lang.reflect.Method;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n \n import org.hamcrest.Matcher;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n+import org.mockito.internal.matchers.CapturingMatcher;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.NotNull;\n import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n         \n         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n+    \n+    @Test\n+    public void shouldCaptureArgumentsFromInvocation() throws Exception {\n+        //given\n+        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        CapturingMatcher capturingMatcher = new CapturingMatcher();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) Arrays.asList(new Equals(\"1\"), capturingMatcher));        \n+        \n+        //when\n+        invocationMatcher.captureArgumentsFrom(invocation);\n+        \n+        //then\n+        assertEquals(1, capturingMatcher.getAllValues().size());\n+        assertEquals(100, capturingMatcher.getLastValue());\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/matchers/CapturingMatcherTest.java\n+package org.mockito.internal.matchers;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CapturingMatcherTest extends TestBase {\n+\n+    @Test\n+    public void shouldCaptureArguments() throws Exception {\n+        //given\n+        CapturingMatcher m = new CapturingMatcher();\n+        \n+        //when\n+        m.captureFrom(\"foo\");\n+        m.captureFrom(\"bar\");\n+        \n+        //then\n+        Assertions.assertThat(m.getAllValues()).containsSequence(\"foo\", \"bar\");\n+    }\n+    \n+    @Test\n+    public void shouldKnowLastCapturedValue() throws Exception {\n+        //given\n+        CapturingMatcher m = new CapturingMatcher();\n+        \n+        //when\n+        m.captureFrom(\"foo\");\n+        m.captureFrom(\"bar\");\n+        \n+        //then\n+        assertEquals(\"bar\", m.getLastValue());\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenNothingYetCaptured() throws Exception {\n+        //given\n+        CapturingMatcher m = new CapturingMatcher();\n+\n+        try {\n+            //when\n+            m.getLastValue();\n+            //then\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- a/test/org/mockito/internal/matchers/LocalizedMatcherTest.java\n+++ b/test/org/mockito/internal/matchers/LocalizedMatcherTest.java\n         //then\n         assertSame(m, m.withExtraTypeInfo());\n     }\n+    \n+    @Test\n+    public void shouldDelegateToCapturingMatcher() throws Exception {\n+        //given\n+        CapturingMatcher capturingMatcher = new CapturingMatcher();\n+        LocalizedMatcher m = new LocalizedMatcher(capturingMatcher);\n+        \n+        //when\n+        m.captureFrom(\"boo\");\n+        \n+        //then\n+        assertEquals(\"boo\", capturingMatcher.getLastValue());\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/ObjectBox.java\n+package org.mockito.internal.util;\n+\n+\n+public class ObjectBox {\n+\n+    private Object object;\n+\n+    public void put(Object object) {\n+        this.object = object;\n+    }\n+    \n+    public Object getObject() {\n+        return object;\n+    }\n+}\n--- a/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n+++ b/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n  */\n package org.mockitousage.matchers;\n \n+import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n import java.util.List;\n import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n public class CapturingArgumentsTest extends TestBase {\n \n+    @Mock IMethods mock;\n+    \n     class Person {\n \n         private final Integer age;\n         } catch (MockitoException e) {}\n     }\n     \n+    @Test\n+    public void shouldCaptureWhenFullArgListMatches() throws Exception {\n+        //given\n+        mock.simpleMethod(\"foo\", 1);\n+        mock.simpleMethod(\"bar\", 2);\n+        \n+        //when\n+        ArgumentCaptor<String> captor = new ArgumentCaptor<String>();\n+        verify(mock).simpleMethod(captor.capture(), eq(1));\n+        \n+        //then\n+        assertEquals(1, captor.getAllValues().size());\n+        assertEquals(\"foo\", captor.getValue());\n+    }\n+    \n     //TODO: not yet implemented\n     @Ignore\n     @Test", "timestamp": 1248035288, "metainfo": ""}