{"sha": "e78afec0f5d00d52256a6e7234b3bf0fc80d2322", "log": "Better Javadoc for the MockMaker interface", "commit": "\n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n import org.mockito.internal.Incubating;\n \n /**\n- * The facility to create mocks. By default, a cglib/asm based implementation is used.\n- * It is possible to configure your own mock maker so that dynamic proxies are created without cglib/asm.\n+ * The facility to create mocks.\n+ *\n+ * <p>By default, an internal cglib/asm based implementation is used.</p>\n+ *\n+ * <p>It is possible to configure your own mock maker so that dynamic proxies are created without cglib/asm.\n  * For example, the android users can use a MockMaker that can work with Dalvik virtual machine\n- * and hence bring Mockito to android apps developers.\n+ * and hence bring Mockito to android apps developers.</p>\n  *\n- * TODO: way more documentation and examples.\n+ * <p>Can load available mockito extensions. Currently Mockito only have one extension point the\n+ * {@link MockMaker}. This extension point allows a user to provide his own bytecode engine to build mocks.</p>\n+ *\n+ * <p>Suppose you wrote an extension to create mocks with some <em>Awesome</em> library, in order to tell\n+ * Mockito to use it you need to put in your classpath\n+ * <ol style=\"list-style-type: lower-alpha\">\n+ *     <li>The implementation itself, for example <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ *     <li>A file named <code>org.mockito.plugins.MockMaker</code> in a folder named\n+ *     <code>mockito-extensions</code>, the content of this file need to have <strong>one</strong> line with\n+ *     the qualified name <code>org.awesome.mockito.AwesomeMockMaker</code>.</li>\n+ * </ol></p>\n+ *\n+ * @see MockSettingsInfo\n+ * @see MockitoInvocationHandler\n+ * @see org.mockito.internal.configuration.ClassPathLoader\n  */\n @Incubating\n public interface MockMaker {\n      * Returns a new instance of {@code typeToMock} that implements the\n      * interfaces of {@code extraInterfaces}. Invocations to the methods of the\n      * returned instance will be delegated to {@code handler}.\n+     *\n+     * @param typeToMock The type to imposterize, could be a <strong>class</strong> or an <strong>interface</strong>.\n+     * @param extraInterfaces Interfaces the mock should implements as well, never <code>null</code>.\n+     * @param handler Handler of every invocation on the mock.\n+     * @param settings Mock creation settings.\n+     * @param <T> Type of the mock to return, actually the <code>typeToMock</code>.\n+     * @return The mock instance.\n      */\n-    <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n-            MockitoInvocationHandler handler, MockSettingsInfo settings);\n+    <T> T createMock(\n+            Class<T> typeToMock,\n+            Class<?>[] extraInterfaces,\n+            MockitoInvocationHandler handler,\n+            MockSettingsInfo settings\n+    );\n \n     /**\n      * Returns the handler for the {@code mock}, or null if {@code mock} was not\n-     * a mock object created by {@link #createMock}.\n+     * a mock object created by {@link #createMock(Class, Class[], MockitoInvocationHandler, MockSettingsInfo)}.\n+     *\n+     * @param mock The mock instance.\n+     * @return The invocation handler if this object is a mock, otherwise <code>null</code>.\n      */\n     MockitoInvocationHandler getHandler(Object mock);\n \n     /**\n      * Replaces the existing handler on {@code mock} with {@code newHandler}.\n+     *\n+     * <p>The invocation handler actually store invocations to achieve\n+     * stubbing and verification. In order to reset the mock, we pass\n+     * a new instance of the invocation handler.</p>\n+     *\n+     * @param mock The mock instance whose invocation handler shall be replaced.\n+     * @param newHandler The new invocation handler instance.\n+     * @param settings The mock settings.\n      */\n-    void resetMock(Object mock, MockitoInvocationHandler newHandler,\n-                          MockSettingsInfo settings);\n+    void resetMock(\n+            Object mock,\n+            MockitoInvocationHandler newHandler,\n+            MockSettingsInfo settings\n+    );\n }\n--- a/src/org/mockito/plugins/MockitoInvocationHandler.java\n+++ b/src/org/mockito/plugins/MockitoInvocationHandler.java\n  */\n package org.mockito.plugins;\n \n-import java.io.Serializable;\n-\n import org.mockito.internal.Incubating;\n import org.mockito.internal.invocation.Invocation;\n \n+import java.io.Serializable;\n+\n /**\n- * Handles the invocation on a mock\n+ * Mockito handler of an invocation on a mock.\n  *\n- * TODO - should it extend serializable?\n+ * <p>Takes an invocation object and handles it.\n+ * The Invocation instance should be created by the mock maker internal filter.</p>\n  */\n+// TODO XXX Invocation is concrete and in another package, could we use a Factory and use an interface instead.\n+// see MethodInterceptorFilter\n @Incubating\n public interface MockitoInvocationHandler extends Serializable {\n \n+    /**\n+     * Handles the invocation.\n+     *\n+     * @param invocation The invocation to handle\n+     * @return Result\n+     * @throws Throwable Throwable\n+     */\n     @Incubating\n     Object handle(Invocation invocation) throws Throwable;\n ", "timestamp": 1333130998, "metainfo": ""}