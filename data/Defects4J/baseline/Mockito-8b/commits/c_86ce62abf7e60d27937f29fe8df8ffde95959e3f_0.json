{"sha": "86ce62abf7e60d27937f29fe8df8ffde95959e3f", "log": "issue 399 fixes serialization for deep stub answer   - disables generics deep stub when serialization occurs (not supported yet)  - also refactored a bit the initialization of this answer", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.withSettings;\n \n+import java.io.IOException;\n import java.io.Serializable;\n-\n import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.settings.CreationSettings;\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n-    private transient MockitoCore mockitoCore;\n-    private transient ReturnsEmptyValues delegate;\n-\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n-        instantiateMockitoCoreIfNeeded();\n-        instantiateDelegateIfNeeded();\n-        if (!mockitoCore.isTypeMockable(rawType)) {\n-            return delegate.returnValueFor(rawType);\n+        if (!mockitoCore().isTypeMockable(rawType)) {\n+            return delegate().returnValueFor(rawType);\n         }\n \n-        return getMock(invocation, returnTypeGenericMetadata);\n+        return makeDeepMock(invocation, returnTypeGenericMetadata);\n     }\n \n-    private synchronized void instantiateMockitoCoreIfNeeded() {\n-        if (mockitoCore == null) {\n-            mockitoCore = new MockitoCore();\n-        }\n-    }\n+\tprivate void instantiateFieldsIfNeeded() {\n+\t\tif (mockitoCore == null) {\n+\t\t\tmockitoCore = new MockitoCore();\n+\t\t}\n+\t\tif (delegate == null) {\n+\t\t\tdelegate = new ReturnsEmptyValues();\n+\t\t}\n+\t}\n \n-    private synchronized void instantiateDelegateIfNeeded() {\n-        if (delegate == null) {\n-            delegate = new ReturnsEmptyValues();\n-        }\n-    }\n-\n-    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n+\tprivate Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n      * @return The mock\n      */\n     private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n-        return mockitoCore.mock(\n+        return mockitoCore().mock(\n                 returnTypeGenericMetadata.rawType(),\n                 withSettingsUsing(returnTypeGenericMetadata)\n         );\n     }\n \n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n-        return new ReturnsDeepStubs() {\n-            @Override\n-            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n-                return returnTypeGenericMetadata;\n-            }\n-        };\n+        return new NotSerializableGenericsAwareReturnsDeepStubs(returnTypeGenericMetadata);\n     }\n \n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n-\n         container.addAnswer(new SerializableAnswer() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n                 return mock;\n             }\n         }, false);\n-\n         return mock;\n     }\n-\t\n-\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n-\t\t\n+\n+    private static class NotSerializableGenericsAwareReturnsDeepStubs extends ReturnsDeepStubs implements Serializable {\n+        private final GenericMetadataSupport returnTypeGenericMetadata;\n+\n+        public NotSerializableGenericsAwareReturnsDeepStubs(GenericMetadataSupport returnTypeGenericMetadata) {\n+            this.returnTypeGenericMetadata = returnTypeGenericMetadata;\n+        }\n+\n+        @Override\n+        protected GenericMetadataSupport actualParameterizedType(Object mock) {\n+            return returnTypeGenericMetadata;\n+        }\n+\n+        private Object writeReplace() throws IOException {\n+            return Mockito.RETURNS_DEEP_STUBS;\n+        }\n+    }\n+\n+    abstract class SerializableAnswer implements Answer<Object>, Serializable {\n \t}\n \t\n \n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n         return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n     }\n+\n+\n+    private static MockitoCore mockitoCore() {\n+        return LazyHolder.MOCKITO_CORE;\n+    }\n+    private static ReturnsEmptyValues delegate() {\n+        return LazyHolder.DELEGATE;\n+    }\n+    private static class LazyHolder {\n+        private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n+        private static final ReturnsEmptyValues DELEGATE = new ReturnsEmptyValues();\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/DeepStubsSerializableTest.java\n+package org.mockitousage.serialization;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.junit.Test;\n+\n+public class DeepStubsSerializableTest {\n+\n+    @Test\n+    public void should_serialize_and_deserialize_mock_created_with_deep_stubs() throws Exception {\n+        // given\n+        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+        when(sampleClass.getSample().isFalse()).thenReturn(true);\n+        when(sampleClass.getSample().number()).thenReturn(999);\n+\n+        // when\n+        SampleClass deserializedSample = serializeAndBack(sampleClass);\n+\n+        // then\n+        assertThat(deserializedSample.getSample().isFalse()).isEqualTo(true);\n+        assertThat(deserializedSample.getSample().number()).isEqualTo(999);\n+    }\n+\n+\t@Test\n+\tpublic void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs() throws Exception {\n+\t\t// given\n+\t\tListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+\t\twhen(deep_stubbed.iterator().next().add(\"yes\")).thenReturn(true);\n+\n+\t\t// when\n+\t\tListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);\n+\t\t\n+\t\t// then\n+\t\tassertThat(deserialized_deep_stub.iterator().next().add(\"not stubbed but mock already previously resolved\")).isEqualTo(false);\n+        assertThat(deserialized_deep_stub.iterator().next().add(\"yes\")).isEqualTo(true);\n+\t}\n+\n+\t@Test(expected = ClassCastException.class)\n+\tpublic void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {\n+\t\t// given\n+\t\tListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+\t\twhen(deep_stubbed.iterator().hasNext()).thenReturn(true);\n+\n+\t\tListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);\n+\n+\t\t// when stubbing on a deserialized mock\n+        when(deserialized_deep_stub.iterator().next().get(42)).thenReturn(\"no\");\n+\n+\t\t// then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException\n+\t}\n+\n+\n+    static class SampleClass implements Serializable {\n+        SampleClass2 getSample() { return new SampleClass2(); }\n+    }\n+\n+    static class SampleClass2 implements Serializable {\n+        boolean isFalse() { return false; }\n+        int number() { return 100; }\n+    }\n+\n+    static class Container<E> implements Iterable<E>, Serializable {\n+        private E e;\n+        public Container(E e) { this.e = e; }\n+        public E get() { return e; }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new Iterator<E>() {\n+                @Override public boolean hasNext() { return true; }\n+                @Override public E next() { return e; }\n+                @Override public void remove() { }\n+            };\n+        }\n+    }\n+\n+    static class ListContainer extends Container<List<String>> {\n+        public ListContainer(List<String> list) { super(list); }\n+    }\n+}", "timestamp": 1394497239, "metainfo": ""}