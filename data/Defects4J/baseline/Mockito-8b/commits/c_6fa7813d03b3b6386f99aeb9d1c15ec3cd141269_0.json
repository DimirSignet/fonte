{"sha": "6fa7813d03b3b6386f99aeb9d1c15ec3cd141269", "log": "Binary comparator now compares zips. Tidy-ups pending.", "commit": "\n--- a/buildSrc/src/main/groovy/org/mockito/release/comparison/BinaryComparator.java\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/BinaryComparator.java\n         final byte[] hash1 = hasher.hash(file1);\n         final byte[] hash2 = hasher.hash(file2);\n \n-        final boolean equals = Arrays.equals(hash1, hash2);\n+        final boolean equals = new ZipCompare().compareZips(file1.getAbsolutePath(), file2.getAbsolutePath());\n \n         return new Result() {\n             public boolean areEqual() { return equals; }\n--- /dev/null\n+++ b/buildSrc/src/main/groovy/org/mockito/release/comparison/ZipCompare.java\n+package org.mockito.release.comparison;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+class ZipCompare {\n+\n+    boolean compareZips(String filePath1, String filePath2) {\n+        ZipFile file1;\n+        try {\n+            file1 = new ZipFile(filePath1);\n+        } catch (IOException e) {\n+            System.out.println(\"Could not open zip file \" + filePath1 + \": \" + e);\n+            return false;\n+        }\n+\n+        ZipFile file2;\n+        try {\n+            file2 = new ZipFile(filePath2);\n+        } catch (IOException e) {\n+            System.out.println(\"Could not open zip file \" + filePath1 + \": \" + e);\n+            return false;\n+        }\n+\n+        System.out.println(\"Comparing \" + filePath1 + \" with \" + filePath2 + \":\");\n+\n+        Set set1 = new LinkedHashSet();\n+        for (Enumeration e = file1.entries(); e.hasMoreElements(); )\n+            set1.add(((ZipEntry) e.nextElement()).getName());\n+\n+        Set set2 = new LinkedHashSet();\n+        for (Enumeration e = file2.entries(); e.hasMoreElements(); )\n+            set2.add(((ZipEntry) e.nextElement()).getName());\n+\n+        int errcount = 0;\n+        int filecount = 0;\n+        for (Iterator i = set1.iterator(); i.hasNext(); ) {\n+            String name = (String) i.next();\n+            if (!set2.contains(name)) {\n+                System.out.println(name + \" not found in \" + filePath2);\n+                errcount += 1;\n+                continue;\n+            }\n+            try {\n+                set2.remove(name);\n+                if (!streamsEqual(file1.getInputStream(file1.getEntry(name)), file2.getInputStream(file2\n+                        .getEntry(name)))) {\n+                    System.out.println(name + \" does not match\");\n+                    errcount += 1;\n+                    continue;\n+                }\n+            } catch (Exception e) {\n+                System.out.println(name + \": IO Error \" + e);\n+                e.printStackTrace();\n+                errcount += 1;\n+                continue;\n+            }\n+            filecount += 1;\n+        }\n+        for (Iterator i = set2.iterator(); i.hasNext(); ) {\n+            String name = (String) i.next();\n+            System.out.println(name + \" not found in \" + filePath1);\n+            errcount += 1;\n+        }\n+        System.out.println(filecount + \" entries matched\");\n+        if (errcount > 0) {\n+            System.out.println(errcount + \" entries did not match\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    static boolean streamsEqual(InputStream stream1, InputStream stream2) throws IOException {\n+        byte[] buf1 = new byte[4096];\n+        byte[] buf2 = new byte[4096];\n+        boolean done1 = false;\n+        boolean done2 = false;\n+\n+        try {\n+            while (!done1) {\n+                int off1 = 0;\n+                int off2 = 0;\n+\n+                while (off1 < buf1.length) {\n+                    int count = stream1.read(buf1, off1, buf1.length - off1);\n+                    if (count < 0) {\n+                        done1 = true;\n+                        break;\n+                    }\n+                    off1 += count;\n+                }\n+                while (off2 < buf2.length) {\n+                    int count = stream2.read(buf2, off2, buf2.length - off2);\n+                    if (count < 0) {\n+                        done2 = true;\n+                        break;\n+                    }\n+                    off2 += count;\n+                }\n+                if (off1 != off2 || done1 != done2)\n+                    return false;\n+                for (int i = 0; i < off1; i++) {\n+                    if (buf1[i] != buf2[i])\n+                        return false;\n+                }\n+            }\n+            return true;\n+        } finally {\n+            stream1.close();\n+            stream2.close();\n+        }\n+    }\n+}", "timestamp": 1416078253, "metainfo": ""}