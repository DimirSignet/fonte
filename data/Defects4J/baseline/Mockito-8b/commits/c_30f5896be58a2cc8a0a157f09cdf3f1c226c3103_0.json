{"sha": "30f5896be58a2cc8a0a157f09cdf3f1c226c3103", "log": "refactored some stuff from MockitoBehavior into RegisteredInvocations  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4078", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n+package org.mockito.internal;\n+\n+import java.util.*;\n+\n+public class AllInvocationsFinder implements InvocationsFinder {\n+\n+    public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n+        List<Invocation> allInvocations = new LinkedList<Invocation>();\n+        for (Object mock : mocks) {\n+            List<Invocation> invocationsOfSingleMock = MockUtil.getControl(mock).getRegisteredInvocations();\n+            allInvocations.addAll(invocationsOfSingleMock);\n+        }\n+        return allInvocations;\n+    }\n+}\n--- a/src/org/mockito/internal/ExpectedInvocation.java\n+++ b/src/org/mockito/internal/ExpectedInvocation.java\n         this.matchers = matchers;\n     }\n     \n-    //TODO add test that makes sure sequenceNumber doesnt take part in equals()\n     public boolean equals(Object o) {\n         if (o == null || !this.getClass().equals(o.getClass()))\n             return false;\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n public class Invocation {\n \n     private boolean verified;\n-    private int sequenceNumber;\n     \n+    private final int sequenceNumber;\n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n \n-    public Invocation(Object mock, Method method, Object[] args) {\n+    public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n         this.mock = mock;\n         this.method = method;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n+        this.sequenceNumber = sequenceNumber;\n     }\n \n     private static Object[] expandVarArgs(final boolean isVarArgs,\n         return arguments;\n     }\n \n+    //TODO add test that makes sure sequenceNumber doesnt take part in equals()\n     public boolean equals(Object o) {\n         if (o == null || !o.getClass().equals(this.getClass()))\n             return false;\n     public Integer getSequenceNumber() {\n         return sequenceNumber;\n     }\n-\n-    public void setSequenceNumber(int sequenceNumber) {\n-        this.sequenceNumber = sequenceNumber;\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationsFinder.java\n+package org.mockito.internal;\n+\n+import java.util.List;\n+\n+public interface InvocationsFinder {\n+\n+    List<Invocation> allInvocationsInOrder(List<Object> mocks);\n+\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n         \n-        Invocation invocation = new Invocation(proxy, method, args);\n+        Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n         List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n //        }\n         \n         mockitoState.reportLastControl(this);\n-        \n-        invocation.setSequenceNumber(mockitoState.nextSequenceNumber());\n         \n         behavior.addInvocation(expectedInvocation);\n         \n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n     private T mock;\n     \n-    //TODO change this class to RegisteredInvocations that we can as about different stuff so Behavior can verify based on answers\n-    private List<Invocation> registeredInvocations = new LinkedList<Invocation>();\n+    private RegisteredInvocations registeredInvocations = new RegisteredInvocations(new AllInvocationsFinder());\n     private Map<ExpectedInvocation, Result> results = new HashMap<ExpectedInvocation, Result>();\n \n     private ExpectedInvocation invocationForStubbing;\n \n     public void addResult(Result result) {\n         assert invocationForStubbing != null;\n-        registeredInvocations.remove(invocationForStubbing.getInvocation());\n+        registeredInvocations.removeLast();\n         this.results.put(invocationForStubbing, result);\n     }\n \n         checkForMissingInvocation(expected, verifyingMode);\n         checkOrderOfInvocations(expected, verifyingMode);\n         checkForWrongNumberOfInvocations(expected, verifyingMode);        \n-        markInvocationsAsVerified(expected, verifyingMode);\n+        registeredInvocations.markInvocationsAsVerified(expected, verifyingMode);\n     }\n     \n-    void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode mode) {\n-        if (mode.expectedCountIsZero()) {\n-            return;\n-        }\n-        \n-        if (mode.orderOfInvocationsMatters()) {\n-            List<InvocationChunk> chunks = getUnverifiedInvocationChunks(mode);\n-            chunks.get(0).markAllInvocationsAsVerified();\n-        } else {\n-            for (Invocation invocation : registeredInvocations) {\n-                if (expected.matches(invocation)) {\n-                    invocation.markVerified();\n-                }\n-            }\n-        }\n-    }\n-\n     private void checkForMissingInvocation(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        int actualCount = numberOfActualInvocations(expected);\n+        int actualCount = registeredInvocations.countActual(expected);\n         Integer expectedCount = verifyingMode.expectedCount();\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n                \n             return;\n         }\n         \n-        int actuallyInvoked = numberOfActualInvocations(expected);\n+        int actuallyInvoked = registeredInvocations.countActual(expected);\n         Integer expectedInvoked = verifyingMode.expectedCount();\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n         \n \n     private void reportMissingInvocationError(ExpectedInvocation invocation) throws VerificationAssertionError {\n         //TODO refactor message building somewhere else...\n-        Invocation similarInvocation = findSimilarInvocation(invocation);\n+        Invocation similarInvocation = registeredInvocations.findSimilarInvocation(invocation);\n         String message = \n             \"\\n\" +\n             \"Invocation differs from actual\" +\n             return;\n         }\n         \n-        List<InvocationChunk> chunks = getUnverifiedInvocationChunks(mode);\n+        List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n         \n         if (mode.expectedCountIsZero() && !chunks.isEmpty() && expected.matches(chunks.get(0).getInvocation())) {\n             throw new NumberOfInvocationsAssertionError(0, chunks.get(0).getCount(), expected);\n         }\n     }\n \n-    private List<InvocationChunk> getUnverifiedInvocationChunks(VerifyingMode verifyingMode) {\n-        Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n-                new Comparator<Invocation>(){\n-                    public int compare(Invocation o1, Invocation o2) {\n-                        int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n-                        assert comparison != 0;\n-                        return comparison;\n-                    }});\n-        \n-        List<Object> allMocksToBeVerifiedInOrder = verifyingMode.getAllMocksToBeVerifiedInSequence();\n-        for (Object mock : allMocksToBeVerifiedInOrder) {\n-            List<Invocation> invocations = MockUtil.getControl(mock).getRegisteredInvocations();\n-            allInvocationsInOrder.addAll(invocations);\n-        }\n-        \n-        List<InvocationChunk> chunks = new LinkedList<InvocationChunk>();\n-        for (Invocation i : allInvocationsInOrder) {\n-            if (i.isVerified()) {\n-                continue;\n-            }\n-            if (!chunks.isEmpty() \n-                    && chunks.get(chunks.size()-1).getInvocation().equals(i)) {\n-                chunks.get(chunks.size()-1).add(i);\n-            } else {\n-                chunks.add(new InvocationChunk(i));\n-            }\n-        }\n-        \n-        return chunks;\n-    }\n-\n-    /**\n-     * gets first registered invocation with the same method name\n-     * or just first invocation\n-     */\n-    private Invocation findSimilarInvocation(ExpectedInvocation expectedInvocation) {\n-        for (Invocation registered : registeredInvocations) {\n-            String expectedMethodName = expectedInvocation.getMethod().getName();\n-            String registeredInvocationName = registered.getMethod().getName();\n-            if (expectedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n-                return registered;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private int numberOfActualInvocations(ExpectedInvocation expectedInvocation) {\n-        int actual = 0;\n-        for (Invocation registeredInvocation : registeredInvocations) {\n-            if (expectedInvocation.matches(registeredInvocation)) {\n-                actual++;\n-            }\n-        }\n-\n-        return actual;\n-    }\n-\n     public void verifyNoMoreInteractions() {\n         verifyNoMoreInteractions(\"No more interactions expected\");\n     }\n     }\n     \n     private void verifyNoMoreInteractions(String verificationErrorMessage) {\n-        for (Invocation registeredInvocation : registeredInvocations) {\n+        for (Invocation registeredInvocation : registeredInvocations.all()) {\n             if (!registeredInvocation.isVerified()) {\n                 String mockName = Namer.nameForMock(mock);\n                 throw new VerificationAssertionError(\n     }\n \n     public List<Invocation> getRegisteredInvocations() {\n-        return registeredInvocations;\n+        return registeredInvocations.all();\n     }\n \n     public ExpectedInvocation getInvocationForStubbing() {\n--- /dev/null\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n+package org.mockito.internal;\n+\n+import java.util.*;\n+\n+public class RegisteredInvocations {\n+    \n+    private List<Invocation> registeredInvocations = new LinkedList<Invocation>();\n+    private final InvocationsFinder invocationsFinder;\n+    \n+    public RegisteredInvocations(InvocationsFinder invocationsFinder) {\n+        this.invocationsFinder = invocationsFinder;\n+    }\n+\n+    public void add(Invocation invocation) {\n+        registeredInvocations.add(invocation);        \n+    }\n+\n+    public void removeLast() {\n+        registeredInvocations.remove(registeredInvocations.size()-1);\n+    }\n+    \n+    public void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode mode) {\n+        if (mode.expectedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (mode.orderOfInvocationsMatters()) {\n+            List<InvocationChunk> chunks = unverifiedInvocationChunks(mode);\n+            chunks.get(0).markAllInvocationsAsVerified();\n+        } else {\n+            for (Invocation invocation : registeredInvocations) {\n+                if (expected.matches(invocation)) {\n+                    invocation.markVerified();\n+                }\n+            }\n+        }\n+    }\n+    \n+    public List<InvocationChunk> unverifiedInvocationChunks(VerifyingMode verifyingMode) {\n+        Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n+                new Comparator<Invocation>(){\n+                    public int compare(Invocation o1, Invocation o2) {\n+                        int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n+                        assert comparison != 0;\n+                        return comparison;\n+                    }});\n+        \n+        List<Object> allMocksToBeVerifiedInOrder = verifyingMode.getAllMocksToBeVerifiedInSequence();\n+        List<Invocation> allInvocations = invocationsFinder.allInvocationsInOrder(allMocksToBeVerifiedInOrder);\n+        allInvocationsInOrder.addAll(allInvocations);\n+        \n+        List<InvocationChunk> chunks = new LinkedList<InvocationChunk>();\n+        for (Invocation i : allInvocationsInOrder) {\n+            if (i.isVerified()) {\n+                continue;\n+            }\n+            if (!chunks.isEmpty() \n+                    && chunks.get(chunks.size()-1).getInvocation().equals(i)) {\n+                chunks.get(chunks.size()-1).add(i);\n+            } else {\n+                chunks.add(new InvocationChunk(i));\n+            }\n+        }\n+        \n+        return chunks;\n+    }\n+    \n+    /**\n+     * gets first registered invocation with the same method name\n+     * or just first invocation\n+     */\n+    public Invocation findSimilarInvocation(ExpectedInvocation expectedInvocation) {\n+        for (Invocation registered : registeredInvocations) {\n+            String expectedMethodName = expectedInvocation.getMethod().getName();\n+            String registeredInvocationName = registered.getMethod().getName();\n+            if (expectedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n+                return registered;\n+            }\n+        }\n+\n+        return null;\n+    }\n+    \n+    public int countActual(ExpectedInvocation expectedInvocation) {\n+        int actual = 0;\n+        for (Invocation registeredInvocation : registeredInvocations) {\n+            if (expectedInvocation.matches(registeredInvocation)) {\n+                actual++;\n+            }\n+        }\n+\n+        return actual;\n+    }\n+\n+    public List<Invocation> all() {\n+        return registeredInvocations;\n+    }\n+}\n--- a/test/org/mockito/InvocationTest.java\n+++ b/test/org/mockito/InvocationTest.java\n         dummyMethod = Object.class.getMethod(\"equals\",\n                 new Class[] { Object.class });\n         Object mock = new Object();\n-        call = new Invocation(mock, dummyMethod, arguments1);\n-        equalCall = new Invocation(mock, dummyMethod, arguments2);\n-        nonEqualCall = new Invocation(mock, dummyMethod, arguments3);\n+        call = new Invocation(mock, dummyMethod, arguments1, 0);\n+        equalCall = new Invocation(mock, dummyMethod, arguments2, 0);\n+        nonEqualCall = new Invocation(mock, dummyMethod, arguments3, 0);\n     }\n \n     @Test\n--- a/test/org/mockito/internal/ExpectedInvocationTest.java\n+++ b/test/org/mockito/internal/ExpectedInvocationTest.java\n     public void shouldImplementHashcodeToBeHashMapsCitizen() throws Exception {\n         Object[] args = new Object[] { \"\" };\n         Method m = Object.class.getMethod(\"equals\", new Class[] { Object.class });\n-        Invocation invocation = new Invocation(null, m, args);\n+        Invocation invocation = new Invocation(null, m, args, 0);\n         assertThat(new ExpectedInvocation(invocation, null).hashCode(), equalTo(1));\n     }\n     \n                 new Class[] { Object.class });\n \n         ExpectedInvocation invocationWithOneArg = new ExpectedInvocation(\n-                new Invocation(mock, dummyMethod, new Object[] { \"\" }), null);\n+                new Invocation(mock, dummyMethod, new Object[] { \"\" }, 0), null);\n         ExpectedInvocation invocationWithTwoArgs = new ExpectedInvocation(\n-                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }), null);\n+                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }, 0), null);\n \n         assertFalse(invocationWithOneArg.equals(null));\n         assertFalse(invocationWithOneArg.equals(invocationWithTwoArgs));\n--- a/test/org/mockito/internal/MockitoBehaviorTest.java\n+++ b/test/org/mockito/internal/MockitoBehaviorTest.java\n  */\n package org.mockito.internal;\n \n-import static org.junit.Assert.assertEquals;\n-\n import java.lang.reflect.Method;\n import java.util.*;\n-\n+import static org.junit.Assert.*;\n import org.junit.*;\n \n @SuppressWarnings(\"unchecked\")\n \n     private MockitoBehavior behavior;\n     private ExpectedInvocation toLowerCaseInvocation;\n-    private ExpectedInvocation toUpperCaseInvocation;\n-    private ExpectedInvocation toLowerCaseInvocationTwo;\n-    private ExpectedInvocation toLowerCaseInvocationThree;\n \n     @Before\n     public void setup() throws Exception {\n         Method toLowerCase = String.class.getMethod(\"toLowerCase\", new Class[] {});\n-        Method toUpperCase = String.class.getMethod(\"toUpperCase\", new Class[] {});\n         \n-        toLowerCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n-        toLowerCaseInvocationTwo = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n-        toLowerCaseInvocationThree = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n-        toUpperCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toUpperCase , new Object[] {}), Collections.EMPTY_LIST);\n+        toLowerCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}, 0), Collections.EMPTY_LIST);\n         \n         behavior = new MockitoBehavior();\n-        \n-        behavior.addInvocation(toLowerCaseInvocation);\n-        behavior.addInvocation(toLowerCaseInvocationTwo);\n-        \n-        behavior.addInvocation(toUpperCaseInvocation);\n-        \n-        behavior.addInvocation(toLowerCaseInvocationThree);\n-    }\n-    \n-    //TODO use some of this test to create test for invocationsChunker\n-    \n-    @Test\n-    public void shouldMarkAllInvocationsAsVerified() throws Exception {\n-        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(2));\n-        \n-        List<Invocation> invocations = behavior.getRegisteredInvocations();\n-        assertEquals(true, invocations.get(0).isVerified());\n-        assertEquals(true, invocations.get(1).isVerified());\n-        assertEquals(false, invocations.get(2).isVerified());\n-        assertEquals(true, invocations.get(3).isVerified());\n-    }\n-    \n-    @Test\n-    public void shouldMarkAllInvocationsAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n-        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.atLeastOnce());\n-        \n-        List<Invocation> invocations = behavior.getRegisteredInvocations();\n-        assertEquals(true, invocations.get(0).isVerified());\n-        assertEquals(true, invocations.get(1).isVerified());\n-        assertEquals(false, invocations.get(2).isVerified());\n-        assertEquals(true, invocations.get(3).isVerified());\n-    }\n-    \n-    @Test\n-    public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n-        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(0));\n-        \n-        List<Invocation> invocations = behavior.getRegisteredInvocations();\n-        assertEquals(false, invocations.get(0).isVerified());\n-        assertEquals(false, invocations.get(1).isVerified());\n-        assertEquals(false, invocations.get(2).isVerified());\n-        assertEquals(false, invocations.get(3).isVerified());\n     }\n     \n     @Test\n     public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n-        behavior.checkForWrongNumberOfInvocations(toLowerCaseInvocation, VerifyingMode.inOrder(1, Arrays.asList(new Object())));\n+        VerifyingMode inOrder = VerifyingMode.inOrder(1, Arrays.asList(new Object()));\n+        assertTrue(inOrder.orderOfInvocationsMatters());\n+        \n+        behavior.checkForWrongNumberOfInvocations(toLowerCaseInvocation, inOrder);\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/RegisteredInvocationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import static java.util.Collections.*;\n+import static java.util.Arrays.*;\n+\n+import org.junit.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class RegisteredInvocationsTest {\n+\n+    private RegisteredInvocations registered;\n+    private Invocation toLowerCaseInvocation;\n+    private Invocation toUpperCaseInvocation;\n+    private Invocation toLowerCaseInvocationTwo;\n+    private Invocation toLowerCaseInvocationThree;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        Method toLowerCase = String.class.getMethod(\"toLowerCase\", new Class[] {});\n+        Method toUpperCase = String.class.getMethod(\"toUpperCase\", new Class[] {});\n+        \n+        toLowerCaseInvocation = new Invocation(\"mock\", toLowerCase , new Object[] {}, 1);\n+        toLowerCaseInvocationTwo = new Invocation(\"mock\", toLowerCase , new Object[] {}, 2);\n+        toUpperCaseInvocation = new Invocation(\"mock\", toUpperCase , new Object[] {}, 3);\n+        toLowerCaseInvocationThree = new Invocation(\"mock\", toLowerCase , new Object[] {}, 4);\n+        \n+        registered = new RegisteredInvocations(new InvocationsFinder() {\n+            public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n+                return Arrays.asList(toLowerCaseInvocation, toLowerCaseInvocationTwo, toUpperCaseInvocation, toLowerCaseInvocationThree) ;\n+            }});\n+        \n+        registered.add(toLowerCaseInvocation);\n+        registered.add(toLowerCaseInvocationTwo);\n+        registered.add(toUpperCaseInvocation);\n+        registered.add(toLowerCaseInvocationThree);\n+    }\n+\n+    @Test\n+    public void shouldAskInvocationFinderForAllInvocations() throws Exception {\n+        final List<Object> dummyMocks = asList(new Object(), new Object());\n+        final StringBuilder s = new StringBuilder();\n+        \n+        registered = new RegisteredInvocations(new InvocationsFinder() {\n+            public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n+                s.append(\"InvocationsFinder was asked\");\n+                assertSame(dummyMocks, mocks);\n+                return EMPTY_LIST;\n+            }});\n+        \n+        registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, dummyMocks));\n+        assertEquals(\"InvocationsFinder was asked\", s.toString());\n+    }    \n+    \n+    @Test\n+    public void shouldGetUnverifiedInvocationChunks() throws Exception {\n+        Object mock = new Object();\n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        assertEquals(3, chunks.size());\n+        \n+        InvocationChunk firstChunk = chunks.get(0);\n+        assertEquals(2, firstChunk.getCount());\n+        assertEquals(toLowerCaseInvocation, firstChunk.getInvocation());\n+        assertEquals(toLowerCaseInvocationTwo, firstChunk.getInvocation());\n+        \n+        InvocationChunk secondChunk = chunks.get(1);\n+        assertEquals(1, secondChunk.getCount());\n+        assertEquals(toUpperCaseInvocation, secondChunk.getInvocation());\n+        \n+        InvocationChunk thirdChunk = chunks.get(2);\n+        assertEquals(1, thirdChunk.getCount());\n+        assertEquals(toLowerCaseInvocationThree, thirdChunk.getInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldGetTwoUnverifiedInvocationChunks() throws Exception {\n+        Object mock = new Object();\n+        \n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        assertEquals(2, chunks.size());\n+        \n+        InvocationChunk firstChunk = chunks.get(0);\n+        assertEquals(1, firstChunk.getCount());\n+        assertEquals(toUpperCaseInvocation, firstChunk.getInvocation());\n+        \n+        InvocationChunk secondChunk = chunks.get(1);\n+        assertEquals(1, secondChunk.getCount());\n+        assertEquals(toLowerCaseInvocationThree, secondChunk.getInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldGetOneUnverifiedInvocationChunk() throws Exception {\n+        Object mock = new Object();\n+        \n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toUpperCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        assertEquals(1, chunks.size());\n+        \n+        InvocationChunk firstChunk = chunks.get(0);\n+        assertEquals(1, firstChunk.getCount());\n+        assertEquals(toLowerCaseInvocationThree, firstChunk.getInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldNotGetAnyInvocationChunks() throws Exception {\n+        Object mock = new Object();\n+        \n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toUpperCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n+        \n+        assertEquals(0, chunks.size());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllToLowerCaseAsVerified() throws Exception {\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST),VerifyingMode.times(2));\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllToLowerCaseAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.atLeastOnce());\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.times(0));\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(false, invocations.get(0).isVerified());\n+        assertEquals(false, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromFirstChunk() throws Exception {\n+        VerifyingMode mode = VerifyingMode.inOrder(null, Arrays.asList(new Object()));\n+        assertTrue(mode.orderOfInvocationsMatters());\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(null, EMPTY_LIST), mode);\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromSecondChunk() throws Exception {\n+        VerifyingMode mode = VerifyingMode.inOrder(null, Arrays.asList(new Object()));\n+        assertTrue(mode.orderOfInvocationsMatters());\n+        \n+        Invocation doesntMatter = null;\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter, EMPTY_LIST), mode);\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter, EMPTY_LIST), mode);\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromThirdChunk() throws Exception {\n+        VerifyingMode mode = VerifyingMode.inOrder(null, Arrays.asList(new Object()));\n+        assertTrue(mode.orderOfInvocationsMatters());\n+        \n+        Invocation doesntMatter = null;\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter, EMPTY_LIST), mode);\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter, EMPTY_LIST), mode);\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter, EMPTY_LIST), mode);\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldRemoveLastInvocation() throws Exception {\n+        registered.removeLast();\n+        assertEquals(3, registered.all().size());\n+    }\n+}", "timestamp": 1196178002, "metainfo": ""}