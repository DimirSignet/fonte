{"sha": "5e7ef66fd469848eee66dcc476f885c4474e75cb", "log": "Merging TestNG stuff", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/CaptorAnnotationProcessor.java\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.GenericMaster;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Instantiate {@link \u2021ArgumentCaptor} a field annotated by &#64;Captor.\n+ */\n+public class CaptorAnnotationProcessor implements FieldAnnotationProcessor<Captor> {\n+    public Object process(Captor annotation, Field field) {\n+        Class<?> type = field.getType();\n+        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n+            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: '\"\n+               + field.getName() + \"' has wrong type\\n\"\n+               + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n+        }\n+        Class cls = new GenericMaster().getGenericType(field);\n+        return ArgumentCaptor.forClass(cls);\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n-import org.mockito.*;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.reflection.FieldSetter;\n-import org.mockito.internal.util.reflection.GenericMaster;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n+import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n  */\n @SuppressWarnings(\"unchecked\")\n public class DefaultAnnotationEngine implements AnnotationEngine {\n+    private final Map<Class<? extends Annotation>, FieldAnnotationProcessor<?>> annotationProcessorMap = new HashMap<Class<? extends Annotation>, FieldAnnotationProcessor<?>>();\n+\n+    public DefaultAnnotationEngine() {\n+        registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());\n+        registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());\n+        registerAnnotationProcessor(Captor.class, new CaptorAnnotationProcessor());\n+    }\n \n     /* (non-Javadoc)\n     * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n     */\n     @SuppressWarnings(\"deprecation\")\n     public Object createMockFor(Annotation annotation, Field field) {\n-        if (annotation instanceof Mock) {\n-            return processAnnotationOn((Mock) annotation, field);\n-        }\n-        if (annotation instanceof MockitoAnnotations.Mock) {\n-            return processAnnotationOn((MockitoAnnotations.Mock) annotation, field);\n-        }\n-        if (annotation instanceof Captor) {\n-            return processAnnotationOn((Captor) annotation, field);\n-        }        \n-\n-        return null;\n-    }\n-    \n-    private Object processAnnotationOn(Mock annotation, Field field) {\n-        MockSettings mockSettings = Mockito.withSettings();\n-        if (annotation.extraInterfaces().length > 0) { // never null\n-            mockSettings.extraInterfaces(annotation.extraInterfaces());\n-        }\n-        if (\"\".equals(annotation.name())) {\n-            mockSettings.name(field.getName());\n-        } else {\n-            mockSettings.name(annotation.name());\n-        }\n-\n-        // see @Mock answer default value\n-        mockSettings.defaultAnswer(annotation.answer().get());\n-        return Mockito.mock(field.getType(), mockSettings);\n+        return forAnnotation(annotation).process(annotation, field);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    private Object processAnnotationOn(org.mockito.MockitoAnnotations.Mock annotation, Field field) {\n-        return Mockito.mock(field.getType(), field.getName());\n+    private <A extends Annotation> FieldAnnotationProcessor<A> forAnnotation(A annotation) {\n+        if (annotationProcessorMap.containsKey(annotation.annotationType())) {\n+            return (FieldAnnotationProcessor<A>) annotationProcessorMap.get(annotation.annotationType());\n+        }\n+        return new FieldAnnotationProcessor<A>() {\n+            public Object process(A annotation, Field field) {\n+                return null;\n+            }\n+        };\n     }\n-    \n-    private Object processAnnotationOn(Captor annotation, Field field) {\n-        Class<?> type = field.getType();\n-        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n-            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: '\"\n-                    + field.getName() + \"' has wrong type\\n\"\n-                    + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n-        }\n-        Class cls = new GenericMaster().getGenericType(field);        \n-        return ArgumentCaptor.forClass(cls);    \n-    }           \n+\n+    private <A extends Annotation> void registerAnnotationProcessor(Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {\n+        annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);\n+    }\n \n     public void process(Class<?> clazz, Object testInstance) {\n         Field[] fields = clazz.getDeclaredFields();\n             new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n         }\n     }\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/FieldAnnotationProcessor.java\n+package org.mockito.internal.configuration;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Simple annotation processor interface.\n+ */\n+public interface FieldAnnotationProcessor<A extends Annotation> {\n+    Object process(A annotation, Field field);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Instantiates a mock on a field annotated by {@link Mock}\n+ */\n+public class MockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {\n+    public Object process(Mock annotation, Field field) {\n+        MockSettings mockSettings = Mockito.withSettings();\n+        if (annotation.extraInterfaces().length > 0) { // never null\n+            mockSettings.extraInterfaces(annotation.extraInterfaces());\n+        }\n+        if (\"\".equals(annotation.name())) {\n+            mockSettings.name(field.getName());\n+        } else {\n+            mockSettings.name(annotation.name());\n+        }\n+\n+        // see @Mock answer default value\n+        mockSettings.defaultAnswer(annotation.answer().get());\n+        return Mockito.mock(field.getType(), mockSettings);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/MockitoAnnotationsMockAnnotationProcessor.java\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.MockitoAnnotations.Mock;\n+\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Instantiates a mock on a field annotated by {@link MockitoAnnotations.Mock}\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public class MockitoAnnotationsMockAnnotationProcessor implements FieldAnnotationProcessor<Mock> {\n+\n+    public Object process(MockitoAnnotations.Mock annotation, Field field) {\n+        return Mockito.mock(field.getType(), field.getName());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.internal.Incubating;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.ListUtil.Filter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Small fluent reflection tools to work with fields.\n+ *\n+ * Code is very new and might need rework.\n+ */\n+@Incubating\n+public abstract class Fields {\n+\n+    /**\n+     * Instance fields declared in thes class and superclasses of the given instance.\n+     *\n+     * @param instance Instance from which declared fields will be retrieved.\n+     * @return InstanceFields of this object instance.\n+     */\n+    public static InstanceFields allDeclaredFieldsOf(Object instance) {\n+        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n+        for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));\n+        }\n+        return new InstanceFields(instance, instanceFields);\n+    }\n+\n+    /**\n+     * Instance fields declared in the of the given instance.\n+     *\n+     * @param instance Instance from which declared fields will be retrieved.\n+     * @return InstanceFields of this object instance.\n+     */\n+    public static InstanceFields declaredFieldsOf(Object instance) {\n+        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n+        instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));\n+        return new InstanceFields(instance, instanceFields);\n+    }\n+\n+    private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {\n+        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();\n+        for (Field field : fields) {\n+            InstanceField instanceField = new InstanceField(field, instance);\n+            instanceDeclaredFields.add(instanceField);\n+        }\n+        return instanceDeclaredFields;\n+    }\n+\n+    /**\n+     * Accept fields annotated by the given annotations.\n+     *\n+     * @param annotations Annotation types to check.\n+     * @return The filter.\n+     */\n+    public static Filter<InstanceField> annotatedBy(final Class<? extends Annotation>... annotations) {\n+        return new Filter<InstanceField>() {\n+            public boolean isOut(InstanceField instanceField) {\n+                Checks.checkNotNull(annotations, \"Provide at least one annotation class\");\n+\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if(instanceField.isAnnotatedBy(annotation)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Accept fields with non null value.\n+     *\n+     * @return The filter.\n+     */\n+    private static Filter<InstanceField> nullField() {\n+        return new Filter<InstanceField>() {\n+            public boolean isOut(InstanceField instanceField) {\n+                return instanceField.isNull();\n+            }\n+        };\n+    }\n+\n+    public static class InstanceFields {\n+        private final Object instance;\n+\n+        private final List<InstanceField> instanceFields;\n+\n+        public InstanceFields(Object instance, List<InstanceField> instanceFields) {\n+            this.instance = instance;\n+            this.instanceFields = instanceFields;\n+        }\n+\n+        public InstanceFields filter(Filter<InstanceField> withFilter) {\n+            return new InstanceFields(instance, ListUtil.filter(instanceFields, withFilter));\n+        }\n+\n+        public InstanceFields notNull() {\n+            return filter(nullField());\n+        }\n+\n+        public List<InstanceField> instanceFields() {\n+            return new ArrayList<InstanceField>(instanceFields);\n+        }\n+\n+        public List<Object> assignedValues() {\n+            List<Object> values = new ArrayList<Object>(instanceFields.size());\n+            for (InstanceField instanceField : instanceFields) {\n+                values.add(instanceField.read());\n+            }\n+            return values;\n+        }\n+\n+        public List<String> names() {\n+            List<String> fieldNames = new ArrayList<String>(instanceFields.size());\n+            for (InstanceField instanceField : instanceFields) {\n+                fieldNames.add(instanceField.name());\n+            }\n+            return fieldNames;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/InstanceField.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.internal.util.Checks;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+/**\n+ * Represents an accessible instance field.\n+ *\n+ * Contains the instance reference on which the field can be read adn write.\n+ */\n+public class InstanceField {\n+    private final Field field;\n+    private final Object instance;\n+    private FieldReader fieldReader;\n+\n+    /**\n+     * Create a new InstanceField.\n+     *\n+     * @param field The field that should be accessed, note that no checks are performed to ensure\n+     *              the field belong to this instance class.\n+     * @param instance The instance from which the field shall be accessed.\n+     */\n+    public InstanceField(Field field, Object instance) {\n+        this.field = Checks.checkNotNull(field, \"field\");\n+        this.instance = Checks.checkNotNull(instance, \"instance\");\n+    }\n+\n+    /**\n+     * Safely read the field.\n+     *\n+     * @return the field value.\n+     * @see FieldReader\n+     */\n+    public Object read() {\n+        return reader().read();\n+    }\n+\n+    /**\n+     * Set the given value to the field of this instance.\n+     *\n+     * @param value The value that should be written to the field.\n+     * @see FieldSetter\n+     */\n+    public void set(Object value) {\n+        new FieldSetter(instance, field).set(value);\n+    }\n+\n+    /**\n+     * Check that the field is not null.\n+     *\n+     * @return <code>true</code> if <code>null</code>, else <code>false</code>.\n+     */\n+    public boolean isNull() {\n+        return reader().isNull();\n+    }\n+\n+    /**\n+     * Check if the field is annotated by the given annotation.\n+     *\n+     * @param annotationClass The annotation type to check.\n+     * @return <code>true</code> if the field is annotated by this annotation, else <code>false</code>.\n+     */\n+    public boolean isAnnotatedBy(Class<? extends Annotation> annotationClass) {\n+        return field.isAnnotationPresent(annotationClass);\n+    }\n+\n+    /**\n+     * Returns the annotation instance for the given annotation type.\n+     *\n+     * @param annotationClass Tha annotation type to retrieve.\n+     * @param <A> Type of the annotation.\n+     * @return The annotation instance.\n+     */\n+    public <A extends Annotation> A annotation(Class<A> annotationClass) {\n+        return field.getAnnotation(annotationClass);\n+    }\n+\n+    /**\n+     * Returns the JDK {@link Field} instance.\n+     *\n+     * @return The actual {@link Field} instance.\n+     */\n+    public Field jdkField() {\n+        return field;\n+    }\n+\n+    private FieldReader reader() {\n+        if (fieldReader == null) {\n+            fieldReader = new FieldReader(instance, field);\n+        }\n+        return fieldReader;\n+    }\n+\n+    /**\n+     * Returns the name of the field.\n+     *\n+     * @return Name of the field.\n+     */\n+    public String name() {\n+        return field.getName();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        InstanceField that = (InstanceField) o;\n+\n+        if (!field.equals(that.field)) return false;\n+        if (!instance.equals(that.instance)) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = field.hashCode();\n+        result = 31 * result + instance.hashCode();\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n+package org.mockito.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.Fields;\n+import org.testng.IInvokedMethod;\n+import org.testng.ITestResult;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.mockito.internal.util.reflection.Fields.annotatedBy;\n+\n+public class MockitoAfterTestNGMethod {\n+\n+    public void applyFor(IInvokedMethod method, ITestResult testResult) {\n+        Mockito.validateMockitoUsage();\n+\n+        if (method.isTestMethod()) {\n+            resetMocks(testResult.getInstance());\n+        }\n+    }\n+\n+\n+    private void resetMocks(Object instance) {\n+        Mockito.reset(instanceMocksOf(instance).toArray());\n+    }\n+\n+    private Collection<Object> instanceMocksOf(Object instance) {\n+        return Fields.allDeclaredFieldsOf(instance)\n+                                            .filter(annotatedBy(Mock.class,\n+                                                                Spy.class,\n+                                                                MockitoAnnotations.Mock.class))\n+                                            .notNull()\n+                                            .assignedValues();\n+    }\n+\n+    private Set<Object> instanceMocksIn(Object instance, Class<?> clazz) {\n+        Set<Object> instanceMocks = new HashSet<Object>();\n+        Field[] declaredFields = clazz.getDeclaredFields();\n+        for (Field declaredField : declaredFields) {\n+            if (declaredField.isAnnotationPresent(Mock.class) || declaredField.isAnnotationPresent(Spy.class)) {\n+                declaredField.setAccessible(true);\n+                try {\n+                    Object fieldValue = declaredField.get(instance);\n+                    if (fieldValue != null) {\n+                        instanceMocks.add(fieldValue);\n+                    }\n+                } catch (IllegalAccessException e) {\n+                    throw new MockitoException(\"Could not access field \" + declaredField.getName());\n+                }\n+            }\n+        }\n+        return instanceMocks;\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoBeforeTestNGMethod.java\n+package org.mockito.testng;\n+\n+import org.mockito.Captor;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.configuration.CaptorAnnotationProcessor;\n+import org.mockito.internal.util.reflection.Fields;\n+import org.mockito.internal.util.reflection.InstanceField;\n+import org.testng.IInvokedMethod;\n+import org.testng.ITestResult;\n+\n+import java.util.List;\n+import java.util.WeakHashMap;\n+\n+import static org.mockito.internal.util.reflection.Fields.annotatedBy;\n+\n+public class MockitoBeforeTestNGMethod {\n+\n+    private WeakHashMap<Object, Boolean> initializedInstances = new WeakHashMap<Object, Boolean>();\n+\n+    /**\n+     * Initialize mocks.\n+     *\n+     * @param method Invoked method.\n+     * @param testResult TestNG Test Result\n+     */\n+    public void applyFor(IInvokedMethod method, ITestResult testResult) {\n+        initMocks(testResult);\n+        reinitCaptors(method, testResult);\n+    }\n+\n+    private void reinitCaptors(IInvokedMethod method, ITestResult testResult) {\n+        if (method.isConfigurationMethod()) {\n+            return;\n+        }\n+        initializeCaptors(testResult.getInstance());\n+    }\n+\n+    private void initMocks(ITestResult testResult) {\n+        if (alreadyInitialized(testResult.getInstance())) {\n+            return;\n+        }\n+        MockitoAnnotations.initMocks(testResult.getInstance());\n+        markAsInitialized(testResult.getInstance());\n+    }\n+\n+    private void initializeCaptors(Object instance) {\n+        List<InstanceField> instanceFields = Fields.allDeclaredFieldsOf(instance).filter(annotatedBy(Captor.class)).instanceFields();\n+        for (InstanceField instanceField : instanceFields) {\n+            new CaptorAnnotationProcessor().process(instanceField.annotation(Captor.class), instanceField.jdkField());\n+        }\n+    }\n+\n+    private void markAsInitialized(Object instance) {\n+        initializedInstances.put(instance, true);\n+    }\n+\n+    private boolean alreadyInitialized(Object instance) {\n+        return initializedInstances.containsKey(instance);\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoTestNGListener.java\n+package org.mockito.testng;\n+\n+import org.testng.IInvokedMethod;\n+import org.testng.IInvokedMethodListener;\n+import org.testng.ITestNGListener;\n+import org.testng.ITestResult;\n+import org.testng.annotations.Listeners;\n+\n+/**\n+ * Mockito TestNG Listener, this listener adds the following behavior to your test :\n+ * <ul>\n+ *     <li>\n+ *         Initializes mocks annotated with {@link org.mockito.Mock}, so that <strong>explicit usage of\n+ *         {@link org.mockito.MockitoAnnotations#initMocks(Object)} is not necessary</strong>.\n+ *         <strong>Note :</strong> With TestNG, mocks are initialized before any TestNG method, either a <em>configuration\n+ *         method</em> (&#064;BeforeMethod, &#064;BeforeClass, etc) or a <em>test</em> method, i.e. mocks are initialized\n+ *         once only once for each test instance.\n+ *     </li>\n+ *     <li>\n+ *         As mocks are initialized only once, they will be reset after each <em>test method</em>.\n+ *         See javadoc {@link org.mockito.Mockito#reset(Object[])}\n+ *     </li>\n+ *     <li>\n+ *         Validates framework usage after each test method. See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ *     </li>\n+ * </ul>\n+ *\n+ * <p>\n+ * The listener is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.\n+ * Explicitly validating framework usage is also optional because it is triggered automatically by Mockito every time you use the framework.\n+ * See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ *\n+ * <p>\n+ * Read more about &#064;Mock annotation in javadoc for {@link org.mockito.MockitoAnnotations}\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ * <b>&#064;Listeners(MockitoTestNGListener.class)</b>\n+ * public class ExampleTest {\n+ *\n+ *     &#064;Mock\n+ *     private List list;\n+ *\n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * </code></pre>\n+ */\n+public class MockitoTestNGListener implements IInvokedMethodListener {\n+\n+    private MockitoBeforeTestNGMethod beforeTest = new MockitoBeforeTestNGMethod();\n+    private MockitoAfterTestNGMethod afterTest = new MockitoAfterTestNGMethod();\n+\n+\n+    public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {\n+        if (hasMockitoTestNGListenerInTestHierarchy(testResult.getTestClass().getRealClass())) {\n+            beforeTest.applyFor(method, testResult);\n+        }\n+    }\n+\n+    public void afterInvocation(IInvokedMethod method, ITestResult testResult) {\n+        if (hasMockitoTestNGListenerInTestHierarchy(testResult.getTestClass().getRealClass())) {\n+            afterTest.applyFor(method, testResult);\n+        }\n+    }\n+\n+    protected boolean hasMockitoTestNGListenerInTestHierarchy(Class<?> testClass) {\n+        for (Class<?> clazz = testClass; clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            if (hasMockitoTestNGListener(clazz)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean hasMockitoTestNGListener(Class<?> clazz) {\n+        Listeners listeners = clazz.getAnnotation(Listeners.class);\n+        if (listeners == null) {\n+            return false;\n+        }\n+\n+        for (Class<? extends ITestNGListener> listenerClass : listeners.value()) {\n+            if (listenerClass() == listenerClass) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected Class<MockitoTestNGListener> listenerClass() {\n+        return MockitoTestNGListener.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/AnnotatedFieldsShouldBeInitializedByMockitoTestNGListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class AnnotatedFieldsShouldBeInitializedByMockitoTestNGListenerTest {\n+\n+    @Mock List list;\n+    @Spy HashMap map;\n+    @InjectMocks SomeType someType;\n+    @Captor ArgumentCaptor<List> captor;\n+\n+    @Test\n+    public void ensure_annotated_fields_are_instantiated() throws Exception {\n+        assertThat(list).isNotNull();\n+        assertThat(map).isNotNull();\n+        assertThat(captor).isNotNull();\n+        assertThat(someType).isNotNull();\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/CaptorAnnotatedFieldShouldBeClearedTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@Listeners(MockitoTestNGListener.class)\n+@Test(enabled = false, description = \"not yet ready\")\n+public class CaptorAnnotatedFieldShouldBeClearedTest {\n+\n+    @Captor ArgumentCaptor<String> captor;\n+    @Mock List<String> list;\n+\n+    @Test(enabled = false)\n+    public void first_test_method_that_uses_captor() throws Exception {\n+        list.add(\"a\");\n+        list.add(\"b\");\n+\n+        verify(list, times(2)).add(captor.capture());\n+        assertThat(captor.getAllValues()).containsOnly(\"a\", \"b\");\n+    }\n+\n+    @Test(enabled = false)\n+    public void second_test_method_that_uses_captor() throws Exception {\n+        list.add(\"t\");\n+        list.add(\"u\");\n+\n+        verify(list, times(2)).add(captor.capture());\n+        assertThat(captor.getAllValues()).containsOnly(\"t\", \"u\");\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ConfigurationMethodTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class ConfigurationMethodTest {\n+    @Mock private Map map;\n+\n+    @BeforeMethod\n+    public void some_behavior() {\n+        when(map.get(\"the answer to ...\")).thenReturn(42);\n+    }\n+\n+\n+    @Test\n+    public void mocks_should_stay_configured_with_behavior() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/DontResetMocksIfNoListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+public class DontResetMocksIfNoListenerTest {\n+\n+    @Mock private Map map;\n+\n+    @BeforeMethod\n+    public void init_mocks() {\n+        MockitoAnnotations.initMocks(this);\n+        when(map.get(\"the answer to ...\")).thenReturn(42);\n+    }\n+\n+    @Test\n+    public void mock_behavior_not_resetted_1() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+\n+    @Test\n+    public void mock_behavior_not_resetted_2() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/EnsureMocksAreInitializedBeforeBeforeClassMethodTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Observer;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class EnsureMocksAreInitializedBeforeBeforeClassMethodTest {\n+    \n+    @Mock Observer observer;\n+\n+    @BeforeClass\n+    private void make_sure_mock_is_initialized() {\n+        assertThat(observer).isNotNull();\n+    }\n+\n+    @Test\n+    public void dummy_test_see_BeforeClass_code() throws Exception {\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/InitializeChildTestWhenParentHasListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class InitializeChildTestWhenParentHasListenerTest extends ParentTest {\n+\n+    @Mock Map childMockField;\n+\n+    @Test\n+    public void verify_mocks_are_initialized() throws Exception {\n+        assertThat(childMockField).isNotNull();\n+        assertThat(parentMockField).isNotNull();\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/MockFieldsShouldBeResetBetweenTestMethodsTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class MockFieldsShouldBeResetBetweenTestMethodsTest {\n+    \n+    @Mock List<String> list;\n+    @Spy HashMap hashMap;\n+    @InjectMocks SomeType someType;\n+\n+    @Mock Observable will_be_nulled;\n+\n+    @Test\n+    public void behaviour_A_without_infection_from_behaviour_B() throws Exception {\n+        // verify mock is clean\n+        assertThat(list.get(0)).isNull();\n+        verify(list, never()).add(anyString());\n+\n+        // local behaviour A\n+        given(list.get(0)).willReturn(\"A\");\n+        assertThat(list.get(0)).isEqualTo(\"A\");\n+\n+        list.add(\"something else after A\");\n+    }\n+\n+    @Test\n+    public void behaviour_B_without_infection_from_behaviour_A() throws Exception {\n+        // verify mock is clean\n+        assertThat(list.get(0)).isNull();\n+        verify(list, never()).add(anyString());\n+\n+        // local behaviour A\n+        given(list.get(0)).willReturn(\"B\");\n+        assertThat(list.get(0)).isEqualTo(\"B\");\n+\n+        list.add(\"something else after B\");\n+    }\n+\n+    @Test\n+    public void dont_fail_when_reseting_null_field() throws Exception {\n+        will_be_nulled = null;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ParentTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+\n+import java.util.Map;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public abstract class ParentTest {\n+\n+    @Mock Map parentMockField;\n+\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ResetMocksInParentTestClassTooTest.java\n+package org.mockitousage.testng;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+public class ResetMocksInParentTestClassTooTest extends ParentTest {\n+\n+    @Test\n+    public void interact_with_parent_mock() throws Exception {\n+        parentMockField.get(\"a\");\n+    }\n+\n+    @Test\n+    public void verify__zero_interaction_with_parent_mock() throws Exception {\n+        verifyZeroInteractions(parentMockField);\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/SomeType.java\n+package org.mockitousage.testng;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SomeType {\n+    List list;\n+    Map map;\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/TestWithoutListenerShouldNotInitializeAnnotatedFieldsTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class TestWithoutListenerShouldNotInitializeAnnotatedFieldsTest {\n+\n+    @Mock List list;\n+    @Spy Map map;\n+    @InjectMocks SomeType someType;\n+    @Captor ArgumentCaptor<List> captor;\n+\n+    @Test\n+    public void test_not_annotated_by_MockitoTestNGListener_should_not_touch_annotated_fields() throws Exception {\n+        assertThat(list).isNull();\n+        assertThat(map).isNull();\n+        assertThat(captor).isNull();\n+        assertThat(someType).isNull();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseIncorrectAnnotationUsage.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseIncorrectAnnotationUsage {\n+    @Spy Map spy_cant_initialize_interface_fields;\n+    @Test public void dummy_test_method() throws Exception { }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseIncorrectStubbingSyntax.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.PrintStream;\n+\n+import static org.mockito.Matchers.anySet;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseIncorrectStubbingSyntax {\n+\n+    @Test(expectedExceptions = InvalidUseOfMatchersException.class)\n+    public void incorrect_stubbing_syntax_in_test() throws Exception {\n+        mock(PrintStream.class);\n+        anyString();\n+        anySet();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseWrongStubbingSyntaxInConfigurationMethod.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Matchers.anyString;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseWrongStubbingSyntaxInConfigurationMethod {\n+\n+    @Mock List list;\n+\n+    // should fail\n+    @BeforeMethod public void some_wrong_stubs() {\n+        anyString();\n+    }\n+\n+\n+    @Test\n+    public void here_to_execute_the_config_method() throws Exception {\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/TestNGShouldFailWhenMockitoListenerFailsTest.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockitousage.testng.utils.FailureRecordingListener;\n+import org.testng.TestNG;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.testng.Assert.assertTrue;\n+\n+@Test(\n+        singleThreaded = true,\n+        description = \"Test that failing tests report a Mockito exception\"\n+)\n+public class TestNGShouldFailWhenMockitoListenerFailsTest {\n+\n+    private final FailureRecordingListener failureRecorder = new FailureRecordingListener();\n+\n+    public void report_failure_on_incorrect_annotation_usage() throws Throwable {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectAnnotationUsage.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(MockitoException.class);\n+    }\n+\n+    @Test\n+    public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_test_methods() throws Exception {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectStubbingSyntax.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(InvalidUseOfMatchersException.class);\n+    }\n+\n+\n+    @Test\n+    public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_configuration_methods() throws Exception {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseWrongStubbingSyntaxInConfigurationMethod.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(InvalidUseOfMatchersException.class);\n+    }\n+\n+    @AfterMethod\n+    public void clear_failure_recorder() throws Exception {\n+        failureRecorder.clear();\n+    }\n+\n+\n+    private TestNG new_TestNG_with_failure_recorder_for(Class<?>... testNGClasses) {\n+        TestNG testNG = new TestNG();\n+        testNG.setVerbose(0);\n+        testNG.setUseDefaultListeners(false);\n+        testNG.addListener(failureRecorder);\n+\n+        testNG.setTestClasses(testNGClasses);\n+        return testNG;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/utils/FailureRecordingListener.java\n+package org.mockitousage.testng.utils;\n+\n+import org.testng.IConfigurationListener;\n+import org.testng.ITestContext;\n+import org.testng.ITestListener;\n+import org.testng.ITestResult;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * <strong>Not thread-safe</strong> listener that record only failures, either on the test or on a configuration method.\n+ */\n+public class FailureRecordingListener implements ITestListener, IConfigurationListener {\n+\n+    public List<ITestResult> failedTestResults = new ArrayList<ITestResult>();\n+\n+    public void onTestFailure(ITestResult result) {\n+        failedTestResults.add(result);\n+    }\n+\n+    public void onConfigurationFailure(ITestResult result) {\n+        failedTestResults.add(result);\n+    }\n+\n+    public Throwable lastThrowable() {\n+        ListIterator<ITestResult> iterator = failedTestResults.listIterator(failedTestResults.size());\n+        return iterator.hasPrevious() ? iterator.previous().getThrowable() : null;\n+    }\n+\n+    public void clear() {\n+        failedTestResults.clear();\n+    }\n+\n+    // don't care bellow\n+\n+\n+    public void onConfigurationSuccess(ITestResult itr) { }\n+    public void onConfigurationSkip(ITestResult itr) { }\n+    public void onTestStart(ITestResult result) { }\n+    public void onTestSuccess(ITestResult result) { }\n+    public void onTestSkipped(ITestResult result) { }\n+    public void onTestFailedButWithinSuccessPercentage(ITestResult result) { }\n+    public void onStart(ITestContext context) { }\n+    public void onFinish(ITestContext context) { }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/FieldsTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+\n+import java.lang.reflect.Field;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class FieldsTest {\n+\n+    @Test\n+    public void fields_should_return_all_declared_fields_in_hierarchy() throws Exception {\n+        assertThat(Fields.allDeclaredFieldsOf(new HierarchyOfClasses()).names())\n+                .containsOnly(\"a\", \"b\", \"static_a\", \"static_b\");\n+    }\n+\n+    @Test\n+    public void fields_should_return_declared_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new HierarchyOfClasses()).names())\n+                .containsOnly(\"b\", \"static_b\");\n+    }\n+\n+    @Test\n+    public void can_filter_not_null_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new NullOrNotNullFields()).notNull().names())\n+                .containsOnly(\"c\");\n+    }\n+\n+    @Test\n+    public void can_get_values_of_instance_fields() throws Exception {\n+        assertThat(Fields.declaredFieldsOf(new ValuedFields()).assignedValues())\n+                .containsOnly(\"a\", \"b\");\n+    }\n+\n+\n+    @Test\n+    public void can_get_list_of_InstanceField() throws Exception {\n+        ValuedFields instance = new ValuedFields();\n+\n+        assertThat(Fields.declaredFieldsOf(instance).instanceFields())\n+                .containsOnly(new InstanceField(field(\"a\", instance), instance),\n+                              new InstanceField(field(\"b\", instance), instance)\n+                );\n+    }\n+\n+    private Field field(String name, Object instance) throws NoSuchFieldException {\n+        return instance.getClass().getDeclaredField(name);\n+    }\n+\n+\n+    interface AnInterface {\n+        int someStaticInInterface = 0;\n+\n+    }\n+    public static class ParentClass implements AnInterface {\n+        static int static_a;\n+        int a;\n+\n+    }\n+    public static class HierarchyOfClasses extends ParentClass {\n+        static int static_b;\n+        int b = 1;\n+\n+    }\n+    public static class NullOrNotNullFields {\n+        static Object static_b;\n+        Object b;\n+        Object c = new Object();\n+    }\n+\n+    public static class ValuedFields {\n+        String a = \"a\";\n+        String b = \"b\";\n+    }\n+}\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n import java.io.Serializable;\n \n /**\n- * Allows mock creation with additional mock settings. \n- * <p>\n- * Don't use it too often. \n- * Consider writing simple tests that use simple mocks. \n+ * Allows mock creation with additional mock settings.\n+ * <p/>\n+ * Don't use it too often.\n+ * Consider writing simple tests that use simple mocks.\n  * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n  * If you cannot write a test in a simple way - refactor the code under test.\n- * <p>\n+ * <p/>\n  * Examples of mock settings:\n  * <pre class=\"code\"><code class=\"java\">\n  *   //Creates mock with different default answer & name\n  *   Foo mock = mock(Foo.class, withSettings()\n- *       .defaultAnswer(RETURNS_SMART_NULLS)\n- *       .name(\"cool mockie\"));\n- *       \n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                );\n+ *\n  *   //Creates mock with different default answer, descriptive name and extra interfaces\n  *   Foo mock = mock(Foo.class, withSettings()\n- *       .defaultAnswer(RETURNS_SMART_NULLS)\n- *       .name(\"cool mockie\")\n- *       .extraInterfaces(Bar.class));    \n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                .extraInterfaces(Bar.class));\n  * </code></pre>\n- * {@link MockSettings} has been introduced for two reasons. \n+ * {@link MockSettings} has been introduced for two reasons.\n  * Firstly, to make it easy to add another mock setting when the demand comes.\n  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n  */\n public interface MockSettings extends Serializable, MockSettingsInfo {\n-    \n+\n     /**\n      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n-     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>  \n-     * <p>\n-     * This mysterious feature should be used very occasionally. \n+     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n+     * <p>\n+     * This mysterious feature should be used very occasionally.\n      * The object under test should know exactly its collaborators & dependencies.\n      * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n-     * <p>   \n+     * <p>\n      * Examples:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n-     *   \n+     *\n      *   //now, the mock implements extra interfaces, so following casting is possible:\n      *   Bar bar = (Bar) foo;\n      *   Baz baz = (Baz) foo;\n      * </code></pre>\n-     * \n+     *\n      * @param interfaces extra interfaces the should implement.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings extraInterfaces(Class<?>... interfaces);\n \n     /**\n-     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n+     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n      * <p>\n      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n      * Examples:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n-     *   \n+     *\n      *   //Below does exactly the same:\n      *   Foo foo = mock(Foo.class, \"foo\");\n      * </code></pre>\n \n     /**\n      * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n-     * Sets the real implementation to be called when the method is called on a mock object.\n+     *\n+     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n      * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * <p>\n-     * However, there are rare cases when partial mocks come handy: \n+     * However, there are rare cases when partial mocks come handy:\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Enough warnings about partial mocks, see an example how spiedInstance() works:\n      * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, spiedInstance(fooInstance));\n-     *   \n+     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n+     *\n      *   //Below does exactly the same:\n      *   Foo foo = spy(fooInstance);\n      * </code></pre>\n-     * \n+     *\n+     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n+     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *\n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </code>\n+     *\n      * @param instance to spy on\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings spiedInstance(Object instance);\n \n     /**\n-     * Specifies default answers to interactions. \n+     * Specifies default answers to interactions.\n      * It's quite advanced feature and typically you don't need it to write decent tests.\n      * However it can be helpful when working with legacy systems.\n      * <p>\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n      *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n-     *   \n+     *\n      *   //Below does exactly the same:\n      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n      * </code></pre>\n-     * \n+     *\n      * @param defaultAnswer default answer to be used by mock when not stubbed\n      * @return settings instance so that you can fluently specify other settings\n      */\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings serializable();\n-    \n+\n     /**\n      * Enables real-time logging of method invocations on this mock. Can be used\n      * during test debugging in order to find wrong interactions with this mock.\n      * <pre class=\"code\"><code class=\"java\">\n      * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n      * </code></pre>\n-     * \n+     *\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings verboseLogging();\n-    \n+\n     /**\n      * Registers a listener for method invocations on this mock. The listener is\n      * notified every time a method on this mock is called.\n      * <p>\n      * Multiple listeners may be added, but the same object is only added once.\n      * The order, in which the listeners are added, is not guaranteed to be the\n-     * order in which the listeners are notified. \n-     * \n+     * order in which the listeners are notified.\n+     *\n      * Example:\n      * <pre class=\"code\"><code class=\"java\">\n      *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n      * </code></pre>\n-     * \n+     *\n      * See the {@link InvocationListener listener interface} for more details.\n-     * \n+     *\n      * @param listeners The invocation listeners to add. May not be null.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings invocationListeners(InvocationListener... listeners);\n+\n+    /**\n+     * Specifies the delegated instance on which a mock should forward calls.\n+     *\n+     * Makes sense only for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API.\n+     * Possible use cases :\n+     * <ul>\n+     *     <li>Final classes but with an interface</li>\n+     *     <li>Already custom proxied object</li>\n+     *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n+     *     <li>...</li>\n+     * </ul>\n+     * Sets the real implementation to be called when the method is called on a mock object.\n+     * <p>\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * In most cases, this is not the way you want to design your application.\n+     * <p>\n+     * However, there are rare cases when partial mocks come handy:\n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+     * <p>\n+     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   final class DontMessTheCodeOfThisList implements list { ... }\n+     *\n+     *   DontMessTheCodeOfThisList awesomeList = new DontMessTheCodeOfThisList();\n+     *\n+     *   List listWithDelegate = mock(List.class, withSettings().forwardTo(awesomeList));\n+     * </code></pre>\n+     *\n+     * <p>\n+     * This features suffer from the same drawback as the spy. The mock will always call the delegate.\n+     * This mean that you have to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List listWithDelegate = mock(List.class, withSettings().forwardTo(awesomeList));\n+     *\n+     *   //Impossible: real method is called so listWithDelegate.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(listWithDelegate.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(listWithDelegate).get(0);\n+     * </code>\n+     *\n+     * @param delegate The delegate to forward calls to.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings forwardTo(Object delegate) ;\n }\n--- /dev/null\n+++ b/src/org/mockito/MockingDetails.java\n+package org.mockito;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+/**\n+ * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n+ * effectively a &ldquo;public&rdquo; version of {@link MockUtil}.\n+ */\n+public class MockingDetails {\n+    \n+    private Object toInspect;\n+    private MockUtil delegate;\n+\n+    MockingDetails( Object toInspect, MockUtil delegate ){\n+        this.toInspect = toInspect;\n+        this.delegate = delegate;\n+    }\n+\n+    /**\n+     * Create a MockingDetails to inspect a particular Object.\n+     * @param toInspect the object to inspect\n+     * @return\n+     */\n+    public static MockingDetails of( Object toInspect ){\n+        return new MockingDetails( toInspect, new MockUtil());\n+    }\n+\n+    /**\n+     * Find out whether the object is a mock.\n+     * @return whether the object is a mock.\n+     */\n+    public boolean isMock(){\n+        return delegate.isMock( toInspect );\n+    }\n+\n+    /**\n+     * Find out whether the object is a spy.\n+     * @return whether the object is a spy.\n+     */\n+    public boolean isSpy(){\n+        return delegate.isSpy( toInspect );\n+    }\n+\n+\n+}\n+\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *      <a href=\"#9\">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation </a><br/>\n  *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n  *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n- *      <a href=\"#12\">12. <code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doReturn()</code> family of methods mostly for stubbing voids </a><br/>\n+ *      <a href=\"#12\">12. <code>doReturn()</code>|<code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a><br/>\n  *      <a href=\"#13\">13. Spying on real objects </a><br/>\n  *      <a href=\"#14\">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>\n  *      <a href=\"#15\">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>\n  *      <a href=\"#20\">20. Serializable mocks (Since 1.8.1) </a><br/>\n  *      <a href=\"#21\">21. New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </a><br/>\n  *      <a href=\"#22\">22. (New) Verification with timeout (Since 1.8.5) </a><br/>\n- *      <a href=\"#23\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9)</a><br/>\n- *      <a href=\"#24\">24. (**New**) One-liner stubs (Since 1.9)</a><br/>\n- *      <a href=\"#25\">25. (**New**) Verification ignoring stubs (Since 1.9)</a><br/>\n+ *      <a href=\"#23\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9.0)</a><br/>\n+ *      <a href=\"#24\">24. (**New**) One-liner stubs (Since 1.9.0)</a><br/>\n+ *      <a href=\"#25\">25. (**New**) Verification ignoring stubs (Since 1.9.0)</a><br/>\n+ *      <a href=\"#26\">26. (**New**) Mocking details (Since 1.9.1)</a><br/>\n  * </b>\n  * \n  * <p>\n  * like <code>add()</code>, <code>get()</code>, <code>clear()</code> will be used). <br>\n  * You probably wouldn't mock List class 'in real'.\n  * \n- * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n+ * <h3 id=\"1\"><a name=\"verify\">1. Let's verify some behaviour!</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //Let's import Mockito statically so that the code looks clearer\n  * Once created, mock will remember all interactions. Then you can selectively\n  * verify whatever interaction you are interested in.\n  * \n- * <h3 id=\"2\">2. How about some stubbing?</h3>\n+ * <h3 id=\"2\"><a name=\"stubbing\">2. How about some stubbing?</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //You can mock concrete classes, not only interfaces\n  * \n  * </ul>\n  * \n- * <h3 id=\"3\">3. Argument matchers</h3>\n+ * <h3 id=\"3\"><a name=\"matchers\">3. Argument matchers</a></h3>\n  * \n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n  * Sometimes, when extra flexibility is required then you might use argument matchers:  \n  * This implementation is due static type safety imposed by java compiler.\n  * The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.\n  * \n- * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n+ * <h3 id=\"4\"><a name=\"verifyexactly\">4. Verifying exact number of invocations / at least x / never</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //using mock \n  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n  * omitted.\n  * \n- * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n+ * <h3 id=\"5\"><a name=\"stubexceptions\">5. Stubbing void methods with exceptions</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n  * Currently <code>stubVoid()</code> is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n  * \n- * <h3 id=\"6\">6. Verification in order</h3>\n+ * <h3 id=\"6\"><a name=\"verifyinorder\">6. Verification in order</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * // A. Single mock whose methods must be invoked in a particular order\n  * Also, you can create InOrder object passing only mocks that are relevant for\n  * in-order verification.\n  * \n- * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n+ * <h3 id=\"7\"><a name=\"verifynever\">7. Making sure interaction(s) never happened on mock</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //using mocks - only mockOne is interacted\n  * \n  * </code></pre>\n  * \n- * <h3 id=\"8\">8. Finding redundant invocations</h3>\n+ * <h3 id=\"8\"><a name=\"findredundant\">8. Finding redundant invocations</a></h3>\n  * \n  * <pre class=\"code\"><code class=\"java\">\n  * //using mocks\n  * communicates the intent well.\n  * <p>\n  * \n- * <h3 id=\"9\">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation</h3>\n+ * <h3 id=\"9\"><a name=\"mockannotation\">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation</a></h3>\n  * \n  * <ul>\n  * <li>Minimizes repetitive mock creation code.</li>\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n  * \n- * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n+ * <h3 id=\"10\"><a name=\"stubrepeated\"> 10. Stubbing consecutive calls (iterator-style stubbing)</a></h3>\n  * \n  * Sometimes we need to stub with different return value/exception for the same\n  * method call. Typical use case could be mocking iterators. \n  *   .thenReturn(\"one\", \"two\", \"three\");\n  * </code></pre>\n  * \n- * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n+ * <h3 id=\"11\"><a name=\"stubanswer\"> 11. Stubbing with callbacks</a></h3>\n  * \n  * Allows stubbing with generic {@link Answer} interface.\n *  <p>\n  * System.out.println(mock.someMethod(\"foo\"));\n  * </code></pre>\n  * \n- * <h3 id=\"12\"> 12. <code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doReturn()</code> family of methods for stubbing voids (mostly)</h3>\n+ * <h3 id=\"12\"><a name=\"stubdo\"> 12. <code>doReturn()</code>|<code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a></h3>\n  * \n  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n  * <p>\n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n  * </code></pre>\n- * \n- * Read more about other methods:\n+ *\n+ * <p>\n+ * You can use <code>doThrow()</code>, <code>doAnswer()</code>,  <code>doNothing()</code>,  <code>doReturn()</code> and <code>doCallRealMethod()</code> in place\n+ * of the corresponding call with <code>when()</code>, for any method.  It is necessary when you\n+ * <ul>\n+ *     <li>stub void methods</li>\n+ *     <li>stub methods on spy objects (see below)</li>\n+ *     <li>stub the same method more than once, to change the behaviour of a mock in the middle of a test.</li>\n+ * </ul>\n+ * but you may prefer to use these methods in place of the alternative with <code>when()</code>, for all of your stubbing calls.\n+ * <p>\n+ * Read more about these methods:\n+ * <p>\n+ * {@link Mockito#doReturn(Object)}\n  * <p>\n  * {@link Mockito#doThrow(Throwable)}\n  * <p>\n+ * {@link Mockito#doThrow(Class)}\n+ * <p>\n  * {@link Mockito#doAnswer(Answer)}\n  * <p>\n  * {@link Mockito#doNothing()}\n  * <p>\n- * {@link Mockito#doReturn(Object)}\n- * \n- * <h3 id=\"13\"> 13. Spying on real objects</h3>\n+ * {@link Mockito#doCallRealMethod()}\n+ *\n+ * <h3 id=\"13\"><a name=\"spy\"> 13. Spying on real objects</a></h3>\n  * \n  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n  * <p>\n  * </li>\n  * </ol>\n  *\n- * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n+ * <h3 id=\"14\"><a name=\"defaultreturn\">14. Changing default return values of unstubbed invocations (Since 1.7) </a></h3>\n  * \n  * You can create a mock with specified strategy for its return values.\n  * It's quite advanced feature and typically you don't need it to write decent tests.\n  * <p>\n  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n  * \n- * <h3 id=\"15\">15. Capturing arguments for further assertions (Since 1.8.0) </h3>\n+ * <h3 id=\"15\"><a name=\"captors\">15. Capturing arguments for further assertions (Since 1.8.0) </a></h3>\n  * \n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * </ul>\n  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n  * \n- * <h3 id=\"16\">16. Real partial mocks (Since 1.8.0) </h3>\n+ * <h3 id=\"16\"><a name=\"partialmocks\">16. Real partial mocks (Since 1.8.0) </a></h3>\n  *  \n  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n  *  \n- * <h3 id=\"17\">17. Resetting mocks (Since 1.8.0) </h3>\n+ * <h3 id=\"17\"><a name=\"resetting\">17. Resetting mocks (Since 1.8.0) </a></h3>\n  *  \n  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n  * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n  *   //at this point the mock forgot any interactions & stubbing\n  * </code></pre>\n  *  \n- * <h3 id=\"18\">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>\n+ * <h3 id=\"18\"><a name=\"frameworkvalidate\">18. Troubleshooting & validating framework usage (Since 1.8.0) </a></h3>\n  * \n  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n  * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n  * \n- * <h3 id=\"19\">19. Aliases for behavior driven development (Since 1.8.0) </h3>\n+ * <h3 id=\"19\"><a name=\"bddmockito\">19. Aliases for behavior driven development (Since 1.8.0) </a></h3>\n  * \n  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n  * This is exactly how we write our tests and we warmly encourage you to do so!\n  * }  \n  * </code></pre>\n  * \n- * <h3 id=\"20\">20. (**New**) Serializable mocks (Since 1.8.1) </h3>\n+ * <h3 id=\"20\"><a name=\"serializablemocks\">20. (**New**) Serializable mocks (Since 1.8.1) </a></h3>\n  * \n  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n  * <p>\n  *                 .serializable());\n  * </code></pre>\n  * \n- * <h3 id=\"21\">21. (**New**) New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </h3>\n+ * <h3 id=\"21\"><a name=\"annotations183\">21. (**New**) New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3)</a></h3>\n  * <p>\n  * Release 1.8.3 brings new annotations that may be helpful on occasion:\n  * \n  * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.\n  * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner}.\n  * <p>\n- * <h3 id=\"22\">22. (**New**) Verification with timeout (Since 1.8.5)  </h3>\n- * <p>\n- * Allows verifying with timeout. May be useful for testing in concurrent conditions.\n+ * <h3 id=\"22\"><a name=\"verificationtimeout\">22. (**New**) Verification with timeout (Since 1.8.5)  </a></h3>\n+ * <p>\n+ * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n+ * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent\n+ * conditions.\n  * <p>\n  * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system.\n  * <p>\n  *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n  *   verify(mock, timeout(100).times(2)).someMethod();\n  *\n- *   //passes when someMethod() is called <b>*at lest*</b> 2 times within given time span\n+ *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n  *   verify(mock, timeout(100).atLeast(2)).someMethod();\n  *   \n  *   //verifies someMethod() within given time span using given verification mode\n  *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n  * </code></pre>\n  *\n- * <h3 id=\"23\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9)</h3>\n+ * <h3 id=\"23\"><a name=\"autoinstantiate\">23. (**New**) Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9.0)</a></h3>\n  * <p>\n  * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields\n  * using <b>constructor</b> injection, <b>setter</b> injection, or <b>field</b> injection.\n  * &#064;InjectMocks LocalPub;\n  * </code></pre>\n  *\n- * <h3 id=\"24\">24. (**New**) One-liner stubs (Since 1.9)</h3>\n+ * <h3 id=\"24\"><a name=\"onelinestub\">24. (**New**) One-liner stubs (Since 1.9.0)</a></h3>\n  * <p>\n  * Mockito will now allow you to create mocks when stubbing.\n  * Basically, it allows to create a stub in one line of code.\n  *   &#064;Test public void should... {}\n  * </code></pre>\n  *\n- * <h3 id=\"25\">25. Verification ignoring stubs (Since 1.9)</h3>\n+ * <h3 id=\"25\"><a name=\"verifyignorestubs\">25. Verification ignoring stubs (Since 1.9.0)</a></h3>\n  * <p>\n  * Mockito will now allow to ignore stubbing for the sake of verification.\n  * Sometimes useful when coupled with <code>verifyNoMoreInteractions()</code> or verification <code>inOrder()</code>.\n  * </code></pre>\n  * <p>\n  * Advanced examples and more details can be found in javadoc for {@link Mockito#ignoreStubs(Object...)}\n+ *\n+ * <h3 id=\"26\"><a name=\"mockingdetails\">26. Mocking details (Since 1.9.1)</a></h3>\n+ * <p>\n+ * To identify whether a particular object is a mock or a spy, you can write\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     MockingDetails.of( someObject ).isMock();\n+ *     MockingDetails.of( someObject ).isSpy();\n+ * </code></pre>\n+ * Both the <code>isMock()</code> and <code>isSpy()</code> methods return <code>boolean</code>.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n      * <h4>Important gotcha on spying real objects!</h4>\n      * <ol>\n      * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n-     * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of methods for stubbing. Example:\n+     * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>\n+     * family of methods for stubbing. Example:\n      *\n      * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n     }    \n     \n     /**\n-     * Allows verifying with timeout. May be useful for testing in concurrent conditions.\n+     * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n+     * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent\n+     * conditions.\n      * <p>\n      * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n      * <p>\n      *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n      *   verify(mock, timeout(100).times(2)).someMethod();\n      *\n-     *   //passes when someMethod() is called <b>*at lest*</b> 2 times within given time span\n+     *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n      *   verify(mock, timeout(100).atLeast(2)).someMethod();\n      *   \n      *   //verifies someMethod() within given time span using given verification mode\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.misusing.*;\n-import org.mockito.exceptions.verification.*;\n+import org.mockito.exceptions.misusing.FriendlyReminderException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.exceptions.misusing.NullInsteadOfMockException;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.SmartNullPointerException;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockito.exceptions.verification.junit.JUnitTool;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n import org.mockito.listeners.InvocationListener;\n \n import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n \n import static org.mockito.exceptions.Pluralizer.pluralize;\n                 ));\n     }\n \n-    public void invalidUseOfMatchers(int expectedMatchersCount, int recordedMatchersCount) {\n+    public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Invalid use of argument matchers!\",\n-                expectedMatchersCount + \" matchers expected, \" + recordedMatchersCount + \" recorded.\",\n+                expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n+                locationsOf(recordedMatchers),\n+                \"\",\n                 \"This exception may occur if matchers are combined with raw values:\",\n                 \"    //incorrect:\",\n                 \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                 \"    //correct:\",\n                 \"    someMethod(anyObject(), eq(\\\"String by matcher\\\"));\",\n                 \"\",\n-                \"For more info see javadoc for Matchers class.\"\n-        ));\n+                \"For more info see javadoc for Matchers class.\",\n+                \"\"\n+        ));\n+    }\n+\n+    public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {\n+        throw new InvalidUseOfMatchersException(join(\n+                \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n+                new Location(),\n+                \"\",\n+                expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n+                locationsOf(matcherStack),\n+                \"\",\n+                \"This exception may occur if matchers are combined with raw values:\",\n+                \"    //incorrect:\",\n+                \"    someMethod(AdditionalMatchers.and(isNotNull(), \\\"raw String\\\");\",\n+                \"When using matchers, all arguments have to be provided by matchers.\",\n+                \"For example:\",\n+                \"    //correct:\",\n+                \"    someMethod(AdditionalMatchers.and(isNotNull(), eq(\\\"raw String\\\"));\",\n+                \"\",\n+                \"For more info see javadoc for Matchers and AdditionalMatchers classes.\",\n+                \"\"\n+        ));\n+    }\n+\n+    public void reportNoSubMatchersFound(String additionalMatcherName) {\n+        throw new InvalidUseOfMatchersException(join(\n+                \"No matchers found for additional matcher \" + additionalMatcherName,\n+                new Location(),\n+                \"\"\n+        ));\n+    }\n+\n+\n+    private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n+        List<String> description = new ArrayList<String>();\n+        for (LocalizedMatcher matcher : matchers)\n+\t\t\tdescription.add(matcher.getLocation().toString());\n+        return join(description.toArray());\n     }\n \n     public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n         throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n     }\n \n-    public void misplacedArgumentMatcher(Location location) {\n+    public void misplacedArgumentMatcher(List<LocalizedMatcher> lastMatchers) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Misplaced argument matcher detected here:\",\n-                location,\n+                locationsOf(lastMatchers),\n                 \"\",\n                 \"You cannot use argument matchers outside of verification or stubbing.\",\n                 \"Examples of correct usage of argument matchers:\",\n                 \"\"\n         ), details);\n     }\n+\n+\tpublic void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n+\t\tthrow new MockitoException(join(\n+                \"Mocked type must be the same as the type of your delegated instance.\",\n+                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n+                \"  //correct delegate:\",\n+                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n+                \"  //incorrect - types don't match:\",\n+                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n+        ));\n+\t}\n+\n+\tpublic void spyAndDelegateAreMutuallyExclusive() {\n+\t\tthrow new MockitoException(join(\n+\t\t\t\t\"Settings should not define a spy instance and a delegated instance at the same time.\"\n+\t\t\t\t)) ;\n+\t}\n }\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n package org.mockito.internal.configuration;\n \n import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n import org.mockito.internal.creation.CglibMockMaker;\n import org.mockito.plugins.MockMaker;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.List;\n-import java.util.ServiceConfigurationError;\n \n public class ClassPathLoader {\n     private static final MockMaker mockMaker = findPlatformMockMaker();\n         try {\n             resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n         } catch (IOException e) {\n-            throw new ServiceConfigurationError(\"Failed to load \" + service, e);\n+            throw new MockitoException(\"Failed to load \" + service, e);\n         }\n \n         List<T> result = new ArrayList<T>();\n                     }\n                 }\n             } catch (Exception e) {\n-                throw new ServiceConfigurationError(\n+                throw new MockitoException(\n                         \"Failed to load \" + service + \" using \" + resource, e);\n             } finally {\n                 closeQuietly(in);\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n import java.lang.reflect.Field;\n import java.util.HashSet;\n import java.util.Set;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * See {@link MockitoAnnotations}\n     public void injectMocks(final Object testClassInstance) {\n         Class<?> clazz = testClassInstance.getClass();\n         Set<Field> mockDependentFields = new HashSet<Field>();\n-        Set<Object> mocks = new HashSet<Object>();\n+        Set<Object> mocks = newMockSafeHashSet();\n         \n         while (clazz != Object.class) {\n             new InjectMocksScanner(clazz).addTo(mockDependentFields);\n--- a/src/org/mockito/internal/configuration/injection/MockInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n \n import static org.mockito.internal.util.Checks.checkItemsNotNull;\n import static org.mockito.internal.util.Checks.checkNotNull;\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Internal injection configuration utility.\n      */\n     public static class OngoingMockInjection {\n         private Set<Field> fields = new HashSet<Field>();\n-        private Set<Object> mocks = new HashSet<Object>();\n+        private Set<Object> mocks = newMockSafeHashSet();\n         private Object fieldOwner;\n         private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n         private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.injection.filter.*;\n-import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n import java.util.*;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Inject mocks using first setters then fields, if no setters available.\n         Class<?> fieldClass = report.fieldClass();\n         Object fieldInstanceNeedingInjection = report.fieldInstance();\n         while (fieldClass != Object.class) {\n-            injectionOccurred |= injectMockCandidate(fieldClass, new HashSet<Object>(mockCandidates), fieldInstanceNeedingInjection);\n+            injectionOccurred |= injectMockCandidate(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n             fieldClass = fieldClass.getSuperclass();\n         }\n         return injectionOccurred;\n     }\n+\n \n \n     private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n--- a/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n import org.mockito.internal.util.reflection.FieldReader;\n \n import java.lang.reflect.Field;\n-import java.util.HashSet;\n import java.util.Set;\n+\n+import static org.mockito.internal.util.collections.Sets.newMockSafeHashSet;\n \n /**\n  * Scan mocks, and prepare them if needed.\n      * @return A prepared set of mock\n      */\n     private Set<Object> scan() {\n-        Set<Object> mocks = new HashSet<Object>();\n+        Set<Object> mocks = newMockSafeHashSet();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n             FieldReader fieldReader = new FieldReader(instance, field);\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n+import org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations;\n import org.mockito.internal.util.MockName;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.stubbing.Answer;\n     private Class<?>[] extraInterfaces;\n     private String name;\n     private Object spiedInstance;\n+    private Object delegatedInstance ;\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n     private boolean serializable;\n         if (extraInterfaces == null || extraInterfaces.length == 0) {\n             new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n         }\n-            \n+\n         for (Class<?> i : extraInterfaces) {\n             if (i == null) {\n                 new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n \n     public Object getSpiedInstance() {\n         return spiedInstance;\n+    }\n+\n+    public Object getDelegatedInstance() {\n+    \treturn this.delegatedInstance ;\n     }\n \n     public MockSettings name(String name) {\n     public boolean isSerializable() {\n         return serializable;\n     }\n-    \n+\n     public void initiateMockName(Class classToMock) {\n         mockName = new MockName(name, classToMock);\n     }\n     public void redefineMockName(String newName) {\n         mockName = new MockName(newName);\n     }\n+\n+\tpublic MockSettings forwardTo(Object delegatedInstance) {\n+\t\tthis.delegatedInstance = delegatedInstance ;\n+\t\treturn defaultAnswer(new ForwardsInvocations(this.delegatedInstance)) ;\n+\t}\n }\n \n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.List;\n \n import org.mockito.internal.debugging.Location;\n-import org.mockito.internal.util.ListUtil;\n-import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.internal.verification.api.InOrderContext;\n \n public class InvocationsFinder {\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n \n package org.mockito.internal.invocation;\n \n+import org.hamcrest.Matcher;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n+import org.mockito.internal.progress.ArgumentMatcherStorage;\n+\n import java.io.Serializable;\n import java.util.List;\n-\n-import org.hamcrest.Matcher;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.progress.ArgumentMatcherStorage;\n \n @SuppressWarnings(\"unchecked\")\n public class MatchersBinder implements Serializable {\n     private static final long serialVersionUID = -311433939339443463L;\n \n     public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n-        List<Matcher> lastMatchers = argumentMatcherStorage.pullMatchers();\n+        List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n-        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);\n+        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, (List<Matcher>)(List) lastMatchers);\n         return invocationWithMatchers;\n     }\n \n-    private void validateMatchers(Invocation invocation, List<Matcher> matchers) {\n-        if (!matchers.isEmpty()) {\n-            int recordedMatchersSize = matchers.size();\n+    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {\n+        if (!lastMatchers.isEmpty()) {\n+            int recordedMatchersSize = lastMatchers.size();\n             int expectedMatchersSize = invocation.getArgumentsCount();\n             if (expectedMatchersSize != recordedMatchersSize) {\n-                new Reporter().invalidUseOfMatchers(expectedMatchersSize, recordedMatchersSize);\n+                new Reporter().invalidUseOfMatchers(expectedMatchersSize, lastMatchers);\n             }\n         }\n     }\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n package org.mockito.internal.invocation.finder;\n \n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil;\n \n import java.util.List;\n \n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n+import org.hamcrest.Matcher;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n+\n import java.util.List;\n-\n-import org.hamcrest.Matcher;\n \n @SuppressWarnings(\"unchecked\")\n public interface ArgumentMatcherStorage {\n \n     HandyReturnValues reportMatcher(Matcher matcher);\n \n-    List<Matcher> pullMatchers();\n+    List<LocalizedMatcher> pullLocalizedMatchers();\n \n     HandyReturnValues reportAnd();\n \n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n \n package org.mockito.internal.progress;\n \n+import org.hamcrest.Matcher;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.matchers.And;\n+import org.mockito.internal.matchers.LocalizedMatcher;\n+import org.mockito.internal.matchers.Not;\n+import org.mockito.internal.matchers.Or;\n+\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Stack;\n \n-import org.hamcrest.Matcher;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.internal.matchers.And;\n-import org.mockito.internal.matchers.LocalizedMatcher;\n-import org.mockito.internal.matchers.Not;\n-import org.mockito.internal.matchers.Or;\n-\n @SuppressWarnings(\"unchecked\")\n public class ArgumentMatcherStorageImpl implements ArgumentMatcherStorage {\n-    \n+\n+    public static final int TWO_SUB_MATCHERS = 2;\n+    public static final int ONE_SUB_MATCHER = 1;\n     private Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();\n     \n     /* (non-Javadoc)\n     }\n \n     /* (non-Javadoc)\n-     * @see org.mockito.internal.progress.ArgumentMatcherStorage#pullMatchers()\n+     * @see org.mockito.internal.progress.ArgumentMatcherStorage#pullLocalizedMatchers()\n      */\n-    public List<Matcher> pullMatchers() {\n+    public List<LocalizedMatcher> pullLocalizedMatchers() {\n         if (matcherStack.isEmpty()) {\n             return Collections.emptyList();\n         }\n     }\n \n     /* (non-Javadoc)\n-     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportAnd()\n+    * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportAnd()\n+    */\n+    public HandyReturnValues reportAnd() {\n+        assertStateFor(\"And(?)\", TWO_SUB_MATCHERS);\n+        And and = new And(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n+        matcherStack.push(new LocalizedMatcher(and));\n+        return new HandyReturnValues();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportOr()\n      */\n-    public HandyReturnValues reportAnd() {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found for And(?).\");\n-        And and = new And(popLastArgumentMatchers(2));\n-        matcherStack.push(new LocalizedMatcher(and));\n+    public HandyReturnValues reportOr() {\n+        assertStateFor(\"Or(?)\", TWO_SUB_MATCHERS);\n+        Or or = new Or(popLastArgumentMatchers(TWO_SUB_MATCHERS));\n+        matcherStack.push(new LocalizedMatcher(or));\n         return new HandyReturnValues();\n     }\n \n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportNot()\n      */\n     public HandyReturnValues reportNot() {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found for Not(?).\");\n-        Not not = new Not(popLastArgumentMatchers(1).get(0));\n+        assertStateFor(\"Not(?)\", ONE_SUB_MATCHER);\n+        Not not = new Not(popLastArgumentMatchers(ONE_SUB_MATCHER).get(0));\n         matcherStack.push(new LocalizedMatcher(not));\n         return new HandyReturnValues();\n     }\n \n+    private void assertStateFor(String additionalMatcherName, int subMatchersCount) {\n+        assertMatchersFoundFor(additionalMatcherName);\n+        assertIncorrectUseOfAdditionalMatchers(additionalMatcherName, subMatchersCount);\n+    }\n+\n     private List<Matcher> popLastArgumentMatchers(int count) {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n-        assertState(matcherStack.size() >= count,\n-                \"\" + count + \" matchers expected, \" + matcherStack.size() + \" recorded.\");\n         List<Matcher> result = new LinkedList<Matcher>();\n         result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));\n         for (int i = 0; i < count; i++) {\n         return result;\n     }\n \n-    private void assertState(boolean toAssert, String message) {\n-        if (!toAssert) {\n+    private void assertMatchersFoundFor(String additionalMatcherName) {\n+        if (matcherStack.isEmpty()) {\n             matcherStack.clear();\n-            throw new InvalidUseOfMatchersException(message);\n+            new Reporter().reportNoSubMatchersFound(additionalMatcherName);\n         }\n     }\n \n-    /* (non-Javadoc)\n-     * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportOr()\n-     */\n-    public HandyReturnValues reportOr() {\n-        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n-        Or or = new Or(popLastArgumentMatchers(2));\n-        matcherStack.push(new LocalizedMatcher(or));\n-        return new HandyReturnValues();\n+    private void assertIncorrectUseOfAdditionalMatchers(String additionalMatcherName, int count) {\n+        if(matcherStack.size() < count) {\n+            ArrayList<LocalizedMatcher> lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n+            matcherStack.clear();\n+            new Reporter().incorrectUseOfAdditionalMatchers(additionalMatcherName, count, lastMatchers);\n+        }\n     }\n \n     /* (non-Javadoc)\n      */\n     public void validateState() {\n         if (!matcherStack.isEmpty()) {\n-            LocalizedMatcher lastMatcher = matcherStack.lastElement();\n+            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n             matcherStack.clear();\n-            new Reporter().misplacedArgumentMatcher(lastMatcher.getLocation());\n+            new Reporter().misplacedArgumentMatcher(lastMatchers);\n         }\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ForwardsInvocations.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+\n+public class ForwardsInvocations implements Answer<Object>, Serializable {\n+\n+\tprivate static final long serialVersionUID = -8343690268123254910L;\n+\n+\tprivate Object delegatedObject = null ;\n+\n+\tpublic ForwardsInvocations(Object delegatedObject) {\n+\t\tthis.delegatedObject = delegatedObject ;\n+\t}\n+\n+\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\n+\t\tMethod method = invocation.getMethod() ;\n+\n+        return method.invoke(delegatedObject, invocation.getArguments());\n+\t}\n+}\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n \n @SuppressWarnings(\"unchecked\")\n     public boolean isTypeMockable(Class<?> clz) {\n         return ClassImposterizer.INSTANCE.canImposterise(clz);\n     }\n-    \n+\n     public void validateType(Class classToMock) {\n         if (!isTypeMockable(classToMock)) {\n             new Reporter().cannotMockFinalClass(classToMock);\n         }\n     }\n-    \n+\n     public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n         if (extraInterfaces == null) {\n             return;\n         }\n-        \n+\n         for (Class i : extraInterfaces) {\n             if (classToMock == i) {\n                 new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n             }\n         }\n     }\n-    \n+\n     public void validateMockedType(Class classToMock, Object spiedInstance) {\n         if (classToMock == null || spiedInstance == null) {\n             return;\n             new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n         }\n     }\n+\n+    public void validateDelegatedInstance(Class classToMock, Object delegatedInstance) {\n+    \tif (classToMock == null || delegatedInstance == null) {\n+            return;\n+        }\n+    \tif (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n+            new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n+        }\n+    }\n+\n+\tpublic void validateMutualExclusionForSpyOrDelegate(MockSettingsImpl settings) {\n+\t\tif (settings.getDelegatedInstance() != null && settings.getSpiedInstance() != null) {\n+\t\t\tnew Reporter().spyAndDelegateAreMutuallyExclusive() ;\n+\t\t}\n+\n+\t}\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import java.io.Serializable;\n import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.plugins.MockMaker;\n import org.mockito.internal.InvocationNotifierHandler;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockito.plugins.MockMaker;\n+\n+import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n     public MockUtil(MockCreationValidator creationValidator) {\n         this.creationValidator = creationValidator;\n     }\n-    \n+\n     public MockUtil() {\n         this(new MockCreationValidator());\n     }\n         creationValidator.validateType(classToMock);\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n         creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n+        creationValidator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance()) ;\n+        creationValidator.validateMutualExclusionForSpyOrDelegate(settings) ;\n \n         settings.initiateMockName(classToMock);\n \n         if (spiedInstance != null) {\n             new LenientCopyTool().copyToMock(spiedInstance, mock);\n         }\n-        \n+\n         return mock;\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n+package org.mockito.internal.util.collections;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+/**\n+ * hashCode and equals safe mock wrapper.\n+ *\n+ * <p>\n+ *     It doesn't use the actual mock {@link Object#hashCode} and {@link Object#equals} method as they might\n+ *     throw an NPE if those method cannot be stubbed <em>even internally</em>.\n+ * </p>\n+ *\n+ * <p>\n+ *     Instead the strategy is :\n+ *     <ul>\n+ *         <li>For hashCode : <strong>use {@link System#identityHashCode}</strong></li>\n+ *         <li>For equals : <strong>use the object reference equality</strong></li>\n+ *     </ul>\n+ * </p>\n+ *\n+ * @see HashCodeAndEqualsSafeSet\n+ */\n+public class HashCodeAndEqualsMockWrapper {\n+\n+    private Object mockInstance;\n+\n+    public HashCodeAndEqualsMockWrapper(Object mockInstance) {\n+        this.mockInstance = mockInstance;\n+    }\n+\n+    public Object get() {\n+        return mockInstance;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof HashCodeAndEqualsMockWrapper)) return false;\n+\n+        HashCodeAndEqualsMockWrapper that = (HashCodeAndEqualsMockWrapper) o;\n+\n+        return mockInstance == that.mockInstance;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(mockInstance);\n+    }\n+\n+    public static HashCodeAndEqualsMockWrapper of(Object mock) {\n+        return new HashCodeAndEqualsMockWrapper(mock);\n+    }\n+\n+    @Override public String toString() {\n+        MockUtil mockUtil = new MockUtil();\n+        return \"HashCodeAndEqualsMockWrapper{\" +\n+                \"mockInstance=\" + (mockUtil.isMock(mockInstance) ? mockUtil.getMockName(mockInstance) : typeInstanceString()) +\n+                '}';\n+    }\n+\n+    private String typeInstanceString() {\n+        return mockInstance.getClass().getSimpleName() + \"(\" + System.identityHashCode(mockInstance) + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n+package org.mockito.internal.util.collections;\n+\n+import org.mockito.internal.util.Checks;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import static java.lang.reflect.Array.*;\n+\n+/**\n+ * hashCode and equals safe hash based set.\n+ *\n+ * <p>\n+ *     Useful for holding mocks that have un-stubbable hashCode or equals method,\n+ *     meaning that in this scenario the real code is always called and will most probably\n+ *     cause an {@link NullPointerException}.\n+ * </p>\n+ * <p>\n+ *     This collection wraps the mock in an augmented type {@link HashCodeAndEqualsMockWrapper}\n+ *     that have his own implementation.\n+ * </p>\n+ *\n+ * @see HashCodeAndEqualsMockWrapper\n+ */\n+public class HashCodeAndEqualsSafeSet implements Set<Object> {\n+\n+    private HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+\n+    public Iterator<Object> iterator() {\n+        return new Iterator<Object>() {\n+            private Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n+\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            public Object next() {\n+                return iterator.next().get();\n+            }\n+\n+            public void remove() {\n+                iterator.remove();\n+            }\n+        };\n+    }\n+\n+    public int size() {\n+        return backingHashSet.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return backingHashSet.isEmpty();\n+    }\n+\n+    public boolean contains(Object mock) {\n+        return backingHashSet.contains(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public boolean add(Object mock) {\n+        return backingHashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public boolean remove(Object mock) {\n+        return backingHashSet.remove(HashCodeAndEqualsMockWrapper.of(mock));\n+    }\n+\n+    public void clear() {\n+        backingHashSet.clear();\n+    }\n+\n+    @Override public Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+        if (!(o instanceof HashCodeAndEqualsSafeSet)) {\n+            return false;\n+        }\n+        HashCodeAndEqualsSafeSet that = (HashCodeAndEqualsSafeSet) o;\n+        return backingHashSet.equals(that.backingHashSet);\n+    }\n+\n+    @Override public int hashCode() {\n+        return backingHashSet.hashCode();\n+    }\n+\n+    public Object[] toArray() {\n+        return unwrapTo(new Object[size()]);\n+    }\n+\n+    private <T> T[] unwrapTo(T[] array) {\n+        Iterator<Object> iterator = iterator();\n+        for (int i = 0, objectsLength = array.length; i < objectsLength; i++) {\n+            if (iterator.hasNext()) {\n+                array[i] = (T) iterator.next();\n+            }\n+        }\n+        return array;\n+    }\n+\n+\n+    public <T> T[] toArray(T[] typedArray) {\n+        T[] array = typedArray.length >= size() ? typedArray :\n+                (T[]) newInstance(typedArray.getClass().getComponentType(), size());\n+        return unwrapTo(array);\n+    }\n+\n+    public boolean removeAll(Collection<?> mocks) {\n+        return backingHashSet.removeAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean containsAll(Collection<?> mocks) {\n+        return backingHashSet.containsAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean addAll(Collection<?> mocks) {\n+        return backingHashSet.addAll(asWrappedMocks(mocks));\n+    }\n+\n+    public boolean retainAll(Collection<?> mocks) {\n+        return backingHashSet.retainAll(asWrappedMocks(mocks));\n+    }\n+\n+    private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {\n+        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n+        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+        for (Object mock : mocks) {\n+            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n+            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n+        }\n+        return hashSet;\n+    }\n+\n+    @Override public String toString() {\n+        return backingHashSet.toString();\n+    }\n+\n+    public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n+        return of(Arrays.asList(mocks));\n+    }\n+\n+    public static HashCodeAndEqualsSafeSet of(Iterable<Object> objects) {\n+        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet = new HashCodeAndEqualsSafeSet();\n+        if (objects != null) {\n+            for (Object mock : objects) {\n+                hashCodeAndEqualsSafeSet.add(mock);\n+            }\n+        }\n+        return hashCodeAndEqualsSafeSet;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/IdentitySet.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import java.util.LinkedList;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class IdentitySet {\n+\n+    LinkedList list = new LinkedList();\n+    \n+    public boolean contains(Object o) {\n+        for(Object existing:list) {\n+            if (existing == o) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void add(Object o) {\n+        list.add(o);        \n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/ListUtil.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.util.collections;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+\n+public class ListUtil {\n+\n+    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n+        LinkedList<T> filtered = new LinkedList<T>();\n+        for (T t : collection) {\n+            if (!filter.isOut(t)) {\n+                filtered.add(t);\n+            }\n+        }\n+        return filtered;\n+    }\n+    \n+    public static interface Filter<T> {\n+        boolean isOut(T object);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/Sets.java\n+package org.mockito.internal.util.collections;\n+\n+\n+import java.util.Set;\n+\n+public abstract class Sets {\n+    public static Set<Object> newMockSafeHashSet(Iterable<Object> mocks) {\n+        return HashCodeAndEqualsSafeSet.of(mocks);\n+    }\n+\n+    public static Set<Object> newMockSafeHashSet(Object... mocks) {\n+        return HashCodeAndEqualsSafeSet.of(mocks);\n+    }\n+\n+    public static IdentitySet newIdentitySet() {\n+        return new IdentitySet();\n+    }\n+}\n--- a/src/org/mockito/internal/verification/InOrderContextImpl.java\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n \n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.IdentitySet;\n+import org.mockito.internal.util.collections.IdentitySet;\n import org.mockito.internal.verification.api.InOrderContext;\n \n public class InOrderContextImpl implements InOrderContext {\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.util.ListUtil;\n-import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n \n import java.io.Serializable;\n import java.util.Collections;\n \n     private static final long serialVersionUID = -2674402327380736290L;\n     private final List<Invocation> invocations = Collections.synchronizedList(new LinkedList<Invocation>());\n-    \n+\n     public void add(Invocation invocation) {\n         invocations.add(invocation);\n     }\n     }\n \n     public List<Invocation> getAll() {\n-        return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());\n+    \tList<Invocation> copiedList;\n+    \tsynchronized (invocations) {\n+\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n+\t\t}\n+\n+        return ListUtil.filter(copiedList, new RemoveToString());\n     }\n \n     public boolean isEmpty() {\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.concurrentmockito;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n import org.junit.runner.Result;\n import org.mockito.internal.progress.MockingProgressImplTest;\n import org.mockito.internal.progress.TimesTest;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n-import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.util.collections.ListUtilTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;\n import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n import org.mockitousage.verification.VerificationUsingMatchersTest;\n import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n \n public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n     \n--- /dev/null\n+++ b/test/org/mockito/MockingDetailsTest.java\n+package org.mockito;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class MockingDetailsTest {\n+    \n+    private static class TestClass{\n+    }\n+\n+    @Mock TestClass mock1;\n+    @Spy TestClass spy1;\n+    \n+    @Before\n+    public void setUp(){\n+        initMocks( this );\n+    }\n+    \n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForAnnotatedMock(){\n+        assertTrue(MockingDetails.of(mock1).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForDirectMock(){\n+        TestClass mock2 = mock( TestClass.class );\n+        assertTrue(MockingDetails.of(mock2).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsMock_ForNonMock(){\n+        TestClass nonMock = new TestClass();\n+        assertFalse(MockingDetails.of(nonMock).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsSpy_ForAnnotatedSpy(){\n+        assertTrue(MockingDetails.of(spy1).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsSpy_ForDirectSpy(){\n+        TestClass spy2 = spy( new TestClass());\n+        assertTrue(MockingDetails.of(spy2).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForNonSpy(){\n+        TestClass nonSpy = new TestClass();\n+        assertFalse(MockingDetails.of(nonSpy).isSpy());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSetTest.java\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Observer;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+public class HashCodeAndEqualsSafeSetTest {\n+\n+    @Test\n+    public void can_add_mock_that_have_failing_hashCode_method() throws Exception {\n+        new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));\n+    }\n+\n+    @Test\n+    public void mock_with_failing_hashCode_method_can_be_added() throws Exception {\n+        new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));\n+    }\n+\n+    @Test\n+    public void mock_with_failing_equals_method_can_be_used() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();\n+        UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);\n+        mocks.add(mock);\n+\n+        assertThat(mocks.contains(mock)).isTrue();\n+        assertThat(mocks.contains(mock(UnmockableHashCodeAndEquals.class))).isFalse();\n+    }\n+\n+    @Test\n+    public void can_remove() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();\n+        UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);\n+        mocks.add(mock);\n+        mocks.remove(mock);\n+\n+        assertThat(mocks.isEmpty()).isTrue();\n+    }\n+\n+\n+    @Test\n+    public void can_add_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+\n+        assertThat(workingSet.containsAll(mocks)).isTrue();\n+    }\n+\n+    @Test\n+    public void can_retain_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+        workingSet.add(mock(List.class));\n+\n+        assertThat(workingSet.retainAll(mocks)).isTrue();\n+        assertThat(workingSet.containsAll(mocks)).isTrue();\n+    }\n+\n+    @Test\n+    public void can_remove_a_collection() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();\n+\n+        workingSet.addAll(mocks);\n+        workingSet.add(mock(List.class));\n+\n+        assertThat(workingSet.removeAll(mocks)).isTrue();\n+        assertThat(workingSet.containsAll(mocks)).isFalse();\n+    }\n+\n+    @Test\n+    public void can_iterate() throws Exception {\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(\n+                mock(UnmockableHashCodeAndEquals.class),\n+                mock(Observer.class));\n+\n+        LinkedList<Object> accumulator = new LinkedList<Object>();\n+        for (Object mock : mocks) {\n+            accumulator.add(mock);\n+        }\n+        assertThat(accumulator).isNotEmpty();\n+    }\n+\n+    @Test\n+    public void toArray_just_work() throws Exception {\n+        UnmockableHashCodeAndEquals mock1 = mock(UnmockableHashCodeAndEquals.class);\n+        HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1);\n+\n+        assertThat(mocks.toArray()[0]).isSameAs(mock1);\n+\n+        assertThat(mocks.toArray(new UnmockableHashCodeAndEquals[0])[0]).isSameAs(mock1);\n+    }\n+\n+    private static class UnmockableHashCodeAndEquals {\n+        @Override public final int hashCode() {\n+            throw new NullPointerException(\"I'm failing on hashCode and I don't care\");\n+        }\n+\n+        @Override public final boolean equals(Object obj) {\n+            throw new NullPointerException(\"I'm failing on equals and I don't care\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/IdentitySetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+public class IdentitySetTest {\n+    \n+    IdentitySet set = new IdentitySet();\n+    \n+    @Test\n+    public void shouldWork() throws Exception {\n+        //when\n+        Object o = new Object();\n+        set.add(o);\n+\n+        //then\n+        assertTrue(set.contains(o));\n+        assertFalse(set.contains(new Object()));\n+    }\n+    \n+    class Fake {\n+        @Override\n+        public boolean equals(Object obj) {\n+            return true;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldWorkEvenIfEqualsTheSame() throws Exception {\n+        //given\n+        assertEquals(new Fake(), new Fake());\n+        Fake fake = new Fake();\n+        \n+        //when\n+        set.add(fake);\n+\n+        //then\n+        assertTrue(set.contains(fake));\n+        assertFalse(set.contains(new Fake()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/collections/ListUtilTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.util.collections;\n+\n+import org.junit.Test;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.mockitoutil.ExtraMatchers.hasExactlyInOrder;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ListUtilTest extends TestBase {\n+\n+    @Test\n+    public void shouldFilterList() throws Exception {\n+        List list = asList(\"one\", \"x\", \"two\", \"x\", \"three\");\n+        List filtered = ListUtil.filter(list, new Filter() {\n+            public boolean isOut(Object object) {\n+                return object == \"x\";\n+            }\n+        });\n+        \n+        assertThat(filtered, hasExactlyInOrder(\"one\", \"two\", \"three\"));\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyIfEmptyListGiven() throws Exception {\n+        List list = new LinkedList();\n+        List filtered = ListUtil.filter(list, null);\n+        assertTrue(filtered.isEmpty());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.timeout;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+\n+// issue 322\n+// the only evidence of this failing test was shown on a RHEL with IBM J9 JVM 64bits\n+//\n+// details\n+// java.fullversion=JRE 1.6.0 IBM J9 2.6 Linux amd64-64 20111113_94967  (JIT enabled, AOT enabled)\n+// Linux2.6.32-220.4.2.el6.x86_64 #1SMP Mon Feb 6 16:39:28EST 2012x86_64 x86_64 x86_64 GNU/Linux\n+public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {\n+\n+\tint nThreads = 1;\n+\tstatic final int TEST_MILLIS = 1000;\n+\tstatic final int INTERVAL_MILLIS = 10;\n+\tstatic final int TIMES = TEST_MILLIS / INTERVAL_MILLIS;\n+\n+\tITarget target = Mockito.mock(ITarget.class);\n+\tExecutorService fixedThreadPool;\n+\t\n+\t@Before\n+\tpublic void setUp() {\n+\t\ttarget = Mockito.mock(ITarget.class);\n+\t\tfixedThreadPool = Executors.newFixedThreadPool(nThreads);\n+\t}\n+\n+\t@Test\n+\tpublic void testInvocationConcurrently() throws Exception {\n+\t\treset(target);\n+\t\tstartInvocations();\n+\t\tverify(target, timeout(TEST_MILLIS).times(TIMES*nThreads)).targetMethod(\"arg\");\n+\t\tverifyNoMoreInteractions(target);\n+\t}\n+\n+\tprivate void startInvocations() throws InterruptedException,\n+\t\t\tExecutionException {\n+\t\t\n+\t\tfor(int i=0; i<nThreads; i++) {\n+\t\t\tfixedThreadPool.submit(new TargetInvoker(i));\n+\t\t}\n+\n+\t}\n+\n+\t\n+\tpublic class TargetInvoker implements Callable<Object> {\n+\n+\t\tprivate final int seq;\n+\n+\t\tTargetInvoker(int seq) {\n+\t\t\tthis.seq = seq;\n+\t\t}\n+\t\t\n+\t\tpublic Object call() throws Exception {\n+\t\t\tSystem.err.println(\"started \" + seq);\n+\t\t\tfor (int i = 0; i < TIMES; i++) {\n+\t\t\t\tThread.yield();\n+\t\t\t\ttarget.targetMethod(\"arg\");\n+\t\t\t\tThread.sleep((long) INTERVAL_MILLIS);\n+\t\t\t}\n+\t\t\tSystem.err.println(\"finished\" + seq);\n+\t\t\treturn seq;\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\tpublic static interface ITarget {\n+\n+\t\tpublic String targetMethod(String arg);\n+\t}\n+\t\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/FinalHashCodeAndEqualsRaiseNPEInInitMocksTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.nio.charset.Charset;\n+\n+// issue 327\n+public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {\n+    @Mock private Charset charset;\n+    @InjectMocks private FieldCharsetHolder fieldCharsetHolder;\n+    @InjectMocks private ConstructorCharsetHolder constructorCharsetHolder;\n+\n+    @Test\n+    public void dont_raise_NullPointerException() throws Exception {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    private static class FieldCharsetHolder {\n+        private Charset charset;\n+    }\n+\n+    private static class ConstructorCharsetHolder {\n+        public ConstructorCharsetHolder(Charset charset) {\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n \n package org.mockitousage.matchers;\n \n-import static org.mockito.Matchers.*;\n-\n-import org.junit.After;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n import org.mockito.AdditionalMatchers;\n import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.runners.MockitoJUnitRunner;\n import org.mockitousage.IMethods;\n-import org.mockitoutil.TestBase;\n \n-public class InvalidUseOfMatchersTest extends TestBase {\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class InvalidUseOfMatchersTest {\n \n     @Mock private IMethods mock;\n \n-    @After\n-    public void resetState() {\n-        super.resetState();\n+    @Test\n+    public void should_detect_wrong_number_of_matchers_when_stubbing() {\n+        when(mock.threeArgumentMethod(1, \"2\", \"3\")).thenReturn(null);\n+        try {\n+            when(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).thenReturn(null);\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertThat(e.getMessage())\n+                      .contains(\"3 matchers expected\")\n+                      .contains(\"1 recorded\");\n+        }\n     }\n \n     @Test\n-    public void shouldDetectWrongNumberOfMatchersWhenStubbing() {\n-        Mockito.when(mock.threeArgumentMethod(1, \"2\", \"3\")).thenReturn(null);\n-        try {\n-            Mockito.when(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).thenReturn(null);\n-            fail();\n-        } catch (InvalidUseOfMatchersException e) {}\n-    }\n-\n-    @Test\n-    public void shouldDetectStupidUseOfMatchersWhenVerifying() {\n+    public void should_detect_stupid_use_of_matchers_when_verifying() {\n         mock.oneArg(true);\n         eq(\"that's the stupid way\");\n         eq(\"of using matchers\");\n         try {\n             Mockito.verify(mock).oneArg(true);\n             fail();\n-        } catch (InvalidUseOfMatchersException e) {}\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertThat(e.getMessage())\n+                      .contains(\"Misplaced argument matcher detected here\");\n+            e.printStackTrace();\n+        }\n     }\n \n     @Test\n-    public void shouldScreamWhenMatchersAreInvalid() {\n+    public void should_not_scream_on_correct_usage() throws Exception {\n         mock.simpleMethod(AdditionalMatchers.not(eq(\"asd\")));\n+        mock.simpleMethod(AdditionalMatchers.or(eq(\"jkl\"), eq(\"asd\")));\n+    }\n+\n+    @Test\n+    public void should_scream_when_no_matchers_inside_not() {\n         try {\n             mock.simpleMethod(AdditionalMatchers.not(\"jkl\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertContains(\"No matchers found for Not(?).\", e.getMessage());\n+            assertThat(e.getMessage())\n+                    .contains(\"No matchers found for\")\n+                    .containsIgnoringCase(\"Not(?)\");\n         }\n+    }\n \n+    @Test\n+    public void should_scream_when_not_enough_matchers_inside_or_AddtionalMatcher() {\n         try {\n             mock.simpleMethod(AdditionalMatchers.or(eq(\"jkl\"), \"asd\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertContains(\"2 matchers expected, 1 recorded.\", e.getMessage());\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"inside additional matcher Or(?)\")\n+                    .contains(\"2 sub matchers expected\")\n+                    .contains(\"1 recorded\");\n         }\n+    }\n \n+    @Test\n+    public void should_scream_when_Matchers_count_dont_match_parameter_count() {\n         try {\n             mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertContains(\"3 matchers expected, 1 recorded.\", e.getMessage());\n+            assertThat(e.getMessage())\n+                      .contains(\"3 matchers expected\")\n+                      .contains(\"1 recorded\");\n         }\n     }\n }\n--- a/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.misuse;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n \n import org.junit.After;\n import org.junit.Test;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.Observer;\n+\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.validateMockitoUsage;\n+import static org.mockito.Mockito.verify;\n \n public class DetectingMisusedMatchersTest extends TestBase {\n \n         super.resetState();\n     }\n \n-    private void misplacedArgumentMatcher() {\n+    private void misplaced_anyObject_argument_matcher() {\n         anyObject();\n+    }\n+    \n+    private void misplaced_anyInt_argument_matcher() {\n+        anyInt();\n+    }\n+    \n+    private void misplaced_anyBoolean_argument_matcher() {\n+        anyBoolean();\n     }\n \n     @Test\n-    public void shouldFailFastWhenArgumentMatchersAbused() {\n-        misplacedArgumentMatcher();\n+    public void should_fail_fast_when_argument_matchers_are_abused() {\n+        misplaced_anyObject_argument_matcher();\n         try {\n             mock(IMethods.class);\n             fail();\n             assertContains(\"Misplaced argument matcher\", e.getMessage());\n         }\n     }\n+    \n+    @Test\n+    public void should_report_argument_locations_when_argument_matchers_misused() {\n+        try {\n+        \tObserver observer = mock(Observer.class);\n+        \t\n+        \tmisplaced_anyInt_argument_matcher();\n+        \tmisplaced_anyObject_argument_matcher();\n+        \tmisplaced_anyBoolean_argument_matcher();\n+        \t\n+        \tobserver.update(null, null);\n+        \t\n+        \tvalidateMockitoUsage();\n+        \tfail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertContains(\"DetectingMisusedMatchersTest.misplaced_anyInt_argument_matcher\", e.getMessage());\n+            assertContains(\"DetectingMisusedMatchersTest.misplaced_anyObject_argument_matcher\", e.getMessage());\n+            assertContains(\"DetectingMisusedMatchersTest.misplaced_anyBoolean_argument_matcher\", e.getMessage());\n+        }\n+    }\n+   \n     \n     @Test\n     public void shouldSayUnfinishedVerificationButNotInvalidUseOfMatchers() {\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+import org.mockitousage.MethodsImpl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithDelegate {\n+\n+\t@Test\n+\tpublic void when_not_stubbed_delegate_should_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\n+\t\tList<String> mock = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\n+\t\tmock.add(\"two\") ;\n+\n+        assertEquals(2, mock.size());\n+\t}\n+\n+\t@Test\n+\tpublic void when_stubbed_the_delegate_should_not_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mock = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\n+\t\tdoReturn(10).when(mock).size();\n+\n+\t\tmock.add(\"two\") ;\n+\n+\t\tassertEquals(10, mock.size());\n+        assertEquals(2, delegatedList.size());\n+\t}\n+\n+\t@Test\n+\tpublic void delegate_should_not_be_called_when_stubbed2() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mockedList = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\n+\t\tdoReturn(false).when(mockedList).add(Mockito.anyString()) ;\n+\n+        mockedList.add(\"two\") ;\n+\n+\t\tassertEquals(1, mockedList.size()) ;\n+\t\tassertEquals(1, delegatedList.size()) ;\n+\t}\n+\n+    @Test\n+    public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {\n+        IMethods methods = mock(IMethods.class, withSettings().forwardTo(new MethodsImpl()));\n+\n+        try {\n+            byte b = methods.byteObjectReturningMethod(); // real method returns null\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.toString()).doesNotContain(\"org.mockito\");\n+        }\n+    }\n+}", "timestamp": 1333100168, "metainfo": ""}