{"sha": "78e1b0c359232122ee71b1c8f5d599a7737d0fdd", "log": "Spy Javadoc enhancement + some visual tweaks for bold parts (transplanted from f18c0a7177fd033f92d357b53abea9aa736e13b6)  --HG-- branch : 1.9-rc1 extra : transplant_source : %F1%8C%0Aqw%FD%03%3F%92%D3W%B5%3A%BE%A9%AAsn%13%B6", "commit": "\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n     /**\n      * Allows creating custom argument matchers.\n      * <p>\n-     * In rare cases when the parameter is a primitive then you *must* use relevant intThat(), floatThat(), etc. method.\n+     * In rare cases when the parameter is a primitive then you <b>*must*</b> use relevant intThat(), floatThat(), etc. method.\n      * This way you will avoid NullPointerException during autounboxing  \n      * <p>\n      * See examples in javadoc for {@link ArgumentMatcher} class\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *   //You have to use doReturn() for stubbing\n  *   doReturn(\"foo\").when(spy).get(0);\n  * </pre>\n- * \n- * 2. Watch out for final methods. \n+ *\n+ * 2. Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n+ * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction\n+ * and their effect on real instance state.\n+ * The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,\n+ * you won't see any effects on the real instance.\n+ *\n+ * 3. Watch out for final methods.\n  * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n- * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n- * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n+ * Also you won't be able to verify those method as well.\n  * \n  * <h3 id=\"14\">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>\n  * \n  * that Mockito will inject mocks in a partial mock under testing. As a remainder, please read point 16 about partial mocks.\n  *\n  * <p>\n- * All new annotations are *only* processed on {@link MockitoAnnotations#initMocks(Object)}.\n+ * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.\n  * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner}.\n  * <p>\n  * <h3 id=\"22\">22. (**New**) Verification with timeout (Since 1.8.5)  </h3>\n  *   //above is an alias to:\n  *   verify(mock, timeout(100).times(1)).someMethod();\n  *   \n- *   //passes when someMethod() is called *exactly* 2 times within given time span\n+ *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n  *   verify(mock, timeout(100).times(2)).someMethod();\n  *\n- *   //passes when someMethod() is called *at lest* 2 times within given time span\n+ *   //passes when someMethod() is called <b>*at lest*</b> 2 times within given time span\n  *   verify(mock, timeout(100).atLeast(2)).someMethod();\n  *   \n  *   //verifies someMethod() within given time span using given verification mode\n      * </pre>\n      * \n      * <h4>Important gotcha on spying real objects!</h4>\n-     * \n+     *\n      * 1. Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n      * Therefore when using spies please consider doReturn|Answer|Throw() family of methods for stubbing. Example:\n-     * \n+     *\n      * <pre>\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n-     *   \n+     *\n      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n      *   when(spy.get(0)).thenReturn(\"foo\");\n-     *   \n+     *\n      *   //You have to use doReturn() for stubbing\n      *   doReturn(\"foo\").when(spy).get(0);\n      * </pre>\n-     * \n-     * 2. Watch out for final methods. \n+     *\n+     * 2. Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n+     * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction\n+     * and their effect on real instance state.\n+     * The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,\n+     * you won't see any effects on the real instance.\n+     *\n+     * 3. Watch out for final methods.\n      * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n-     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n-     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n-     * \n+     * Also you won't be able to verify those method as well.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * \n      * <b>Warning</b>, ignoreStubs() might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...));\n      * Bear in mind that Mockito does not recommend bombarding every test with verifyNoMoreInteractions()\n      * for the reasons outlined in javadoc for {@link Mockito#verifyNoMoreInteractions(Object...)}\n-     * Other words: all *stubbed* methods of given mocks are marked *verfied* so that they don't get in a way during verifyNoMoreInteractions().\n+     * Other words: all <b>*stubbed*</b> methods of given mocks are marked <b>*verfied*</b> so that they don't get in a way during verifyNoMoreInteractions().\n      * <p>\n      * This method <b>changes the input mocks</b>! This method returns input mocks just for convenience.\n      * <p>\n      *  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()\n      *  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));\n      *\n-     *  //Remember that ignoreStubs() *changes* the input mocks and returns them for convenience.\n+     *  //Remember that ignoreStubs() <b>*changes*</b> the input mocks and returns them for convenience.\n      * <pre>\n      * Ignoring stubs can be used with <b>verification in order</b>:\n      * <pre>\n      *   //above is an alias to:\n      *   verify(mock, timeout(100).times(1)).someMethod();\n      *   \n-     *   //passes when someMethod() is called *exactly* 2 times within given time span\n+     *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n      *   verify(mock, timeout(100).times(2)).someMethod();\n      *\n-     *   //passes when someMethod() is called *at lest* 2 times within given time span\n+     *   //passes when someMethod() is called <b>*at lest*</b> 2 times within given time span\n      *   verify(mock, timeout(100).atLeast(2)).someMethod();\n      *   \n      *   //verifies someMethod() within given time span using given verification mode\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n  *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n  *     <ul>\n  *     <li>find mock candidate by type\n- *     <li>if more than *one* candidate find mock candidate on name\n+ *     <li>if more than <b>*one*</b> candidate find mock candidate on name\n  *     <li>if one mock candidate then\n  *       <ul>\n  *       <li>set mock by property setter if possible", "timestamp": 1321970758, "metainfo": ""}