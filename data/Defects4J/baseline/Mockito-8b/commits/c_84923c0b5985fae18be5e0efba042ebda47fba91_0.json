{"sha": "84923c0b5985fae18be5e0efba042ebda47fba91", "log": "Removed Generic Metadata stuff Mockito settings, now use a new answer instance with the actual metadata of the type that is returned in the function call", "commit": "\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockNameImpl;\n import org.mockito.internal.util.MockitoSpy;\n-import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n         return interfaces;\n     }\n \n-    public MockSettings parameterizedInfo(GenericMetadataSupport mockitoGenericMetadata) {\n-        this.mockitoGenericMetadata = mockitoGenericMetadata;\n-        return this;\n-    }\n }\n \n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n  */\n package org.mockito.internal.creation.settings;\n \n-import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n     protected MockName mockName;\n     protected boolean serializable;\n     protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n-    protected GenericMetadataSupport mockitoGenericMetadata;\n     protected boolean stubOnly;\n \n     public CreationSettings() {}\n         this.mockName = copy.mockName;\n         this.serializable = copy.serializable;\n         this.invocationListeners = copy.invocationListeners;\n-        this.mockitoGenericMetadata = copy.mockitoGenericMetadata;\n         this.stubOnly = copy.stubOnly;\n     }\n \n         return invocationListeners;\n     }\n \n-    public GenericMetadataSupport getMockitoGenericMetadata() {\n-        if (mockitoGenericMetadata == null) {\n-            this.mockitoGenericMetadata = GenericMetadataSupport.inferFrom(typeToMock);\n-        }\n-        return mockitoGenericMetadata;\n-    }\n-\n-    public void setMockitoGenericMetadata(GenericMetadataSupport mockitoGenericMetadata) {\n-        this.mockitoGenericMetadata = mockitoGenericMetadata;\n-    }\n-\n     public boolean isStubOnly() {\n         return stubOnly;\n     }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n+import org.mockito.MockSettings;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n \t\t}\n \n         // deep stub\n-        return recordDeepStubMock(returnTypeGenericMetadata.toMock(this), container);\n+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n+    }\n+\n+    /**\n+     * Creates a mock using the Generics Metadata.\n+     *\n+     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n+     * @return The mock\n+     */\n+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n+        return mock(\n+                returnTypeGenericMetadata.rawType(),\n+                withSettingsUsing(returnTypeGenericMetadata)\n+        );\n+    }\n+\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n+        MockSettings mockSettings =\n+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n+                : withSettings();\n+\n+        return mockSettings\n+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n+    }\n+\n+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n+        return new ReturnsDeepStubs() {\n+            @Override\n+            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n+                return returnTypeGenericMetadata;\n+            }\n+        };\n     }\n \n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n         return mock;\n     }\n \n-    private GenericMetadataSupport actualParameterizedType(Object mock) {\n+    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n-        return mockSettings.getMockitoGenericMetadata();\n+        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n \n \n import org.mockito.Incubating;\n-import org.mockito.MockSettings;\n-import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.Checks;\n import org.mockito.stubbing.Answer;\n \n import java.lang.reflect.*;\n import java.util.*;\n-\n-import static org.mockito.Mockito.withSettings;\n \n \n /**\n \n \n     /**\n-     * @return Returns extra interfaces if relevant, otherwise empty List.\n+     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n      */\n     public List<Type> extraInterfaces() {\n         return Collections.emptyList();\n+    }\n+\n+    /**\n+     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n+     */\n+    public Class<?>[] rawExtraInterfaces() {\n+        return new Class[0];\n     }\n \n \n         return type;\n     }\n \n-\n-\n-    /**\n-     * Creates a mock using the Generics Metadata represented by this instance.\n-     *\n-     * @param answer The answer to use in mock settings.\n-     * @return The mock or null if not mockable.\n-     */\n-    public Object toMock(Answer answer) {\n-        return createMock(rawType(), ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this));\n-    }\n-\n-    private Object createMock(Class<?> rawType, MockSettings mockSettings) {\n-        return Mockito.mock(rawType, mockSettings);\n-    }\n \n \n     /**\n             throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n         }\n \n-        private Class<?>[] rawExtraInterfaces() {\n+        /**\n+         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n+         * @see #extractRawTypeOf(java.lang.reflect.Type)\n+         */\n+        public Class<?>[] rawExtraInterfaces() {\n             List<Type> extraInterfaces = extraInterfaces();\n             List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n             for (Type extraInterface : extraInterfaces) {\n                 }\n                 return actualFirstBound;\n             }\n-            return type; // irrelevant, we don't manage other types.\n-        }\n-\n-        public Object toMock(Answer answer) {\n-            Class<?>[] rawExtraInterfaces = rawExtraInterfaces();\n-            if (rawExtraInterfaces.length <= 0) {\n-                return super.toMock(answer);\n-            }\n-\n-            return super.createMock(\n-                    rawType(),\n-                    ((MockSettingsImpl) withSettings()\n-                            .defaultAnswer(answer)\n-                            .extraInterfaces(rawExtraInterfaces))\n-                            .parameterizedInfo(this)\n-            );\n+            return type; // irrelevant, we don't manage other types as they are not bounded.\n         }\n     }\n \n--- a/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n package org.mockito.internal.util.reflection;\n \n import org.junit.Test;\n-import org.mockito.exceptions.base.MockitoException;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n \n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.RETURNS_DEFAULTS;\n import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;\n \n @SuppressWarnings(\"unused\")\n \n \n \n-\n-    @Test(expected = MockitoException.class)\n-    public void toMock_propagate_MockitoException_if_type_unmockable() throws Exception {\n-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n-\n-        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n-\n-        inferFrom(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);\n-    }\n-\n-    @Test\n-    public void toMock_returns_mock_of_correct_type() throws Exception {\n-        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n-\n-        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Comparable.class);\n-        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Cloneable.class);\n-    }\n-\n-\n     private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {\n         for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {\n             if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {", "timestamp": 1351194479, "metainfo": ""}