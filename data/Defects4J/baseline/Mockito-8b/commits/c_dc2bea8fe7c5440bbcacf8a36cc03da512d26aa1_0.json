{"sha": "dc2bea8fe7c5440bbcacf8a36cc03da512d26aa1", "log": "Added wildcard support  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n+++ b/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n \n import org.mockito.Incubating;\n+import org.mockito.MockSettings;\n import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.Checks;\n-import org.mockito.internal.util.ConsoleMockitoLogger;\n-import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.stubbing.Answer;\n \n-import java.lang.reflect.Method;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.*;\n import java.util.*;\n \n import static org.mockito.Mockito.withSettings;\n \n+\n+/**\n+ *\n+ *\n+ *\n+ *\n+ *\n+ */\n @Incubating\n public abstract class MockitoGenericMetadata {\n \n-    public static MockitoLogger logger = new ConsoleMockitoLogger();\n+    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n     /**\n      * Represents actual type variables resolved for current class.\n \n \n     protected void registerTypeVariablesOn(Type classType) {\n-        if (!(classType instanceof ParameterizedType)) { // null protected\n+        if (!(classType instanceof ParameterizedType)) {\n             return;\n         }\n         ParameterizedType parameterizedType = (ParameterizedType) classType;\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n-            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n-            logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n+            if (actualTypeArgument instanceof WildcardType) {\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n+            } else {\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n+            }\n+            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n         for (TypeVariable typeParameter : typeParameters) {\n             contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n-            logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n-        }\n-    }\n-\n-    private Type boundsOf(TypeVariable typeParameter) {\n+            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    /**\n+     * @param typeParameter The TypeVariable parameter\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(TypeVariable typeParameter) {\n         if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n             return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n         }\n-        return new BoundedType(typeParameter);\n+        return new TypeVarBoundedType(typeParameter);\n+    }\n+\n+    /**\n+     * @param wildCard The WildCard type\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(WildcardType wildCard) {\n+        /*\n+         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n+         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n+         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n+         */\n+\n+        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n+        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n+        }\n+\n+        return wildCardBoundedType;\n     }\n \n \n             Type actualType = getActualTypeArgumentFor(typeParameter);\n \n             actualTypeArguments.put(typeParameter, actualType);\n-            logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n+            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n         }\n \n         return actualTypeArguments;\n      * Creates a mock using the Generics Metadata represented by this instance.\n      *\n      * @param answer The answer to use in mock settings.\n-     * @return The mock.\n+     * @return The mock or null if not mockable.\n      */\n     public Object toMock(Answer answer) {\n-        return Mockito.mock(\n-                rawType(),\n-                ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this)\n-        );\n-    }\n-\n+        return createMock(rawType(), ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this));\n+    }\n+\n+    private Object createMock(Class<?> rawType, MockSettings mockSettings) {\n+        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n+            return null;\n+        }\n+        return Mockito.mock(rawType, mockSettings);\n+    }\n \n \n     /**\n      */\n     public MockitoGenericMetadata resolveGenericReturnType(Method method) {\n         Type genericReturnType = method.getGenericReturnType();\n-        logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n+        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n \n         if (genericReturnType instanceof Class) {\n             return new NotGenericReturnType(genericReturnType);\n         if (genericReturnType instanceof TypeVariable) {\n             return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n         }\n-        if (genericReturnType instanceof BoundedType) {\n-            return new TypeVariableReturnType(this, method.getTypeParameters(), ((BoundedType) genericReturnType).typeVariable());\n-        }\n-\n-        throw new IllegalStateException(\"ouch\");\n+\n+        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n     }\n \n     /**\n \n         @Override\n         public Class<?> rawType() {\n-            // ParameterizedType#getRawType() always return a class !\n             return (Class<?>) parameterizedType.getRawType();\n         }\n     }\n             }\n             if (type instanceof TypeVariable) {\n                 /*\n-                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n-                on the class definition, such as such as List<E>.\n-                */\n+                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                 * on the class definition, such as such as List<E>.\n+                 */\n                 return extractRawTypeOf(contextualActualTypeParameters.get(type));\n             }\n             throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n                 return super.toMock(answer);\n             }\n \n-            return Mockito.mock(\n+            return super.createMock(\n                     rawType(),\n                     ((MockSettingsImpl) withSettings()\n                             .defaultAnswer(answer)\n         public Class<?> rawType() {\n             return returnType;\n         }\n+    }\n+\n+\n+\n+    /**\n+     * Type representing bounds of a type\n+     *\n+     * @see TypeVarBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     * @see WildCardBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n+     */\n+    public static interface BoundedType extends Type {\n+        Type firstBound();\n+\n+        Type[] interfaceBounds();\n     }\n \n     /**\n      *     // will return Comparable type\n      * </code></pre>\n      * </p>\n-     */\n-    public static class BoundedType implements Type {\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class TypeVarBoundedType implements BoundedType {\n         private TypeVariable typeVariable;\n \n \n-        public BoundedType(TypeVariable typeVariable) {\n+        public TypeVarBoundedType(TypeVariable typeVariable) {\n             this.typeVariable = typeVariable;\n         }\n \n         }\n \n         /**\n-         * On a Type Variable (typeVar extends AClass_0 & I_1 & I_2 & etc), will return an array\n+         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n          * containing I_1 and I_2.\n          *\n          * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n             if (this == o) return true;\n             if (o == null || getClass() != o.getClass()) return false;\n \n-            return typeVariable.equals(((BoundedType) o).typeVariable);\n+            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n \n         }\n \n             return typeVariable;\n         }\n     }\n+\n+    /**\n+     * Type representing bounds of a wildcard, allows to keep all bounds information.\n+     *\n+     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n+     * are not allowed.\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class WildCardBoundedType implements BoundedType {\n+        private WildcardType wildcard;\n+\n+\n+        public WildCardBoundedType(WildcardType wildcard) {\n+            this.wildcard = wildcard;\n+        }\n+\n+        /**\n+         * @return The first bound, either a type or a reference to a TypeVariable\n+         */\n+        public Type firstBound() {\n+            Type[] lowerBounds = wildcard.getLowerBounds();\n+            Type[] upperBounds = wildcard.getUpperBounds();\n+\n+            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n+        }\n+\n+        /**\n+         * @return An empty array as, wildcard don't support multiple bounds.\n+         */\n+        public Type[] interfaceBounds() {\n+            return new Type[0];\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return wildcard.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=[]}\");\n+            return sb.toString();\n+        }\n+\n+        public WildcardType wildCard() {\n+            return wildcard;\n+        }\n+    }\n+\n }\n \n \n--- a/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n+++ b/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.Serializable;\n \n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.RETURNS_DEFAULTS;\n import static org.mockito.internal.util.reflection.MockitoGenericMetadata.from;\n \n @SuppressWarnings(\"unused\")\n \n     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n         Set<Number> remove(Object key); // override with fixed ParameterizedType\n-        List<? super Integer> returningWildcard();\n+        List<? super Integer> returning_wildcard_with_class_lower_bound();\n+        List<? super K> returning_wildcard_with_typeVar_lower_bound();\n+        List<? extends K> returning_wildcard_with_typeVar_upper_bound();\n         K returningK();\n-        <O extends K> List<O> paramTypeWithTypeParams();\n-        <S, T extends S> T twoTypeParams();\n-        <O extends K> O typeVarWithTypeParams();\n+        <O extends K> List<O> paramType_with_type_params();\n+        <S, T extends S> T two_type_params();\n+        <O extends K> O typeVar_with_type_params();\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void typeVariable_return_type_of___get___resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+    public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n     }\n \n     @Test\n-    public void bounded_typeVariable_return_type_of___returningK___resolved_to_Comparable_and_with_BoundedType() throws Exception {\n+    public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n     }\n \n     @Test\n-    public void fixed_ParamType_return_type_of___remove___resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+    public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n     }\n \n     @Test\n-    public void paramType_return_type_of___values___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+    public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);\n     }\n \n     @Test\n-    public void paramType_with_type_parameters_return_type_of___paramTypeWithTypeParams___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n-        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramTypeWithTypeParams\", GenericsNest.class));\n-\n-        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n-        Type firstBoundOfE = ((MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n+    public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramType_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        Type firstBoundOfE = ((MockitoGenericMetadata.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n         assertThat(from(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n     }\n \n     @Test\n-    public void typeVariable_with_type_parameters_return_type_of___typeVarWithTypeParams___resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n-        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVarWithTypeParams\", GenericsNest.class));\n+    public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVar_with_type_params\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n         MockitoGenericMetadata extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n     }\n \n     @Test\n-    public void class_return_type_of___append___resolved_to_StringBuilder_and_type_arguments() throws Exception {\n+    public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n         assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n     }\n \n-    @Test\n-    @Ignore(\"TODO WildCard\")\n-    public void paramType_with_wildcard_return_type_of___returningWildcard___resolved_to_List_and_type_argument_to_Integer() throws Exception {\n-        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningWildcard\", GenericsNest.class));\n-\n-        fail(\"TODO\");\n+\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        MockitoGenericMetadata.BoundedType boundedType = (MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+        assertThat(boundedType.firstBound()).isEqualTo(Integer.class);\n+        assertThat(boundedType.interfaceBounds()).isEmpty();\n+    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        MockitoGenericMetadata.BoundedType boundedType = (MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_upper_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        MockitoGenericMetadata.BoundedType boundedType = (MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);\n+    }\n+\n+\n+\n+\n+    @Test\n+    public void toMock_returns_null_if_type_unmockable() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        MockitoGenericMetadata.BoundedType boundedType = (MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS)).isNull();\n+    }\n+\n+    @Test\n+    public void toMock_returns_mock_of_correct_type() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Comparable.class);\n+        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Cloneable.class);\n     }\n \n ", "timestamp": 1343830285, "metainfo": ""}