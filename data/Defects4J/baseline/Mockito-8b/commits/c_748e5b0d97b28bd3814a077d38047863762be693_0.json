{"sha": "748e5b0d97b28bd3814a077d38047863762be693", "log": "calculator is now analyzer  --HG-- rename : src/org/mockito/internal/invocation/InvocationsCalculator.java => src/org/mockito/internal/invocation/InvocationsAnalyzer.java rename : test/org/mockito/internal/invocation/InvocationsCalculatorTest.java => test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40213", "commit": "\n--- a/src/org/mockito/exceptions/verification/VerificationError.java\n+++ b/src/org/mockito/exceptions/verification/VerificationError.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n \n-//TODO create specific NoInteractionsWantedError?\n+/**\n+ * Verification failed\n+ */\n public class VerificationError extends MockitoAssertionError {\n \n     private static final long serialVersionUID = 1L;\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.progress.VerificationMode;\n+\n+/**\n+ * Provides handful of methods to search and count invocations\n+ */\n+public class InvocationsAnalyzer {\n+\n+    public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n+        int actual = 0;\n+        for (Invocation registeredInvocation : invocations) {\n+            if (wanted.matches(registeredInvocation)) {\n+                actual++;\n+            }\n+        }\n+\n+        return actual;\n+    }\n+\n+    //TODO start all with find\n+    public Invocation findActualInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n+        Invocation actualbyName = null;\n+        for (Invocation registered : invocations) {\n+            String wantedMethodName = wanted.getMethod().getName();\n+            String registeredInvocationName = registered.getMethod().getName();\n+            if (wantedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n+                actualbyName = registered;\n+            }\n+        }\n+        \n+        return actualbyName != null ? actualbyName : getFirstUnverified(invocations);\n+    }\n+    \n+    public Invocation getFirstUnverified(List<Invocation> invocations) {\n+        for (Invocation i : invocations) {\n+            if (!i.isVerified()) {\n+                return i;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    public HasStackTrace getLastInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n+        Invocation lastMatching = null;\n+        for (Invocation registered : invocations) {\n+            if (wanted.matches(registered)) {\n+                lastMatching = registered;\n+            }\n+        }\n+        return lastMatching != null ? lastMatching.getStackTrace() : null;\n+    }\n+\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        int counter = 0;\n+        for (Invocation registered : invocations) {\n+            if (wanted.matches(registered)) {\n+                counter++;\n+                if (counter > mode.wantedCount()) {\n+                    return registered.getStackTrace();\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"There are no undesired invocations!\");\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.invocation.InvocationsPrinter;\n import org.mockito.internal.progress.VerificationMode;\n \n public class MissingInvocationVerifier implements Verifier {\n     \n     private final Reporter reporter;\n-    private final InvocationsCalculator calculator;\n+    private final InvocationsAnalyzer analyzer;\n     \n     public MissingInvocationVerifier() {\n-        this(new InvocationsCalculator(), new Reporter());\n+        this(new InvocationsAnalyzer(), new Reporter());\n     }\n     \n-    public MissingInvocationVerifier(InvocationsCalculator calculator, Reporter reporter) {\n-        this.calculator = calculator;\n+    public MissingInvocationVerifier(InvocationsAnalyzer analyzer, Reporter reporter) {\n+        this.analyzer = analyzer;\n         this.reporter = reporter;\n     }\n \n             return;\n         }\n         \n-        int actualCount = calculator.countActual(invocations, wanted);\n+        int actualCount = analyzer.countActual(invocations, wanted);\n         if (actualCount == 0) {\n             reportMissingInvocationError(invocations, wanted);\n         }\n     }\n     \n     private void reportMissingInvocationError(List<Invocation> invocations, InvocationMatcher wanted) {\n-        Invocation actual = calculator.findActualInvocation(invocations, wanted);\n+        Invocation actual = analyzer.findActualInvocation(invocations, wanted);\n         \n         if (actual != null) {\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n--- a/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationMode;\n \n public class NoMoreInvocationsVerifier implements Verifier {\n \n     private final Reporter reporter;\n-    private final InvocationsCalculator calculator;\n+    private final InvocationsAnalyzer analyzer;\n \n     public NoMoreInvocationsVerifier() {\n-        this(new InvocationsCalculator(), new Reporter());\n+        this(new InvocationsAnalyzer(), new Reporter());\n     }\n     \n-    public NoMoreInvocationsVerifier(InvocationsCalculator calculator, Reporter reporter) {\n-        this.calculator = calculator;\n+    public NoMoreInvocationsVerifier(InvocationsAnalyzer analyzer, Reporter reporter) {\n+        this.analyzer = analyzer;\n         this.reporter = reporter;\n     }\n \n             return;\n         }\n \n-        Invocation unverified = calculator.getFirstUnverified(invocations);\n+        Invocation unverified = analyzer.getFirstUnverified(invocations);\n         if (unverified != null) {\n             reporter.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationMode;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n     \n     private final Reporter reporter;\n-    private final InvocationsCalculator calculator;\n+    private final InvocationsAnalyzer analyzer;\n \n     public NumberOfInvocationsVerifier() {\n-        this(new Reporter(), new InvocationsCalculator());\n+        this(new Reporter(), new InvocationsAnalyzer());\n     }\n     \n-    NumberOfInvocationsVerifier(Reporter reporter, InvocationsCalculator calculator) {\n+    NumberOfInvocationsVerifier(Reporter reporter, InvocationsAnalyzer analyzer) {\n         this.reporter = reporter;\n-        this.calculator = calculator;\n+        this.analyzer = analyzer;\n     }\n     \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n             return;\n         }\n         \n-        int actualCount = calculator.countActual(invocations, wanted);\n+        int actualCount = analyzer.countActual(invocations, wanted);\n         int wantedCount = mode.wantedCount();\n         \n         if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocation = calculator.getLastInvocationStackTrace(invocations, wanted);\n+            HasStackTrace lastInvocation = analyzer.getLastInvocationStackTrace(invocations, wanted);\n             reporter.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n-            HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(invocations, wanted, mode);\n+            HasStackTrace firstUndesired = analyzer.getFirstUndesiredInvocationStackTrace(invocations, wanted, mode);\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.progress.VerificationMode;\n+\n+public class InvocationsAnalyzerTest extends RequiresValidState {\n+    \n+    private List<Invocation> invocations = new LinkedList<Invocation>();\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+    private InvocationsAnalyzer analyzer;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n+        invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n+        analyzer = new InvocationsAnalyzer();\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUnverifiedInvocation() throws Exception {\n+        assertSame(simpleMethodInvocation, analyzer.getFirstUnverified(invocations));\n+        \n+        simpleMethodInvocationTwo.markVerified();\n+        simpleMethodInvocation.markVerified();\n+        \n+        assertSame(differentMethodInvocation, analyzer.getFirstUnverified(invocations));\n+        \n+        differentMethodInvocation.markVerified();\n+        assertNull(analyzer.getFirstUnverified(invocations));\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n+        HasStackTrace firstUndesired = analyzer.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n+        HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n+        HasStackTrace firstUndesired = analyzer.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n+        HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n+        analyzer.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n+        analyzer.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n+    }\n+}\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationMode;\n \n public class MissingInvocationVerifierTest extends RequiresValidState {\n \n     private MissingInvocationVerifier verifier;\n-    private InvocationsCalculatorStub calculatorStub;\n+    private InvocationsAnalyzerStub analyzerStub;\n     private ReporterStub reporterStub;\n     \n     private InvocationMatcher wanted;\n \n     @Before\n     public void setup() {\n-        calculatorStub = new InvocationsCalculatorStub();\n+        analyzerStub = new InvocationsAnalyzerStub();\n         reporterStub = new ReporterStub();\n-        verifier = new MissingInvocationVerifier(calculatorStub, reporterStub);\n+        verifier = new MissingInvocationVerifier(analyzerStub, reporterStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n         invocations = asList(new InvocationBuilder().toInvocation());\n     }\n     \n     @Test\n-    public void shouldAskCalculatorForActualNumberOfInvocations() {\n-        calculatorStub.actualCountToReturn = 1;\n+    public void shouldAskAnalyzerForActualNumberOfInvocations() {\n+        analyzerStub.actualCountToReturn = 1;\n         verifier.verify(invocations, wanted, atLeastOnce());\n         \n-        assertSame(invocations, calculatorStub.invocations);\n-        assertSame(wanted, calculatorStub.wanted);\n+        assertSame(invocations, analyzerStub.invocations);\n+        assertSame(wanted, analyzerStub.wanted);\n     }\n     \n     @Test\n     public void shouldPassBecauseActualInvocationFound() {\n-        calculatorStub.actualCountToReturn = 1;\n+        analyzerStub.actualCountToReturn = 1;\n         verifier.verify(invocations, wanted, atLeastOnce());\n     }\n     \n     @Test\n-    public void shouldAskCalculatorForActualInvocationAndReportWantedButNotInvoked() {\n-        calculatorStub.actualCountToReturn = 0;\n-        calculatorStub.actualInvocationToReturn = null;\n+    public void shouldAskAnalyzerForActualInvocationAndReportWantedButNotInvoked() {\n+        analyzerStub.actualCountToReturn = 0;\n+        analyzerStub.actualInvocationToReturn = null;\n         verifier.verify(invocations, wanted, VerificationMode.atLeastOnce());\n         \n-        assertSame(invocations, calculatorStub.invocations);\n-        assertSame(wanted, calculatorStub.wanted);\n+        assertSame(invocations, analyzerStub.invocations);\n+        assertSame(wanted, analyzerStub.wanted);\n         \n         assertEquals(wanted.toString(), reporterStub.wanted);\n     }\n     \n     @Test\n     public void shouldReportWantedInvocationDiffersFromActual() {\n-        calculatorStub.actualCountToReturn = 0;\n+        analyzerStub.actualCountToReturn = 0;\n         Invocation actualInvocation = new InvocationBuilder().toInvocation();\n-        calculatorStub.actualInvocationToReturn = actualInvocation;\n+        analyzerStub.actualInvocationToReturn = actualInvocation;\n         verifier.verify(invocations, wanted, VerificationMode.atLeastOnce());\n         \n         assertEquals(wanted.toString(), reporterStub.wanted);\n         assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n     }\n     \n-    class InvocationsCalculatorStub extends InvocationsCalculator {\n+    class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private List<Invocation> invocations;\n         private InvocationMatcher wanted;\n         private int actualCountToReturn;\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationMode;\n \n public class NoMoreInvocationsVerifierTest extends RequiresValidState {\n \n     private NoMoreInvocationsVerifier verifier;\n-    private InvocationsCalculatorStub calculator;\n+    private InvocationsAnalyzerStub analyzer;\n     private ReporterStub reporterStub;\n \n     @Before\n     public void setup() {\n-        calculator = new InvocationsCalculatorStub();\n+        analyzer = new InvocationsAnalyzerStub();\n         reporterStub = new ReporterStub();\n-        verifier = new NoMoreInvocationsVerifier(calculator, reporterStub);\n+        verifier = new NoMoreInvocationsVerifier(analyzer, reporterStub);\n     }\n     \n     @Test\n     \n     @Test\n     public void shouldPassVerification() throws Exception {\n-        calculator.invocationToReturn = null;\n+        analyzer.invocationToReturn = null;\n         verifier.verify(null, null, VerificationMode.noMoreInteractions());\n     }\n     \n     @Test\n     public void shouldReportError() throws Exception {\n         Invocation firstUnverified = new InvocationBuilder().toInvocation();\n-        calculator.invocationToReturn = firstUnverified;\n+        analyzer.invocationToReturn = firstUnverified;\n         List<Invocation> invocations = asList(new InvocationBuilder().toInvocation());\n         \n         verifier.verify(invocations, null, VerificationMode.noMoreInteractions());\n         \n-        assertSame(invocations, calculator.invocations);\n+        assertSame(invocations, analyzer.invocations);\n         \n         assertEquals(firstUnverified.toString(), reporterStub.undesired);\n         assertSame(firstUnverified.getStackTrace(), reporterStub.actualInvocationStackTrace);\n     }\n     \n-    class InvocationsCalculatorStub extends InvocationsCalculator {\n+    class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private List<Invocation> invocations;\n         private Invocation invocationToReturn;\n         @Override public Invocation getFirstUnverified(List<Invocation> invocations) {\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationMode;\n \n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n \n     private NumberOfInvocationsVerifier verifier;\n-    private InvocationsCalculatorStub calculatorStub;\n+    private InvocationsAnalyzerStub analyzerStub;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n     private List<Invocation> invocations;\n     @Before\n     public void setup() {\n         reporterStub = new ReporterStub();\n-        calculatorStub = new InvocationsCalculatorStub();\n-        verifier = new NumberOfInvocationsVerifier(reporterStub, calculatorStub);\n+        analyzerStub = new InvocationsAnalyzerStub();\n+        verifier = new NumberOfInvocationsVerifier(reporterStub, analyzerStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n         invocations = asList(new InvocationBuilder().toInvocation());\n     @Test\n     public void shouldCountActualInvocations() throws Exception {\n         verifier.verify(invocations, wanted, times(4));\n-        assertSame(wanted, calculatorStub.wanted);\n+        assertSame(wanted, analyzerStub.wanted);\n     }\n     \n     @Test\n-    public void shouldAskCalculatorToCountActual() throws Exception {\n+    public void shouldAskAnalyzerToCountActual() throws Exception {\n         VerificationMode mode = times(1);\n-        calculatorStub.actualCountToReturn = 1;\n+        analyzerStub.actualCountToReturn = 1;\n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, calculatorStub.invocations);\n-        assertSame(wanted, calculatorStub.wanted);\n+        assertSame(invocations, analyzerStub.invocations);\n+        assertSame(wanted, analyzerStub.wanted);\n     }\n     \n     @Test\n     public void shouldReportTooLittleInvocations() throws Exception {\n         VerificationMode mode = times(10);\n-        calculatorStub.actualCountToReturn = 5;\n+        analyzerStub.actualCountToReturn = 5;\n         MockitoException lastInvocation = new MockitoException(\"\");\n-        calculatorStub.invocationTraceToReturn = lastInvocation;\n+        analyzerStub.invocationTraceToReturn = lastInvocation;\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, calculatorStub.invocations);\n-        assertSame(wanted, calculatorStub.wanted);\n+        assertSame(invocations, analyzerStub.invocations);\n+        assertSame(wanted, analyzerStub.wanted);\n         \n         assertEquals(5, reporterStub.actualCount);\n         assertEquals(10, reporterStub.wantedCount);\n     @Test\n     public void shouldReportTooManyInvocations() throws Exception {\n         VerificationMode mode = times(0);\n-        calculatorStub.actualCountToReturn = 5;\n+        analyzerStub.actualCountToReturn = 5;\n         MockitoException firstUndesiredInvocation = new MockitoException(\"\");\n-        calculatorStub.invocationTraceToReturn = firstUndesiredInvocation;\n+        analyzerStub.invocationTraceToReturn = firstUndesiredInvocation;\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertSame(invocations, calculatorStub.invocations);\n-        assertSame(wanted, calculatorStub.wanted);\n+        assertSame(invocations, analyzerStub.invocations);\n+        assertSame(wanted, analyzerStub.wanted);\n         \n-        assertSame(mode, calculatorStub.mode);\n+        assertSame(mode, analyzerStub.mode);\n         \n         assertEquals(5, reporterStub.actualCount);\n         assertEquals(0, reporterStub.wantedCount);\n         assertSame(firstUndesiredInvocation, reporterStub.stackTrace);\n     }\n     \n-    class InvocationsCalculatorStub extends InvocationsCalculator {\n+    class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private HasStackTrace invocationTraceToReturn;\n         private int actualCountToReturn;\n \n--- a/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n public class NoMoreInteractionsVerificationTest extends RequiresValidState {", "timestamp": 1197735206, "metainfo": ""}