{"sha": "af66e9e1c91d75cd6cf03181a67ea1a5fc41ceb4", "log": "added chained stubbing for void method  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40606", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n-import org.mockito.internal.stubbing.StubbedMethodSelector;\n+import org.mockito.internal.stubbing.DontThrow;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n     }\n     \n     private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n-        public StubbedMethodSelector<T> toThrow(Throwable throwable) {\n+        public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n             stubber.addThrowableForVoidMethod(throwable);\n-            return new StubbedMethodSelector<T>() {\n-                public T on() {\n-                    return mock;\n-                }\n-            };\n+            return this;\n+        }\n+        \n+        public VoidMethodStubbable<T> toReturn() {\n+            stubber.addThrowableForVoidMethod(DontThrow.DONT_THROW);\n+            return this;\n+        }\n+        \n+        public T on() {\n+            return mock;\n         }\n     }\n \n--- a/src/org/mockito/internal/stubbing/AnswerFactory.java\n+++ b/src/org/mockito/internal/stubbing/AnswerFactory.java\n     public static Answer createThrowingAnswer(final Throwable throwable, final StackTraceFilter filter) {\n         return new Answer<Object>() {\n             public Object answer() throws Throwable {\n+                if (throwable == DontThrow.DONT_THROW) {\n+                    return null;\n+                }\n                 Throwable filtered = throwable.fillInStackTrace();\n                 filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));\n                 throw filtered;\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/DontThrow.java\n+package org.mockito.internal.stubbing;\n+\n+public class DontThrow extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+    public static final DontThrow DONT_THROW = new DontThrow();\n+}\n--- a/src/org/mockito/internal/stubbing/StubbedMethodSelector.java\n+++ b/src/org/mockito/internal/stubbing/StubbedMethodSelector.java\n \n import org.mockito.Mockito;\n \n+//TODO remove me\n /**\n  * Chooses void method for stubbing with throwable. E.g:\n  * \n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n  */\n package org.mockito.internal.stubbing;\n \n+import java.util.ArrayList;\n import java.util.LinkedList;\n+import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.StackTraceFilter;\n     private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private final Reporter reporter = new Reporter();\n     private final MockingProgress mockingProgress;\n+    private final List<Throwable> throwablesForVoidMethod = new ArrayList<Throwable>();\n     \n     private InvocationMatcher invocationForStubbing;\n-    private Throwable throwableForVoidMethod;\n     \n     public Stubber(MockingProgress mockingProgress) {\n         this.mockingProgress = mockingProgress;\n     \n     public void addReturnValue(Object value) {\n         mockingProgress.stubbingCompleted();\n-        addResult(AnswerFactory.createReturningAnswer(value));\n+        Answer answer = AnswerFactory.createReturningAnswer(value);\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n     }\n     \n     public void addThrowable(Throwable throwable) {\n         mockingProgress.stubbingCompleted();\n         validateThrowable(throwable);\n-        addResult(AnswerFactory.createThrowingAnswer(throwable, new StackTraceFilter()));\n-    }\n-    \n-    private void addResult(Answer result) {\n-        assert invocationForStubbing != null;\n-        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, result));\n+        Answer answer = AnswerFactory.createThrowingAnswer(throwable, new StackTraceFilter());\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n     }\n     \n     public void addConsecutiveReturnValue(Object value) {\n     }\n \n     public void addThrowableForVoidMethod(Throwable throwable) {\n-        throwableForVoidMethod = throwable;\n+        throwablesForVoidMethod.add(throwable);\n     }\n \n     public boolean hasThrowableForVoidMethod() {\n-        return throwableForVoidMethod != null;\n+        return !throwablesForVoidMethod.isEmpty();\n     }\n     \n     public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {\n         invocationForStubbing = voidMethodInvocationMatcher;\n-        addThrowable(throwableForVoidMethod);\n-        throwableForVoidMethod = null;\n+        assert hasThrowableForVoidMethod();\n+        for (int i = 0; i < throwablesForVoidMethod.size(); i++) {\n+            Throwable throwable = throwablesForVoidMethod.get(i);\n+            if (i == 0) {\n+                addThrowable(throwable);\n+            } else {\n+                addConsecutiveThrowable(throwable);\n+            }\n+        }\n+        throwablesForVoidMethod.clear();\n     }\n     \n     private void validateThrowable(Throwable throwable) {\n--- a/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n  * \n  * See examples in javadoc for {@link Mockito#stubVoid}\n  */\n-public interface VoidMethodStubbable<T> {\n+public interface VoidMethodStubbable<T> extends StubbedMethodSelector<T>{\n \n     /**\n      * Stubs void method with an exception. E.g:\n      * \n      * @return method selector - to choose void method and finish stubbing \n      */\n-    StubbedMethodSelector<T> toThrow(Throwable throwable);\n+    VoidMethodStubbable<T> toThrow(Throwable throwable);\n+    \n+    /**\n+     * Stubs void method to 'just return' (e.g. to <b>not</b> throw any exception)\n+     * <p>\n+     * <b>Only</b> use this method if you're chaining multiple return values.\n+     * <p>\n+     * For example:\n+     * <pre>\n+     * stubVoid(mock)\n+     *   .toReturn()\n+     *   .toThrow(new RuntimeException())\n+     *   .on().foo(10);\n+     * </pre>\n+     * <ol> \n+     * <li>first time foo(10) is called the mock will 'just return' (e.g. don't throw any exception)</li>\n+     * <li>second time foo(10) is called the mock will throw RuntimeException</li>\n+     * <li>every next time foo(10) is called the mock will throw RuntimeException</li>\n+     * </ol> \n+     * \n+     * See examples in javadoc for {@link Mockito#stubVoid}\n+     * \n+     * @param throwable\n+     *            to be thrown on method invocation\n+     * \n+     * @return method selector - to choose void method and finish stubbing \n+     */\n+    VoidMethodStubbable<T> toReturn();\n \n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     String toString();\n     \n     String toString(String foo);\n+\n+    void voidMethod();\n }\n--- a/test/org/mockitousage/stubbing/StubbingConsecutiveReturnValuesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingConsecutiveReturnValuesTest.java\n     }\n     \n     @Test\n-    public void shouldAllowConsecutiveStubbingForVoidMethod() throws Exception {\n-        //TODO implement me!\n-//        stubVoid(mock)\n-//            .toThrow(new IllegalArgumentException())\n-//            .toReturn()\n-//            .toThrow(new NullPointerException())\n-//            .toReturn();\n-//        \n-//        try {\n-//            mock.simpleMethod();\n-//            fail();\n-//        } catch (IllegalArgumentException e) {}\n+    public void shouldStubVoidMethodAndContinueThrowing() throws Exception {\n+        stubVoid(mock)\n+            .toThrow(new IllegalArgumentException())\n+            .toReturn()\n+            .toThrow(new NullPointerException())\n+            .on().voidMethod();\n+        \n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (IllegalArgumentException e) {}\n+        \n+        mock.voidMethod();\n+        \n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (NullPointerException e) {}\n+        \n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (NullPointerException e) {}        \n+    }\n+    \n+    @Test\n+    public void shouldStubVoidMethod() throws Exception {\n+        stubVoid(mock)\n+            .toReturn()\n+            .toThrow(new NullPointerException())\n+            .toReturn()\n+            .on().voidMethod();\n+        \n+        mock.voidMethod();\n+        \n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (NullPointerException e) {}\n+        \n+        mock.voidMethod();\n+        mock.voidMethod();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldValidateConsecutiveExceptionForVoidMethod() throws Exception {\n+        stubVoid(mock)\n+            .toReturn()\n+            .toThrow(new Exception())\n+            .on().voidMethod();\n     }\n }", "timestamp": 1209336632, "metainfo": ""}