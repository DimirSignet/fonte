{"sha": "7342c3c8a7f72ae21dbc683053aefc8d026554b2", "log": "revamp fields manipulation in testng integration to avoid code duplication  --HG-- branch : issue 304 : TestNG integration", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.internal.util.Checks;\n+import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.ListUtil.Filter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Small fluent reflection tools to work with fields\n+ */\n+public abstract class Fields {\n+\n+\n+    public static InstanceFields allFieldsInHierarchy(Object instance) {\n+        List<InstanceField> instanceFields = new ArrayList<InstanceField>();\n+        for (Class<?> clazz = instance.getClass(); clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            instanceFields.addAll(instanceFieldsIn(instance, clazz));\n+        }\n+        return new InstanceFields(instance, instanceFields);\n+    }\n+\n+    public static Filter<InstanceField> notAnnotatedBy(final Class<? extends Annotation>... annotations) {\n+        return new Filter<InstanceField>() {\n+            public boolean isOut(InstanceField instanceField) {\n+                Checks.checkNotNull(annotations, \"Provide at least one annotation class\");\n+\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if(instanceField.isAnnotatedBy(annotation)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+    }\n+\n+    private static Filter<InstanceField> nullField() {\n+        return new Filter<InstanceField>() {\n+            public boolean isOut(InstanceField instanceField) {\n+                return instanceField.isNotNull();\n+            }\n+        };\n+    }\n+\n+    private static List<InstanceField> instanceFieldsIn(Object instance, Class<?> clazz) {\n+        List<InstanceField> instanceDeclaredFields = new ArrayList<InstanceField>();\n+        Field[] declaredFields = clazz.getDeclaredFields();\n+        for (Field declaredField : declaredFields) {\n+            InstanceField instanceField = new InstanceField(declaredField, instance);\n+            instanceDeclaredFields.add(instanceField);\n+        }\n+        return instanceDeclaredFields;\n+    }\n+    public static class InstanceFields {\n+        private final Object instance;\n+\n+        private final List<InstanceField> instanceFields;\n+\n+        public InstanceFields(Object instance, List<InstanceField> instanceFields) {\n+            this.instance = instance;\n+            this.instanceFields = instanceFields;\n+        }\n+\n+        // TODO get Filter out of ListFilter\n+        public InstanceFields filter(Filter<InstanceField> withFilter) {\n+            return new InstanceFields(instance, ListUtil.filter(instanceFields, withFilter));\n+        }\n+\n+        public InstanceFields notNull() {\n+            return filter(nullField());\n+        }\n+\n+        public List<InstanceField> instanceFields() {\n+            return new ArrayList<InstanceField>(instanceFields);\n+        }\n+\n+        public List<Object> assignedValues() {\n+            List<Object> values = new ArrayList<Object>(instanceFields.size());\n+            for (InstanceField instanceField : instanceFields) {\n+                values.add(instanceField.read());\n+            }\n+            return values;\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/InstanceField.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+/**\n+*\n+*/\n+public class InstanceField {\n+    private final Field field;\n+    private final Object instance;\n+    private FieldReader fieldReader;\n+\n+    public InstanceField(Field field, Object instance) {\n+        this.field = field;\n+        this.instance = instance;\n+    }\n+\n+    public Object read() {\n+        return reader().read();\n+    }\n+\n+    public void set(Object value) {\n+        new FieldSetter(instance, field).set(value);\n+    }\n+\n+    public boolean isNotNull() {\n+        return reader().isNull();\n+    }\n+\n+    public boolean isAnnotatedBy(Class<? extends Annotation> annotation) {\n+        return field.isAnnotationPresent(annotation);\n+    }\n+\n+    public <A extends Annotation> A annotation(Class<A> annotationClass) {\n+        return field.getAnnotation(annotationClass);\n+    }\n+\n+    public Field jdkField() {\n+        return field;\n+    }\n+\n+    private FieldReader reader() {\n+        if (fieldReader == null) {\n+            fieldReader = new FieldReader(instance, field);\n+        }\n+        return fieldReader;\n+    }\n+}\n--- a/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n \n import org.mockito.Mock;\n import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n import org.mockito.Spy;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.Fields;\n import org.testng.IInvokedMethod;\n import org.testng.ITestResult;\n \n import java.lang.reflect.Field;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.Set;\n+\n+import static org.mockito.internal.util.reflection.Fields.notAnnotatedBy;\n \n public class MockitoAfterTestNGMethod {\n \n         Mockito.reset(instanceMocksOf(instance).toArray());\n     }\n \n-    private Set<Object> instanceMocksOf(Object instance) {\n-        Class<?> testClass = instance.getClass();\n-        Set<Object> instanceMocks = new HashSet<Object>();\n-\n-        for (Class<?> clazz = testClass; clazz != Object.class; clazz = clazz.getSuperclass()) {\n-            instanceMocks.addAll(instanceMocksIn(instance, clazz));\n-        }\n-        return instanceMocks;\n+    private Collection<Object> instanceMocksOf(Object instance) {\n+        return Fields.allFieldsInHierarchy(instance)\n+                                            .filter(notAnnotatedBy(Mock.class,\n+                                                                   Spy.class,\n+                                                                   MockitoAnnotations.Mock.class))\n+                                            .notNull()\n+                                            .assignedValues();\n     }\n \n     private Set<Object> instanceMocksIn(Object instance, Class<?> clazz) {\n--- a/subprojects/testng/src/test/java/org/mockitousage/testng/MockFieldsShouldBeResetBetweenTestMethodsTest.java\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/MockFieldsShouldBeResetBetweenTestMethodsTest.java\n \n import java.util.HashMap;\n import java.util.List;\n+import java.util.Observable;\n \n import static org.fest.assertions.Assertions.assertThat;\n import static org.mockito.BDDMockito.given;\n     @Mock List<String> list;\n     @Spy HashMap hashMap;\n     @InjectMocks SomeType someType;\n+\n+    @Mock Observable will_be_nulled;\n \n     @Test\n     public void behaviour_A_without_infection_from_behaviour_B() throws Exception {\n \n         list.add(\"something else after B\");\n     }\n+\n+    @Test\n+    public void dont_fail_when_reseting_null_field() throws Exception {\n+        will_be_nulled = null;\n+    }\n }", "timestamp": 1331516518, "metainfo": ""}