{"sha": "55935429c669828f8136182ddeca0191305c2421", "log": "Refactored stuff / rename job  --HG-- rename : src/org/mockito/internal/matchers/CanDescribeVerbosely.java => src/org/mockito/internal/matchers/ContainsExtraTypeInformation.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401482", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/ContainsExtraTypeInformation.java\n+package org.mockito.internal.matchers;\n+\n+import org.hamcrest.SelfDescribing;\n+\n+public interface ContainsExtraTypeInformation {\n+    SelfDescribing withExtraTypeInfo();\n+\n+    boolean typeMatches(Object object);\n+}\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n import org.hamcrest.SelfDescribing;\n import org.mockito.ArgumentMatcher;\n \n-public class Equals extends ArgumentMatcher<Object> implements CanDescribeVerbosely {\n+public class Equals extends ArgumentMatcher<Object> implements ContainsExtraTypeInformation {\n \n     private final Object wanted;\n \n         throw new UnsupportedOperationException(\"hashCode() is not supported\");\n     }\n \n-    public SelfDescribing getSelfDescribingVerbosely() {\n+    public SelfDescribing withExtraTypeInfo() {\n         return new SelfDescribing() {\n             public void describeTo(Description description) {\n                 description.appendText(describe(\"(\"+ wanted.getClass().getSimpleName() +\") \" + wanted));\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class LocalizedMatcher implements Matcher, CanDescribeVerbosely {\n+public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation {\n \n     private final Matcher actualMatcher;\n     private Location location;\n         return \"Localized: \" + this.actualMatcher;\n     }\n \n-    public SelfDescribing getSelfDescribingVerbosely() {\n-        if (actualMatcher instanceof CanDescribeVerbosely) {\n-            return ((CanDescribeVerbosely) actualMatcher).getSelfDescribingVerbosely();\n+    public SelfDescribing withExtraTypeInfo() {\n+        if (actualMatcher instanceof ContainsExtraTypeInformation) {\n+            return ((ContainsExtraTypeInformation) actualMatcher).withExtraTypeInfo();\n         } else {\n             return this;\n         }\n     }\n \n     public boolean typeMatches(Object object) {\n-        if (actualMatcher instanceof CanDescribeVerbosely) {\n-            return ((CanDescribeVerbosely) actualMatcher).typeMatches(object);\n+        if (actualMatcher instanceof ContainsExtraTypeInformation) {\n+            return ((ContainsExtraTypeInformation) actualMatcher).typeMatches(object);\n         } else {\n             return false;\n         }\n--- a/src/org/mockito/internal/matchers/MatchersPrinter.java\n+++ b/src/org/mockito/internal/matchers/MatchersPrinter.java\n         List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing>();\n         int i = 0;\n         for (final Matcher matcher : matchers) {\n-            if (matcher instanceof CanDescribeVerbosely && printSettings.printsVerbosely(i)) {\n-                withPrintSettings.add(((CanDescribeVerbosely) matcher).getSelfDescribingVerbosely());\n+            if (matcher instanceof ContainsExtraTypeInformation && printSettings.extraTypeInfoFor(i)) {\n+                withPrintSettings.add(((ContainsExtraTypeInformation) matcher).withExtraTypeInfo());\n             } else {\n                 withPrintSettings.add(matcher);\n             }\n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n public class PrintSettings {\n \n     private boolean multiline;\n-    private List<Integer> verboseMatchers = new LinkedList<Integer>();\n+    private List<Integer> withTypeInfo = new LinkedList<Integer>();\n \n     public void setMultiline(boolean multiline) {\n         this.multiline = multiline;\n         return multiline;\n     }\n \n-    public static PrintSettings verboseMatchers(Integer ... verboselyPrinted) {\n+    public static PrintSettings verboseMatchers(Integer ... indexesOfMatchers) {\n         PrintSettings settings = new PrintSettings();\n-        settings.setMatchersToBePrintedVerbosely(verboselyPrinted);\n+        settings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchers);\n         return settings;\n     }\n \n-    public boolean printsVerbosely(int argumentIndex) {\n-        return verboseMatchers.contains(argumentIndex);\n+    public boolean extraTypeInfoFor(int argumentIndex) {\n+        return withTypeInfo.contains(argumentIndex);\n     }\n \n-    public void setMatchersToBePrintedVerbosely(Integer[] toBePrintedVerbosely) {\n-        this.verboseMatchers = Arrays.asList(toBePrintedVerbosely);\n+    public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {\n+        this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n     }\n }\n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n     private final String wanted;\n     private final String actual;\n \n-    public SmartPrinter(PrintingFriendlyInvocation wanted, PrintingFriendlyInvocation actual, Integer ... toBePrintedVerbosely) {\n+    public SmartPrinter(PrintingFriendlyInvocation wanted, PrintingFriendlyInvocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n         PrintSettings printSettings = new PrintSettings();\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n-        printSettings.setMatchersToBePrintedVerbosely(toBePrintedVerbosely);\n+        printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n         \n         this.wanted = wanted.toString(printSettings);\n         this.actual = actual.toString(printSettings);\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n \n import org.hamcrest.Matcher;\n import org.hamcrest.StringDescription;\n-import org.mockito.internal.matchers.CanDescribeVerbosely;\n+import org.mockito.internal.matchers.ContainsExtraTypeInformation;\n \n @SuppressWarnings(\"unchecked\")\n public class ArgumentMatchingTool {\n         List<Integer> suspicious = new LinkedList<Integer>();\n         int i = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CanDescribeVerbosely \n+            if (m instanceof ContainsExtraTypeInformation \n                     && !safelyMatches(m, arguments[i]) \n                     && toStringEquals(m, arguments[i])\n-                    && !((CanDescribeVerbosely) m).typeMatches(arguments[i])) {\n+                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                 suspicious.add(i);\n             }\n             i++;\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n             Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n             if (similar != null) {\n                 ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n-                Integer[] toBePrintedVerbosely = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n-                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, toBePrintedVerbosely);\n+                Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n+                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\n                 reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n             } else {\n                 reporter.wantedButNotInvoked(wanted, invocations);\n--- a/test/org/mockito/internal/matchers/EqualsTest.java\n+++ b/test/org/mockito/internal/matchers/EqualsTest.java\n     }\n     \n     @Test\n-    public void shouldGiveVerboselyDescribedVersionOfInt() throws Exception {\n-        String descStr = describe(new Equals(100).getSelfDescribingVerbosely());\n+    public void shouldDescribeWithExtraTypeInfo() throws Exception {\n+        String descStr = describe(new Equals(100).withExtraTypeInfo());\n         \n         assertEquals(\"(Integer) 100\", descStr);\n     }\n \n     @Test\n-    public void shouldGiveVerboselyDescribedVersionOfLong() throws Exception {\n-        String descStr = describe(new Equals(100L).getSelfDescribingVerbosely());\n+    public void shouldDescribeWithExtraTypeInfoOfLong() throws Exception {\n+        String descStr = describe(new Equals(100L).withExtraTypeInfo());\n         \n         assertEquals(\"(Long) 100\", descStr);\n     }\n     @Test\n     public void shouldMatchTypes() throws Exception {\n         //when\n-        CanDescribeVerbosely equals = new Equals(10);\n+        ContainsExtraTypeInformation equals = new Equals(10);\n         \n         //then\n         //TODO: null checks\n--- /dev/null\n+++ b/test/org/mockito/internal/matchers/LocalizedMatcherTest.java\n+package org.mockito.internal.matchers;\n+\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class LocalizedMatcherTest extends TestBase {\n+    \n+    @Test\n+    public void shouldMatchTypesWhenActualMatcherHasCorrectType() throws Exception {\n+        //when\n+        ContainsExtraTypeInformation equals10 = new Equals(10);\n+        LocalizedMatcher m = new LocalizedMatcher((Matcher) equals10);\n+        \n+        //then\n+        assertTrue(m.typeMatches(10));\n+        assertFalse(m.typeMatches(10L));\n+    }\n+\n+    @Test\n+    public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType() throws Exception {\n+        //when\n+        LocalizedMatcher m = new LocalizedMatcher(Any.ANY);\n+        \n+        //then\n+        assertFalse(m.typeMatches(10));\n+    }\n+    \n+    @Test\n+    public void shouldGetSelfDescribingVerboselyTypesWhenActualMatcherHasCorrectType() throws Exception {\n+        //when\n+        ContainsExtraTypeInformation equals10 = new Equals(10);\n+        LocalizedMatcher m = new LocalizedMatcher((Matcher) equals10);\n+        \n+        //then\n+        assertTrue(m.typeMatches(10));\n+        assertFalse(m.typeMatches(10L));\n+    }\n+}\n--- a/test/org/mockito/internal/matchers/MatchersPrinterTest.java\n+++ b/test/org/mockito/internal/matchers/MatchersPrinterTest.java\n     }\n \n     @Test\n-    public void shouldPrintVerboselyOnlyMarkedMatchers() {\n+    public void shouldDescribeTypeInfoOnlyMarkedMatchers() {\n         //when\n         String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(1));\n         //then", "timestamp": 1244408691, "metainfo": ""}