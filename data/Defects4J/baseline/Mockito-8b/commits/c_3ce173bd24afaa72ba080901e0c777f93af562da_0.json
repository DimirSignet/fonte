{"sha": "3ce173bd24afaa72ba080901e0c777f93af562da", "log": "Fixes a few javadoc warnings", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n  *\n  * <p>\n  *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},\n- *     if the mock settings is set to be serializable it will add the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable} interface.\n- *     This interface defines a the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n+ *     if the mock settings is set to be serializable it will add the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable}\n+ *     interface.\n+ *     This interface defines a the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n  *     whose signature match the one that is looked by the standard Java serialization.\n  * </p>\n  *\n      * </code></pre>\n      *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and\n      *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.\n-     *         At this point, the code will return an {@link AcrossJVMMockSerializationProxy}.</p>\n+     *         At this point, the code will return an\n+     *         {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy}.</p>\n      *     </li>\n      *     <li>\n-     *         <p>Now, in the constructor {@link AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n-     *         the mock is being serialized in a custom way (using {@link MockitoMockObjectOutputStream}) to a\n+     *         <p>Now, in the constructor\n+     *         {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n+     *         the mock is being serialized in a custom way (using\n+     *         {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream}) to a\n      *         byte array. So basically it means the code is performing double nested serialization of the passed\n      *         <code>mockitoMock</code>.</p>\n      *\n      * This is the serialization proxy that will encapsulate the real mock data as a byte array.\n      *\n      * <p>When called in the constructor it will serialize the mock in a byte array using a\n-     * custom {@link MockitoMockObjectOutputStream} that will annotate the mock class in the stream.\n-     * other information are used in this class in order to facilitate deserialization.\n+     * custom {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream} that\n+     * will annotate the mock class in the stream.\n+     * Other information are used in this class in order to facilitate deserialization.\n      * </p>\n      *\n      * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via\n         /**\n          * Creates the wrapper that be used in the serialization stream.\n          *\n-         * <p>Immediately serializes the Mockito mock using specifically crafted {@link MockitoMockObjectOutputStream},\n+         * <p>Immediately serializes the Mockito mock using specifically crafted\n+         * {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream},\n          * in a byte array.</p>\n          *\n          * @param mockitoMock The Mockito mock to serialize.\n      *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream\n      *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it\n      *     delegates class resolution to the default super behavior.\n-     *     The mirror method used for serializing the mock is {@link MockitoMockObjectOutputStream#annotateClass(Class)}.\n+     *     The mirror method used for serializing the mock is\n+     *     {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream#annotateClass(Class)}.\n      * </p>\n      *\n      * <p>", "timestamp": 1406228744, "metainfo": ""}