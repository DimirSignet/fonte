{"sha": "5d2689c04334f867afa0e5aef19101909d945085", "log": "new object: InvocationsPrinter that makes sure we cover special cases when invocation matches but toString() gives the same result  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40171", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         return arguments;\n     }\n \n-    public boolean equals(Object o) {\n-        if (o == null || !o.getClass().equals(this.getClass()))\n-            return false;\n-\n-        Invocation other = (Invocation) o;\n-\n-        return this.mock.equals(other.mock) && this.method.equals(other.method)\n-                && this.equalArguments(other.arguments);\n-    }\n-\n-    public int hashCode() {\n-        throw new RuntimeException(\"hashCode() is not implemented\");\n-    }\n-\n-    private boolean equalArguments(Object[] arguments) {\n-        return Arrays.equals(arguments, this.arguments);\n-    }\n-\n-    private String getMockAndMethodName() {\n-        return MockNamer.nameForMock(mock) + \".\" + method.getName();\n-    }\n-    \n-    private String getMockAndMethodNameWithSeqenceNumber() {\n-        return MockNamer.nameForMock(mock) + \"#\" + sequenceNumber + \".\" + method.getName();\n-    }\n-\n-    public String toString() {\n-        List<IArgumentMatcher> matchers = argumentsToMatchers();\n-        return toString(matchers);\n-    }\n-\n-    private List<IArgumentMatcher> argumentsToMatchers() {\n-        List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n-        for (Object arg : this.arguments) {\n-            if (arg != null && arg.getClass().isArray()) {\n-                matchers.add(new ArrayEquals(arg));\n-            } else {\n-                matchers.add(new Equals(arg));\n-            }\n-        }\n-        return matchers;\n-    }\n-    \n-    public String toString(List<IArgumentMatcher> matchers) {\n-        return getMockAndMethodName() + getArgumentsString(matchers);\n-    }\n-\n-    private String getArgumentsString(List<IArgumentMatcher> matchers) {\n-        StringBuilder result = new StringBuilder();\n-        result.append(\"(\");\n-        for (IArgumentMatcher matcher : matchers) {\n-            matcher.appendTo(result);\n-            result.append(\", \");\n-        }\n-        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n-    }\n-    \n-    public String toStringWithArgumentTypes() {\n-        StringBuilder result = new StringBuilder();\n-        result.append(getMockAndMethodName());\n-        result.append(\"(\");\n-        for (Class<?> paramType : getMethod().getParameterTypes()) {\n-            result.append(paramType);\n-            result.append(\", \");\n-        } \n-        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n-    }\n-    \n     public void markVerified() {\n         verified = true;\n     }\n     public boolean isVerifiedInOrder() {\n         return verifiedInOrder;\n     }\n+    \n+    public HasStackTrace getStackTrace() {\n+        return stackTrace;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !o.getClass().equals(this.getClass()))\n+            return false;\n+\n+        Invocation other = (Invocation) o;\n+\n+        return this.mock.equals(other.mock) && this.method.equals(other.method)\n+                && this.equalArguments(other.arguments);\n+    }\n+\n+    private boolean equalArguments(Object[] arguments) {\n+        return Arrays.equals(arguments, this.arguments);\n+    }\n+\n+    public int hashCode() {\n+        throw new RuntimeException(\"hashCode() is not implemented\");\n+    }\n+    \n+    public String toString() {\n+        return toString(argumentsToMatchers());\n+    }\n+\n+    public String toString(List<IArgumentMatcher> matchers) {\n+        return getMockAndMethodName() + getArgumentsString(matchers);\n+    }\n \n     public String toStringWithSequenceNumber() {\n         return toStringWithSequenceNumber(argumentsToMatchers());\n     public String toStringWithSequenceNumber(List<IArgumentMatcher> matchers) {\n         return getMockAndMethodNameWithSeqenceNumber() + getArgumentsString(matchers);\n     }\n-\n-    public HasStackTrace getStackTrace() {\n-        return stackTrace;\n+    \n+    public String toStringWithArgumentTypes() {\n+        StringBuilder result = new StringBuilder();\n+        result.append(getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Class<?> paramType : getMethod().getParameterTypes()) {\n+            result.append(paramType);\n+            result.append(\", \");\n+        } \n+        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n     }\n-}\n+    \n+    private String getMockAndMethodName() {\n+        return MockNamer.nameForMock(mock) + \".\" + method.getName();\n+    }\n+    \n+    private String getMockAndMethodNameWithSeqenceNumber() {\n+        return MockNamer.nameForMock(mock) + \"#\" + sequenceNumber + \".\" + method.getName();\n+    }\n+    \n+    private String getArgumentsString(List<IArgumentMatcher> matchers) {\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"(\");\n+        for (IArgumentMatcher matcher : matchers) {\n+            matcher.appendTo(result);\n+            result.append(\", \");\n+        }\n+        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n+    }\n+    \n+    private List<IArgumentMatcher> argumentsToMatchers() {\n+        List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n+        for (Object arg : this.arguments) {\n+            if (arg != null && arg.getClass().isArray()) {\n+                matchers.add(new ArrayEquals(arg));\n+            } else {\n+                matchers.add(new Equals(arg));\n+            }\n+        }\n+        return matchers;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n     public InvocationMatcher(Invocation invocation) {\n         this(invocation, Collections.<IArgumentMatcher>emptyList());\n     }\n+    \n+    public Method getMethod() {\n+        return invocation.getMethod();\n+    }\n+    \n+    public Invocation getInvocation() {\n+        return this.invocation;\n+    }\n+    \n+    public List<IArgumentMatcher> getMatchers() {\n+        return this.matchers;\n+    }\n \n     public boolean matches(Invocation actual) {\n-        return this.invocation.getMock().equals(\n-                actual.getMock())\n-                && this.invocation.getMethod().equals(actual.getMethod())\n-                && matches(actual.getArguments());\n+        return invocation.getMock().equals(actual.getMock())\n+                && invocation.getMethod().equals(actual.getMethod())\n+                && argumentsMatch(actual.getArguments());\n+    }\n+    \n+    public boolean matchesButMocksAreDifferent(Invocation actual) {\n+        return !invocation.getMock().equals(actual.getMock())\n+            && invocation.getMethod().equals(actual.getMethod())\n+            && argumentsMatch(actual.getArguments());\n+    }\n+    \n+    public boolean matchesButNotMethodDeclaredClass(Invocation actual) {\n+        return invocation.getMock().equals(actual.getMock())\n+            && argumentsMatch(actual.getArguments())\n+            && invocation.getMethod().getName().equals(actual.getMethod().getName())\n+            && invocation.getMethod().getDeclaringClass() != actual.getMethod().getDeclaringClass();\n     }\n \n-    private boolean matches(Object[] arguments) {\n+    private boolean argumentsMatch(Object[] arguments) {\n         if (arguments.length != matchers.size()) {\n             return false;\n         }\n         return true;\n     }\n     \n-    public String toStringWithSequenceNumber() {\n-        return this.invocation.toStringWithSequenceNumber(matchers);\n-    }\n-    \n     public String toString() {\n         return invocation.toString(matchers);\n     }\n-\n-    public Method getMethod() {\n-        return invocation.getMethod();\n+    \n+    public String toStringWithSequenceNumber() {\n+        return invocation.toStringWithSequenceNumber(matchers);\n     }\n     \n-    public Invocation getInvocation() {\n-        return this.invocation;\n-    }\n-    \n-    public List<IArgumentMatcher> getMatchers() {\n-        return this.matchers;\n+    public String toStringWithArgumentTypes() {\n+        return invocation.toStringWithArgumentTypes();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsPrinter.java\n+package org.mockito.internal.invocation;\n+\n+public class InvocationsPrinter {\n+\n+    private final String wanted;\n+    private final String actual;\n+\n+    public InvocationsPrinter(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        if (wantedInvocation.matchesButNotMethodDeclaredClass(actualInvocation)) {\n+            wanted = wantedInvocation.toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        } else if (wantedInvocation.matchesButMocksAreDifferent(actualInvocation)) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber();\n+        } else {\n+            wanted = wantedInvocation.toString();\n+            actual = actualInvocation.toString();\n+        }\n+    }\n+\n+    public String printWanted() {\n+        return wanted;\n+    }\n+\n+    public String printActual() {\n+        return actual;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsPrinter;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class MissingInvocationVerifier implements Verifier {\n         Invocation actual = calculator.findActualInvocation(wanted);\n         \n         if (actual != null) {\n-            reportDiscrepancy(wanted, actual);\n+            InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n+            Exceptions.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n         } else {\n             Exceptions.wantedButNotInvoked(wanted.toString());\n         }\n     }\n-\n-    private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n-        String wanted = wantedInvocation.toString();\n-        String actual = actualInvocation.toString();\n-        //TODO this dummy string equal logic doesnt work when matchers come into play\n-        if (wanted.equals(actual)) {\n-            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n-            actual = actualInvocation.toStringWithArgumentTypes();\n-        }\n-        if (wanted.equals(actual)) {\n-            wanted = wantedInvocation.toStringWithSequenceNumber();\n-            actual = actualInvocation.toStringWithSequenceNumber();\n-        }\n-        \n-        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n-    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+public class InvocationsPrinterTest {\n+\n+    @Test\n+    public void shouldPrintWantedAndActualInvocation() throws Exception {\n+        InvocationMatcher simpleMethod = new InvocationBuilder().simpleMethod().toInvocationMatcher();\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        InvocationsPrinter printer = new InvocationsPrinter(simpleMethod, differentMethod);\n+        \n+        assertEquals(\"Object.simpleMethod()\", printer.printWanted());\n+        assertEquals(\"Object.differentMethod()\", printer.printActual());\n+    }\n+    \n+    @Test\n+    public void shouldPrintSequenceNumberWhenInvocationMatchesButMocksAreDifferent() throws Exception {\n+        InvocationMatcher mockOneMethod = new InvocationBuilder().mock(\"mockOne\").seq(1).toInvocationMatcher();\n+        Invocation mockTwoMethod = new InvocationBuilder().mock(\"mockTwo\").seq(2).toInvocation();\n+        InvocationsPrinter printer = new InvocationsPrinter(mockOneMethod, mockTwoMethod);\n+        \n+        assertEquals(\"Object#1.simpleMethod()\", printer.printWanted());\n+        assertEquals(\"Object#2.simpleMethod()\", printer.printActual());\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldPrintTypesWantedAndActualWhenInvocationIsTheSame() throws Exception {\n+        fail(\"todo\");\n+        InvocationMatcher mockOneMethod = new InvocationBuilder().mock(\"mockOne\").seq(1).toInvocationMatcher();\n+        Invocation mockTwoMethod = new InvocationBuilder().mock(\"mockTwo\").seq(2).toInvocation();\n+        InvocationsPrinter printer = new InvocationsPrinter(mockOneMethod, mockTwoMethod);\n+        \n+        assertEquals(\"Object#1.simpleMethod()\", printer.printWanted());\n+        assertEquals(\"Object#2.simpleMethod()\", printer.printActual());\n+    }\n+}\n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n             assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n             assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n         }\n+    }\n+    \n+    @Test\n+    public void shouldUseArgumentTypeWhenMatcherUsed() throws Exception {\n+        Sub sub = mock(Sub.class);\n+        setMockWithDowncast(sub);\n+        say(\"Hello world\");\n+        try {\n+            verify(sub).say(CrazyMatchers.contains(\"world\"));\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n+            assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n+        }\n     }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n         try {\n             strictly.verify(two).simpleMethod();\n             fail();\n-        } catch (VerificationError expected) {\n-            assertThat(expected, messageContains(\"IMethods#3.simpleMethod()\"));\n-            assertThat(expected, causeMessageContains(\"IMethods#1.simpleMethod()\"));\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods#3.simpleMethod()\"));\n+            assertThat(e, causeMessageContains(\"IMethods#1.simpleMethod()\"));\n         }\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldPrintSequenceNumberAndMatchersWhenMocksAndMethodsAreTheSame() {\n         StateResetter.reset();", "timestamp": 1197581659, "metainfo": ""}