{"sha": "9952454f4efc6a8734149b5e81e4f66c0349dcbb", "log": "package refactoring + changing names  --HG-- rename : src/org/mockito/internal/MockAwareInvocationHandler.java => src/org/mockito/internal/creation/MockAwareInvocationHandler.java rename : src/org/mockito/internal/MockFactory.java => src/org/mockito/internal/creation/MockFactory.java rename : src/org/mockito/internal/ObjectMethodsFilter.java => src/org/mockito/internal/creation/ObjectMethodsFilter.java rename : src/org/mockito/internal/ObjenesisClassInstantiator.java => src/org/mockito/internal/creation/ObjenesisClassInstantiator.java rename : src/org/mockito/internal/Invocation.java => src/org/mockito/internal/invocation/Invocation.java rename : src/org/mockito/internal/InvocationChunk.java => src/org/mockito/internal/invocation/InvocationChunk.java rename : src/org/mockito/internal/InvocationMatcher.java => src/org/mockito/internal/invocation/InvocationMatcher.java rename : src/org/mockito/internal/InvocationsFinder.java => src/org/mockito/internal/invocation/InvocationsFinder.java rename : src/org/mockito/internal/MatchersBinder.java => src/org/mockito/internal/invocation/MatchersBinder.java rename : src/org/mockito/internal/LastArguments.java => src/org/mockito/internal/state/LastArguments.java rename : src/org/mockito/internal/MockitoState.java => src/org/mockito/internal/state/MockitoState.java rename : src/org/mockito/internal/MockitoStateImpl.java => src/org/mockito/internal/state/MockitoStateImpl.java rename : src/org/mockito/internal/ThreadSafeMockitoState.java => src/org/mockito/internal/state/ThreadSafeMockitoState.java rename : src/org/mockito/internal/EmptyReturnValues.java => src/org/mockito/internal/stubbing/EmptyReturnValues.java rename : src/org/mockito/internal/IAnswer.java => src/org/mockito/internal/stubbing/IAnswer.java rename : src/org/mockito/internal/Result.java => src/org/mockito/internal/stubbing/Result.java rename : src/org/mockito/internal/StubbedInvocationMatcher.java => src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java rename : src/org/mockito/internal/Stubber.java => src/org/mockito/internal/stubbing/Stubber.java rename : src/org/mockito/internal/MissingInvocationVerifier.java => src/org/mockito/internal/verification/MissingInvocationVerifier.java rename : src/org/mockito/internal/NumberOfInvocationsVerifier.java => src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java rename : src/org/mockito/internal/OrderOfInvocationsVerifier.java => src/org/mockito/internal/verification/OrderOfInvocationsVerifier.java rename : src/org/mockito/internal/Verifier.java => src/org/mockito/internal/verification/Verifier.java rename : src/org/mockito/internal/VerifyingRecorder.java => src/org/mockito/internal/verification/VerifyingRecorder.java rename : test/org/mockito/internal/CglibTest.java => test/org/mockito/internal/creation/CglibTest.java rename : test/org/mockito/internal/MockFactoryTest.java => test/org/mockito/internal/creation/MockFactoryTest.java rename : test/org/mockito/internal/InvocationBuilder.java => test/org/mockito/internal/invocation/InvocationBuilder.java rename : test/org/mockito/internal/InvocationChunkTest.java => test/org/mockito/internal/invocation/InvocationChunkTest.java rename : test/org/mockito/internal/InvocationMatcherTest.java => test/org/mockito/internal/invocation/InvocationMatcherTest.java rename : test/org/mockito/InvocationTest.java => test/org/mockito/internal/invocation/InvocationTest.java rename : test/org/mockito/internal/MockitoStateImplTest.java => test/org/mockito/internal/state/MockitoStateImplTest.java rename : test/org/mockito/internal/EmptyReturnValuesTest.java => test/org/mockito/internal/stubbing/EmptyReturnValuesTest.java rename : test/org/mockito/internal/StubberTest.java => test/org/mockito/internal/stubbing/StubberTest.java rename : test/org/mockito/internal/NumberOfInvocationsVerifierTest.java => test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java rename : test/org/mockito/internal/RegisteredInvocationsTest.java => test/org/mockito/internal/verification/RegisteredInvocationsTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40163", "commit": "\n--- a/src/org/mockito/CrazyMatchers.java\n+++ b/src/org/mockito/CrazyMatchers.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.LastArguments;\n import org.mockito.internal.matchers.*;\n+import org.mockito.internal.state.LastArguments;\n \n public class CrazyMatchers {\n     \n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.LastArguments;\n import org.mockito.internal.matchers.*;\n+import org.mockito.internal.state.LastArguments;\n \n public class Matchers {\n     /**\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n import org.mockito.exceptions.*;\n import org.mockito.internal.*;\n+import org.mockito.internal.creation.MockFactory;\n+import org.mockito.internal.creation.ObjectMethodsFilter;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.state.*;\n+import org.mockito.internal.stubbing.VoidMethodStubable;\n \n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n     static MockitoState mockitoState = new ThreadSafeMockitoState();\n     \n-    public static VerifyingMode atLeastOnce() {\n-        return VerifyingMode.atLeastOnce();\n+    public static OngoingVerifyingMode atLeastOnce() {\n+        return OngoingVerifyingMode.atLeastOnce();\n     }\n     \n     public static <T> T mock(Class<T> classToMock) {\n                 classToMock, mockControl));\n     }\n \n-    public static <T> MockitoExpectation<T> stub(T methodCallToStub) {\n+    public static <T> OngoingStubbing<T> stub(T methodCallToStub) {\n         mockitoState.stubbingStarted();\n         \n-        MockitoExpectation controlToStub = mockitoState.pullControlToBeStubbed();\n+        OngoingStubbing controlToStub = mockitoState.pullStubable();\n         if (controlToStub == null) {\n             Exceptions.missingMethodInvocation();\n         }\n     }\n     \n     public static <T> T verify(T mock, int wantedNumberOfInvocations) {\n-        return verify(mock, VerifyingMode.times(wantedNumberOfInvocations));\n+        return verify(mock, OngoingVerifyingMode.times(wantedNumberOfInvocations));\n     }\n     \n-    public static <T> T verify(T mock, VerifyingMode mode) {\n+    public static <T> T verify(T mock, OngoingVerifyingMode mode) {\n         MockUtil.validateMock(mock);\n         mockitoState.verifyingStarted(mode);\n         return mock;\n         }\n     }\n     \n-    public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n+    public static <T> VoidMethodStubable<T> stubVoid(T mock) {\n         MockControl<T> control = MockUtil.getControl(mock);\n         mockitoState.stubbingStarted();\n         return control;\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n import java.util.*;\n \n import org.mockito.exceptions.Exceptions;\n-import org.mockito.internal.VerifyingMode;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n \n class StrictOrderVerifier implements Strictly {\n     \n     }\n     //TODO get rid of interface with int\n     public <T> T verify(T mock, int wantedNumberOfInvocations) {\n-        return this.verify(mock, VerifyingMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n+        return this.verify(mock, OngoingVerifyingMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n     }\n     \n-    public <T> T verify(T mock, VerifyingMode verifyingMode) {\n+    public <T> T verify(T mock, OngoingVerifyingMode ongoingVerifyingMode) {\n         if (!mocksToBeVerifiedInOrder.contains(mock)) {\n             Exceptions.strictlyRequiresFamiliarMock();\n         }\n-        return Mockito.verify(mock, VerifyingMode.inOrder(verifyingMode.wantedCount(), mocksToBeVerifiedInOrder));\n+        return Mockito.verify(mock, OngoingVerifyingMode.inOrder(ongoingVerifyingMode.wantedCount(), mocksToBeVerifiedInOrder));\n     }\n \n     public void addMockToBeVerifiedInOrder(Object mock) {\n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.VerifyingMode;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n \n public interface Strictly {\n \n     //TODO get rid of interface with int\n     <T> T verify(T mock, int wantedNumberOfInvocations);\n     \n-    <T> T verify(T mock, VerifyingMode verifyingMode);\n+    <T> T verify(T mock, OngoingVerifyingMode ongoingVerifyingMode);\n     \n }\n--- a/src/org/mockito/internal/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n  */\n package org.mockito.internal;\n \n-import java.util.*;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationsFinder;\n \n public class AllInvocationsFinder implements InvocationsFinder {\n \n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import java.lang.reflect.Method;\n import java.util.List;\n \n-public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n+import org.mockito.internal.creation.MockAwareInvocationHandler;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.state.MockitoState;\n+import org.mockito.internal.state.OngoingStubbing;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.stubbing.EmptyReturnValues;\n+import org.mockito.internal.stubbing.StubbedMethodSelector;\n+import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.VoidMethodStubable;\n+import org.mockito.internal.verification.VerifyingRecorder;\n+\n+public class MockControl<T> implements MockAwareInvocationHandler<T>, OngoingStubbing<T>, VoidMethodStubable<T>, StubbedMethodSelector<T> {\n \n     private final VerifyingRecorder<T> verifyingRecorder;\n     private final Stubber stubber;\n         this.mockitoState = mockitoState;\n         this.matchersBinder = matchersBinder;\n         stubber = new Stubber(mockitoState);\n-        verifyingRecorder = new VerifyingRecorder<T>(new OrderOfInvocationsVerifier(), new MissingInvocationVerifier(), new NumberOfInvocationsVerifier());\n+        verifyingRecorder = new VerifyingRecorder<T>(new AllInvocationsFinder());\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n             return null;\n         }\n         \n-        VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n+        OngoingVerifyingMode ongoingVerifyingMode = mockitoState.pullVerifyingMode();\n         mockitoState.validateState();\n         \n         Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n         \n-        if (verifyingMode != null) {\n-            verifyingRecorder.verify(invocationMatcher, verifyingMode);\n+        if (ongoingVerifyingMode != null) {\n+            verifyingRecorder.verify(invocationMatcher, ongoingVerifyingMode);\n             return EmptyReturnValues.emptyValueFor(method.getReturnType());\n         } \n         \n         stubber.setInvocationForPotentialStubbing(invocationMatcher);\n         verifyingRecorder.recordInvocation(invocationMatcher);\n \n-        mockitoState.reportControlForStubbing(this);\n+        mockitoState.reportStubable(this);\n         \n         return stubber.resultFor(invocationMatcher.getInvocation());\n     }\n         stubber.addReturnValue(value);\n     }\n \n-    public void andThrows(Throwable throwable) {\n+    public void andThrow(Throwable throwable) {\n         verifyingRecorder.eraseLastInvocation();\n         stubber.addThrowable(throwable);\n     }\n     \n-    public MethodSelector<T> toThrow(Throwable throwable) {\n+    public StubbedMethodSelector<T> toThrow(Throwable throwable) {\n         stubber.addThrowableForVoidMethod(throwable);\n         return this;\n     }\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n  */\n package org.mockito.internal;\n \n-import net.sf.cglib.proxy.*;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.exceptions.parents.MockitoException;\n-import org.mockito.internal.MockFactory.MockMethodInterceptor;\n+import org.mockito.internal.creation.ObjectMethodsFilter;\n+import org.mockito.internal.creation.MockFactory.MockMethodInterceptor;\n \n public class MockUtil {\n     \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MockAwareInvocationHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.InvocationHandler;\n+\n+public interface MockAwareInvocationHandler<T> extends InvocationHandler {\n+    void setMock(T mock);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MockFactory.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.util.List;\n+\n+\n+import net.sf.cglib.core.CollectionUtils;\n+import net.sf.cglib.core.VisibilityPredicate;\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+/**\n+ * Factory generating a mock for a class.\n+ * <p>\n+ * Note that this class is stateful\n+ */\n+public class MockFactory<T> {\n+\n+    public static interface MockMethodInterceptor extends MethodInterceptor {\n+        InvocationHandler getHandler();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T createMock(Class<T> toMock, final MockAwareInvocationHandler handler) {\n+\n+        MethodInterceptor interceptor = new MockMethodInterceptor() {\n+\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                if (method.isBridge()) {\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+                return handler.invoke(obj, method, args);\n+            }\n+\n+            public InvocationHandler getHandler() {\n+                return handler;\n+            }\n+        };\n+\n+        Enhancer enhancer = new Enhancer() {\n+            /**\n+             * Filter all private constructors but do not check that there are\n+             * some left\n+             */\n+            protected void filterConstructors(Class sc, List constructors) {\n+                CollectionUtils.filter(constructors, new VisibilityPredicate(\n+                        sc, true));\n+            }\n+        };\n+        \n+        if (toMock.isInterface()) {\n+\t\t\tenhancer.setInterfaces(new Class[] { toMock });\n+\t\t} else {\n+\t\t\tenhancer.setSuperclass(toMock);\n+\t\t}\n+        \n+        enhancer.setCallbackType(interceptor.getClass());\n+\n+        Class mockClass = enhancer.createClass();\n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+\n+        Factory mock;\n+        try {\n+            mock = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(\"Fail to instantiate mock for \" + toMock\n+                    + \" on \" + System.getProperty(\"java.vm.vendor\") + \" JVM\");\n+        }\n+\n+        // This call is required. Cglib has some \"magic code\" making sure a\n+        // callback is used by only one instance of a given class. So only the\n+        // instance created right after registering the callback will get it.\n+        // However, this is done in the construtor which I'm bypassing to\n+        // allow class instantiation without calling a constructor.\n+        // Fortunatly, the \"magic code\" is also called in getCallback which is\n+        // why I'm calling it here mock.getCallback(0);\n+        \n+        mock.getCallback(0);\n+\n+        handler.setMock(mock);\n+        return (T) mock;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MockNamer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+public class MockNamer {\n+\n+    public static String nameForMock(Object mock) {\n+    \tif (mock.getClass().getInterfaces().length == 2) {\n+    \t\treturn mock.getClass().getInterfaces()[0].getSimpleName();\n+    \t} else {\n+    \t\treturn mock.getClass().getSuperclass().getSimpleName();\n+    \t}\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/ObjectMethodsFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.Method;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ObjectMethodsFilter<T extends MockAwareInvocationHandler> implements MockAwareInvocationHandler {\n+    private final Method equalsMethod;\n+\n+    private final Method hashCodeMethod;\n+\n+    private final Method toStringMethod;\n+\n+    private final T delegate;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectMethodsFilter(Class toMock, T delegate) {\n+        try {\n+            if (toMock.isInterface()) {\n+                toMock = Object.class;\n+            }\n+            equalsMethod = toMock.getMethod(\"equals\", new Class[] { Object.class });\n+            hashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n+            toStringMethod = toMock.getMethod(\"toString\", (Class[]) null);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"An Object method could not be found!\");\n+        }\n+        this.delegate = delegate;\n+    }\n+\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+            throws Throwable {\n+        if (equalsMethod.equals(method)) {\n+            return Boolean.valueOf(proxy == args[0]);\n+        }\n+        if (hashCodeMethod.equals(method)) {\n+            return new Integer(System.identityHashCode(proxy));\n+        }\n+        if (toStringMethod.equals(method)) {\n+            return mockToString(proxy);\n+        }\n+        return delegate.invoke(proxy, method, args);\n+    }\n+\n+    private String mockToString(Object mock) {\n+        return \"Mock for \" + MockNamer.nameForMock(mock);\n+    }\n+\n+    public T getDelegate() {\n+        return delegate;\n+    }\n+\n+    public void setMock(Object mock) {\n+        delegate.setMock(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/ObjenesisClassInstantiator.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import org.objenesis.ObjenesisHelper;\n+\n+public class ObjenesisClassInstantiator {\n+\n+    public static Object newInstance(Class<?> clazz) throws InstantiationException {\n+        return ObjenesisHelper.newInstance(clazz);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.creation.MockNamer;\n+import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+\n+public class Invocation {\n+\n+    private boolean verified;\n+    \n+    private final int sequenceNumber;\n+    private final Object mock;\n+    private final Method method;\n+    private final Object[] arguments;\n+\n+    private boolean verifiedInOrder;\n+\n+    private HasStackTrace stackTrace;\n+\n+    public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n+        this.mock = mock;\n+        this.method = method;\n+        this.arguments = expandVarArgs(method.isVarArgs(), args);\n+        this.sequenceNumber = sequenceNumber;\n+        this.stackTrace = new MockitoException(\"\");\n+    }\n+\n+    private static Object[] expandVarArgs(final boolean isVarArgs,\n+            final Object[] args) {\n+        if (!isVarArgs || isVarArgs && args[args.length - 1] != null\n+                && !args[args.length - 1].getClass().isArray()) {\n+            return args == null ? new Object[0] : args;\n+        }\n+        Object[] varArgs = ArrayEquals.createObjectArray(args[args.length - 1]);\n+        final int nonVarArgsCount = args.length - 1;\n+        final int varArgsCount = varArgs.length;\n+        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n+        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n+        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n+        return newArgs;\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !o.getClass().equals(this.getClass()))\n+            return false;\n+\n+        Invocation other = (Invocation) o;\n+\n+        return this.mock.equals(other.mock) && this.method.equals(other.method)\n+                && this.equalArguments(other.arguments);\n+    }\n+\n+    public int hashCode() {\n+        throw new RuntimeException(\"hashCode() is not implemented\");\n+    }\n+\n+    private boolean equalArguments(Object[] arguments) {\n+        return Arrays.equals(arguments, this.arguments);\n+    }\n+\n+    private String getMockAndMethodName() {\n+        return MockNamer.nameForMock(mock) + \".\" + method.getName();\n+    }\n+    \n+    private String getMockAndMethodNameWithSeqenceNumber() {\n+        return MockNamer.nameForMock(mock) + \"#\" + sequenceNumber + \".\" + method.getName();\n+    }\n+\n+    public String toString() {\n+        List<IArgumentMatcher> matchers = argumentsToMatchers();\n+        return toString(matchers);\n+    }\n+\n+    private List<IArgumentMatcher> argumentsToMatchers() {\n+        List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n+        for (Object arg : this.arguments) {\n+            if (arg != null && arg.getClass().isArray()) {\n+                matchers.add(new ArrayEquals(arg));\n+            } else {\n+                matchers.add(new Equals(arg));\n+            }\n+        }\n+        return matchers;\n+    }\n+    \n+    public String toString(List<IArgumentMatcher> matchers) {\n+        return getMockAndMethodName() + getArgumentsString(matchers);\n+    }\n+\n+    private String getArgumentsString(List<IArgumentMatcher> matchers) {\n+        StringBuilder result = new StringBuilder();\n+        result.append(\"(\");\n+        for (IArgumentMatcher matcher : matchers) {\n+            matcher.appendTo(result);\n+            result.append(\", \");\n+        }\n+        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n+    }\n+    \n+    public String toStringWithArgumentTypes() {\n+        StringBuilder result = new StringBuilder();\n+        result.append(getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Class<?> paramType : getMethod().getParameterTypes()) {\n+            result.append(paramType);\n+            result.append(\", \");\n+        } \n+        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n+    }\n+    \n+    public void markVerified() {\n+        verified = true;\n+    }\n+\n+    public boolean isVerified() {\n+        return verified;\n+    }\n+    \n+    public Integer getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    public void markVerifiedInOrder() {\n+        this.verifiedInOrder = true;\n+        \n+    }\n+\n+    public boolean isVerifiedInOrder() {\n+        return verifiedInOrder;\n+    }\n+\n+    public String toStringWithSequenceNumber() {\n+        return toStringWithSequenceNumber(argumentsToMatchers());\n+    }\n+\n+    public String toStringWithSequenceNumber(List<IArgumentMatcher> matchers) {\n+        return getMockAndMethodNameWithSeqenceNumber() + getArgumentsString(matchers);\n+    }\n+\n+    public HasStackTrace getStackTrace() {\n+        return stackTrace;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationChunk.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class InvocationChunk {\n+\n+    private final List<Invocation> invocations = new LinkedList<Invocation>();\n+\n+    public InvocationChunk(Invocation invocation) {\n+        invocations.add(invocation);\n+    }\n+    \n+    public Invocation getInvocation() {\n+        return invocations.get(0);\n+    }\n+\n+    public int getCount() {\n+        return invocations.size();\n+    }\n+\n+    public void add(Invocation invocation) {\n+        invocations.add(invocation);\n+    }\n+    \n+    public void markAllInvocationsAsVerified() {\n+        for (Invocation invocation : invocations) {\n+            invocation.markVerifiedInOrder();\n+            invocation.markVerified();\n+        }\n+    }\n+    \n+    public String toString() {\n+        return getInvocation() + \" x \" + getCount();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+\n+public class InvocationMatcher {\n+\n+    protected final Invocation invocation;\n+    protected final List<IArgumentMatcher> matchers;\n+\n+    public InvocationMatcher(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        if (matchers == null) {\n+            throw new IllegalArgumentException(\"matchers cannot be null\");\n+        }\n+        this.invocation = invocation;\n+        this.matchers = matchers;\n+    }\n+    \n+    public InvocationMatcher(Invocation invocation) {\n+        this(invocation, Collections.<IArgumentMatcher>emptyList());\n+    }\n+\n+    public boolean matches(Invocation actual) {\n+        return this.invocation.getMock().equals(\n+                actual.getMock())\n+                && this.invocation.getMethod().equals(actual.getMethod())\n+                && matches(actual.getArguments());\n+    }\n+\n+    private boolean matches(Object[] arguments) {\n+        if (arguments.length != matchers.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!matchers.get(i).matches(arguments[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    public String toStringWithSequenceNumber() {\n+        return this.invocation.toStringWithSequenceNumber(matchers);\n+    }\n+    \n+    public String toString() {\n+        return invocation.toString(matchers);\n+    }\n+\n+    public Method getMethod() {\n+        return invocation.getMethod();\n+    }\n+    \n+    public Invocation getInvocation() {\n+        return this.invocation;\n+    }\n+    \n+    public List<IArgumentMatcher> getMatchers() {\n+        return this.matchers;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.util.List;\n+\n+\n+public interface InvocationsFinder {\n+\n+    List<Invocation> allInvocationsInOrder(List<Object> mocks);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.internal.state.LastArguments;\n+\n+public class MatchersBinder {\n+\n+    public InvocationMatcher bindMatchers(Invocation invocation) throws InvalidUseOfMatchersException {\n+        List<IArgumentMatcher> lastMatchers = LastArguments.instance().pullMatchers();\n+        validateMatchers(invocation, lastMatchers);\n+\n+        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n+        \n+        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, processedMatchers);\n+        return invocationWithMatchers;\n+    }\n+\n+    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) throws InvalidUseOfMatchersException {\n+        if (matchers != null) {\n+            if (matchers.size() != invocation.getArguments().length) {\n+                throw new InvalidUseOfMatchersException(\n+                        + invocation.getArguments().length\n+                        + \" matchers expected, \" + matchers.size()\n+                        + \" recorded.\");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * if user passed bare arguments then create EqualsMatcher for every argument\n+     */\n+    private List<IArgumentMatcher> createEqualsMatchers(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        if (matchers != null) {\n+            return matchers;\n+        }\n+        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/LastArguments.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Stack;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.And;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.internal.matchers.Not;\n+import org.mockito.internal.matchers.Or;\n+\n+public class LastArguments {\n+    \n+    private static ThreadLocal<LastArguments> INSTANCE = new ThreadLocal<LastArguments>();\n+    \n+    private Stack<IArgumentMatcher> matcherStack = new Stack<IArgumentMatcher>();\n+\n+    public static LastArguments instance() {\n+        if (INSTANCE.get() == null) {\n+            INSTANCE.set(new LastArguments()); \n+        }\n+        \n+        return INSTANCE.get();\n+    }\n+    \n+    public void reportMatcher(IArgumentMatcher matcher) {\n+        matcherStack.push(matcher);\n+    }\n+\n+    public List<IArgumentMatcher> pullMatchers() {\n+        if (matcherStack.isEmpty()) {\n+            return null;\n+        }\n+        \n+        ArrayList<IArgumentMatcher> matchers = new ArrayList<IArgumentMatcher>(matcherStack);\n+        matcherStack.clear();\n+        return matchers;\n+    }\n+\n+    public void reportAnd(int count) {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found for And(?).\");\n+        matcherStack.push(new And(popLastArgumentMatchers(count)));\n+    }\n+\n+    public void reportNot() {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found for Not(?).\");\n+        matcherStack.push(new Not(popLastArgumentMatchers(1).get(0)));\n+    }\n+\n+    private List<IArgumentMatcher> popLastArgumentMatchers(int count) {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n+        assertState(matcherStack.size() >= count,\n+                \"\" + count + \" matchers expected, \" + matcherStack.size() + \" recorded.\");\n+        List<IArgumentMatcher> result = new LinkedList<IArgumentMatcher>();\n+        result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));\n+        for (int i = 0; i < count; i++) {\n+            matcherStack.pop();\n+        }\n+        return result;\n+    }\n+\n+    private void assertState(boolean toAssert, String message) {\n+        if (!toAssert) {\n+            matcherStack.clear();\n+            throw new InvalidUseOfMatchersException(message);\n+        }\n+    }\n+\n+    public void reportOr(int count) {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n+        matcherStack.push(new Or(popLastArgumentMatchers(count)));\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/MockitoState.java\n+package org.mockito.internal.state;\n+\n+\n+\n+//TODO name should be something like that: MockingState\n+//TODO verificationMode instead verifying\n+@SuppressWarnings(\"unchecked\")\n+public interface MockitoState {\n+\n+    void reportStubable(OngoingStubbing ongoingStubbing);\n+\n+    OngoingStubbing pullStubable();\n+\n+    void verifyingStarted(OngoingVerifyingMode verifyingMode);\n+\n+    OngoingVerifyingMode pullVerifyingMode();\n+\n+    void stubbingStarted();\n+\n+    void stubbingCompleted();\n+    \n+    int nextSequenceNumber();\n+\n+    void validateState();\n+\n+    void reset();\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/MockitoStateImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import org.mockito.exceptions.Exceptions;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoStateImpl implements MockitoState {\n+    \n+    private OngoingStubbing ongoingStubbing;\n+    private OngoingVerifyingMode ongoingVerifyingMode;\n+    private int invocationSequenceNumber = 1;\n+    private boolean stubbingInProgress = false;\n+\n+    public void reportStubable(OngoingStubbing ongoingStubbing) {\n+        this.ongoingStubbing = ongoingStubbing;\n+    }\n+\n+    public OngoingStubbing pullStubable() {\n+        OngoingStubbing temp = ongoingStubbing;\n+        ongoingStubbing = null;\n+        return temp;\n+    }\n+    \n+    public void verifyingStarted(OngoingVerifyingMode verify) {\n+        validateState();\n+        ongoingVerifyingMode = verify;\n+    }\n+\n+    public OngoingVerifyingMode pullVerifyingMode() {\n+        OngoingVerifyingMode temp = ongoingVerifyingMode;\n+        ongoingVerifyingMode = null;\n+        return temp;\n+    }\n+\n+    public int nextSequenceNumber() {\n+        return invocationSequenceNumber++;\n+    }\n+\n+    public void stubbingStarted() {\n+        validateState();\n+        stubbingInProgress = true;\n+    }\n+\n+    public void validateState() {\n+        if (ongoingVerifyingMode != null) {\n+            ongoingVerifyingMode = null;\n+            Exceptions.unfinishedVerificationException();\n+        }\n+        \n+        if (stubbingInProgress) {\n+            stubbingInProgress = false;\n+            Exceptions.unfinishedStubbing();\n+        }\n+    }\n+\n+    public void stubbingCompleted() {\n+        stubbingInProgress = false;\n+    }\n+    \n+    public String toString() {\n+        return  \"ongoingStubbing: \" + ongoingStubbing + \n+        \", ongoingVerifyingMode: \" + ongoingVerifyingMode +\n+        \", invocationSequenceNumber: \" + invocationSequenceNumber +\n+        \", stubbingInProgress: \" + stubbingInProgress;\n+    }\n+\n+    public void reset() {\n+        stubbingInProgress = false;\n+        ongoingVerifyingMode = null;\n+        invocationSequenceNumber = 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/OngoingStubbing.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+public interface OngoingStubbing<T> {\n+\n+    void andReturn(T value);\n+\n+    void andThrow(Throwable throwable);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/OngoingVerifyingMode.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.mockito.exceptions.parents.MockitoException;\n+\n+public class OngoingVerifyingMode {\n+\n+    private final Integer wantedInvocationCount;\n+    private final List<Object> mocksToBeVerifiedInSequence;\n+\n+    private OngoingVerifyingMode(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n+        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+        this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n+    }\n+    \n+    public static OngoingVerifyingMode atLeastOnce() {\n+        return new OngoingVerifyingMode(null, Collections.emptyList());\n+    }\n+\n+    public static OngoingVerifyingMode times(int wantedNumberOfInvocations) {\n+        return new OngoingVerifyingMode(wantedNumberOfInvocations, Collections.emptyList());\n+    }\n+    \n+    /**\n+     * Don't use OngoingVerifyingMode class directly. \n+     * <p>\n+     * Use Mockito.atLeastOnce() and Mockito.times()\n+     */\n+    public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n+    \n+    public static OngoingVerifyingMode inOrder(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n+        return new OngoingVerifyingMode(wantedNumberOfInvocations, mocksToBeVerifiedInOrder);\n+    }\n+\n+    public boolean atLeastOnceMode() {\n+        return wantedInvocationCount == null;\n+    }\n+\n+    public Integer wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+\n+    public List<Object> getAllMocksToBeVerifiedInSequence() {\n+        return mocksToBeVerifiedInSequence;\n+    }\n+\n+    public boolean orderOfInvocationsMatters() {\n+        return !mocksToBeVerifiedInSequence.isEmpty();\n+    }\n+\n+    public boolean wantedCountIsZero() {\n+        return wantedInvocationCount != null && wantedInvocationCount == 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/state/ThreadSafeMockitoState.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ThreadSafeMockitoState implements MockitoState {\n+    \n+    private static ThreadLocal<MockitoState> mockitoState = new ThreadLocal<MockitoState>();\n+\n+    static MockitoState threadSafely() {\n+        if (mockitoState.get() == null) {\n+            mockitoState.set(new MockitoStateImpl());\n+        }\n+        return mockitoState.get();\n+    }\n+    \n+    public void reportStubable(OngoingStubbing ongoingStubbing) {\n+        threadSafely().reportStubable(ongoingStubbing);\n+    }\n+\n+    public OngoingStubbing pullStubable() {\n+        return threadSafely().pullStubable();\n+    }\n+    \n+    public void verifyingStarted(OngoingVerifyingMode verify) {\n+        threadSafely().verifyingStarted(verify);\n+    }\n+\n+    public OngoingVerifyingMode pullVerifyingMode() {\n+        return threadSafely().pullVerifyingMode();\n+    }\n+\n+    public int nextSequenceNumber() {\n+        return threadSafely().nextSequenceNumber();\n+    }\n+\n+    public void stubbingStarted() {\n+        threadSafely().stubbingStarted();\n+    }\n+\n+    public void validateState() {\n+        threadSafely().validateState();\n+    }\n+\n+    public void stubbingCompleted() {\n+        threadSafely().stubbingCompleted();\n+    }\n+    \n+    public String toString() {\n+        return threadSafely().toString();\n+    }\n+\n+    public void reset() {\n+        threadSafely().reset();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/EmptyReturnValues.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+public class EmptyReturnValues {\n+    \n+    public static Object emptyValueFor(Class<?> type) {\n+        return emptyReturnValueToType.get(type);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n+    \n+    static {\n+        emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());\n+        \n+        emptyReturnValueToType.put(Set.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(HashSet.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(SortedSet.class, new TreeSet<Object>());        \n+        emptyReturnValueToType.put(TreeSet.class, new TreeSet<Object>());\n+        emptyReturnValueToType.put(LinkedHashSet.class, new LinkedHashSet<Object>());        \n+\n+        emptyReturnValueToType.put(List.class, new LinkedList<Object>());       \n+        emptyReturnValueToType.put(LinkedList.class, new LinkedList<Object>());\n+        emptyReturnValueToType.put(ArrayList.class, new ArrayList<Object>());\n+        \n+        emptyReturnValueToType.put(Map.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(HashMap.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(SortedMap.class, new TreeMap<Object, Object>());        \n+        emptyReturnValueToType.put(TreeMap.class, new TreeMap<Object, Object>());\n+        emptyReturnValueToType.put(LinkedHashMap.class, new LinkedHashMap<Object, Object>());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/IAnswer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+/**\n+ * Used to answer expected calls.\n+ * @param <T> the type to return.\n+ */\n+public interface IAnswer<T> {\n+    /**\n+     * is called to answer an expected call. \n+     * The answer may be to return a value, or to throw an exception.\n+     * The arguments of the call for which the answer is generated \n+     * are available via getCurrentArguments() - be careful\n+     * here, using the arguments is not refactoring-safe.\n+     * \n+     * @return the value to be returned\n+     * @throws Throwable the throwable to be thrown\n+     */\n+    T answer() throws Throwable;\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/Result.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.exceptions.parents.StackTraceFilter;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class Result implements IAnswer {\n+\n+    private IAnswer value;\n+\n+    private Result(IAnswer value) {\n+        this.value = value;\n+    }\n+\n+    public static Result createThrowResult(final Throwable throwable) {\n+        return new Result(new IAnswer<Object>() {\n+            public Object answer() throws Throwable {\n+                StackTraceFilter filter = new StackTraceFilter();\n+                final Throwable filtered = throwable.fillInStackTrace();\n+                \n+                //TODO unit test?\n+                filter.filterStackTrace(new HasStackTrace() {\n+                    public StackTraceElement[] getStackTrace() {\n+                        return filtered.getStackTrace();\n+                    }\n+                    public void setStackTrace(StackTraceElement[] stackTrace) {\n+                        filtered.setStackTrace(stackTrace);\n+                    }\n+                });\n+                \n+                throw filtered;\n+            }\n+        });\n+    }\n+    public static Result createReturnResult(final Object value) {\n+\n+        return new Result(new IAnswer<Object>() {\n+            public Object answer() throws Throwable {\n+                return value;\n+            }\n+        });\n+    }\n+\n+    public static Result createAnswerResult(IAnswer answer) {\n+        return new Result(answer);\n+    }\n+\n+    public Object answer() throws Throwable {\n+        return value.answer();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+public class StubbedInvocationMatcher extends InvocationMatcher {\n+\n+    private final Result result;\n+    \n+    public StubbedInvocationMatcher(InvocationMatcher invocation, Result result) {\n+        super(invocation.getInvocation(), invocation.getMatchers());\n+        this.result = result;\n+    }\n+\n+    public Result getResult() {\n+        return result;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return super.toString() + \" stubbed with: \" + result.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/StubbedMethodSelector.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+public interface StubbedMethodSelector<T> {\n+    \n+    T on();\n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n+package org.mockito.internal.stubbing;\n+\n+import java.util.LinkedList;\n+\n+import org.mockito.exceptions.Exceptions;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.state.MockitoState;\n+\n+public class Stubber {\n+\n+    private InvocationMatcher invocationForStubbing;\n+    private LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n+    private Throwable throwableForVoidMethod;\n+    private final MockitoState mockitoState;\n+    \n+    public Stubber(MockitoState mockitoState) {\n+        this.mockitoState = mockitoState;\n+    }\n+\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        this.invocationForStubbing = invocation;\n+    }\n+    \n+    public void addReturnValue(Object value) {\n+        mockitoState.stubbingCompleted();\n+        addResult(Result.createReturnResult(value));\n+    }\n+    \n+    public void addThrowable(Throwable throwable) {\n+        mockitoState.stubbingCompleted();\n+        validateThrowable(throwable);\n+        addResult(Result.createThrowResult(throwable));\n+    }\n+\n+    private void addResult(Result result) {\n+        assert invocationForStubbing != null;\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, result));\n+    }\n+\n+    public Object resultFor(Invocation wanted) throws Throwable {\n+        for (StubbedInvocationMatcher s : stubbed) {\n+            if (s.matches(wanted)) {\n+                return s.getResult().answer();\n+            }\n+        }\n+\n+        return EmptyReturnValues.emptyValueFor(wanted.getMethod().getReturnType());\n+    }\n+\n+    public void addThrowableForVoidMethod(Throwable throwable) {\n+        throwableForVoidMethod = throwable;\n+    }\n+\n+    public boolean hasThrowableForVoidMethod() {\n+        return throwableForVoidMethod != null;\n+    }\n+    \n+    public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {\n+        invocationForStubbing = voidMethodInvocationMatcher;\n+        addThrowable(throwableForVoidMethod);\n+        throwableForVoidMethod = null;\n+    }\n+    \n+    private void validateThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            Exceptions.cannotStubWithNullThrowable();\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+    \n+        if (!isValidCheckedException(throwable)) {\n+            Exceptions.checkedExceptionInvalid(throwable);\n+        }\n+    }\n+\n+    private boolean isValidCheckedException(Throwable throwable) {\n+        Invocation lastInvocation = invocationForStubbing.getInvocation();\n+\n+        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubable.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+\n+\n+public interface VoidMethodStubable<T> {\n+\n+    StubbedMethodSelector<T> toThrow(Throwable throwable);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.Exceptions;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+public class MissingInvocationVerifier implements Verifier {\n+\n+    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        boolean atLeastOnce = mode.atLeastOnceMode();\n+               \n+        if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n+            reportMissingInvocationError(registeredInvocations, wanted);\n+        }\n+    }\n+    \n+    private void reportMissingInvocationError(RegisteredInvocations registeredInvocations, InvocationMatcher wanted) {\n+        Invocation actual = registeredInvocations.findActualInvocation(wanted);\n+        \n+        if (actual != null) {\n+            reportDiscrepancy(wanted, actual);\n+        } else {\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+    }\n+\n+    private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        if (wanted.equals(actual)) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+public class NumberOfInvocationsVerifier implements Verifier {\n+\n+    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n+            return;\n+        }\n+        \n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        \n+        if (actualCount < wantedCount) {\n+            HasStackTrace lastInvocation = registeredInvocations.getLastInvocationStackTrace(wanted);\n+            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n+        } else if (actualCount > wantedCount) {\n+            HasStackTrace firstUndesired = registeredInvocations.getFirstUndesiredInvocationStackTrace(wanted, mode);\n+            Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/OrderOfInvocationsVerifier.java\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Exceptions;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationChunk;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+public class OrderOfInvocationsVerifier implements Verifier {\n+\n+    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        if (!mode.orderOfInvocationsMatters()) {\n+            return;\n+        }\n+        \n+        List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n+        \n+        if (mode.wantedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n+            Exceptions.numberOfInvocationsDiffers(0, chunks.get(0).getCount(), wanted.toString());\n+        } else if (mode.wantedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (chunks.isEmpty()) {\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+        \n+        if (!wanted.matches(chunks.get(0).getInvocation())) {\n+            reportStrictOrderDiscrepancy(wanted, chunks.get(0).getInvocation());\n+        }\n+        \n+        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.wantedCount()) {\n+            Exceptions.numberOfInvocationsDiffers(mode.wantedCount(), chunks.get(0).getCount(), wanted.toString());\n+        }\n+    }\n+    \n+    private void reportStrictOrderDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        boolean sameMocks = wantedInvocation.getInvocation().getMock().equals(actualInvocation.getMock());\n+        boolean sameMethods = wanted.equals(actual);\n+        if (sameMethods && !sameMocks) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber();\n+        } else if (sameMethods) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.strictlyWantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationChunk;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+public class RegisteredInvocations {\n+    \n+    private List<Invocation> registeredInvocations = new LinkedList<Invocation>();\n+    private final InvocationsFinder invocationsFinder;\n+    \n+    public RegisteredInvocations(InvocationsFinder invocationsFinder) {\n+        this.invocationsFinder = invocationsFinder;\n+    }\n+\n+    public void add(Invocation invocation) {\n+        registeredInvocations.add(invocation);    \n+    }\n+\n+    public void removeLast() {\n+        registeredInvocations.remove(registeredInvocations.size()-1);\n+    }\n+    \n+    public void markInvocationsAsVerified(InvocationMatcher expected, OngoingVerifyingMode mode) {\n+        if (mode.wantedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (mode.orderOfInvocationsMatters()) {\n+            List<InvocationChunk> chunks = unverifiedInvocationChunks(mode);\n+            chunks.get(0).markAllInvocationsAsVerified();\n+        } else {\n+            for (Invocation invocation : registeredInvocations) {\n+                if (expected.matches(invocation)) {\n+                    invocation.markVerified();\n+                }\n+            }\n+        }\n+    }\n+    \n+    public List<InvocationChunk> unverifiedInvocationChunks(OngoingVerifyingMode ongoingVerifyingMode) {\n+        Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n+                new Comparator<Invocation>(){\n+                    public int compare(Invocation o1, Invocation o2) {\n+                        int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n+                        assert comparison != 0;\n+                        return comparison;\n+                    }});\n+        \n+        List<Object> allMocksToBeVerifiedInOrder = ongoingVerifyingMode.getAllMocksToBeVerifiedInSequence();\n+        List<Invocation> allInvocations = invocationsFinder.allInvocationsInOrder(allMocksToBeVerifiedInOrder);\n+        allInvocationsInOrder.addAll(allInvocations);\n+        \n+        LinkedList<InvocationChunk> chunks = new LinkedList<InvocationChunk>();\n+        for (Invocation i : allInvocationsInOrder) {\n+            if (i.isVerifiedInOrder()) {\n+                continue;\n+            }\n+            if (!chunks.isEmpty() \n+                    && chunks.getLast().getInvocation().equals(i)) {\n+                chunks.get(chunks.size()-1).add(i);\n+            } else {\n+                chunks.add(new InvocationChunk(i));\n+            }\n+        }\n+        \n+        return chunks;\n+    }\n+    \n+    public Invocation findActualInvocation(InvocationMatcher wanted) {\n+        Invocation actualbyName = null;\n+        for (Invocation registered : registeredInvocations) {\n+            String wantedMethodName = wanted.getMethod().getName();\n+            String registeredInvocationName = registered.getMethod().getName();\n+            if (wantedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n+                actualbyName = registered;\n+            }\n+        }\n+        \n+        return actualbyName != null ? actualbyName : getFirstUnverified();\n+    }\n+\n+    public int countActual(InvocationMatcher wanted) {\n+        int actual = 0;\n+        for (Invocation registeredInvocation : registeredInvocations) {\n+            if (wanted.matches(registeredInvocation)) {\n+                actual++;\n+            }\n+        }\n+\n+        return actual;\n+    }\n+\n+    public List<Invocation> all() {\n+        return registeredInvocations;\n+    }\n+\n+    public Invocation getFirstUnverified() {\n+        for (Invocation registered : registeredInvocations) {\n+            if (!registered.isVerified()) {\n+                return registered;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted) {\n+        Invocation lastMatching = null;\n+        for (Invocation registered : registeredInvocations) {\n+            if (wanted.matches(registered)) {\n+                lastMatching = registered;\n+            }\n+        }\n+        return lastMatching != null ? lastMatching.getStackTrace() : null;\n+    }\n+\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        int counter = 0;\n+        for (Invocation registered : registeredInvocations) {\n+            if (wanted.matches(registered)) {\n+                counter++;\n+                if (counter > mode.wantedCount()) {\n+                    return registered.getStackTrace();\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"There are no undesired invocations!\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/Verifier.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+\n+public interface Verifier {\n+\n+    void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode);\n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Exceptions;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+public class VerifyingRecorder<T> {\n+\n+    private final RegisteredInvocations registeredInvocations;\n+    \n+    //TODO change name of invocationsFinder\n+    public VerifyingRecorder(InvocationsFinder invocationsFinder) {\n+        this.registeredInvocations = new RegisteredInvocations(invocationsFinder);\n+    }\n+    \n+    public void recordInvocation(InvocationMatcher invocation) {\n+        this.registeredInvocations.add(invocation.getInvocation());\n+    }\n+    \n+    public void eraseLastInvocation() {\n+        registeredInvocations.removeLast();\n+    }\n+\n+    public List<Invocation> getRegisteredInvocations() {\n+        return registeredInvocations.all();\n+    }\n+\n+    public void verify(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        //get unverified invocation chunk and run following verifiers:\n+        \n+        // chunks can be empty, can have invocations from different mocks or\n+        // have invocations only from one mock (not strict verification\n+        // scenario)\n+        \n+        // new MissingInvocationVerifier(), \n+        // new NumberOfInvocationsVerifier()\n+        \n+        new OrderOfInvocationsVerifier().verify(registeredInvocations, wanted, mode); \n+        new MissingInvocationVerifier().verify(registeredInvocations, wanted, mode); \n+        new NumberOfInvocationsVerifier().verify(registeredInvocations, wanted, mode);\n+        \n+        registeredInvocations.markInvocationsAsVerified(wanted, mode);\n+    }\n+    \n+    public void verifyNoMoreInteractions() {\n+        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        if (unverified != null) {\n+            Exceptions.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n+        }\n+    }\n+    \n+    public void verifyZeroInteractions() {\n+        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        if (unverified != null) {\n+            Exceptions.zeroInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n+        }\n+    }\n+}\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         List mock = Mockito.mock(List.class);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n-        assertNull(Mockito.mockitoState.pullControlToBeStubbed());\n+        assertNull(Mockito.mockitoState.pullStubable());\n     }\n     \n     @Test(expected=NotAMockException.class)\n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.state.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MockControlTest extends RequiresValidState {\n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         MockitoStateImpl state = new MockitoStateImpl();\n-        state.verifyingStarted(VerifyingMode.atLeastOnce());\n+        state.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n         MockControl control = new MockControl(state, new ExceptionThrowingBinder());\n         \n         try {\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/CglibTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import static org.junit.Assert.assertNotSame;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+\n+import net.sf.cglib.proxy.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.creation.ObjenesisClassInstantiator;\n+\n+/**\n+ * This test case is used to make sure that the way cglib is used is providing the expected behavior\n+ */\n+public class CglibTest extends RequiresValidState {\n+\n+    /**\n+     * Check that an interceptor is used by only one instance of a class\n+     * @throws Exception\n+     */\n+    @Test \n+    public void shouldCallbacksBeDifferent() throws Exception {\n+        Factory f1 = createMock();\n+        Factory f2 = createMock();\n+        \n+        assertNotSame(f1.getCallback(0), f2.getCallback(0));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Factory createMock() throws Exception {\n+        MethodInterceptor interceptor = new MethodInterceptor() {\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                return proxy.invokeSuper(obj, args);\n+            }\n+        };\n+\n+        Enhancer enhancer = new Enhancer();\n+        enhancer.setSuperclass(ArrayList.class);\n+        enhancer.setCallbackType(MethodInterceptor.class);\n+        \n+        Class mockClass = enhancer.createClass();\n+        \n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+                \n+        Factory f = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        \n+        f.getCallback(0);\n+        \n+        return f;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/MockFactoryTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import static org.junit.Assert.*;\n+import net.sf.cglib.proxy.Factory;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.creation.MockFactory;\n+import org.mockito.internal.creation.ObjectMethodsFilter;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockFactoryTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldCreateMockFromInterface() throws Exception {\n+        MockFactory<SomeInterface> factory = new MockFactory<SomeInterface>();\n+        SomeInterface proxy = factory.createMock(SomeInterface.class, new MockAwareStub());\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(Object.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClass() throws Exception {\n+        MockFactory<ClassWithoutConstructor> factory = new MockFactory<ClassWithoutConstructor>();\n+        ClassWithoutConstructor proxy = factory.createMock(ClassWithoutConstructor.class, new MockAwareStub());\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(ClassWithoutConstructor.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {\n+        try {\n+            new ClassWithDodgyConstructor();\n+            fail();\n+        } catch (Exception e) {};\n+        \n+        MockFactory<ClassWithDodgyConstructor> factory = new MockFactory<ClassWithDodgyConstructor>();\n+        ClassWithDodgyConstructor mock = factory.createMock(ClassWithDodgyConstructor.class, new MockAwareStub());\n+        assertNotNull(mock);\n+    }\n+    \n+    @Test \n+    public void shouldMocksHaveDifferentInterceptors() throws Exception {\n+        MockFactory<SomeClass> factory = new MockFactory<SomeClass>();\n+        SomeClass mockOne = factory.createMock(SomeClass.class, new MockAwareStub());\n+        SomeClass mockTwo = factory.createMock(SomeClass.class, new MockAwareStub());\n+        \n+        Factory cglibFactoryOne = (Factory) mockOne;\n+        Factory cglibFactoryTwo = (Factory) mockTwo;\n+        \n+        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n+    }\n+    \n+    private interface SomeInterface {};\n+\n+    private class SomeClass {};\n+    private class ClassWithoutConstructor {};\n+    \n+    private class ClassWithDodgyConstructor {\n+        public ClassWithDodgyConstructor() {\n+            throw new RuntimeException();\n+        }\n+    };\n+    \n+    private final class MockAwareStub extends ObjectMethodsFilter {\n+        public MockAwareStub() {\n+            super(Object.class, null);\n+        }\n+\n+        public void setMock(Object mock) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationBuilder {\n+\n+    private String methodName = \"simpleMethod\";\n+    private int sequenceNumber = 0;\n+    private Object[] args = new Object[] {};\n+    private Object mock = \"mock\";\n+    private Method method;\n+\n+    public Invocation toInvocation() {\n+        if (method != null) {\n+            return new Invocation(mock, method, args, sequenceNumber);\n+        }\n+        \n+        Method m;\n+        List<Class> argTypes = new LinkedList<Class>();\n+        for (Object arg : args) {\n+            if (arg == null) {\n+                argTypes.add(Object.class);\n+            } else {\n+                argTypes.add(arg.getClass());\n+            }\n+        }\n+        \n+        try {\n+            m = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\n+        }\n+        return new Invocation(mock, m, args, sequenceNumber);\n+    }\n+\n+    public InvocationBuilder method(String methodName) {\n+        this.methodName  = methodName;\n+        return this;\n+    }\n+\n+    public InvocationBuilder seq(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+        return this;\n+    }\n+\n+    public InvocationBuilder args(Object ... args) {\n+        this.args = args;\n+        return this;\n+    }\n+\n+    public InvocationBuilder mock(Object mock) {\n+        this.mock = mock;\n+        return this;\n+    }\n+\n+    public InvocationBuilder method(Method method) {\n+        this.method = method;\n+        return this;\n+    }\n+\n+    public InvocationMatcher toInvocationMatcher() {\n+        return new InvocationMatcher(toInvocation());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationChunkTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationChunk;\n+\n+public class InvocationChunkTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldMarkAllAsVerified() throws Exception {\n+        Invocation i = new InvocationBuilder().toInvocation();\n+        Invocation i2 = new InvocationBuilder().toInvocation();\n+        \n+        InvocationChunk chunk = new InvocationChunk(i);\n+        chunk.add(i2);\n+        \n+        chunk.markAllInvocationsAsVerified();\n+        \n+        assertTrue(i.isVerified());\n+        assertTrue(i.isVerifiedInOrder());\n+        \n+        assertTrue(i2.isVerified());\n+        assertTrue(i2.isVerifiedInOrder());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.matchers.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationMatcherTest extends RequiresValidState {\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldScreamWhenMatchersNull() throws Exception {\n+        new InvocationMatcher(new InvocationBuilder().toInvocation(), null);\n+    }\n+    \n+    @Test\n+    public void shouldBeACitizenOfHashes() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n+        \n+        Map map = new HashMap();\n+        map.put(new InvocationMatcher(invocation), \"one\");\n+        map.put(new InvocationMatcher(invocationTwo), \"two\");\n+        \n+        assertEquals(2, map.size());\n+    }\n+    \n+    @Test\n+    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n+        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n+        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n+\n+        assertFalse(withOneArg.equals(null));\n+        assertFalse(withOneArg.equals(withTwoArgs));\n+    }\n+    \n+    @Test\n+    public void shouldToStringWithMatchers() throws Exception {\n+        IArgumentMatcher m = NotNull.NOT_NULL;\n+        InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));\n+        IArgumentMatcher mTwo = new Equals('x');\n+        InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));\n+\n+        assertEquals(\"Object.simpleMethod(notNull())\", notNull.toString());\n+        assertEquals(\"Object.simpleMethod('x')\", equals.toString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationTest extends RequiresValidState {\n+\n+    private Invocation invocation;\n+\n+    @Before\n+    public void setup() throws SecurityException, NoSuchMethodException {\n+        invocation = new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+    }\n+\n+    @Test\n+    public void shouldKnowIfIsEqualTo() {\n+        Invocation equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+        Invocation nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n+        Invocation withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n+\n+        assertFalse(invocation.equals(null));\n+        assertFalse(invocation.equals(\"\"));\n+        assertTrue(invocation.equals(equal));\n+        assertFalse(invocation.equals(nonEqual));\n+        assertTrue(invocation.equals(withNewStringInstance));\n+    }\n+    \n+    @Test\n+    public void shouldEqualToNotConsiderSequenceNumber() {\n+        Invocation equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        \n+        assertTrue(invocation.equals(equal));\n+        assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());\n+    }\n+    \n+    @Test\n+    public void shouldNotBeACitizenOfHashes() {\n+        Map map = new HashMap();\n+        try {\n+            map.put(invocation, \"one\");\n+            fail();\n+        } catch (RuntimeException e) {\n+            assertEquals(\"hashCode() is not implemented\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodName() {\n+        invocation = new InvocationBuilder().toInvocation();\n+        assertEquals(\"Object.simpleMethod()\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodArgs() {\n+        invocation = new InvocationBuilder().args(\"foo\").toInvocation();\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\")\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodIntegerArgAndString() {\n+        invocation = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1)\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintNull() {\n+        invocation = new InvocationBuilder().args((String)null).toInvocation();\n+        assertEquals(\"Object.simpleMethod(null)\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintArray() {\n+        invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] {1,2,3}).toInvocation();\n+        assertEquals(\"Object.oneArray([1, 2, 3])\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintNullIfArrayIsNull() throws Exception {\n+        Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n+        invocation = new InvocationBuilder().method(m).args((Object)null).toInvocation();\n+        assertEquals(\"Object.oneArray(null)\", invocation.toString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/state/MockitoStateImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+\n+public class MockitoStateImplTest extends RequiresValidState {\n+\n+    private MockitoState mockitoState;\n+\n+    @Before\n+    public void setup() {\n+        mockitoState = new MockitoStateImpl();\n+    }\n+    \n+    @Test\n+    public void shouldSwitchVerifyingMode() throws Exception {\n+        assertNull(mockitoState.pullVerifyingMode());\n+        \n+        OngoingVerifyingMode mode = OngoingVerifyingMode.times(19);\n+        \n+        mockitoState.verifyingStarted(mode);\n+        \n+        assertSame(mode, mockitoState.pullVerifyingMode());\n+    }\n+    \n+    @Test\n+    public void shouldCheckIfVerificationWasFinished() throws Exception {\n+        mockitoState.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+        try {\n+            mockitoState.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/state/OngoingVerifyingModeTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.state;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+\n+public class OngoingVerifyingModeTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n+        OngoingVerifyingMode mode = OngoingVerifyingMode.atLeastOnce();\n+        assertTrue(mode.atLeastOnceMode());\n+        \n+        mode = OngoingVerifyingMode.times(50);\n+        assertFalse(mode.atLeastOnceMode());\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            OngoingVerifyingMode.times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/EmptyReturnValuesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.stubbing.EmptyReturnValues;\n+\n+public class EmptyReturnValuesTest extends RequiresValidState {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n+        assertTrue(((Collection)EmptyReturnValues.emptyValueFor(Collection.class)).isEmpty());\n+        \n+        assertTrue(((Set)EmptyReturnValues.emptyValueFor(Set.class)).isEmpty());\n+        assertTrue(((SortedSet)EmptyReturnValues.emptyValueFor(SortedSet.class)).isEmpty());\n+        assertTrue(((HashSet)EmptyReturnValues.emptyValueFor(HashSet.class)).isEmpty());\n+        assertTrue(((TreeSet)EmptyReturnValues.emptyValueFor(TreeSet.class)).isEmpty());\n+        assertTrue(((LinkedHashSet)EmptyReturnValues.emptyValueFor(LinkedHashSet.class)).isEmpty());        \n+\n+        assertTrue(((List)EmptyReturnValues.emptyValueFor(List.class)).isEmpty());\n+        assertTrue(((ArrayList)EmptyReturnValues.emptyValueFor(ArrayList.class)).isEmpty());\n+        assertTrue(((LinkedList)EmptyReturnValues.emptyValueFor(LinkedList.class)).isEmpty());\n+        \n+        assertTrue(((Map)EmptyReturnValues.emptyValueFor(Map.class)).isEmpty());\n+        assertTrue(((SortedMap)EmptyReturnValues.emptyValueFor(SortedMap.class)).isEmpty());\n+        assertTrue(((HashMap)EmptyReturnValues.emptyValueFor(HashMap.class)).isEmpty());\n+        assertTrue(((TreeMap)EmptyReturnValues.emptyValueFor(TreeMap.class)).isEmpty());\n+        assertTrue(((LinkedHashMap)EmptyReturnValues.emptyValueFor(LinkedHashMap.class)).isEmpty());\n+        \n+        assertNull(EmptyReturnValues.emptyValueFor(String.class));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n+package org.mockito.internal.stubbing;\n+\n+import static org.junit.Assert.*;\n+\n+import java.nio.charset.CharacterCodingException;\n+\n+import org.junit.*;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.state.MockitoStateImpl;\n+import org.mockito.internal.stubbing.Stubber;\n+\n+public class StubberTest extends RequiresValidState{\n+\n+    private Stubber stubber;\n+    private MockitoStateImpl state;\n+    private Invocation simpleMethod;\n+    \n+    @Before\n+    public void setup() {\n+        state = new MockitoStateImpl();\n+        \n+        stubber = new Stubber(state);\n+        stubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        \n+        simpleMethod = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+    }\n+\n+    @Test\n+    public void shouldFinishStubbingBeforeValidatingThrowable() throws Exception {\n+        state.stubbingStarted();\n+        try {\n+            stubber.addThrowable(new Exception());\n+            fail();\n+        } catch (MockitoException e) {\n+            state.validateState();\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFinishStubbingOnAddingReturnValue() throws Exception {\n+        state.stubbingStarted();\n+        stubber.addReturnValue(\"test\");\n+        state.validateState();\n+    }\n+    \n+    @Test\n+    public void shouldGetResultsForMethods() throws Throwable {\n+        stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        stubber.addReturnValue(\"simpleMethod\");\n+        \n+        Invocation differentMethod = new InvocationBuilder().method(\"differentMethod\").toInvocation();\n+        stubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        stubber.addThrowable(new MyException());\n+        \n+        assertEquals(\"simpleMethod\", stubber.resultFor(simpleMethod));\n+        \n+        try {\n+            stubber.resultFor(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldGetEmptyResultIfMethodsDontMatch() throws Throwable {\n+        stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        stubber.addReturnValue(\"simpleMethod\");\n+        \n+        Invocation differentMethod = new InvocationBuilder().method(\"differentMethod\").toInvocation();\n+        \n+        assertEquals(null, stubber.resultFor(differentMethod));\n+    }\n+    \n+    @Test\n+    public void shouldAddThrowableForVoidMethod() throws Throwable {\n+        stubber.addThrowableForVoidMethod(new MyException());\n+        stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));\n+        \n+        try {\n+            stubber.resultFor(simpleMethod);\n+            fail();\n+        } catch (MyException e) {};\n+    }\n+    \n+    @Test\n+    public void shouldValidateThrowableForVoidMethod() throws Throwable {\n+        stubber.addThrowableForVoidMethod(new Exception());\n+        \n+        try {\n+            stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));\n+            fail();\n+        } catch (MockitoException e) {};\n+    }\n+    \n+    @Test\n+    public void shouldValidateNullThrowable() throws Throwable {\n+        try {\n+            stubber.addThrowable(null);\n+            fail();\n+        } catch (MockitoException e) {};\n+    }\n+    \n+    @Test\n+    public void shouldLetSettingProperCheckedException() throws Throwable {\n+        stubber.setInvocationForPotentialStubbing(new InvocationBuilder().method(\"canThrowException\").toInvocationMatcher());\n+        stubber.addThrowable(new CharacterCodingException());\n+    }\n+    \n+    @SuppressWarnings(\"serial\") class MyException extends RuntimeException {};\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+\n+import org.junit.*;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n+\n+    private NumberOfInvocationsVerifier verifier;\n+    \n+    @Before\n+    public void setup() {\n+        verifier = new NumberOfInvocationsVerifier();\n+    }\n+\n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n+        OngoingVerifyingMode inOrder = OngoingVerifyingMode.inOrder(1, Arrays.asList(new Object()));\n+        assertTrue(inOrder.orderOfInvocationsMatters());\n+        \n+        verifier.verify(null, null, inOrder);\n+    }\n+    \n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n+        OngoingVerifyingMode inOrder = OngoingVerifyingMode.atLeastOnce();\n+        \n+        verifier.verify(null, null, inOrder);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.EMPTY_LIST;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.state.OngoingVerifyingMode.*;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationChunk;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.verification.RegisteredInvocations;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class RegisteredInvocationsTest extends RequiresValidState {\n+\n+    private RegisteredInvocations registered;\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+    private Invocation simpleMethodInvocationThree;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n+        \n+        registered = new RegisteredInvocations(new InvocationsFinder() {\n+            public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n+                return Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation, simpleMethodInvocationThree) ;\n+            }});\n+        \n+        registered.add(simpleMethodInvocation);\n+        registered.add(simpleMethodInvocationTwo);\n+        registered.add(differentMethodInvocation);\n+        registered.add(simpleMethodInvocationThree);\n+    }\n+\n+    @Test\n+    public void shouldAskInvocationFinderForAllInvocations() throws Exception {\n+        final List<Object> dummyMocks = asList(new Object(), new Object());\n+        final StringBuilder s = new StringBuilder();\n+        \n+        registered = new RegisteredInvocations(new InvocationsFinder() {\n+            public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n+                s.append(\"InvocationsFinder was asked\");\n+                assertSame(dummyMocks, mocks);\n+                return EMPTY_LIST;\n+            }});\n+        \n+        registered.unverifiedInvocationChunks(inOrder(null, dummyMocks));\n+        assertEquals(\"InvocationsFinder was asked\", s.toString());\n+    }    \n+    \n+    @Test\n+    public void shouldGetUnverifiedInvocationChunks() throws Exception {\n+        Object mock = new Object();\n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n+        \n+        assertEquals(3, chunks.size());\n+        \n+        InvocationChunk firstChunk = chunks.get(0);\n+        assertEquals(2, firstChunk.getCount());\n+        assertEquals(simpleMethodInvocation, firstChunk.getInvocation());\n+        assertEquals(simpleMethodInvocationTwo, firstChunk.getInvocation());\n+        \n+        InvocationChunk secondChunk = chunks.get(1);\n+        assertEquals(1, secondChunk.getCount());\n+        assertEquals(differentMethodInvocation, secondChunk.getInvocation());\n+        \n+        InvocationChunk thirdChunk = chunks.get(2);\n+        assertEquals(1, thirdChunk.getCount());\n+        assertEquals(simpleMethodInvocationThree, thirdChunk.getInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldGetTwoUnverifiedInvocationChunks() throws Exception {\n+        Object mock = new Object();\n+        \n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        \n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n+        \n+        assertEquals(2, chunks.size());\n+        \n+        InvocationChunk firstChunk = chunks.get(0);\n+        assertEquals(1, firstChunk.getCount());\n+        assertEquals(differentMethodInvocation, firstChunk.getInvocation());\n+        \n+        InvocationChunk secondChunk = chunks.get(1);\n+        assertEquals(1, secondChunk.getCount());\n+        assertEquals(simpleMethodInvocationThree, secondChunk.getInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldGetOneUnverifiedInvocationChunk() throws Exception {\n+        Object mock = new Object();\n+        \n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(differentMethodInvocation), inOrder(null, asList(mock)));\n+        \n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n+        \n+        assertEquals(1, chunks.size());\n+        \n+        InvocationChunk firstChunk = chunks.get(0);\n+        assertEquals(1, firstChunk.getCount());\n+        assertEquals(simpleMethodInvocationThree, firstChunk.getInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldNotGetAnyInvocationChunks() throws Exception {\n+        Object mock = new Object();\n+        \n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(differentMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        \n+        List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n+        \n+        assertEquals(0, chunks.size());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllsimpleMethodAsVerified() throws Exception {\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation),times(2));\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllsimpleMethodAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), times(0));\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(false, invocations.get(0).isVerified());\n+        assertEquals(false, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromFirstChunk() throws Exception {\n+        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        assertTrue(mode.orderOfInvocationsMatters());\n+        registered.markInvocationsAsVerified(new InvocationMatcher(null), mode);\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(0).isVerifiedInOrder());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(true, invocations.get(1).isVerifiedInOrder());\n+        \n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromSecondChunk() throws Exception {\n+        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        assertTrue(mode.orderOfInvocationsMatters());\n+        \n+        Invocation doesntMatter = null;\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(2).isVerifiedInOrder());\n+        \n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromThirdChunk() throws Exception {\n+        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        assertTrue(mode.orderOfInvocationsMatters());\n+        \n+        Invocation doesntMatter = null;\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        \n+        List<Invocation> invocations = registered.all();\n+        assertEquals(true, invocations.get(3).isVerified());\n+        assertEquals(true, invocations.get(3).isVerifiedInOrder());\n+    }\n+    \n+    @Test\n+    public void shouldRemoveLastInvocation() throws Exception {\n+        registered.removeLast();\n+        assertEquals(3, registered.all().size());\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUnverifiedInvocation() throws Exception {\n+        assertSame(simpleMethodInvocation, registered.getFirstUnverified());\n+        \n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertSame(differentMethodInvocation, registered.getFirstUnverified());\n+        \n+        registered.markInvocationsAsVerified(new InvocationMatcher(differentMethodInvocation), atLeastOnce());\n+        assertNull(registered.getFirstUnverified());\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(0));\n+        HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(1));\n+        HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsTwo() throws Exception {\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(2));\n+        HasStackTrace expected = simpleMethodInvocationThree.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+}\n--- a/test/org/mockitousage/InvalidUsageTest.java\n+++ b/test/org/mockitousage/InvalidUsageTest.java\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n-        stub(mock.simpleMethod()).andThrows(new Exception());\n+        stub(mock.simpleMethod()).andThrow(new Exception());\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowable() throws Exception {\n-        stub(mock.simpleMethod()).andThrows(null);\n+        stub(mock.simpleMethod()).andThrow(null);\n     }    \n }\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n \n import org.junit.Test;\n import org.junit.runner.*;\n-import org.junit.runner.Result;\n import org.junit.runner.notification.Failure;\n import org.mockito.*;\n import org.mockito.exceptions.parents.*;\n import org.mockito.internal.*;\n+import org.mockito.internal.creation.CglibTest;\n+import org.mockito.internal.creation.MockFactoryTest;\n+import org.mockito.internal.invocation.InvocationChunkTest;\n+import org.mockito.internal.invocation.InvocationMatcherTest;\n+import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n+import org.mockito.internal.state.MockitoStateImplTest;\n+import org.mockito.internal.state.OngoingVerifyingModeTest;\n+import org.mockito.internal.stubbing.EmptyReturnValuesTest;\n+import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n+import org.mockito.internal.verification.RegisteredInvocationsTest;\n import org.mockitousage.binding.*;\n import org.mockitousage.matchers.*;\n import org.mockitousage.sample.MockitoSampleTest;\n                     MockitoStateImplTest.class, \n                     RegisteredInvocationsTest.class, \n                     EmptyReturnValuesTest.class, \n-                    VerifyingModeTest.class, \n+                    OngoingVerifyingModeTest.class, \n                     InvocationTest.class, \n                     MockUtilTest.class, \n                     MockitoAssertionErrorTest.class, \n--- a/test/org/mockitousage/StackTrackeFilteringTest.java\n+++ b/test/org/mockitousage/StackTrackeFilteringTest.java\n     @Test\n     public void shouldFilterStackTraceWhenThrowingExceptionFromControl() {\n         try {\n-            stub(mock.oneArg(true)).andThrows(new Exception());\n+            stub(mock.oneArg(true)).andThrow(new Exception());\n             fail();\n         } catch (MockitoException expected) {\n             assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromControl\"));\n     \n     @Test\n     public void shouldShowProperExceptionStackTrace() throws Exception {\n-        stub(mock.simpleMethod()).andThrows(new RuntimeException());\n+        stub(mock.simpleMethod()).andThrow(new RuntimeException());\n \n         try {\n             mock.simpleMethod();\n--- a/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n+++ b/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n     public void shouldStubUsingMatchers() {\n         stub(one.simpleMethod(2)).andReturn(\"2\");\n         stub(two.simpleMethod(anyString())).andReturn(\"any\");\n-        stub(three.simpleMethod(startsWith(\"test\"))).andThrows(new RuntimeException());\n+        stub(three.simpleMethod(startsWith(\"test\"))).andThrow(new RuntimeException());\n \n         assertEquals(null, one.simpleMethod(1));\n         assertEquals(\"2\", one.simpleMethod(2));\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n     \n     @Test\n     public void shouldStubbingWithThrowableFailVerification() {\n-        stub(mock.simpleMethod(\"one\")).andThrows(new RuntimeException());\n+        stub(mock.simpleMethod(\"one\")).andThrow(new RuntimeException());\n         stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod(\"two\");\n         \n         verifyZeroInteractions(mock);\n--- a/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n     @Test\n     public void shouldStubWithThrowable() throws Exception {\n         IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n-        stub(mock.add(\"throw\")).andThrows(expected);\n+        stub(mock.add(\"throw\")).andThrow(expected);\n         \n         try {\n             mock.add(\"throw\");\n     \n     @Test\n     public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {\n-        stub(mock.get(1)).andThrows(new ExceptionOne());\n+        stub(mock.get(1)).andThrow(new ExceptionOne());\n         \n         try {\n-            stub(mock.get(1)).andThrows(new ExceptionTwo());\n+            stub(mock.get(1)).andThrow(new ExceptionTwo());\n             fail();\n         } catch (ExceptionOne e) {}\n     }   \n         Reader reader = mock(Reader.class);\n         IOException ioException = new IOException();\n         \n-        stub(reader.read()).andThrows(ioException);\n+        stub(reader.read()).andThrow(ioException);\n         \n         try {\n             reader.read();\n     public void shouldAllowSettingError() throws Exception {\n         Error error = new Error();\n         \n-        stub(mock.add(\"quake\")).andThrows(error);\n+        stub(mock.add(\"quake\")).andThrow(error);\n         \n         try {\n             mock.add(\"quake\");\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n-        stub(mock.add(\"monkey island\")).andThrows(new Exception());\n+        stub(mock.add(\"monkey island\")).andThrow(new Exception());\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowable() throws Exception {\n-        stub(mock.add(\"monkey island\")).andThrows(null);\n+        stub(mock.add(\"monkey island\")).andThrow(null);\n     }    \n     \n     @Test\n     public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n-        stub(mock.add(\"ExceptionOne\")).andThrows(new ExceptionOne());\n+        stub(mock.add(\"ExceptionOne\")).andThrow(new ExceptionOne());\n         stub(mock.getLast()).andReturn(\"last\");\n         stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();\n         \n         stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();\n-        stub(mockTwo.containsValue(\"ExceptionFour\")).andThrows(new ExceptionFour());\n+        stub(mockTwo.containsValue(\"ExceptionFour\")).andThrow(new ExceptionFour());\n         stub(mockTwo.get(\"Are you there?\")).andReturn(\"Yes!\");\n \n         assertNull(mockTwo.get(\"foo\"));\n     \n     @Test\n     public void shouldStubbingWithThrowableBeVerifiable() {\n-        stub(mock.size()).andThrows(new RuntimeException());\n+        stub(mock.size()).andThrow(new RuntimeException());\n         stubVoid(mock).toThrow(new RuntimeException()).on().clone();\n         \n         try {\n     \n     @Test\n     public void shouldStubbingWithThrowableFailVerification() {\n-        stub(mock.size()).andThrows(new RuntimeException());\n+        stub(mock.size()).andThrow(new RuntimeException());\n         stubVoid(mock).toThrow(new RuntimeException()).on().clone();\n         \n         verifyZeroInteractions(mock);", "timestamp": 1197406924, "metainfo": ""}