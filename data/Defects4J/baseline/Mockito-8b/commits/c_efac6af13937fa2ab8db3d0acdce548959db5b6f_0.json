{"sha": "efac6af13937fa2ab8db3d0acdce548959db5b6f", "log": "added documentation  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40222", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n \n-@SuppressWarnings(\"unchecked\")\n+/**\n+ * Enables mock objects creation, verification and stubbing.\n+ * \n+ * <h3>Let's verify!</h3>\n+ * \n+ * <pre>\n+ * //Let's import Mockito statically so that code looks clearer\n+ * import static org.mockito.Mockito.*;\n+ * \n+ * //mock creation\n+ * List mockedList = mock(List.class);\n+ * \n+ * //using mock object\n+ * mockedList.add(\"one\");\n+ * mockedList.clear();\n+ * \n+ * //verification\n+ * verify(mockedList).add(\"one\");\n+ * verify(mockedList).clear();\n+ * </pre>\n+ * \n+ * <p>\n+ * Once created, mock object will record all invocations. Then you can\n+ * selectively verify whatever interaction you are interested in.\n+ * \n+ * <h3>How about some stubbing?</h3>\n+ * \n+ * <pre>\n+ * //You can create mocks of concrete classes, not only interfaces\n+ * LinkedList mockedList = mock(LinkedList.class);\n+ * \n+ * //stubbing\n+ * stub(mockedList.get(0)).andReturn(\"first\");\n+ * stub(mockedList.get(1)).andReturn(\"second\");\n+ * stub(mockedList.get(2)).andThrow(new RuntimeException());\n+ * \n+ * //following prints \"first\"\n+ * System.out.println(mockedList.get(0));\n+ * \n+ * //following prints \"second\" three times\n+ * System.out.println(mockedList.get(1));\n+ * System.out.println(mockedList.get(1));\n+ * System.out.println(mockedList.get(1));\n+ * \n+ * //following throws runtime exception\n+ * System.out.println(mockedList.get(2));\n+ * \n+ * //following prints \"null\"\n+ * System.out.println(mockedList.get(999));\n+ * \n+ * //if you want you can still verify stubbed invocation\n+ * verify(mockedList.get(0));\n+ * </pre>\n+ * \n+ * <p>\n+ * Once stubbed, mock object will always return stubbed value regardless of how many times it is called. \n+ * <p>\n+ * By default, for all methods that return value mock object will return null,\n+ * appropriate primitive value (0, false, etc.) or empty collection. \n+ * \n+ * <h3>Argument matchers</h3>\n+ * \n+ * <pre>\n+ *  //stubbing using anyInt() argument matcher\n+ *  stub(mockedList.get(anyInt())).andReturn(\"element\");\n+ *  \n+ *  //following prints \"element\"\n+ *  System.out.println(mockedList.get(999));\n+ *  \n+ *  //you can also verify using argument matcher\n+ *  verify(mockedList).get(anyInt());\n+ * </pre>\n+ * \n+ * <p>\n+ * Argument matchers allow less constrained verification or stubbing. Link to argument matchers documentation needed.\n+ * \n+ * <h3>Exact number of invocations verification</h3>\n+ *\n+ *<pre>\n+ *  //using mock \n+ *  mockedList.add(\"once\");\n+ *  \n+ *  mockedList.add(\"twice\");\n+ *  mockedList.add(\"twice\");\n+ *  \n+ *  mockedList.add(\"three times\");\n+ *  mockedList.add(\"three times\");\n+ *  mockedList.add(\"three times\");\n+ *  \n+ *  //following two verifications work exactly the same\n+ *  verify(mockedList, times(1)).add(\"once\");\n+ *  verify(mockedList).add(\"once\");\n+ *  \n+ *  //exact number of invocation verification\n+ *  verify(mockedList, times(2)).add(\"twice\");\n+ *  verify(mockedList, times(3)).add(\"three times\");\n+ *  \n+ *  //verification using atLeastOnce()\n+ *  verify(mockedList, atLeastOnce()).add(\"three times\");\n+ * </pre>\n+ * \n+ * <p>\n+ * If times(x) is not given times(1) is assumed. Therefore using times(1) explicitly should be omitted.\n+ * \n+ * <h3>Stubbing void methods with exceptions</h3>\n+ * \n+ * <pre>\n+ *   stubVoid(mockedList).toThrow(new RuntimeException()).on().clear();\n+ *   \n+ *   //following throws exception\n+ *   mockedList.clear();\n+ * </pre>\n+ *\n+ * <h3>Finding redundant invocations</h3>\n+ * \n+ * <pre>\n+ *   //using mocks\n+ *   mockedList.add(\"one\");\n+ *   mockedList.add(\"two\");\n+ *   \n+ *   verify(mockedList).add(\"one\");\n+ *   \n+ *   //following verification will fail \n+ *   verifyNoMoreInteractions(mockedList);\n+ * </pre>\n+ * \n+ * See more {@link Mockito.verifyNoMoreInteractions}\n+ * \n+ * <h3>Strict order verification</h3>\n+ * \n+ * <pre>\n+ *   List mockOne = mock(List.class);\n+ *   List mockTwo = mock(List.class);\n+ *   \n+ *   //using mocks\n+ *   mockOne.add(\"one\");\n+ *   mockTwo.add(\"two\");\n+ *   \n+ *   //create strict verifier \n+ *   Strictly strictly = createStrictOrderVerifier(mockOne, mockTwo);\n+ *   \n+ *   //following will make sure that mockOne was called before mockTwo\n+ *   strictly.verify(mockOne).add(\"one\");\n+ *   strictly.verify(mockTwo).add(\"two\");\n+ * </pre>\n+ * \n+ * <p>\n+ * Strict verification is required only in some cases and in most cases ordinary verification is enough. \n+ * \n+ * <h3>Making sure no interactions happened on mock</h3>\n+ * \n+ * <pre>\n+ *   //using mocks - only mockOne is interacted\n+ *   mockOne.add(\"one\");\n+ *   \n+ *   //ordinary verification\n+ *   verify(mockOne).add(\"one\");\n+ *   \n+ *   //other mocks should not be interacted\n+ *   verifyZeroInteractions(mockTwo, mockThree);\n+ *   \n+ *   //following works exactly the same as above\n+ *   verifyNoMoreInteractions(mockTwo, mockThree);\n+ * </pre>\n+ * \n+ * <p>\n+ * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but \n+ * the first one is more explicit and can read better.\n+ * \n+ */\n public class Mockito extends Matchers {\n \n     private static final Reporter REPORTER = new Reporter();\n     static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n \n+    /**\n+     * Creates mock object of given class or interface.\n+     * <p>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param classToMock\n+     * @return mock object\n+     */\n     public static <T> T mock(Class<T> classToMock) {\n         return MockUtil.createMock(classToMock, MOCKING_PROGRESS);\n     }\n \n+    /**\n+     * Stubs with return value or exception, e.g:\n+     * <pre>\n+     *   stub(mock.countElements()).andReturn(10);\n+     *   \n+     *   stub(mock.countElements()).andThrow(new RuntimeException());\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param methodCallToStub\n+     * @return\n+     */\n+    @SuppressWarnings(\"unchecked\")\n     public static <T> OngoingStubbing<T> stub(T methodCallToStub) {\n         MOCKING_PROGRESS.stubbingStarted();\n \n         return stubbable;\n     }\n \n+    /**\n+     * Verifies certain behavior, e.g:\n+     * <pre>\n+     *   verify(mock).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mock\n+     * @return\n+     */\n     public static <T> T verify(T mock) {\n         return verify(mock, times(1));\n     }\n \n+    /**\n+     * Verifies certain behavior happened exact number of times, e.g:\n+     * <pre>\n+     *   verify(mock, times(5)).someMethod(\"one\");\n+     *   \n+     *   verify(mock, atLeastOnce()).someMethod(\"two\");\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mock\n+     * @param mode\n+     * @return\n+     */\n     public static <T> T verify(T mock, VerificationMode mode) {\n         MockUtil.validateMock(mock);\n         MOCKING_PROGRESS.verificationStarted(mode);\n     }\n \n     /**\n-     * Throws an AssertionError if any of given mocks has any unverified interaction.\n+     * Throws an AssertionError if any of given mocks has any unverified\n+     * interaction.\n      * <p>\n      * Use this method after you verified your mocks - to make sure that nothing\n      * else was invoked on your mocks.\n      * <p>\n-     * It's a good pattern not to use this method in every test method.\n-     * Test methods should focus on different behavior/interaction\n-     * and it's not necessary to call verifyNoMoreInteractions() all the time\n+     * It's a good pattern not to use this method in every test method. Test\n+     * methods should focus on different behavior/interaction and it's not\n+     * necessary to call verifyNoMoreInteractions() all the time\n      * <p>\n      * Stubbed invocations are also treated as interactions.\n      * <p>\n      * Example:\n-     * <pre>\n-     *     //interactions\n-     *     mock.doSomething();\n-     *     mock.doSomethingUnexpected();\n-     *\n-     *     //verification\n-     *     verify(mock).doSomething();\n-     *\n-     *     verifyNoMoreInteractions(mock);\n-     *     //oups: 'doSomethingUnexpected()' is unexpected\n-     *</pre>\n-     *\n-     * @param mocks\n-     */\n-    public static void verifyNoMoreInteractions(Object ... mocks) {\n+     * \n+     * <pre>\n+     * //interactions\n+     * mock.doSomething();\n+     * mock.doSomethingUnexpected();\n+     * \n+     * //verification\n+     * verify(mock).doSomething();\n+     * verifyNoMoreInteractions(mock);\n+     * \n+     * //oups: 'doSomethingUnexpected()' is unexpected\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mocks to be verified\n+     */\n+    public static void verifyNoMoreInteractions(Object... mocks) {\n         assertMocksNotEmpty(mocks);\n         MOCKING_PROGRESS.validateState();\n         for (Object mock : mocks) {\n         }\n     }\n \n-    public static void verifyZeroInteractions(Object ... mocks) {\n+    /**\n+     * Verifies that no interactions happened on given mocks.\n+     * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but \n+     * the first one is more explicit and can read better.\n+     * <p>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mocks to be verified\n+     */\n+    public static void verifyZeroInteractions(Object... mocks) {\n         verifyNoMoreInteractions(mocks);\n     }\n \n         }\n     }\n \n+    /**\n+     * Stubs void method with exception, e.g:\n+     * <pre>\n+     *   stubVoid(mock).toThrow(new RuntimeException()).on().someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mock to stub\n+     * @return\n+     */\n     public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n         MockHandler<T> handler = MockUtil.getMockHandler(mock);\n         MOCKING_PROGRESS.stubbingStarted();\n         return handler;\n     }\n \n-    public static Strictly createStrictOrderVerifier(Object ... mocks) {\n+    /**\n+     * Creates strict verifier that allows verifying mocks in order.\n+     * <p>\n+     * See examples {@link Mockito}\n+     * \n+     * @param mocks to verified in strict order\n+     * @return\n+     */\n+    public static Strictly createStrictOrderVerifier(Object... mocks) {\n         if (mocks.length == 0) {\n             REPORTER.mocksHaveToBePassedWhenCreatingStrictly();\n         }\n         return strictOrderVerifier;\n     }\n \n+    /**\n+     * Allows at-least-once verification, e.g:\n+     * <pre>\n+     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @return\n+     */\n     public static VerificationMode atLeastOnce() {\n         return VerificationMode.atLeastOnce();\n     }\n \n+    /**\n+     * Allows exact number of invocations verification, e.g:\n+     * <pre>\n+     *   verify(mock, times(2)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param wantedNumberOfInvocations wanted number of invocations \n+     * @return\n+     */\n     public static VerificationMode times(int wantedNumberOfInvocations) {\n         return VerificationMode.times(wantedNumberOfInvocations);\n     }\n--- a/src/org/mockito/internal/progress/OngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n  */\n package org.mockito.internal.progress;\n \n+//TODO document exposed interfaces\n public interface OngoingStubbing<T> {\n \n     void andReturn(T value);\n--- a/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n     @Before\n     public void setUp() {\n         mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyExactNumberOfInvocationsUsingMatcher() {\n+        mock.simpleMethod(1);\n+        mock.simpleMethod(2);\n+        mock.simpleMethod(3);\n+        \n+        verify(mock, times(3)).simpleMethod(anyInt());\n     }\n \n     @Test", "timestamp": 1197846468, "metainfo": ""}