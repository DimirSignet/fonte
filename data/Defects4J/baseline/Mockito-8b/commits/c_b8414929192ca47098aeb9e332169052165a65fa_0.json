{"sha": "b8414929192ca47098aeb9e332169052165a65fa", "log": "In order to put additional reflection classes in consistent folder I did some package rename job  --HG-- rename : src/org/mockito/internal/util/copy/AccessibilityChanger.java => src/org/mockito/internal/util/reflection/AccessibilityChanger.java rename : src/org/mockito/internal/util/copy/FieldCopier.java => src/org/mockito/internal/util/reflection/FieldCopier.java rename : src/org/mockito/internal/util/copy/LenientCopyTool.java => src/org/mockito/internal/util/reflection/LenientCopyTool.java rename : src/org/mockito/internal/util/copy/package.html => src/org/mockito/internal/util/reflection/package.html rename : test/org/mockito/internal/util/copy/LenientCopyToolTest.java => test/org/mockito/internal/util/reflection/LenientCopyToolTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401551", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/AccessibilityChanger.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Field;\n+\n+public class AccessibilityChanger {\n+    \n+    private Boolean wasAccessible = null;\n+\n+    /**\n+     * safely disables access\n+     */\n+    public void safelyDisableAccess(Field field) {\n+        assert wasAccessible != null;\n+        try {\n+            field.setAccessible(wasAccessible);\n+        } catch (Throwable t) {\n+            //ignore\n+        }\n+    }\n+\n+    /**\n+     * changes the field accessibility and returns true if accessibility was changed\n+     */\n+    public void enableAccess(Field field) {\n+        wasAccessible = field.isAccessible();\n+        field.setAccessible(true);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/FieldCopier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Field;\n+\n+public class FieldCopier {\n+\n+    public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {\n+        Object value = field.get(from);\n+        field.set(to, value);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/LenientCopyTool.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class LenientCopyTool {\n+\n+    FieldCopier fieldCopier = new FieldCopier();\n+\n+    public <T> void copyToMock(T from, T mock) {\n+        Class clazz = from.getClass();\n+        Class mockSuperClass = mock.getClass().getSuperclass();\n+        assert mockSuperClass == clazz \n+            : \"Classes must have the same type: class of the object from: \" + clazz + \", mock super class: \" + mockSuperClass;\n+\n+        while (clazz != Object.class) {\n+            copyValues(from, mock, clazz);\n+            clazz = clazz.getSuperclass();\n+        }\n+    }\n+\n+    private <T> void copyValues(T from, T mock, Class classFrom) {\n+        Field[] fields = classFrom.getDeclaredFields();\n+\n+        for (int i = 0; i < fields.length; i++) {\n+            // ignore static fields\n+            Field field = fields[i];\n+            if (Modifier.isStatic(field.getModifiers())) {\n+                continue;\n+            }\n+            AccessibilityChanger accessibilityChanger = new AccessibilityChanger();\n+            try {\n+                accessibilityChanger.enableAccess(field);\n+                fieldCopier.copyValue(from, mock, field);\n+            } catch (Throwable t) {\n+                //Ignore - be lenient - if some field cannot be copied then let's be it\n+            } finally {\n+                accessibilityChanger.safelyDisableAccess(field);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.lang.reflect.Field;\n+import java.util.LinkedList;\n+\n+import org.junit.Test;\n+import org.mockito.internal.util.reflection.FieldCopier;\n+import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class LenientCopyToolTest extends TestBase {\n+\n+    private LenientCopyTool tool = new LenientCopyTool();\n+\n+    static class InheritMe {\n+        protected String protectedInherited = \"protected\";\n+        private String privateInherited = \"private\";\n+    }\n+    \n+    static class SomeObject extends InheritMe {\n+        @SuppressWarnings(\"unused\") \n+        // required because static fields needs to be excluded from copying \n+        private static int staticField = -100;\n+        private int privateField = -100;\n+        private transient int privateTransientField = -100;\n+        String defaultField = \"-100\";\n+        protected Object protectedField = new Object();\n+        public SomeOtherObject instancePublicField = new SomeOtherObject();\n+        final int finalField;\n+\n+        public SomeObject(int finalField) {\n+            this.finalField = finalField;\n+        }\n+    }\n+\n+    static class SomeOtherObject {\n+    }\n+\n+    private SomeObject from = new SomeObject(100);\n+    private SomeObject to = mock(SomeObject.class);\n+\n+    @Test\n+    public void shouldShallowCopyBasicFinalField() throws Exception {\n+        // given\n+        assertEquals(100, from.finalField);\n+        assertNotEquals(100, to.finalField);\n+\n+        // when\n+        tool.copyToMock(from, to);\n+\n+        // then\n+        assertEquals(100, to.finalField);\n+    }\n+\n+    @Test\n+    public void shouldShallowCopyTransientPrivateFields() throws Exception {\n+        // given\n+        from.privateTransientField = 1000;\n+        assertNotEquals(1000, to.privateTransientField);\n+\n+        // when\n+        tool.copyToMock(from, to);\n+\n+        // then\n+        assertEquals(1000, to.privateTransientField);\n+    }\n+\n+    @Test\n+    public void shouldShallowCopyLinkedListIntoMock() throws Exception {\n+        // given\n+        LinkedList fromList = new LinkedList();\n+        LinkedList toList = mock(LinkedList.class);\n+\n+        // when\n+        tool.copyToMock(fromList, toList);\n+\n+        // then no exception is thrown\n+    }\n+\n+    @Test\n+    public void shouldShallowCopyFieldValuesIntoMock() throws Exception {\n+        // given\n+        from.defaultField = \"foo\";\n+        from.instancePublicField = new SomeOtherObject();\n+        from.privateField = 1;\n+        from.privateTransientField = 2;\n+        from.protectedField = 3;\n+        \n+        assertNotEquals(from.defaultField, to.defaultField);\n+        assertNotEquals(from.instancePublicField, to.instancePublicField);\n+        assertNotEquals(from.privateField, to.privateField);\n+        assertNotEquals(from.privateTransientField, to.privateTransientField);\n+        assertNotEquals(from.protectedField, to.protectedField);\n+\n+        // when\n+        tool.copyToMock(from, to);\n+\n+        // then\n+        assertEquals(from.defaultField, to.defaultField);\n+        assertEquals(from.instancePublicField, to.instancePublicField);\n+        assertEquals(from.privateField, to.privateField);\n+        assertEquals(from.privateTransientField, to.privateTransientField);\n+        assertEquals(from.protectedField, to.protectedField);\n+    }\n+    \n+    @Test\n+    public void shouldCopyValuesOfInheritedFields() throws Exception {\n+        //given\n+        ((InheritMe) from).privateInherited = \"foo\";\n+        ((InheritMe) from).protectedInherited = \"bar\";\n+    \n+        assertNotEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+        assertNotEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then\n+        assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+        assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+    }\n+    \n+    @Test\n+    public void shouldEnableAndThenDisableAccessibility() throws Exception {\n+        //given\n+        Field privateField = SomeObject.class.getDeclaredField(\"privateField\");\n+        assertFalse(privateField.isAccessible());\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then\n+        privateField = SomeObject.class.getDeclaredField(\"privateField\");\n+        assertFalse(privateField.isAccessible());\n+    }\n+    \n+    @Test\n+    public void shouldContinueEvenIfThereAreProblemsCopyingSingleFieldValue() throws Exception {\n+        //given\n+        tool.fieldCopier = mock(FieldCopier.class);\n+        \n+        doNothing().\n+        doThrow(new IllegalAccessException()).\n+        doNothing().\n+        when(tool.fieldCopier).\n+        copyValue(anyObject(), anyObject(), any(Field.class));\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then\n+        verify(tool.fieldCopier, atLeast(3)).copyValue(any(), any(), any(Field.class));\n+    }\n+}", "timestamp": 1247139218, "metainfo": ""}