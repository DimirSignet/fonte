{"sha": "a4dbbb24520fc9f624a76e2aea60aee3d2ffc676", "log": "registered invocations are no longer InvocationWithMatchers  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4071", "commit": "\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n \n import java.lang.reflect.Method;\n \n-import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.*;\n \n public class Invocation {\n \n     private boolean verified;\n+    private int sequenceNumber;\n+    \n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n     }\n \n     public int hashCode() {\n-        throw new UnsupportedOperationException(\"hashCode() is not implemented\");\n+        return 1;\n     }\n \n     private boolean equalArguments(Object[] arguments) {\n         String mockName = Namer.nameForMock(mock);\n         return mockName + \".\" + method.getName();\n     }\n+    \n+    public String toString() {\n+        //TODO separate unit test?\n+        StringBuffer result = new StringBuffer();\n+        result.append(getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Object arg : this.arguments) {\n+            //TODO lil bit hacky way of using Equals matcher\n+            new Equals(arg).appendTo(result);\n+            result.append(\", \");\n+        }\n+        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n+    }\n+    \n+    public String toStringWithArgumentTypes() {\n+        //TODO separate unit test?\n+        StringBuilder result = new StringBuilder();\n+        result.append(getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Class<?> paramType : getMethod().getParameterTypes()) {\n+            result.append(paramType);\n+            result.append(\", \");\n+        } \n+        return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n+    }\n \n     public void markVerified() {\n         verified = true;\n     public boolean isVerified() {\n         return verified;\n     }\n+    \n+    public Integer getSequenceNumber() {\n+        return sequenceNumber;\n+    }\n+\n+    public void setSequenceNumber(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+    }\n }\n--- a/src/org/mockito/internal/InvocationWithMatchers.java\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n \n     protected final Invocation invocation;\n     private final List<IArgumentMatcher> matchers;\n-    private int sequenceNumber;\n \n     public InvocationWithMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n         this.invocation = invocation;\n     public Invocation getInvocation() {\n         return this.invocation;\n     }\n-\n-    public String toStringWithArgumentTypes() {\n-        StringBuilder result = new StringBuilder();\n-        result.append(invocation.getMockAndMethodName());\n-        result.append(\"(\");\n-        for (Class<?> paramType : invocation.getMethod().getParameterTypes()) {\n-            result.append(paramType);\n-            result.append(\", \");\n-        }\n-        return result.toString().replaceFirst(\", \", \"\").concat(\")\");\n-    }\n-\n-    public Integer getSequenceNumber() {\n-        return sequenceNumber;\n-    }\n-\n-    public void setSequenceNumber(int sequenceNumber) {\n-        this.sequenceNumber = sequenceNumber;\n-    }\n }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n         \n         mockitoState.reportLastControl(this);\n         \n-        invocationWithMatchers.setSequenceNumber(mockitoState.nextSequenceNumber());\n+        invocation.setSequenceNumber(mockitoState.nextSequenceNumber());\n         \n         behavior.addInvocation(invocationWithMatchers);\n         \n     }\n \n     private boolean isValidCheckedException(Throwable throwable) {\n-        Invocation lastInvocation = behavior.lastInvocation();\n+        //TODO move validation logic to behavior, so that we don't need to expose getInvocationForStubbing()\n+        Invocation lastInvocation = behavior.getInvocationForStubbing().getInvocation();\n \n         Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n         Class<?> throwableClass = throwable.getClass();\n         behavior.setMock(mock);\n     }\n \n-    public List<InvocationWithMatchers> getRegisteredInvocations() {\n+    public List<Invocation> getRegisteredInvocations() {\n         return behavior.getRegisteredInvocations();\n     }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n     private T mock;\n     \n-    private List<InvocationWithMatchers> registeredInvocations = new LinkedList<InvocationWithMatchers>();\n+    private List<Invocation> registeredInvocations = new LinkedList<Invocation>();\n     private Map<InvocationWithMatchers, Result> results = new HashMap<InvocationWithMatchers, Result>();\n+\n+    private InvocationWithMatchers invocationForStubbing;\n     \n     public void addInvocation(InvocationWithMatchers invocation) {\n-        this.registeredInvocations.add(invocation);\n+        this.registeredInvocations.add(invocation.getInvocation());\n+        this.invocationForStubbing = invocation;\n     }\n \n     public void addResult(Result result) {\n-        this.results.put(registeredInvocations.remove(registeredInvocations.size()-1), result);\n+        assert invocationForStubbing != null;\n+        registeredInvocations.remove(invocationForStubbing.getInvocation());\n+        this.results.put(invocationForStubbing, result);\n     }\n \n     public void verify(InvocationWithMatchers expected, VerifyingMode verifyingMode) {\n     \n     void markInvocationsAsVerified(InvocationWithMatchers expected, VerifyingMode verifyingMode) {\n         int verifiedSoFar = 0;        \n-        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n-            Invocation invocation = registeredInvocation.getInvocation();\n+        for (Invocation invocation : registeredInvocations) {\n             boolean shouldMarkAsVerified = \n                 verifyingMode.atLeastOnceMode() || verifyingMode.getExpectedNumberOfInvocations() >= verifiedSoFar;\n             if (expected.matches(invocation) && shouldMarkAsVerified) {\n \n     private void reportMissingInvocationError(InvocationWithMatchers invocation) throws VerificationAssertionError {\n         //TODO refactor message building somewhere else...\n-        InvocationWithMatchers similarInvocation = findSimilarInvocation(invocation);\n+        Invocation similarInvocation = findSimilarInvocation(invocation);\n         String message = \n             \"\\n\" +\n             \"Invocation differs from actual\" +\n         if (similarInvocation != null) {\n             String actual = similarInvocation.toString();\n             if (expected.equals(actual)) {\n-                expected = invocation.toStringWithArgumentTypes();\n+                expected = invocation.getInvocation().toStringWithArgumentTypes();\n                 actual = similarInvocation.toStringWithArgumentTypes();\n             }\n             \n             return;\n         }\n         \n-        Map<InvocationWithMatchers, Integer> sequenceOfInvocations = getSequenceOfInvocations(verifyingMode);\n-        InvocationWithMatchers firstUnverifiedInvocation = null;\n-        for (InvocationWithMatchers registered : sequenceOfInvocations.keySet()) {\n-            if (!registered.getInvocation().isVerified()) {\n+        Map<Invocation, Integer> sequenceOfInvocations = getSequenceOfInvocations(verifyingMode);\n+        Invocation firstUnverifiedInvocation = null;\n+        for (Invocation registered : sequenceOfInvocations.keySet()) {\n+            if (!registered.isVerified()) {\n                 firstUnverifiedInvocation = registered;\n             } else {\n                 break;\n         //TODO cover this scenario firstUnverified == null\n         assert firstUnverifiedInvocation != null;\n         \n-        if (!firstUnverifiedInvocation.matches(expected.getInvocation())) {\n+        if (!expected.matches(firstUnverifiedInvocation)) {\n             throw new StrictVerificationError();\n         }\n     }\n \n-    private Map<InvocationWithMatchers, Integer> getSequenceOfInvocations(VerifyingMode verifyingMode) {\n-        Set<InvocationWithMatchers> allInvocationsInOrder = new TreeSet<InvocationWithMatchers>(\n-                new Comparator<InvocationWithMatchers>(){\n-                    public int compare(InvocationWithMatchers o1, InvocationWithMatchers o2) {\n+    private Map<Invocation, Integer> getSequenceOfInvocations(VerifyingMode verifyingMode) {\n+        Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n+                new Comparator<Invocation>(){\n+                    public int compare(Invocation o1, Invocation o2) {\n                         int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n                         assert comparison != 0;\n                         return comparison;\n         \n         List<Object> allMocksToBeVerifiedInOrder = verifyingMode.getAllMocksToBeVerifiedInSequence();\n         for (Object mock : allMocksToBeVerifiedInOrder) {\n-            List<InvocationWithMatchers> invocations = MockUtil.getControl(mock).getRegisteredInvocations();\n+            List<Invocation> invocations = MockUtil.getControl(mock).getRegisteredInvocations();\n             allInvocationsInOrder.addAll(invocations);\n         }\n         \n-        Map<InvocationWithMatchers, Integer> sequenceOfInvocations = new LinkedHashMap<InvocationWithMatchers, Integer>();\n-        for (InvocationWithMatchers i : allInvocationsInOrder) {\n+        Map<Invocation, Integer> sequenceOfInvocations = new LinkedHashMap<Invocation, Integer>();\n+        for (Invocation i : allInvocationsInOrder) {\n             if (sequenceOfInvocations.containsKey(i)) {\n                 int currentCount = sequenceOfInvocations.get(i).intValue();\n                 sequenceOfInvocations.put(i, currentCount + 1);\n      * gets first registered invocation with the same method name\n      * or just first invocation\n      */\n-    private InvocationWithMatchers findSimilarInvocation(InvocationWithMatchers expectedInvocation) {\n-        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n+    private Invocation findSimilarInvocation(InvocationWithMatchers expectedInvocation) {\n+        for (Invocation registeredInvocation : registeredInvocations) {\n             String expectedMethodName = expectedInvocation.getMethod().getName();\n             String registeredInvocationName = registeredInvocation.getMethod().getName();\n-            if (expectedMethodName.equals(registeredInvocationName) && !registeredInvocation.getInvocation().isVerified()) {\n+            if (expectedMethodName.equals(registeredInvocationName) && !registeredInvocation.isVerified()) {\n                 return registeredInvocation;\n             }\n         }\n \n     private int numberOfActualInvocations(InvocationWithMatchers expectedInvocation) {\n         int verifiedInvocations = 0;\n-        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n-            Invocation invocation = registeredInvocation.getInvocation();\n-            if (expectedInvocation.matches(invocation)) {\n+        for (Invocation registeredInvocation : registeredInvocations) {\n+            if (expectedInvocation.matches(registeredInvocation)) {\n                 verifiedInvocations++;\n             }\n         }\n     }\n     \n     private void verifyNoMoreInteractions(String verificationErrorMessage) {\n-        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n-            if (!registeredInvocation.getInvocation().isVerified()) {\n+        for (Invocation registeredInvocation : registeredInvocations) {\n+            if (!registeredInvocation.isVerified()) {\n                 String mockName = Namer.nameForMock(mock);\n                 throw new VerificationAssertionError(\n                         \"\\n\" +\n         return ToTypeMappings.emptyReturnValueFor(invocation.getMethod().getReturnType());\n     }\n \n-    public Invocation lastInvocation() {\n-        return registeredInvocations.get(registeredInvocations.size() - 1).getInvocation();\n-    }\n-\n     public T getMock() {\n         return mock;\n     }\n         this.mock = mock;\n     }\n \n-    public List<InvocationWithMatchers> getRegisteredInvocations() {\n+    public List<Invocation> getRegisteredInvocations() {\n         return registeredInvocations;\n     }\n+\n+    public InvocationWithMatchers getInvocationForStubbing() {\n+        return invocationForStubbing;\n+    }\n }\n--- a/test/org/mockito/InvocationTest.java\n+++ b/test/org/mockito/InvocationTest.java\n         assertTrue(call.equals(equalCall));\n         assertFalse(call.equals(nonEqualCall));\n     }\n-    \n-    @Test\n-    public void shouldNotImplementHashCodeBecauseItsNotUsedWithMaps() {\n-        try {\n-            call.hashCode();\n-            fail();\n-        } catch (UnsupportedOperationException expected) {\n-            assertEquals(\"hashCode() is not implemented\", expected.getMessage());\n-        }\n-    }\n }\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n     \n     //TODO do we need nice message when expected number of invocations = 0?\n     \n+    //TODO what happens if user uses a different matcher like Find(), those matchers print differently\n }\n--- a/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n  */\n package org.mockito.usage.verification;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.mock;\n \n import java.util.*;\n \n import org.junit.*;\n-import org.mockito.Strictly;\n \n @SuppressWarnings(\"unchecked\")  \n public class VerificationInOrderMixedWithOrdiraryVerificationTest {\n     private LinkedList list;\n     private HashMap map;\n     private HashSet set;\n-    private Strictly strictly;\n+//    private Strictly strictly;\n \n     @Before\n     public void setUp() {\n         map.put(\"five\", \"five\");\n         set.add(\"six\");\n         \n-        strictly = strictOrderVerifier(list, map, set);\n+//        strictly = strictOrderVerifier(list, map, set);\n     }\n     \n     @Test", "timestamp": 1196101158, "metainfo": ""}