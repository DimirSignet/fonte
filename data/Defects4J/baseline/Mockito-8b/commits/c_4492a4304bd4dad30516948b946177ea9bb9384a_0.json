{"sha": "4492a4304bd4dad30516948b946177ea9bb9384a", "log": "In order to fix issue 94 and make people who write extensions for Mockito happy I changed the way CGLIBHacker works. I made him traverse the object graph in case the MethodProxy class has been proxied. I added powermock-reflect as test-dependency to the project. It should be the runtime dependency as I'm trying to avoid too many runtime dependencies.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401523", "commit": "\n--- a/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n+++ b/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n \n     public void setMockitoNamingPolicy(MethodProxy methodProxy) {\n         try {\n-            Field createInfoField = methodProxy.getClass().getDeclaredField(\"createInfo\");\n+            Field createInfoField = reflectOnCreateInfo(methodProxy);\n             createInfoField.setAccessible(true);\n             Object createInfo = createInfoField.get(methodProxy);\n             Field namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\n             throw new RuntimeException(\"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses\", e);\n         }\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws NoSuchFieldException {\n+        Class cglibMethodProxyClass = methodProxy.getClass();\n+        //in case methodProxy was extended by user, let's traverse the object graph to find the cglib methodProxy \n+        //with all the fields we would like to change \n+        while (cglibMethodProxyClass != MethodProxy.class) {\n+            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();\n+        }\n+        return cglibMethodProxyClass.getDeclaredField(\"createInfo\");\n+    }\n }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     private boolean verified;\n     private boolean verifiedInOrder;\n     private Object[] rawArguments;\n-    private final RealMethod realMethod;\n+    final RealMethod realMethod;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, RealMethod realMethod) {\n         this.mock = mock;\n--- a/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n import org.mockito.cglib.proxy.MethodProxy;\n \n \n-public class CGLIBProxyRealMethod implements RealMethod {\n+public class CGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy {\n \n     private final MethodProxy methodProxy;\n \n     public Object invoke(Object target, Object[] arguments) throws Throwable {\n         return methodProxy.invokeSuper(target, arguments);\n     }\n+\n+    public MethodProxy getMethodProxy() {\n+        return methodProxy;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n-public class FilteredCGLIBProxyRealMethod implements RealMethod {\n+public class FilteredCGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy {\n \n     private final RealMethod realMethod;\n \n             throw t;\n         }\n     }\n+\n+    public MethodProxy getMethodProxy() {\n+        return ((HasCGLIBMethodProxy) realMethod).getMethodProxy();\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/HasCGLIBMethodProxy.java\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+public interface HasCGLIBMethodProxy {\n+\n+    MethodProxy getMethodProxy();\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n+package org.mockito.internal.creation.cglib;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.core.NamingPolicy;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockitoutil.TestBase;\n+import org.powermock.reflect.Whitebox;\n+\n+public class CGLIBHackerTest extends TestBase {\n+\n+    @Test\n+    public void shouldSetMockitoNamingPolicy() throws Exception {\n+        //given\n+        MethodProxy methodProxy = new MethodProxyBuilder().build();\n+        \n+        //when\n+        new CGLIBHacker().setMockitoNamingPolicy(methodProxy);\n+        \n+        //then\n+        Object createInfo = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, \"namingPolicy\");\n+        assertEquals(namingPolicy, MockitoNamingPolicy.INSTANCE);\n+    }\n+    \n+    @Test\n+    public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied() throws Exception {\n+        //given\n+        MethodProxy proxiedMethodProxy = spy(new MethodProxyBuilder().build());\n+        \n+        //when\n+        new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);\n+        \n+        //then\n+        Object createInfo = Whitebox.getInternalState(proxiedMethodProxy, \"createInfo\");\n+        NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, \"namingPolicy\");\n+        assertEquals(namingPolicy, MockitoNamingPolicy.INSTANCE);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n+package org.mockito.internal.creation.cglib;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.invocation.ExposedInvocation;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+\n+public class MethodProxyBuilder {\n+\n+    public MethodProxy build() {\n+        IMethods mock = mock(IMethods.class);\n+        when(mock.objectReturningMethodNoArgs()).thenAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return invocation;\n+            }});\n+        \n+        Invocation i = (Invocation) mock.objectReturningMethodNoArgs();\n+        return new ExposedInvocation(i).getMethodProxy();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n+package org.mockito.internal.invocation;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.invocation.realmethod.HasCGLIBMethodProxy;\n+\n+public class ExposedInvocation {\n+\n+    private final MethodProxy methodProxy;\n+\n+    public ExposedInvocation(Invocation toBeExposed) {\n+         methodProxy = ((HasCGLIBMethodProxy) toBeExposed.realMethod).getMethodProxy();\n+    }\n+\n+    public MethodProxy getMethodProxy() {\n+        return methodProxy;\n+    }\n+}", "timestamp": 1245248910, "metainfo": ""}