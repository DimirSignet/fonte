{"sha": "f319112b71df8a5848d7e7923bcb446e7f1bb4d3", "log": "Fixed issue 139 In order to provide decent exception quickly when user does something wrong - passes wrong arguments to the mock() method (incosistent types of mocked type and spied instance type).  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401658", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"extraInterfaces() requires at least one interface.\"\n         ));\n     }\n+\n+    public void mockedTypeIsInconsistentWithSpiedInstanceType(Class<?> mockedType, Object spiedInstance) {\n+        throw new MockitoException(join(\n+                \"Mocked type must be the same as the type of your spied instance.\",\n+                \"Mocked type must be: \" + spiedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n+                \"  //correct spying:\",\n+                \"  spy = mock( ->ArrayList.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\",\n+                \"  //incorrect - types don't match:\",\n+                \"  spy = mock( ->List.class<- , withSettings().spiedInstance( ->new ArrayList()<- );\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/internal/util/CreationValidator.java\n+++ b/src/org/mockito/internal/util/CreationValidator.java\n             }\n         }\n     }\n+    \n+    public void validateMockedType(Class classToMock, Object spiedInstance) {\n+        if (classToMock == null || spiedInstance == null) {\n+            return;\n+        }\n+        if (!classToMock.equals(spiedInstance.getClass())) {\n+            new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n     public <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\n         creationValidator.validateType(classToMock);\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n+        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n         \n         MockName mockName = new MockName(settings.getMockName(), classToMock);\n         MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings);\n--- a/test/org/mockito/internal/util/CreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/CreationValidatorTest.java\n  */\n package org.mockito.internal.util;\n \n+import java.util.ArrayList;\n+import java.util.List;\n+\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+@SuppressWarnings(\"unchecked\")\n public class CreationValidatorTest extends TestBase {\n \n     final class FinalClass {}\n+    CreationValidator validator = new CreationValidator();\n     \n     @Test\n     public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n-        //given\n-        CreationValidator validator = new CreationValidator();\n-        \n         try {\n             //when\n             validator.validateExtraInterfaces(IMethods.class, new Class<?>[] {IMethods.class});\n             assertContains(\"You mocked following type: IMethods\", e.getMessage());\n         }\n     }\n-    \n+        \n     @Test\n-    public void shouldIgnoreIfExtraInterfacesAreNull() throws Exception {\n-        //given\n-        CreationValidator validator = new CreationValidator();\n-        \n-        //when\n-        validator.validateExtraInterfaces(IMethods.class, (Class[]) null);\n-\n-        //then ok\n+    public void shouldNotAllowsInconsistentTypes() throws Exception {\n+        try {\n+            //when\n+            validator.validateMockedType(List.class, new ArrayList());\n+            fail();\n+            //then\n+        } catch(MockitoException e) {}\n     }\n     \n     @Test\n-    public void shouldNotAllowFinalClasses() throws Exception {\n-        //given\n-        CreationValidator validator = new CreationValidator();\n-        \n-        try {\n-            //when\n-            validator.validateType(FinalClass.class);\n-            fail();\n-        } catch (MockitoException e) {\n-            //then\n-            assertContains(\"Cannot mock/spy\", e.getMessage());\n-        }\n+    public void shouldAllowOnlyConsistentTypes() throws Exception {\n+        //when\n+        validator.validateMockedType(ArrayList.class, new ArrayList());\n+        //then no exception is thrown\n+    }\n+    \n+    @Test\n+    public void shouldValidationBeSafeWhenNullsPassed() throws Exception {\n+        //when\n+        validator.validateMockedType(null, new ArrayList());\n+        //or\n+        validator.validateMockedType(ArrayList.class, null);\n+        //then no exception is thrown\n     }\n }\n--- a/test/org/mockitousage/basicapi/MocksCreationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksCreationTest.java\n import static org.hamcrest.CoreMatchers.*;\n import static org.mockito.Mockito.*;\n \n+import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+@SuppressWarnings(\"unchecked\")\n public class MocksCreationTest extends TestBase {\n \n     private class HasPrivateConstructor {};\n         //then\n         assertContains(\"great mockie\", name);\n     }\n+    \n+    @Test\n+    public void shouldScreamWhenSpyCreatedWithWrongType() {\n+        //given\n+        List list = new LinkedList();\n+        try {\n+            //when\n+            mock(List.class, withSettings().spiedInstance(list));\n+            fail();\n+            //then\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @Test\n+    public void shouldAllowCreatingSpiesWithCorrectType() {\n+        List list = new LinkedList();\n+        mock(LinkedList.class, withSettings().spiedInstance(list));\n+    }\n }", "timestamp": 1257683908, "metainfo": ""}