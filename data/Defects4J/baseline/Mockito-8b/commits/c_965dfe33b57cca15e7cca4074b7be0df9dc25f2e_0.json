{"sha": "965dfe33b57cca15e7cca4074b7be0df9dc25f2e", "log": "verification error now has a cause attached. Cause points to actual invocation so it is easy to compare actual invocation and wanted invocation  --HG-- rename : src/org/mockito/exceptions/MockitoStackTraceFilter.java => src/org/mockito/exceptions/StackTraceFilter.java rename : test/org/mockito/exceptions/MockitoStackTraceMergerTest.java => test/org/mockito/exceptions/StackTraceRemoverTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40139", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/exceptions/CommonStackTraceRemover.java\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+public class CommonStackTraceRemover {\n+\n+    public void remove(HasStackTrace hasStackTrace, List<StackTraceElement> causeStackTrace) {\n+        List<StackTraceElement> exceptionsPart = null;\n+        List<StackTraceElement> exceptionsTrace = Arrays.asList(hasStackTrace.getStackTrace());\n+        int length = exceptionsTrace.size();\n+        for(int i=0 ; i<length; i++) {\n+            List<StackTraceElement> subList = exceptionsTrace.subList(i, length);\n+            int lastStartingIndexOfSubList = Collections.lastIndexOfSubList(causeStackTrace, subList);\n+            if (lastStartingIndexOfSubList == -1) {\n+                continue;\n+            }\n+            \n+            int lastEndingIndexOfSubList = lastStartingIndexOfSubList + subList.size() - 1;\n+            if (lastEndingIndexOfSubList == causeStackTrace.size() - 1) {\n+                exceptionsPart = exceptionsTrace.subList(0, i);\n+                break;\n+            }\n+        }\n+        \n+        assert exceptionsPart != null;\n+        hasStackTrace.setStackTrace(exceptionsPart.toArray(new StackTraceElement[exceptionsPart.size()]));\n+    }\n+}\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n  */\n package org.mockito.exceptions;\n \n-import java.util.*;\n+import static org.mockito.exceptions.Strings.join;\n \n /**\n  * All messages in one place makes it easier to tune and amend the text. \n  */\n public class Exceptions {\n     \n-    private static String join(String ... linesToBreak) {\n-        StringBuilder out = new StringBuilder(\"\\n\");\n-        for (String line : linesToBreak) {\n-            out.append(line).append(\"\\n\");\n-        }\n-        int lastBreak = out.lastIndexOf(\"\\n\");\n-        return out.replace(lastBreak, lastBreak+1, \"\").toString();\n-    }\n-\n     private static String pluralize(int number) {\n         return number == 1 ? \"1 time\" : number + \" times\";\n     }\n         \n     }\n     \n-    public static VerificationError wantedInvocationDiffersFromActual(String wanted, String actual, List<StackTraceElement> invocationStackTrace) {\n-        return new VerificationError(join(\n+    public static void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+        WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n+            \"Actual invocation:\",\n+            actual\n+        ));\n+        \n+        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+        \n+        throw new VerificationError(join(\n                 \"Invocation differs from actual\",\n-                \"Wanted: \" + wanted,    \n-                \"Actual: \" + actual\n-            ), invocationStackTrace);\n+                \"Wanted invocation:\",\n+                wanted\n+            ), cause);\n     }\n     \n-\n     public static void strictlyWantedInvocationDiffersFromActual(String wanted, String actual) {\n         throw new VerificationError(join(\n                 \"Strict order verification failed\",\n                 \"Wanted: \" + wanted,\n                 \"Actual: \" + actual\n             ));\n-        \n     }\n \n     public static void wantedButNotInvoked(String wanted) {\n--- a/src/org/mockito/exceptions/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/MockitoAssertionError.java\n  */\n package org.mockito.exceptions;\n \n-import java.util.List;\n-\n+import java.util.Arrays;\n \n public class MockitoAssertionError extends AssertionError implements HasStackTrace {\n \n \n         unfilteredStackTrace = getStackTrace();\n         \n-        MockitoStackTraceFilter filter = new MockitoStackTraceFilter();\n+        StackTraceFilter filter = new StackTraceFilter();\n         filter.filterStackTrace(this);\n     }\n     \n-    public MockitoAssertionError(String message, List<StackTraceElement> invocationStackTrace) {\n+    public MockitoAssertionError(String message, Throwable cause) {\n         this(message);\n+        this.initCause(cause);\n         \n-        MockitoStackTraceMerger merger = new MockitoStackTraceMerger();\n-        merger.merge(this, invocationStackTrace);\n+        CommonStackTraceRemover remover = new CommonStackTraceRemover();\n+        remover.remove(this, Arrays.asList(cause.getStackTrace()));\n     }\n \n     public StackTraceElement[] getUnfilteredStackTrace() {\n         return unfilteredStackTrace;\n     }\n-}\n+}\n--- a/src/org/mockito/exceptions/MockitoException.java\n+++ b/src/org/mockito/exceptions/MockitoException.java\n \n         unfilteredStackTrace = getStackTrace();\n         \n-        MockitoStackTraceFilter filter = new MockitoStackTraceFilter();\n+        StackTraceFilter filter = new StackTraceFilter();\n         filter.filterStackTrace(this);\n     }\n     \n--- /dev/null\n+++ b/src/org/mockito/exceptions/StackTraceFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+public class StackTraceFilter {\n+    \n+    public boolean isLastStackElementToRemove(StackTraceElement e) {\n+        boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByCGLIB$$\");\n+        boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n+        return fromMockObject || fromOrgMockito;\n+    }\n+\n+    public void filterStackTrace(HasStackTrace hasStackTrace) {\n+        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasStackTrace.getStackTrace());\n+        \n+        int lastToRemove = -1;\n+        int i = 0;\n+        for (StackTraceElement trace : unfilteredStackTrace) {\n+            if (this.isLastStackElementToRemove(trace)) {\n+                lastToRemove = i;\n+            }\n+            i++;\n+        }\n+        \n+        List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove+1, unfilteredStackTrace.size() - 1);\n+        hasStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+    }\n+}\n--- a/src/org/mockito/exceptions/VerificationError.java\n+++ b/src/org/mockito/exceptions/VerificationError.java\n  */\n package org.mockito.exceptions;\n \n-import java.util.*;\n \n public class VerificationError extends MockitoAssertionError {\n \n         super(message);\n     }\n \n-    public VerificationError(String message, List<StackTraceElement> invocationStackTrace) {\n-        super(message, invocationStackTrace);\n+    public VerificationError(String message, Throwable cause) {\n+        super(message, cause);\n     }\n }\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n  */\n package org.mockito.internal;\n \n-import java.lang.reflect.*;\n+import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.exceptions.MockitoException;\n+import org.mockito.exceptions.*;\n import org.mockito.internal.matchers.*;\n \n public class Invocation {\n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n-    private final StackTraceElement[] stackTrace;\n \n     private boolean verifiedInOrder;\n+\n+    private HasStackTrace stackTrace;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n         this.mock = mock;\n         this.method = method;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n         this.sequenceNumber = sequenceNumber;\n-        this.stackTrace = new MockitoException(\"just to get stack trace\").getStackTrace();\n+        this.stackTrace = new MockitoException(\"\");\n     }\n \n     private static Object[] expandVarArgs(final boolean isVarArgs,\n         return getMockAndMethodNameWithSeqenceNumber() + getArgumentsString(matchers);\n     }\n \n-    public StackTraceElement[] getStackTrace() {\n-        return this.stackTrace;\n+    public HasStackTrace getStackTrace() {\n+        return stackTrace;\n     }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n             actual = actualInvocation.toStringWithArgumentTypes();\n         }\n         \n-        List<StackTraceElement> elements = new LinkedList<StackTraceElement>(Arrays.asList(actualInvocation.getStackTrace()));\n-        \n-        throw Exceptions.wantedInvocationDiffersFromActual(wanted, actual, elements);\n+        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n     }\n     \n     private void reportStrictOrderDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation) {\n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n package org.mockito.internal;\n \n import java.util.*;\n-\n-import org.mockito.exceptions.MockitoException;\n \n public class RegisteredInvocations {\n     \n--- a/src/org/mockito/internal/Result.java\n+++ b/src/org/mockito/internal/Result.java\n     public static Result createThrowResult(final Throwable throwable) {\n         return new Result(new IAnswer<Object>() {\n             public Object answer() throws Throwable {\n-                MockitoStackTraceFilter filter = new MockitoStackTraceFilter();\n+                StackTraceFilter filter = new StackTraceFilter();\n                 final Throwable filtered = throwable.fillInStackTrace();\n                 \n+                //TODO unit test?\n                 filter.filterStackTrace(new HasStackTrace() {\n                     public StackTraceElement[] getStackTrace() {\n                         return filtered.getStackTrace();\n--- /dev/null\n+++ b/test/org/mockito/exceptions/StackTraceRemoverTest.java\n+package org.mockito.exceptions;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+import java.util.*;\n+\n+import org.junit.Test;\n+\n+public class StackTraceRemoverTest {\n+\n+    private StackTraceElement[] stackTrace;\n+    private List<StackTraceElement> causeStackTrace;\n+    private List<String> methodsOnTraceAfterRemoving;\n+    \n+    private class SomeException implements HasStackTrace {\n+        public StackTraceElement[] getStackTrace() {\n+            return stackTrace;\n+        }\n+        public void setStackTrace(StackTraceElement[] stackTrace) {\n+            methodsOnTraceAfterRemoving = new LinkedList<String>();\n+            for(StackTraceElement e : stackTrace) {\n+                methodsOnTraceAfterRemoving.add(e.getMethodName());\n+            }\n+        }\n+    }\n+    \n+    private void remove() {\n+        CommonStackTraceRemover remover = new CommonStackTraceRemover();\n+        SomeException exception = new SomeException();\n+        remover.remove(exception, causeStackTrace);\n+    }\n+    \n+    private void setStackTrace(String ... methods) {\n+        stackTrace = new StackTraceBuilder().methods(methods).toStackTrace();\n+    }\n+    \n+    private void setCauseStackTrace(String ... methods) {\n+        causeStackTrace = new StackTraceBuilder().methods(methods).toStackTraceList();\n+    }\n+    \n+    @Test\n+    public void shouldRemoveCommonStackTrace() throws Exception {\n+        setStackTrace(\"methodOne\", \"methodTwo\", \"methodThree\", \"commonMethodOne\", \"commonMethodTwo\");\n+        setCauseStackTrace(\"actualOne\", \"actualTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n+        remove();\n+        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+                \"methodOne\",\n+                \"methodTwo\",\n+                \"methodThree\"\n+        ));\n+    }\n+    \n+    @Test\n+    public void shouldRemoveCommonWhenExceptionTraceHasRecursion() throws Exception {\n+        setStackTrace(\"methodOne\", \"commonMethodOne\", \"commonMethodTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n+        setCauseStackTrace(\"actualOne\", \"commonMethodOne\", \"commonMethodTwo\");\n+        remove();\n+        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+                \"methodOne\",\n+                \"commonMethodOne\",\n+                \"commonMethodTwo\"\n+        ));\n+    }\n+\n+    @Test\n+    public void shouldRemoveCommonWhenActualTraceHasRecursion() throws Exception {\n+        setStackTrace(\"methodOne\", \"commonMethodOne\");\n+        setCauseStackTrace(\"actualOne\", \"commonMethodOne\", \"actualOne\", \"commonMethodOne\");\n+        remove();\n+        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+                \"methodOne\"\n+        ));\n+    }\n+    \n+    @Test\n+    public void shouldRemoveCommonWhenOnlyOneMethodOnStackTrace() throws Exception {\n+        setStackTrace(\"commonOne\");\n+        setCauseStackTrace(\"commonOne\");\n+        remove();\n+        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder());\n+    }\n+    \n+    @Test\n+    public void shouldRemoveCommonWhenOneMethodEach() throws Exception {\n+        setStackTrace(\"one\", \"commonOne\");\n+        setCauseStackTrace(\"two\", \"commonOne\");\n+        remove();\n+        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+                \"one\"\n+        ));\n+    }\n+}\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n         };\n     }\n     \n+    public static <T> Matcher<String> contains(final String text) {\n+        return new BaseMatcher<String>() {\n+\n+            public boolean matches(Object string) {\n+                return ((String)string).contains(text); \n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"string doesn't contain \" + text);\n+            }\n+        };\n+    }\n+    \n     public static <T> Matcher<Object> hasBridgeMethod(final String methodName) {\n         return new BaseMatcher<Object>() {\n \n         };\n     }\n     \n-    public static <T> Matcher<Collection> collectionContainingInOrder(final T ... elements) {\n+    public static <T> Matcher<Collection> collectionIsExactlyInOrder(final T ... elements) {\n         return new BaseMatcher<Collection>() {\n \n             public boolean matches(Object collection) {\n--- a/test/org/mockitousage/StackTrackeChangingTest.java\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n     }\n     \n     @Test\n-    public void shouldMergeInvocationStackTraceAndExceptionStackTrace() {\n+    public void shouldShowActualInvocationAsExceptionCause() {\n         simpleMethodOnAMock();\n         try {\n             verifySimpleMethodOnAMock();\n             fail();\n         } catch (VerificationError e) {\n             assertThat(e, hasMethodInStackTraceAt(0, \"verifySimpleMethodOnAMock\"));\n-            assertThat(e, hasMethodInStackTraceAt(1, \"shouldMergeInvocationStackTraceAndExceptionStackTrace\"));\n-            assertThat(e, hasMethodInStackTraceAt(2, \"_below_is_actual_invocation_stack_trace_\"));\n-            assertThat(e, hasMethodInStackTraceAt(3, \"simpleMethodOnAMock\"));\n-            assertThat(e, hasMethodInStackTraceAt(4, \"shouldMergeInvocationStackTraceAndExceptionStackTrace\"));\n+            assertThat(e, hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n+            assertThat(e.getCause(), hasMethodInStackTraceAt(0, \"simpleMethodOnAMock\"));\n+            assertThat(e.getCause(), hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n         }\n     }\n \n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n                 \"\\n\" +\n         \t\t\"Invocation differs from actual\" +\n         \t\t\"\\n\" +\n-                \"Wanted: Sub.say(class java.lang.String)\" +\n+                \"Wanted invocation:\" +\n                 \"\\n\" +\n-                \"Actual: Sub.say(class java.lang.Object)\";\n+                \"Sub.say(class java.lang.String)\";\n             \n-            assertEquals(expected, error.getMessage());\n+            assertEquals(expected, error.getMessage());\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Actual invocation:\" +\n+                \"\\n\" +\n+                \"Sub.say(class java.lang.Object)\";\n+            assertEquals(expectedCause, error.getCause().getMessage());\n         }\n     }\n     \n--- a/test/org/mockitousage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/NiceMessagesWhenVerificationFailsTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.*;\n-import static org.mockito.CrazyMatchers.aryEq;\n+import static org.mockito.util.ExtraMatchers.contains;\n+import static org.mockito.CrazyMatchers.*;\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n         try {\n             verify(mock).twoArgumentMethod(1, 1000);\n             fail();\n-        } catch (VerificationError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n+        } catch (VerificationError e) {\n+            String expected = \n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n                     \"\\n\" +\n-                    \"Wanted: IMethods.twoArgumentMethod(1, 1000)\" +\n-                    \"\\n\" +\n-                    \"Actual: IMethods.twoArgumentMethod(1, 2)\";\n-            \n-            assertEquals(expectedMessage, actualMessage);         \n+                    \"Wanted invocation:\" +\n+                    \"\\n\" +\n+                    \"IMethods.twoArgumentMethod(1, 1000)\";\n+            \n+            assertEquals(expected, e.getMessage());\n+            \n+            String expectedCause =\n+                    \"\\n\" +\n+                    \"Actual invocation:\" +\n+                    \"\\n\" +\n+                    \"IMethods.twoArgumentMethod(1, 2)\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());      \n         }\n     }\n     \n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n-        } catch (VerificationError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                    \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Wanted: IMethods.simpleMethod(\\\"test\\\")\" +\n-                    \"\\n\" +\n-                    \"Actual: IMethods.simpleMethod()\";\n-            \n-            assertEquals(expectedMessage, actualMessage);         \n+        } catch (VerificationError e) {\n+            assertThat(e.getMessage(), contains(\"IMethods.simpleMethod(\\\"test\\\")\"));\n+            assertThat(e.getCause().getMessage(), contains(\"IMethods.simpleMethod()\"));\n         }\n     }    \n     \n         try {\n             verify(mock).twoArgumentMethod(3, 1000);\n             fail();\n-        } catch (VerificationError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                    \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Wanted: IMethods.twoArgumentMethod(3, 1000)\" +\n-                    \"\\n\" +\n-                    \"Actual: IMethods.twoArgumentMethod(3, 3)\";\n-            \n-            assertEquals(expectedMessage, actualMessage);         \n+        } catch (VerificationError e) {\n+            assertThat(e.getMessage(), contains(\"IMethods.twoArgumentMethod(3, 1000)\"));\n+            assertThat(e.getCause().getMessage(), contains(\"IMethods.twoArgumentMethod(3, 3)\"));\n         }\n     }  \n     \n             verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));\n             fail();\n         } catch (VerificationError e) {\n-            String expected = \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Wanted: IMethods.oneArray([false, false, false])\" +\n-                    \"\\n\" +\n-                    \"Actual: IMethods.oneArray([true, false, false])\";\n-            assertEquals(expected, e.getMessage());\n+            assertThat(e.getMessage(), contains(\"IMethods.oneArray([false, false, false])\"));\n+            assertThat(e.getCause().getMessage(), contains(\"IMethods.oneArray([true, false, false])\"));\n         }\n     }\n     \n             verify(mock).varargsString(10, \"two\", \"one\");\n             fail();\n         } catch (VerificationError e) {\n-            String expected = \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Wanted: IMethods.varargsString(10, \\\"two\\\", \\\"one\\\")\" +\n-                    \"\\n\" +\n-                    \"Actual: IMethods.varargsString(10, \\\"one\\\", \\\"two\\\")\";\n-            assertEquals(expected, e.getMessage());\n+            assertThat(e.getMessage(), contains(\"IMethods.varargsString(10, \\\"two\\\", \\\"one\\\")\"));\n+            assertThat(e.getCause().getMessage(), contains(\"IMethods.varargsString(10, \\\"one\\\", \\\"two\\\")\"));\n         }\n     }\n     \n             verify(mock).simpleMethod(matches(\"burrito\"));\n             fail();\n         } catch (VerificationError e) {\n-            String expected = \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Wanted: IMethods.simpleMethod(matches(\\\"burrito\\\"))\" +\n-                    \"\\n\" +\n-                    \"Actual: IMethods.simpleMethod(\\\"foo\\\")\";\n-            assertEquals(expected, e.getMessage());\n+            assertThat(e.getMessage(), contains(\"IMethods.simpleMethod(matches(\\\"burrito\\\"))\"));\n+            assertThat(e.getCause().getMessage(), contains(\"IMethods.simpleMethod(\\\"foo\\\")\"));\n         }\n     }\n     \n             verify(mock).simpleMethod(\"test\");\n             fail();\n         } catch (VerificationError e) {\n-            assertTrue(e.getMessage().contains(\"simpleMethod(null, null)\"));\n+            assertThat(e.getCause().getMessage(), contains(\"simpleMethod(null, null)\"));\n         }\n     }\n }", "timestamp": 1197151695, "metainfo": ""}