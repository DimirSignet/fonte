{"sha": "5490d9b2fc7814bc4c1efe5a66f05ce5874d38bc", "log": "Refactoring a bit the patch of Eric, added AdditionalAnswers as a placeholder for future answers.  --HG-- rename : src/org/mockito/stubbing/answers/IdentityAnswers.java => src/org/mockito/stubbing/answers/ReturnsIdentity.java rename : test/org/mockito/stubbing/answers/IdentityAnswersTest.java => test/org/mockito/stubbing/answers/ReturnsIdentityTest.java", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/AdditionalAnswers.java\n+package org.mockito;\n+\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.answers.ReturnsIdentity;\n+\n+/**\n+ *\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class AdditionalAnswers {\n+    private static final ReturnsIdentity RETURNS_FIRST_ARGUMENT = new ReturnsIdentity(0);\n+    private static final ReturnsIdentity RETURNS_SECOND_ARGUMENT = new ReturnsIdentity(1);\n+    private static final ReturnsIdentity RETURNS_LAST_ARGUMENT = new ReturnsIdentity(-1);\n+\n+    /**\n+     * Returns the first parameter of an invocation.\n+     *\n+     * <p>\n+     *     This additional answer could be used at stub time using the\n+     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(carKeyFob.authenticate(carKey)).will(returnsFirstArg());\n+     * daAnswer(returnsFirstArg()).when(carKeyFob).authenticate(carKey)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the first argument of the invocation.\n+     */\n+    public static <T> Answer<T> returnsFirstArg() {\n+        return (Answer<T>) RETURNS_FIRST_ARGUMENT;\n+    }\n+\n+    /**\n+     * Returns the second parameter of an invocation.\n+     *\n+     * <p>\n+     *     This additional answer could be used at stub time using the\n+     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(trader.apply(leesFormula, onCreditDefaultSwap)).will(returnsSecondArg());\n+     * daAnswer(returnsSecondArg()).when(trader).apply(leesFormula, onCreditDefaultSwap)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the second argument of the invocation.\n+     */\n+    public static <T> Answer<T> returnsSecondArg() {\n+        return (Answer<T>) RETURNS_SECOND_ARGUMENT;\n+    }\n+\n+    /**\n+     * Returns the last parameter of an invocation.\n+     *\n+     * <p>\n+     *     This additional answer could be used at stub time using the\n+     *     <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsLastArg());\n+     * daAnswer(returnsLastArg()).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the last argument of the invocation.\n+     */\n+    public static <T> Answer<T> returnsLastArg() {\n+        return (Answer<T>) RETURNS_LAST_ARGUMENT;\n+    }\n+\n+    /**\n+     * Returns the parameter of an invocation at the given position.\n+     *\n+     * <p>\n+     * This additional answer could be used at stub time using the\n+     * <code>then|do|will{@link org.mockito.stubbing.Answer}</code> methods. For example :\n+     * </p>\n+     *\n+     * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsArgAtPosition(3));\n+     * daAnswer(returnsArgAtPosition(3)).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n+     *\n+     * @param <T> Return type of the invocation.\n+     * @return Answer that will return the second argument of the invocation.\n+     */\n+    public static <T> Answer<T> returnsArgAtPosition(int position) {\n+        return (Answer<T>) new ReturnsIdentity(position);\n+    }\n+\n+\n+}\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.util.StringJoiner;\n import org.mockito.invocation.DescribedInvocation;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.InvocationOnMock;\n import org.mockito.invocation.Location;\n import org.mockito.listeners.InvocationListener;\n \n \t\t\t\t\"Settings should not define a spy instance and a delegated instance at the same time.\"\n \t\t\t\t)) ;\n \t}\n+\n+    public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n+        throw new MockitoException(join(\"Invalid argument index.\",\n+                                        \"The index need to be a positive number that indicates the position of the argument to return.\",\n+                                        \"However it is possible to use the -1 value to indicates that the last argument should be\",\n+                                        \"returned.\"));\n+    }\n+\n+    public int invalidArgumentIndexRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n+        throw new MockitoException(\n+                join(\"Invalid argument index for the current invocation of method : \",\n+                     \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName(),\n+                     \"\",\n+                     (willReturnLastParameter ?\n+                             \"Last parameter wanted\" :\n+                             \"Wanted parameter at position \" + argumentIndex) + possibleArgumentTypesOf(invocation),\n+                     \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n+                     \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n+                     \"\"));\n+    }\n+\n+    private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n+        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n+        if (parameterTypes.length == 0) {\n+            return new StringBuilder(\" but the method has no arguments.\\n\");\n+        }\n+\n+        StringBuilder stringBuilder = new StringBuilder(\" but possible argument indexes for this method are :\\n\");\n+        for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {\n+            stringBuilder.append(\"    [\").append(i).append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n+        }\n+        return stringBuilder;\n+    }\n+\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/stubbing/answers/ReturnsIdentity.java\n+package org.mockito.stubbing.answers;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Returns the passed parameter identity at specified index.\n+ *\n+ * <p>The <code>argumentIndex</code> represents the index in the argument array of the invocation.</p>\n+ * <p>If this number equals -1 then the last argument is returned.</p>\n+ *\n+ * @see org.mockito.AdditionalAnswers\n+ */\n+public class ReturnsIdentity implements Answer<Object>, Serializable {\n+\n+    private static final long serialVersionUID = -589315085166295101L;\n+\n+    public static final int LAST_ARGUMENT = -1;\n+\n+    private final int argumentIndex;\n+\n+    /**\n+     * Build the identity answer to return the argument at the given position in the argument array.\n+     *\n+     * @param argumentIndex The position of the argument identity to return in the invocation.\n+     *                      Using <code>-1</code> indicates the last argument.\n+     */\n+    public ReturnsIdentity(int argumentIndex) {\n+        this.argumentIndex = checkWithinAllowedRange(argumentIndex);\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        return willReturnLastArg() ?\n+                lastArgumentOf(invocation) :\n+                argumentIndexOf(invocation);\n+    }\n+\n+    private boolean willReturnLastArg() {\n+        return argumentIndex == LAST_ARGUMENT;\n+    }\n+\n+    private Object argumentIndexOf(InvocationOnMock invocation) {\n+        Object[] arguments = invocation.getArguments();\n+        return arguments[checkWithinInvocationRange(invocation, argumentIndex)];\n+    }\n+\n+    private Object lastArgumentOf(InvocationOnMock invocation) {\n+        Object[] arguments = invocation.getArguments();\n+        return arguments[checkWithinInvocationRange(invocation, arguments.length - 1)];\n+    }\n+\n+    private int checkWithinAllowedRange(int argumentIndex) {\n+        if (argumentIndex < -1) {\n+            new Reporter().invalidArgumentRangeAtIdentityAnswerCreationTime();\n+        }\n+        return argumentIndex;\n+    }\n+\n+    private int checkWithinInvocationRange(InvocationOnMock invocation, int actualArgumentIndex) {\n+        if (actualArgumentIndex < 0 || invocation.getArguments().length <= actualArgumentIndex) {\n+            new Reporter().invalidArgumentIndexRangeAtInvocationTime(invocation, willReturnLastArg(), argumentIndex);\n+        }\n+\n+        return actualArgumentIndex;\n+    }\n+\n+}\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n  */\n package org.mockito.internal.stubbing.answers;\n \n-import static org.mockito.Mockito.*;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n+import org.mockitoutil.TestBase;\n \n import java.io.IOException;\n import java.nio.charset.CharacterCodingException;\n import java.util.ArrayList;\n \n-import org.junit.Test;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.invocation.Invocation;\n-import org.mockitoutil.TestBase;\n+import static org.mockito.Mockito.mock;\n \n @SuppressWarnings(\"unchecked\")\n public class AnswersValidatorTest extends TestBase {\n--- /dev/null\n+++ b/test/org/mockito/stubbing/answers/ReturnsIdentityTest.java\n+package org.mockito.stubbing.answers;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class ReturnsIdentityTest {\n+\t@Test\n+\tpublic void should_be_able_to_return_the_first_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsIdentity(0).answer(invocationWith(\"A\", \"B\"))).isEqualTo(\"A\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_second_parameter()\n+\t\t\tthrows Throwable {\n+\t\tassertThat(new ReturnsIdentity(1).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"B\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_last_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsIdentity(-1).answer(invocationWith(\"A\"))).isEqualTo(\"A\");\n+\t\tassertThat(new ReturnsIdentity(-1).answer(invocationWith(\"A\", \"B\"))).isEqualTo(\"B\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_be_able_to_return_the_specified_parameter() throws Throwable {\n+\t\tassertThat(new ReturnsIdentity(0).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"A\");\n+\t\tassertThat(new ReturnsIdentity(1).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"B\");\n+\t\tassertThat(new ReturnsIdentity(2).answer(invocationWith(\"A\", \"B\", \"C\"))).isEqualTo(\"C\");\n+\t}\n+\n+\t@Test\n+\tpublic void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time() throws Throwable {\n+        try {\n+            new ReturnsIdentity(-30);\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"argument index\")\n+                    .containsIgnoringCase(\"positive number\")\n+                    .contains(\"1\")\n+                    .containsIgnoringCase(\"last argument\");\n+        }\n+    }\n+\n+\t@Test\n+\tpublic void should_raise_an_exception_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {\n+        try {\n+            new ReturnsIdentity(30).answer(new InvocationBuilder().method(\"oneArg\").arg(\"A\").toInvocation());\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"invalid argument index\")\n+                    .containsIgnoringCase(\"iMethods.oneArg\")\n+                    .containsIgnoringCase(\"[0] String\")\n+                    .containsIgnoringCase(\"position\")\n+                    .contains(\"30\");\n+        }\n+    }\n+\n+\t@Test\n+\tpublic void should_raise_an_exception_if_index_is_not_in_range_for_no_arg_invocation() throws Throwable {\n+        try {\n+            new ReturnsIdentity(ReturnsIdentity.LAST_ARGUMENT).answer(new InvocationBuilder().method(\"simpleMethod\").toInvocation());\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"invalid argument index\")\n+                    .containsIgnoringCase(\"iMethods.simpleMethod\")\n+                    .containsIgnoringCase(\"no arguments\")\n+                    .containsIgnoringCase(\"last parameter wanted\");\n+        }\n+    }\n+\n+\tprivate static InvocationOnMock invocationWith(final String... parameters) {\n+\t\t@SuppressWarnings(\"serial\")\n+\t\tInvocationOnMock invocation = new InvocationOnMock() {\n+\n+\t\t\tpublic Object getMock() {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tpublic Method getMethod() {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tpublic Object[] getArguments() {\n+\t\t\t\treturn parameters;\n+\t\t\t}\n+\n+\t\t\tpublic Object callRealMethod() throws Throwable {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t};\n+\t\treturn invocation;\n+\t}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockitousage.IMethods;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.AdditionalAnswers.returnsFirstArg;\n+import static org.mockito.AdditionalAnswers.returnsLastArg;\n+import static org.mockito.AdditionalAnswers.returnsSecondArg;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.anyVararg;\n+import static org.mockito.Matchers.eq;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class StubbingWithAdditionalAnswers {\n+\n+    @Mock IMethods iMethods;\n+\n+    @Test\n+    public void can_return_arguments_of_invocation() throws Exception {\n+        given(iMethods.objectArgMethod(anyObject())).will(returnsFirstArg());\n+        given(iMethods.threeArgumentMethod(eq(0), anyObject(), anyString())).will(returnsSecondArg());\n+        given(iMethods.threeArgumentMethod(eq(1), anyObject(), anyString())).will(returnsLastArg());\n+\n+        assertThat(iMethods.objectArgMethod(\"first\")).isEqualTo(\"first\");\n+        assertThat(iMethods.threeArgumentMethod(0, \"second\", \"whatever\")).isEqualTo(\"second\");\n+        assertThat(iMethods.threeArgumentMethod(1, \"whatever\", \"last\")).isEqualTo(\"last\");\n+    }\n+\n+    @Test\n+    public void can_return_expanded_arguments_of_invocation() throws Exception {\n+        given(iMethods.objectReturningMethod(anyVararg())).will(returnsSecondArg());\n+\n+        assertThat(iMethods.objectReturningMethod(\"bob\", \"alice\", \"carl\")).isEqualTo(\"alice\");\n+    }\n+}", "timestamp": 1333536797, "metainfo": ""}