{"sha": "d3c8889788335c60116e58df35638e7e2980a866", "log": "...  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40234", "commit": "\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n \n public class PointingStackTraceToActualInvocationTest extends RequiresValidState {\n     \n         mock = Mockito.mock(IMethods.class);\n         mockTwo = Mockito.mock(IMethods.class);\n         \n-        firstChunk();\n-        secondChunk();\n-        thirdChunk();\n-        fourthChunk();\n+        first();\n+        second();\n+        third();\n+        fourth();\n     }\n \n-    private void firstChunk() {\n-        mock.simpleMethod(1);\n+    private void first() {\n         mock.simpleMethod(1);\n     }\n-    private void secondChunk() {\n-        mockTwo.simpleMethod(2);\n+    private void second() {\n         mockTwo.simpleMethod(2);\n     }\n-    private void thirdChunk() {\n-        mock.simpleMethod(3);\n+    private void third() {\n         mock.simpleMethod(3);\n     }\n-    private void fourthChunk() {\n-        mockTwo.simpleMethod(4);\n+    private void fourth() {\n         mockTwo.simpleMethod(4);\n     }\n     \n         Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n         \n         strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        strictly.verify(mockTwo).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mock).simpleMethod(999);\n             fail();\n-        } catch (VerificationError e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n         }\n     }\n     \n         try {\n             strictly.verify(mockTwo).simpleMethod(999);\n             fail();\n-        } catch (VerificationError e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToUnverifiedInvocation() {\n         Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        strictly.verify(mockTwo).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mockTwo, times(3)).simpleMethod(999);\n             fail();\n-        } catch (VerificationError e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n         }\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldPointToTooManyInvocationsChunk() {\n         Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n         \n         try {\n-            strictly.verify(mockTwo).simpleMethod(anyInt());\n+            strictly.verify(mockTwo, times(0)).simpleMethod(anyInt());\n             fail();\n-        } catch (TooManyActualInvocationsError e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n-        }\n-    }\n-    \n-    @Ignore\n-    @Test\n-    public void shouldPointToTooLittleInvocationsUnverifiChunk() {\n-        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n-        \n-        try {\n-            strictly.verify(mockTwo).simpleMethod(anyInt());\n-            fail();\n-        } catch (TooLittleActualInvocationsError e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        } catch (TooManyActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n         }\n     }\n     \n     @Test\n-    public void shouldFilterStackTraceOnVerify() {\n-        verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+    public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mockTwo).simpleMethod(anyInt());\n         \n         try {\n-            verify(mockTwo).simpleMethod(999);\n+            strictly.verify(mockTwo, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (VerificationError e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n         }\n     }\n+    \n+    @Test\n+    public void shouldPointToActualInvocationOnVerificationError() {\n+        try {\n+            verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedActualInvocationOnVerificationError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, atLeastOnce()).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsChunkOnError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, times(3)).simpleMethod(3);\n+            fail();\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunkOnError() {\n+        try {\n+            verify(mock, times(0)).simpleMethod(1);\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n+        }\n+    }   \n }", "timestamp": 1198535107, "metainfo": ""}