{"sha": "7ac16f5df1767c37d6829a4f2c976886c0ffffab", "log": "Mergin patch proposal from Andre Rigon about Constructor Injection  --HG-- branch : issue 238 : constructor injection", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/ConstructorInitializer.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.exceptions.Reporter;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.mock;\n+\n+public class ConstructorInitializer {\n+\n+\tprivate final Field field;\n+\tprivate final Object target;\n+\n+\tpublic ConstructorInitializer(Field field, Object target) {\n+\t\tthis.field = field;\n+\t\tthis.target = target;\n+\t}\n+\t\n+\n+\tpublic void initialize(Set<Object> mocks) {\n+\t\ttry {\n+\t\t\tfinal Object instance = newInstance( mocks);\n+\t\t\tfinal AccessibilityChanger changer = new AccessibilityChanger();\n+\t\t\tchanger.enableAccess(field);\n+\t\t\tfield.set(target, instance);\n+\t\t\tchanger.safelyDisableAccess(field);\n+\t\t} catch (Exception e) {\n+\t\t\tnew Reporter().cannotInitializeForInjectMocksAnnotation(\n+\t\t\t\t\tfield.getName(), e);\n+\t\t}\n+\t}\n+\n+\tprivate Object newInstance(Set<Object> mocks)\n+\t\t\tthrows Exception {\n+\t\tfinal Constructor<?> c = biggestConstructor(field.getType());\n+\t\tfinal Object[] args = args(c, mocks);\n+\t\tfinal AccessibilityChanger changer = new AccessibilityChanger();\n+\t\tchanger.enableAccess(c);\n+\t\tfinal Object instance = c.newInstance(args);\n+\t\tchanger.safelyDisableAccess(c);\n+\t\treturn instance;\n+\t}\n+\n+\tprivate Object[] args(Constructor<?> c, Set<Object> mocks) {\n+\t\tfinal List<Object> args = new ArrayList<Object>(\n+\t\t\t\tc.getParameterTypes().length);\n+\n+\t\tfor (Class<?> paramClass : c.getParameterTypes()) {\n+\t\t\targs.add(findMockByTypeOrCreateOne(mocks, paramClass));\n+\t\t}\n+\t\treturn args.toArray();\n+\t}\n+\n+\tprivate Object findMockByTypeOrCreateOne(Set<Object> mocks,\n+\t\t\tClass<?> paramClass) {\n+\t\tfor (Object mock : mocks) {\n+\t\t\tif (paramClass.isAssignableFrom(mock.getClass())) {\n+\t\t\t\treturn mock;\n+\t\t\t}\n+\t\t}\n+\t\treturn notMockFoundForClass(paramClass);\n+\t}\n+\n+\tprivate Object notMockFoundForClass(Class<?> paramClass) {\n+\t\treturn mock(paramClass);\n+\t}\n+\n+\tprivate Constructor<?> biggestConstructor(Class<?> clazz) {\n+\t\tfinal List<Constructor<?>> constructors = Arrays.asList(clazz\n+\t\t\t\t.getConstructors());\n+\t\tCollections.sort(constructors, new Comparator<Constructor<?>>() {\n+\n+\t\t\tpublic int compare(Constructor<?> o1, Constructor<?> o2) {\n+\t\t\t\treturn o2.getParameterTypes().length\n+\t\t\t\t\t\t- o1.getParameterTypes().length;\n+\t\t\t}\n+\t\t});\n+\t\treturn constructors.get(0);\n+\t}\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/InjectMocksTest.java\n+package org.mockitousage.annotation;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockitousage.examples.use.ArticleCalculator;\n+import org.mockitousage.examples.use.ArticleManager;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.when;\n+\n+public class InjectMocksTest extends TestBase {\n+\n+\t@Mock\n+\tArticleCalculator calculator;\n+\n+\t@InjectMocks\n+\tArticleManager articleManager;\n+\n+\t@Test\n+\tpublic void shouldNotFailWhenNotInitialized() {\n+\t\tassertNotNull(articleManager);\n+\t}\n+\n+\t@Test(expected = IllegalArgumentException.class)\n+\tpublic void testInnerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {\n+\t\twhen(calculator.countArticles(\"new\")).thenThrow(new IllegalArgumentException());\n+\n+\t\tarticleManager.updateArticleCounters(\"new\");\n+\t}\n+\n+\t@Test\n+\tpublic void mockJustWorks() {\n+\t\tarticleManager.updateArticleCounters(\"new\");\n+\t}\n+}\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackFilter.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackFilter.java\n package org.mockito.cglib.proxy;\n \n import java.lang.reflect.Method;\n+import java.util.List;\n \n /**\n  * Map methods of subclasses generated by {@link Enhancer} to a particular\n public interface CallbackFilter {\n     /**\n      * Map a method to a callback.\n+     *\n      * @param method the intercepted method\n-     * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method, \n+     * @param allMethods all the methods found on the instance. Don't mess with the contents of this list!!!\n+     * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method,\n      */\n-    int accept(Method method);\n+    int accept(Method method, List<Method> allMethods);\n \n     /**\n      * The <code>CallbackFilter</code> in use affects which cached class\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackHelper.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackHelper.java\n         }\n     }\n \n-    public int accept(Method method)\n+    public int accept(Method method, List<Method> allMethods)\n     {\n         return ((Integer)methodMap.get(method)).intValue();\n     }\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/Enhancer.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Enhancer.java\n  */\n package org.mockito.cglib.proxy;\n \n-import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.asm.Attribute;\n import org.mockito.asm.ClassVisitor;\n import org.mockito.asm.Label;\n import org.mockito.asm.Type;\n public class Enhancer extends AbstractClassGenerator\n {\n     private static final CallbackFilter ALL_ZERO = new CallbackFilter(){\n-        public int accept(Method method) {\n+        public int accept(Method method, List<Method> allMethods) {\n             return 0;\n         }\n     };\n         while (it1.hasNext()) {\n             MethodInfo method = (MethodInfo)it1.next();\n             Method actualMethod = (it2 != null) ? (Method)it2.next() : null;\n-            int index = filter.accept(actualMethod);\n+            int index = filter.accept(actualMethod, actualMethods);\n             if (index >= callbackTypes.length) {\n                 throw new IllegalArgumentException(\"Callback filter returned an index that is too large: \" + index);\n             }\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/Proxy.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Proxy.java\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.lang.reflect.Member;\n+import java.util.List;\n \n import org.mockito.cglib.core.CodeGenerationException;\n \n     protected InvocationHandler h;\n \n     private static final CallbackFilter BAD_OBJECT_METHOD_FILTER = new CallbackFilter() {\n-        public int accept(Method method) {\n+        public int accept(Method method, List<Method> allMethods) {\n             if (method.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\n                 String name = method.getName();\n                 if (!(name.equals(\"hashCode\") ||\n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n          * See original {@link OngoingStubbing#thenAnswer(Answer)}\n          */\n         BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer);\n-        \n+\n+        /**\n+         * See original {@link OngoingStubbing#then(Answer)}\n+         */\n+        BDDMyOngoingStubbing<T> will(Answer<?> answer);\n+\n         /**\n          * See original {@link OngoingStubbing#thenReturn(Object)}\n          */\n         BDDMyOngoingStubbing<T> willReturn(T value);\n-        \n-        /**\n-         * See original {@link OngoingStubbing#thenReturn(Object, Object...)}\n+\n+        /**\n+         * See original {@link OngoingStubbing#thenReturn(Object, Object[])}\n          */\n         BDDMyOngoingStubbing<T> willReturn(T value, T... values);\n-        \n+\n         /**\n          * See original {@link OngoingStubbing#thenThrow(Throwable...)}\n          */\n         BDDMyOngoingStubbing<T> willThrow(Throwable... throwables);\n \n         /**\n+         * See original {@link OngoingStubbing#thenThrow(Class[])}\n+         */\n+        BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses);\n+\n+        /**\n          * See original {@link OngoingStubbing#thenCallRealMethod()}\n          */\n         BDDMyOngoingStubbing<T> willCallRealMethod();\n+\n+        /**\n+         * See original {@link OngoingStubbing#getMock()}\n+         */\n+        <M> M getMock();\n     }\n     \n     public static class BDDOngoingStubbingImpl<T> implements BDDMyOngoingStubbing<T> {\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDMyOngoingStubbing#willAnswer(org.mockito.stubbing.Answer)\n+         * @see BDDMockito.BDDMyOngoingStubbing#willAnswer(Answer)\n          */\n         public BDDMyOngoingStubbing<T> willAnswer(Answer<?> answer) {\n             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenAnswer(answer));\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDMyOngoingStubbing#willReturn(java.lang.Object)\n+         * @see BDDMockito.BDDMyOngoingStubbing#will(Answer)\n+         */\n+        public BDDMyOngoingStubbing<T> will(Answer<?> answer) {\n+            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.then(answer));\n+        }\n+\n+        /* (non-Javadoc)\n+         * @see BDDMockito.BDDMyOngoingStubbing#willReturn(java.lang.Object)\n          */\n         public BDDMyOngoingStubbing<T> willReturn(T value) {\n             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenReturn(value));\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDMyOngoingStubbing#willReturn(java.lang.Object, T[])\n+         * @see BDDMockito.BDDMyOngoingStubbing#willReturn(java.lang.Object, T[])\n          */\n         public BDDMyOngoingStubbing<T> willReturn(T value, T... values) {\n             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenReturn(value, values));\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDMyOngoingStubbing#willThrow(java.lang.Throwable[])\n+         * @see BDDMockito.BDDMyOngoingStubbing#willThrow(java.lang.Throwable[])\n          */\n         public BDDMyOngoingStubbing<T> willThrow(Throwable... throwables) {\n             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwables));\n         }\n+        /* (non-Javadoc)\n+         * @see BDDMockito.BDDMyOngoingStubbing#willThrow(java.lang.Class[])\n+         */\n+        public BDDMyOngoingStubbing<T> willThrow(Class<? extends Throwable>... throwableClasses) {\n+            return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenThrow(throwableClasses));\n+        }\n \n         public BDDMyOngoingStubbing<T> willCallRealMethod() {\n             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenCallRealMethod());\n         }\n+\n+        public <M> M getMock() {\n+            return (M) mockitoOngoingStubbing.getMock();\n+        }\n     }\n     \n     /**\n          * See original {@link Stubber#doThrow(Throwable)}\n          */\n         BDDStubber willThrow(Throwable toBeThrown);\n-        \n+\n+        /**\n+         * See original {@link Stubber#doThrow(Class)}\n+         */\n+        BDDStubber willThrow(Class<? extends Throwable> toBeThrown);\n+\n         /**\n          * See original {@link Stubber#when(Object)}\n          */\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDStubber#given(java.lang.Object)\n+         * @see BDDMockito.BDDStubber#given(java.lang.Object)\n          */\n         public <T> T given(T mock) {\n             return mockitoStubber.when(mock);\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDStubber#willAnswer(org.mockito.stubbing.Answer)\n+         * @see BDDMockito.BDDStubber#willAnswer(Answer)\n          */\n         public BDDStubber willAnswer(Answer answer) {\n             return new BDDStubberImpl(mockitoStubber.doAnswer(answer));\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDStubber#willNothing()\n+         * @see BDDMockito.BDDStubber#willNothing()\n          */\n         public BDDStubber willNothing() {\n             return new BDDStubberImpl(mockitoStubber.doNothing());\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDStubber#willReturn(java.lang.Object)\n+         * @see BDDMockito.BDDStubber#willReturn(java.lang.Object)\n          */\n         public BDDStubber willReturn(Object toBeReturned) {\n             return new BDDStubberImpl(mockitoStubber.doReturn(toBeReturned));\n         }\n \n         /* (non-Javadoc)\n-         * @see org.mockitousage.customization.BDDMockito.BDDStubber#willThrow(java.lang.Throwable)\n+         * @see BDDMockito.BDDStubber#willThrow(java.lang.Throwable)\n          */\n         public BDDStubber willThrow(Throwable toBeThrown) {\n             return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));\n         }\n+\n+        /* (non-Javadoc)\n+         * @see BDDMockito.BDDStubber#willThrow(Class)\n+         */\n+        public BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {\n+            return new BDDStubberImpl(mockitoStubber.doThrow(toBeThrown));\n+        }\n     }\n     \n     /**\n      * see original {@link Mockito#doThrow(Throwable)}\n      */\n     public static BDDStubber willThrow(Throwable toBeThrown) {\n+        return new BDDStubberImpl(Mockito.doThrow(toBeThrown));\n+    }\n+\n+    /**\n+     * see original {@link Mockito#doThrow(Throwable)}\n+     */\n+    public static BDDStubber willThrow(Class<? extends Throwable> toBeThrown) {\n         return new BDDStubberImpl(Mockito.doThrow(toBeThrown));\n     }\n     \n     public static BDDStubber willCallRealMethod() {\n         return new BDDStubberImpl(Mockito.doCallRealMethod());\n     }\n-}\n+}\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n-\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.*;\n import org.mockito.internal.progress.HandyReturnValues;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n /**\n  * Allow flexible verification or stubbing. See also {@link AdditionalMatchers}.\n     }\n \n     /**\n+     * null argument.\n+     * The class argument is provided to avoid casting.\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     *\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T isNull(Class<T> clazz) {\n+        return (T) reportMatcher(Null.NULL).returnNull();\n+    }\n+\n+    /**\n      * not null argument.\n      * <p>\n      * alias to {@link Matchers#isNotNull()}\n     public static Object notNull() {\n         return reportMatcher(NotNull.NOT_NULL).returnNull();\n     }\n+\n+    /**\n+     * not null argument, not necessary of the given class.\n+     * The class argument is provided to avoid casting.\n+     * <p>\n+     * alias to {@link Matchers#isNotNull(Class)}\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     *\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T notNull(Class<T> clazz) {\n+        return (T) reportMatcher(NotNull.NOT_NULL).returnNull();\n+    }\n     \n     /**\n      * not null argument.\n      */\n     public static Object isNotNull() {\n         return notNull();\n+    }\n+\n+    /**\n+     * not null argument, not necessary of the given class.\n+     * The class argument is provided to avoid casting.\n+     * <p>\n+     * alias to {@link Matchers#notNull(Class)}\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     *\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T isNotNull(Class<T> clazz) {\n+        return notNull(clazz);\n     }\n \n     /**\n     private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n         return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n     }\n-}\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.debugging.MockitoDebuggerImpl;\n-import org.mockito.internal.stubbing.answers.AnswerReturnValuesAdapter;\n-import org.mockito.internal.stubbing.answers.CallsRealMethods;\n-import org.mockito.internal.stubbing.answers.DoesNothing;\n-import org.mockito.internal.stubbing.answers.Returns;\n-import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.internal.stubbing.answers.*;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.runners.MockitoJUnitRunner;\n-import org.mockito.stubbing.Answer;\n-import org.mockito.stubbing.DeprecatedOngoingStubbing;\n-import org.mockito.stubbing.OngoingStubbing;\n-import org.mockito.stubbing.Stubber;\n-import org.mockito.stubbing.VoidMethodStubbable;\n-import org.mockito.verification.VerificationWithTimeout;\n+import org.mockito.stubbing.*;\n import org.mockito.verification.Timeout;\n import org.mockito.verification.VerificationMode;\n+import org.mockito.verification.VerificationWithTimeout;\n \n /**\n  * <p align=\"left\"><img src=\"logo.jpg\"/></p>\n  *      <a href=\"#21\">21. New annotations: &#064;Captor, &#064;Spy, &#064;InjectMocks (Since 1.8.3) </a><br/>\n  *      <a href=\"#22\">22. (New) Verification with timeout (Since 1.8.5) </a><br/>\n  *      <a href=\"#23\">23. (**New**) Automatic instantiation of &#064;Spy, &#064;InjectMocks fields (Since 1.9)</a><br/>\n+ *      <a href=\"#24\">24. (**New**) Inline mock creation and stubbing (Since 1.9)</a><br/>\n  * </b>\n  * \n  * <p>\n  * &#064;InjectMocks LocalPub;\n  * </pre>\n  *\n+ * <h3> id=\"24\">24. (**New**) Inline mock creation and stubbing (Since 1.9)\n+ * <p>\n+ * Mockito will now allow you to create mocks when stubbing. Example :\n+ * <pre>\n+ * Car car = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();\n+ * </pre>\n+ *\n+ *\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     }\n \n     /**\n+     * Use doThrow() when you want to stub the void method to throw exception of specified class.\n+     * <p>\n+     * A new exception instance will be created for each method invocation.\n+     * <p>\n+     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+     * <p>\n+     * Example:\n+     *\n+     * <pre>\n+     *   doThrow(RuntimeException.class).when(mock).someVoidMethod();\n+     * </pre>\n+     *\n+     * @param toBeThrown to be thrown when the stubbed method is called\n+     * @return stubber - to select a method for stubbing\n+     */\n+    public static Stubber doThrow(Class<? extends Throwable> toBeThrown) {\n+        return MOCKITO_CORE.doAnswer(new ThrowsExceptionClass(toBeThrown));\n+    }\n+\n+\n+    /**\n      * Use doCallRealMethod() when you want to call the real implementation of a method.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n     static MockitoDebugger debug() {\n         return new MockitoDebuggerImpl();\n     }\n+\n }\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n         if (testClass == null) {\n             throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n         }\n-        \n+\n+        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n         Class<?> clazz = testClass.getClass();\n-        while (clazz != Object.class) {\n-            scan(testClass, clazz);\n-            clazz = clazz.getSuperclass();\n+\n+        //below can be removed later, when we get rid of deprecated stuff\n+        if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n+            //this means user has his own annotation engine and we have to respect that.\n+            //we will do annotation processing the old way so that we are backwards compatible\n+            while (clazz != Object.class) {\n+                scanDeprecatedWay(annotationEngine, testClass, clazz);\n+                clazz = clazz.getSuperclass();\n+            }\n         }\n+\n+        //anyway act 'the new' way\n+        annotationEngine.process(testClass.getClass(), testClass);\n     }\n \n-    static void scan(Object testClass, Class<?> clazz) {\n-        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n+    static void scanDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Class<?> clazz) {\n         Field[] fields = clazz.getDeclaredFields();\n+\n         for (Field field : fields) {\n-            //below can be removed later, when we get rid of deprecated stuff\n-            if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n-                //this means user has his own annotation engine and we have to respect that.\n-                //we will do annotation processing the old way so that we are backwards compatible\n-                processAnnotationDeprecatedWay(annotationEngine, testClass, field);                \n-            } \n+            processAnnotationDeprecatedWay(annotationEngine, testClass, field);\n         }\n-        //act 'the new' way\n-        annotationEngine.process(clazz, testClass);\n     }\n \n     @SuppressWarnings(\"deprecation\")\n--- a/src/org/mockito/configuration/AnnotationEngine.java\n+++ b/src/org/mockito/configuration/AnnotationEngine.java\n  */\n package org.mockito.configuration;\n \n+import org.mockito.MockitoAnnotations;\n+\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n-\n-import org.mockito.MockitoAnnotations;\n \n /**\n  * Configures mock creation logic behind &#064;Mock, &#064;Captor and &#064;Spy annotations\n \n     /**\n      * @deprecated\n-     * Please use AnnotationProcessor 'execute' method instead that is more robust\n+     * Please use {@link AnnotationEngine#process(Class, Object)} method instead that is more robust\n      * <p>\n      * Creates mock, ArgumentCaptor or wraps field instance in spy object.\n      * Only if of correct annotation type.\n      *\n-     * @param annotation\n-     * @param field\n+     * @param annotation Annotation\n+     * @param field Field details\n      */\n     @Deprecated\n     Object createMockFor(Annotation annotation, Field field);\n \n     /**\n-     * Allows extending the interface to perform action on specific fields on the test class\n+     * Allows extending the interface to perform action on specific fields on the test class.\n      * <p>\n-     * See the implementation of this method to figure out what is it for\n+     * See the implementation of this method to figure out what is it for.\n      * \n-     * @param context\n-     * @param testClass \n+     * @param clazz Class where to extract field information, check implementation for details\n+     * @param testInstance Test instance\n      */\n-    void process(Class<?> context, Object testClass);\n+    void process(Class<?> clazz, Object testInstance);\n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n-import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.exceptions.misusing.NullInsteadOfMockException;\n-import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n-import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n-import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n+import org.mockito.exceptions.misusing.*;\n import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n                 \"Also, this error might show up because:\",\n                 \"1. you stub either of: final/private/equals()/hashCode() methods.\",\n                 \"   Those methods *cannot* be stubbed/verified.\",\n-                \"2. inside when() you don't call method on mock but on some other object.\"\n+                \"2. inside when() you don't call method on mock but on some other object.\",\n+                \"\"\n         ));\n     }\n \n             \"   //and... don't forget about some @Mocks for injection :)\",\n                 \"\"), details);\n     }\n+\n+    public void atMostShouldNotBeUsedWithTimeout() {\n+        throw new FriendlyReminderException(join(\"\",\n+                \"Don't panic! I'm just a friendly reminder!\",\n+                \"timeout() should not be used with atMost() because...\",\n+                \"...it does not make much sense - the test would have passed immediately in concurency\",\n+                \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n+                \"In future release we will remove timeout(x).atMost(y) from the API.\",\n+                \"If you want to find out more please refer to issue 235\",\n+                \"\"));\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/misusing/FriendlyReminderException.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.misusing;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class FriendlyReminderException extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public FriendlyReminderException(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal;\n-\n-import java.util.List;\n \n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.InvocationContainer;\n-import org.mockito.internal.stubbing.InvocationContainerImpl;\n-import org.mockito.internal.stubbing.OngoingStubbingImpl;\n-import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n+import org.mockito.internal.stubbing.*;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n \n /**\n  * Invocation handler set on mock objects.\n                 mockingProgress.verificationStarted(verificationMode);\n             }\n         }\n-        \n+\n+        // prepare invocation for stubbing\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n         OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n         mockingProgress.reportOngoingStubbing(ongoingStubbing);\n \n+        // look for existing answer for this invocation\n         StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n \n         if (stubbedInvocation != null) {\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n                     \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n         } catch (Exception e) {\n             throw new MockitoConfigurationException(\"\\n\" +\n-                    \"Unable to instantianate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n+                    \"Unable to instantiate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n         }\n     }\n }\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Captor;\n-import org.mockito.Mock;\n-import org.mockito.MockSettings;\n-import org.mockito.Mockito;\n-import org.mockito.MockitoAnnotations;\n+import org.mockito.*;\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.reflection.FieldSetter;\n import org.mockito.internal.util.reflection.GenericMaster;\n \n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n- * <p/>\n- * See {@link MockitoAnnotations}\n+ *\n+ * <p>\n+ * The {@link #process(Class, Object)} method implementation <strong>does not</strong> process super classes!\n+ *\n+ * @see {@link MockitoAnnotations}\n  */\n @SuppressWarnings(\"unchecked\")\n public class DefaultAnnotationEngine implements AnnotationEngine {\n         return ArgumentCaptor.forClass(cls);    \n     }           \n \n-    public void process(Class<?> clazz, Object testClass) {\n+    public void process(Class<?> clazz, Object testInstance) {\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n             boolean alreadyAssigned = false;\n                     throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                     alreadyAssigned = true;                    \n                     try {\n-                        new FieldSetter(testClass, field).set(mock);\n+                        new FieldSetter(testInstance, field).set(mock);\n                     } catch (Exception e) {\n                         throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                 + annotation, e);\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import java.lang.reflect.Field;\n-import java.util.Set;\n-\n import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\n import org.mockito.internal.configuration.injection.MockCandidateFilter;\n import org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\n import org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\n-import org.mockito.internal.util.reflection.AccessibilityChanger;\n-import org.mockito.internal.util.reflection.ConstructorInitializer;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n /**\n- * Initializes mock/spies dependencies for fields annotated with\n- * &#064;InjectMocks\n+ * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n  * <p/>\n  * See {@link org.mockito.MockitoAnnotations}\n  */\n public class DefaultInjectionEngine {\n \n-\tprivate final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(\n-\t\t\tnew NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n+    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n+    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n+        public int compare(Field field1, Field field2) {\n+            Class<?> field1Type = field1.getType();\n+            Class<?> field2Type = field2.getType();\n \n-\t// for each tested\n-\t// - for each field of tested\n-\t// - find mock candidate by type\n-\t// - if more than *one* find mock candidate on name\n-\t// - if one mock candidate then set mock\n-\t// - else don't fail, user will then provide dependencies\n-\tpublic void injectMocksOnFields(Set<Field> testClassFields,\n-\t\t\tSet<Object> mocks, Object testClass) {\n-\t\tfor (Field field : testClassFields) {\n-\t\t\tif (hasDefaultConstructor(field, testClass) || alreadyInitialized(field, testClass)) {\n-\t\t\t\tsetterInject(mocks, testClass, field);\n-\t\t\t} else {\n-\t\t\t\tconstructorInject(mocks, testClass, field);\n-\t\t\t}\n-\t\t}\n-\t}\n+            if(field1Type.isAssignableFrom(field2Type)) {\n+                return 1;\n+            }\n+            if(field2Type.isAssignableFrom(field1Type)) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+    };\n \n-\tprivate void constructorInject(Set<Object> mocks, Object testClass,\n-\t\t\tField field) {\n-\t\tnew ConstructorInitializer(field, testClass).initialize(mocks);\n-\t}\n+    /**\n+     * Inject mocks in injectMocksFields, and initialize them if needed.\n+     *\n+     * <p>\n+     * <u>Algorithm :<br></u>\n+     * for each field annotated by @InjectMocks\n+     *   <ul>\n+     *   <li>copy mocks set\n+     *   <li>initialize field annotated by @InjectMocks\n+     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n+     *     <ul>\n+     *     <li>find mock candidate by type\n+     *     <li>if more than *one* candidate find mock candidate on name\n+     *     <li>if one mock candidate then\n+     *       <ul>\n+     *       <li>set mock by property setter if possible\n+     *       <li>else set mock by field injection\n+     *       </ul>\n+     *     <li>remove mock from mocks copy (mocks are just injected once)\n+     *     <li>else don't fail, user will then provide dependencies\n+     *     </ul>\n+     *   </ul>\n+     * </p>\n+     *\n+     * @param injectMocksFields Fields annotated by @InjectMocks\n+     * @param mocks Mocks\n+     * @param testClassInstance The test class instance\n+     */\n+    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n+        for (Field field : injectMocksFields) {\n+            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n+            Object injectMocksFieldInstance = null;\n+            try {\n+                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n+            } catch (MockitoException e) {\n+                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n+            }\n \n-\tprivate void setterInject(Set<Object> mocks, Object testClass, Field field) {\n-\t\ttry {\n-\t\t\tObject fieldInstance = new FieldInitializer(testClass, field)\n-\t\t\t\t\t.initialize();\n-\t\t\tClass<?> fieldClass = fieldInstance.getClass();\n-\t\t\t// for each field in the class hierarchy\n-\t\t\twhile (fieldClass != Object.class) {\n-\t\t\t\tinjectMockCandidate(fieldClass, mocks, fieldInstance);\n-\t\t\t\tfieldClass = fieldClass.getSuperclass();\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tnew Reporter().cannotInitializeForInjectMocksAnnotation(\n-\t\t\t\t\tfield.getName(), e);\n-\t\t}\n+            // for each field in the class hierarchy\n+            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n+            while (fieldClass != Object.class) {\n+                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n+                fieldClass = fieldClass.getSuperclass();\n+            }\n+        }\n+    }\n \n-\t}\n+    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n+        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+            mocks.remove(injected);\n+        }\n+    }\n \n-\tprivate boolean hasDefaultConstructor(Field field, Object testClass) {\n-\t\ttry {\n-\t\t\tfield.getType().getDeclaredConstructor();\n-\t\t\treturn true;\n-\t\t} catch (Exception e) {\n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\n-\tprivate boolean alreadyInitialized(Field field, Object testClass) {\n-\t\tfinal AccessibilityChanger changer = new AccessibilityChanger();\n-\t\tchanger.enableAccess(field);\n-\t\ttry {\n-\t\t\treturn field.get(testClass) != null;\n-\t\t} catch (Exception e) {\n-\t\t\treturn false;\n-\t\t} finally {\n-\t\t\tchanger.safelyDisableAccess(field);\n-\t\t}\n-\t}\n-\n-\tprivate void injectMockCandidate(Class<?> awaitingInjectionClazz,\n-\t\t\tSet<Object> mocks, Object fieldInstance) {\n-\t\tfor (Field field : awaitingInjectionClazz.getDeclaredFields()) {\n-\t\t\tmockCandidateFilter.filterCandidate(mocks, field, fieldInstance)\n-\t\t\t\t\t.thenInject();\n-\t\t}\n-\t}\n+    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n+        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n+        Arrays.sort(declaredFields, supertypesLast);\n+        return declaredFields;\n+    }\n \n }\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n     \n     AnnotationEngine delegate = new DefaultAnnotationEngine();\n     AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n-    \n-    /* (non-Javadoc)\n-    * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n-    */    \n+\n+    /***\n+     * Create a mock using {@link DefaultAnnotationEngine}\n+     *\n+     * @see org.mockito.internal.configuration.DefaultAnnotationEngine\n+     * @see org.mockito.configuration.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n+     */\n+    @Deprecated\n     public Object createMockFor(Annotation annotation, Field field) {\n         return delegate.createMockFor(annotation, field);\n     }\n-    \n-    public void process(Class<?> context, Object testClass) {\n-        //this will create @Mocks, @Captors, etc:\n-        delegate.process(context, testClass);\n-        //this will create @Spies:\n-        spyAnnotationEngine.process(context, testClass);\n-        \n-        //this injects mocks\n-        Field[] fields = context.getDeclaredFields();\n-        for (Field field : fields) {\n-            if (field.isAnnotationPresent(InjectMocks.class)) {\n-                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n-                injectMocks(testClass);\n+\n+    /**\n+     * Process the fields of the test instance and create Mocks, Spies, Captors and inject them on fields\n+     * annotated &#64;InjectMocks.\n+     *\n+     * <p>\n+     * This code process the test class and the super classes.\n+     * <ol>\n+     * <li>First create Mocks, Spies, Captors.</li>\n+     * <li>Then try to inject them.</li>\n+     * </ol>\n+     *\n+     * @param clazz Not used\n+     * @param testInstance The instance of the test, should not be null.\n+     *\n+     * @see org.mockito.configuration.AnnotationEngine#process(Class, Object)\n+     */\n+    public void process(Class<?> clazz, Object testInstance) {\n+        processIndependentAnnotations(testInstance.getClass(), testInstance);\n+        processInjectMocks(testInstance.getClass(), testInstance);\n+    }\n+\n+    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n+        Class<?> classContext = clazz;\n+        while (classContext != Object.class) {\n+            //this injects mocks\n+            Field[] fields = classContext.getDeclaredFields();\n+            for (Field field : fields) {\n+                if (field.isAnnotationPresent(InjectMocks.class)) {\n+                    assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n+                    injectMocks(testInstance);\n+                }\n             }\n+            classContext = classContext.getSuperclass();\n         }\n-    } \n-    \n-    void assertNoAnnotations(Field field, Class ... annotations) {\n+    }\n+\n+    private void processIndependentAnnotations(final Class<?> clazz, final Object testInstance) {\n+        Class<?> classContext = clazz;\n+        while (classContext != Object.class) {\n+            //this will create @Mocks, @Captors, etc:\n+            delegate.process(classContext, testInstance);\n+            //this will create @Spies:\n+            spyAnnotationEngine.process(classContext, testInstance);\n+\n+            classContext = classContext.getSuperclass();\n+        }\n+    }\n+\n+    void assertNoAnnotations(final Field field, final Class ... annotations) {\n         for (Class annotation : annotations) {\n             if (field.isAnnotationPresent(annotation)) {\n                 new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n      * @param testClass\n      *            Test class, usually <code>this</code>\n      */\n-    public void injectMocks(Object testClass) {       \n+    public void injectMocks(final Object testClass) {\n         Class<?> clazz = testClass.getClass();\n         Set<Field> mockDependents = new HashSet<Field>();\n         Set<Object> mocks = new HashSet<Object>();\n         new DefaultInjectionEngine().injectMocksOnFields(mockDependents, mocks, testClass);\n     }\n \n-    private static Set<Field> scanForInjection(Object testClass, Class<?> clazz) {\n+    /**\n+     * Scan fields annotated by &#064;InjectMocks\n+     *\n+     * @param testClass\n+     * @param clazz\n+     * @return\n+     */\n+    private static Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n         Set<Field> testedFields = new HashSet<Field>();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n         return testedFields;\n     }\n \n-    private static Set<Object> scanMocks(Object testClass, Class<?> clazz) {\n+    private static Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n         Set<Object> mocks = new HashSet<Object>();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n             if (null != field.getAnnotation(Spy.class) || null != field.getAnnotation(org.mockito.Mock.class)\n-                    || null != field.getAnnotation(Mock.class)) {\n+                    || null != field.getAnnotation(org.mockito.MockitoAnnotations.Mock.class)) {\n                 Object fieldInstance = null;\n                 boolean wasAccessible = field.isAccessible();\n                 field.setAccessible(true);\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n     }\n     \n     @SuppressWarnings(\"deprecation\")\n-    public void process(Class<?> context, Object testClass) {\n+    public void process(Class<?> context, Object testInstance) {\n         Field[] fields = context.getDeclaredFields();\n         for (Field field : fields) {\n             if (field.isAnnotationPresent(Spy.class)) {\n                 assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                 Object instance = null;\n                 try {\n-                    instance = new FieldInitializer(testClass, field).initialize();\n+                    instance = new FieldInitializer(testInstance, field).initialize();\n                 } catch (MockitoException e) {\n                     new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                 }\n                         Mockito.reset(instance);\n                     } else {\n                         field.setAccessible(true);\n-                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n+                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                 .spiedInstance(instance)\n                                 .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                 .name(field.getName())));\n--- a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n             final Object matchingMock = mocks.iterator().next();\n \n             return new OngoingInjecter() {\n-                public boolean thenInject() {\n+                public Object thenInject() {\n                     try {\n                         if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\n                     } catch (Exception e) {\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                     }\n-                    return true;\n+                    return matchingMock;\n                 }\n             };\n         }\n \n         return new OngoingInjecter() {\n-            public boolean thenInject() {\n-                return false;\n+            public Object thenInject() {\n+                return null;\n             }\n         };\n \n--- a/src/org/mockito/internal/configuration/injection/OngoingInjecter.java\n+++ b/src/org/mockito/internal/configuration/injection/OngoingInjecter.java\n      * Please check the actual implementation.\n      * </p>\n      *\n-     * @return <code>true</code> if injected, <code>false</code> otherwise.\n+     * @return the mock that was injected, <code>null</code> otherwise.\n      */\n-    boolean thenInject();\n+    Object thenInject();\n \n-}\n+}\n--- a/src/org/mockito/internal/stubbing/BaseStubbing.java\n+++ b/src/org/mockito/internal/stubbing/BaseStubbing.java\n import org.mockito.internal.stubbing.answers.CallsRealMethods;\n import org.mockito.internal.stubbing.answers.Returns;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;\n import org.mockito.stubbing.DeprecatedOngoingStubbing;\n import org.mockito.stubbing.OngoingStubbing;\n \n         return stubbing;\n     }        \n \n+    private OngoingStubbing<T> thenThrow(Class<? extends Throwable> throwableClass) {\n+        return thenAnswer(new ThrowsExceptionClass(throwableClass));\n+    }\n+\n+    public OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses) {\n+        if (throwableClasses == null) {\n+            thenThrow((Throwable) null);\n+        }\n+        OngoingStubbing<T> stubbing = null;\n+        for (Class<? extends Throwable> t: throwableClasses) {\n+            if (stubbing == null) {\n+                stubbing = thenThrow(t);\n+            } else {\n+                stubbing = stubbing.thenThrow(t);\n+            }\n+        }\n+        return stubbing;\n+    }\n+\n     public OngoingStubbing<T> thenCallRealMethod() {\n         return thenAnswer(new CallsRealMethods());\n     }\n     public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n         return toAnswer(new ThrowsException(throwable));\n     }\n-}\n+}\n--- a/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java\n+++ b/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java\n         invocationContainerImpl.addConsecutiveAnswer(answer);\n         return this;\n     }\n+\n+    public OngoingStubbing<T> then(Answer<?> answer) {\n+        return thenAnswer(answer);\n+    }\n     \n     public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n         invocationContainerImpl.addConsecutiveAnswer(answer);\n         return this;\n     }\n+\n+    public <M> M getMock() {\n+        return (M) invocationContainerImpl.invokedMock();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.stubbing.answers.AnswersValidator;\n import org.mockito.internal.verification.RegisteredInvocations;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationContainerImpl implements InvocationContainer, Serializable {\n     public List<StubbedInvocationMatcher> getStubbedInvocations() {\n         return stubbed;\n     }\n+\n+    public Object invokedMock() {\n+        return invocationForStubbing.getInvocation().getMock();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n         return new ConsecutiveStubbing<T>(invocationContainerImpl);\n     }\n \n+    public OngoingStubbing<T> then(Answer<?> answer) {\n+        return thenAnswer(answer);\n+    }\n+\n     public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n         invocationContainerImpl.addAnswer(answer);\n         return new ConsecutiveStubbing<T>(invocationContainerImpl);\n         //TODO interface for tests\n         return invocationContainerImpl.getInvocations();\n     }\n+\n+    public <M> M getMock() {\n+        return (M) invocationContainerImpl.invokedMock();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/StubberImpl.java\n+++ b/src/org/mockito/internal/stubbing/StubberImpl.java\n  */\n package org.mockito.internal.stubbing;\n \n-import java.util.LinkedList;\n-import java.util.List;\n-\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.stubbing.answers.DoesNothing;\n import org.mockito.internal.stubbing.answers.Returns;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.Stubber;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class StubberImpl implements Stubber {\n         return this;\n     }\n \n+    public Stubber doThrow(Class<? extends Throwable> toBeThrown) {\n+        answers.add(new ThrowsExceptionClass(toBeThrown));\n+        return this;\n+    }\n+\n     public Stubber doNothing() {\n         answers.add(new DoesNothing());\n         return this;\n         answers.add(answer);\n         return this;\n     }\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.objenesis.ObjenesisHelper;\n+\n+import java.io.Serializable;\n+\n+public class ThrowsExceptionClass implements Answer<Object>, Serializable {\n+\n+    private Class<? extends Throwable> throwableClass;\n+    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n+\n+    public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {\n+\n+        this.throwableClass = throwableClass;\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+\n+        Throwable throwable = (Throwable) ObjenesisHelper.newInstance(throwableClass);\n+        throwable.fillInStackTrace();\n+        filter.filter(throwable);\n+        throw throwable;\n+    }\n+\n+    public Class<? extends Throwable> getThrowableClass() {\n+        return throwableClass;\n+    }\n+}\n--- a/src/org/mockito/internal/util/reflection/ConstructorInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/ConstructorInitializer.java\n package org.mockito.internal.util.reflection;\n \n-import static org.mockito.Mockito.mock;\n+import org.mockito.exceptions.Reporter;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n \n-import org.mockito.exceptions.Reporter;\n+import static org.mockito.Mockito.mock;\n \n public class ConstructorInitializer {\n \n \t\t\t\t.getConstructors());\n \t\tCollections.sort(constructors, new Comparator<Constructor<?>>() {\n \n-\t\t\t@Override\n \t\t\tpublic int compare(Constructor<?> o1, Constructor<?> o2) {\n \t\t\t\treturn o2.getParameterTypes().length\n \t\t\t\t\t\t- o1.getParameterTypes().length;\n--- a/src/org/mockito/stubbing/OngoingStubbing.java\n+++ b/src/org/mockito/stubbing/OngoingStubbing.java\n      */\n     OngoingStubbing<T> thenThrow(Throwable... throwables);\n \n+    /**\n+     * Sets Throwable classes to be thrown when the method is called. E.g:\n+     * <pre>\n+     * when(mock.someMethod()).thenThrow(RuntimeException.class);\n+     * </pre>\n+     *\n+     * <p>\n+     * Each throwable class will be instantiated for each method invocation.\n+     * <p>\n+     * If throwableClasses contain a checked exception then it has to\n+     * match one of the checked exceptions of method signature.\n+     * <p>\n+     * You can specify throwableClasses to be thrown for consecutive calls.\n+     * In that case the last throwable determines the behavior of further consecutive calls.\n+     * <p>\n+     * if throwable is null then exception will be thrown.\n+     * <p>\n+     * See examples in javadoc for {@link Mockito#when}\n+     *\n+     * @param throwableClasses to be thrown on method invocation\n+     *\n+     * @return iOngoingStubbing object that allows stubbing consecutive calls\n+     */\n+    OngoingStubbing<T> thenThrow(Class<? extends Throwable>... throwableClasses);\n+\n     /**     \n      * Sets the real implementation to be called when the method is called on a mock object.\n      * <p>\n      * @return iOngoingStubbing object that allows stubbing consecutive calls\n      */\n     OngoingStubbing<T> thenAnswer(Answer<?> answer);\n+\n+    /**\n+     * Sets a generic Answer for the method.\n+     *\n+     * This method is an alias of {@link #thenAnswer(Answer)}.\n+     *\n+     * @param answer the custom answer to execute.\n+     * @return iOngoingStubbing object that allows stubbing consecutive calls\n+     *\n+     * @see #thenAnswer(Answer)\n+     */\n+    OngoingStubbing<T> then(Answer<?> answer);\n+\n+    /**\n+     * Returns the mock that was used for this stub.\n+     *\n+     * This code allows fast mock creation and stubbing. E.g:\n+     * <pre>\n+     * Set mockedSet = when(mock(Set.class).isEmpty()).thenReturn(false).getMock();\n+     * </pre>\n+     *\n+     * @param <M> The mock type given by the variable type.\n+     * @return Mock used in this ongoing stubbing.\n+     */\n+    <M> M getMock();\n+\n }\n--- a/src/org/mockito/stubbing/Stubber.java\n+++ b/src/org/mockito/stubbing/Stubber.java\n      * @return stubber - to select a method for stubbing\n      */\n     Stubber doThrow(Throwable toBeThrown);\n-    \n+\n+    /**\n+     * Use it for stubbing consecutive calls in {@link Mockito#doThrow(Class<? extends Throwable>)} style:\n+     * <pre>\n+     *   doThrow(RuntimeException.class).\n+     *   doThrow(IllegalArgumentException.class)\n+     *   .when(mock).someVoidMethod();\n+     * </pre>\n+     * See javadoc for {@link Mockito#doThrow(Class)}\n+     *\n+     * @param toBeThrown exception class to be thrown when the stubbed method is called\n+     * @return stubber - to select a method for stubbing\n+     */\n+    Stubber doThrow(Class<? extends Throwable> toBeThrown);\n+\n     /**\n      * Use it for stubbing consecutive calls in {@link Mockito#doAnswer(Answer)} style:\n      * <pre>\n      * @return stubber - to select a method for stubbing\n      */\n     Stubber doReturn(Object toBeReturned);\n-}\n+}\n--- a/src/org/mockito/verification/Timeout.java\n+++ b/src/org/mockito/verification/Timeout.java\n  */\n package org.mockito.verification;\n \n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.misusing.FriendlyReminderException;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.VerificationWithTimeoutImpl;\n import org.mockito.internal.verification.api.VerificationData;\n \n /**\n  * See the javadoc for {@link VerificationWithTimeout}\n+ * <p>\n+ * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n+ * See javadoc for {@link VerificationWithTimeout}\n  */\n public class Timeout implements VerificationWithTimeout {\n \n \n     /**\n      * See the javadoc for {@link VerificationWithTimeout}\n+     * <p>\n+     * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n+     * See javadoc for {@link VerificationWithTimeout}\n      */\n     public Timeout(int millis, VerificationMode delegate) {\n         this(10, millis, delegate);\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     Timeout(int treshhold, int millis, VerificationMode delegate) {\n         this.impl = new VerificationWithTimeoutImpl(treshhold, millis, delegate);\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public void verify(VerificationData data) {\n         impl.verify(data);\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public VerificationMode atLeast(int minNumberOfInvocations) {\n         return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeast(minNumberOfInvocations));\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public VerificationMode atLeastOnce() {\n         return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeastOnce());\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public VerificationMode atMost(int maxNumberOfInvocations) {\n-        return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atMost(maxNumberOfInvocations));\n+        new Reporter().atMostShouldNotBeUsedWithTimeout();\n+        return null;\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public VerificationMode never() {\n         return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(0));\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public VerificationMode only() {\n         return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.only());\n     }\n \n+    /**\n+     * See the javadoc for {@link VerificationWithTimeout}\n+     */\n     public VerificationMode times(int wantedNumberOfInvocations) {\n         return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(wantedNumberOfInvocations));\n     }\n--- a/src/org/mockito/verification/VerificationWithTimeout.java\n+++ b/src/org/mockito/verification/VerificationWithTimeout.java\n     public VerificationMode atLeast(int minNumberOfInvocations);\n \n     /**\n-     * Allows at-most-x verification within given timeout. E.g:\n-     * <pre>\n-     *   verify(mock, timeout(100).atMost(3)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param maxNumberOfInvocations max number of invocations \n-     * \n+     * @deprecated\n+     *\n+     * <b>Deprecated</b>\n+     * validation with timeout combined with atMost simply does not make sense...\n+     * The test would have passed immediately in the concurrent environment\n+     * <p>\n+     * To avoid compilation erros upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n+     * <p>\n+     * In future release we will remove timeout(x).atMost(y) from the API.\n+     * <p>\n+     * Do you want to find out more? See <a href=\"http://code.google.com/p/mockito/issues/detail?id=235\">issue 235</a>\n+     *\n      * @return verification mode\n      */\n+    @Deprecated\n     public VerificationMode atMost(int maxNumberOfInvocations);\n \n     /**\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n import org.mockito.internal.stubbing.answers.Returns;\n \n import java.util.LinkedList;\n-import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n \n /**\n  * Author: Szczepan Faber\n             throw exceptions.getFirst();\n         }\n     }\n+\n+    @Test\n+    public void shouldReturnInvokedMock() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+\n+        assertEquals(invocation.getMock(), container.invokedMock());\n+    }\n }\n--- a/test/org/mockito/verification/TimeoutTest.java\n+++ b/test/org/mockito/verification/TimeoutTest.java\n         assertCorrectMode(t.times(5), Timeout.class, 50, 25, Times.class);\n         assertCorrectMode(t.never(), Timeout.class, 50, 25, Times.class);\n         assertCorrectMode(t.only(), Timeout.class, 50, 25, Only.class);\n-        assertCorrectMode(t.atMost(10), Timeout.class, 50, 25, AtMost.class);\n     }\n     \n     private void assertCorrectMode(VerificationMode t, Class expectedType, int expectedTimeout, int expectedTreshold, Class expectedDelegateType) {\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/DeprecatedMockAnnotationTest.java\n+package org.mockitousage.annotation;\n+\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.awt.*;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+public class DeprecatedMockAnnotationTest {\n+\n+    @MockitoAnnotations.Mock private List deprecatedMock;\n+\n+    @InjectMocks private AnInjectedObject anInjectedObject;\n+\n+    @Before\n+    public void initMocks() throws Exception {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void shouldCreateMockForDeprecatedMockAnnotation() throws Exception {\n+        assertNotNull(deprecatedMock);\n+    }\n+\n+    @Test\n+    public void shouldInjectDeprecatedMockAnnotation() throws Exception {\n+        assertNotNull(anInjectedObject.aFieldAwaitingInjection);\n+    }\n+\n+    private static class AnInjectedObject {\n+        List aFieldAwaitingInjection;\n+    }\n+}\n--- a/test/org/mockitousage/annotation/InjectMocksTest.java\n+++ b/test/org/mockitousage/annotation/InjectMocksTest.java\n package org.mockitousage.annotation;\n-\n-import static org.mockito.Mockito.when;\n \n import org.junit.Test;\n import org.mockito.InjectMocks;\n import org.mockitousage.examples.use.ArticleCalculator;\n import org.mockitousage.examples.use.ArticleManager;\n import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.when;\n \n public class InjectMocksTest extends TestBase {\n \n \n \t@Test(expected = IllegalArgumentException.class)\n \tpublic void testInnerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {\n-\t\twhen(calculator.countArticles(\"new\")).thenThrow(\n-\t\t\t\tnew IllegalArgumentException());\n+\t\twhen(calculator.countArticles(\"new\")).thenThrow(new IllegalArgumentException());\n+\n \t\tarticleManager.updateArticleCounters(\"new\");\n \t}\n \n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MockAccessTest.java\n+package org.mockitousage.basicapi;\n+\n+\n+import org.junit.Test;\n+\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class MockAccessTest {\n+\n+    @Test\n+    public void shouldAllowStubbedMockReferenceAccess() throws Exception {\n+        Set expectedMock = mock(Set.class);\n+\n+        Set returnedMock = when(expectedMock.isEmpty()).thenReturn(false).getMock();\n+\n+        assertEquals(expectedMock, returnedMock);\n+    }\n+\n+    @Test\n+    public void stubbedMockShouldWorkAsUsual() throws Exception {\n+        Set returnedMock = when(mock(Set.class).isEmpty()).thenReturn(false, true).getMock();\n+\n+        assertEquals(false, returnedMock.isEmpty());\n+        assertEquals(true, returnedMock.isEmpty());\n+    }\n+}\n--- a/test/org/mockitousage/basicapi/MocksCreationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksCreationTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.basicapi;\n-\n-import static org.hamcrest.CoreMatchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.mockito.Mockito.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MocksCreationTest extends TestBase {\n         List list = new LinkedList();\n         mock(LinkedList.class, withSettings().spiedInstance(list));\n     }\n+\n+    @Test\n+    public void shouldAllowInlineMockCreation() throws Exception {\n+        when(mock(Set.class).isEmpty()).thenReturn(false);\n+    }\n+\n }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/BridgeMethodsHitAgainTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+//see issue 101\n+public class BridgeMethodsHitAgainTest extends TestBase {\n+   \n+  public interface Factory {}\n+  public interface ExtendedFactory extends Factory {}\n+\n+  public interface SomeInterface {\n+    Factory factory();\n+  }\n+\n+  public interface SomeSubInterface extends SomeInterface {\n+    ExtendedFactory factory();\n+  }\n+\n+  @Mock SomeSubInterface someSubInterface;\n+  @Mock ExtendedFactory extendedFactory;\n+\n+  @Test\n+  public void basicCheck() {\n+    Mockito.when((someSubInterface).factory()).thenReturn(extendedFactory);\n+    SomeInterface si = someSubInterface;\n+    assertTrue(si.factory() != null);\n+  }\n+\n+  @Test\n+  public void checkWithExtraCast() {\n+    Mockito.when(((SomeInterface) someSubInterface).factory()).thenReturn(extendedFactory);\n+    SomeInterface si = someSubInterface;\n+    assertTrue(si.factory() != null);\n+  }\n+}\n--- a/test/org/mockitousage/bugs/CovariantOverrideTest.java\n+++ b/test/org/mockitousage/bugs/CovariantOverrideTest.java\n  */\n package org.mockitousage.bugs;\n \n-import static org.mockito.Mockito.*;\n-\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockitoutil.TestBase;\n \n+import static org.mockito.Mockito.*;\n+\n+//see issue 101\n public class CovariantOverrideTest extends TestBase {\n    \n     public static interface ReturnsObject {\n         when(mock.callMe()).thenReturn(\"foo\");\n         assertEquals(\"foo\", mock.callMe()); // Passes\n     }\n-    \n-    @Ignore //we don't know how to implement it - covariant override\n+\n     @Test \n     public void returnFoo4() {\n         ReturnsString mock = mock(ReturnsString.class);\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.lang.reflect.Field;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest {\n+\n+    private static final Object REFERENCE = new Object();\n+\n+    @Mock private Bean mockedBean;\n+\n+    @InjectMocks private Service illegalInjectionExample = new Service();\n+    @InjectMocks private ServiceWithReversedOrder reversedOrderService = new ServiceWithReversedOrder();\n+    @InjectMocks private WithNullObjectField withNullObjectField = new WithNullObjectField();\n+\n+    @Test\n+    public void just_for_information_fields_are_read_in_declaration_order_see_Service() {\n+        Field[] declaredFields = Service.class.getDeclaredFields();\n+\n+        assertEquals(\"mockShouldNotGoInHere\", declaredFields[0].getName());\n+        assertEquals(\"mockShouldGoInHere\", declaredFields[1].getName());\n+    }\n+\n+    @Test\n+    public void mock_should_be_injected_once_and_in_the_best_matching_type() {\n+        assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);\n+        assertSame(mockedBean, illegalInjectionExample.mockShouldGoInHere);\n+    }\n+\n+    @Test\n+    public void should_match_be_consistent_regardless_of_order() {\n+        assertSame(REFERENCE, reversedOrderService.mockShouldNotGoInHere);\n+        assertSame(mockedBean, reversedOrderService.mockShouldGoInHere);\n+    }\n+\n+    @Test\n+    public void should_not_inject_the_object() {\n+        assertNull(withNullObjectField.keepMeNull);\n+        assertSame(mockedBean, withNullObjectField.injectMePlease);\n+    }\n+\n+    public static class Bean {}\n+\n+    public static class Service {\n+        public final Object mockShouldNotGoInHere = REFERENCE;\n+        public Bean mockShouldGoInHere;\n+    }\n+\n+    public static class ServiceWithReversedOrder {\n+        public Bean mockShouldGoInHere;\n+        public final Object mockShouldNotGoInHere = REFERENCE;\n+    }\n+\n+    class WithNullObjectField{\n+        Bean injectMePlease;\n+        Object keepMeNull = null;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ParentTestMockInjectionTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+// issue 229 : @Mock fields in super test class are not injected on @InjectMocks fields\n+public class ParentTestMockInjectionTest {\n+\n+    @Test\n+    public void injectMocksShouldInjectMocksFromTestSuperClasses() {\n+        ImplicitTest it = new ImplicitTest();\n+        MockitoAnnotations.initMocks(it);\n+\n+        assertNotNull(it.daoFromParent);\n+        assertNotNull(it.daoFromSub);\n+        assertNotNull(it.sut.daoFromParent);\n+        assertNotNull(it.sut.daoFromSub);\n+    }\n+\n+    @Ignore\n+    public static abstract class BaseTest {\n+        @Mock protected DaoA daoFromParent;\n+    }\n+\n+    @Ignore(\"JUnit : don't this test!\")\n+    public static class ImplicitTest extends BaseTest {\n+        @InjectMocks private TestedSystem sut = new TestedSystem();\n+\n+        @Mock private DaoB daoFromSub;\n+\n+        @Before\n+        public void setup() {\n+            MockitoAnnotations.initMocks(this);\n+        }\n+\n+        @Test\n+        public void noNullPointerException() {\n+            sut.businessMethod();\n+        }\n+    }\n+\n+    public static class TestedSystem {\n+        private DaoA daoFromParent;\n+        private DaoB daoFromSub;\n+\n+        public void businessMethod() {\n+            daoFromParent.doQuery();\n+            daoFromSub.doQuery();\n+        }\n+    }\n+\n+\n+    public static class DaoA {\n+        public void doQuery() { }\n+    }\n+\n+    public static class DaoB {\n+        public void doQuery() { }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/TimeoutWithAtMostShouldBeDisabledTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.FriendlyReminderException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.*;\n+\n+//see issue 235\n+public class TimeoutWithAtMostShouldBeDisabledTest extends TestBase {\n+\n+    @Mock IMethods mock;\n+\n+\t@Test\n+\tpublic void shouldDisableTimeout() {\n+        try {\n+\t\t    verify(mock, timeout(30000).atMost(1)).simpleMethod();\n+            fail();\n+        } catch (FriendlyReminderException e) {}\n+\t}\n+}\n--- a/test/org/mockitousage/customization/BDDMockitoTest.java\n+++ b/test/org/mockitousage/customization/BDDMockitoTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.customization;\n-\n-import static org.mockito.BDDMockito.*;\n \n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.Set;\n+\n+import static org.mockito.BDDMockito.*;\n \n public class BDDMockitoTest extends TestBase {\n     \n             fail();\n         } catch(RuntimeException e) {}\n     }\n+\n+    @Test\n+    public void shouldStubWithThrowableClass() throws Exception {\n+        given(mock.simpleMethod(\"foo\")).willThrow(RuntimeException.class);\n+\n+        try {\n+            assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n+            fail();\n+        } catch(RuntimeException e) {}\n+    }\n     \n     @Test\n     public void shouldStubWithAnswer() throws Exception {\n                 return (String) invocation.getArguments()[0];\n             }});\n         \n+        assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n+    }\n+\n+    @Test\n+    public void shouldStubWithWillAnswerAlias() throws Exception {\n+        given(mock.simpleMethod(anyString())).will(new Answer<String>() {\n+            public String answer(InvocationOnMock invocation) throws Throwable {\n+                return (String) invocation.getArguments()[0];\n+            }});\n+\n         assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n     }\n \n             fail();\n         } catch(RuntimeException e) {}\n     }\n-    \n+\n+    @Test\n+    public void shouldStubVoidWithExceptionClass() throws Exception {\n+        willThrow(RuntimeException.class).given(mock).voidMethod();\n+\n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch(RuntimeException e) {}\n+    }\n+\n     @Test\n     public void shouldStubVoidConsecutively() throws Exception {\n         willDoNothing()\n             mock.voidMethod();\n             fail();\n         } catch(RuntimeException e) {}\n+    }\n+\n+    @Test\n+    public void shouldStubVoidConsecutivelyWithExceptionClass() throws Exception {\n+        willDoNothing()\n+        .willThrow(IllegalArgumentException.class)\n+        .given(mock).voidMethod();\n+\n+        mock.voidMethod();\n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch(IllegalArgumentException e) {}\n     }\n     \n     @Test\n         //then\n         assertEquals(\"woof\", dog.bark());\n     }\n-}\n+\n+    @Test\n+    public void shouldAllStubbedMockReferenceAccess() throws Exception {\n+        Set expectedMock = mock(Set.class);\n+\n+        Set returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();\n+\n+        assertEquals(expectedMock, returnedMock);\n+    }\n+}\n--- a/test/org/mockitousage/matchers/MoreMatchersTest.java\n+++ b/test/org/mockitousage/matchers/MoreMatchersTest.java\n  */\n package org.mockitousage.matchers;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n \n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedList;\n \n-import org.junit.Test;\n-import org.mockito.Mock;\n-import org.mockitousage.IMethods;\n-import org.mockitoutil.TestBase;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n public class MoreMatchersTest extends TestBase {\n \n     @Mock private IMethods mock;\n-    \n+\n     @Test\n     public void shouldHelpOutWithUnnecessaryCasting() {\n         when(mock.objectArgMethod(any(String.class))).thenReturn(\"string\");\n-        \n+\n         assertEquals(\"string\", mock.objectArgMethod(\"foo\"));\n     }\n \n         verify(mock).simpleMethod(anyObject());\n         verify(mock).simpleMethod(any(Object.class));\n     }\n-    \n+\n     @Test\n     public void shouldHelpOutWithUnnecessaryCastingOfLists() {\n         //Below yields compiler warning:\n         //when(mock.listArgMethod(anyList())).thenReturn(\"list\");\n         when(mock.listArgMethod(anyListOf(String.class))).thenReturn(\"list\");\n-        \n+\n         assertEquals(\"list\", mock.listArgMethod(new LinkedList<String>()));\n         assertEquals(\"list\", mock.listArgMethod(Collections.<String>emptyList()));\n     }\n-    \n+\n     @Test\n     public void shouldHelpOutWithUnnecessaryCastingOfSets() {\n         //Below yields compiler warning:\n         //when(mock.setArgMethod(anySet())).thenReturn(\"set\");\n         when(mock.setArgMethod(anySetOf(String.class))).thenReturn(\"set\");\n-        \n+\n         assertEquals(\"set\", mock.setArgMethod(new HashSet<String>()));\n         assertEquals(\"set\", mock.setArgMethod(Collections.<String>emptySet()));\n     }\n-    \n+\n     @Test\n     public void shouldHelpOutWithUnnecessaryCastingOfCollections() {\n         //Below yields compiler warning:\n         //when(mock.setArgMethod(anySet())).thenReturn(\"set\");\n         when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn(\"col\");\n-        \n+\n         assertEquals(\"col\", mock.collectionArgMethod(new ArrayList<String>()));\n         assertEquals(\"col\", mock.collectionArgMethod(Collections.<String>emptyList()));\n     }\n-}\n+\n+    @Test\n+    public void shouldHelpOutWithUnnecessaryCastingOfNullityChecks() {\n+        when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn(\"string\");\n+        when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn(\"string\");\n+        when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn(\"string\");\n+\n+        assertEquals(\"string\", mock.objectArgMethod(null));\n+        assertEquals(\"string\", mock.objectArgMethod(\"foo\"));\n+        assertEquals(\"string\", mock.objectArgMethod(\"foo\"));\n+    }\n+\n+}\n--- a/test/org/mockitousage/misuse/InvalidUsageTest.java\n+++ b/test/org/mockitousage/misuse/InvalidUsageTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.misuse;\n-\n-import static org.mockito.Mockito.*;\n \n import org.junit.After;\n import org.junit.Test;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n \n public class InvalidUsageTest extends TestBase {\n \n     @SuppressWarnings(\"all\")\n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowableVararg() throws Exception {\n-        when(mock.simpleMethod()).thenThrow(null);\n+        when(mock.simpleMethod()).thenThrow((Throwable) null);\n     }    \n \n     @Test(expected=MockitoException.class)\n         \n         verifyZeroInteractions(clazz);\n     }\n-}\n+}\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.stubbing;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Matchers.isA;\n+import static org.mockito.Mockito.*;\n \n public class BasicStubbingTest extends TestBase {\n \n         \n         verifyZeroInteractions(mock);\n     }\n-    \n+\n     @Test\n     public void unfinishedStubbingCleansUpTheState() {\n         reset(mock);\n     public void shouldAllowMockingWhenToStringIsFinal() throws Exception {\n         mock(Foo.class);\n     }\n-}\n+}\n--- a/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.stubbing;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.io.IOException;\n \n import org.junit.After;\n import org.junit.Test;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import java.io.IOException;\n+\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.*;\n+\n @SuppressWarnings(\"serial\")\n public class StubbingUsingDoReturnTest extends TestBase {\n \n         assertEquals(\"bar\", mock.simpleMethod());\n         assertEquals(\"bar\", mock.simpleMethod());\n     }\n-    \n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void shouldAllowChainedStubbingWithExceptionClass() throws Exception {\n+        doReturn(\"whatever\").doThrow(IllegalArgumentException.class).when(mock).simpleMethod();\n+\n+        assertEquals(\"whatever\", mock.simpleMethod());\n+        mock.simpleMethod();\n+    }\n+\n     @Test\n     public void shouldAllowChainedStubbingOnVoidMethods() {\n         doNothing().\n         doReturn(1).when(mock).intReturningMethod();\n         doReturn(new Integer(2)).when(mock).intReturningMethod();\n     }\n-}\n+}\n--- a/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.stubbing;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.lang.reflect.Method;\n \n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.stubVoid;\n+import static org.mockito.Mockito.when;\n \n @SuppressWarnings({\"unchecked\", \"deprecation\"})\n public class StubbingWithCustomAnswerTest extends TestBase {\n         });\n \n         assertEquals(\"simpleMethod-test\", mock.simpleMethod(\"test\"));\n+    }\n+\n+    @Test\n+    public void shouldAnswerWithThenAnswerAlias() throws Exception {\n+        RecordCall recordCall = new RecordCall();\n+        Set mockedSet = when(mock(Set.class).isEmpty()).then(recordCall).getMock();\n+\n+        mockedSet.isEmpty();\n+\n+        assertTrue(recordCall.isCalled());\n     }\n \n     @Test\n         mock.voidMethod();\n         assertTrue(call2.isCalled());\n     }\n-    \n+\n     @Test\n     public void shouldMakeSureTheInterfaceDoesNotChange() throws Exception {\n         when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {\n             public String answer(InvocationOnMock invocation) throws Throwable {\n                 assertTrue(invocation.getArguments().getClass().isArray());\n                 assertEquals(Method.class, invocation.getMethod().getClass());\n-                \n+\n                 return \"assertions passed\";\n             }\n         });\n \n         assertEquals(\"assertions passed\", mock.simpleMethod(\"test\"));\n-    }    \n+    }\n \n     private static class RecordCall implements Answer {\n         private boolean called = false;\n--- a/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n  */\n package org.mockitousage.stubbing;\n \n-import static org.mockito.Mockito.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitoutil.TestBase;\n \n import java.io.IOException;\n import java.io.Reader;\n import java.util.LinkedList;\n import java.util.Map;\n \n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n-import org.mockitoutil.TestBase;\n-\n-@SuppressWarnings({\"serial\", \"unchecked\", \"all\"})\n+import static org.mockito.Mockito.*;\n+\n+@SuppressWarnings({\"serial\", \"unchecked\", \"all\", \"deprecation\"})\n public class StubbingWithThrowablesTest extends TestBase {\n \n     private LinkedList mock;\n         } catch (Error e) {\n             assertEquals(error, e);\n         }\n-    }    \n+    }\n+\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void shouldInstantiateExceptionClassOnInteraction() {\n+        when(mock.add(null)).thenThrow(IllegalArgumentException.class);\n+\n+        mock.add(null);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void shouldInstantiateExceptionClassWithOngoingStubbingOnInteraction() {\n+        Mockito.doThrow(IllegalArgumentException.class).when(mock).add(null);\n+\n+        mock.add(null);\n+    }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowable() throws Exception {\n-        when(mock.add(\"monkey island\")).thenThrow(null);\n-    }    \n+        when(mock.add(\"monkey island\")).thenThrow((Throwable) null);\n+    }\n+\n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingNullThrowableArray() throws Exception {\n+        when(mock.add(\"monkey island\")).thenThrow((Throwable[]) null);\n+    }\n     \n     @Test\n     public void shouldMixThrowablesAndReturnsOnDifferentMocks() throws Exception {\n         } catch (NoInteractionsWanted e) {}\n     }\n     \n-    private class ExceptionOne extends RuntimeException {};\n-    private class ExceptionTwo extends RuntimeException {};\n-    private class ExceptionThree extends RuntimeException {};\n-    private class ExceptionFour extends RuntimeException {};\n-}\n+    private class ExceptionOne extends RuntimeException {}\n+    private class ExceptionTwo extends RuntimeException {}\n+    private class ExceptionThree extends RuntimeException {}\n+    private class ExceptionFour extends RuntimeException {}\n+\n+    public class NaughtyException extends RuntimeException {\n+        public NaughtyException() {\n+            throw new RuntimeException(\"boo!\");\n+        }\n+    }\n+\n+    @Test(expected = NaughtyException.class)\n+    public void shouldShowDecentMessageWhenExcepionIsNaughty() throws Exception {\n+        when(mock.add(\"\")).thenThrow(NaughtyException.class);\n+        mock.add(\"\");\n+    }\n+}\n--- a/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n+++ b/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n     @Test\n     public void shouldAllowMixingOtherModesWithTimeout() throws Exception {\n         //given\n-        Thread t1 = waitAndExerciseMock(20);\n-        Thread t2 = waitAndExerciseMock(20);\n+        Thread t1 = waitAndExerciseMock(30);\n+        Thread t2 = waitAndExerciseMock(30);\n         \n         //when\n         t1.start();\n     @Test\n     public void shouldAllowMixingOtherModesWithTimeoutAndFail() throws Exception {\n         //given\n-        Thread t1 = waitAndExerciseMock(20);\n-        Thread t2 = waitAndExerciseMock(20);\n+        Thread t1 = waitAndExerciseMock(30);\n+        Thread t2 = waitAndExerciseMock(30);\n         \n         //when\n         t1.start();", "timestamp": 1300042125, "metainfo": ""}