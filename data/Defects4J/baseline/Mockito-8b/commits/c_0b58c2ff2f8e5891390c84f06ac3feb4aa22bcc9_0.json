{"sha": "0b58c2ff2f8e5891390c84f06ac3feb4aa22bcc9", "log": "More work on exception messages more descriptive", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);   \n     }\n \n-    public void cannotInitializeForSpyAnnotation(String fieldName, String details) {\n+    public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n         throw new MockitoException(join(\"Cannot instianate a @Spy for '\" + fieldName + \"' field.\",\n             \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n-            \"However, I failed because: \" + details,\n+            \"However, I failed because: \" + details.getMessage(),\n             \"Examples of correct usage of @Spy:\",\n             \"   @Spy List mock = new LinkedList();\",\n             \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n             \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n-                \"\"));\n+                \"\"), details);\n     }\n }\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n                 try {\n                     instance = new FieldInitializer(testClass, field).initialize();\n                 } catch (MockitoException e) {\n-                    new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e.getMessage());\n+                    new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                 }\n                 try {\n                     if (new MockUtil().isMock(instance)) {\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n             Object newFieldInstance = constructor.newInstance(noArg);\n             new FieldSetter(testClass, field).set(newFieldInstance);\n         } catch (NoSuchMethodException e) {\n-            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" has no default constructor\", e);\n+            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n         } catch (InvocationTargetException e) {\n-            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the default constructor of type \" + field.getType() + \" has raised an exception : \" + e.getTargetException().toString(), e);\n+            throw new MockitoException(\"the default constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n         } catch (InstantiationException e) {\n-            throw new MockitoException(\"Unexpected InstantiationException for field : \\\"\" + field.getName() + \"\\\"\", e);\n+            throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n         } catch (IllegalAccessException e) {\n-            throw new MockitoException(\"Unexpected IllegalAccessException for field : \\\"\" + field.getName() + \"\\\"\", e);\n+            throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n         } finally {\n             if(constructor != null) {\n                 changer.safelyDisableAccess(constructor);\n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n \n import java.util.AbstractList;\n import java.util.ArrayList;\n-import java.util.LinkedList;\n import java.util.List;\n \n-import static org.fest.assertions.Assertions.assertThat;\n-import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.*;\n \n @SuppressWarnings({\"unchecked\", \"unused\"})\n public class SpyAnnotationTest extends TestBase {\n \n-    @Spy\n-    final List spiedList = new ArrayList();\n+    @Spy final List spiedList = new ArrayList();\n \n-    @Spy\n-    NestedClassWithNoArgConstructor staticTypeWithNoArgConstructor;\n+    @Spy NestedClassWithNoArgConstructor staticTypeWithNoArgConstructor;\n \n     @Spy\n     NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;\n             fail();\n         } catch (Exception e) {\n             Assertions.assertThat(e.getMessage()).contains(\"an interface\");\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReportWhenNoArgConstructor() throws Exception {\n+\t\tclass FailingSpy {\n+\t        @Spy\n+            NoValidConstructor noValidConstructor;\n+\t\t}\n+\n+        try {\n+            MockitoAnnotations.initMocks(new FailingSpy());\n+            fail();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"default constructor\");\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldReportWhenConstructorThrows() throws Exception {\n+\t\tclass FailingSpy {\n+\t        @Spy\n+            ThrowingConstructor throwingConstructor;\n+\t\t}\n+\n+        try {\n+            MockitoAnnotations.initMocks(new FailingSpy());\n+            fail();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"raised an exception\");\n         }\n     }\n \n \n     static class NestedClassWithNoArgConstructor {\n         NestedClassWithNoArgConstructor() { }\n-        NestedClassWithNoArgConstructor(String _1arg) { }\n+        NestedClassWithNoArgConstructor(String f) { }\n+    }\n+\n+    static class NoValidConstructor {\n+        NoValidConstructor(String f) { }\n+    }\n+\n+    static class ThrowingConstructor {\n+        ThrowingConstructor() { throw new RuntimeException(\"boo!\"); }\n     }\n }", "timestamp": 1288380481, "metainfo": ""}