{"sha": "af7f19ccf9fc5232ed5cc289ec4ac50cb606c679", "log": "In order to make Mockito compatible with previous versions I had to change the return type of InvocationOnMock.getMethod() Renamed one test class to be consistent with renamed class  --HG-- rename : test/org/mockito/internal/invocation/SerializableMockitoMethodTest.java => test/org/mockito/internal/invocation/SerializableMethodTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401668", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n  */\n package org.mockito.internal.invocation;\n \n-import java.util.*;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.MatchersPrinter;\n import org.mockito.internal.reporting.PrintSettings;\n import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n-import org.mockito.internal.util.*;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n         return mock;\n     }\n \n-    public SerializableMethod getMethod() {\n-        return method;\n+    public Method getMethod() {\n+        return method.getJavaMethod();\n     }\n \n     public Object[] getArguments() {\n     }\n \n     public Object callRealMethod() throws Throwable {\n-        if (this.getMethod().isDeclaredOnInterface()) {\n+        if (isDeclaredOnInterface()) {\n             new Reporter().cannotCallRealMethodOnInterface();\n         }\n         return realMethod.invoke(mock, rawArguments);\n     }\n+    \n+    public boolean isDeclaredOnInterface() {\n+        return this.getMethod().getDeclaringClass().isInterface();\n+    }      \n \n     public String toString(PrintSettings printSettings) {\n         return toString(argumentsToMatchers(), printSettings);\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n package org.mockito.internal.invocation;\n \n import java.io.Serializable;\n+import java.lang.reflect.Method;\n import java.util.Collections;\n import java.util.List;\n \n         this(invocation, Collections.<Matcher>emptyList());\n     }\n \n-    public SerializableMethod getMethod() {\n+    public Method getMethod() {\n         return invocation.getMethod();\n     }\n     \n--- a/src/org/mockito/internal/invocation/SerializableMethod.java\n+++ b/src/org/mockito/internal/invocation/SerializableMethod.java\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.Arrays;\n+\n+import org.mockito.exceptions.base.MockitoException;\n \n public class SerializableMethod implements Serializable {\n \n \n     public boolean isVarArgs() {\n         return isVarArgs;\n-    }\n-    \n-    public boolean isDeclaredOnInterface() {\n-        return declaringClass.isInterface();\n+    }  \n+\n+    public Method getJavaMethod() {\n+        try {\n+            return declaringClass.getDeclaredMethod(methodName, parameterTypes);\n+        } catch (SecurityException e) {\n+            String message = String.format(\n+                    \"The method %1$s.%2$s is probably private or protected and cannot be mocked.\\n\" +\n+                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n+            throw new MockitoException(message, e);\n+        } catch (NoSuchMethodException e) {\n+            String message = String.format(\n+                    \"The method %1$s.%2$s does not exists and you should not get to this point.\\n\" +\n+                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n+            throw new MockitoException(message, e);\n+        }\n     }    \n \n     @Override\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n     }\n \n     private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {\n-        if (invocation.getMethod().isDeclaredOnInterface()) {\n+        if (invocation.isDeclaredOnInterface()) {\n             reporter.cannotCallRealMethodOnInterface();\n         }\n     }\n--- a/src/org/mockito/invocation/InvocationOnMock.java\n+++ b/src/org/mockito/invocation/InvocationOnMock.java\n package org.mockito.invocation;\n \n import java.io.Serializable;\n-\n-import org.mockito.internal.invocation.SerializableMethod;\n+import java.lang.reflect.Method;\n \n /**\n  * An invocation on a mock\n      * \n      * @return method\n      */\n-    //TODO: this has to return java.reflect.method in order to keep the interface consistent\n-    SerializableMethod getMethod();\n+    Method getMethod();\n \n     /**\n      * returns arguments passed to the method\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/SerializableMethodTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class SerializableMethodTest extends TestBase {\n+\n+    private SerializableMethod method;\n+    private Method toStringMethod;\n+    private Class<?>[] args;\n+\n+    @Before\n+    public void createMethodToTestWith() throws SecurityException, NoSuchMethodException {\n+        args = new Class<?>[0];\n+        toStringMethod = this.getClass().getMethod(\"toString\", args);\n+        method = new SerializableMethod(toStringMethod);\n+    }\n+    \n+    @Test\n+    public void shouldBeSerializable() throws Exception {\n+        ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n+        new ObjectOutputStream(serialized).writeObject(method);\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToRetrieveMethodExceptionTypes() throws Exception {\n+        assertArrayEquals(toStringMethod.getExceptionTypes(), method.getExceptionTypes());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToRetrieveMethodName() throws Exception {\n+        assertEquals(toStringMethod.getName(), method.getName());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToCheckIsArgVargs() throws Exception {\n+        assertEquals(toStringMethod.isVarArgs(), method.isVarArgs());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToGetParameterTypes() throws Exception {\n+        assertArrayEquals(toStringMethod.getParameterTypes(), method.getParameterTypes());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToGetReturnType() throws Exception {\n+        assertEquals(toStringMethod.getReturnType(), method.getReturnType());\n+    }\n+    \n+    @Test\n+    public void shouldBeEqualForTwoInstances() throws Exception {\n+        assertTrue(new SerializableMethod(toStringMethod).equals(method));\n+    }\n+    \n+    @Test\n+    public void shouldNotBeEqualForSameMethodFromTwoDifferentClasses() throws Exception {\n+        Method testBaseToStringMethod = String.class.getMethod(\"toString\", args);\n+        assertFalse(new SerializableMethod(testBaseToStringMethod).equals(method));\n+    }\n+    \n+    //TODO: add tests for generated equals() method\n+    \n+}\n--- a/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n \n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n+\n+import java.lang.reflect.Method;\n \n import org.junit.Test;\n import org.mockito.Mock;\n \n         mock.voidMethod();\n         assertTrue(call2.isCalled());\n+    }\n+    \n+    @Test\n+    public void shouldMakeSureTheInterfaceDoesNotChange() throws Exception {\n+        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {\n+            public String answer(InvocationOnMock invocation) throws Throwable {\n+                assertTrue(invocation.getArguments().getClass().isArray());\n+                assertEquals(Method.class, invocation.getMethod().getClass());\n+                \n+                return \"assertions passed\";\n+            }\n+        });\n \n-    }\n+        assertEquals(\"assertions passed\", mock.simpleMethod(\"test\"));\n+    }    \n \n     private static class RecordCall implements Answer {\n         private boolean called = false;", "timestamp": 1257713406, "metainfo": ""}