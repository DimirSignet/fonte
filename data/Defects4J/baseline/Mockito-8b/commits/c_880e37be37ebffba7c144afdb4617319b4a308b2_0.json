{"sha": "880e37be37ebffba7c144afdb4617319b4a308b2", "log": "refactored code around MockHandler - moved all the inner classes outside enabled spy/partial mock tests as the functionality is working now  --HG-- rename : src/org/mockito/internal/stubbing/AnswersValidator.java => src/org/mockito/internal/stubbing/answers/AnswersValidator.java rename : src/org/mockito/internal/stubbing/CallsRealMethod.java => src/org/mockito/internal/stubbing/answers/CallsRealMethod.java rename : src/org/mockito/internal/stubbing/DoesNothing.java => src/org/mockito/internal/stubbing/answers/DoesNothing.java rename : src/org/mockito/internal/stubbing/Returns.java => src/org/mockito/internal/stubbing/answers/Returns.java rename : src/org/mockito/internal/stubbing/ThrowsException.java => src/org/mockito/internal/stubbing/answers/ThrowsException.java rename : test/org/mockito/internal/stubbing/AnswersValidatorTest.java => test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401408", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.returnvalues.MoreEmptyReturnValues;\n import org.mockito.internal.returnvalues.RealReturnValues;\n import org.mockito.internal.returnvalues.SmartNullReturnValues;\n-import org.mockito.internal.stubbing.CallsRealMethod;\n-import org.mockito.internal.stubbing.DoesNothing;\n-import org.mockito.internal.stubbing.Returns;\n import org.mockito.internal.stubbing.Stubber;\n-import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.stubbing.answers.CallsRealMethod;\n+import org.mockito.internal.stubbing.answers.DoesNothing;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.api.VerificationMode;\n import org.mockito.runners.MockitoJUnitRunner;\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.SequenceNumber;\n-import org.mockito.internal.stubbing.CallsRealMethod;\n-import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.MockitoStubber;\n-import org.mockito.internal.stubbing.Returns;\n-import org.mockito.internal.stubbing.ThrowsException;\n+import org.mockito.internal.stubbing.OngoingStubbingImpl;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n import org.mockito.internal.util.MockName;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.RegisteredInvocations;\n             return null;\n         }\n \n+        registeredInvocations.add(invocationMatcher.getInvocation());\n         mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n-        registeredInvocations.add(invocationMatcher.getInvocation());\n-\n-        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n \n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n         if (!invocation.isVoid() && answer == null) {\n         } else if (MockUtil.isMock(instance)) {\n             return returnValues.valueFor(invocation);\n         } else {\n-            return methodProxy.invokeSuper(proxy, args);\n+            Object ret = methodProxy.invokeSuper(proxy, args);\n+            //redo setting invocation for potential stubbing in case of partial mocks / spies.\n+            //Without it, the real method inside 'when' might have delegated \n+            //to other self method and overwrite the intended stubbed method with a different one.\n+            mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n         }\n     }\n \n     }\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n-        return new VoidMethodStubbableImpl(mock);\n+        return new VoidMethodStubbableImpl<T>(mock, mockitoStubber);\n     }\n \n     public void setInstance(T instance) {\n         return mockName;\n     }\n \n-    private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n-        private final T mock;\n-\n-        public VoidMethodStubbableImpl(T mock) {\n-            this.mock = mock;\n-        }\n-\n-        public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n-            mockitoStubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n-            return this;\n-        }\n-\n-        public VoidMethodStubbable<T> toReturn() {\n-            mockitoStubber.addAnswerForVoidMethod(new DoesNothing());\n-            return this;\n-        }\n-\n-        public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n-            mockitoStubber.addAnswerForVoidMethod(answer);\n-            return this;\n-        }\n-\n-        public T on() {\n-            return mock;\n-        }\n-    }\n-\n-    private abstract class BaseStubbing implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n-        public NewOngoingStubbing<T> thenReturn(T value) {\n-            return thenAnswer(new Returns(value));\n-        }\n-\n-        public NewOngoingStubbing<T> thenReturn(T value, T... values) {\n-            NewOngoingStubbing<T> stubbing = thenReturn(value);            \n-            if (values == null) {\n-                return stubbing.thenReturn(null);\n-            }\n-            for (T v: values) {\n-                stubbing = stubbing.thenReturn(v);\n-            }\n-            return stubbing;\n-        }\n-\n-        private NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n-            return thenAnswer(new ThrowsException(throwable));\n-        }\n-\n-        public NewOngoingStubbing<T> thenThrow(Throwable... throwables) {\n-            if (throwables == null) {\n-                thenThrow((Throwable) null);\n-            }\n-            NewOngoingStubbing<T> stubbing = null;\n-            for (Throwable t: throwables) {\n-                if (stubbing == null) {\n-                    stubbing = thenThrow(t);                    \n-                } else {\n-                    stubbing = stubbing.thenThrow(t);\n-                }\n-            }\n-            return stubbing;\n-        }        \n-\n-        public NewOngoingStubbing<T> thenCallRealMethod() {\n-            return thenAnswer(new CallsRealMethod());\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toReturn(T value) {\n-            return toAnswer(new Returns(value));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n-            return toAnswer(new ThrowsException(throwable));\n-        }\n-    }\n-    \n-    private class OngoingStubbingImpl extends BaseStubbing {\n-        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n-            registeredInvocations.removeLast();\n-            mockitoStubber.addAnswer(answer);\n-            return new ConsecutiveStubbing();\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            registeredInvocations.removeLast();\n-            mockitoStubber.addAnswer(answer);\n-            return new ConsecutiveStubbing();\n-        }\n-    }\n-\n-    private class ConsecutiveStubbing extends BaseStubbing {\n-        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n-            mockitoStubber.addConsecutiveAnswer(answer);\n-            return this;\n-        }\n-        \n-        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            mockitoStubber.addConsecutiveAnswer(answer);\n-            return this;\n-        }\n-    }    \n-    \n     @SuppressWarnings(\"unchecked\")\n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n     public ReturnValues getReturnValues() {\n         return returnValues;\n     }\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/BaseStubbing.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.internal.stubbing.answers.CallsRealMethod;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+\n+public abstract class BaseStubbing<T> implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n+    public NewOngoingStubbing<T> thenReturn(T value) {\n+        return thenAnswer(new Returns(value));\n+    }\n+\n+    public NewOngoingStubbing<T> thenReturn(T value, T... values) {\n+        NewOngoingStubbing<T> stubbing = thenReturn(value);            \n+        if (values == null) {\n+            return stubbing.thenReturn(null);\n+        }\n+        for (T v: values) {\n+            stubbing = stubbing.thenReturn(v);\n+        }\n+        return stubbing;\n+    }\n+\n+    private NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n+        return thenAnswer(new ThrowsException(throwable));\n+    }\n+\n+    public NewOngoingStubbing<T> thenThrow(Throwable... throwables) {\n+        if (throwables == null) {\n+            thenThrow((Throwable) null);\n+        }\n+        NewOngoingStubbing<T> stubbing = null;\n+        for (Throwable t: throwables) {\n+            if (stubbing == null) {\n+                stubbing = thenThrow(t);                    \n+            } else {\n+                stubbing = stubbing.thenThrow(t);\n+            }\n+        }\n+        return stubbing;\n+    }        \n+\n+    public NewOngoingStubbing<T> thenCallRealMethod() {\n+        return thenAnswer(new CallsRealMethod());\n+    }\n+\n+    public DeprecatedOngoingStubbing<T> toReturn(T value) {\n+        return toAnswer(new Returns(value));\n+    }\n+\n+    public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+        return toAnswer(new ThrowsException(throwable));\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.stubbing.Answer;\n+\n+public class ConsecutiveStubbing<T> extends BaseStubbing<T> {\n+    private final MockitoStubber mockitoStubber;\n+\n+    public ConsecutiveStubbing(MockitoStubber mockitoStubber) {\n+        this.mockitoStubber = mockitoStubber;\n+    }\n+\n+    public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+        mockitoStubber.addConsecutiveAnswer(answer);\n+        return this;\n+    }\n+    \n+    public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+        mockitoStubber.addConsecutiveAnswer(answer);\n+        return this;\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.stubbing.answers.AnswersValidator;\n import org.mockito.stubbing.Answer;\n \n @SuppressWarnings(\"unchecked\")\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.internal.verification.RegisteredInvocations;\n+import org.mockito.stubbing.Answer;\n+\n+public class OngoingStubbingImpl<T> extends BaseStubbing<T> {\n+    \n+    private final MockitoStubber mockitoStubber;\n+    private final RegisteredInvocations registeredInvocations;\n+\n+    public OngoingStubbingImpl(MockitoStubber mockitoStubber,\n+            RegisteredInvocations registeredInvocations) {\n+        this.mockitoStubber = mockitoStubber;\n+        this.registeredInvocations = registeredInvocations;\n+    }\n+\n+    public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+        registeredInvocations.removeLast();\n+        mockitoStubber.addAnswer(answer);\n+        return new ConsecutiveStubbing<T>(mockitoStubber);\n+    }\n+\n+    public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+        registeredInvocations.removeLast();\n+        mockitoStubber.addAnswer(answer);\n+        return new ConsecutiveStubbing<T>(mockitoStubber);\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/StubberImpl.java\n+++ b/src/org/mockito/internal/stubbing/StubberImpl.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.stubbing.answers.DoesNothing;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.stubbing.Answer;\n \n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.stubbing.answers.DoesNothing;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.stubbing.Answer;\n+\n+public class VoidMethodStubbableImpl<T> implements VoidMethodStubbable<T> {\n+    private final T mock;\n+    private MockitoStubber mockitoStubber;\n+\n+    public VoidMethodStubbableImpl(T mock, MockitoStubber mockitoStubber) {\n+        this.mock = mock;\n+        this.mockitoStubber = mockitoStubber;\n+    }\n+\n+    public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n+        mockitoStubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n+        return this;\n+    }\n+\n+    public VoidMethodStubbable<T> toReturn() {\n+        mockitoStubber.addAnswerForVoidMethod(new DoesNothing());\n+        return this;\n+    }\n+\n+    public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n+        mockitoStubber.addAnswerForVoidMethod(answer);\n+        return this;\n+    }\n+\n+    public T on() {\n+        return mock;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.stubbing.Answer;\n+\n+public class AnswersValidator {\n+\n+    private Reporter reporter = new Reporter();\n+    \n+    public void validate(Answer<?> answer, Invocation invocation) {\n+        if (answer instanceof ThrowsException) {\n+            validateException((ThrowsException) answer, invocation);\n+        }\n+        \n+        if (answer instanceof Returns) {\n+            validateReturnValue((Returns) answer, invocation);\n+        }\n+        \n+        if (answer instanceof DoesNothing) {\n+            validateDoNothing((DoesNothing) answer, invocation);\n+        }\n+    }\n+\n+    private void validateDoNothing(DoesNothing answer, Invocation invocation) {\n+        if (!invocation.isVoid()) {\n+            reporter.onlyVoidMethodsCanBeSetToDoNothing();\n+        }\n+    }\n+\n+    private void validateReturnValue(Returns answer, Invocation invocation) {\n+        if (invocation.isVoid()) {\n+            reporter.cannotStubVoidMethodWithAReturnValue();\n+        }\n+        \n+        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n+            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n+        } \n+\n+        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n+            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n+        }\n+    }\n+\n+    private void validateException(ThrowsException answer, Invocation invocation) {\n+        Throwable throwable = answer.getThrowable();\n+        if (throwable == null) {\n+            reporter.cannotStubWithNullThrowable();\n+        }\n+        \n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+        \n+        if (!invocation.isValidException(throwable)) {\n+            reporter.checkedExceptionInvalid(throwable);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethod.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+/**\n+ * Description: TODO: Enter a paragraph that summarizes what the class does and\n+ * why someone might want to utilize it\n+ * \n+ * <p>\n+ * Copyright  2000-2007, NetSuite, Inc.\n+ * </p>\n+ * \n+ * @author amurkes\n+ * @version 2007.0\n+ * @since Apr 10, 2009\n+ */\n+public class CallsRealMethod implements Answer<Object> {\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        return invocation.invokeSuper();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/DoesNothing.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+public class DoesNothing implements Answer<Object> {\n+    \n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/Returns.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+public class Returns implements Answer<Object> {\n+\n+    private final Object value;\n+\n+    public Returns(Object value) {\n+        this.value = value;\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        return value;\n+    }\n+\n+    public String printReturnType() {\n+        return value.getClass().getSimpleName();\n+    }\n+\n+    public Class<?> getReturnType() {\n+        return value.getClass();\n+    }\n+\n+    public boolean returnsNull() {\n+        return value == null;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Returns: \" + value;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import org.mockito.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+public class ThrowsException implements Answer<Object> {\n+\n+    private final Throwable throwable;\n+    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n+\n+    public ThrowsException(Throwable throwable) {\n+        this.throwable = throwable;\n+    }\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        if (MockUtil.isMock(throwable)) {\n+            throw throwable;\n+        }\n+        Throwable t = throwable.fillInStackTrace();\n+        filter.filter(t);\n+        throw t;\n+    }\n+\n+    public Throwable getThrowable() {\n+        return throwable;\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockitoutil.TestBase;\n \n public class MockitoStubberTest extends TestBase{\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.answers;\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.stubbing.answers.AnswersValidator;\n+import org.mockito.internal.stubbing.answers.DoesNothing;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockitoutil.TestBase;\n+\n+public class AnswersValidatorTest extends TestBase {\n+\n+    private AnswersValidator validator = new AnswersValidator();\n+    private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+\n+    @Test\n+    public void shouldValidateNullThrowable() throws Throwable {\n+        try {\n+            validator.validate(new ThrowsException(null), null);\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @Test\n+    public void shouldPassProperCheckedException() throws Throwable {\n+        validator.validate(new ThrowsException(new CharacterCodingException()), invocation);\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailInvalidCheckedException() throws Throwable {\n+        validator.validate(new ThrowsException(new IOException()), invocation);\n+    }\n+    \n+    @Test\n+    public void shouldPassRuntimeExceptions() throws Throwable {\n+        validator.validate(new ThrowsException(new Error()), invocation);\n+        validator.validate(new ThrowsException(new RuntimeException()), invocation);\n+    }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailWhenReturnValueSetForVoidMethod() throws Throwable {\n+        validator.validate(new Returns(\"one\"), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n+    }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailWhenNonVoidMethodDoesNothing() throws Throwable {\n+        validator.validate(new DoesNothing(), new InvocationBuilder().simpleMethod().toInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldAllowVoidReturnForVoidMethod() throws Throwable {\n+        validator.validate(new DoesNothing(), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldAllowCorrectTypeOfReturnValue() throws Throwable {\n+        validator.validate(new Returns(\"one\"), new InvocationBuilder().simpleMethod().toInvocation());\n+        validator.validate(new Returns(false), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n+        validator.validate(new Returns(new Boolean(true)), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n+        validator.validate(new Returns(1), new InvocationBuilder().method(\"integerReturningMethod\").toInvocation());\n+        validator.validate(new Returns(1L), new InvocationBuilder().method(\"longReturningMethod\").toInvocation());\n+        validator.validate(new Returns(1L), new InvocationBuilder().method(\"longObjectReturningMethod\").toInvocation());\n+        validator.validate(new Returns(null), new InvocationBuilder().method(\"objectReturningMethodNoArgs\").toInvocation());\n+        validator.validate(new Returns(1), new InvocationBuilder().method(\"objectReturningMethodNoArgs\").toInvocation());\n+    }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailOnReturnTypeMismatch() throws Throwable {\n+        validator.validate(new Returns(\"String\"), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n+    }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailOnWrongPrimitive() throws Throwable {\n+        validator.validate(new Returns(1), new InvocationBuilder().method(\"doubleReturningMethod\").toInvocation());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailOnNullWithPrimitive() throws Throwable {\n+        validator.validate(new Returns(null), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n+    }\n+}\n--- a/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n+++ b/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockitoutil.TestBase;\n \n-@Ignore\n @SuppressWarnings(\"unchecked\")\n public class PartialMockingWithSpiesTest extends TestBase {\n \n--- a/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n+++ b/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n import org.mockitoutil.TestBase;\n \n-@Ignore\n @SuppressWarnings(\"unchecked\")\n public class SpyingOnRealObjectsTest extends TestBase {\n ", "timestamp": 1241462130, "metainfo": ""}