{"sha": "554224f9cc39c4cbbcdaa0ff7e183a1cc416ce8e", "log": "refactored some stuff and added tests to Stubber  --HG-- rename : src/org/mockito/internal/ToTypeMappings.java => src/org/mockito/internal/EmptyReturnValues.java rename : src/org/mockito/internal/StubbedInvocation.java => src/org/mockito/internal/StubbedInvocationMatcher.java rename : test/org/mockito/internal/ToTypeMappingsTest.java => test/org/mockito/internal/EmptyReturnValuesTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40156", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/EmptyReturnValues.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+public class EmptyReturnValues {\n+    \n+    public static Object emptyValueFor(Class<?> type) {\n+        return emptyReturnValueToType.get(type);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n+    \n+    static {\n+        emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());\n+        \n+        emptyReturnValueToType.put(Set.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(HashSet.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(SortedSet.class, new TreeSet<Object>());        \n+        emptyReturnValueToType.put(TreeSet.class, new TreeSet<Object>());\n+        emptyReturnValueToType.put(LinkedHashSet.class, new LinkedHashSet<Object>());        \n+\n+        emptyReturnValueToType.put(List.class, new LinkedList<Object>());       \n+        emptyReturnValueToType.put(LinkedList.class, new LinkedList<Object>());\n+        emptyReturnValueToType.put(ArrayList.class, new ArrayList<Object>());\n+        \n+        emptyReturnValueToType.put(Map.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(HashMap.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(SortedMap.class, new TreeMap<Object, Object>());        \n+        emptyReturnValueToType.put(TreeMap.class, new TreeMap<Object, Object>());\n+        emptyReturnValueToType.put(LinkedHashMap.class, new LinkedHashMap<Object, Object>());\n+    }\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n         \n         if (verifyingMode != null) {\n             behavior.verify(invocationWithMatchers, verifyingMode);\n-            return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n+            return EmptyReturnValues.emptyValueFor(method.getReturnType());\n         } \n         \n         stubber.setInvocationForPotentialStubbing(invocationWithMatchers);\n--- /dev/null\n+++ b/src/org/mockito/internal/StubbedInvocationMatcher.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+public class StubbedInvocationMatcher extends InvocationMatcher {\n+\n+    private final Result result;\n+\n+    public StubbedInvocationMatcher(InvocationMatcher invocation, Result result) {\n+        super(invocation.invocation, invocation.matchers);\n+        this.result = result;\n+    }\n+\n+    public Result getResult() {\n+        return result;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return super.toString() + \" stubbed with: \" + result.toString();\n+    }\n+}\n--- a/src/org/mockito/internal/Stubber.java\n+++ b/src/org/mockito/internal/Stubber.java\n public class Stubber {\n \n     private InvocationMatcher invocationForStubbing;\n-    private LinkedList<StubbedInvocation> stubbed = new LinkedList<StubbedInvocation>();\n+    private LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private Throwable throwableForVoidMethod;\n+    \n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        this.invocationForStubbing = invocation;\n+    }\n     \n     public void addReturnValue(Object value) {\n         MockitoState.instance().stubbingCompleted();\n         addResult(Result.createThrowResult(throwable));\n     }\n \n-    public void addVoidMethodForThrowable(InvocationMatcher invocationWithMatchers) {\n-        this.invocationForStubbing = invocationWithMatchers;\n-        this.addThrowable(throwableForVoidMethod);\n-        throwableForVoidMethod = null;\n-    }\n-    \n     private void addResult(Result result) {\n         assert invocationForStubbing != null;\n-        stubbed.addFirst(new StubbedInvocation(invocationForStubbing, result));\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, result));\n     }\n-    \n+\n     public Object resultFor(Invocation wanted) throws Throwable {\n-        for (StubbedInvocation s : stubbed) {\n+        for (StubbedInvocationMatcher s : stubbed) {\n             if (s.matches(wanted)) {\n                 return s.getResult().answer();\n             }\n         }\n \n-        return ToTypeMappings.emptyReturnValueFor(wanted.getMethod().getReturnType());\n+        return EmptyReturnValues.emptyValueFor(wanted.getMethod().getReturnType());\n+    }\n+\n+    public void addThrowableForVoidMethod(Throwable throwable) {\n+        throwableForVoidMethod = throwable;\n+    }\n+\n+    public boolean hasThrowableForVoidMethod() {\n+        return throwableForVoidMethod != null;\n+    }\n+    \n+    public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {\n+        invocationForStubbing = voidMethodInvocationMatcher;\n+        addThrowable(throwableForVoidMethod);\n+        throwableForVoidMethod = null;\n     }\n     \n     private void validateThrowable(Throwable throwable) {\n         \n         return false;\n     }\n-\n-    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n-        this.invocationForStubbing = invocation;\n-    }\n-\n-    public void addThrowableForVoidMethod(Throwable throwable) {\n-        throwableForVoidMethod = throwable;\n-    }\n-\n-    public boolean hasThrowableForVoidMethod() {\n-        return throwableForVoidMethod != null;\n-    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/EmptyReturnValuesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.util.RequiresValidState;\n+\n+public class EmptyReturnValuesTest extends RequiresValidState {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n+        assertTrue(((Collection)EmptyReturnValues.emptyValueFor(Collection.class)).isEmpty());\n+        \n+        assertTrue(((Set)EmptyReturnValues.emptyValueFor(Set.class)).isEmpty());\n+        assertTrue(((SortedSet)EmptyReturnValues.emptyValueFor(SortedSet.class)).isEmpty());\n+        assertTrue(((HashSet)EmptyReturnValues.emptyValueFor(HashSet.class)).isEmpty());\n+        assertTrue(((TreeSet)EmptyReturnValues.emptyValueFor(TreeSet.class)).isEmpty());\n+        assertTrue(((LinkedHashSet)EmptyReturnValues.emptyValueFor(LinkedHashSet.class)).isEmpty());        \n+\n+        assertTrue(((List)EmptyReturnValues.emptyValueFor(List.class)).isEmpty());\n+        assertTrue(((ArrayList)EmptyReturnValues.emptyValueFor(ArrayList.class)).isEmpty());\n+        assertTrue(((LinkedList)EmptyReturnValues.emptyValueFor(LinkedList.class)).isEmpty());\n+        \n+        assertTrue(((Map)EmptyReturnValues.emptyValueFor(Map.class)).isEmpty());\n+        assertTrue(((SortedMap)EmptyReturnValues.emptyValueFor(SortedMap.class)).isEmpty());\n+        assertTrue(((HashMap)EmptyReturnValues.emptyValueFor(HashMap.class)).isEmpty());\n+        assertTrue(((TreeMap)EmptyReturnValues.emptyValueFor(TreeMap.class)).isEmpty());\n+        assertTrue(((LinkedHashMap)EmptyReturnValues.emptyValueFor(LinkedHashMap.class)).isEmpty());\n+        \n+        assertNull(EmptyReturnValues.emptyValueFor(String.class));\n+    }\n+}\n--- a/test/org/mockito/internal/InvocationBuilder.java\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n         return this;\n     }\n \n-    public InvocationMatcher toMatchingInvocation() {\n+    public InvocationMatcher toInvocationMatcher() {\n         return new InvocationMatcher(toInvocation());\n     }\n }\n--- a/test/org/mockito/internal/StubberTest.java\n+++ b/test/org/mockito/internal/StubberTest.java\n package org.mockito.internal;\n \n-import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+import org.junit.*;\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.util.RequiresValidState;\n \n-import static org.junit.Assert.*;\n+public class StubberTest extends RequiresValidState{\n \n-public class StubberTest extends RequiresValidState{\n+    private Stubber s;\n+    \n+    @Before\n+    public void setup() {\n+        s = new Stubber();\n+        s.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        MockitoState.instance().stubbingStarted();\n+    }\n \n     @Test\n     public void shouldFinishStubbingBeforeValidatingThrowable() throws Exception {\n-        Stubber s = new Stubber();\n-        s.setInvocationForPotentialStubbing(new InvocationBuilder().toMatchingInvocation());\n-        \n-        MockitoState.instance().stubbingStarted();\n         try {\n             s.addThrowable(new Exception());\n             fail();\n     \n     @Test\n     public void shouldFinishStubbingOnAddingReturnValue() throws Exception {\n-        Stubber s = new Stubber();\n-        s.setInvocationForPotentialStubbing(new InvocationBuilder().toMatchingInvocation());\n-        \n-        MockitoState.instance().stubbingStarted();\n         s.addReturnValue(\"test\");\n         MockitoState.instance().validateState();\n     }\n+    \n+    @Test\n+    public void shouldGetResultsForMethods() throws Throwable {\n+        Invocation simpleMethod = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        s.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        s.addReturnValue(\"simpleMethod\");\n+        \n+        Invocation differentMethod = new InvocationBuilder().method(\"differentMethod\").toInvocation();\n+        s.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        s.addThrowable(new IllegalStateException());\n+        \n+        assertEquals(\"simpleMethod\", s.resultFor(simpleMethod));\n+        \n+        try {\n+            s.resultFor(differentMethod);\n+            fail();\n+        } catch (IllegalStateException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldGetEmptyResultIfMethodsDontMatch() throws Throwable {\n+        Invocation simpleMethod = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        s.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        s.addReturnValue(\"simpleMethod\");\n+        \n+        Invocation differentMethod = new InvocationBuilder().method(\"differentMethod\").toInvocation();\n+        \n+        assertEquals(null, s.resultFor(differentMethod));\n+    }\n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n \n     public String throwsError(int count) throws Error;\n \n-    boolean simpleMethod();\n+    String simpleMethod();\n     \n-    void differentMethod();\n+    String differentMethod();\n \n     String simpleMethod(String argument);\n     \n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n                     MockitoBehaviorTest.class, \n                     MockitoStateTest.class, \n                     RegisteredInvocationsTest.class, \n-                    ToTypeMappingsTest.class, \n+                    EmptyReturnValuesTest.class, \n                     VerifyingModeTest.class, \n                     InvocationTest.class, \n                     MockUtilTest.class, ", "timestamp": 1197326252, "metainfo": ""}