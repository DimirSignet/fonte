{"sha": "2bfc39b9d66e139686e1777063c55e4a4cc8d6cb", "log": "-killed some tests -removed weird logic that maintained empty return values for primitives  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%405", "commit": "\n--- a/src/org/easymock/internal/ToTypeMappings.java\n+++ b/src/org/easymock/internal/ToTypeMappings.java\n public class ToTypeMappings {\n     \n     @SuppressWarnings(\"unchecked\")\n-    protected static Map<Class, Object> emptyReturnValueToPrimitiveType = new HashMap<Class, Object>();\n-\n-    static {\n-        emptyReturnValueToPrimitiveType.put(Void.TYPE, null);\n-        emptyReturnValueToPrimitiveType.put(Boolean.TYPE, Boolean.FALSE);\n-        emptyReturnValueToPrimitiveType.put(Byte.TYPE, new Byte((byte) 0));\n-        emptyReturnValueToPrimitiveType.put(Short.TYPE, new Short((short) 0));\n-        emptyReturnValueToPrimitiveType.put(Character.TYPE, new Character((char) 0));\n-        emptyReturnValueToPrimitiveType.put(Integer.TYPE, new Integer(0));\n-        emptyReturnValueToPrimitiveType.put(Long.TYPE, new Long(0));\n-        emptyReturnValueToPrimitiveType.put(Float.TYPE, new Float(0));\n-        emptyReturnValueToPrimitiveType.put(Double.TYPE, new Double(0));\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n     protected static Map<Class, Class> primitiveToWrapperType = new HashMap<Class, Class>();\n \n     static {\n     }\n     \n     public static Object emptyReturnValueFor(Class type) {\n-        if (type.isPrimitive()) {\n-            return emptyReturnValueToPrimitiveType.get(type);\n-        }\n-        \n         return emptyReturnValueToType.get(type);\n     }\n     \n--- a/test/org/easymock/tests/InvocationTest.java\n+++ b/test/org/easymock/tests/InvocationTest.java\n \n import java.lang.reflect.Method;\n \n-import org.easymock.internal.EqualsMatcher;\n-import org.easymock.internal.Invocation;\n+import org.easymock.internal.*;\n import org.junit.Before;\n import org.junit.Test;\n \n \n     private Invocation nonEqualCall;\n \n+    private Method dummyMethod;\n+\n     @Before\n     public void setup() throws SecurityException, NoSuchMethodException {\n         Object[] arguments1 = new Object[] { \"\" };\n         Object[] arguments2 = new Object[] { \"\" };\n         Object[] arguments3 = new Object[] { \"X\" };\n-        Method m = Object.class.getMethod(\"equals\",\n+        dummyMethod = Object.class.getMethod(\"equals\",\n                 new Class[] { Object.class });\n         Object mock = new Object();\n-        call = new Invocation(mock, m, arguments1);\n-        equalCall = new Invocation(mock, m, arguments2);\n-        nonEqualCall = new Invocation(mock, m, arguments3);\n+        call = new Invocation(mock, dummyMethod, arguments1);\n+        equalCall = new Invocation(mock, dummyMethod, arguments2);\n+        nonEqualCall = new Invocation(mock, dummyMethod, arguments3);\n     }\n \n     @Test\n-    public void testEquals() {\n+    public void shouldKnowIfIsEqualTo() {\n         assertFalse(call.equals(null));\n         assertFalse(call.equals(\"\"));\n         assertTrue(call.equals(equalCall));\n         assertFalse(call.equals(nonEqualCall));\n     }\n+    \n+    @Test\n+    public void shouldNotEqualIfNumberOfArgsDiffer() throws SecurityException, NoSuchMethodException {\n+        Object mock = new Object();\n+\n+        ExpectedInvocation invocationWithOneArg = new ExpectedInvocation(\n+                new Invocation(mock, dummyMethod, new Object[] { \"\" }),\n+                null);\n+        ExpectedInvocation invocationWithTwoArgs = new ExpectedInvocation(\n+                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }),\n+                null);\n+\n+        assertFalse(invocationWithOneArg.equals(null));\n+        assertFalse(invocationWithOneArg.equals(invocationWithTwoArgs));\n+    }\n \n     @Test\n-    public void testHashCode() {\n+    public void shouldNotImplementHashCodeBecauseItsNotUsedWithMaps() {\n         try {\n             call.hashCode();\n             fail();\n     }\n \n     @Test\n-    public void testShouldDisplayMocksToStringIfValidJavaIdentifier()\n+    public void shouldDisplayMocksToStringIfValidJavaIdentifier()\n             throws SecurityException, NoSuchMethodException {\n-        class ToString {\n-            private final String name;\n-\n-            public ToString(String name) {\n-                this.name = name;\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return name;\n-            }\n-\n-            public void aMethod() {\n-            }\n-        }\n-\n         Method method = ToString.class.getMethod(\"aMethod\", new Class[0]);\n         Invocation invocation = new Invocation(new ToString(\"validJavaIdentifier\"),\n                 method, null);\n         assertEquals(invocation.toString(new EqualsMatcher()), \"aMethod()\");\n \n     }\n+    \n+    class ToString {\n+        private final String name;\n+\n+        public ToString(String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        public void aMethod() {\n+        }\n+    }\n }\n--- a/test/org/easymock/tests/ObjectMethodsTest.java\n+++ b/test/org/easymock/tests/ObjectMethodsTest.java\n import org.easymock.MockControl;\n import org.easymock.internal.MockInvocationHandler;\n import org.easymock.internal.ObjectMethodsFilter;\n-import org.junit.Before;\n-import org.junit.Test;\n+import org.junit.*;\n \n public class ObjectMethodsTest {\n     private MockControl<EmptyInterface> control;\n         assertEquals(\"EasyMock for \" + MockedClass.class.toString(), filter\n                 .invoke(new DummyProxy(), toString, new Object[0]));\n     }\n+    \n+    @Ignore\n+    @Test\n+    public void whatHappensWhenClassToMockIsAnonymous() throws Exception {\n+        fail();\n+    }\n \n }", "timestamp": 1195149949, "metainfo": ""}