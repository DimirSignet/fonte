{"sha": "e29a99e8eca77bed275750bf4ab698d542211526", "log": "fixed issue 50  mock.toString() prints mock name if mock has name  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401219", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.stubbing.Returns;\n import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.util.MockName;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.RegisteredInvocations;\n import org.mockito.internal.verification.VerificationDataImpl;\n     private final MockitoStubber mockitoStubber;\n     private final MatchersBinder matchersBinder;\n     private final MockingProgress mockingProgress;\n-    private final String mockName;\n+    private final MockName mockName;\n     private final ReturnValues returnValues;\n \n     private T instance;\n \n-    public MockHandler(String mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder, ReturnValues returnValues) {\n+    public MockHandler(MockName mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder, ReturnValues returnValues) {\n         this.mockName = mockName;\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n         return registeredInvocations.getAll();\n     }\n \n-    public String getMockName() {\n+    public MockName getMockName() {\n         return mockName;\n     }\n \n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n     }\n+\n+    public boolean hasName() {\n+        return false;\n+    }\n }\n--- a/src/org/mockito/internal/returnvalues/EmptyReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/EmptyReturnValues.java\n import org.mockito.ReturnValues;\n import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.MockName;\n+import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n \n     public Object valueFor(InvocationOnMock invocation) {\n         if (Invocation.isToString(invocation)) {\n             Object mock = invocation.getMock();\n-            String mockDescription = \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n-            return mockDescription;\n+            MockName name = MockUtil.getMockName(mock);\n+            if (name.isSurrogate()) {\n+                return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n+            } else {\n+                return name.toString();\n+            }\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockName.java\n+package org.mockito.internal.util;\n+\n+public class MockName {\n+    \n+    private final String mockName;\n+    private boolean surrogate;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MockName(String mockName, Class classToMock) {\n+        if (mockName == null) {\n+            this.mockName = toInstanceName(classToMock);\n+            this.surrogate = true;\n+        } else {\n+            this.mockName = mockName;\n+        }\n+    }\n+\n+    private static String toInstanceName(Class<?> clazz) {\n+        String className = clazz.getSimpleName();\n+        //lower case first letter\n+        return className.substring(0, 1).toLowerCase() + className.substring(1);\n+    }\n+    \n+    public boolean isSurrogate() {\n+        return surrogate;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return mockName;\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n     \n     public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String mockName, T optionalInstance, ReturnValues returnValues) {\n         validateType(classToMock);\n-        if (mockName == null) {\n-            mockName = toInstanceName(classToMock);\n-        }\n-        MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), returnValues);\n+        MockHandler<T> mockHandler = new MockHandler<T>(new MockName(mockName, classToMock), progress, new MatchersBinder(), returnValues);\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n         \n         T mock = (T) ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n         if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n             new Reporter().cannotMockFinalClass(classToMock);\n         }\n-    }\n-\n-    private static String toInstanceName(Class<?> clazz) {\n-        String className = clazz.getSimpleName();\n-        //lower case first letter\n-        return className.substring(0, 1).toLowerCase() + className.substring(1);\n     }\n     \n     public static <T> MockHandler<T> getMockHandler(T mock) {\n         return null;\n     }\n \n-    public static String getMockName(Object mock) {\n+    public static MockName getMockName(Object mock) {\n         return getMockHandler(mock).getMockName();\n     }\n }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         Mockito.inOrder(\"notMock\");\n     }\n     \n-    //TODO after 1.7 add initMocks that allows to send own annotation/own implementation of creation logic\n     //TODO after 1.7 stack trace remover does not work very well when it comes to threads\n     //TODO after 1.7 print warning when trying to mock a final class\n }\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n         verifyZeroInteractions(mock);\n     }\n     \n+    @Test\n+    public void shouldToStringMockName() {\n+        IMethods mock = mock(IMethods.class, \"mockie\");\n+        IMethods mockTwo = mock(IMethods.class);\n+        \n+        assertContains(\"Mock for IMethods\", \"\" + mockTwo);\n+        assertEquals(\"mockie\", \"\" + mock);\n+    }\n+    \n     class Foo {\n         public final String toString() {\n             return \"foo\";\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n         };\n     }\n     \n+    \n     //Assertors will never be matchers...\n //    public static <T> Assertor<T> not(final Assertor<T> assertor) {\n //        return new Assertor<T>() {\n             }\n         };\n     }\n+\n+    public static void assertContains(String sub, String string) {\n+        assertTrue(\"\\n\" +\n+                \"This substing:\" +\n+                sub +\n+                \"\\n\" +\n+                \"should be inside of:\" +\n+                string +\n+                \"\\n\"\n+                , string.contains(sub));\n+    }\n }", "timestamp": 1232306399, "metainfo": ""}