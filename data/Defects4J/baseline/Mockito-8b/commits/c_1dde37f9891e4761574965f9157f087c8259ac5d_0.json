{"sha": "1dde37f9891e4761574965f9157f087c8259ac5d", "log": "Flickering test - renamed DurationChecker to Timer, removed unnecessary interface (initially wanted to be in accord with convention but the interface was unnecessary), added test for timer, changed other tests to use the Timer.", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/Timer.java\n+package org.mockito.internal.verification;\n+\n+public class Timer {\n+\n+    private final long durationMillis;\n+\n+    public Timer(long durationMillis) {\n+        this.durationMillis = durationMillis;\n+    }\n+\n+    public boolean isUp(long startTime) {\n+        return System.currentTimeMillis() - startTime <= durationMillis;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n     private final long durationMillis;\n     private final VerificationMode delegate;\n     private final boolean returnOnSuccess;\n-    private final DurationChecker durationChecker;\n+    private final Timer timer;\n     \n     /**\n      * Create this verification mode, to be used to verify invocation ongoing data later.\n         this.durationMillis = durationMillis;\n         this.delegate = delegate;\n         this.returnOnSuccess = returnOnSuccess;\n-        this.durationChecker = new DurationCheckerImpl(durationMillis);\n+        this.timer = new Timer(durationMillis);\n     }\n \n     /**\n      *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n      *                        the delegate is satisfied and the full duration has passed (as in\n      *                        {@link org.mockito.verification.VerificationAfterDelay}).\n-     * @param durationChecker Checker of whether the duration of the verification is still acceptable\n+     * @param timer Checker of whether the duration of the verification is still acceptable\n      */\n-    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess, DurationChecker durationChecker) {\n+    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {\n         this.pollingPeriodMillis = pollingPeriodMillis;\n         this.durationMillis = durationMillis;\n         this.delegate = delegate;\n         this.returnOnSuccess = returnOnSuccess;\n-        this.durationChecker = durationChecker;\n+        this.timer = timer;\n     }\n \n     /**\n         AssertionError error = null;\n         \n         long startTime = System.currentTimeMillis();\n-        while (durationChecker.isVerificationStillInProgress(startTime)) {\n+        while (timer.isUp(startTime)) {\n             try {\n                 delegate.verify(data);\n                 \n--- a/src/org/mockito/verification/Timeout.java\n+++ b/src/org/mockito/verification/Timeout.java\n package org.mockito.verification;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.verification.DurationChecker;\n-import org.mockito.internal.verification.DurationCheckerImpl;\n+import org.mockito.internal.verification.Timer;\n import org.mockito.internal.verification.VerificationOverTimeImpl;\n /**\n  * See the javadoc for {@link VerificationWithTimeout}\n     /**\n      * See the javadoc for {@link VerificationWithTimeout}\n      */\n-    Timeout(long pollingPeriodMillis, long millis, VerificationMode delegate, DurationChecker durationChecker) {\n-        super(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true, durationChecker));\n+    Timeout(long pollingPeriodMillis, long millis, VerificationMode delegate, Timer timer) {\n+        super(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true, timer));\n     }\n     \n     @Override\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/TimerTest.java\n+package org.mockito.internal.verification;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+\n+public class TimerTest extends TestBase {\n+\n+    @Test\n+    public void should_return_true_if_task_is_in_acceptable_time_bounds() {\n+        long duration = 10000L;\n+        long now = System.currentTimeMillis();\n+        Timer timer = new Timer(duration);\n+\n+        boolean isTimeUp = timer.isUp(now);\n+\n+        assertThat(isTimeUp, is(true));\n+    }\n+\n+    @Test\n+    public void should_return_false_if_task_is_outside_the_acceptable_time_bounds() {\n+        long duration = 0L;\n+        Timer timer = new Timer(duration);\n+        long timeFromPast = generate_time_from_past();\n+\n+        boolean isTimeUp = timer.isUp(timeFromPast);\n+\n+        assertThat(isTimeUp, is(false));\n+    }\n+\n+    long generate_time_from_past() {\n+        return System.currentTimeMillis() - 10000L;\n+    }\n+\n+}\n--- a/test/org/mockito/verification/TimeoutTest.java\n+++ b/test/org/mockito/verification/TimeoutTest.java\n     \n     @Mock VerificationMode mode;\n     @Mock VerificationDataImpl data;\n-    @Mock DurationChecker durationChecker;\n+    @Mock Timer timer;\n     MockitoAssertionError error = new MockitoAssertionError(\"\"); \n \n     @Test\n     public void should_pass_when_verification_passes() {\n-        Timeout t = new Timeout(1, 3, mode);\n-        \n+        Timeout t = new Timeout(1, 3, mode, timer);\n+\n+        when(timer.isUp(anyLong())).thenReturn(true, true, true, false);\n         doNothing().when(mode).verify(data);\n-        \n+\n         t.verify(data);\n     }\n     \n     @Test\n     public void should_fail_because_verification_fails() {\n-        Timeout t = new Timeout(1, 2, mode);\n-        \n+        Timeout t = new Timeout(1, 2, mode, timer);\n+\n+        when(timer.isUp(anyLong())).thenReturn(true, true, true, false);\n         doThrow(error).\n         doThrow(error).\n         doThrow(error).\n     \n     @Test\n     public void should_pass_even_if_first_verification_fails() {\n-        Timeout t = new Timeout(1, 5, mode);\n-        \n+        Timeout t = new Timeout(1, 5, mode, timer);\n+\n+        when(timer.isUp(anyLong())).thenReturn(true, true, true, false);\n         doThrow(error).\n         doThrow(error).\n         doNothing().\n \n     @Test\n     public void should_try_to_verify_correct_number_of_times() {\n-        Timeout t = new Timeout(10, 50, mode, durationChecker);\n+        Timeout t = new Timeout(10, 50, mode, timer);\n         \n         doThrow(error).when(mode).verify(data);\n-        when(durationChecker.isVerificationStillInProgress(anyLong())).thenReturn(true, true, true, true, true, false);\n+        when(timer.isUp(anyLong())).thenReturn(true, true, true, true, true, false);\n \n         try {\n             t.verify(data);\n     \n     @Test\n     public void should_create_correctly_configured_timeout() {\n-        Timeout t = new Timeout(25, 50, mode);\n+        Timeout t = new Timeout(25, 50, mode, timer);\n         \n         assertTimeoutCorrectlyConfigured(t.atLeastOnce(), Timeout.class, 50, 25, AtLeast.class);\n         assertTimeoutCorrectlyConfigured(t.atLeast(5), Timeout.class, 50, 25, AtLeast.class);", "timestamp": 1411850417, "metainfo": ""}