{"sha": "46158895587c8386aa9ecde36fb1d49189aacc5d", "log": "Improved after() to return immediately if a test has definitely failed, rather than waiting the full time", "commit": "\n--- a/src/org/mockito/internal/verification/VerificationAfterDelayImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationAfterDelayImpl.java\n \n package org.mockito.internal.verification;\n \n+import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.verification.VerificationMode;\n \n public class VerificationAfterDelayImpl implements VerificationMode {\n \n+    private int pollingPeriod;\n     private int delayMillis;\n     private VerificationMode delegate;\n \n-    public VerificationAfterDelayImpl(int delayMillis, VerificationMode delegate) {\n+    public VerificationAfterDelayImpl(int pollingPeriod, int delayMillis, VerificationMode delegate) {\n+        this.pollingPeriod = pollingPeriod;\n         this.delayMillis = delayMillis;\n         this.delegate = delegate;\n     }\n     \n     public void verify(VerificationData data) {\n+        MockitoAssertionError error = null;\n+        \n         long startTime = System.currentTimeMillis();\n         while (System.currentTimeMillis() - startTime <= delayMillis) {\n             try {\n-                Thread.sleep(delayMillis);\n-            } catch (InterruptedException ie) {\n-                // Oops. Try again.\n+                delegate.verify(data);\n+                error = null;\n+            } catch (MockitoAssertionError e) {\n+                if (canRecoverFromFailure(delegate)) {\n+                    error = e;\n+                    sleep(pollingPeriod);\n+                } else {\n+                    throw e;\n+                }\n             }\n         }\n         \n-        delegate.verify(data);\n+        if (error != null) {\n+            throw error;\n+        }\n+    }\n+\n+    private boolean canRecoverFromFailure(VerificationMode verificationMode) {\n+        return !(verificationMode instanceof AtMost || verificationMode instanceof Only || verificationMode instanceof NoMoreInteractions);\n+    }\n+\n+    private void sleep(int sleep) {\n+        try {\n+            Thread.sleep(sleep);\n+        } catch (InterruptedException ie) {\n+            // oups. not much luck.\n+        }\n     }\n \n     public int getDelay() {\n         return delayMillis;\n     }\n \n+    public int getPollingPeriod() {\n+        return pollingPeriod;\n+    }\n+\n }\n--- a/src/org/mockito/verification/After.java\n+++ b/src/org/mockito/verification/After.java\n \n import org.mockito.internal.verification.VerificationAfterDelayImpl;\n \n-\n+/**\n+ * See the javadoc for {@link VerificationAfterDelay}\n+ * <p>\n+ * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n+ * See javadoc for {@link VerificationWithTimeout}\n+ */  \n public class After extends VerificationWrapper<VerificationAfterDelayImpl> implements VerificationAfterDelay {\n     \n     /**\n      * <p>\n      * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n      * See javadoc for {@link VerificationWithTimeout}\n-     */    \n+     */\n     public After(int delayMillis, VerificationMode verificationMode) {\n-        super(new VerificationAfterDelayImpl(delayMillis, verificationMode));\n+        this(10, delayMillis, verificationMode);\n+    }\n+    \n+    public After(int pollingPeriod, int delayMillis, VerificationMode verificationMode) {\n+        super(new VerificationAfterDelayImpl(pollingPeriod, delayMillis, verificationMode));\n     }\n     \n     @Override\n     protected VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode) {\n-        return new After(wrappedVerification.getDelay(), verificationMode);\n+        return new After(wrappedVerification.getPollingPeriod(), wrappedVerification.getDelay(), verificationMode);\n     }\n \n }\n--- a/src/org/mockito/verification/VerificationAfterDelay.java\n+++ b/src/org/mockito/verification/VerificationAfterDelay.java\n  * verify(mock, after(200).atLeastOnce()).baz();\n  * </code></pre>\n  * \n- * This is similar to {@link VerificationWithTimeout timeout()} except the assertion will not terminate until \n- * the full time has elapsed (whereas timeout() will also stop if the condition is true at any point, as is\n+ * This is similar to {@link VerificationWithTimeout timeout()} except the assertion will not terminate until either the condition is \n+ * definitively failed, or the full time has elapsed (whereas timeout() will also stop if the conditions is true at any point, as is\n  * typically the case with never() etc initially). \n  * \n  * <p>\n public interface VerificationAfterDelay extends VerificationMode {\n     \n     /**\n-     * Verifies that there are exactly N invocations during the given period.\n+     * Verifies that there are exactly N invocations during the given period. This will wait the full period given.\n      */\n     public VerificationMode times(int wantedNumberOfInvocations);\n \n     /**\n-     * Allows verification that there are no invocations at any point during the given period.\n+     * Allows verification that there are no invocations at any point during the given period. This will wait the \n+     * full period given, unless an invocation occurs (in which case there will be immediate failure)\n      */\n     public VerificationMode never();\n     \n     /**\n-     * Verifies that there is at least 1 invocation during the given period.\n+     * Verifies that there is at least 1 invocation during the given period. This will wait the full period given.\n      */\n     public VerificationMode atLeastOnce();\n     \n     /**\n-     * Verifies that there is are least N invocations during the given period.\n+     * Verifies that there is are least N invocations during the given period. This will wait the full period given.\n      */\n     public VerificationMode atLeast(int minNumberOfInvocations);\n     \n     /**\n-     * Verifies that there is are most N invocations during the given period.\n+     * Verifies that there is are most N invocations during the given period. This will wait the full period given,\n+     * unless too many invocations occur (in which case there will be an immediate failure)\n      */\n     public VerificationMode atMost(int maxNumberOfInvocations);\n     \n     /**\n-     * Verifies that there the given method is invoked and is the only method invoked.\n+     * Verifies that there the given method is invoked and is the only method invoked. This will wait the full \n+     * period given, unless another method is invoked (in which case there will be an immediate failure)\n      */\n     public VerificationMode only();\n     \n--- a/src/org/mockito/verification/VerificationWithTimeout.java\n+++ b/src/org/mockito/verification/VerificationWithTimeout.java\n  * </code></pre>\n  * \n  * This is similar to {@link VerificationAfterDelay after()} except this assertion will immediately pass if it becomes true at any point,\n- * whereas after() will wait the full period. Assertions which are consistently expected to be initially true and potentially become false are \n- * deprecated below, and after() should be used instead.\n+ * whereas after() will wait the full period (or until the test has definitely failed). Assertions which are consistently expected to be\n+ * initially true and potentially become false are deprecated below, and after() should be used instead.\n  * \n  * <p>\n  * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n--- a/test/org/mockitousage/verification/VerificationAfterDelayTest.java\n+++ b/test/org/mockitousage/verification/VerificationAfterDelayTest.java\n     }\n \n     @Test\n-    public void shouldWaitTheFullTime() throws Exception {\n+    public void shouldWaitTheFullTimeIfTheTestCouldPass() throws Exception {\n         // given\n         Thread t = waitAndExerciseMock(50);\n \n         // when\n         t.start();\n \n+        // then        \n+        long startTime = System.currentTimeMillis();\n+        \n+        try {\n+            verify(mock, after(100).atLeast(2)).clear();\n+            fail();\n+        } catch (MockitoAssertionError e) {}\n+        \n+        assertTrue(System.currentTimeMillis() - startTime >= 100);\n+    }\n+    \n+    @Test(timeout=100)\n+    public void shouldStopEarlyIfTestIsDefinitelyFailed() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(50);\n+        \n+        // when\n+        t.start();\n+        \n         // then\n-        long startTime = System.currentTimeMillis();\n-        verify(mock, after(100).atMost(1)).clear();\n-        assertTrue(System.currentTimeMillis() - startTime >= 100);\n-    } \n+        expected.expect(MockitoAssertionError.class);\n+        verify(mock, after(10000).never()).clear();\n+    }\n \n     private Thread waitAndExerciseMock(final int sleep) {\n         Thread t = new Thread() {", "timestamp": 1381493193, "metainfo": ""}