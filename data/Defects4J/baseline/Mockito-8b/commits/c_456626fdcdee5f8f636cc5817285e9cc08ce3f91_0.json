{"sha": "456626fdcdee5f8f636cc5817285e9cc08ce3f91", "log": "javadoc tune-up  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40399", "commit": "\n--- a/src/org/mockito/AdditionalMatchers.java\n+++ b/src/org/mockito/AdditionalMatchers.java\n  *   //1 or 10\n  *   mock.someMethod(or(eq(1), eq(10)));\n  * </pre>\n+ * \n+ * Scroll down to see all methods - full list of matchers.\n  */\n public class AdditionalMatchers {\n \n--- a/src/org/mockito/InOrder.java\n+++ b/src/org/mockito/InOrder.java\n      * See examples in javadoc for {@link Mockito} class\n      * \n      * @param mock to be verified\n-     * @param mode, for example times(x) or atLeastOnce()\n+     * @param mode for example times(x) or atLeastOnce()\n      * \n      * @return mock object itself\n      */\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *   mockedList.clear();\n  * </pre>\n  *\n+ * <h3>Verification in order</h3>\n+ * \n+ * <pre>\n+ *   List firstMock = mock(List.class);\n+ *   List secondMock = mock(List.class);\n+ *   \n+ *   //using mocks\n+ *   firstMock.add(\"was called first\");\n+ *   secondMock.add(\"was called second\");\n+ *   \n+ *   //create inOrder object passing any mocks that need to be verified in order\n+ *   InOrder inOrder = inOrder(firstMock, secondMock);\n+ *   \n+ *   //following will make sure that firstMock was called before secondMock\n+ *   inOrder.verify(firstMock).add(\"was called first\");\n+ *   inOrder.verify(secondMock).add(\"was called second\");\n+ * </pre>\n+ * \n+ * Verification in order is flexible - you don't have to verify all interactions one-by-one\n+ * but only those that you are interested in testing in order. \n+ * <p>\n+ * Also, you can create InOrder object passing only mocks that relevant for in-order verification.  \n+ *\n+ * <h3>Making sure interaction(s) never happened on mock</h3>\n+ * \n+ * <pre>\n+ *   //using mocks - only mockOne is interacted\n+ *   mockOne.add(\"one\");\n+ *   \n+ *   //ordinary verification\n+ *   verify(mockOne).add(\"one\");\n+ *   \n+ *   //verify that method was never called on a mock\n+ *   verify(mockOne, never()).add(\"two\"); \n+ *   \n+ *   //verify that other mocks were not interacted\n+ *   verifyZeroInteractions(mockTwo, mockThree);\n+ *   \n+ *   //following works exactly the same as above\n+ *   verifyNoMoreInteractions(mockTwo, mockThree);\n+ * </pre>\n+ *\n+ * See more {@link Mockito#verifyNoMoreInteractions}\n+ * \n+ * <p>\n+ * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but \n+ * the first one is more explicit and can read better.\n+ *\n  * <h3>Finding redundant invocations</h3>\n  * \n  * <pre>\n  * </pre>\n  * \n  * Remember that usually it's not necessary to call verifyNoMoreInteractions() all the time.\n- * <p>\n- * See more {@link Mockito#verifyNoMoreInteractions}\n- * \n- * <h3>Verification in order</h3>\n- * \n- * <pre>\n- *   List firstMock = mock(List.class);\n- *   List secondMock = mock(List.class);\n- *   \n- *   //using mocks\n- *   firstMock.add(\"was called first\");\n- *   secondMock.add(\"was called second\");\n- *   \n- *   //create inOrder object passing any mocks that need to be verified in order\n- *   InOrder inOrder = inOrder(firstMock, secondMock);\n- *   \n- *   //following will make sure that firstMock was called before secondMock\n- *   inOrder.verify(firstMock).add(\"was called first\");\n- *   inOrder.verify(secondMock).add(\"was called second\");\n- * </pre>\n- * \n- * Verification in order is flexible - you don't have to verify all interactions one-by-one\n- * but only those that you are interested in testing in order. \n- * <p>\n- * Also, you can create InOrder object passing only mocks that relevant for in-order verification.  \n- *\n- * <h3>Making sure interaction(s) never happened on mock</h3>\n- * \n- * <pre>\n- *   //using mocks - only mockOne is interacted\n- *   mockOne.add(\"one\");\n- *   \n- *   //ordinary verification\n- *   verify(mockOne).add(\"one\");\n- *   \n- *   //verify that method was never called on a mock\n- *   verify(mockOne, never()).add(\"two\"); \n- *   \n- *   //verify that other mocks were not interacted\n- *   verifyZeroInteractions(mockTwo, mockThree);\n- *   \n- *   //following works exactly the same as above\n- *   verifyNoMoreInteractions(mockTwo, mockThree);\n- * </pre>\n- * \n- * <p>\n- * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but \n- * the first one is more explicit and can read better.\n+ * See also {@link Mockito#never()} - it is more explicit and communicates an intent well. \n+ * <p>\n  * \n  * <h3>Shorthand for mocks creation - &#064;Mock annotation</h3>\n  * \n      * else was invoked on your mocks.\n      * <p>\n      * Usually it's not necessary to call verifyNoMoreInteractions() all the time.\n+     * See also {@link Mockito#never()} - it is more explicit and communicates an intent well.\n      * <p>\n      * Stubbed invocations (if called) are also treated as interactions.\n      * <p>", "timestamp": 1204035182, "metainfo": ""}