{"sha": "48da013300b1f151dfcbde995e85ac1d5ca60f84", "log": "Started working on issue 212. Introduced new feature to cglib. Now one can better decide on whether to include a method in proxying or not.", "commit": "\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackFilter.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackFilter.java\n package org.mockito.cglib.proxy;\n \n import java.lang.reflect.Method;\n+import java.util.List;\n \n /**\n  * Map methods of subclasses generated by {@link Enhancer} to a particular\n public interface CallbackFilter {\n     /**\n      * Map a method to a callback.\n+     *\n      * @param method the intercepted method\n-     * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method, \n+     * @param allMethods all the methods found on the instance. Don't mess with the contents of this list!!!\n+     * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method,\n      */\n-    int accept(Method method);\n+    int accept(Method method, List<Method> allMethods);\n \n     /**\n      * The <code>CallbackFilter</code> in use affects which cached class\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackHelper.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackHelper.java\n         }\n     }\n \n-    public int accept(Method method)\n+    public int accept(Method method, List<Method> allMethods)\n     {\n         return ((Integer)methodMap.get(method)).intValue();\n     }\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/Enhancer.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Enhancer.java\n  */\n package org.mockito.cglib.proxy;\n \n-import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.asm.Attribute;\n import org.mockito.asm.ClassVisitor;\n import org.mockito.asm.Label;\n import org.mockito.asm.Type;\n public class Enhancer extends AbstractClassGenerator\n {\n     private static final CallbackFilter ALL_ZERO = new CallbackFilter(){\n-        public int accept(Method method) {\n+        public int accept(Method method, List<Method> allMethods) {\n             return 0;\n         }\n     };\n         while (it1.hasNext()) {\n             MethodInfo method = (MethodInfo)it1.next();\n             Method actualMethod = (it2 != null) ? (Method)it2.next() : null;\n-            int index = filter.accept(actualMethod);\n+            int index = filter.accept(actualMethod, actualMethods);\n             if (index >= callbackTypes.length) {\n                 throw new IllegalArgumentException(\"Callback filter returned an index that is too large: \" + index);\n             }\n--- a/cglib-and-asm/src/org/mockito/cglib/proxy/Proxy.java\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Proxy.java\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-import java.lang.reflect.Member;\n+import java.util.List;\n \n import org.mockito.cglib.core.CodeGenerationException;\n \n     protected InvocationHandler h;\n \n     private static final CallbackFilter BAD_OBJECT_METHOD_FILTER = new CallbackFilter() {\n-        public int accept(Method method) {\n+        public int accept(Method method, List<Method> allMethods) {\n             if (method.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\n                 String name = method.getName();\n                 if (!(name.equals(\"hashCode\") ||", "timestamp": 1294007854, "metainfo": ""}