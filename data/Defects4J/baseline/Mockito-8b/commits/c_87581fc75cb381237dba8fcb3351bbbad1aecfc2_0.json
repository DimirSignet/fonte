{"sha": "87581fc75cb381237dba8fcb3351bbbad1aecfc2", "log": "more stuff to doReturn() - more checks around exceptional scenarios  --HG-- rename : test/org/mockitousage/examples/use/PrototypingTest.java => test/org/mockitousage/PrototypingTest.java rename : test/org/mockitousage/binding/BridgeMethodPuzzleTest.java => test/org/mockitousage/puzzlers/BridgeMethodPuzzleTest.java rename : test/org/mockitousage/binding/OverloadingPuzzleTest.java => test/org/mockitousage/puzzlers/OverloadingPuzzleTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40685", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.Returns;\n+import org.mockito.internal.stubbing.ReturnsVoid;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.StubberImpl;\n import org.mockito.internal.stubbing.ThrowsException;\n     }\n     \n     public static Stubber doReturn() {\n-        return doAnswer(new Returns());\n+        return doAnswer(new ReturnsVoid());\n     }\n     \n     public static Stubber doThrow(Throwable toBeThrown) {\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     public void cannotStubVoidMethodWithAReturnValue() {\n         throw new MockitoException(join(\n                 \"Cannot stub a void method with a return value!\",\n-                \"Voids should be stubbed with Throwables (or instances of Answer interface)\"\n+                \"Voids are usually stubbed with Throwables:\",\n+                \"    doThrow(new RuntimeException()).when(mock).someVoidMethod();\"\n              ));\n     }\n+\n+    public void cannotStubNonVoidMethodWithAVoidReturn() {\n+        throw new MockitoException(join(\n+                \"Cannot stub a non-void method with a void return!\",\n+                \"Void return is only used for stubbing consecutive calls on void methods.\",\n+                \"Example:\",\n+                \"    doReturn().\",\n+                \"    doThrow(new RuntimeException()).\",\n+                \"    when(mock).someVoidMethod();\",\n+                \"Above means:\",\n+                \"someVoidMethod() does nothing the 1st time but throws an exception 2nd time is called\"\n+             ));\n+    }\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.stubbing.MockitoStubber;\n import org.mockito.internal.stubbing.Returns;\n-import org.mockito.internal.stubbing.MockitoStubber;\n+import org.mockito.internal.stubbing.ReturnsVoid;\n import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n         }\n \n         public VoidMethodStubbable<T> toReturn() {\n-            mockitoStubber.addAnswerForVoidMethod(new Returns());\n+            mockitoStubber.addAnswerForVoidMethod(new ReturnsVoid());\n             return this;\n         }\n \n--- a/src/org/mockito/internal/stubbing/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/AnswersValidator.java\n     \n     public void validate(Answer<?> answer, Invocation invocation) {\n         if (answer instanceof ThrowsException) {\n-            validateException(answer, invocation);\n+            validateException((ThrowsException) answer, invocation);\n         }\n         \n         if (answer instanceof Returns) {\n-            validateReturnValue(answer, invocation);\n+            validateReturnValue((Returns) answer, invocation);\n+        }\n+        \n+        if (answer instanceof ReturnsVoid) {\n+            validateVoidReturn((ReturnsVoid) answer, invocation);\n         }\n     }\n \n-    private void validateReturnValue(Answer<?> answer, Invocation invocation) {\n-        if (invocation.isVoid() && ((Returns) answer).hasReturnValue()) {\n+    private void validateVoidReturn(ReturnsVoid answer, Invocation invocation) {\n+        if (!invocation.isVoid()) {\n+            reporter.cannotStubNonVoidMethodWithAVoidReturn();\n+        }\n+    }\n+\n+    private void validateReturnValue(Returns answer, Invocation invocation) {\n+        if (invocation.isVoid()) {\n             reporter.cannotStubVoidMethodWithAReturnValue();\n         }\n     }\n \n-    private void validateException(Answer<?> answer, Invocation invocation) {\n-        Throwable throwable = ((ThrowsException) answer).getThrowable();\n+    private void validateException(ThrowsException answer, Invocation invocation) {\n+        Throwable throwable = answer.getThrowable();\n         if (throwable == null) {\n             reporter.cannotStubWithNullThrowable();\n         }\n--- a/src/org/mockito/internal/stubbing/Returns.java\n+++ b/src/org/mockito/internal/stubbing/Returns.java\n         this.value = value;\n     }\n \n-    public Returns() {\n-        this(null);\n-    }\n-\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return value;\n     }\n-\n-    public boolean hasReturnValue() {\n-        return this.value != null;\n-    }\n }\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n     Stubber doReturn();\n     Stubber doThrow(Throwable toBeThrown);\n     Stubber doAnswer(Answer answer);\n-    \n }\n--- a/src/org/mockito/internal/stubbing/StubberImpl.java\n+++ b/src/org/mockito/internal/stubbing/StubberImpl.java\n     }\n \n     public Stubber doReturn() {\n-        answers.add(new Returns());\n+        answers.add(new ReturnsVoid());\n         return this;\n     }\n \n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.verification.VerifyingRecorderTest;\n import org.mockitousage.ReplacingObjectMethodsTest;\n import org.mockitousage.UsingVarargsTest;\n-import org.mockitousage.binding.BridgeMethodPuzzleTest;\n-import org.mockitousage.binding.OverloadingPuzzleTest;\n import org.mockitousage.examples.configure.withbaseclass.ConfiguringDefaultReturnValuesUsingBaseClassTest;\n import org.mockitousage.examples.configure.withrunner.ConfiguringDefaultReturnValuesUsingRunnerTest;\n import org.mockitousage.examples.configure.withstaticutility.ConfiguringSelectedMocksToReturnFakesTest;\n import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n import org.mockitousage.misuse.InvalidStateDetectionTest;\n import org.mockitousage.misuse.InvalidUsageTest;\n+import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n+import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationChunkTest;\n import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n import org.mockitousage.stacktrace.StackTraceFilteringTest;\n--- a/test/org/mockito/internal/stubbing/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/AnswersValidatorTest.java\n     public void shouldFailWhenReturnValueSetForVoidMethod() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailWhenVoidReturnSetOnNonVoidMethod() throws Throwable {\n+        validator.validate(new ReturnsVoid(), new InvocationBuilder().simpleMethod().toInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldAllowVoidReturnForVoidMethod() throws Throwable {\n+        validator.validate(new ReturnsVoid(), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/ReturnsVoid.java\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+public class ReturnsVoid implements Answer<Object> {\n+    \n+    @Override\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/PrototypingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockitousage.examples.junitrunner.MockitoRunner;\n+import org.mockitoutil.TestBase;\n+\n+@RunWith(MockitoRunner.class)\n+public class PrototypingTest extends TestBase {\n+    \n+    @Ignore\n+    @Test\n+    public void prototypingNewAPI() throws Exception {\n+//        List mock = mock(List.class);\n+//        stubVoid(mock).toThrow(new RuntimeException()).on().clear();\n+//        \n+//        when(mock.get(0)).thenReturn(\"afsdf\");\n+//        \n+//        \n+//        when(mock.get(0))\n+//            .thenReturn(\"foo\")\n+//            .thenReturn(\"bar\")\n+//            .thenRaise(new RuntimeException());\n+//        \n+//        raise(new RuntimeException())\n+//            .thenRaise(new RuntimeException())\n+//            .thenReturn()\n+//            .when(mock).get(0);\n+//        \n+//        \n+//        \n+//        when(mock.get(0))\n+//            .thenReturn(\"foo\")\n+//            .thenReturn(\"bar\")\n+//            .thenThrow(new RuntimeException());\n+//    \n+//        doThrow(new RuntimeException())\n+//            .thenThrow(new RuntimeException())\n+//            .thenReturn()\n+//            .when(mock).get(0);\n+//\n+//        \n+//        raise(new RuntimeException()).when(mock).clear();\n+//        \n+//        raise(new RuntimeException())\n+//        .thenRaise(new RuntimeException())\n+//        .when(mock).clear();\n+//        \n+//        doReturn(\"two\")\n+//        .thenReturn(\"one\")\n+//        .when(mock).get(0);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/puzzlers/BridgeMethodPuzzleTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.puzzlers;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockitoutil.ExtraMatchers.*;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+/**\n+ * Bridge method is generated by compiler when erasure in parent class is\n+ * different. When is different then it means that in runtime we will have\n+ * overloading rather than overridding Therefore the compiler generates bridge\n+ * method in Subclass so that erasures are the same, signatures of methods match\n+ * and overridding is ON.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class BridgeMethodPuzzleTest extends TestBase {\n+    \n+    private class Super<T> {\n+        public String say(T t) {\n+            return \"Super says: \" + t;\n+        }\n+    }\n+    \n+    private class Sub extends Super<String> {\n+        @Override\n+        public String say(String t)  {\n+            return \"Dummy says: \" + t;\n+        }\n+    }\n+\n+    Super mock;\n+    \n+    private void setMockWithDownCast(Super mock) {\n+        this.mock = mock;\n+    }\n+    \n+    private void say(String string) {\n+        mock.say(string);\n+    }\n+    \n+    @Test\n+    public void shouldHaveBridgeMethod() throws Exception {\n+        Super s = new Sub();\n+        \n+        assertEquals(\"Dummy says: Hello\", s.say(\"Hello\"));\n+        \n+        assertThat(Sub.class, hasBridgeMethod(\"say\"));\n+        assertThat(s, hasBridgeMethod(\"say\"));\n+    }\n+    \n+    @Test\n+    public void shouldVerifyCorrectlyWhenBridgeMethodCalled() throws Exception {\n+        //Super has following erasure: say(Object) which differs from Dummy.say(String)\n+        //mock has to detect it and do the super.say()\n+        //see MockFactory.java\n+        Sub s = mock(Sub.class);\n+        setMockWithDownCast(s);\n+        say(\"Hello\");\n+        \n+        verify(s).say(\"Hello\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/puzzlers/OverloadingPuzzleTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.puzzlers;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitoutil.TestBase;\n+\n+public class OverloadingPuzzleTest extends TestBase {\n+\n+    private Super mock;\n+\n+    private void setMockWithDowncast(Super mock) {\n+        this.mock = mock;\n+    }\n+\n+    private interface Super {\n+        void say(Object message);\n+    }\n+\n+    private interface Sub extends Super {\n+        void say(String message);\n+    }\n+\n+    private void say(Object message) {\n+        mock.say(message);\n+    }\n+\n+    @Test\n+    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected() throws Exception {\n+        Sub sub = mock(Sub.class);\n+        setMockWithDowncast(sub);\n+        say(\"Hello\");\n+        try {\n+            verify(sub).say(\"Hello\");\n+            fail();\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+}\n--- a/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n import java.io.IOException;\n \n import org.junit.After;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.StateMaster;\n import org.mockito.MockitoAnnotations.Mock;\n         assertEquals(\"foo\", mock.simpleMethod());\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldNotAllowDoReturnOnNonVoids() {\n-        doReturn().when(mock).simpleMethod();\n-        fail();\n+        try {\n+            doReturn().when(mock).simpleMethod();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage(), contains(\"Cannot stub a non-void method\"));\n+        }\n     }\n     \n     //TODO state validation", "timestamp": 1216248044, "metainfo": ""}