{"sha": "52929f4db49db9a3384f9962cb61e336ffff1c00", "log": "refactored mock creation logic to the way jmock guys did it  --HG-- rename : src/org/mockito/internal/creation/SearchingClassLoader.java => src/org/mockito/internal/creation/jmock/SearchingClassLoader.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40920", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     \n     public void cannotMockFinalClass(Class<?> clazz) {\n         throw new MockitoException(join(\n-                \"Mockito cannot mock final classes like: \",\n+                \"Mockito cannot mock primitives or final classes like: \",\n                 clazz.toString()\n         ));\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+package org.mockito.internal.creation.jmock;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.List;\n+\n+import net.sf.cglib.core.CodeGenerationException;\n+import net.sf.cglib.core.DefaultNamingPolicy;\n+import net.sf.cglib.core.NamingPolicy;\n+import net.sf.cglib.core.Predicate;\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.CallbackFilter;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.NoOp;\n+\n+import org.objenesis.ObjenesisStd;\n+\n+/**\n+ * Thanks to jMock guys for this handy class that wraps all the cglib magic. \n+ */\n+public class ClassImposterizer  {\n+\n+    public static final ClassImposterizer INSTANCE = new ClassImposterizer();\n+    \n+    private ClassImposterizer() {}\n+    \n+    private ObjenesisStd objenesis = new ObjenesisStd();\n+    \n+    private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new DefaultNamingPolicy() {\n+        @Override\n+        public String getClassName(String prefix, String source, Object key, Predicate names) {\n+            return \"codegen.\" + super.getClassName(prefix, source, key, names);\n+        }\n+    };\n+    \n+    private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {\n+        public int accept(Method method) {\n+            return method.isBridge() ? 1 : 0;\n+        }\n+    };\n+    \n+    public boolean canImposterise(Class<?> type) {\n+        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n+    }\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancilliaryTypes) {\n+        try {\n+            setConstructorsAccessible(mockedType, true);\n+            Class<?> proxyClass = createProxyClass(mockedType);\n+            return mockedType.cast(createProxy(proxyClass, interceptor));\n+        } finally {\n+            setConstructorsAccessible(mockedType, false);\n+        }\n+    }\n+    \n+    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n+        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n+            constructor.setAccessible(accessible);\n+        }\n+    }\n+    \n+    private <T> Class<?> createProxyClass(Class<?> mockedType) {\n+        if (mockedType == Object.class) {\n+            mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n+        }\n+        \n+        Enhancer enhancer = new Enhancer() {\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            protected void filterConstructors(Class sc, List constructors) {\n+                // Don't filter\n+            }\n+        };\n+        enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));\n+        enhancer.setUseFactory(true);\n+        if (mockedType.isInterface()) {\n+            enhancer.setSuperclass(Object.class);\n+            enhancer.setInterfaces(prepend(mockedType));\n+        } else {\n+            enhancer.setSuperclass(mockedType);\n+        }\n+        enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\n+        enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\n+        if (mockedType.getSigners() != null) {\n+            enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);\n+        }\n+        \n+        try {\n+            return enhancer.createClass(); \n+        } catch (CodeGenerationException e) {\n+            throw new IllegalArgumentException(\"could not imposterise \" + mockedType, e);\n+        }\n+    }\n+    \n+    private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\n+        Factory proxy = (Factory) objenesis.newInstance(proxyClass);\n+        proxy.setCallbacks(new Callback[] {interceptor, NoOp.INSTANCE});\n+        return proxy;\n+    }\n+    \n+    private Class<?>[] prepend(Class<?> first, Class<?>... rest) {\n+        Class<?>[] all = new Class<?>[rest.length+1];\n+        all[0] = first;\n+        System.arraycopy(rest, 0, all, 1, rest.length);\n+        return all;\n+    }\n+    \n+    public static class ClassWithSuperclassToWorkAroundCglibBug {}\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/jmock/SearchingClassLoader.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.jmock;\n+\n+import static java.lang.Thread.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Thanks to jMock guys for this ClassLoader. \n+ */\n+public class SearchingClassLoader extends ClassLoader {\n+    private final ClassLoader nextToSearch;\n+    \n+    public SearchingClassLoader(ClassLoader parent, ClassLoader nextToSearch) {\n+        super(parent);\n+        this.nextToSearch = nextToSearch;\n+    }\n+    \n+    public static ClassLoader combineLoadersOf(Class<?>... classes) {\n+        return combineLoadersOf(classes[0], classes);\n+    }\n+    \n+    private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {\n+        List<ClassLoader> loaders = new ArrayList<ClassLoader>();\n+        \n+        addIfNewElement(loaders, first.getClassLoader());\n+        for (Class<?> c : others) {\n+            addIfNewElement(loaders, c.getClassLoader());\n+        }\n+        \n+        // To support Eclipse Plug-in tests.\n+        // In an Eclipse plug-in, jMock itself will not be on the system class loader\n+        // but in the class loader of the plug-in.\n+        //\n+        // Note: I've been unable to reproduce the error in jMock's test suite.\n+        addIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());\n+        \n+        // To support the Maven Surefire plugin.\n+        // Note: I've been unable to reproduce the error in jMock's test suite.\n+        addIfNewElement(loaders, currentThread().getContextClassLoader());\n+\n+        addIfNewElement(loaders, ClassLoader.getSystemClassLoader());\n+        \n+        return combine(loaders);\n+    }\n+    \n+    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n+        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n+        \n+        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n+            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n+        }\n+        \n+        return loader;\n+    }\n+    \n+    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n+        if (c != null && !loaders.contains(c)) {\n+            loaders.add(c);\n+        }\n+    }\n+    \n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        if (nextToSearch != null) {\n+            return nextToSearch.loadClass(name);\n+        } else {\n+            return super.findClass(name); // will throw ClassNotFoundException\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n \n+import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.creation.MethodInterceptorFilter;\n-import org.mockito.internal.creation.MockFactory;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n \n public class MockUtil {\n     \n     public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String mockName, T optionalInstance) {\n+        validateType(classToMock);\n         if (mockName == null) {\n             mockName = toInstanceName(classToMock);\n         }\n-        MockFactory<T> proxyFactory = new MockFactory<T>();\n         MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder());\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n-        return proxyFactory.createMock(classToMock, filter, optionalInstance);\n+        \n+        T mock = (T) ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n+        filter.setInstance(optionalInstance != null ? optionalInstance : mock);\n+        return mock;\n+    }\n+\n+    private static <T> void validateType(Class<T> classToMock) {\n+        if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n+            new Reporter().cannotMockFinalClass(classToMock);\n+        }\n     }\n \n     private static String toInstanceName(Class<?> clazz) {\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.MockHandlerTest;\n import org.mockito.internal.configuration.DefaultReturnValuesTest;\n import org.mockito.internal.creation.CglibTest;\n-import org.mockito.internal.creation.MockFactoryTest;\n+import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.invocation.InvocationsFinderTest;\n                     NoMoreInvocationsVerifierTest.class,\n                     NumberOfInvocationsInOrderVerifierTest.class,\n                     MissingInvocationInOrderVerifierTest.class,\n-                    MockFactoryTest.class,\n+                    ClassImposterizerTest.class,\n                     CglibTest.class,\n                     InvocationMatcherTest.class,\n                     InvocationsFinderTest.class,\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n+package org.mockito.internal.creation.jmock;\n+\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+import org.junit.Test;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ClassImposterizerTest {\n+\n+    @Test\n+    public void shouldCreateMockFromInterface() throws Exception {\n+        SomeInterface proxy = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeInterface.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(Object.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClass() throws Exception {\n+        ClassWithoutConstructor proxy = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(ClassWithoutConstructor.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {\n+        try {\n+            new ClassWithDodgyConstructor();\n+            fail();\n+        } catch (Exception e) {}\n+        \n+        ClassWithDodgyConstructor mock = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);\n+        assertNotNull(mock);\n+    }\n+    \n+    @Test \n+    public void shouldMocksHaveDifferentInterceptors() throws Exception {\n+        SomeClass mockOne = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        SomeClass mockTwo = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        \n+        Factory cglibFactoryOne = (Factory) mockOne;\n+        Factory cglibFactoryTwo = (Factory) mockTwo;\n+        \n+        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n+    }\n+    \n+    private interface SomeInterface {};\n+\n+    private class SomeClass {};\n+    private class ClassWithoutConstructor {};\n+    \n+    private class ClassWithDodgyConstructor {\n+        public ClassWithDodgyConstructor() {\n+            throw new RuntimeException();\n+        }\n+    };\n+    \n+    private final class MethodInterceptorStub implements MethodInterceptor {\n+\n+        @Override\n+        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+            return null;\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/misuse/InvalidUsageTest.java\n+++ b/test/org/mockitousage/misuse/InvalidUsageTest.java\n         mock(FinalClass.class); \n     }\n     \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowMockingPrimitves() throws Exception {\n+        mock(Integer.TYPE); \n+    }\n+    \n     interface ObjectLikeInterface {\n         boolean equals(Object o);\n         String toString();\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n         \n         verifyZeroInteractions(mock);\n     }\n+    \n+    class Foo {\n+        public final String toString() {\n+            return \"foo\";\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldAllowMockingWhenToStringIsFinal() throws Exception {\n+        mock(Foo.class);\n+    }\n }", "timestamp": 1223472825, "metainfo": ""}