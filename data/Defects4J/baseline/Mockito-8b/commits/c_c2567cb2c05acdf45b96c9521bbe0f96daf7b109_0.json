{"sha": "c2567cb2c05acdf45b96c9521bbe0f96daf7b109", "log": "Renaming test methods to new naming convention before adding new test methods", "commit": "\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.invocation.Invocation;\n+import org.mockito.stubbing.answers.ReturnsIdentity;\n import org.mockitoutil.TestBase;\n \n import java.io.IOException;\n     private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n \n     @Test\n-    public void shouldValidateNullThrowable() throws Throwable {\n+    public void should_validate_null_throwable() throws Throwable {\n         try {\n             validator.validate(new ThrowsException(null), new InvocationBuilder().toInvocation());\n             fail();\n     }\n \n     @Test\n-    public void shouldPassProperCheckedException() throws Throwable {\n+    public void should_pass_proper_checked_exception() throws Throwable {\n         validator.validate(new ThrowsException(new CharacterCodingException()), invocation);\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailInvalidCheckedException() throws Throwable {\n+    public void should_fail_invalid_checked_exception() throws Throwable {\n         validator.validate(new ThrowsException(new IOException()), invocation);\n     }\n     \n     @Test\n-    public void shouldPassRuntimeExceptions() throws Throwable {\n+    public void should_pass_RuntimeExceptions() throws Throwable {\n         validator.validate(new ThrowsException(new Error()), invocation);\n         validator.validate(new ThrowsException(new RuntimeException()), invocation);\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailWhenReturnValueIsSetForVoidMethod() throws Throwable {\n+    public void should_fail_when_return_Value_is_set_for_void_method() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailWhenNonVoidMethodDoesNothing() throws Throwable {\n+    public void should_fail_when_non_void_method_does_nothing() throws Throwable {\n         validator.validate(new DoesNothing(), new InvocationBuilder().simpleMethod().toInvocation());\n     }\n     \n     @Test\n-    public void shouldAllowVoidReturnForVoidMethod() throws Throwable {\n+    public void should_allow_void_return_for_void_method() throws Throwable {\n         validator.validate(new DoesNothing(), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     }\n     \n     @Test\n-    public void shouldAllowCorrectTypeOfReturnValue() throws Throwable {\n+    public void should_allow_correct_type_of_return_value() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().simpleMethod().toInvocation());\n         validator.validate(new Returns(false), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n         validator.validate(new Returns(new Boolean(true)), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailOnReturnTypeMismatch() throws Throwable {\n+    public void should_fail_on_return_type_mismatch() throws Throwable {\n         validator.validate(new Returns(\"String\"), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n     }\n     \n     @Test(expected = MockitoException.class)\n-    public void shouldFailOnWrongPrimitive() throws Throwable {\n+    public void should_fail_on_wrong_primitive() throws Throwable {\n         validator.validate(new Returns(1), new InvocationBuilder().method(\"doubleReturningMethod\").toInvocation());\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailOnNullWithPrimitive() throws Throwable {\n+    public void should_fail_on_null_with_primitive() throws Throwable {\n         validator.validate(new Returns(null), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n     }\n     \n     @Test\n-    public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\n+    public void should_fail_when_calling_real_method_on_interface() throws Throwable {\n         //given\n         Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n         try {\n     }\n             \n     @Test\n-    public void shouldBeOKWhenCallingRealMethodOnConcreteClass() throws Throwable {\n+    public void should_be_OK_when_calling_real_method_on_concrete_class() throws Throwable {\n         //given\n         ArrayList mock = mock(ArrayList.class);\n         mock.clear();\n         validator.validate(new CallsRealMethods(), invocationOnClass);\n         //then no exception is thrown\n     }\n+\n }", "timestamp": 1333539442, "metainfo": ""}