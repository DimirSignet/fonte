{"sha": "f00a5d7736939f19fd11d2bb5b856f1505526c15", "log": "issue 145 / 280 : mock with delegate instance", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n import java.io.Serializable;\n \n /**\n- * Allows mock creation with additional mock settings. \n- * <p>\n- * Don't use it too often. \n- * Consider writing simple tests that use simple mocks. \n+ * Allows mock creation with additional mock settings.\n+ * <p/>\n+ * Don't use it too often.\n+ * Consider writing simple tests that use simple mocks.\n  * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n  * If you cannot write a test in a simple way - refactor the code under test.\n- * <p>\n+ * <p/>\n  * Examples of mock settings:\n  * <pre class=\"code\"><code class=\"java\">\n  *   //Creates mock with different default answer & name\n  *   Foo mock = mock(Foo.class, withSettings()\n- *       .defaultAnswer(RETURNS_SMART_NULLS)\n- *       .name(\"cool mockie\"));\n- *       \n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                );\n+ *\n  *   //Creates mock with different default answer, descriptive name and extra interfaces\n  *   Foo mock = mock(Foo.class, withSettings()\n- *       .defaultAnswer(RETURNS_SMART_NULLS)\n- *       .name(\"cool mockie\")\n- *       .extraInterfaces(Bar.class));    \n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                .extraInterfaces(Bar.class));\n  * </code></pre>\n- * {@link MockSettings} has been introduced for two reasons. \n+ * {@link MockSettings} has been introduced for two reasons.\n  * Firstly, to make it easy to add another mock setting when the demand comes.\n  * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n  */\n public interface MockSettings extends Serializable, MockSettingsInfo {\n-    \n+\n     /**\n      * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n-     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>  \n-     * <p>\n-     * This mysterious feature should be used very occasionally. \n+     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n+     * <p>\n+     * This mysterious feature should be used very occasionally.\n      * The object under test should know exactly its collaborators & dependencies.\n      * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n-     * <p>   \n+     * <p>\n      * Examples:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n-     *   \n+     *\n      *   //now, the mock implements extra interfaces, so following casting is possible:\n      *   Bar bar = (Bar) foo;\n      *   Baz baz = (Baz) foo;\n      * </code></pre>\n-     * \n+     *\n      * @param interfaces extra interfaces the should implement.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings extraInterfaces(Class<?>... interfaces);\n \n     /**\n-     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n+     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n      * <p>\n      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n      * Examples:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n-     *   \n+     *\n      *   //Below does exactly the same:\n      *   Foo foo = mock(Foo.class, \"foo\");\n      * </code></pre>\n \n     /**\n      * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n-     * Sets the real implementation to be called when the method is called on a mock object.\n+     *\n+     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n      * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * <p>\n-     * However, there are rare cases when partial mocks come handy: \n+     * However, there are rare cases when partial mocks come handy:\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Enough warnings about partial mocks, see an example how spiedInstance() works:\n      * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, spiedInstance(fooInstance));\n-     *   \n+     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n+     *\n      *   //Below does exactly the same:\n      *   Foo foo = spy(fooInstance);\n      * </code></pre>\n-     * \n+     *\n+     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n+     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *\n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </code>\n+     *\n      * @param instance to spy on\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings spiedInstance(Object instance);\n \n     /**\n-     * Specifies default answers to interactions. \n+     * Specifies default answers to interactions.\n      * It's quite advanced feature and typically you don't need it to write decent tests.\n      * However it can be helpful when working with legacy systems.\n      * <p>\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n      *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n-     *   \n+     *\n      *   //Below does exactly the same:\n      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n      * </code></pre>\n-     * \n+     *\n      * @param defaultAnswer default answer to be used by mock when not stubbed\n      * @return settings instance so that you can fluently specify other settings\n      */\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings serializable();\n-    \n+\n     /**\n      * Enables real-time logging of method invocations on this mock. Can be used\n      * during test debugging in order to find wrong interactions with this mock.\n      * <pre class=\"code\"><code class=\"java\">\n      * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n      * </code></pre>\n-     * \n+     *\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings verboseLogging();\n-    \n+\n     /**\n      * Registers a listener for method invocations on this mock. The listener is\n      * notified every time a method on this mock is called.\n      * <p>\n      * Multiple listeners may be added, but the same object is only added once.\n      * The order, in which the listeners are added, is not guaranteed to be the\n-     * order in which the listeners are notified. \n-     * \n+     * order in which the listeners are notified.\n+     *\n      * Example:\n      * <pre class=\"code\"><code class=\"java\">\n      *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n      * </code></pre>\n-     * \n+     *\n      * See the {@link InvocationListener listener interface} for more details.\n-     * \n+     *\n      * @param listeners The invocation listeners to add. May not be null.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings invocationListeners(InvocationListener... listeners);\n+\n+    /**\n+     * Specifies the delegated instance on which a mock should forward calls.\n+     *\n+     * Makes sense only for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API.\n+     * Possible use cases :\n+     * <ul>\n+     *     <li>Final classes but with an interface</li>\n+     *     <li>Already custom proxied object</li>\n+     *     <li>Special objects with a finalize method, that should be executed 2 times</li>\n+     *     <li>...</li>\n+     * </ul>\n+     * Sets the real implementation to be called when the method is called on a mock object.\n+     * <p>\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * In most cases, this is not the way you want to design your application.\n+     * <p>\n+     * However, there are rare cases when partial mocks come handy:\n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+     * <p>\n+     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   final class DontMessTheCodeOfThisList implements list { ... }\n+     *\n+     *   DontMessTheCodeOfThisList awesomeList = new DontMessTheCodeOfThisList();\n+     *\n+     *   List listWithDelegate = mock(List.class, withSettings().forwardTo(awesomeList));\n+     * </code></pre>\n+     *\n+     * <p>\n+     * This features suffer from the same drawback as the spy. The mock will always call the delegate.\n+     * This mean that you have to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List listWithDelegate = mock(List.class, withSettings().forwardTo(awesomeList));\n+     *\n+     *   //Impossible: real method is called so listWithDelegate.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(listWithDelegate.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(listWithDelegate).get(0);\n+     * </code>\n+     *\n+     * @param delegate The delegate to forward calls to.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings forwardTo(Object delegate) ;\n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n      * <h4>Important gotcha on spying real objects!</h4>\n      * <ol>\n      * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n-     * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of methods for stubbing. Example:\n+     * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>\n+     * family of methods for stubbing. Example:\n      *\n      * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"\"\n         ), details);\n     }\n+\n+\tpublic void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n+\t\tthrow new MockitoException(join(\n+                \"Mocked type must be the same as the type of your delegated instance.\",\n+                \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n+                \"  //correct delegate:\",\n+                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new ArrayList()<- );\",\n+                \"  //incorrect - types don't match:\",\n+                \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n+        ));\n+\t}\n+\n+\tpublic void spyAndDelegateAreMutuallyExclusive() {\n+\t\tthrow new MockitoException(join(\n+\t\t\t\t\"Settings should not define a spy instance and a delegated instance at the same time.\"\n+\t\t\t\t)) ;\n+\t}\n }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsDelegate;\n import org.mockito.internal.util.MockName;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.stubbing.Answer;\n     private Class<?>[] extraInterfaces;\n     private String name;\n     private Object spiedInstance;\n+    private Object delegatedInstance ;\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n     private boolean serializable;\n         if (extraInterfaces == null || extraInterfaces.length == 0) {\n             new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n         }\n-            \n+\n         for (Class<?> i : extraInterfaces) {\n             if (i == null) {\n                 new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n \n     public Object getSpiedInstance() {\n         return spiedInstance;\n+    }\n+\n+    public Object getDelegatedInstance() {\n+    \treturn this.delegatedInstance ;\n     }\n \n     public MockSettings name(String name) {\n     public boolean isSerializable() {\n         return serializable;\n     }\n-    \n+\n     public void initiateMockName(Class classToMock) {\n         mockName = new MockName(name, classToMock);\n     }\n     public void redefineMockName(String newName) {\n         mockName = new MockName(newName);\n     }\n+\n+\tpublic MockSettings forwardTo(Object delegatedInstance) {\n+\t\tthis.delegatedInstance = delegatedInstance ;\n+\t\treturn defaultAnswer(new ReturnsDelegate(this.delegatedInstance)) ;\n+\t}\n }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDelegate.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.internal.util.Primitives;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+\n+public class ReturnsDelegate implements Answer<Object>, Serializable {\n+\n+\tprivate static final long serialVersionUID = -8343690268123254910L;\n+\n+\tprivate Object delegatedObject = null ;\n+\n+\tpublic ReturnsDelegate(Object delegatedObject) {\n+\t\tthis.delegatedObject = delegatedObject ;\n+\t}\n+\n+\tpublic Object answer(InvocationOnMock invocation) throws Throwable {\n+\t\tMethod method = invocation.getMethod() ;\n+\t\tObject ret = method.invoke(delegatedObject, invocation.getArguments()) ;\n+\t\tif (ret != null) {\n+\t\t\treturn ret;\n+\t\t}\n+\n+\t\treturn returnValueFor(invocation.getMethod().getReturnType());\n+\t}\n+\n+\tObject returnValueFor(Class<?> type) {\n+\t\tif (type.isPrimitive()) {\n+\t\t\treturn primitiveOf(type);\n+\t\t} else if (Primitives.isPrimitiveWrapper(type)) {\n+\t\t\treturn Primitives.primitiveWrapperOf(type);\n+\t\t\t//new instances are used instead of Collections.emptyList(), etc.\n+\t\t\t//to avoid UnsupportedOperationException if code under test modifies returned collection\n+\t\t}\n+\n+\t\treturn null ;\n+\t}\n+\n+\tprivate Object primitiveOf(Class<?> type) {\n+\t\tif (type == Boolean.TYPE) {\n+\t\t\treturn false;\n+\t\t} else if (type == Character.TYPE) {\n+\t\t\treturn (char) 0;\n+\t\t} else {\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n+}\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n \n @SuppressWarnings(\"unchecked\")\n     public boolean isTypeMockable(Class<?> clz) {\n         return ClassImposterizer.INSTANCE.canImposterise(clz);\n     }\n-    \n+\n     public void validateType(Class classToMock) {\n         if (!isTypeMockable(classToMock)) {\n             new Reporter().cannotMockFinalClass(classToMock);\n         }\n     }\n-    \n+\n     public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n         if (extraInterfaces == null) {\n             return;\n         }\n-        \n+\n         for (Class i : extraInterfaces) {\n             if (classToMock == i) {\n                 new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n             }\n         }\n     }\n-    \n+\n     public void validateMockedType(Class classToMock, Object spiedInstance) {\n         if (classToMock == null || spiedInstance == null) {\n             return;\n             new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n         }\n     }\n+\n+    public void validateDelegatedInstance(Class classToMock, Object delegatedInstance) {\n+    \tif (classToMock == null || delegatedInstance == null) {\n+            return;\n+        }\n+    \tif (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n+            new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n+        }\n+    }\n+\n+\tpublic void validateMutualExclusionForSpyOrDelegate(MockSettingsImpl settings) {\n+\t\tif (settings.getDelegatedInstance() != null && settings.getSpiedInstance() != null) {\n+\t\t\tnew Reporter().spyAndDelegateAreMutuallyExclusive() ;\n+\t\t}\n+\n+\t}\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import java.io.Serializable;\n import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.plugins.MockMaker;\n import org.mockito.internal.InvocationNotifierHandler;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockito.plugins.MockMaker;\n+\n+import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n     public MockUtil(MockCreationValidator creationValidator) {\n         this.creationValidator = creationValidator;\n     }\n-    \n+\n     public MockUtil() {\n         this(new MockCreationValidator());\n     }\n         creationValidator.validateType(classToMock);\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n         creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n+        creationValidator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance()) ;\n+        creationValidator.validateMutualExclusionForSpyOrDelegate(settings) ;\n \n         settings.initiateMockName(classToMock);\n \n         if (spiedInstance != null) {\n             new LenientCopyTool().copyToMock(spiedInstance, mock);\n         }\n-        \n+\n         return mock;\n     }\n \n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static junit.framework.Assert.assertEquals;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithDelegate {\n+\n+\t@Test\n+\tpublic void when_not_stubbed_delegate_should_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\n+\t\tList<String> mock = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\n+\t\tmock.add(\"two\") ;\n+\n+        assertEquals(2, mock.size());\n+\t}\n+\n+\t@Test\n+\tpublic void when_stubbed_the_delegate_should_not_be_called() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mock = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\n+\t\tdoReturn(10).when(mock).size();\n+\n+\t\tmock.add(\"two\") ;\n+\n+\t\tassertEquals(10, mock.size());\n+        assertEquals(2, delegatedList.size());\n+\t}\n+\n+\t@Test\n+\tpublic void delegate_should_not_be_called_when_stubbed2() {\n+\t\tList<String> delegatedList = new ArrayList<String>();\n+\t\tdelegatedList.add(\"un\") ;\n+\t\tList<String> mockedList = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\n+\t\tdoReturn(false).when(mockedList).add(Mockito.anyString()) ;\n+\n+        mockedList.add(\"two\") ;\n+\n+\t\tassertEquals(1, mockedList.size()) ;\n+\t\tassertEquals(1, delegatedList.size()) ;\n+\t}\n+}", "timestamp": 1331333903, "metainfo": ""}