{"sha": "6eaf9a247dcfb68b88fec1f2a28808f2bfc19436", "log": "Trying a Top-Down approach instead of the Bottom-Up approach to better solve this generic mess (tests are broken here)(missing files)  --HG-- branch : issue230", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/BoundedType.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.Arrays;\n+\n+/**\n+ * Type representing bounds of a type variable, allows to keep all bounds information.\n+ *\n+ * <p>It uses the first bound in the array, as this array is never null and always contains at least\n+ * one element (Object is always here if no bounds are declared).</p>\n+ *\n+ * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n+ * interfacesBound will be an array of the additional interfaces.\n+ *\n+ * i.e. <code>SomeClass</code>.\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n+ *         E get();\n+ *     }\n+ *     // will return Comparable type\n+ * </code></pre>\n+ * </p>\n+ */\n+public class BoundedType implements Type {\n+    private TypeVariable typeVariable;\n+\n+\n+    public BoundedType(TypeVariable typeVariable) {\n+        this.typeVariable = typeVariable;\n+    }\n+\n+    /**\n+     * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n+     */\n+    public Type firstBound() {\n+        return typeVariable.getBounds()[0]; //\n+    }\n+\n+    /**\n+     * On a Type Variable (typeVar extends AClass_0 & I_1 & I_2 & etc), will return an array\n+     * containing I_1 and I_2.\n+     *\n+     * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n+     * empty array if no other bound declared.\n+     */\n+    public Type[] interfaceBounds() {\n+        Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n+        System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n+        return interfaceBounds;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        return typeVariable.equals(((BoundedType) o).typeVariable);\n+\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return typeVariable.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"{firstBound=\").append(firstBound());\n+        sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n+package org.mockito.internal.util.reflection;\n+\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+@Incubating\n+public abstract class MockitoGenericMetadata {\n+\n+    /**\n+     * Represents actual type variables resolved for current class.\n+     */\n+    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n+\n+    private MockitoGenericMetadata() {\n+    }\n+\n+\n+    protected void registerTypeVariablesOn(Type classType) {\n+        if (!(classType instanceof ParameterizedType)) { // null protected\n+            return;\n+        }\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            TypeVariable typeParameter = typeParameters[i];\n+            Type actualTypeArgument = actualTypeArguments[i];\n+\n+            contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n+            GenericTypeInfo.logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"' }\");\n+        }\n+    }\n+\n+    protected void registerTypeVariablesOn(Class<?> clazz) {\n+        TypeVariable[] typeParameters = clazz.getTypeParameters();\n+        for (TypeVariable typeParameter : typeParameters) {\n+            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n+            GenericTypeInfo.logger.log(\"For '\" + clazz.getCanonicalName() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    private Type boundsOf(TypeVariable typeParameter) {\n+        return new BoundedType(typeParameter);\n+    }\n+\n+    /**\n+     * @return Raw type of the current instance.\n+     */\n+    public abstract Class<?> rawType();\n+\n+    /**\n+     * @return Actual type arguments matching the type variables of the raw type represented by this {@link MockitoGenericMetadata} instance.\n+     */\n+    public Map<TypeVariable, Type> actualTypeArguments() {\n+        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n+\n+        TypeVariable[] typeParameters = rawType().getTypeParameters();\n+        for (TypeVariable typeParameter : typeParameters) {\n+\n+            Type actualType = getActualTypeArgumentFor(typeParameter);\n+\n+            actualTypeArguments.put(typeParameter, actualType);\n+            GenericTypeInfo.logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n+        }\n+\n+        return actualTypeArguments;\n+    }\n+\n+    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n+        Type type = this.contextualActualTypeParameters.get(typeParameter);\n+        if (type instanceof TypeVariable) {\n+            TypeVariable typeVariable = (TypeVariable) type;\n+            return getActualTypeArgumentFor(typeVariable);\n+        }\n+\n+        return type;\n+    }\n+\n+    public MockitoGenericMetadata resolveParameterizedType(Type genericReturnType) {\n+        throw new UnsupportedOperationException(\"not implemented yet\");\n+    }\n+\n+    /**\n+     * Resolve current method generic return type to a {@link MockitoGenericMetadata}.\n+     *\n+     * @param method Method to resolve the return type.\n+     * @return {@link MockitoGenericMetadata} representing this generic return type.\n+     */\n+    public MockitoGenericMetadata resolveGenericReturnType(Method method) {\n+        Type genericReturnType = method.getGenericReturnType();\n+        System.out.println(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n+\n+        if (genericReturnType instanceof Class) {\n+            return new NotGenericReturnType(genericReturnType);\n+        }\n+\n+        if (genericReturnType instanceof ParameterizedType) {\n+            ParameterizedType returnType = (ParameterizedType) genericReturnType;\n+            return new ParameterizedReturnType(this, method);\n+        }\n+\n+        return new MethodGenericReturnTypeMockitoGenericMetadata(this, method);\n+    }\n+\n+    /**\n+     * Create an new MockitoGenericMetadata from a {@link Type}.\n+     *\n+     * @param type The class from which the {@link MockitoGenericMetadata} should be built.\n+     * @return The new {@link MockitoGenericMetadata}.\n+     */\n+    public static MockitoGenericMetadata from(Type type) {\n+        if (type instanceof Class) {\n+            return new FromClassMockitoGenericMetadata((Class<?>) type);\n+        }\n+        if (type instanceof ParameterizedType) {\n+            return new FromParameterizedTypeMockitoGenericMetadata((ParameterizedType) type);\n+        }\n+        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n+    }\n+\n+\n+    private static class FromClassMockitoGenericMetadata extends MockitoGenericMetadata {\n+        private Class<?> clazz;\n+\n+        public FromClassMockitoGenericMetadata(Class<?> clazz) {\n+            this.clazz = clazz;\n+            readActualTypeParametersOnDeclaringClass();\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass() {\n+            registerTypeVariablesOn(clazz);\n+            registerTypeVariablesOn(clazz.getGenericSuperclass());\n+            for (Type genericInterface : clazz.getGenericInterfaces()) {\n+                registerTypeVariablesOn(genericInterface);\n+            }\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return clazz;\n+        }\n+    }\n+\n+\n+\n+    private static class FromParameterizedTypeMockitoGenericMetadata extends MockitoGenericMetadata {\n+        private ParameterizedType parameterizedType;\n+\n+        public FromParameterizedTypeMockitoGenericMetadata(ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            readActualTypeParameters();\n+        }\n+\n+        private void readActualTypeParameters() {\n+            registerTypeVariablesOn(parameterizedType.getRawType());\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            // ParameterizedType#getRawType() always return a class !\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+    }\n+\n+\n+\n+    private static class ParameterizedReturnType extends MockitoGenericMetadata {\n+\n+\n+        private final ParameterizedType parameterizedType;\n+        private final TypeVariable<Method>[] typeParameters;\n+\n+        public ParameterizedReturnType(MockitoGenericMetadata source, Method method) {\n+            parameterizedType = (ParameterizedType) method.getGenericReturnType();\n+            typeParameters = method.getTypeParameters();\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeVariables() {\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+    }\n+\n+\n+\n+    private static class MethodGenericReturnTypeMockitoGenericMetadata extends MockitoGenericMetadata {\n+        private final TypeVariable<Method>[] typeParameters;\n+\n+        private final Type genericReturnType;\n+\n+        public MethodGenericReturnTypeMockitoGenericMetadata(MockitoGenericMetadata source, Method method) {\n+            genericReturnType = method.getGenericReturnType();\n+            typeParameters = method.getTypeParameters();\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            resolveActualMethodTypeParameter();\n+        }\n+\n+        private void resolveActualMethodTypeParameter() {\n+            if (genericReturnType instanceof TypeVariable) {\n+                TypeVariable typeVariable = (TypeVariable) genericReturnType;\n+                for (Type type : typeVariable.getBounds()) {\n+                    registerTypeVariablesOn(type);\n+                }\n+                registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n+            }\n+            if (genericReturnType instanceof ParameterizedType) {\n+                registerTypeVariablesOn(genericReturnType);\n+            }\n+\n+            // throw new MockitoException(\"genericReturnType is a '\" + genericReturnType.getClass() + \"' : \" + genericReturnType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            if (genericReturnType instanceof TypeVariable) {\n+                Type actualTypeArgument = getActualTypeArgumentFor((TypeVariable) genericReturnType);\n+                return extractRawTypeOf(actualTypeArgument);\n+            }\n+            return extractRawTypeOf(genericReturnType);\n+        }\n+\n+        private Class<?> extractRawTypeOf(Type type) {\n+            if (type instanceof Class) {\n+                return (Class<?>) type;\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) type).getRawType();\n+            }\n+            if (type instanceof BoundedType) {\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\n+            }\n+            throw new MockitoException(\"Raw extraction not managed for : '\" + type + \"'\");\n+        }\n+\n+    }\n+    private static class NotGenericReturnType extends MockitoGenericMetadata {\n+        private final Class<?> returnType;\n+\n+        public NotGenericReturnType(Type genericReturnType) {\n+            returnType = (Class<?>) genericReturnType;\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return returnType;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsTest.java\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.junit.Test;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+\n+public class ReturnsDeepStubsTest {\n+\n+    interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {}\n+\n+\n+    @Test\n+    public void testName() throws Exception {\n+        MapWithNestedGenerics<?> mock = mock(MapWithNestedGenerics.class, RETURNS_DEEP_STUBS);\n+\n+        Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n+        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n+        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n+\n+        Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n+        Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n+\n+        Set<Number> value = mock.entrySet().iterator().next().getValue();\n+        Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n+        Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+    }\n+\n+\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.*;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.internal.util.reflection.MockitoGenericMetadata.from;\n+\n+public class MockitoGenericMetadataTest {\n+\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Integer> returningWildcard();\n+        K returningK();\n+        <O extends K> O paramTypeWithTypeParams();\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_from_Class() throws Exception {\n+        assertThat(from(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n+        assertThat(from(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n+        assertThat(from(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+    }\n+\n+\n+    @Test\n+    public void can_get_raw_type_from_ParameterizedType() throws Exception {\n+        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(from(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+    }\n+\n+    @Test\n+    @Ignore(\"not the right unit test\")\n+    public void returning_deep_stubs() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n+        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n+        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n+\n+        Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n+        Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n+\n+        Set<Number> value = mock.entrySet().iterator().next().getValue();\n+        Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n+        Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_Class() throws Exception {\n+        assertThat(from(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"K\");\n+        assertThat(from(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(from(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n+        assertThat(from(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(from(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_ParameterizedType() throws Exception {\n+        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n+        assertThat(from(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n+        assertThat(from(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of___get___resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of___returningK___resolved_to_Comparable_and_with_BoundedType() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        BoundedType boundedType = (BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"T\");\n+        assertThat(boundedType.firstBound()); // use MockitoGenericMetadata ?\n+        fail(\"API design to do\");\n+    }\n+\n+    @Test\n+    public void fixed_ParamType_return_type_of___remove___resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_return_type_of___values___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);\n+        MockitoGenericMetadata fromTypeVariableE = from(typeVariableValue(genericMetadata.actualTypeArguments(), \"E\"));\n+        assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);\n+        assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_return_type_of___returningWildcard___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningWildcard\", GenericsNest.class));\n+\n+        fail(\"TODO\");\n+    }\n+\n+    @Test\n+    public void paramType_return_type_of___paramTypeWithTypeParams___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramTypeWithTypeParams\", GenericsNest.class));\n+\n+        fail(\"TODO\");\n+    }\n+\n+\n+    @Test\n+    public void class_return_type_of___append___resolved_to_StringBuilder_and_type_arguments() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n+        assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n+    }\n+\n+\n+    private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {\n+        for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {\n+            if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {\n+                return typeVariableTypeEntry.getValue();\n+            }\n+        }\n+\n+        fail(\"'\" + typeVariableName + \"' was not found in \" + typeVariables);\n+        return null; // unreachable\n+    }\n+\n+    private Method firstNamedMethod(String methodName, Class<?> clazz) {\n+        for (Method method : clazz.getMethods()) {\n+            if (method.getName().contains(methodName)) {\n+                return method;\n+            }\n+        }\n+        throw new IllegalStateException(\"The method : '\" + methodName + \"' do not exist in '\" + clazz.getSimpleName() + \"'\");\n+    }\n+\n+\n+}", "timestamp": 1343125602, "metainfo": ""}