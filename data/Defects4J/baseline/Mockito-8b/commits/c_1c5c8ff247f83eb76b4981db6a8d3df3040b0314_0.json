{"sha": "1c5c8ff247f83eb76b4981db6a8d3df3040b0314", "log": "Location's stack trace ele ment is now always created from filtered stack trace. Since Location only stores last stack trace element then if it is not filtered it does not have any value.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401340", "commit": "\n--- a/src/org/mockito/exceptions/base/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/base/MockitoAssertionError.java\n         unfilteredStackTrace = getStackTrace();\n         \n         StackTraceFilter filter = new StackTraceFilter();\n-        filter.filterStackTrace(this);\n+        filter.filterConditionally(this);\n     }\n \n     public StackTraceElement[] getUnfilteredStackTrace() {\n--- a/src/org/mockito/exceptions/base/MockitoException.java\n+++ b/src/org/mockito/exceptions/base/MockitoException.java\n         unfilteredStackTrace = getStackTrace();\n         \n         StackTraceFilter filter = new StackTraceFilter();\n-        filter.filterStackTrace(this);\n+        filter.filterConditionally(this);\n     }\n \n     public StackTraceElement[] getUnfilteredStackTrace() {\n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n         return fromMockObject || fromOrgMockito && !isRunner;\n     }\n \n-    public void filterStackTrace(Throwable throwable) {\n-        StackTraceElement[] filtered = filterStackTrace(throwable.getStackTrace());\n+    public void filterConditionally(Throwable throwable) {\n+        if (!config.cleansStackTrace()) {\n+            return;\n+        }\n+        StackTraceElement[] filtered = filter(throwable.getStackTrace());\n         throwable.setStackTrace(filtered);\n     }\n \n-    public StackTraceElement[] filterStackTrace(StackTraceElement[] target) {\n-        if (!config.cleansStackTrace()) {\n-            return target;\n-        }\n-            \n+    public StackTraceElement[] filter(StackTraceElement[] target) {\n         List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n         \n         int lastToRemove = -1;\n--- a/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n         \n         unfilteredStackTrace = getStackTrace();\n         StackTraceFilter filter = new StackTraceFilter();\n-        filter.filterStackTrace(this);\n+        filter.filterConditionally(this);\n     }\n     \n     @Override\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n \n     public Location() {\n         StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n-        //TODO location should have always clean stack traces\n         StackTraceFilter filter = new StackTraceFilter();\n-        this.firstTraceElement = filter.filterStackTrace(stackTrace)[0];\n+        this.firstTraceElement = filter.filter(stackTrace)[0];\n     }\n \n     @Override\n--- a/src/org/mockito/internal/stubbing/ThrowsException.java\n+++ b/src/org/mockito/internal/stubbing/ThrowsException.java\n             throw throwable;\n         }\n         Throwable t = throwable.fillInStackTrace();\n-        filter.filterStackTrace(t);\n+        filter.filterConditionally(t);\n         throw t;\n     }\n \n--- a/test/org/concurrentmockito/ThreadVerifiesContinuoslyInteractingMockTest.java\n+++ b/test/org/concurrentmockito/ThreadVerifiesContinuoslyInteractingMockTest.java\n     @Mock private IMethods mock;\n \n     @Test\n-    public void testShouldAllowVerifyingInThreads() throws Exception {\n+    public void shouldAllowVerifyingInThreads() throws Exception {\n         for(int i = 0; i < 100; i++) {\n             performTest();\n         }\n--- a/test/org/concurrentmockito/ThreadsShareAMockTest.java\n+++ b/test/org/concurrentmockito/ThreadsShareAMockTest.java\n     private IMethods mock;\n \n     @Test\n-    public void testShouldAllowVerifyingInThreads() throws Exception {\n+    public void shouldAllowVerifyingInThreads() throws Exception {\n         for(int i = 0; i < 100; i++) {\n             performTest();\n         }\n--- a/test/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java\n+++ b/test/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java\n     private IMethods mock;\n \n     @Test\n-    public void testShouldAllowVerifyingInThreads() throws Exception {\n+    public void shouldAllowVerifyingInThreads() throws Exception {\n         for(int i = 0; i < 50; i++) {\n             performTest();\n         }\n--- a/test/org/concurrentmockito/ThreadsStubSharedMockTest.java\n+++ b/test/org/concurrentmockito/ThreadsStubSharedMockTest.java\n \n     @Ignore(\"stubbing from multiple threads is not supported\")\n     @Test\n-    public void testShouldStubFineConcurrently() throws Exception {\n+    public void shouldStubFineConcurrently() throws Exception {\n         for(int i = 0; i < 100; i++) {\n             performTest();\n         }\n--- a/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n     private StackTraceFilter filter = new StackTraceFilter();\n     \n     @Test\n-    public void testShouldFilterOutCglibGarbage() {\n-        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n-        \n-        Throwable t = new TraceBuilder().classes(\n+    public void shouldFilterOutCglibGarbage() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n             \"MockitoExampleTest\",\n             \"List$$EnhancerByMockitoWithCGLIB$$2c406024\", \n             \"MethodInterceptorFilter\"\n-        ).toThrowable();\n+        ).toTraceArray();\n         \n-        filter.filterStackTrace(t);\n+        StackTraceElement[] filtered = filter.filter(t);\n         \n-        assertThat(t, hasOnlyThoseClassesInStackTrace(\"MockitoExampleTest\"));\n+        assertThat(filtered, hasOnlyThoseClasses(\"MockitoExampleTest\"));\n     }\n     \n     @Test\n-    public void testShouldFilterOutMockitoPackage() {\n-        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n-        \n-        Throwable t = new TraceBuilder().classes(\n+    public void shouldFilterOutMockitoPackage() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n             \"org.test.MockitoSampleTest\",\n             \"org.test.TestSupport\",\n             \"org.mockito.Mockito\", \n             \"org.test.TestSupport\",\n             \"org.mockito.Mockito\"\n-        ).toThrowable();\n+        ).toTraceArray();\n             \n-        filter.filterStackTrace(t);\n+        StackTraceElement[] filtered = filter.filter(t);\n         \n-        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n     }\n     \n     @Test\n-    public void testShouldIgnoreRunners() {\n-        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n-        \n-        Throwable t = new TraceBuilder().classes(\n+    public void shouldIgnoreRunners() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n                 \"org.mockito.runners.Runner\",\n                 \"junit.stuff\",\n                 \"org.test.MockitoSampleTest\",\n                 \"org.mockito.Mockito\"\n-        ).toThrowable();\n+        ).toTraceArray();\n         \n-        filter.filterStackTrace(t);\n+        StackTraceElement[] filtered = filter.filter(t);\n         \n-        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.test.MockitoSampleTest\", \"junit.stuff\", \"org.mockito.runners.Runner\"));\n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"junit.stuff\", \"org.mockito.runners.Runner\"));\n     }\n     \n+    //TODO remove this test when next TODO is finished\n     @Test\n-    public void testShouldNotFilterWhenConfigurationSaysNo() {\n+    public void shouldFilterEvenIfConfigurationSaysNo() {\n         ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n         \n         Throwable t = new TraceBuilder().classes(\n             \"org.mockito.Mockito\" \n         ).toThrowable();\n             \n-        filter.filterStackTrace(t);\n+        StackTraceElement[] filtered = filter.filter(t.getStackTrace());\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\"));\n+    }\n+    \n+    //TODO move to different class\n+    @Test\n+    public void shouldNotFilterConditionally() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n+        \n+        Throwable t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\" \n+        ).toThrowable();\n+        \n+        filter.filterConditionally(t);\n         \n         assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.mockito.Mockito\", \"org.test.MockitoSampleTest\"));\n     }\n--- a/test/org/mockito/exceptions/base/TraceBuilder.java\n+++ b/test/org/mockito/exceptions/base/TraceBuilder.java\n     private String[] classes = {};\n \n     public Throwable toThrowable() {\n-        List<StackTraceElement> trace = toTraceList();\n         RuntimeException exception = new RuntimeException();\n-        exception.setStackTrace(trace.toArray(new StackTraceElement[0]));\n+        exception.setStackTrace(toTraceArray());\n         return exception;\n     }\n \n-    public List<StackTraceElement> toTraceList() {\n+    private List<StackTraceElement> toTraceList() {\n         assert methods.length == 0 || classes.length == 0;\n         \n         List<StackTraceElement> trace = new LinkedList<StackTraceElement>();\n         Collections.reverse(trace);\n         return trace;\n     }\n+    \n+    public StackTraceElement[] toTraceArray() {\n+        return toTraceList().toArray(new StackTraceElement[0]);\n+    }\n \n     public TraceBuilder classes(String ... classes) {\n         this.classes = classes;\n--- a/test/org/mockitousage/ReplacingObjectMethodsTest.java\n+++ b/test/org/mockitousage/ReplacingObjectMethodsTest.java\n     }\n     \n     @Test \n-    public void testShouldReplaceObjectMethods() {\n+    public void shouldReplaceObjectMethods() {\n         Object mock = Mockito.mock(ObjectMethodsOverridden.class);\n         Object otherMock = Mockito.mock(ObjectMethodsOverridden.class);\n         \n     }\n     \n     @Test \n-    public void testShouldReplaceObjectMethodsWhenOverridden() {\n+    public void shouldReplaceObjectMethodsWhenOverridden() {\n         Object mock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n         Object otherMock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n         \n--- a/test/org/mockitoutil/ExtraMatchers.java\n+++ b/test/org/mockitoutil/ExtraMatchers.java\n                     \n                 for (int i = 0; i < trace.length; i++) {\n                     assertEquals(classes[i], trace[i].getClassName());\n+                }\n+            }\n+        };\n+    }\n+    \n+    public static <T> Assertor<StackTraceElement[]> hasOnlyThoseClasses(final String ... classes) {\n+        return new Assertor<StackTraceElement[]>() {\n+            public void assertValue(StackTraceElement[] traceElements) {\n+                assertEquals(\"Number of classes does not match.\" +\n+                        \"\\nExpected: \" + Arrays.toString(classes) + \n+                        \"\\nGot: \" + Arrays.toString(traceElements),\n+                        classes.length, traceElements.length);\n+                \n+                for (int i = 0; i < traceElements.length; i++) {\n+                    assertEquals(classes[i], traceElements[i].getClassName());\n                 }\n             }\n         };\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n         ConfigurationAccess.getConfig().overrideReturnValues(null);\n     }\n \n-    //TODO find out why performance dropped from 4.2 -> 4.3\n     @Before\n     public void init() {\n         new StateMaster().validate();\n     }\n     \n     public void makeStackTracesClean() {\n+        //TODO in some tests this is not necessary do to latest changes\n         ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n     }\n     ", "timestamp": 1240161208, "metainfo": ""}