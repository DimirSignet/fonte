{"sha": "1bd90b762d1d70fdd955795e87c07a95b8aaa165", "log": "Added atLeast(int) functionality.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40830", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * //verification using atLeastOnce()\n  * verify(mockedList, atLeastOnce()).add(\"three times\");\n  * \n+ * //verification using atLeast()\n+ * verify(mockedList, atLeast(2)).add(\"twice\");\n+ * verify(mockedList, atLeast(2)).add(\"three times\");\n+ * \n  * </pre>\n  * \n  * <p>\n     }\n \n     /**\n+     * Allows at-least-x verification. E.g:\n+     * <pre>\n+     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param minNumberOfInvocations minimum number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode atLeast(int minNumberOfInvocations) {\n+        return VerificationModeImpl.atLeast(minNumberOfInvocations);\n+    }\n+    \n+    /**\n      * Allows verifying exact number of invocations. E.g:\n      * <pre>\n      *   verify(mock, times(2)).someMethod(\"some arg\");\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockito.exceptions.verification.junit.JUnitTool;\n+import org.mockito.internal.invocation.InvocationMatcher;\n \n /**\n  * Reports verification and misusing errors.\n                 \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n              ));\n     }\n+\n+    public void tooLittleActualInvocationsInAtLeastMode(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace lastActualInvocationStackTrace) {        \n+        TooLittleInvocations cause = createTooLittleInvocationsCause(lastActualInvocationStackTrace);\n+\n+        throw new TooLittleActualInvocations(join(\n+            wanted.toString(),\n+            \"Wanted at least \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n         List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n         \n-        if (mode.atLeastOnceMode() || !mode.matchesActualCount(firstChunk.size())) {\n+        if (mode.atLeastMode() || !mode.matchesActualCount(firstChunk.size())) {\n             return this.findAllMatchingUnverifiedChunks(invocations, wanted);\n         } else {\n             return firstChunk;\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n     enum Verification { EXPLICIT, NO_MORE_WANTED };\n     \n     private final Integer wantedInvocationCount;\n+    private final Integer minInvocationCount;\n     private final List<? extends Object> mocksToBeVerifiedInOrder;\n     private final Verification verification;\n     \n-    private VerificationModeImpl(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder, Verification verification) {\n-        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n-            throw new MockitoException(\"Negative value is not allowed here\");\n+    private VerificationModeImpl(Integer wantedNumberOfInvocations, Integer minNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder, Verification verification) {\n+        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations < 0) {\n+            throw new MockitoException(\"Negative value is not allowed for wantedNumberOfInvocations\");\n+        }\n+        if (minNumberOfInvocations != null && minNumberOfInvocations < 1) {\n+            throw new MockitoException(\"Negative value and zero are not allowed for minNumberOfInvocations\");\n         }\n         assert mocksToBeVerifiedInOrder != null;\n         this.wantedInvocationCount = wantedNumberOfInvocations;\n+        this.minInvocationCount = minNumberOfInvocations;\n         this.mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder;\n         this.verification = verification;\n     }\n     \n     public static VerificationModeImpl atLeastOnce() {\n-        return new VerificationModeImpl(null, Collections.emptyList(), Verification.EXPLICIT);\n+        return atLeast(1);\n+    }\n+\n+    public static VerificationModeImpl atLeast(int minNumberOfInvocations) {\n+        return new VerificationModeImpl(null, minNumberOfInvocations, Collections.emptyList(), Verification.EXPLICIT);\n     }\n \n     public static VerificationModeImpl times(int wantedNumberOfInvocations) {\n-        return new VerificationModeImpl(wantedNumberOfInvocations, Collections.emptyList(), Verification.EXPLICIT);\n+        return new VerificationModeImpl(wantedNumberOfInvocations, null, Collections.emptyList(), Verification.EXPLICIT);\n     }\n \n     public static VerificationModeImpl inOrder(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder) {\n         assert !mocksToBeVerifiedInOrder.isEmpty();\n-        return new VerificationModeImpl(wantedNumberOfInvocations, mocksToBeVerifiedInOrder, Verification.EXPLICIT);\n+        return new VerificationModeImpl(wantedNumberOfInvocations, null, mocksToBeVerifiedInOrder, Verification.EXPLICIT);\n     }\n     \n     public static VerificationModeImpl noMoreInteractions() {\n-        return new VerificationModeImpl(null, Collections.emptyList(), Verification.NO_MORE_WANTED);\n+        return new VerificationModeImpl(null, null, Collections.emptyList(), Verification.NO_MORE_WANTED);\n     }\n \n     public Integer wantedCount() {\n         return wantedInvocationCount;\n     }\n \n+    public Integer minimumCount() {\n+        return minInvocationCount;\n+    }\n+\n     public List<? extends Object> getMocksToBeVerifiedInOrder() {\n         return mocksToBeVerifiedInOrder;\n     }\n \n-    public boolean atLeastOnceMode() {\n-        return wantedInvocationCount == null && verification == Verification.EXPLICIT;\n+    public boolean atLeastMode() {\n+        return wantedInvocationCount == null && explicitMode();\n     }\n \n     public boolean explicitMode() {\n     }\n     \n     public boolean missingMethodMode() {\n-        return explicitMode() && (atLeastOnceMode() || wantedInvocationCount > 0);\n+        return explicitMode() && (atLeastMode() || wantedInvocationCount > 0);\n     }\n     \n     public boolean missingMethodInOrderMode() {\n     }\n \n     public boolean matchesActualCount(int actualCount) {\n-        boolean atLeastOnce = atLeastOnceMode() && actualCount > 0;\n-        boolean actualMatchesWanted = !atLeastOnceMode() && wantedInvocationCount == actualCount;\n+        boolean atLeast = atLeastMode() && actualCount >= minInvocationCount;\n+        boolean actualMatchesWanted = !atLeastMode() && wantedInvocationCount == actualCount;\n         \n-        return atLeastOnce || actualMatchesWanted;\n+        return atLeast || actualMatchesWanted;\n     }\n     \n     public boolean tooLittleActualInvocations(int actualCount) {\n-        return !atLeastOnceMode() && wantedInvocationCount > actualCount;\n+        return !atLeastMode() && wantedInvocationCount > actualCount; \n+    }\n+\n+    public boolean tooLittleActualInvocationsInAtLeastMode(int actualCount) {\n+        return atLeastMode() && minInvocationCount > actualCount;\n     }\n     \n     public boolean tooManyActualInvocations(int actualCount) {\n-        return !atLeastOnceMode() && wantedInvocationCount < actualCount;\n+        return !atLeastMode() && wantedInvocationCount < actualCount;\n     }\n     \n     public boolean neverWanted() {\n-        return !atLeastOnceMode() && wantedInvocationCount == 0;\n+        return !atLeastMode() && wantedInvocationCount == 0;\n     }\n     \n     public boolean neverWantedButInvoked(int actualCount) {\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         if (mode.tooLittleActualInvocations(actualCount)) {\n             HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n             reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (mode.tooLittleActualInvocationsInAtLeastMode(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n+            reporter.tooLittleActualInvocationsInAtLeastMode(mode.minimumCount(), actualCount, wanted, lastInvocation);        \n         } else if (mode.neverWantedButInvoked(actualCount)) {\n             HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n             reporter.neverWantedButInvoked(wanted, firstUndesired); \n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n     @Test\n     public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n         VerificationModeImpl mode = atLeastOnce();\n-        assertTrue(mode.atLeastOnceMode());\n+        assertTrue(mode.atLeastMode());\n         \n         mode = times(50);\n-        assertFalse(mode.atLeastOnceMode());\n+        assertFalse(mode.atLeastMode());\n     }\n     \n     @Test\n             times(-50);\n             fail();\n         } catch (MockitoException e) {\n-            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+            assertEquals(\"Negative value is not allowed for wantedNumberOfInvocations\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfMinimumInvocations() throws Exception {\n+        try {\n+            atLeast(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value and zero are not allowed for minNumberOfInvocations\", e.getMessage());\n         }\n     }\n     \n     }\n     \n     @Test\n-    public void shouldKnowIfIsAtLeastOnceMode() throws Exception {\n-        assertTrue(atLeastOnce().atLeastOnceMode());\n+    public void shouldKnowIfIsAtLeastMode() throws Exception {\n+        assertTrue(atLeastOnce().atLeastMode());\n+        assertTrue(atLeast(10).atLeastMode());\n         \n-        assertFalse(times(0).atLeastOnceMode());\n-        assertFalse(times(2).atLeastOnceMode());\n-        assertFalse(noMoreInteractions().atLeastOnceMode());\n+        assertFalse(times(0).atLeastMode());\n+        assertFalse(times(2).atLeastMode());\n+        assertFalse(noMoreInteractions().atLeastMode());\n     }\n     \n     @Test\n         assertTrue(atLeastOnce().matchesActualCount(1));\n         assertTrue(atLeastOnce().matchesActualCount(100));\n     }\n+\n+    @Test\n+    public void shouldKnowIfMatchesActualInvocationCountWhenAtLeastMode() throws Exception {\n+        assertFalse(atLeast(10).matchesActualCount(5));\n+        assertFalse(atLeast(2).matchesActualCount(1));\n+        \n+        assertTrue(atLeast(10).matchesActualCount(10));\n+        assertTrue(atLeast(10).matchesActualCount(15));\n+    }\n     \n     @Test\n     public void shouldKnowIfTooLittleActualInvocations() throws Exception {\n         assertFalse(times(0).tooLittleActualInvocations(0));\n         assertFalse(times(1).tooLittleActualInvocations(1));\n         assertFalse(times(1).tooLittleActualInvocations(2));\n+    }\n+    \n+    @Test\n+    public void tooLittleActualInvocationsShouldNotApplyToAtLeastMode() throws Exception {\n+        assertFalse(atLeast(10).tooLittleActualInvocations(5));        \n+        assertFalse(atLeast(10).tooLittleActualInvocations(15));        \n+        assertFalse(atLeastOnce().tooLittleActualInvocations(10));        \n+    }\n+\n+    @Test\n+    public void shouldKnowIfTooLittleActualInvocationsInAtLeastMode() throws Exception {\n+        assertTrue(atLeast(3).tooLittleActualInvocationsInAtLeastMode(2));\n+        assertTrue(atLeast(3).tooLittleActualInvocationsInAtLeastMode(1));\n+        assertTrue(atLeast(3).tooLittleActualInvocationsInAtLeastMode(0));\n+        \n+        assertFalse(atLeast(1).tooLittleActualInvocationsInAtLeastMode(1));\n+        assertFalse(atLeast(1).tooLittleActualInvocationsInAtLeastMode(2));\n+    }\n+\n+    @Test\n+    public void tooLittleActualInvocationsInAtLeastModeShouldNotApplyToOtherModes() throws Exception {\n+        assertFalse(times(10).tooLittleActualInvocationsInAtLeastMode(5));        \n+        assertFalse(times(10).tooLittleActualInvocationsInAtLeastMode(15));        \n     }\n     \n     @Test\n--- a/test/org/mockitousage/verification/AtLeastXVerificationTest.java\n+++ b/test/org/mockitousage/verification/AtLeastXVerificationTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitoutil.TestBase;\n \n     }\n     \n     @Test\n-    public void shouldVerifyAtLeast3Times() throws Exception {\n+    public void shouldVerifyAtLeastXTimes() throws Exception {\n         mock.add(\"foo\");\n         mock.add(\"foo\");\n         mock.add(\"foo\");\n-        \n-//TODO        \n-//      verify(mock, atLeast(2)).add(\"foo\");\n+\n+        verify(mock, atLeast(1)).add(\"foo\");\n+        verify(mock, atLeast(2)).add(\"foo\");\n+        verify(mock, atLeast(3)).add(\"foo\");\n     }\n+    \n+    @Test(expected=TooLittleActualInvocations.class)\n+    public void shouldFailOnVerifyAtLeast10WhenMethodWasInvokedOnce() throws Exception {\n+        mock.add(\"foo\");\n+\n+        verify(mock, atLeast(10)).add(\"foo\");\n+    }    \n }", "timestamp": 1219857816, "metainfo": ""}