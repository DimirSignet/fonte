{"sha": "1caa476f709ccf50a36509282fd4b3f8da10177b", "log": "Reworked MockSettingImpl, changed callback(InvocationListener) to invocationListeners(InvocationListeners), removed the dupe type check there, users might want to order them as they wish  --HG-- branch : issue148", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n  */\n package org.mockito;\n \n-import java.io.Serializable;\n-\n import org.mockito.invocation.InvocationListener;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n \n /**\n  * Allows mock creation with additional mock settings. \n      * \n      * Example:\n      * <pre>\n-     *  List mockWithListener = mock(List.class, withSettings().callback(new YourInvocationListener()));\n+     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n      * </pre>\n      * \n-     * See the {@link InvocationListener listeners interface} for more details.\n+     * See the {@link InvocationListener listener interface} for more details.\n      * \n-     * @param listener The invocation listener to add as callback. May not be null.\n+     * @param listeners The invocation listeners to add. May not be null.\n      * @return settings instance so that you can fluently specify other settings\n      */\n-    MockSettings callback(InvocationListener listener);\n-}\n+    MockSettings invocationListeners(InvocationListener... listeners);\n+}\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n-import org.mockito.invocation.InvocationListener;\n \n import java.lang.reflect.Field;\n import java.util.List;\n                 \"\"), details);\n \n     }\n+\n+    public void invocationListenerDoesNotAcceptNullParameters() {\n+        throw new MockitoException(join(\n+                \"invocationListeners() does not accept null parameters\"\n+        ));\n+    }\n+\n+    public void invocationListenersRequiresAtLeastOneListener() {\n+        throw new MockitoException(join(\n+                \"invocationListeners() requires at least one listener\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal;\n-\n-import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.InvocationContainer;\n-import org.mockito.internal.stubbing.InvocationContainerImpl;\n-import org.mockito.internal.stubbing.OngoingStubbingImpl;\n-import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n+import org.mockito.internal.stubbing.*;\n import org.mockito.internal.util.StringJoiner;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n \n /**\n  * Invocation handler set on mock objects.\n     }\n     \n \tprivate void notifyAllListenerOfInvocationWithReturnValue(Invocation invocation, Object returnValue) {\n-\t\tfor (InvocationListener listener : mockSettings.getInvocationListener()) {\n+\t\tfor (InvocationListener listener : mockSettings.getInvocationListeners()) {\n \t\t\tnotifyListenerOfInvocationWithReturnValue(invocation, returnValue, listener);\n     \t} \n \t}\n \n \tprivate void notifyAllListenerOfInvocationWithException(Invocation invocation, Exception exception) {\n-\t\tfor (InvocationListener listener : mockSettings.getInvocationListener()) {\n+\t\tfor (InvocationListener listener : mockSettings.getInvocationListeners()) {\n \t\t\tnotifyListenerOfInvocationWithException(invocation, exception, listener);\n \t\t} \n \t}\n \tprivate String getStubbingLocationOrNull(Invocation invocation) {\n \t\treturn (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt();\n \t}\n-}\n+}\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.creation;\n-\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n \n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.util.MockName;\n import org.mockito.invocation.InvocationListener;\n import org.mockito.stubbing.Answer;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class MockSettingsImpl implements MockSettings {\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n     private boolean serializable;\n-    private Set<InvocationListener> invocationListener = new HashSet<InvocationListener>();\n+    private List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public MockSettings serializable() {\n         this.serializable = true;\n     }\n \n \tpublic MockSettings verboseLogging() {\n-\t\tif (doesNotHaveListenerOfClass(LogInvocationsToStdOutListener.class)) {\n-\t\t\tcallback(new LogInvocationsToStdOutListener());\n-\t\t}\n+        if (!invocationListenersContainsType(LogInvocationsToStdOutListener.class)) {\n+            invocationListeners(new LogInvocationsToStdOutListener());\n+        }\n+        return this;\n+\t}\n+\n+    public MockSettings invocationListeners(InvocationListener... listeners) {\n+        if (listeners == null || listeners.length == 0) {\n+            new Reporter().invocationListenersRequiresAtLeastOneListener();\n+        }\n+        for (InvocationListener listener : listeners) {\n+            if (listener == null) {\n+                new Reporter().invocationListenerDoesNotAcceptNullParameters();\n+            }\n+            this.invocationListeners.add(listener);\n+        }\n \t\treturn this;\n \t}\n \n-\tpublic MockSettings callback(InvocationListener listener) {\n-\t\tvalidateListener(listener);\n-\t\tthis.invocationListener.add(listener);\n-\t\treturn this;\n+\tprivate boolean invocationListenersContainsType(Class<?> clazz) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+\t\t\tif (listener.getClass().equals(clazz)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n \t}\n \n-\t/** Returns the registered invocation listener, never {@code null} */\n-\tpublic Collection<InvocationListener> getInvocationListener() {\n-\t\treturn this.invocationListener;\n-\t}\n-\t\n-\tprivate boolean doesNotHaveListenerOfClass(Class<?> clazz) {\n-\t\tfor (InvocationListener listener : invocationListener) {\n-\t\t\tif (listener.getClass().equals(clazz)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n-\t\n-\tprivate void validateListener(InvocationListener listener) {\n-\t\tif (listener == null) {\n-\t\t\tnew Reporter().nullInvocationListenerAdded();\n-\t\t}\n-\t}\n+    public List<InvocationListener> getInvocationListeners() {\n+        return this.invocationListeners;\n+    }\n+\n+    public boolean containsInvocationListener(InvocationListener invocationListener) {\n+        return invocationListeners.contains(invocationListener);\n+    }\n+\n+    public boolean hasInvocationListeners() {\n+        return !invocationListeners.isEmpty();\n+    }\n }\n \n--- a/src/org/mockito/invocation/InvocationListener.java\n+++ b/src/org/mockito/invocation/InvocationListener.java\n \t/**\n \t * Called when a method on the listener's mock was invoked and returned normally.\n \t * \n-\t * Exceptions during this callback are treated as fatal errors. \n+\t * Exceptions during this invocationListeners are treated as fatal errors.\n \t * \n \t * @param invocation information on the happening method call, never {@code null}\n \t * @param returnValue whatever it was that the method returned, may be {@code null}\n \t * Note that the exception is not necessarily caused by stubbing the method with it, but may also\n \t * be the result of incorrect usage of the mockito API or even a bug inside mockito.\n \t * \n-\t * Exceptions during this callback are treated as fatal errors. \n+\t * Exceptions during this invocationListeners are treated as fatal errors.\n \t * \n \t * @param invocation information on the happening method call, never {@code null}\n \t * @param exception the exception that was thrown\n--- a/test/org/mockito/exceptions/ReporterTest.java\n+++ b/test/org/mockito/exceptions/ReporterTest.java\n     \n     @Test(expected=MockitoException.class)\n     public void shouldThrowCorrectExceptionForNullInvocationListener() throws Exception {\n-    \tnew Reporter().nullInvocationListenerAdded();\n+    \tnew Reporter().invocationListenerDoesNotAcceptNullParameters();\n     }\n-}\n+}\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n  */\n package org.mockito.internal;\n \n-import static org.mockito.BDDMockito.given;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Mockito.doThrow;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyZeroInteractions;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.invocation.StubInfo;\n+import org.mockito.internal.invocation.*;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.verification.VerificationMode;\n import org.mockitoutil.TestBase;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.*;\n+\n @SuppressWarnings({ \"unchecked\", \"serial\" })\n public class MockHandlerTest extends TestBase {\n \n \n \t@SuppressWarnings(\"rawtypes\")\n \tprivate void stubWithPreviouslySetVoidAnswer(MockHandler handler) {\n-\t\tList<Answer<?>> answers = new ArrayList<Answer<?>>();\n+\t\tList<Answer> answers = new ArrayList<Answer>();\n \t\tanswers.add(new DoesNothing());\n \t\thandler.setAnswersForStubbing(answers);\n \t}\n \t\t@SuppressWarnings(\"rawtypes\")\n \t\tMockHandler<?> handler = new MockHandler(mock(MockSettingsImpl.class));\n \t\thandler.matchersBinder = mock(MatchersBinder.class);\n-\t\tgiven(handler.getMockSettings().getInvocationListener()).willReturn(Arrays.asList(listener));\n+\t\tgiven(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));\n \t\treturn handler;\n \t}\n-}\n+}\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n  */\n package org.mockito.internal.creation;\n \n-import static org.mockito.Mockito.mock;\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.debugging.LogInvocationsToStdOutListener;\n+import org.mockito.invocation.InvocationListener;\n+import org.mockitoutil.TestBase;\n \n import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n \n-import org.junit.Test;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.debugging.LogInvocationsToStdOutListener;\n-import org.mockito.invocation.InvocationListener;\n-import org.mockitoutil.TestBase;\n-\n public class MockSettingsImplTest extends TestBase {\n \n     private MockSettingsImpl mockSettingsImpl = new MockSettingsImpl();\n     \n-    private static final InvocationListener SOME_LISTENER = mock(InvocationListener.class);\n+    @Mock private InvocationListener invocationListener;\n \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullInterface() {\n         //then\n         assertTrue(mockSettingsImpl.isSerializable());\n     }\n-    \n+\n+    /////////////////////////////////////////////////////////////////////////\n+    /////////////////////////////////////////////////////////////////////////\n+    /////////////////////////////////////////////////////////////////////////\n+    // issue 148\n+\n+\n     @Test\n     public void shouldAddVerboseLoggingListener() {\n         //given\n-        assertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+        assertFalse(mockSettingsImpl.hasInvocationListeners());\n \n         //when\n         mockSettingsImpl.verboseLogging();\n \n         //then\n-        assertEquals(1, mockSettingsImpl.getInvocationListener().size());\n-        assertTrue(getListener(mockSettingsImpl) instanceof LogInvocationsToStdOutListener);\n+        assertContainsType(mockSettingsImpl.getInvocationListeners(), LogInvocationsToStdOutListener.class);\n     }\n \n     @Test\n     public void shouldAddVerboseLoggingListenerOnlyOnce() {\n     \t//given\n-    \tassertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+    \tassertFalse(mockSettingsImpl.hasInvocationListeners());\n     \t\n     \t//when\n     \tmockSettingsImpl.verboseLogging().verboseLogging();\n     \t\n     \t//then\n-    \tassertEquals(1, mockSettingsImpl.getInvocationListener().size());\n+    \tAssertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowNullListener() {\n-    \tmockSettingsImpl.callback(null);\n+    \tmockSettingsImpl.invocationListeners(null);\n     }\n \n     @Test\n     public void shouldAddInvocationListener() {\n     \t//given\n-    \tassertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+    \tassertFalse(mockSettingsImpl.hasInvocationListeners());\n     \t\n     \t//when\n-    \tmockSettingsImpl.callback(SOME_LISTENER);\n+    \tmockSettingsImpl.invocationListeners(invocationListener);\n     \t\n     \t//then\n-    \tassertEquals(1, mockSettingsImpl.getInvocationListener().size());\n-    \tassertSame(SOME_LISTENER, getListener(mockSettingsImpl));\n+        Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);\n     }\n     \n     @Test\n-    public void shouldAddInvocationListenerOnlyOnce() {\n+    public void canAddDuplicateInvocationListeners_ItsNotOurBusinessThere() {\n     \t//given\n-    \tassertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+    \tassertFalse(mockSettingsImpl.hasInvocationListeners());\n     \t\n     \t//when\n-    \tmockSettingsImpl.callback(SOME_LISTENER).callback(SOME_LISTENER);\n+    \tmockSettingsImpl.invocationListeners(invocationListener, invocationListener).invocationListeners(invocationListener);\n     \t\n     \t//then\n-    \tassertEquals(1, mockSettingsImpl.getInvocationListener().size());\n+    \tAssertions.assertThat(mockSettingsImpl.getInvocationListeners()).containsSequence(invocationListener, invocationListener, invocationListener);\n+    }\n+\n+    @Test\n+    public void shouldReportErrorWhenAddingNoInvocationListeners() throws Exception {\n+        try {\n+            mockSettingsImpl.invocationListeners();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"at least one listener\");\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReportErrorWhenAddingANullInvocationListener() throws Exception {\n+        try {\n+            mockSettingsImpl.invocationListeners(invocationListener, null);\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"does not accept null\");\n+        }\n+    }\n+\n+    private InvocationListener getListener(MockSettingsImpl settings) {\n+    \treturn settings.getInvocationListeners().iterator().next();\n     }\n     \n-    private InvocationListener getListener(MockSettingsImpl settings) {\n-    \treturn settings.getInvocationListener().iterator().next();\n-    }\n-    \n-}\n+}\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.debugging;\n-\n-import static org.mockito.BDDMockito.given;\n-import static org.mockito.Matchers.eq;\n-import static org.mockito.Matchers.isA;\n-import static org.mockito.Mockito.doThrow;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.withSettings;\n \n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.invocation.InvocationListener;\n import org.mockitousage.debugging.VerboseLoggingOfInvocationsOnMockTest.ThirdPartyException;\n import org.mockitoutil.TestBase;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.isA;\n+import static org.mockito.Mockito.*;\n \n /**\n  * Ensures that custom listeners can be registered and will be called every time\n \t\t// Cannot use a mockito-mock here: during stubbing, the listener will be called\n \t\t// and mockito will confuse the mocks.\n \t\tRememberingListener listener = new RememberingListener();\n-\t\tFoo foo = mock(Foo.class, withSettings().callback(listener));\n+\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener));\n \t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n \n \t\t// when\n \t\t// and mockito will confuse the mocks.\n \t\tRememberingListener listener1 = new RememberingListener();\n \t\tRememberingListener listener2 = new RememberingListener();\n-\t\tFoo foo = mock(Foo.class, withSettings().callback(listener1).callback(listener2));\n+\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1).invocationListeners(listener2));\n \t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n \n \t\t// when\n \t\t// given\n \t\tInvocationListener listener = mock(InvocationListener.class);\n \t\tRuntimeException expectedException = new ThirdPartyException();\n-\t\tFoo foo = mock(Foo.class, withSettings().callback(listener));\n+\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener));\n \t\tdoThrow(expectedException).when(foo).doSomething(SOME_STRING_ARGUMENT);\n \n \t\t// when\n \t\t// given\n \t\tInvocationListener listener1 = mock(InvocationListener.class);\n \t\tInvocationListener listener2 = mock(InvocationListener.class);\n-\t\tFoo foo = mock(Foo.class, withSettings().callback(listener1).callback(listener2));\n+\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1).invocationListeners(listener2));\n \t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(SOME_STRING_ARGUMENT);\n \n \t\t// when\n \t\t}\n \t\t\n \t}\n-}\n+}\n--- a/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n+++ b/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.debugging;\n-\n-import static org.mockito.BDDMockito.given;\n-import static org.mockito.Mockito.doCallRealMethod;\n-import static org.mockito.Mockito.doThrow;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.withSettings;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n \n import org.junit.After;\n import org.junit.Before;\n import org.mockito.Mock;\n import org.mockito.internal.util.MockUtil;\n import org.mockitoutil.TestBase;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.*;\n \n /**\n  * Tests the verbose logging of invocation on mock methods.\n \n \tprivate PrintStream original;\n \n-\t@Mock\n-\tUnrelatedClass unrelatedMock;\n+\t@Mock UnrelatedClass unrelatedMock;\n \t\n \t@Before\n \tpublic void setUp() {\n \t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-\t\tgiven(foo.giveMeSomeString(SOME_STRING_VALUE)).willReturn(\n-\t\t\t\tSOME_RETURN_VALUE);\n+\t\tgiven(foo.giveMeSomeString(SOME_STRING_VALUE)).willReturn(SOME_RETURN_VALUE);\n \n \t\t// when\n \t\tfoo.giveMeSomeString(SOME_STRING_VALUE);\n \t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(\n-\t\t\t\tSOME_STRING_VALUE);\n+\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(SOME_STRING_VALUE);\n \n \t\ttry {\n \t\t\t// when\n \t\tfoo.doSomething(SOME_STRING_VALUE);\n \t}\n \n-\tprivate void assertStreamContainsClassName(Class<?> clazz,\n-\t\t\tByteArrayOutputStream baos) {\n+\n+    private void assertStreamContainsClassName(Class<?> clazz,ByteArrayOutputStream baos) {\n \t\tassertContains(clazz.getName().toString(), baos.toString());\n \t}\n \n \t\treturn baos;\n \t}\n \n-\tprivate void assertStreamContainsMockName(Object mock,\n-\t\t\tByteArrayOutputStream baos) {\n-\t\tassertContains(new MockUtil().getMockName(mock).toString(),\n-\t\t\t\tbaos.toString());\n+\tprivate void assertStreamContainsMockName(Object mock, ByteArrayOutputStream baos) {\n+\t\tassertContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n \t}\n \n-\tprivate void assertStreamDoesNotContainMockName(Object mock,\n-\t\t\tByteArrayOutputStream baos) {\n-\t\tassertNotContains(new MockUtil().getMockName(mock).toString(),\n-\t\t\t\tbaos.toString());\n+\tprivate void assertStreamDoesNotContainMockName(Object mock, ByteArrayOutputStream baos) {\n+\t\tassertNotContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n \t}\n \n \tprivate static class UnrelatedClass {\n \t\t}\n \n \t}\n-}\n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n package org.mockitoutil;\n \n import junit.framework.Assert;\n+import org.fest.assertions.Assertions;\n+import org.fest.assertions.Condition;\n import org.hamcrest.Matcher;\n import org.hamcrest.SelfDescribing;\n import org.hamcrest.StringDescription;\n import org.mockito.internal.util.MockUtil;\n \n import java.io.*;\n+import java.util.Collection;\n \n import static org.mockito.Mockito.mock;\n \n \n     public static void assertContains(String sub, String string) {\n         assertTrue(\"\\n\" +\n-                \"This substing:[\" +\n+                \"This substring:[\" +\n                 sub +\n                 \"]\\n\" +\n                 \"should be inside of:[\" +\n \n     public static void assertContainsIgnoringCase(String sub, String string) {\n         assertTrue(\"\\n\" +\n-                \"This substing:\" +\n+                \"This substring:\" +\n                 sub +\n                 \"\\n\" +\n                 \"should be inside of:\" +\n \n     public static void assertNotContains(String sub, String string) {\n         assertFalse(\"\\n\" +\n-                \"This substing:\" +\n+                \"This substring:\" +\n                 sub +\n                 \"\\n\" +\n                 \"should NOT be inside of:\" +\n     protected boolean isMock(Object o) {\n         return new MockUtil().isMock(o);\n     }\n-}\n+\n+    protected void assertContainsType(final Collection<?> list, final Class<?> clazz) {\n+        Assertions.assertThat(list).satisfies(new Condition<Collection<?>>() {\n+            @Override\n+            public boolean matches(Collection<?> objects) {\n+                for (Object object : objects) {\n+                    if (clazz.isAssignableFrom(object.getClass())) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+        });\n+    }\n+}", "timestamp": 1304872438, "metainfo": ""}