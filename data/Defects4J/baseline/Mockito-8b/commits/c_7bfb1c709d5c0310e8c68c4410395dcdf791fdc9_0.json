{"sha": "7bfb1c709d5c0310e8c68c4410395dcdf791fdc9", "log": "refactored back to the mode, where strict verification was really strict...  --HG-- rename : test/org/mockitousage/PointingStackTraceToActualChunkTest.java => test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40235", "commit": "\n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n  * See examples {@link Mockito#createStrictOrderVerifier(Object...)}\n  */\n public interface Strictly {\n-\n     /**\n      * Verifies mock object strictly in order. E.g:\n      * \n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n /**\n \n     }\n \n+    //TODO refactor to wanted but not invoked with wanted and actual\n     public void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n         WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n                 \"Actual invocation:\",\n                 wanted\n             ), cause);\n     }\n+    \n+    public void strictVerificationFailed(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+        WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n+                \"Actual invocation:\",\n+                actual\n+            ));\n+\n+        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+\n+        throw new StrictVerificationFailure(join(\n+                \"Strict verification failure\",\n+                \"Wanted invocation:\",\n+                wanted\n+            ), cause);\n+    }\n \n     public void wantedButNotInvoked(String wanted) {\n         throw new WantedButNotInvoked(join(\n                     wanted\n         ));\n     }\n+    \n+    public void strictlyWantedButNotInvoked(String wanted) {\n+        throw new StrictVerificationFailure(join(\n+                    \"Strict verification failure\",\n+                    \"Wanted but not invoked:\",\n+                    wanted\n+        ));\n+    }\n \n     public void tooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n         UndesiredInvocation cause = new UndesiredInvocation(join(\"Undesired invocation:\"));\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n     }\n+    \n+    //TODO duplicated\n+    public void strictlyTooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n+        UndesiredInvocation cause = new UndesiredInvocation(join(\"Undesired invocation:\"));\n+        cause.setStackTrace(firstUndesired.getStackTrace());\n+\n+        throw new StrictVerificationFailure(join(\n+                \"Strict verification failure\",\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);\n+    }    \n \n     public void tooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n         TooLittleInvocations cause = null;\n         }\n \n         throw new TooLittleActualInvocations(join(\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);\n+    }\n+    \n+    public void strictlyTooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n+        TooLittleInvocations cause = null;\n+        if (lastActualInvocationStackTrace != null) {\n+            cause = new TooLittleInvocations(join(\"Too little invocations:\"));\n+            cause.setStackTrace(lastActualInvocationStackTrace.getStackTrace());\n+        }\n+\n+        throw new StrictVerificationFailure(join(\n+                \"Strict verification failure\",\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n--- /dev/null\n+++ b/src/org/mockito/exceptions/cause/ShouldBeInvokedAfter.java\n+package org.mockito.exceptions.cause;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class ShouldBeInvokedAfter extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+    \n+    public ShouldBeInvokedAfter(String message) {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/StrictVerificationFailure.java\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class StrictVerificationFailure extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public StrictVerificationFailure(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public StrictVerificationFailure(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n-import org.mockito.internal.verification.MarkingVerifier;\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n+import org.mockito.internal.verification.StrictVerifier;\n import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n \n     \n     private VerifyingRecorder createRecorder() {\n         List<Verifier> verifiers = Arrays.asList(\n+                new StrictVerifier(),\n                 new MissingInvocationVerifier(),\n                 new NumberOfInvocationsVerifier(),\n-                new MarkingVerifier(),\n                 new NoMoreInvocationsVerifier());\n         return new VerifyingRecorder(new AllInvocationsFinder(), verifiers);\n     }\n--- a/src/org/mockito/internal/invocation/ActualInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/ActualInvocationsFinder.java\n \n public class ActualInvocationsFinder {\n \n-    private final Chunker chunker;\n-    \n-    public ActualInvocationsFinder() {\n-        this(new Chunker());\n-    }\n-    \n-    ActualInvocationsFinder(Chunker chunker) {\n-        this.chunker = chunker;\n-    }\n-\n     public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        if (mode.strictMode()) {\n-            List<Invocation> unverified = new InvocationsAnalyzer().removeUntilLastStrictlyVerified(invocations);\n-            return strictlyMatching(unverified, wanted, mode); \n-        } else {\n-            return nonStrictlyMatching(invocations, wanted);\n-        }\n-    }\n-\n-    private List<Invocation> strictlyMatching(List<Invocation> invocations, InvocationMatcher wanted,\n-            VerificationModeImpl mode) {\n-        List<ObjectsChunk<Invocation>> chunks = chunker.chunk(invocations, new MatchesWantedSeer(wanted));\n-        List<Invocation> firstMatching = new LinkedList<Invocation>(); \n-        for(ObjectsChunk<Invocation> chunk : chunks) {\n-            boolean wantedMatchesActual = wanted.matches(chunk.getObject());\n-            if (!wantedMatchesActual) {\n-                continue;\n-            }\n-            \n-            if (firstMatching.isEmpty()) {\n-                firstMatching.addAll(chunk.getObjects());\n-            }\n-                \n-            boolean chunkSizeMatches = mode.matchesActualCount(chunk.getSize());\n-            if (chunkSizeMatches) {\n-                return chunk.getObjects();\n-            }\n-        }\n-        return firstMatching;\n-    }\n-\n-    private List<Invocation> nonStrictlyMatching(List<Invocation> invocations, InvocationMatcher wanted) {\n         List<Invocation> actual = new LinkedList<Invocation>();\n         for (Invocation i : invocations) {\n             if (wanted.matches(i)) {\n         }\n         return actual;\n     }\n+\n+    public List<Invocation> findFirstStrictlyUnverified(List<Invocation> invocations, InvocationMatcher wanted) {\n+        List<Invocation> unverified = new LinkedList<Invocation>();\n+        //TODO refactor\n+        for (Invocation i : invocations) {\n+            if (i.isVerifiedStrictly()) {\n+                continue;\n+            }\n+            \n+            if (wanted.matches(i)) {\n+                unverified.add(i);\n+                continue;\n+            }\n+            \n+            if (unverified.isEmpty()) {\n+                unverified.add(i);\n+            }\n+            \n+            break;\n+        }\n+        return unverified;\n+    }\n     \n-    private final class MatchesWantedSeer implements Chunker.ChunkSeer<Invocation> {\n+    private final class MatchingBasedDistributor implements Chunker.ChunksDistributor<Invocation> {\n         private final InvocationMatcher wanted;\n-\n-        public MatchesWantedSeer(InvocationMatcher wanted) {\n+        \n+        public MatchingBasedDistributor(InvocationMatcher wanted) {\n             this.wanted = wanted;\n         }\n         \n--- a/src/org/mockito/internal/invocation/Chunker.java\n+++ b/src/org/mockito/internal/invocation/Chunker.java\n      * <p>\n      * if objects are [1,1,2,1,1] then there are 3 chunks: [1,1] [2] [1,1]\n      */\n-    public <T> List<ObjectsChunk<T>> chunk(List<T> objects, ChunkSeer<T> chunkSeer) {\n+    public <T> List<ObjectsChunk<T>> chunk(List<T> objects, ChunksDistributor<T> distributor) {\n         LinkedList<ObjectsChunk<T>> chunks = new LinkedList<ObjectsChunk<T>>();\n         T previous = null;\n         for (T current : objects) {\n                 continue;\n             } \n             \n-            if (chunkSeer.isSameChunk(previous, current)) {\n+            if (distributor.isSameChunk(previous, current)) {\n                 chunks.getLast().addObject(current);\n             } else {\n                 chunks.add(new ObjectsChunk<T>(current));\n         return chunks;\n     }\n     \n-    static interface ChunkSeer<T> {\n+    static interface ChunksDistributor<T> {\n         boolean isSameChunk(T previous, T current);\n     }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n public class InvocationsAnalyzer {\n \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        List<Invocation> unverified = removeUntilLastStrictlyVerified(invocations);\n-        \n-        for (Invocation invocation : unverified) {\n+        for (Invocation invocation : invocations) {\n             String wantedMethodName = wanted.getMethod().getName();\n             String currentMethodName = invocation.getMethod().getName();\n             \n             }\n         }\n         \n-        return findFirstUnverified(unverified, wanted.getInvocation().getMock());\n+        return findFirstUnverified(invocations, wanted.getInvocation().getMock());\n     }\n     \n     public Invocation findFirstUnverified(List<Invocation> invocations) {\n         return null;\n     }\n     \n+    // 1 222  33\n+    // v vvvv\n+    //     ^ - last matching\n     public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n         Invocation lastMatching = null;\n         for (Invocation invocation : invocations) {\n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n \n+    // 1 222  33\n+    // v vv\n+    //     ^ - first undesired\n     public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         int counter = 0;\n         for (Invocation invocation : invocations) {\n         throw new IllegalArgumentException(\"There are no undesired invocations!\");\n     }\n     \n-    List<Invocation> removeUntilLastStrictlyVerified(List<Invocation> invocations) {\n+    public List<Invocation> removeUntilLastStrictlyVerified(List<Invocation> invocations) {\n         List<Invocation> unverified = new LinkedList<Invocation>();\n         for (Invocation i : invocations) {\n             if (i.isVerifiedStrictly()) {\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/ListUtil.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.List;\n+\n+public class ListUtil {\n+\n+    public static <T> List<T> filter(List<T> list, Remove<T> remove) {\n+        return null;\n+    }\n+    \n+    public static interface Remove<T> {\n+        boolean remove(T object);\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/ObjectsChunk.java\n+++ b/src/org/mockito/internal/invocation/ObjectsChunk.java\n     \n     LinkedList<T> objects = new LinkedList<T>(); \n \n+    public ObjectsChunk() {}\n+    \n     public ObjectsChunk(T object) {\n         objects.add(object);\n-    }\n-\n-    public int getSize() {\n-        return objects.size();\n-    }\n-\n-    public List<T> getObjects() {\n-        return objects;\n-    }\n-\n-    public T getObject() {\n-        return objects.getFirst();\n     }\n \n     public void addObject(T object) {\n         objects.add(object);\n     }\n     \n+    public T getObject() {\n+        return objects.getFirst();\n+    }\n+    \n+    public List<T> getObjects() {\n+        return objects;\n+    }\n+    \n+    public int getSize() {\n+        return objects.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return getSize() == 0;\n+    }\n+    \n     @Override\n     public String toString() {\n         return \"Chunk size: \" + getSize() + \", objects: \" + objects;\n     }\n-}\n+}\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n         return explicitMode() && (atLeastOnceMode() || wantedInvocationCount > 0);\n     }\n \n-    public boolean exactNumberOfInvocationsMode() {\n-        return !atLeastOnceMode() && explicitMode();\n-    }\n-    \n     public boolean matchesActualCount(int actualCount) {\n         boolean atLeastOnce = atLeastOnceMode() && actualCount > 0;\n         boolean actualMatchesWanted = !atLeastOnceMode() && wantedInvocationCount == actualCount;\n         return !atLeastOnceMode() && wantedInvocationCount < actualCount;\n     }\n     \n+    public boolean wantedCountIsZero() {\n+        return !atLeastOnceMode() && wantedInvocationCount == 0;\n+    }\n+    \n     @Override\n     public String toString() {\n         return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedStrictly;\n     }\n+\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, similar);\n             reporter.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), similar.getStackTrace());\n         } else {\n-            //TODO For strictly, I really want a cause here, something like: \"wanted after...\" for strictly... :D\n             reporter.wantedButNotInvoked(wanted.toString());\n         }\n     }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n     }\n     \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        if (!mode.exactNumberOfInvocationsMode()) {\n+        //TODO push to mode\n+        if (mode.strictMode() || !mode.explicitMode()) {\n             return;\n         }\n         \n             HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(actualInvocations, wanted, mode);\n             reporter.tooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n         }\n+        \n+        for (Invocation i : actualInvocations) {\n+            i.markVerified();\n+        }\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/StrictVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsAnalyzer;\n+import org.mockito.internal.invocation.InvocationsPrinter;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+public class StrictVerifier implements Verifier {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsAnalyzer analyzer;\n+    private final ActualInvocationsFinder finder;\n+    \n+    public StrictVerifier() {\n+        this(new InvocationsAnalyzer(), new ActualInvocationsFinder(), new Reporter());\n+    }\n+    \n+    public StrictVerifier(InvocationsAnalyzer analyzer, ActualInvocationsFinder finder, Reporter reporter) {\n+        this.analyzer = analyzer;\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+\n+    //TODO tests! - do you like the message?\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        if (!mode.explicitMode() || !mode.strictMode()) {\n+            return;\n+        }\n+        \n+        List<Invocation> chunk = finder.findFirstStrictlyUnverified(invocations, wanted);\n+        \n+        if (mode.wantedCountIsZero() && (chunk.size() == 0 || !wanted.matches(chunk.get(0)))) {\n+            return;\n+        }\n+        \n+        if (chunk.size() == 0 || !wanted.matches(chunk.get(0))) {\n+            //TODO got rid of those ifs... (Printer to have actual stackTrace?)\n+            if (chunk.size() != 0) {\n+                Invocation actual = chunk.get(0);\n+                InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n+                reporter.strictVerificationFailed(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n+            } else {\n+                reporter.strictlyWantedButNotInvoked(wanted.toString());\n+            }\n+        }\n+        \n+        int actualCount = chunk.size();\n+        \n+        if (mode.tooLittleActualInvocations(actualCount)) {\n+            HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(chunk, wanted);\n+            reporter.strictlyTooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n+        } else if (mode.tooManyActualInvocations(actualCount)) {\n+            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(chunk, wanted, mode);\n+            reporter.strictlyTooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n+        }\n+        \n+        //TODO not tested\n+        for (Invocation i : chunk) {\n+            i.markVerifiedStrictly();\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/ActualInvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/ActualInvocationsFinderTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.progress.VerificationModeBuilder;\n \n \n public class ActualInvocationsFinderTest extends RequiresValidState {\n     }\n     \n     @Test\n-    public void shouldSearchOnlyAfterLastStrictlyVerified() throws Exception {\n+    public void shouldFindFirstStrictlyUnverified() throws Exception {\n+        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        \n+        assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstStrictlyUnverifiedAndSkipVerified() throws Exception {\n+        simpleMethodInvocation.markVerifiedStrictly();\n+        \n+        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        \n+        assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocationTwo));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstStrictlyUnverifiedAndSkipTwoVerifiedInvocations() throws Exception {\n         simpleMethodInvocation.markVerifiedStrictly();\n         simpleMethodInvocationTwo.markVerifiedStrictly();\n         \n-        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().strict());\n-        assertTrue(actual.isEmpty());\n+        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        \n+        assertThat(unverified, collectionHasExactlyInOrder(differentMethodInvocation));\n     }\n     \n     @Test\n-    public void shouldSearchAndFindOnlyAfterLastStrictlyVerified() throws Exception {\n+    public void shouldFindFirstStrictlyUnverifiedAndSkipAllInvocations() throws Exception {\n+        simpleMethodInvocation.markVerifiedStrictly();\n+        simpleMethodInvocationTwo.markVerifiedStrictly();\n         differentMethodInvocation.markVerifiedStrictly();\n         \n-        Invocation lastInvocation = new InvocationBuilder().simpleMethod().toInvocation();\n-        invocations.add(lastInvocation);\n+        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n         \n-        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().strict());\n-        assertThat(actual, collectionHasExactlyInOrder(lastInvocation));\n-    }\n-\n-    @Test\n-    public void shouldFindLastInvocationWhenModeIsOneTimeStrictly() throws Exception {\n-        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n-        invocations.add(lastSimpleMethodInvocation);\n-        \n-        List<Invocation> actual = finder.findInvocations(\n-                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().times(1).strict());\n-        assertThat(actual, collectionHasExactlyInOrder(lastSimpleMethodInvocation));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstTwoInvocationsWhenModeIsTwoTimesStrictly() throws Exception {\n-        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n-        invocations.add(lastSimpleMethodInvocation);\n-        \n-        List<Invocation> actual = finder.findInvocations(\n-                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().times(2).strict());\n-        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstMatchingChunkWhenWantedCountDoesNotMatch() throws Exception {\n-        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n-        invocations.add(lastSimpleMethodInvocation);\n-        \n-        List<Invocation> actual = finder.findInvocations(\n-                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().times(20).strict());\n-        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstTwoInvocationsWhenModeIsAtLeastOnceStrictly() throws Exception {\n-        Invocation lastSimpleMethodInvocation = new InvocationBuilder().toInvocation();\n-        invocations.add(lastSimpleMethodInvocation);\n-        \n-        List<Invocation> actual = finder.findInvocations(\n-                invocations, new InvocationMatcher(simpleMethodInvocation), new VerificationModeBuilder().atLeastOnce().strict());\n-        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+        assertTrue(unverified.isEmpty());\n     }\n }\n--- a/test/org/mockito/internal/invocation/ChunkerTest.java\n+++ b/test/org/mockito/internal/invocation/ChunkerTest.java\n \n public class ChunkerTest extends RequiresValidState {\n \n-    private final class EqualitySeer implements Chunker.ChunkSeer<Integer> {\n+    private final class EqualityBasedDistributor implements Chunker.ChunksDistributor<Integer> {\n         public boolean isSameChunk(Integer previous, Integer current) {\n             return previous.equals(current);\n         }\n \n     @Test\n     public void shouldChunkObjectLists() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 2, 3), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 2, 3), new EqualityBasedDistributor());\n         assertEquals(3, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1));\n         assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2));\n     \n     @Test\n     public void shouldChunkObjectListsAndFindDuplicates() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 1, 2, 2, 3, 3, 3, 3), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 1, 2, 2, 3, 3, 3, 3), new EqualityBasedDistributor());\n         assertEquals(3, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1, 1));\n         assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2, 2));\n     \n     @Test\n     public void shouldChunkWhenDuplicatesOnEdges() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 2, 3, 3), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 2, 3, 3), new EqualityBasedDistributor());\n         assertEquals(3, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1));\n         assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2));\n     \n     @Test\n     public void shouldChunkWhenDuplicatesInTheMiddle() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 2, 2, 3), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 2, 2, 3), new EqualityBasedDistributor());\n         assertEquals(3, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1));\n         assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2, 2));\n     \n     @Test\n     public void shouldNotMergeDuplicatesThatAreNotConsecutive() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 2, 1, 1, 1), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1, 2, 1, 1, 1), new EqualityBasedDistributor());\n         assertEquals(3, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1));\n         assertThat(chunked.get(1).getObjects(), collectionHasExactlyInOrder(2));\n     \n     @Test\n     public void shouldCreateSingleChunkForOneElementList() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1), new EqualityBasedDistributor());\n         assertEquals(1, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1));\n     }\n     \n     @Test\n     public void shouldCreateSingleChunkOfSizeTwo() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(asList(1, 1), new EqualityBasedDistributor());\n         assertEquals(1, chunked.size());\n         assertThat(chunked.get(0).getObjects(), collectionHasExactlyInOrder(1, 1));\n     }\n     \n     @Test\n     public void shouldCreateEmptyChunks() throws Exception {\n-        List<ObjectsChunk<Integer>> chunked = chunker.chunk(Collections.<Integer>emptyList(), new EqualitySeer());\n+        List<ObjectsChunk<Integer>> chunked = chunker.chunk(Collections.<Integer>emptyList(), new EqualityBasedDistributor());\n         assertEquals(0, chunked.size());\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class InvocationsAnalyzerTest extends RequiresValidState {\n     }  \n     \n     @Test\n-    public void shouldLookForSimilarOnlyAfterLastStrictlyVerified() throws Exception {\n-        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n-        \n-        simpleMethodInvocationTwo.markVerifiedStrictly();\n-        \n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), mode);\n-        assertSame(differentMethodInvocation, found);\n-    }\n-    \n-    @Test\n-    public void shouldFindSimilarAfterLastStrictlyVerified() throws Exception {\n-        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n-        \n-        Invocation lastInvocation = new InvocationBuilder().simpleMethod().toInvocation();\n-        invocations.add(lastInvocation);\n-        \n-        simpleMethodInvocationTwo.markVerifiedStrictly();\n-        \n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), mode);\n-        assertSame(found, lastInvocation);\n-    }\n-    \n-    @Test\n     public void shouldFindLastMatchingInvocationTrace() throws Exception {\n         HasStackTrace found = analyzer.findLastMatchingInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation));\n         assertSame(simpleMethodInvocationTwo.getStackTrace(), found);\n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n         assertFalse(times(0).missingMethodMode());\n     }\n     \n-    @Test\n-    public void shouldKnowIfIsExactNumberOfInvocationsMode() throws Exception {\n-        assertTrue(times(0).exactNumberOfInvocationsMode());\n-        assertTrue(times(1).exactNumberOfInvocationsMode());\n-        assertTrue(times(2).exactNumberOfInvocationsMode());\n-        \n-        assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n-        assertFalse(atLeastOnce().exactNumberOfInvocationsMode());\n-    }\n+//    @Test\n+//    public void shouldKnowIfIsExactNumberOfInvocationsMode() throws Exception {\n+//        assertTrue(times(0).exactNumberOfInvocationsMode());\n+//        assertTrue(times(1).exactNumberOfInvocationsMode());\n+//        assertTrue(times(2).exactNumberOfInvocationsMode());\n+//        \n+//        assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n+//        assertFalse(atLeastOnce().exactNumberOfInvocationsMode());\n+//    }\n     \n     @Test\n     public void shouldKnowIfIsStrict() throws Exception {\n         assertFalse(times(1).tooManyActualInvocations(1));\n         assertFalse(times(2).tooManyActualInvocations(1));\n     }\n+    \n+    @Test\n+    public void shouldKnowIfWantedCountIsZero() throws Exception {\n+        assertTrue(times(0).wantedCountIsZero());\n+        \n+        assertFalse(times(1).wantedCountIsZero());\n+        assertFalse(times(20).wantedCountIsZero());\n+        assertFalse(atLeastOnce().wantedCountIsZero());\n+    }\n }\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n     }\n \n     @Test\n-    public void shouldNeverVerifyWhenNotModeIsNotExactNumberOfInvocationsMode() throws Exception {\n-        verifier.verify(null, null, atLeastOnce());\n+    public void shouldNeverVerifyWhenNotModeIsStrict() throws Exception {\n+        verifier.verify(null, null, new VerificationModeBuilder().strict());\n     }\n     \n     @Test\n         assertEquals(wanted.toString(), reporterStub.wanted);\n     }\n     \n+    @Test\n+    public void shouldMarkInvocationsAsVerified() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        finderStub.actualToReturn.add(invocation);\n+        assertFalse(invocation.isVerified());\n+        \n+        verifier.verify(invocations, wanted, atLeastOnce());\n+        \n+        assertTrue(invocation.isVerified());\n+    }\n+    \n     class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n         private HasStackTrace invocationTraceToReturn;\n         private List<Invocation> invocations;\n--- /dev/null\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+\n+//TODO pmd rule so that all that starts with should have @Test annotation (or all XTest have some annotations on public methods)\n+public class PointingStackTraceToActualInvocationChunkTest extends RequiresValidState {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        firstChunk();\n+        secondChunk();\n+        thirdChunk();\n+        fourthChunk();\n+    }\n+\n+    private void firstChunk() {\n+        mock.simpleMethod(1);\n+        mock.simpleMethod(1);\n+    }\n+    private void secondChunk() {\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void thirdChunk() {\n+        mock.simpleMethod(3);\n+        mock.simpleMethod(3);\n+    }\n+    private void fourthChunk() {\n+        mockTwo.simpleMethod(4);\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPointStackTraceToActualInvocation() {\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (StrictVerificationFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocation() {\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (StrictVerificationFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedInvocation() {\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(999);\n+            fail();\n+        } catch (StrictVerificationFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunk() {\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(anyInt());\n+            fail();\n+        } catch (StrictVerificationFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(anyInt());\n+            fail();\n+        } catch (StrictVerificationFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocationOnVerificationError() {\n+        try {\n+            verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedActualInvocationOnVerificationError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, atLeastOnce()).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsChunkOnError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, times(3)).simpleMethod(3);\n+            fail();\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunkOnError() {\n+        try {\n+            verify(mock).simpleMethod(1);\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }   \n+}\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n     \n     private IMethods mock;\n     private IMethods mockTwo;\n+    private Strictly strictly;\n \n     @Before\n     public void setup() {\n         mock = Mockito.mock(IMethods.class);\n         mockTwo = Mockito.mock(IMethods.class);\n+        strictly = createStrictOrderVerifier(mock, mockTwo);\n         \n         first();\n         second();\n         mockTwo.simpleMethod(4);\n     }\n     \n+    @Test\n     public void shouldPointStackTraceToActualInvocation() {\n-        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n-        \n         strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         strictly.verify(mockTwo).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mock).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToActualInvocation() {\n-        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mockTwo).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToUnverifiedInvocation() {\n-        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mock).simpleMethod(anyInt());\n         strictly.verify(mockTwo).simpleMethod(anyInt());\n+        strictly.verify(mock).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mockTwo, times(3)).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToTooManyInvocationsChunk() {\n-        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mock).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mockTwo, times(0)).simpleMethod(anyInt());\n             fail();\n-        } catch (TooManyActualInvocations e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n-        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mock).simpleMethod(anyInt());\n         strictly.verify(mockTwo).simpleMethod(anyInt());\n+        strictly.verify(mock).simpleMethod(anyInt());\n         \n         try {\n             strictly.verify(mockTwo, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (TooLittleActualInvocations e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n         }\n     }\n--- a/test/org/mockitousage/StackTraceFilteringTest.java\n+++ b/test/org/mockitousage/StackTraceFilteringTest.java\n import org.mockito.Strictly;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n public class StackTraceFilteringTest extends RequiresValidState {\n         mock.oneArg(true);\n         mock.oneArg(false);\n         \n-        strictly.verify(mock).oneArg(false); \n         try {\n-            strictly.verify(mock).oneArg(true);\n+            strictly.verify(mock).oneArg(false); \n             fail();\n-        } catch (WantedButNotInvoked e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n         }\n     }\n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n \n public class IncorectBindingPuzzleFixedTest extends RequiresValidState {\n \n         try {\n             strictly.verify(sub).say(\"Hello\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n             assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n         }\n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.sample;\n-import static org.mockito.Mockito.stub;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.Arrays;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n \n public class MockitoSampleTest extends RequiresValidState {\n     \n         verify(mockDatabase).save(articleTwo);\n         verify(mockDatabase).save(articleThree);\n     }\n+    \n+    @Test\n+    public void strictVerificationAndArgumentMatchers() {\n+        ArticleCalculator mockCalculator = Mockito.mock(ArticleCalculator.class);\n+        ArticleDatabase mockDatabase = Mockito.mock(ArticleDatabase.class);\n+        \n+        ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n+\n+        Article articleOne = new Article();\n+        Article articleTwo = new Article();\n+        \n+        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).andReturn(1);\n+        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).andReturn(12);\n+        \n+        stub(mockDatabase.getArticlesFor(\"Guardian\")).andReturn(Arrays.asList(articleOne, articleTwo)); \n+        \n+        articleManager.updateRelatedArticlesCounters(\"Guardian\");\n+\n+        Strictly strictly = createStrictOrderVerifier(mockDatabase);\n+        \n+        strictly.verify(mockDatabase, atLeastOnce()).getArticlesFor(anyString());\n+        strictly.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());\n+    }\n }\n--- a/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             strictly.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (WantedButNotInvoked e) {}\n-    }\n-    \n-    @Test(expected=TooManyActualInvocations.class)\n+        } catch (StrictVerificationFailure e) {}\n+    }\n+    \n+    @Test(expected=StrictVerificationFailure.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n         strictly.verify(mockOne, times(0)).simpleMethod(1);\n     }\n     \n-    @Test(expected=TooLittleActualInvocations.class)\n+    @Test(expected=StrictVerificationFailure.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n         strictly.verify(mockOne, times(2)).simpleMethod(1);\n     }\n         try {\n             strictly.verify(mockTwo, times(3)).simpleMethod(2);\n             fail();\n-        } catch (TooLittleActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(0)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne, times(0)).simpleMethod(4);\n             fail();\n-        } catch (TooManyActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne, times(2)).simpleMethod(4);\n             fail();\n-        } catch (TooLittleActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }    \n     \n     /* ------------- */\n     \n-    @Test(expected=InvocationDiffersFromActual.class)\n+    @Test(expected=StrictVerificationFailure.class)\n     public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n         strictly.verify(mockOne).simpleMethod(100);\n     }\n     \n-    @Test(expected=InvocationDiffersFromActual.class)\n+    @Test(expected=StrictVerificationFailure.class)\n     public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n         strictly.verify(mockOne).oneArg(true);\n     }\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(-999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).oneArg(true);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(-666);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).oneArg(false);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }    \n     \n     /* -------------- */\n     \n-    @Test\n-    public void shouldPassSingleMethodFromTheMiddleOfSequence() {\n-        strictly.verify(mockOne).simpleMethod(4);\n-    }\n-    \n-    @Test\n-    public void shouldPassSingleMethodUsingTimesMode() {\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-    }\n-    \n-    @Test\n-    public void shouldPassSingleMethodUsingAtLeastOnceMode() {\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-    }\n-    \n-    @Test\n-    public void shouldPassIfSomeMethodsFromTheMiddleAreLeftOut() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockOne).simpleMethod(4);\n-    }\n-    \n-    @Test\n-    public void shouldPassUsingAtLeastOnceIfSomeMethodsFromTheMiddleAreLeftOut() {\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-    }\n-    \n-    @Test\n-    public void shouldAllowLastMethodEarly() {\n+    @Test(expected=StrictVerificationFailure.class)\n+    public void shouldFailWhenLastMethodVerifiedFirst() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test(expected=StrictVerificationFailure.class)\n+    public void shouldFailWhenMiddleMethodVerifiedFirst() {\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=StrictVerificationFailure.class)\n+    public void shouldFailWhenMiddleMethodVerifiedFirstInAtLeastOnceMode() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=StrictVerificationFailure.class)\n+    public void shouldFailWhenSomeMiddleMethodsAreLeftOut() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test(expected=StrictVerificationFailure.class)\n+    public void shouldFailWhenSomeMiddleMethodsInAtLeastOnceModeAreLeftOut() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=StrictVerificationFailure.class)\n+    public void shouldFailWhenLastMethodIsTooEarly() {\n         strictly.verify(mockOne).simpleMethod(1);\n         strictly.verify(mockOne).simpleMethod(4);\n     }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockitousage.IMethods;\n \n public class DescriptiveMessagesOnStrictOrderErrorsTest extends RequiresValidState {\n     }\n     \n     @Test\n-    public void shouldPrintStrictVerificationError() {\n+    public void shouldPrintStrictErrorAndShowBothWantedAndActual() {\n         strictly.verify(one, atLeastOnce()).simpleMethod(1);\n         \n         try {\n             strictly.verify(one).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (StrictVerificationFailure e) {\n             String expected = \n                     \"\\n\" +\n-                    \"Invocation differs from actual\" +\n+                    \"Strict verification failure\" +\n                     \"\\n\" +\n                     \"Wanted invocation:\" +\n                     \"\\n\" +\n         try {\n             strictly.verify(three).simpleMethod(999);\n             fail();\n-        } catch (WantedButNotInvoked e) {\n+        } catch (StrictVerificationFailure e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n+                    \"\\n\" +\n+                    \"Strict verification failure\" +\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n     }   \n     \n     @Test\n-    public void shouldPrintWrongNumberOfInvocations() {\n+    public void shouldPrintTooManyInvocations() {\n         strictly.verify(one).simpleMethod(1);\n         strictly.verify(one).simpleMethod(11);\n         try {\n             strictly.verify(two, times(1)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocations e) {\n+        } catch (StrictVerificationFailure e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n+                    \"\\n\" +\n+                    \"Strict verification failure\" +\n                     \"\\n\" +\n                     \"IMethods.simpleMethod(2)\" +\n                     \"\\n\" +\n     }  \n     \n     @Test\n-    public void shouldPrintThatWantedButNotInvoked() {\n-        strictly.verify(two, atLeastOnce()).simpleMethod(2);\n-        try {\n-            strictly.verify(one).simpleMethod(1);\n-            fail();\n-        } catch (WantedButNotInvoked e) {}\n-    }  \n-    \n-    @Test\n-    public void shouldPrintUndesiredInvocation() {\n-        two.simpleMethod(2);\n-        two.simpleMethod(2);\n+    public void shouldPrintTooLittleInvocations() {\n         two.simpleMethod(2);\n         \n+        strictly.verify(one, atLeastOnce()).simpleMethod(anyInt());\n+        strictly.verify(two, times(2)).simpleMethod(2);\n         strictly.verify(three, atLeastOnce()).simpleMethod(3);\n         \n         try {\n             strictly.verify(two, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocations e) {\n+        } catch (StrictVerificationFailure e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-                    \"IMethods.simpleMethod(2)\" +\n-                    \"\\n\" +\n-                    \"Wanted 2 times but was 3\";\n-            assertEquals(expectedMessage, actualMessage);\n-            \n-            assertEquals(e.getCause().getClass(), UndesiredInvocation.class);\n-            \n-            String expectedCause = \n-                \"\\n\" +\n-                \"Undesired invocation:\";\n-            \n-            assertEquals(expectedCause, e.getCause().getMessage());\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldPrintTooLittleInvocations() {\n-        two.simpleMethod(2);\n-        \n-        strictly.verify(three, atLeastOnce()).simpleMethod(3);\n-        \n-        try {\n-            strictly.verify(two, times(2)).simpleMethod(2);\n-            fail();\n-        } catch (TooLittleActualInvocations e) {\n-            String actualMessage = e.getMessage();\n-            String expectedMessage = \n+                    \"Strict verification failure\" +\n                     \"\\n\" +\n                     \"IMethods.simpleMethod(2)\" +\n                     \"\\n\" +\n--- a/test/org/mockitousage/verification/RelaxedStrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/RelaxedStrictVerificationTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n+/**\n+ * ignored since Relaxed strict verification is not implemented (too complex to bother).\n+ */\n+@Ignore\n @SuppressWarnings(\"unchecked\")  \n public class RelaxedStrictVerificationTest extends RequiresValidState {\n     \n--- a/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n+++ b/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             strictly.verify(mockOne).differentMethod();\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (StrictVerificationFailure e) {}\n     } \n     \n     @Test\n     public void shouldFailVerificationForMockOneBecauseOfWrongOrder() {\n         Strictly strictly = createStrictOrderVerifier(mockOne);\n-        strictly.verify(mockOne).simpleMethod(4);\n         \n         try {\n-            strictly.verify(mockOne).simpleMethod(1);\n+            strictly.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (WantedButNotInvoked e) {}\n+        } catch (StrictVerificationFailure e) {}\n     } \n \n     @Test\n         try {\n             strictly.verify(mockTwo).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(4)).simpleMethod(2);\n             fail();\n-        } catch (TooLittleActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocations e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         Strictly strictly = createStrictOrderVerifier(mockTwo, mockThree);\n \n         strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockTwo, times(1)).simpleMethod(2);\n-        verifyNoMoreInteractions(mockTwo);\n-        try {\n-            verifyNoMoreInteractions(mockThree);\n-            fail();\n-        } catch (NoInteractionsWanted e) {}\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo, mockThree);\n     }\n     \n     @Test\n--- a/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n import org.mockito.Strictly;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         verify(mockTwo).simpleMethod(2);\n         verify(mockOne, atLeastOnce()).simpleMethod(1);\n \n-        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n     }\n     \n     @Test\n-    public void shouldAllowLastInvocationEarly() {\n+    public void shouldFailOnLastInvocationTooEarly() {\n         strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n         verify(mockTwo).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(4);\n+        try {\n+            strictly.verify(mockThree).simpleMethod(4);\n+            fail();\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test(expected=MockitoException.class)\n--- a/test/org/mockitousage/verification/StrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.StrictVerificationFailure;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         verify(mockOne).simpleMethod(2);\n         verify(mockOne).simpleMethod(1);\n         \n-        strictly.verify(mockOne).simpleMethod(2);\n         try {\n-            strictly.verify(mockOne).simpleMethod(1);\n+            strictly.verify(mockOne).simpleMethod(2);\n             fail();\n-        } catch (WantedButNotInvoked e) {}\n+        } catch (StrictVerificationFailure e) {}\n     } \n     \n     @Test\n-    public void shouldCausePointToMockOne() {\n+    public void shouldMessagesPointToProperMethod() {\n         mockTwo.differentMethod();\n         mockOne.simpleMethod();\n         \n         try {\n             strictly.verify(mockOne, atLeastOnce()).differentMethod();\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (StrictVerificationFailure e) {\n             assertThat(e, messageContains(\"IMethods.differentMethod()\"));\n-            assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n+            assertThat(e, causeMessageContains(\"IMethods.differentMethod()\"));\n         }\n     }\n     \n         mockOne.simpleMethod();\n         \n         strictly.verify(mockOne, atLeastOnce()).simpleMethod();\n+        strictly.verify(mockTwo).differentMethod();\n         strictly.verify(mockOne, times(2)).simpleMethod();\n         try {\n             strictly.verify(mockOne, atLeastOnce()).simpleMethod();\n             fail();\n-        } catch (WantedButNotInvoked e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n     \n     @Test\n         verify(mockOne, times(4)).simpleMethod(anyInt());\n         \n         strictly.verify(mockOne, times(2)).simpleMethod(anyInt());\n+        strictly.verify(mockTwo).differentMethod();\n         strictly.verify(mockOne, times(2)).simpleMethod(anyInt());\n         try {\n             strictly.verify(mockOne, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (WantedButNotInvoked e) {}\n+        } catch (StrictVerificationFailure e) {}\n     }\n }", "timestamp": 1198697163, "metainfo": ""}