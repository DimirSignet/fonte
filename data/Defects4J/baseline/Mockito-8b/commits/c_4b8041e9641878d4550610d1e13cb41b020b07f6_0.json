{"sha": "4b8041e9641878d4550610d1e13cb41b020b07f6", "log": "moved classes around  --HG-- rename : test/org/mockitousage/MatchersMixedWithRawArgumentsTest.java => test/org/mockitousage/matchers/MatchersMixedWithRawArgumentsTest.java rename : test/org/mockitousage/ReflectionMatchersTest.java => test/org/mockitousage/matchers/ReflectionMatchersTest.java rename : test/org/mockitousage/DescriptiveMessagesOnMisuseTest.java => test/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java rename : test/org/mockitousage/InvalidStateDetectionTest.java => test/org/mockitousage/misuse/InvalidStateDetectionTest.java rename : test/org/mockitousage/InvalidUsageTest.java => test/org/mockitousage/misuse/InvalidUsageTest.java rename : test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java => test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java rename : test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java => test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java rename : test/org/mockitousage/PointingStackTraceToActualInvocationInOrderTest.java => test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java rename : test/org/mockitousage/PointingStackTraceToActualInvocationTest.java => test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java rename : test/org/mockitousage/StackTraceFilteringTest.java => test/org/mockitousage/stacktrace/StackTraceFilteringTest.java rename : test/org/mockitousage/StackTrackeChangingTest.java => test/org/mockitousage/stacktrace/StackTrackeChangingTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40589", "commit": "\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockitousage.matchers.MatchersTest;\n import org.mockitousage.matchers.MatchersToStringTest;\n import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n+import org.mockitousage.misuse.InvalidStateDetectionTest;\n+import org.mockitousage.misuse.InvalidUsageTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationChunkTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n+import org.mockitousage.stacktrace.StackTraceFilteringTest;\n+import org.mockitousage.stacktrace.StackTrackeChangingTest;\n import org.mockitousage.stubbing.BasicStubbingTest;\n import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/CapturingMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class CapturingMatchersTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+\n+    @Test\n+    public void shouldAllowCapturingArguments() throws Exception {\n+        \n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/MatchersMixedWithRawArgumentsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockitousage.IMethods;\n+\n+public class MatchersMixedWithRawArgumentsTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+  \n+    //description of an idea:\n+    //types of arguments and descriptor value that identifies matcher:\n+    //Object: objenesis instance to check for identity\n+    //boolean: false\n+    //byte: max-1\n+    //short: max-1\n+    //int: max-1\n+    //long: max-1\n+    //char: 'x'\n+    //double: max-1\n+    //float: max-1\n+    \n+    //1. how objenesis deal with primitive arrays (like byte[])?\n+    //2. Analisys of all matchers used by R2 project finished before anyObject() and so far proves it's a good idea.\n+\n+    @Ignore(\"prototyping new feature that allows to avoid eq() matchers when raw args passed\")\n+    @Test\n+    public void shouldAllowMixingRawArgumentsWithMatchers() {\n+        mock.varargs(\"1\", \"2\", \"3\");\n+        verify(mock).varargs(\"1\", anyString(), \"3\");\n+        \n+        verify(mock).varargs(anyBoolean(), false);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/ReflectionMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+\n+@SuppressWarnings(\"all\")\n+public class ReflectionMatchersTest extends TestBase {\n+\n+    class Parent {\n+        private int parentField;\n+        protected String protectedParentField;\n+        public Parent(int parentField, String protectedParentField) {\n+            this.parentField = parentField;\n+            this.protectedParentField = protectedParentField;\n+        }\n+    }\n+    \n+    class Child extends Parent {\n+        private int childFieldOne;\n+        private Object childFieldTwo;\n+        public Child(int parentField, String protectedParentField, int childFieldOne, Object childFieldTwo) {\n+            super(parentField, protectedParentField);\n+            this.childFieldOne = childFieldOne;\n+            this.childFieldTwo = childFieldTwo;\n+        } \n+    }\n+    \n+    interface MockMe {\n+        void run(Child child);\n+    }\n+    \n+    MockMe mock;\n+    \n+    @Before\n+    public void setup() {\n+        mock = mock(MockMe.class);\n+        \n+        Child actual = new Child(1, \"foo\", 2, \"bar\");\n+        mock.run(actual);\n+    }\n+    \n+    @Test\n+    public void shouldMatchWhenFieldValuesEqual() throws Exception {\n+        Child wanted = new Child(1, \"foo\", 2, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=ArgumentsAreDifferent.class)\n+    public void shouldNotMatchWhenFieldValuesDiffer() throws Exception {\n+        Child wanted = new Child(1, \"foo\", 2, \"bar XXX\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=ArgumentsAreDifferent.class)\n+    public void shouldNotMatchAgain() throws Exception {\n+        Child wanted = new Child(1, \"foo\", 999, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=ArgumentsAreDifferent.class)\n+    public void shouldNotMatchYetAgain() throws Exception {\n+        Child wanted = new Child(1, \"XXXXX\", 2, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+    \n+    @Test(expected=ArgumentsAreDifferent.class)\n+    public void shouldNotMatch() throws Exception {\n+        Child wanted = new Child(234234, \"foo\", 2, \"bar\");\n+        verify(mock).run(refEq(wanted));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.misuse;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockitousage.IMethods;\n+\n+public class DescriptiveMessagesOnMisuseTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+\n+    @SuppressWarnings(\"all\")\n+    @Ignore(\"just for tuning up the error messages\")\n+    @Test\n+    public void tryDescriptiveMessagesOnMisuse() {\n+        verifyNoMoreInteractions();\n+        verifyNoMoreInteractions(null);\n+        verifyNoMoreInteractions(\"\");\n+        verifyZeroInteractions();\n+        verifyZeroInteractions(null);\n+        verifyZeroInteractions(\"\");\n+\n+        inOrder();\n+        inOrder(null);\n+        inOrder(\"test\");\n+        InOrder inOrder = inOrder(mock(List.class));\n+        inOrder.verify(mock).simpleMethod();\n+\n+        verify(mock.differentMethod());\n+        verify(null);\n+\n+        verify(mock).varargs(\"test\", anyString());\n+\n+        stub(\"x\").toReturn(\"x\");\n+\n+        stub(mock.simpleMethod());\n+        stub(mock.differentMethod()).toReturn(\"\");\n+    } \n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldScreamWhenWholeMethodPassedToVerify() {\n+        verify(mock.booleanReturningMethod());\n+    }   \n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldScreamWhenWholeMethodPassedToVerifyNoMoreInteractions() {\n+        verifyNoMoreInteractions(mock.byteReturningMethod());\n+    }  \n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldScreamNullPassedToVerify() {\n+        verify(null);\n+    }  \n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldScreamWhenNotMockPassedToVerifyNoMoreInteractions() {\n+        verifyNoMoreInteractions(null, \"blah\");\n+    } \n+    \n+    @SuppressWarnings(\"all\")\n+    @Test(expected=MockitoException.class)\n+    public void shouldScreamWhenNullPassedToVerifyNoMoreInteractions() {\n+        verifyNoMoreInteractions(null);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.misuse;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.StateResetter;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockitousage.IMethods;\n+\n+/**\n+ * invalid state happens if:\n+ * \n+ *    -unfinished stubbing\n+ *    -unfinished stubVoid\n+ *    -stubbing without actual method call\n+ *    -verify without actual method call\n+ *    \n+ * we should aim to detect invalid state in following scenarios:\n+ * \n+ *    -on method call on mock\n+ *    -on verify\n+ *    -on verifyZeroInteractions\n+ *    -on verifyNoMoreInteractions\n+ *    -on verify in order\n+ *    -on stub\n+ *    -on stubVoid\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidStateDetectionTest extends TestBase {\n+\n+    private IMethods mock;\n+\n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+        mock = mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedStubbing() {\n+        stub(mock.simpleMethod());\n+        detects(new OnMethodCallOnMock(), UnfinishedStubbingException.class);\n+\n+        stub(mock.simpleMethod());\n+        detects(new OnStub(), UnfinishedStubbingException.class);\n+        \n+        stub(mock.simpleMethod());\n+        detects(new OnStubVoid(), UnfinishedStubbingException.class);\n+        \n+        stub(mock.simpleMethod());\n+        detects(new OnVerify(), UnfinishedStubbingException.class);\n+        \n+        stub(mock.simpleMethod());\n+        detects(new OnVerifyInOrder(), UnfinishedStubbingException.class);\n+        \n+        stub(mock.simpleMethod());\n+        detects(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);\n+        \n+        stub(mock.simpleMethod());\n+        detects(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedStubbingVoid() {\n+        stubVoid(mock);\n+        detects(new OnMethodCallOnMock(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnStub(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnStubVoid(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnVerify(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnVerifyInOrder(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerification() {\n+        verify(mock);\n+        detects(new OnStub(), UnfinishedVerificationException.class);\n+        \n+        verify(mock);\n+        detects(new OnStubVoid(), UnfinishedVerificationException.class);\n+        \n+        verify(mock);\n+        detects(new OnVerify(), UnfinishedVerificationException.class);\n+        \n+        verify(mock);\n+        detects(new OnVerifyInOrder(), UnfinishedVerificationException.class);\n+        \n+        verify(mock);\n+        detects(new OnVerifyZeroInteractions(), UnfinishedVerificationException.class);\n+        \n+        verify(mock);\n+        detects(new OnVerifyNoMoreInteractions(), UnfinishedVerificationException.class);\n+    }\n+    \n+    @Test\n+    public void shouldCorrectStateAfterDetectingUnfinishedStubbing() {\n+        stubVoid(mock).toThrow(new RuntimeException());\n+        \n+        try {\n+            stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);\n+            fail();\n+        } catch (UnfinishedStubbingException e) {}\n+        \n+        stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);\n+        try {\n+            mock.oneArg(true);\n+            fail();\n+        } catch (RuntimeException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldCorrectStateAfterDetectingUnfinishedVerification() {\n+        mock.simpleMethod();\n+        verify(mock);\n+        \n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n+        \n+        verify(mock).simpleMethod();\n+    }\n+    \n+    private static interface DetectsInvalidState {\n+        void detect(IMethods mock);\n+    }\n+    \n+    private static class OnVerify implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verify(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyInOrder implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            inOrder(mock).verify(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyZeroInteractions implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verifyZeroInteractions(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyNoMoreInteractions implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verifyNoMoreInteractions(mock);\n+        }\n+    }    \n+    \n+    private static class OnStub implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            stub(mock);\n+        }\n+    }\n+    \n+    private static class OnStubVoid implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            stubVoid(mock);\n+        }\n+    }\n+    \n+    private static class OnMethodCallOnMock implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            mock.simpleMethod();\n+        }\n+    }\n+    \n+    private void detects(DetectsInvalidState detector, Class expected) {\n+        try {\n+            detector.detect(mock);\n+            fail(\"Should throw an exception\");\n+        } catch (Exception e) {\n+            assertEquals(expected, e.getClass());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/InvalidUsageTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.misuse;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.StateResetter;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidUsageTest extends TestBase {\n+\n+    private IMethods mock;\n+    private IMethods mockTwo;\n+\n+    @Before\n+    public void setup() {\n+        mock = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+    }\n+    \n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions() {\n+        verifyNoMoreInteractions();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldRequireArgumentsWhenVerifyingZeroInteractions() {\n+        verifyZeroInteractions();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotCreateInOrderObjectWithoutMocks() {\n+        inOrder();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowVerifyingInOrderUnfamilarMocks() {\n+        InOrder inOrder = inOrder(mock);\n+        inOrder.verify(mockTwo).simpleMethod();\n+    }\n+    \n+    @Test(expected=MissingMethodInvocationException.class)\n+    public void shouldReportMissingMethodInvocationWhenStubbing() {\n+        stub(mock.simpleMethod()).toReturn(\"this stubbing is required to make sure Stubbable is pulled\");\n+        stub(\"\".toString()).toReturn(\"x\");\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n+        stub(mock.simpleMethod()).toThrow(new Exception());\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingNullThrowable() throws Exception {\n+        stub(mock.simpleMethod()).toThrow(null);\n+    }    \n+    \n+    final class FinalClass {}\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowMockingFinalClasses() throws Exception {\n+        mock(FinalClass.class); \n+    }\n+    \n+    interface ObjectLikeInterface {\n+        boolean equals(Object o);\n+        String toString();\n+        int hashCode();\n+    }\n+    \n+    @Test\n+    public void shouldNotMockObjectMethodsOnInterface() throws Exception {\n+        ObjectLikeInterface inter = mock(ObjectLikeInterface.class);\n+        \n+        inter.equals(null);\n+        inter.toString();\n+        inter.hashCode();\n+        \n+        verifyZeroInteractions(inter);\n+    }\n+    \n+    public void shouldNotMockObjectMethodsOnClass() throws Exception {\n+        Object clazz = mock(ObjectLikeInterface.class);\n+        \n+        clazz.equals(null);\n+        clazz.toString();\n+        clazz.hashCode();\n+        \n+        verifyZeroInteractions(clazz);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stacktrace;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n+import org.mockitousage.IMethods;\n+\n+public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        inOrder = inOrder(mock, mockTwo);\n+        \n+        firstChunk();\n+        secondChunk();\n+        thirdChunk();\n+        fourthChunk();\n+    }\n+\n+    private void firstChunk() {\n+        mock.simpleMethod(1);\n+        mock.simpleMethod(1);\n+    }\n+    private void secondChunk() {\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void thirdChunk() {\n+        mock.simpleMethod(3);\n+        mock.simpleMethod(3);\n+    }\n+    private void fourthChunk() {\n+        mockTwo.simpleMethod(4);\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPointStackTraceToPreviousInvocation() {\n+        inOrder.verify(mock, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToThirdInteractionBecauseAtLeastOnceUsed() {\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToThirdChunkWhenTooLittleActualInvocations() {\n+        inOrder.verify(mock, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToFourthChunkBecauseTooManyActualInvocations() {\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo, times(0)).simpleMethod(anyInt());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stacktrace;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockitousage.IMethods;\n+\n+public class PointingStackTraceToActualInvocationChunkTest extends TestBase {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        \n+        firstChunk();\n+        secondChunk();\n+        thirdChunk();\n+        fourthChunk();\n+    }\n+\n+    private void firstChunk() {\n+        mock.simpleMethod(1);\n+        mock.simpleMethod(1);\n+    }\n+    private void secondChunk() {\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void thirdChunk() {\n+        mock.simpleMethod(3);\n+        mock.simpleMethod(3);\n+    }\n+    private void fourthChunk() {\n+        mockTwo.simpleMethod(4);\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocationOnVerificationError() {\n+        try {\n+            verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedActualInvocationOnVerificationError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, atLeastOnce()).simpleMethod(999);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsChunkOnError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, times(3)).simpleMethod(3);\n+            fail();\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunkOnError() {\n+        try {\n+            verify(mock).simpleMethod(1);\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }   \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stacktrace;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n+import org.mockitousage.IMethods;\n+\n+public class PointingStackTraceToActualInvocationInOrderTest extends TestBase {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        inOrder = inOrder(mock, mockTwo);\n+        \n+        first();\n+        second();\n+        third();\n+        fourth();\n+    }\n+\n+    private void first() {\n+        mock.simpleMethod(1);\n+    }\n+    private void second() {\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void third() {\n+        mock.simpleMethod(3);\n+    }\n+    private void fourth() {\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPointStackTraceToPreviousVerified() {\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToThirdMethod() {\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToSecondMethod() {\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToFirstMethodBecauseOfTooManyActualInvocations() {\n+        try {\n+            inOrder.verify(mock, times(0)).simpleMethod(anyInt());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n+        }\n+    }    \n+    \n+    @Test\n+    public void shouldPointToSecondMethodBecauseOfTooManyActualInvocations() {\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo, times(0)).simpleMethod(anyInt());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToFourthMethodBecauseOfTooLittleActualInvocations() {\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(anyInt());\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stacktrace;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockitousage.IMethods;\n+\n+public class PointingStackTraceToActualInvocationTest extends TestBase {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        \n+        first();\n+        second();\n+        third();\n+        fourth();\n+    }\n+\n+    private void first() {\n+        mock.simpleMethod(1);\n+    }\n+    private void second() {\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void third() {\n+        mock.simpleMethod(3);\n+    }\n+    private void fourth() {\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocationOnVerificationError() {\n+        try {\n+            verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedActualInvocationOnVerificationError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, atLeastOnce()).simpleMethod(999);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsChunkOnError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, times(3)).simpleMethod(3);\n+            fail();\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunkOnError() {\n+        try {\n+            verify(mock, times(0)).simpleMethod(1);\n+            fail();\n+        } catch (NeverWantedButInvoked e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n+        }\n+    }   \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stacktrace;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.mockito.StateResetter;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitousage.IMethods;\n+\n+public class StackTraceFilteringTest extends TestBase {\n+    \n+    private IMethods mock;\n+\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Before\n+    public void setup() {\n+        resetState();\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerify() {\n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerify\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyNoMoreInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWanted e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyZeroInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWanted e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceOnMockitoException() {\n+        verify(mock);\n+        try {\n+            verify(mock).oneArg(true); \n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceOnMockitoException\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenVerifyingInOrder() {\n+        InOrder inOrder = inOrder(mock);\n+        mock.oneArg(true);\n+        mock.oneArg(false);\n+        \n+        inOrder.verify(mock).oneArg(false);\n+        try {\n+            inOrder.verify(mock).oneArg(true);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenVerifyingInOrder\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenInOrderThrowsMockitoException() {\n+        try {\n+            inOrder();\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenInOrderThrowsMockitoException\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenInOrderVerifies() {\n+        try {\n+            InOrder inOrder = inOrder(mock);\n+            inOrder.verify(null);\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenInOrderVerifies\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler() {\n+        try {\n+            stub(mock.oneArg(true)).toThrow(new Exception());\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromMockHandler\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldShowProperExceptionStackTrace() throws Exception {\n+        stub(mock.simpleMethod()).toThrow(new RuntimeException());\n+\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (RuntimeException e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldShowProperExceptionStackTrace\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stacktrace/StackTrackeChangingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stacktrace;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+import org.mockitousage.IMethods;\n+\n+public class StackTrackeChangingTest extends TestBase {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    private void simpleMethodOnAMock() {\n+        mock.simpleMethod(\"blah\");\n+    }\n+    \n+    @Test\n+    public void shouldShowActualInvocationAsExceptionCause() {\n+        simpleMethodOnAMock();\n+        try {\n+            verifySimpleMethodOnAMock();\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e, hasMethodInStackTraceAt(0, \"verifySimpleMethodOnAMock\"));\n+            assertThat(e, hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n+            assertThat(e.getCause(), hasMethodInStackTraceAt(0, \"simpleMethodOnAMock\"));\n+            assertThat(e.getCause(), hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n+        }\n+    }\n+\n+    private void verifySimpleMethodOnAMock() {\n+        verify(mock).simpleMethod();        \n+    }\n+}", "timestamp": 1208210060, "metainfo": ""}