{"sha": "60b99d9f4123c2ce6ad78b60a15c90515072e273", "log": "Test for issue 233 : done for the sake of testing but also for fun with ClassLoading", "commit": "\n--- a/test/org/mockito/configuration/MockitoConfiguration.java\n+++ b/test/org/mockito/configuration/MockitoConfiguration.java\n     private Answer<Object> overriddenDefaultAnswer = null;\n     private boolean cleansStackTrace;\n     private AnnotationEngine overriddenEngine;\n+    private boolean enableClassCache = true;\n \n     //for testing purposes, allow to override the configuration\n     public void overrideDefaultAnswer(Answer<Object> defaultAnswer) {\n     public void overrideCleansStackTrace(boolean cleansStackTrace) {\n         this.cleansStackTrace = cleansStackTrace;\n     }\n-    \n+\n     //for testing purposes, allow to override the annotation engine\n     public void overrideAnnotationEngine(AnnotationEngine engine) {\n         this.overriddenEngine = engine;\n+    }\n+\n+    //for testing purposes, allow to override the annotation engine\n+    public void overrideEnableClassCache(boolean enableClassCache) {\n+        this.enableClassCache = enableClassCache;\n     }\n \n     @Override\n             return overriddenDefaultAnswer;\n         }\n     }\n-    \n+\n     @Override\n     public AnnotationEngine getAnnotationEngine() {\n         if (this.overriddenEngine != null) {\n     public boolean cleansStackTrace() {\n         return cleansStackTrace;\n     }\n+\n+    @Override\n+    public boolean enableClassCache() {\n+        return enableClassCache;\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n+package org.mockitousage.configuration;\n+\n+\n+import org.fest.assertions.Condition;\n+import org.junit.Test;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.concurrent.Callable;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ClassCacheVersusClassReloadingTest {\n+\n+    private SimplePerRealmReloadingClassLoader testMethodClassLoaderRealm = new SimplePerRealmReloadingClassLoader(reloadMockito());\n+\n+    @Test\n+    public void should_throw_ClassCastException_on_second_call() throws Exception {\n+        doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+\n+        try {\n+            doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+            fail(\"should have raised a ClasCastException when Objenis Cache is enabled\");\n+        } catch (ClassCastException e) {\n+            assertThat(e).satisfies(thatCceIsThrownFrom(\"org.mockito.internal.creation.jmock.ClassImposterizer.imposterise\"));\n+        }\n+    }\n+\n+    @Test\n+    public void should_not_throw_ClassCastException_when_objenesis_cache_disabled() throws Exception {\n+        prepareMockitoAndDisableObjenesisCache();\n+\n+        doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+        doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n+    }\n+\n+    private Condition<Throwable> thatCceIsThrownFrom(final String stacktraceElementDescription) {\n+        return new Condition<Throwable>() {\n+            @Override\n+            public boolean matches(Throwable throwable) {\n+                return throwable.getStackTrace()[1].toString().contains(stacktraceElementDescription);\n+            }\n+        };\n+    }\n+\n+    public static class DoTheMocking implements Callable {\n+        public Object call() throws Exception {\n+            Class clazz = this.getClass().getClassLoader().loadClass(\"org.mockitousage.MethodsImpl\");\n+            return mock(clazz);\n+        }\n+    }\n+\n+\n+    private static void doInNewChildRealm(ClassLoader parentRealm, String callableCalledInClassLoaderRealm) throws Exception {\n+        new SimplePerRealmReloadingClassLoader(parentRealm, reloadScope()).doInRealm(callableCalledInClassLoaderRealm);\n+    }\n+\n+    private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {\n+        return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n+            public boolean needReload(String qualifiedName) {\n+                return \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\".equals(qualifiedName)\n+                    || \"org.mockitousage.MethodsImpl\".equals(qualifiedName);\n+            }\n+        };\n+    }\n+\n+    private void prepareMockitoAndDisableObjenesisCache() throws Exception {\n+        testMethodClassLoaderRealm.doInRealm(\"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$PrepareMockito\");\n+    }\n+\n+    public static class PrepareMockito implements Callable {\n+        public Object call() throws Exception {\n+            Class.forName(\"org.mockito.Mockito\");\n+            ConfigurationAccess.getConfig().overrideEnableClassCache(false);\n+            return Boolean.TRUE;\n+        }\n+    }\n+\n+    private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {\n+        return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n+            public boolean needReload(String qualifiedName) {\n+                return qualifiedName.contains(\"org.mockito\")\n+                        && !qualifiedName.contains(\"org.mockito.cglib\");\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Custom classloader to load classes in hierarchic realm.\n+     *\n+     * Each class can be reloaded in the realm if the LoadClassPredicate says so.\n+     */\n+    private static class SimplePerRealmReloadingClassLoader extends URLClassLoader {\n+\n+        private ReloadClassPredicate reloadClassPredicate;\n+\n+        public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {\n+            super(new URL[]{obtainClassPath(SimplePerRealmReloadingClassLoader.class)});\n+            this.reloadClassPredicate = reloadClassPredicate;\n+        }\n+\n+        public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {\n+            super(new URL[]{obtainClassPath(SimplePerRealmReloadingClassLoader.class)}, parentClassLoader);\n+            this.reloadClassPredicate = reloadClassPredicate;\n+        }\n+\n+        private static URL obtainClassPath(Class<SimplePerRealmReloadingClassLoader> aClass) {\n+            String path = aClass.getName().replace('.', '/') + \".class\";\n+            String url = aClass.getClassLoader().getResource(path).toExternalForm();\n+\n+            try {\n+                return new URL(url.substring(0, url.length() - path.length()));\n+            } catch (MalformedURLException e) {\n+                throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n+            }\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String qualifiedName) throws ClassNotFoundException {\n+            if(reloadClassPredicate.needReload(qualifiedName)) {\n+                // return customLoadClass(qualifiedName);\n+                return findClass(qualifiedName);\n+            }\n+            return super.loadClass(qualifiedName);\n+        }\n+\n+        public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {\n+            Callable<?> callableInRealm = (Callable<?>) this.loadClass(callableCalledInClassLoaderRealm).newInstance();\n+            return callableInRealm.call();\n+        }\n+\n+        public static interface ReloadClassPredicate {\n+            boolean needReload(String qualifiedName);\n+        }\n+    }\n+}", "timestamp": 1317577581, "metainfo": ""}