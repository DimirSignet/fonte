{"sha": "0d3aae0cbadce3b9b83fb6b686e12fa392126f68", "log": "Reverted hacks to make unfinished stubbing clickable Left code that made WantedButNotInvoked pointing out verification error  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401300", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n     }\n     \n-    public void unfinishedStubbing(Location location) {\n+    public void unfinishedStubbing() {\n         throw new UnfinishedStubbingException(join(\n-                \"Unfinished stubbing detected here:\",\n-                \"-> at \" + location,\n-                \"\",\n+                \"Unfinished stubbing detected!\",\n                 \"E.g. thenReturn() may be missing.\",\n                 \"Examples of correct stubbing:\",\n                 \"    when(mock.isOk()).thenReturn(true);\",\n                 \"    when(mock.isOk()).thenThrow(exception);\",\n                 \"    doThrow(exception).when(mock).someVoidMethod();\",\n                 \"Hints:\",\n-                \" 1. missing thenReturn()\",\n-                \" 2. although stubbed methods may return mocks, you cannot inline a mock() call inside a thenReturn method (see issue 53)\"\n+                \" 1. missing thenReturn() or mock call inside when()\",\n+                \" 2. stubbed method cannot be final.\",\n+                \" 3. although stubbed methods may return mocks, you cannot inline a mock() call inside a thenReturn method (see issue 53)\"\n         ));\n     }\n \n                 \"\"\n                 ));\n     }\n-}\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.SequenceNumber;\n+import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.MockitoStubber;\n-import org.mockito.internal.stubbing.OngoingStubbingImpl;\n+import org.mockito.internal.stubbing.Returns;\n+import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n-import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n import org.mockito.internal.util.MockName;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.RegisteredInvocations;\n  */\n public class MockHandler<T> implements MockAwareInterceptor<T> {\n \n-    final RegisteredInvocations registeredInvocations;\n-    final MockitoStubber mockitoStubber;\n+    private final RegisteredInvocations registeredInvocations;\n+    private final MockitoStubber mockitoStubber;\n     private final MatchersBinder matchersBinder;\n     private final MockingProgress mockingProgress;\n     private final MockName mockName;\n             return null;\n         }\n \n-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n-        mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher, ongoingStubbing);\n+        mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n         registeredInvocations.add(invocationMatcher.getInvocation());\n \n+        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n+\n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n-        //TODO remove - should be part of reportOngoingStubbing\n         if (!invocation.isVoid() && answer == null) {\n             //it is a return-value interaction but not stubbed. This *might* be a problem\n             mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n     }\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n-        return new VoidMethodStubbableImpl<T>(mock, mockitoStubber);\n+        return new VoidMethodStubbableImpl(mock);\n     }\n \n     public void setInstance(T instance) {\n         return mockName;\n     }\n \n+    private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n+        private final T mock;\n+\n+        public VoidMethodStubbableImpl(T mock) {\n+            this.mock = mock;\n+        }\n+\n+        public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n+            mockitoStubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n+            return this;\n+        }\n+\n+        public VoidMethodStubbable<T> toReturn() {\n+            mockitoStubber.addAnswerForVoidMethod(new DoesNothing());\n+            return this;\n+        }\n+\n+        public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n+            mockitoStubber.addAnswerForVoidMethod(answer);\n+            return this;\n+        }\n+\n+        public T on() {\n+            return mock;\n+        }\n+    }\n+\n+    private abstract class BaseStubbing implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n+        public NewOngoingStubbing<T> thenReturn(T value) {\n+            return thenAnswer(new Returns(value));\n+        }\n+\n+        public NewOngoingStubbing<T> thenReturn(T value, T... values) {\n+            NewOngoingStubbing<T> stubbing = thenReturn(value);            \n+            if (values == null) {\n+                return stubbing.thenReturn(null);\n+            }\n+            for (T v: values) {\n+                stubbing = stubbing.thenReturn(v);\n+            }\n+            return stubbing;\n+        }\n+\n+        private NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n+            return thenAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public NewOngoingStubbing<T> thenThrow(Throwable... throwables) {\n+            if (throwables == null) {\n+                thenThrow((Throwable) null);\n+            }\n+            NewOngoingStubbing<T> stubbing = null;\n+            for (Throwable t: throwables) {\n+                if (stubbing == null) {\n+                    stubbing = thenThrow(t);                    \n+                } else {\n+                    stubbing = stubbing.thenThrow(t);\n+                }\n+            }\n+            return stubbing;\n+        }        \n+\n+        public DeprecatedOngoingStubbing<T> toReturn(T value) {\n+            return toAnswer(new Returns(value));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+            return toAnswer(new ThrowsException(throwable));\n+        }\n+    }\n+    \n+    private class OngoingStubbingImpl extends BaseStubbing {\n+        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+            registeredInvocations.removeLast();\n+            mockitoStubber.addAnswer(answer);\n+            return new ConsecutiveStubbing();\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+            registeredInvocations.removeLast();\n+            mockitoStubber.addAnswer(answer);\n+            return new ConsecutiveStubbing();\n+        }\n+    }\n+\n+    private class ConsecutiveStubbing extends BaseStubbing {\n+        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+            mockitoStubber.addConsecutiveAnswer(answer);\n+            return this;\n+        }\n+        \n+        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+            mockitoStubber.addConsecutiveAnswer(answer);\n+            return this;\n+        }\n+    }    \n+    \n     @SuppressWarnings(\"unchecked\")\n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n     private final List<InvocationMatcher> unstubbedInvocations = new LinkedList<InvocationMatcher>();\n \n     private boolean collectingData;\n-    private Invocation lastInvocation;\n \n     public void addStubbedInvocation(Invocation invocation) {\n         if (!collectingData) {\n     }\n \n     public void addPotentiallyUnstubbed(InvocationMatcher invocationMatcher) {\n-        this.lastInvocation = invocationMatcher.getInvocation();\n         if (!collectingData) {\n             return;\n         }\n     public boolean hasData() {\n         return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n     }\n-\n-    public Location getLastInvocationLocation() {\n-        return lastInvocation == null ? null : lastInvocation.getLocation();\n-    }\n }\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n         this.firstTraceElement = filter.filterStackTrace(stackTrace)[0];\n     }\n \n-    public Location(StackTraceElement firstTraceElement) {\n-        this.firstTraceElement = firstTraceElement;\n-    }\n-\n     @Override\n     public String toString() {\n         return this.firstTraceElement.toString();\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         return verifiedInOrder;\n     }\n     \n-    //TODO this needs to go away\n     public HasStackTrace getStackTrace() {\n         return stackTrace;\n     }\n     public boolean returnsPrimitive() {\n         return method.getReturnType().isPrimitive();\n     }\n-\n-    public Location getLocation() {\n-        return new Location(getStackTrace().getStackTrace()[0]);\n-    }\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n         \n         if (stubbingInProgress) {\n             stubbingInProgress = false;\n-            reporter.unfinishedStubbing(debuggingInfo.getLastInvocationLocation());\n+            reporter.unfinishedStubbing();\n         }\n       \n         getArgumentMatcherStorage().validateState();\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.stubbing.Answer;\n \n @SuppressWarnings(\"unchecked\")\n         this.mockingProgress = mockingProgress;\n     }\n \n-    public void setInvocationForPotentialStubbing(InvocationMatcher invocation, OngoingStubbing ongoingStubbing) {\n-        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n         this.invocationForStubbing = invocation;\n     }\n \n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n         state = new MockingProgressImpl();\n         \n         mockitoStubber = new MockitoStubber(state);\n-        mockitoStubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher(), null);\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n         \n         simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n     }\n     \n     @Test\n     public void shouldGetResultsForMethods() throws Throwable {\n-        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod), null);\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n         mockitoStubber.addAnswer(new Returns(\"simpleMethod\"));\n         \n         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n-        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod), null);\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n         mockitoStubber.addAnswer(new ThrowsException(new MyException()));\n         \n         assertEquals(\"simpleMethod\", mockitoStubber.answerTo(simpleMethod));\n--- a/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n+++ b/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.StateMaster;\n         when(mock.simpleMethod());\n     }\n     \n+    //TODO\n+    @Ignore\n     @Test\n     public void shouldPointOutUnfinishedStubbing() {\n         unfinishedStubbingHere();\n--- a/test/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java\n+++ b/test/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java\n \n import static org.mockito.Mockito.*;\n \n-import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n @Ignore\n public class ModellingDescriptiveMessagesTest extends TestBase {\n     \n-    private IMethods mock;\n+    @Mock private IMethods mock;\n \n-    @Before\n-    public void setup() {\n-        mock = Mockito.mock(IMethods.class);\n+    @Test\n+    public void shouldSayWantedButNotInvoked() {\n+        mock.simpleMethod();\n+        verify(mock).otherMethod();\n     }\n     \n     @Test\n         \n         m.simpleMethod();\n     }\n+    \n+    @Test\n+    public void shouldPointOutUnfinishedStubbing() {\n+        when(mock.simpleMethod());\n+        \n+        verify(mock).simpleMethod();\n+    }    \n+\n+    @Test\n+    public void shouldPointOutUnfinishedStubbingWhenVoidMethodCalled() {\n+        doReturn(\"asdf\");\n+        \n+        verify(mock).simpleMethod();\n+    }    \n }", "timestamp": 1238969339, "metainfo": ""}