{"sha": "40129db358b066bb27c2108d09f8e14a780194cf", "log": "Moved classes to a better package.  --HG-- rename : src/org/mockito/internal/InvocationNotifierHandler.java => src/org/mockito/internal/handler/InvocationNotifierHandler.java rename : src/org/mockito/internal/MockHandlerFactory.java => src/org/mockito/internal/handler/MockHandlerFactory.java rename : src/org/mockito/internal/MockHandlerImpl.java => src/org/mockito/internal/handler/MockHandlerImpl.java rename : test/org/mockito/internal/InvocationNotifierHandlerTest.java => test/org/mockito/internal/handler/InvocationNotifierHandlerTest.java rename : test/org/mockito/internal/MockHandlerImplTest.java => test/org/mockito/internal/handler/MockHandlerImplTest.java", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/InvocationNotifierHandler.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.handler;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+\n+import java.util.List;\n+\n+/**\n+ * Handler, that call all listeners wanted for this mock, before delegating it\n+ * to the parameterized handler.\n+ *\n+ * Also imposterize MockHandlerImpl, delegate all call of InternalMockHandler to the real mockHandler\n+ */\n+public class InvocationNotifierHandler<T> implements MockHandler, InternalMockHandler<T> {\n+\n+    private List<InvocationListener> invocationListeners;\n+    private MockHandlerImpl<T> mockHandler;\n+\n+    public InvocationNotifierHandler(MockHandlerImpl<T> mockHandler, MockCreationSettings settings) {\n+        this.mockHandler = mockHandler;\n+        this.invocationListeners = settings.getInvocationListeners();\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+        try {\n+            Object returnedValue = mockHandler.handle(invocation);\n+            notifyMethodCall(invocation, returnedValue);\n+            return returnedValue;\n+        } catch (Throwable t){\n+            notifyMethodCallException(invocation, t);\n+            throw t;\n+        }\n+    }\n+\n+\n+\tprivate void notifyMethodCall(Invocation invocation, Object returnValue) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    private void notifyMethodCallException(Invocation invocation, Throwable exception) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockHandler.getMockSettings();\n+    }\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return mockHandler.voidMethodStubbable(mock);\n+    }\n+\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        mockHandler.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return mockHandler.getInvocationContainer();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/MockHandlerFactory.java\n+package org.mockito.internal.handler;\n+\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n+/**\n+ * by Szczepan Faber, created at: 5/21/12\n+ */\n+public class MockHandlerFactory {\n+\n+    public MockHandler create(MockCreationSettings settings) {\n+        return new InvocationNotifierHandler(\n+                new MockHandlerImpl(settings), settings);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/handler/MockHandlerImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.handler;\n+\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.verification.MockAwareVerificationMode;\n+import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n+ */\n+public class MockHandlerImpl<T> implements InternalMockHandler<T> {\n+\n+    private static final long serialVersionUID = -2917871070982574165L;\n+\n+    InvocationContainerImpl invocationContainerImpl;\n+    MatchersBinder matchersBinder = new MatchersBinder();\n+    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+\n+    private final MockCreationSettings mockSettings;\n+\n+    public MockHandlerImpl(MockCreationSettings mockSettings) {\n+        this.mockSettings = mockSettings;\n+        this.mockingProgress = new ThreadSafeMockingProgress();\n+        this.matchersBinder = new MatchersBinder();\n+        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n+            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+            return null;\n+        }\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n+\n+        mockingProgress.validateState();\n+\n+        // if verificationMode is not null then someone is doing verify()\n+        if (verificationMode != null) {\n+            // We need to check if verification was started on the correct mock\n+            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+            // TODO: can I avoid this cast here?\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+                verificationMode.verify(data);\n+                return null;\n+            } else {\n+                // this means there is an invocation on a different mock. Re-adding verification mode\n+                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+                mockingProgress.verificationStarted(verificationMode);\n+            }\n+        }\n+\n+        // prepare invocation for stubbing\n+        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+        // look for existing answer for this invocation\n+        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+        if (stubbedInvocation != null) {\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n+        } else {\n+            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n+        }\n+\t}\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n+    }\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        invocationContainerImpl.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return invocationContainerImpl;\n+    }\n+}\n+\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.MockHandlerFactory;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockito.internal.handler.MockHandlerFactory;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n import org.mockito.invocation.MockHandler;\n import org.mockito.mock.MockCreationSettings;\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.concurrentmockito;\n+\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n import org.junit.runner.Result;\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.MockHandlerImplTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.handler.MockHandlerImplTest;\n import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationsFinderTest;\n import org.mockitousage.stubbing.BasicStubbingTest;\n import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n-import org.mockitousage.verification.AtMostXVerificationTest;\n-import org.mockitousage.verification.BasicVerificationInOrderTest;\n-import org.mockitousage.verification.BasicVerificationTest;\n-import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;\n-import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;\n-import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n-import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n-import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n-import org.mockitousage.verification.RelaxedVerificationInOrderTest;\n-import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderTest;\n-import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n-import org.mockitousage.verification.VerificationUsingMatchersTest;\n+import org.mockitousage.verification.*;\n import org.mockitoutil.TestBase;\n \n import java.util.LinkedList;\n--- /dev/null\n+++ b/test/org/mockito/internal/handler/InvocationNotifierHandlerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.handler;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.BDDMockito.willThrow;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyList;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+\n+@RunWith(MockitoJUnitRunner.class)\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationNotifierHandlerTest {\n+    private static final String SOME_LOCATION = \"some location\";\n+    private static final RuntimeException SOME_EXCEPTION = new RuntimeException();\n+    private static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();\n+    private static final Answer SOME_ANSWER = mock(Answer.class);\n+\n+\n+    @Mock private InvocationListener listener1;\n+    @Mock private InvocationListener listener2;\n+    @Spy private CustomListener customListener;\n+\n+    @Mock private Invocation invocation;\n+    @Mock private MockHandlerImpl mockHandler;\n+\n+    private InvocationNotifierHandler notifier;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        notifier = new InvocationNotifierHandler(\n+                mockHandler,\n+                (MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)\n+        );\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_calling_delegate_handler() throws Throwable {\n+        // given\n+        given(mockHandler.handle(invocation)).willReturn(\"returned value\");\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_called_delegate_handler_returns_ex() throws Throwable {\n+        // given\n+        Exception computedException = new Exception(\"computed\");\n+        given(mockHandler.handle(invocation)).willReturn(computedException);\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it() throws Throwable {\n+        // given\n+        ParseException parseException = new ParseException(\"\", 0);\n+        given(mockHandler.handle(invocation)).willThrow(parseException);\n+\n+        // when\n+        try {\n+            notifier.handle(invocation);\n+            fail();\n+        } finally {\n+            // then\n+            verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+            verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+        }\n+    }\n+\n+    @Test\n+    public void should_report_listener_exception() throws Throwable {\n+        willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));\n+\n+        try {\n+            notifier.handle(invocation);\n+            fail();\n+        } catch (MockitoException me) {\n+            assertThat(me.getMessage())\n+                    .contains(\"invocation listener\")\n+                    .contains(\"CustomListener\")\n+                    .contains(\"threw an exception\")\n+                    .contains(\"NullPointerException\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() throws Exception {\n+        notifier.getInvocationContainer();\n+        notifier.getMockSettings();\n+        notifier.voidMethodStubbable(mock(IMethods.class));\n+        notifier.setAnswersForStubbing(new ArrayList<Answer>());\n+\n+        verify(mockHandler).getInvocationContainer();\n+        verify(mockHandler).getMockSettings();\n+        verify(mockHandler).voidMethodStubbable(any());\n+        verify(mockHandler).setAnswersForStubbing(anyList());\n+    }\n+\n+    private static class CustomListener implements InvocationListener {\n+        public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+            // nop\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/handler/MockHandlerImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.handler;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.Arrays;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings({ \"unchecked\", \"serial\" })\n+public class MockHandlerImplTest extends TestBase {\n+\n+\tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n+\tprivate Invocation invocation = mock(InvocationImpl.class);\n+\n+\n+\t@Test\n+\tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+\t\t// given\n+\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());\n+\t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+\t\thandler.matchersBinder = new MatchersBinder() {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\t\tthrow new InvalidUseOfMatchersException();\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\thandler.handle(invocation);\n+\n+\t\t\t// then\n+\t\t\tfail();\n+\t\t} catch (InvalidUseOfMatchersException e) {\n+\t\t}\n+\n+\t\tassertNull(handler.mockingProgress.pullVerificationMode());\n+\t}\n+\n+\n+\n+\n+\t@Test(expected = MockitoException.class)\n+\tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n+\t\t// given\n+\t\tInvocationListener throwingListener = mock(InvocationListener.class);\n+\t\tdoThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));\n+\t\tMockHandlerImpl<?> handler = createCorrectlyStubbedHandler(throwingListener);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\t}\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n+\t\tMockHandlerImpl<?> handler = createHandlerWithListeners(throwingListener);\n+\t\tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+\t\treturn handler;\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandlerImpl<?> handler) {\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);\n+\t}\n+\n+\n+\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {\n+\t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);\n+\t}\n+\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createHandlerWithListeners(InvocationListener... listener) {\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));\n+\t\thandler.matchersBinder = mock(MatchersBinder.class);\n+\t\tgiven(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));\n+\t\treturn handler;\n+\t}\n+}", "timestamp": 1337630308, "metainfo": ""}