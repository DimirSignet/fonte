{"sha": "1f1d4d0e734713c3f09313465ed1800b8fb50069", "log": "enabled test for descriptive message when verification in order fails. implemented logic.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40315", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n+import org.mockito.exceptions.cause.WantedAnywhereAfterFollowingInteraction;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n /**\n         ));\n     }\n     \n-    public void wantedButNotInvokedInOrder(String wanted) {\n+    //TODO do something about those objects (Printable object)\n+    public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace previousInOrder) {\n+        WantedAnywhereAfterFollowingInteraction cause = new WantedAnywhereAfterFollowingInteraction(join(\n+                        \"Wanted anywhere AFTER following interaction:\",\n+                        previous.toString()));\n+        cause.setStackTrace(previousInOrder.getStackTrace());\n+        \n         throw new VerifcationInOrderFailed(join(\n                     \"Verification in order failed\",\n                     \"Wanted but not invoked:\",\n-                    wanted\n+                    wanted.toString()\n+        ), cause);\n+    }\n+    \n+    public void wantedButNotInvokedInOrder(Object wanted) {\n+        throw new VerifcationInOrderFailed(join(\n+                    \"Verification in order failed\",\n+                    \"Wanted but not invoked:\",\n+                    wanted.toString()\n         ));\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/exceptions/cause/WantedAnywhereAfterFollowingInteraction.java\n+package org.mockito.exceptions.cause;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class WantedAnywhereAfterFollowingInteraction extends MockitoException {\n+\n+    public WantedAnywhereAfterFollowingInteraction(String message) {\n+        super(message);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+\n+}\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n             return !wanted.matches(invocation);\n         }\n     }\n+\n+    private class RemoveUnverifiedInOrder implements Filter<Invocation> {\n+        public boolean isOut(Invocation invocation) {\n+            return !invocation.isVerifiedInOrder();\n+        }\n+    }\n+    \n+    public Invocation findPreviousInOrder(List<Invocation> invocations, InvocationMatcher wanted) {\n+        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder());\n+        \n+        if (verifiedOnly.isEmpty()) {\n+            return null;\n+        } else {\n+            return verifiedOnly.getLast();\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/util/ListUtil.java\n+++ b/src/org/mockito/internal/util/ListUtil.java\n \n public class ListUtil {\n \n-    public static <T> List<T> filter(List<T> list, Filter<T> filter) {\n-        List<T> filtered = new LinkedList<T>();\n+    public static <T> LinkedList<T> filter(List<T> list, Filter<T> filter) {\n+        LinkedList<T> filtered = new LinkedList<T>();\n         for (T t : list) {\n             if (!filter.isOut(t)) {\n                 filtered.add(t);\n--- a/src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java\n         List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n         \n         if (chunk.size() == 0) {\n-            reporter.wantedButNotInvokedInOrder(wanted.toString());\n+            Invocation previousInOrder = finder.findPreviousInOrder(invocations, wanted);\n+            if (previousInOrder == null) {\n+                reporter.wantedButNotInvokedInOrder(wanted);\n+            } else {\n+                reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getStackTrace());\n+            }\n         }         \n-//        else if (!wanted.matches(chunk.get(0))) {\n-//            Invocation actual = chunk.get(0);\n-//            InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n-//            reporter.wantedDiffersFromActualInOrder(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n-//        }\n     }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n         private String actual;\n         private HasStackTrace actualInvocationStackTrace;\n \n-        @Override public void wantedButNotInvokedInOrder(String wanted) {\n-            this.wanted = wanted;\n+        @Override public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace lastVerifiedInOrder) {\n+            this.wanted = wanted.toString();\n         }\n         \n         @Override public void wantedDiffersFromActualInOrder(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n     }\n     \n     @Test\n-    public void verificationInOrderAndArgumentMatchers() {\n+    public void shouldPersistRecalculatedArticle() {\n         Article articleOne = new Article();\n         Article articleTwo = new Article();\n         \n         \n         articleManager.updateRelatedArticlesCounters(\"Guardian\");\n \n-        InOrder inOrder = inOrder(mockDatabase);\n+        InOrder inOrder = inOrder(mockDatabase, mockCalculator);\n         \n-        inOrder.verify(mockDatabase, atLeastOnce()).getArticlesFor(anyString());\n+        inOrder.verify(mockCalculator).countNumberOfRelatedArticles((Article) anyObject());\n         inOrder.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());\n     }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n-import org.mockito.exceptions.cause.WantedDiffersFromActual;\n+import org.mockito.exceptions.cause.WantedAnywhereAfterFollowingInteraction;\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockitousage.IMethods;\n \n         inOrder = inOrder(one, two, three);\n     }\n     \n-    @Ignore\n     @Test\n-    public void shouldPrintVerificationInOrderErrorAndShowBothWantedAndActual() {\n-        inOrder.verify(one, atLeastOnce()).simpleMethod(1);\n+    public void shouldPrintVerificationInOrderErrorAndShowBothWantedAndPrevious() {\n+        inOrder.verify(one).simpleMethod(1);\n+        inOrder.verify(two, atLeastOnce()).simpleMethod(2);\n         \n+        try {\n+            inOrder.verify(one, atLeastOnce()).simpleMethod(11);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            String expected = \n+                    \"\\n\" +\n+                    \"Verification in order failed\" +\n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(11)\"; \n+            \n+            assertEquals(expected, e.getMessage());\n+            \n+            assertEquals(e.getCause().getClass(), WantedAnywhereAfterFollowingInteraction.class);\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Wanted anywhere AFTER following interaction:\" +\n+                \"\\n\" +\n+                \"IMethods.simpleMethod(2)\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintVerificationInOrderErrorAndShowWantedOnly() {\n         try {\n             inOrder.verify(one).simpleMethod(999);\n             fail();\n                     \"\\n\" +\n                     \"Verification in order failed\" +\n                     \"\\n\" +\n-                    \"Wanted invocation:\" +\n+                    \"Wanted but not invoked:\" +\n                     \"\\n\" +\n                     \"IMethods.simpleMethod(999)\"; \n             \n             assertEquals(expected, e.getMessage());\n             \n-            assertEquals(e.getCause().getClass(), WantedDiffersFromActual.class);\n-            \n-            String expectedCause = \n-                \"\\n\" +\n-                \"Actual invocation in order:\" +\n-                \"\\n\" +\n-                \"IMethods.simpleMethod(11)\";\n-            \n-            assertEquals(expectedCause, e.getCause().getMessage());\n+            assertEquals(null, e.getCause());\n         }\n-    }  \n+    } \n     \n     @Test\n     public void shouldPrintMethodThatWasNotInvoked() {", "timestamp": 1200945753, "metainfo": ""}