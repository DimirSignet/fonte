{"sha": "47632cc7188f880059f96c174782c6e40f238796", "log": "- Now working when run single test from eclipse (runners implement Filterable) - refactored some code out of the runner and provided a test  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401845", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/util/junit/JUnitFailureHacker.java\n+package org.mockito.internal.util.junit;\n+\n+import org.junit.runner.notification.Failure;\n+import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;\n+import org.mockito.internal.util.reflection.Whitebox;\n+\n+public class JUnitFailureHacker {\n+\n+    public void appendWarnings(Failure failure, String warnings) {\n+        //TODO: this has to protect the use in case jUnit changes and this internal state logic fails\n+        Throwable throwable = (Throwable) Whitebox.getInternalState(failure, \"fThrownException\");\n+\n+        String newMessage = \"contains both: actual test failure *and* Mockito warnings.\\n\" +\n+                warnings + \"\\n *** The actual failure is because of: ***\\n\";\n+\n+        ExceptionIncludingMockitoWarnings e = new ExceptionIncludingMockitoWarnings(newMessage, throwable);\n+        e.setStackTrace(throwable.getStackTrace());\n+        Whitebox.setInternalState(failure, \"fThrownException\", e);\n+    }   \n+}\n--- a/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n  */\n package org.mockito.runners;\n \n+import java.lang.reflect.InvocationTargetException;\n+\n import org.junit.runner.Description;\n import org.junit.runner.Runner;\n+import org.junit.runner.manipulation.Filter;\n+import org.junit.runner.manipulation.Filterable;\n+import org.junit.runner.manipulation.NoTestsRemainException;\n import org.junit.runner.notification.Failure;\n import org.junit.runner.notification.RunListener;\n import org.junit.runner.notification.RunNotifier;\n import org.junit.runners.BlockJUnit4ClassRunner;\n import org.mockito.internal.debugging.WarningsCollector;\n-import org.mockito.internal.debugging.WarningsPrinterImpl;\n-import org.mockito.internal.invocation.AllInvocationsFinder;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.UnusedStubsFinder;\n-import org.mockito.internal.listeners.CollectCreatedMocks;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.runners.RunnerFactory;\n import org.mockito.internal.runners.RunnerImpl;\n+import org.mockito.internal.util.ConsoleMockitoLogger;\n import org.mockito.internal.util.MockitoLogger;\n-import org.mockito.internal.util.ConsoleMockitoLogger;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.LinkedList;\n-import java.util.List;\n \n /**\n  * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n  * <p>\n  * Note that code links printed to the console are clickable in any decent IDE (e.g. Eclipse).\n  * <p>\n- * So far I identified 3 cases when warnings are printed:\n- * <li>unstubbed method</li>\n+ * So far I identified 2 cases when warnings are printed:\n  * <li>unsued stub</li>\n  * <li>stubbed method but called with different arguments</li> \n  * <p>\n  * <p>\n  * Do you think it is useful or not? Drop us an email at mockito@googlegroups.com\n  */\n-public class ConsoleSpammingMockitoJUnitRunner extends Runner {\n+public class ConsoleSpammingMockitoJUnitRunner extends Runner implements Filterable {\n \n     private final MockitoLogger logger;\n     private RunnerImpl runner;\n     public Description getDescription() {\n         return runner.getDescription();\n     }\n+    \n+    public void filter(Filter filter) throws NoTestsRemainException {\n+        //filter is required because without it UnrootedTests show up in Eclipse\n+        runner.filter(filter);\n+    }\n }\n--- a/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n  */\n package org.mockito.runners;\n \n+import java.lang.reflect.InvocationTargetException;\n+\n import org.junit.runner.Description;\n import org.junit.runner.Runner;\n+import org.junit.runner.manipulation.Filter;\n+import org.junit.runner.manipulation.Filterable;\n+import org.junit.runner.manipulation.NoTestsRemainException;\n import org.junit.runner.notification.Failure;\n import org.junit.runner.notification.RunListener;\n import org.junit.runner.notification.RunNotifier;\n-import org.mockito.MockSettings;\n-import org.mockito.Mockito;\n+import org.mockito.internal.debugging.WarningsCollector;\n import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;\n-import org.mockito.internal.debugging.WarningsCollector;\n-import org.mockito.internal.debugging.WarningsPrinterImpl;\n-import org.mockito.internal.invocation.AllInvocationsFinder;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.UnusedStubsFinder;\n-import org.mockito.internal.listeners.CollectCreatedMocks;\n-import org.mockito.internal.listeners.MockingStartedListener;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.runners.RunnerFactory;\n import org.mockito.internal.runners.RunnerImpl;\n+import org.mockito.internal.util.junit.JUnitFailureHacker;\n import org.mockito.internal.util.reflection.Whitebox;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.LinkedList;\n-import java.util.List;\n \n /**\n  * Experimental implementation that suppose to improve tdd/testing experience. \n  * <p>\n  * Experimental implementation - will change in future!\n  */\n-public class VerboseMockitoJUnitRunner extends Runner {\n+public class VerboseMockitoJUnitRunner extends Runner implements Filterable {\n \n     private RunnerImpl runner;\n     \n             @Override \n             public void testFailure(final Failure failure) throws Exception {       \n                 String warnings = warningsCollector.getWarnings();\n-                \n-                //TODO: this has to protect the use in case jUnit changes and this internal state logic fails\n-                Throwable throwable = (Throwable) Whitebox.getInternalState(failure, \"fThrownException\");\n-\n-                String newMessage = \"contains both: actual test failure *and* Mockito warnings.\\n\" +\n-                        warnings + \"\\n *** The actual failure is because of: ***\\n\";\n-\n-                ExceptionIncludingMockitoWarnings e = new ExceptionIncludingMockitoWarnings(newMessage, throwable);\n-                e.setStackTrace(throwable.getStackTrace());\n-                Whitebox.setInternalState(failure, \"fThrownException\", e);\n+                new JUnitFailureHacker().appendWarnings(failure, warnings);                              \n             }\n         };\n \n     public Description getDescription() {\n         return runner.getDescription();\n     }\n+    \n+    public void filter(Filter filter) throws NoTestsRemainException {\n+        //filter is required because without it UnrootedTests show up in Eclipse\n+        runner.filter(filter);\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/junit/JUnitFailureHackerTest.java\n+package org.mockito.internal.util.junit;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runner.notification.Failure;\n+import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings;\n+import org.mockitoutil.TestBase;\n+\n+public class JUnitFailureHackerTest extends TestBase {\n+    \n+    JUnitFailureHacker hacker = new JUnitFailureHacker();\n+    \n+    @Test\n+    public void shouldReplaceException() throws Exception {\n+        //given\n+        RuntimeException actualExc = new RuntimeException(\"foo\");\n+        Failure failure = new Failure(Description.EMPTY, actualExc);\n+        \n+        //when\n+        hacker.appendWarnings(failure, \"unused stubbing\");\n+                \n+        //then\n+        assertEquals(ExceptionIncludingMockitoWarnings.class, failure.getException().getClass());\n+        assertEquals(actualExc, failure.getException().getCause());\n+        Assertions.assertThat(actualExc.getStackTrace()).isEqualTo(failure.getException().getStackTrace());\n+    }\n+    \n+    @Test\n+    public void shouldAppendWarning() throws Exception {\n+        Failure failure = new Failure(Description.EMPTY, new RuntimeException(\"foo\"));\n+        \n+        //when\n+        hacker.appendWarnings(failure, \"unused stubbing blah\");\n+        \n+        //then\n+        assertContains(\"unused stubbing blah\", failure.getException().getMessage());        \n+    }\n+}", "timestamp": 1266179039, "metainfo": ""}