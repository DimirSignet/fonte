{"sha": "51aca5035ea543ecdd109a77b30d34006cb98f29", "log": "implemented reset() mocks feature (issue 55) We found a valid case for reset: legacy code combined with DI-container created mocks.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401266", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito;\n-\n-import java.util.Arrays;\n-\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.internal.MockHandler;\n-import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.NewOngoingStubbing;\n-import org.mockito.internal.progress.OngoingStubbing;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.returnvalues.EmptyReturnValues;\n-import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n-import org.mockito.internal.returnvalues.MoreEmptyReturnValues;\n-import org.mockito.internal.returnvalues.SmartNullReturnValues;\n-import org.mockito.internal.stubbing.DoesNothing;\n-import org.mockito.internal.stubbing.Returns;\n-import org.mockito.internal.stubbing.Stubber;\n-import org.mockito.internal.stubbing.StubberImpl;\n-import org.mockito.internal.stubbing.ThrowsException;\n-import org.mockito.internal.stubbing.VoidMethodStubbable;\n-import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.verification.VerificationModeFactory;\n-import org.mockito.internal.verification.api.VerificationMode;\n-import org.mockito.runners.MockitoJUnit44Runner;\n-import org.mockito.runners.MockitoJUnitRunner;\n-import org.mockito.stubbing.Answer;\n-\n-/**\n- * Enables mocks creation, verification and stubbing.\n- * \n- * <h1>Contents</h1>\n- * \n- * <b> \n- *      1. Let's verify some behaviour! <br/> \n- *      2. How about some stubbing? <br/>\n- *      3. Argument matchers <br/> \n- *      4. Verifying exact number of invocations / at least once / never <br/> \n- *      5. Stubbing void methods with exceptions <br/> \n- *      6. Verification in order <br/> \n- *      7. Making sure interaction(s) never happened on mock <br/> \n- *      8. Finding redundant invocations <br/> \n- *      9. Shorthand for mocks creation - &#064;Mock annotation <br/> \n- *      10. Stubbing consecutive calls (iterator-style stubbing) <br/> \n- *      11. Stubbing with callbacks <br/>\n- *      12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids <br/>\n- *      13. Spying on real objects <br/>\n- *      14. (**New**) Changing default return values of unstubbed invocations <br/>\n- * </b>\n- * \n- * <p>\n- * Following examples mock a List, because everyone knows its interface (methods\n- * like add(), get(), clear() will be used). <br>\n- * You probably wouldn't mock List class 'in real'.\n- * \n- * <h3>1. Let's verify some behaviour!</h3>\n- * \n- * <pre>\n- * //Let's import Mockito statically so that the code looks clearer\n- * import static org.mockito.Mockito.*;\n- * \n- * //mock creation\n- * List mockedList = mock(List.class);\n- * \n- * //using mock object\n- * mockedList.add(\"one\");\n- * mockedList.clear();\n- * \n- * //verification\n- * verify(mockedList).add(\"one\");\n- * verify(mockedList).clear();\n- * </pre>\n- * \n- * <p>\n- * Once created, mock will remember all interactions. Then you can selectively\n- * verify whatever interaction you are interested in.\n- * \n- * <h3>2. How about some stubbing?</h3>\n- * \n- * <pre>\n- * //You can mock concrete classes, not only interfaces\n- * LinkedList mockedList = mock(LinkedList.class);\n- * \n- * //stubbing\n- * when(mockedList.get(0)).thenReturn(\"first\");\n- * when(mockedList.get(1)).thenThrow(new RuntimeException());\n- * \n- * //following prints \"first\"\n- * System.out.println(mockedList.get(0));\n- * \n- * //following throws runtime exception\n- * System.out.println(mockedList.get(1));\n- * \n- * //following prints \"null\" because get(999) was not stubbed\n- * System.out.println(mockedList.get(999));\n- *  \n- * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n- * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n- * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n- * verify(mockedList).get(0);\n- * </pre>\n- * \n- * <ul>\n- * <li> By default, for all methods that return value, mock returns null, an\n- * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n- * false, ... for int/Integer, boolean/Boolean, ...). </li>\n- * \n- * <li> Stubbing can be overridden: for example common stubbing can go to\n- * fixture setup but the test methods can override it. </li>\n- * \n- * <li> Once stubbed, the method will always return stubbed value regardless\n- * of how many times it is called. </li>\n- * \n- * <li> Last stubbing is more important - when you stubbed the same method with\n- * the same arguments many times. </li>\n- * \n- * </ul>\n- * \n- * <h3>3. Argument matchers</h3>\n- * \n- * <pre>\n- * //stubbing using built-in anyInt() argument matcher\n- * when(mockedList.get(anyInt())).thenReturn(\"element\");\n- * \n- * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n- * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n- * \n- * //following prints \"element\"\n- * System.out.println(mockedList.get(999));\n- * \n- * //<b>you can also verify using an argument matcher</b>\n- * verify(mockedList).get(anyInt());\n- * </pre>\n- * \n- * <p>\n- * Argument matchers allow flexible verification or stubbing. \n- * {@link Matchers Click here to see} more built-in matchers \n- * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n- * <p>\n- * <b>Warning:</b>\n- * <p>\n- * If you are using argument matchers, <b>all arguments</b> have to be provided\n- * by matchers.\n- * <p>\n- * E.g: (example shows verification but the same applies to stubbing):\n- * \n- * <pre>\n- *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n- *   //above is correct - eq() is also an argument matcher\n- *   \n- *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n- *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n- * </pre>\n- * \n- * <h3>4. Verifying exact number of invocations / at least x / never</h3>\n- * \n- * <pre>\n- * //using mock \n- * mockedList.add(\"once\");\n- * \n- * mockedList.add(\"twice\");\n- * mockedList.add(\"twice\");\n- * \n- * mockedList.add(\"three times\");\n- * mockedList.add(\"three times\");\n- * mockedList.add(\"three times\");\n- * \n- * //following two verifications work exactly the same - times(1) is used by default\n- * verify(mockedList).add(\"once\");\n- * verify(mockedList, times(1)).add(\"once\");\n- * \n- * //exact number of invocations verification\n- * verify(mockedList, times(2)).add(\"twice\");\n- * verify(mockedList, times(3)).add(\"three times\");\n- * \n- * //verification using never(). never() is an alias to times(0)\n- * verify(mockedList, never()).add(\"never happened\");\n- * \n- * //verification using atLeast()/atMost()\n- * verify(mockedList, atLeastOnce()).add(\"three times\");\n- * verify(mockedList, atLeast(2)).add(\"five times\");\n- * verify(mockedList, atMost(5)).add(\"three times\");\n- * \n- * </pre>\n- * \n- * <p>\n- * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n- * omitted.\n- * \n- * <h3>5. Stubbing void methods with exceptions</h3>\n- * \n- * <pre>\n- *   doThrow(new RuntimeException()).when(mockedList).clear();\n- *   \n- *   //following throws RuntimeException:\n- *   mockedList.clear();\n- * </pre>\n- * \n- * Read more about doThrow|doAnswer family of methods in paragraph 12.\n- * <p>\n- * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n- * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n- * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n- * \n- * <h3>6. Verification in order</h3>\n- * \n- * <pre>\n- * List firstMock = mock(List.class);\n- * List secondMock = mock(List.class);\n- * \n- * //using mocks\n- * firstMock.add(\"was called first\");\n- * secondMock.add(\"was called second\");\n- * \n- * //create inOrder object passing any mocks that need to be verified in order\n- * InOrder inOrder = inOrder(firstMock, secondMock);\n- * \n- * //following will make sure that firstMock was called before secondMock\n- * inOrder.verify(firstMock).add(\"was called first\");\n- * inOrder.verify(secondMock).add(\"was called second\");\n- * </pre>\n- * \n- * Verification in order is flexible - <b>you don't have to verify all\n- * interactions</b> one-by-one but only those that you are interested in\n- * testing in order.\n- * <p>\n- * Also, you can create InOrder object passing only mocks that are relevant for\n- * in-order verification.\n- * \n- * <h3>7. Making sure interaction(s) never happened on mock</h3>\n- * \n- * <pre>\n- * //using mocks - only mockOne is interacted\n- * mockOne.add(\"one\");\n- * \n- * //ordinary verification\n- * verify(mockOne).add(\"one\");\n- * \n- * //verify that method was never called on a mock\n- * verify(mockOne, never()).add(\"two\");\n- * \n- * //verify that other mocks were not interacted\n- * verifyZeroInteractions(mockTwo, mockThree);\n- * \n- * </pre>\n- * \n- * <h3>8. Finding redundant invocations</h3>\n- * \n- * <pre>\n- * //using mocks\n- * mockedList.add(\"one\");\n- * mockedList.add(\"two\");\n- * \n- * verify(mockedList).add(\"one\");\n- * \n- * //following verification will fail \n- * verifyNoMoreInteractions(mockedList);\n- * </pre>\n- * \n- * A word of <b>warning</b>: \n- * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n- * verifyNoMoreInteractions() is not recommended to use in every test method. \n- * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n- * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n- * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n- * \n- * <p>   \n- * See also {@link Mockito#never()} - it is more explicit and\n- * communicates the intent well.\n- * <p>\n- * \n- * <h3>9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n- * \n- * <ul>\n- * <li>Minimizes repetitive mock creation code.</li>\n- * <li>Makes the test class more readable.</li>\n- * <li>Makes the verification error easier to read because the <b>field name</b>\n- * is used to identify the mock.</li>\n- * </ul>\n- * \n- * <pre>\n- *   public class ArticleManagerTest { \n- *     \n- *       &#064;Mock private ArticleCalculator calculator;\n- *       &#064;Mock private ArticleDatabase database;\n- *       &#064;Mock private UserProvider userProvider;\n- *     \n- *       private ArticleManager manager;\n- * </pre>\n- * \n- * <b>Important!</b> This needs to be somewhere in the base class or a test\n- * runner:\n- * \n- * <pre>\n- * MockitoAnnotations.initMocks(testClass);\n- * </pre>\n- * \n- * You can use built-in runners {@link MockitoJUnitRunner}, {@link MockitoJUnit44Runner}.\n- * <p>\n- * Read more here: {@link MockitoAnnotations}\n- * \n- * <h3> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n- * \n- * Sometimes we need to stub with different return value/exception for the same\n- * method call. Typical use case could be mocking iterators. \n- * Original version of Mockito did not have this feature to promote simple mocking. \n- * For example, instead of iterators one could use {@link Iterable} or simply\n- * collections. Those offer natural ways of stubbing (e.g. using real\n- * collections). In rare scenarios stubbing consecutive calls could be useful,\n- * though:\n- * <p>\n- * \n- * <pre>\n- * when(mock.someMethod(\"some arg\"))\n- *   .thenThrow(new RuntimeException())\n- *   .thenReturn(\"foo\");\n- * \n- * //First call: throws runtime exception:\n- * mock.someMethod(\"some arg\");\n- * \n- * //Second call: prints \"foo\"\n- * System.out.println(mock.someMethod(\"some arg\"));\n- * \n- * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n- * System.out.println(mock.someMethod(\"some arg\"));\n- * </pre>\n- * \n- * Alternative, shorter version of consecutive stubbing:\n- * \n- * <pre>\n- * when(mock.someMethod(\"some arg\"))\n- *   .thenReturn(\"one\", \"two\", \"three\");\n- * </pre>\n- * \n- * <h3> 11. Stubbing with callbacks</h3>\n- * \n- * Allows stubbing with generic {@link Answer} interface.\n-*  <p>\n- * Yet another controversial feature which was not included in Mockito\n- * originally. We recommend using simple stubbing with toReturn() or\n- * toThrow() only. Those two should be <b>just enough</b> to test/test-drive\n- * any clean & simple code.\n- * \n- * <pre>\n- * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n- *     Object answer(InvocationOnMock invocation) {\n- *         Object[] args = invocation.getArguments();\n- *         Object mock = invocation.getMock();\n- *         return \"called with arguments: \" + args;\n- *     }\n- * });\n- * \n- * //Following prints \"called with arguments: foo\"\n- * System.out.println(mock.someMethod(\"foo\"));\n- * </pre>\n- * \n- * <h3> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n- * \n- * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n- * <p>\n- * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n- * The main reason is improved readability and consistency with the family of doAnswer() methods.\n- * <p>\n- * Use doThrow() when you want to stub a void method with an exception:\n- * <pre>\n- *   doThrow(new RuntimeException()).when(mockedList).clear();\n- *   \n- *   //following throws RuntimeException:\n- *   mockedList.clear();\n- * </pre>\n- * \n- * Read more about other methods:\n- * <p>\n- * {@link Mockito#doThrow(Throwable)}\n- * <p>\n- * {@link Mockito#doAnswer(Answer)}\n- * <p>\n- * {@link Mockito#doNothing()}\n- * <p>\n- * {@link Mockito#doReturn(Object)}\n- * \n- * <h3> 13. Spying on real objects</h3>\n- * \n- * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n- * <p>\n- * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n- * <p>\n- * Spying on real objects is often associated with \"partial mocking\" concept. \n- * However, Mockito spies are not partial mocks. Mockito spy is meant to help testing other classes - not the spy itself. \n- * Therefore spy will not help if you intend to verify if method calls other method on the same object. \n- * In this case I suggest being OO/SRPy (for example you might extract new class/interface...)\n- * \n- * <pre>\n- *   List list = new LinkedList();\n- *   List spy = spy(list);\n- * \n- *   //optionally, you can stub out some methods:\n- *   when(spy.size()).thenReturn(100);\n- * \n- *   //using the spy calls <b>real</b> methods\n- *   spy.add(\"one\");\n- *   spy.add(\"two\");\n- * \n- *   //prints \"one\" - the first element of a list\n- *   System.out.println(spy.get(0));\n- * \n- *   //size() method was stubbed - 100 is printed\n- *   System.out.println(spy.size());\n- * \n- *   //optionally, you can verify\n- *   verify(spy).add(\"one\");\n- *   verify(spy).add(\"two\");\n- * </pre>\n- * \n- * <h4>Important gotcha on spying real objects!</h4>\n- * \n- * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n- * \n- * <pre>\n- *   List list = new LinkedList();\n- *   List spy = spy(list);\n- *   \n- *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n- *   when(spy.get(0)).thenReturn(\"foo\");\n- *   \n- *   //You have to use doReturn() for stubbing\n- *   doReturn(\"foo\").when(spy).get(0);\n- * </pre>\n- * \n- * 2. Watch out for final methods. \n- * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n- * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n- * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n- * \n- * <h3>14. (**New**) Changing default return values of unstubbed invocations</h3>\n- * \n- * You can create a mock with specified strategy of for its return values.\n- * It's quite advanced feature and typically you don't need it to write decent tests.\n- * However, it can be helpful for working with legacy systems.\n- * <p>\n- * Obviously those return values are used only when you don't stub the method call.\n- * \n- * <pre>\n- *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n- *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n- * </pre>\n- * \n- * <p>\n- * Read more about this interesting implementation of <i>ReturnValues</i>: {@link Mockito#RETURNS_SMART_NULLS}\n- * \n- */\n-@SuppressWarnings(\"unchecked\")\n-public class Mockito extends Matchers {\n-    \n-    /**\n-     * Default ReturnValues used by the framework.\n-     * <p>\n-     * {@link ReturnValues} defines the return values of unstubbed invocations. \n-     * <p>\n-     * This implementation first tries the global configuration. \n-     * If there is no global configuration then it uses {@link EmptyReturnValues} (returns zeros, empty collections, nulls, etc.)\n-     */\n-    public static final ReturnValues RETURNS_DEFAULTS = new GloballyConfiguredReturnValues();\n-    \n-    /**\n-     * Optional ReturnValues to be used with {@link Mockito#mock(Class, ReturnValues)}\n-     * <p>\n-     * {@link ReturnValues} defines the return values of unstubbed invocations.\n-     * <p>\n-     * This implementation can be helpful when working with legacy code.\n-     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n-     * This implementation of ReturnValues makes unstubbed methods <b>return SmartNull instead of null</b>.\n-     * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\n-     * <p>\n-     * SmartNullReturnValues first tries to return ordinary return values (see {@link MoreEmptyReturnValues})\n-     * then it tries to return SmartNull. If the return type is final then plain null is returned.\n-     * <p>\n-     * SmartNullReturnValues will be probably the default return values strategy in Mockito 2.0\n-     * <p>\n-     * Example:\n-     * <pre>\n-     *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\n-     *   \n-     *   //calling unstubbed method here:\n-     *   Stuff stuff = mock.getStuff();\n-     *   \n-     *   //using object returned by unstubbed call:\n-     *   stuff.doSomething();\n-     *   \n-     *   //Above doesn't yield NullPointerException this time!\n-     *   //Instead, SmartNullPointerException is thrown. \n-     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n-     * </pre>\n-     */\n-    public static final ReturnValues RETURNS_SMART_NULLS = new SmartNullReturnValues();\n-    \n-    static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n-    private static final Reporter REPORTER = new Reporter();\n-\n-    /**\n-     * Creates mock object of given class or interface.\n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param classToMock class or interface to mock\n-     * @return mock object\n-     */\n-    public static <T> T mock(Class<T> classToMock) {\n-        return mock(classToMock, null, null, RETURNS_DEFAULTS);\n-    }\n-    \n-    /**\n-     * Creates mock with a name. Naming mocks can be helpful for debugging. \n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n-     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n-     * <p>\n-     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n-     * <p>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param classToMock class or interface to mock\n-     * @return mock object\n-     */\n-    public static <T> T mock(Class<T> classToMock, String name) {\n-        return mock(classToMock, name, null, RETURNS_DEFAULTS);\n-    }\n-    \n-    /**\n-     * Creates mock with a specified strategy for its return values. \n-     * It's quite advanced feature and typically you don't need it to write decent tests.\n-     * However it can be helpful for working with legacy systems.\n-     * <p>\n-     * Obviously return values are used only when you don't stub the method call.\n-     *\n-     * <pre>\n-     *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n-     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n-     * </pre>\n-     * \n-     * <p>See examples in javadoc for {@link Mockito} class</p>\n-     * \n-     * @param classToMock class or interface to mock\n-     * @param returnValues default return values for unstubbed methods\n-     *\n-     * @return mock object\n-     */\n-    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n-        return mock(classToMock, null, (T) null, returnValues);\n-    }\n-    \n-    private static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n-        MOCKING_PROGRESS.validateState();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n-        return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n-    }    \n-\n-    /**\n-     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n-     * <p>\n-     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n-     * <p>\n-     * Spying on real objects is often associated with \"partial mocking\" concept. \n-     * However, Mockito spies are not partial mocks. Mockito spy is meant to help testing other classes - not the spy itself. \n-     * Therefore spy will not help if you intend to verify if method calls other method on the same object. \n-     * In this case I suggest being OO/SRPy (for example you might extract new class/interface...)\n-     * <p>\n-     * Example:\n-     * \n-     * <pre>\n-     *   List list = new LinkedList();\n-     *   List spy = spy(list);\n-     * \n-     *   //optionally, you can stub out some methods:\n-     *   when(spy.size()).thenReturn(100);\n-     * \n-     *   //using the spy calls <b>real</b> methods\n-     *   spy.add(\"one\");\n-     *   spy.add(\"two\");\n-     * \n-     *   //prints \"one\" - the first element of a list\n-     *   System.out.println(spy.get(0));\n-     * \n-     *   //size() method was stubbed - 100 is printed\n-     *   System.out.println(spy.size());\n-     * \n-     *   //optionally, you can verify\n-     *   verify(spy).add(\"one\");\n-     *   verify(spy).add(\"two\");\n-     * </pre>\n-     * \n-     * <h4>Important gotcha on spying real objects!</h4>\n-     * \n-     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n-     * \n-     * <pre>\n-     *   List list = new LinkedList();\n-     *   List spy = spy(list);\n-     *   \n-     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   when(spy.get(0)).thenReturn(\"foo\");\n-     *   \n-     *   //You have to use doReturn() for stubbing\n-     *   doReturn(\"foo\").when(spy).get(0);\n-     * </pre>\n-     * \n-     * 2. Watch out for final methods. \n-     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n-     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n-     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n-     * \n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param object\n-     *            to spy on\n-     * @return a spy of the real object\n-     */\n-    public static <T> T spy(T object) {\n-        return mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n-    }\n-\n-    /**\n-     * <pre>\n-     *   //Instead of:\n-     *   stub(mock.count()).toReturn(10);\n-     * \n-     *   //Please do:\n-     *   when(mock.count()).thenReturn(10);\n-     * </pre> \n-     * \n-     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n-     * <p>\n-     * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n-     * <pre>\n-     *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n-     *   stub(          <i>replace with:</i>  when(\n-     *   .toReturn(     <i>replace with:</i>  .thenReturn(\n-     *   .toThrow(      <i>replace with:</i>  .thenThrow(\n-     *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n-     * </pre>\n-     * If you're an existing user then sorry for making your code littered with deprecation warnings. \n-     * This change was required to make Mockito better.\n-     * \n-     * @param methodCall\n-     *            method call\n-     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    @Deprecated\n-    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return (DeprecatedOngoingStubbing) stub();\n-    }\n-    \n-    /**\n-     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n-     * <p>\n-     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n-     * <p>\n-     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n-     * <p>\n-     * Examples:\n-     * \n-     * <pre>\n-     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n-     *\n-     * //you can use flexible argument matchers, e.g:\n-     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n-     *\n-     * //setting exception to be thrown:\n-     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n-     *\n-     * //you can set different behavior for consecutive method calls.\n-     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenThrow(new RuntimeException())\n-     *  .thenReturn(\"foo\");\n-     *  \n-     * //Alternative, shorter version for consecutive stubbing:\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenReturn(\"one\", \"two\");\n-     * //is the same as:\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenReturn(\"one\")\n-     *  .thenReturn(\"two\");\n-     *\n-     * //shorter version for consecutive method calls throwing exceptions:\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenThrow(new RuntimeException(), new NullPointerException();\n-     *   \n-     * </pre>\n-     * \n-     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n-     * <p>\n-     * Stubbing can be overridden: for example common stubbing can go to fixture\n-     * setup but the test methods can override it.\n-     * <p>\n-     * Once stubbed, the method will always return stubbed value regardless\n-     * of how many times it is called.\n-     * <p>\n-     * Last stubbing is more important - when you stubbed the same method with\n-     * the same arguments many times.\n-     * <p>\n-     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n-     * Let's say you've stubbed foo.bar(). \n-     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n-     * If your code doesn't care what get(0) returns then it should not be stubbed. \n-     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n-     * \n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * @param methodCall method to be stubbed\n-     */\n-    public static <T> NewOngoingStubbing<T> when(T methodCall) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return (NewOngoingStubbing) stub();\n-    }\n-\n-    private static OngoingStubbing stub() {\n-        OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n-        if (stubbing == null) {\n-            MOCKING_PROGRESS.reset();\n-            REPORTER.missingMethodInvocation();\n-        }\n-        return stubbing;\n-    }\n-\n-    /**\n-     * Verifies certain behavior <b>happened once</b> \n-     * <p>\n-     * Alias to <code>verify(mock, times(1))</code> E.g:\n-     * <pre>\n-     *   verify(mock).someMethod(\"some arg\");\n-     * </pre>\n-     * Above is equivalent to:\n-     * <pre>\n-     *   verify(mock, times(1)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n-     * <p>\n-     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n-     * Let's say you've stubbed foo.bar(). \n-     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n-     * If your code doesn't care what get(0) returns then it should not be stubbed. \n-     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n-     * \n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mock to be verified\n-     * @return mock object itself\n-     */\n-    public static <T> T verify(T mock) {\n-        return verify(mock, times(1));\n-    }\n-\n-    /**\n-     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n-     * <pre>\n-     *   verify(mock, times(5)).someMethod(\"was called five times\");\n-     *   \n-     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n-     *   \n-     *   //you can use flexible argument matchers, e.g:\n-     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n-     * </pre>\n-     * \n-     * <b>times(1) is the default</b> and can be omitted\n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mock to be verified\n-     * @param mode times(x), atLeastOnce() or never()\n-     * \n-     * @return mock object itself\n-     */\n-    public static <T> T verify(T mock, VerificationMode mode) {\n-        if (mock == null) {\n-            REPORTER.nullPassedToVerify();\n-        } else if (!MockUtil.isMock(mock)) {\n-            REPORTER.notAMockPassedToVerify();\n-        }\n-        MOCKING_PROGRESS.verificationStarted(mode);\n-        return mock;\n-    }\n-\n-    /**\n-     * Checks if any of given mocks has any unverified interaction.\n-     * <p>\n-     * You can use this method after you verified your mocks - to make sure that nothing\n-     * else was invoked on your mocks.\n-     * <p>\n-     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n-     * <p>\n-     * Stubbed invocations (if called) are also treated as interactions.\n-     * <p>\n-     * A word of <b>warning</b>: \n-     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n-     * verifyNoMoreInteractions() is not recommended to use in every test method. \n-     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n-     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n-     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n-     * <p>\n-     * This method will also detect unverified invocations that occurred before the test method,\n-     * for example: in setUp(), &#064;Before method or in constructor.\n-     * Consider writing nice code that makes interactions only in test methods.\n-     * \n-     * <p>\n-     * Example:\n-     * \n-     * <pre>\n-     * //interactions\n-     * mock.doSomething();\n-     * mock.doSomethingUnexpected();\n-     * \n-     * //verification\n-     * verify(mock).doSomething();\n-     * \n-     * //following will fail because 'doSomethingUnexpected()' is unexpected\n-     * verifyNoMoreInteractions(mock);\n-     * \n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mocks to be verified\n-     */\n-    public static void verifyNoMoreInteractions(Object... mocks) {\n-        assertMocksNotEmpty(mocks);\n-        MOCKING_PROGRESS.validateState();\n-        for (Object mock : mocks) {\n-            try {\n-                if (mock == null) {\n-                    REPORTER.nullPassedToVerifyNoMoreInteractions();\n-                }\n-                MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n-            } catch (NotAMockException e) {\n-                REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Verifies that no interactions happened on given mocks.\n-     * <pre>\n-     *   verifyZeroInteractions(mockOne, mockTwo);\n-     * </pre>\n-     * This method will also detect invocations \n-     * that occurred before the test method, for example: in setUp(), &#064;Before method or in constructor.\n-     * Consider writing nice code that makes interactions only in test methods.  \n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mocks to be verified\n-     */\n-    public static void verifyZeroInteractions(Object... mocks) {\n-        verifyNoMoreInteractions(mocks);\n-    }\n-\n-    private static void assertMocksNotEmpty(Object[] mocks) {\n-        if (mocks == null || mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n-        }\n-    }\n-\n-    /**\n-     * <pre>\n-     *   //Instead of:\n-     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n-     * \n-     *   //Please do:\n-     *   doThrow(e).when(mock).someVoidMethod();\n-     * </pre> \n-     * \n-     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n-     * <p>\n-     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n-     * \n-     * <pre>\n-     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n-     * \n-     * //you can stub with different behavior for consecutive calls.\n-     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n-     * stubVoid(mock)\n-     *   .toThrow(new RuntimeException())\n-     *   .toReturn()\n-     *   .on().someMethod();\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n-     * \n-     * @param mock\n-     *            to stub\n-     * @return stubbable object that allows stubbing with throwable\n-     */\n-    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-        MockHandler<T> handler = MockUtil.getMockHandler(mock);\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return handler.voidMethodStubbable(mock);\n-    }\n-    \n-    /**\n-     * Use doThrow() when you want to stub the void method with an exception.\n-     * <p>\n-     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n-     * <p>\n-     * Example:\n-     * \n-     * <pre>\n-     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n-     * </pre>\n-     * \n-     * @param toBeThrown to be thrown when the stubbed method is called\n-     * @return stubber - to select a method for stubbing\n-     */\n-    public static Stubber doThrow(Throwable toBeThrown) {\n-        return doAnswer(new ThrowsException(toBeThrown));\n-    }\n-    \n-    /**\n-     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n-     * <p>\n-     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n-     * <p>\n-     * Example:\n-     * \n-     * <pre>\n-     *  doAnswer(new Answer() {\n-     *      public Object answer(InvocationOnMock invocation) {\n-     *          Object[] args = invocation.getArguments();\n-     *          Mock mock = invocation.getMock();\n-     *          return null;\n-     *      }})\n-     *  .when(mock).someMethod();\n-     * </pre>\n-     * \n-     * @param answer to answer when the stubbed method is called\n-     * @return stubber - to select a method for stubbing\n-     */\n-    public static Stubber doAnswer(Answer answer) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n-        return new StubberImpl().doAnswer(answer);\n-    }  \n-    \n-    /**\n-     * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b> \n-     * However, there are rare situations when doNothing() comes handy:  \n-     * <p>\n-     * 1. Stubbing consecutive calls on a void method:\n-     * <pre>\n-     *   doNothing().\n-     *   doThrow(new RuntimeException())\n-     *   .when(mock).someVoidMethod();\n-     *   \n-     *   //does nothing the first time:\n-     *   mock.someVoidMethod();\n-     *   \n-     *   //throws RuntimeException the next time:\n-     *   mock.someVoidMethod();\n-     * </pre>\n-     * \n-     * 2. When you spy real objects and you want the void method to do nothing:\n-     * <pre>\n-     *   List list = new LinkedList();\n-     *   List spy = spy(list);\n-     *   \n-     *   //let's make clear() do nothing\n-     *   doNothing().when(spy).clear();\n-     *   \n-     *   spy.add(\"one\");\n-     *   \n-     *   //clear() does nothing, so the list still contains \"one\"\n-     *   spy.clear();\n-     * </pre>\n-     *   \n-     * @return stubber - to select a method for stubbing\n-     */\n-    public static Stubber doNothing() {\n-        return doAnswer(new DoesNothing());\n-    }    \n-    \n-    /**\n-     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n-     * <p>\n-     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe \n-     * and more readable</b> (especially when stubbing consecutive calls). \n-     * <p>\n-     * Here are those rare occasions when doReturn() comes handy:\n-     * <p>\n-     * \n-     * 1. When spying real objects and calling real methods on a spy brings side effects  \n-     * \n-     * <pre>\n-     *   List list = new LinkedList();\n-     *   List spy = spy(list);\n-     *   \n-     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   when(spy.get(0)).thenReturn(\"foo\");\n-     *   \n-     *   //You have to use doReturn() for stubbing:\n-     *   doReturn(\"foo\").when(spy).get(0);\n-     * </pre>\n-     * \n-     * 2. Overriding a previous exception-stubbing:\n-     * \n-     * <pre>\n-     *   when(mock.foo()).thenThrow(new RuntimeException());\n-     *   \n-     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown. \n-     *   when(mock.foo()).thenReturn(\"bar\");\n-     *   \n-     *   //You have to use doReturn() for stubbing:\n-     *   doReturn(\"bar\").when(mock).foo();\n-     * </pre>\n-     * \n-     * Above scenarios shows a tradeoff of Mockito's ellegant syntax. Note that the scenarios are very rare, though. \n-     * Spying should be sporadic and overriding exception-stubbing is very rare.  \n-     * \n-     * @param toBeReturned to be returned when the stubbed method is called\n-     * @return stubber - to select a method for stubbing\n-     */\n-    public static Stubber doReturn(Object toBeReturned) {\n-        return doAnswer(new Returns(toBeReturned));\n-    }\n- \n-    /**\n-     * Creates InOrder object that allows verifying mocks in order.\n-     * \n-     * <pre>\n-     *   InOrder inOrder = inOrder(firstMock, secondMock);\n-     *   \n-     *   inOrder.verify(firstMock).add(\"was called first\");\n-     *   inOrder.verify(secondMock).add(\"was called second\");\n-     * </pre>\n-     * \n-     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n-     * but only those that you are interested in testing in order.\n-     * <p>\n-     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n-     *\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mocks to be verified in order\n-     * \n-     * @return InOrder object to be used to verify in order\n-     */\n-    public static InOrder inOrder(Object... mocks) {\n-        if (mocks == null || mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n-        }\n-        for (Object mock : mocks) {\n-            if (mock == null) {\n-                REPORTER.nullPassedWhenCreatingInOrder();\n-            } else if (!MockUtil.isMock(mock)) {\n-                REPORTER.notAMockPassedWhenCreatingInOrder();\n-            }\n-        }\n-        InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n-        return inOrder;\n-    }\n-  \n-    /**\n-     * Allows verifying exact number of invocations. E.g:\n-     * <pre>\n-     *   verify(mock, times(2)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param wantedNumberOfInvocations wanted number of invocations \n-     * \n-     * @return verification mode\n-     */\n-    public static VerificationMode times(int wantedNumberOfInvocations) {\n-        return VerificationModeFactory.times(wantedNumberOfInvocations);\n-    }\n-    \n-    /**\n-     * Alias to times(0), see {@link Mockito#times(int)}\n-     * <p>\n-     * Verifies that interaction did not happen. E.g:\n-     * <pre>\n-     *   verify(mock, never()).someMethod();\n-     * </pre>\n-     * \n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @return verification mode\n-     */\n-    public static VerificationMode never() {\n-        return times(0);\n-    }\n-    \n-    /**\n-     * Allows at-least-once verification. E.g:\n-     * <pre>\n-     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n-     * </pre>\n-     * Alias to atLeast(1)\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @return verification mode\n-     */\n-    public static VerificationMode atLeastOnce() {\n-        return VerificationModeFactory.atLeastOnce();\n-    }\n-\n-    /**\n-     * Allows at-least-x verification. E.g:\n-     * <pre>\n-     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param minNumberOfInvocations minimum number of invocations \n-     * \n-     * @return verification mode\n-     */\n-    public static VerificationMode atLeast(int minNumberOfInvocations) {\n-        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n-    }\n-    \n-    /**\n-     * Allows at-most-x verification. E.g:\n-     * <pre>\n-     *   verify(mock, atMost(3)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param maxNumberOfInvocations max number of invocations \n-     * \n-     * @return verification mode\n-     */\n-    public static VerificationMode atMost(int maxNumberOfInvocations) {\n-        return VerificationModeFactory.atMost(maxNumberOfInvocations);\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import java.util.Arrays;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.MockHandler;\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.returnvalues.EmptyReturnValues;\n+import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n+import org.mockito.internal.returnvalues.MoreEmptyReturnValues;\n+import org.mockito.internal.returnvalues.SmartNullReturnValues;\n+import org.mockito.internal.stubbing.DoesNothing;\n+import org.mockito.internal.stubbing.Returns;\n+import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.StubberImpl;\n+import org.mockito.internal.stubbing.ThrowsException;\n+import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.internal.verification.api.VerificationMode;\n+import org.mockito.runners.MockitoJUnit44Runner;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+\n+/**\n+ * Enables mocks creation, verification and stubbing.\n+ * \n+ * <h1>Contents</h1>\n+ * \n+ * <b> \n+ *      1. Let's verify some behaviour! <br/> \n+ *      2. How about some stubbing? <br/>\n+ *      3. Argument matchers <br/> \n+ *      4. Verifying exact number of invocations / at least once / never <br/> \n+ *      5. Stubbing void methods with exceptions <br/> \n+ *      6. Verification in order <br/> \n+ *      7. Making sure interaction(s) never happened on mock <br/> \n+ *      8. Finding redundant invocations <br/> \n+ *      9. Shorthand for mocks creation - &#064;Mock annotation <br/> \n+ *      10. Stubbing consecutive calls (iterator-style stubbing) <br/> \n+ *      11. Stubbing with callbacks <br/>\n+ *      12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids <br/>\n+ *      13. Spying on real objects <br/>\n+ *      14. (**New**) Changing default return values of unstubbed invocations <br/>\n+ * </b>\n+ * \n+ * <p>\n+ * Following examples mock a List, because everyone knows its interface (methods\n+ * like add(), get(), clear() will be used). <br>\n+ * You probably wouldn't mock List class 'in real'.\n+ * \n+ * <h3>1. Let's verify some behaviour!</h3>\n+ * \n+ * <pre>\n+ * //Let's import Mockito statically so that the code looks clearer\n+ * import static org.mockito.Mockito.*;\n+ * \n+ * //mock creation\n+ * List mockedList = mock(List.class);\n+ * \n+ * //using mock object\n+ * mockedList.add(\"one\");\n+ * mockedList.clear();\n+ * \n+ * //verification\n+ * verify(mockedList).add(\"one\");\n+ * verify(mockedList).clear();\n+ * </pre>\n+ * \n+ * <p>\n+ * Once created, mock will remember all interactions. Then you can selectively\n+ * verify whatever interaction you are interested in.\n+ * \n+ * <h3>2. How about some stubbing?</h3>\n+ * \n+ * <pre>\n+ * //You can mock concrete classes, not only interfaces\n+ * LinkedList mockedList = mock(LinkedList.class);\n+ * \n+ * //stubbing\n+ * when(mockedList.get(0)).thenReturn(\"first\");\n+ * when(mockedList.get(1)).thenThrow(new RuntimeException());\n+ * \n+ * //following prints \"first\"\n+ * System.out.println(mockedList.get(0));\n+ * \n+ * //following throws runtime exception\n+ * System.out.println(mockedList.get(1));\n+ * \n+ * //following prints \"null\" because get(999) was not stubbed\n+ * System.out.println(mockedList.get(999));\n+ *  \n+ * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n+ * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n+ * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+ * verify(mockedList).get(0);\n+ * </pre>\n+ * \n+ * <ul>\n+ * <li> By default, for all methods that return value, mock returns null, an\n+ * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n+ * false, ... for int/Integer, boolean/Boolean, ...). </li>\n+ * \n+ * <li> Stubbing can be overridden: for example common stubbing can go to\n+ * fixture setup but the test methods can override it. </li>\n+ * \n+ * <li> Once stubbed, the method will always return stubbed value regardless\n+ * of how many times it is called. </li>\n+ * \n+ * <li> Last stubbing is more important - when you stubbed the same method with\n+ * the same arguments many times. </li>\n+ * \n+ * </ul>\n+ * \n+ * <h3>3. Argument matchers</h3>\n+ * \n+ * <pre>\n+ * //stubbing using built-in anyInt() argument matcher\n+ * when(mockedList.get(anyInt())).thenReturn(\"element\");\n+ * \n+ * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n+ * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n+ * \n+ * //following prints \"element\"\n+ * System.out.println(mockedList.get(999));\n+ * \n+ * //<b>you can also verify using an argument matcher</b>\n+ * verify(mockedList).get(anyInt());\n+ * </pre>\n+ * \n+ * <p>\n+ * Argument matchers allow flexible verification or stubbing. \n+ * {@link Matchers Click here to see} more built-in matchers \n+ * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n+ * <p>\n+ * <b>Warning:</b>\n+ * <p>\n+ * If you are using argument matchers, <b>all arguments</b> have to be provided\n+ * by matchers.\n+ * <p>\n+ * E.g: (example shows verification but the same applies to stubbing):\n+ * \n+ * <pre>\n+ *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n+ *   //above is correct - eq() is also an argument matcher\n+ *   \n+ *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n+ *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n+ * </pre>\n+ * \n+ * <h3>4. Verifying exact number of invocations / at least x / never</h3>\n+ * \n+ * <pre>\n+ * //using mock \n+ * mockedList.add(\"once\");\n+ * \n+ * mockedList.add(\"twice\");\n+ * mockedList.add(\"twice\");\n+ * \n+ * mockedList.add(\"three times\");\n+ * mockedList.add(\"three times\");\n+ * mockedList.add(\"three times\");\n+ * \n+ * //following two verifications work exactly the same - times(1) is used by default\n+ * verify(mockedList).add(\"once\");\n+ * verify(mockedList, times(1)).add(\"once\");\n+ * \n+ * //exact number of invocations verification\n+ * verify(mockedList, times(2)).add(\"twice\");\n+ * verify(mockedList, times(3)).add(\"three times\");\n+ * \n+ * //verification using never(). never() is an alias to times(0)\n+ * verify(mockedList, never()).add(\"never happened\");\n+ * \n+ * //verification using atLeast()/atMost()\n+ * verify(mockedList, atLeastOnce()).add(\"three times\");\n+ * verify(mockedList, atLeast(2)).add(\"five times\");\n+ * verify(mockedList, atMost(5)).add(\"three times\");\n+ * \n+ * </pre>\n+ * \n+ * <p>\n+ * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n+ * omitted.\n+ * \n+ * <h3>5. Stubbing void methods with exceptions</h3>\n+ * \n+ * <pre>\n+ *   doThrow(new RuntimeException()).when(mockedList).clear();\n+ *   \n+ *   //following throws RuntimeException:\n+ *   mockedList.clear();\n+ * </pre>\n+ * \n+ * Read more about doThrow|doAnswer family of methods in paragraph 12.\n+ * <p>\n+ * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n+ * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n+ * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n+ * \n+ * <h3>6. Verification in order</h3>\n+ * \n+ * <pre>\n+ * List firstMock = mock(List.class);\n+ * List secondMock = mock(List.class);\n+ * \n+ * //using mocks\n+ * firstMock.add(\"was called first\");\n+ * secondMock.add(\"was called second\");\n+ * \n+ * //create inOrder object passing any mocks that need to be verified in order\n+ * InOrder inOrder = inOrder(firstMock, secondMock);\n+ * \n+ * //following will make sure that firstMock was called before secondMock\n+ * inOrder.verify(firstMock).add(\"was called first\");\n+ * inOrder.verify(secondMock).add(\"was called second\");\n+ * </pre>\n+ * \n+ * Verification in order is flexible - <b>you don't have to verify all\n+ * interactions</b> one-by-one but only those that you are interested in\n+ * testing in order.\n+ * <p>\n+ * Also, you can create InOrder object passing only mocks that are relevant for\n+ * in-order verification.\n+ * \n+ * <h3>7. Making sure interaction(s) never happened on mock</h3>\n+ * \n+ * <pre>\n+ * //using mocks - only mockOne is interacted\n+ * mockOne.add(\"one\");\n+ * \n+ * //ordinary verification\n+ * verify(mockOne).add(\"one\");\n+ * \n+ * //verify that method was never called on a mock\n+ * verify(mockOne, never()).add(\"two\");\n+ * \n+ * //verify that other mocks were not interacted\n+ * verifyZeroInteractions(mockTwo, mockThree);\n+ * \n+ * </pre>\n+ * \n+ * <h3>8. Finding redundant invocations</h3>\n+ * \n+ * <pre>\n+ * //using mocks\n+ * mockedList.add(\"one\");\n+ * mockedList.add(\"two\");\n+ * \n+ * verify(mockedList).add(\"one\");\n+ * \n+ * //following verification will fail \n+ * verifyNoMoreInteractions(mockedList);\n+ * </pre>\n+ * \n+ * A word of <b>warning</b>: \n+ * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n+ * verifyNoMoreInteractions() is not recommended to use in every test method. \n+ * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n+ * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+ * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n+ * \n+ * <p>   \n+ * See also {@link Mockito#never()} - it is more explicit and\n+ * communicates the intent well.\n+ * <p>\n+ * \n+ * <h3>9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n+ * \n+ * <ul>\n+ * <li>Minimizes repetitive mock creation code.</li>\n+ * <li>Makes the test class more readable.</li>\n+ * <li>Makes the verification error easier to read because the <b>field name</b>\n+ * is used to identify the mock.</li>\n+ * </ul>\n+ * \n+ * <pre>\n+ *   public class ArticleManagerTest { \n+ *     \n+ *       &#064;Mock private ArticleCalculator calculator;\n+ *       &#064;Mock private ArticleDatabase database;\n+ *       &#064;Mock private UserProvider userProvider;\n+ *     \n+ *       private ArticleManager manager;\n+ * </pre>\n+ * \n+ * <b>Important!</b> This needs to be somewhere in the base class or a test\n+ * runner:\n+ * \n+ * <pre>\n+ * MockitoAnnotations.initMocks(testClass);\n+ * </pre>\n+ * \n+ * You can use built-in runners {@link MockitoJUnitRunner}, {@link MockitoJUnit44Runner}.\n+ * <p>\n+ * Read more here: {@link MockitoAnnotations}\n+ * \n+ * <h3> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n+ * \n+ * Sometimes we need to stub with different return value/exception for the same\n+ * method call. Typical use case could be mocking iterators. \n+ * Original version of Mockito did not have this feature to promote simple mocking. \n+ * For example, instead of iterators one could use {@link Iterable} or simply\n+ * collections. Those offer natural ways of stubbing (e.g. using real\n+ * collections). In rare scenarios stubbing consecutive calls could be useful,\n+ * though:\n+ * <p>\n+ * \n+ * <pre>\n+ * when(mock.someMethod(\"some arg\"))\n+ *   .thenThrow(new RuntimeException())\n+ *   .thenReturn(\"foo\");\n+ * \n+ * //First call: throws runtime exception:\n+ * mock.someMethod(\"some arg\");\n+ * \n+ * //Second call: prints \"foo\"\n+ * System.out.println(mock.someMethod(\"some arg\"));\n+ * \n+ * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n+ * System.out.println(mock.someMethod(\"some arg\"));\n+ * </pre>\n+ * \n+ * Alternative, shorter version of consecutive stubbing:\n+ * \n+ * <pre>\n+ * when(mock.someMethod(\"some arg\"))\n+ *   .thenReturn(\"one\", \"two\", \"three\");\n+ * </pre>\n+ * \n+ * <h3> 11. Stubbing with callbacks</h3>\n+ * \n+ * Allows stubbing with generic {@link Answer} interface.\n+*  <p>\n+ * Yet another controversial feature which was not included in Mockito\n+ * originally. We recommend using simple stubbing with toReturn() or\n+ * toThrow() only. Those two should be <b>just enough</b> to test/test-drive\n+ * any clean & simple code.\n+ * \n+ * <pre>\n+ * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n+ *     Object answer(InvocationOnMock invocation) {\n+ *         Object[] args = invocation.getArguments();\n+ *         Object mock = invocation.getMock();\n+ *         return \"called with arguments: \" + args;\n+ *     }\n+ * });\n+ * \n+ * //Following prints \"called with arguments: foo\"\n+ * System.out.println(mock.someMethod(\"foo\"));\n+ * </pre>\n+ * \n+ * <h3> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n+ * \n+ * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+ * <p>\n+ * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n+ * The main reason is improved readability and consistency with the family of doAnswer() methods.\n+ * <p>\n+ * Use doThrow() when you want to stub a void method with an exception:\n+ * <pre>\n+ *   doThrow(new RuntimeException()).when(mockedList).clear();\n+ *   \n+ *   //following throws RuntimeException:\n+ *   mockedList.clear();\n+ * </pre>\n+ * \n+ * Read more about other methods:\n+ * <p>\n+ * {@link Mockito#doThrow(Throwable)}\n+ * <p>\n+ * {@link Mockito#doAnswer(Answer)}\n+ * <p>\n+ * {@link Mockito#doNothing()}\n+ * <p>\n+ * {@link Mockito#doReturn(Object)}\n+ * \n+ * <h3> 13. Spying on real objects</h3>\n+ * \n+ * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n+ * <p>\n+ * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n+ * <p>\n+ * Spying on real objects is often associated with \"partial mocking\" concept. \n+ * However, Mockito spies are not partial mocks. Mockito spy is meant to help testing other classes - not the spy itself. \n+ * Therefore spy will not help if you intend to verify if method calls other method on the same object. \n+ * In this case I suggest being OO/SRPy (for example you might extract new class/interface...)\n+ * \n+ * <pre>\n+ *   List list = new LinkedList();\n+ *   List spy = spy(list);\n+ * \n+ *   //optionally, you can stub out some methods:\n+ *   when(spy.size()).thenReturn(100);\n+ * \n+ *   //using the spy calls <b>real</b> methods\n+ *   spy.add(\"one\");\n+ *   spy.add(\"two\");\n+ * \n+ *   //prints \"one\" - the first element of a list\n+ *   System.out.println(spy.get(0));\n+ * \n+ *   //size() method was stubbed - 100 is printed\n+ *   System.out.println(spy.size());\n+ * \n+ *   //optionally, you can verify\n+ *   verify(spy).add(\"one\");\n+ *   verify(spy).add(\"two\");\n+ * </pre>\n+ * \n+ * <h4>Important gotcha on spying real objects!</h4>\n+ * \n+ * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n+ * \n+ * <pre>\n+ *   List list = new LinkedList();\n+ *   List spy = spy(list);\n+ *   \n+ *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+ *   when(spy.get(0)).thenReturn(\"foo\");\n+ *   \n+ *   //You have to use doReturn() for stubbing\n+ *   doReturn(\"foo\").when(spy).get(0);\n+ * </pre>\n+ * \n+ * 2. Watch out for final methods. \n+ * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n+ * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n+ * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n+ * \n+ * <h3>14. (**New**) Changing default return values of unstubbed invocations</h3>\n+ * \n+ * You can create a mock with specified strategy of for its return values.\n+ * It's quite advanced feature and typically you don't need it to write decent tests.\n+ * However, it can be helpful for working with legacy systems.\n+ * <p>\n+ * Obviously those return values are used only when you don't stub the method call.\n+ * \n+ * <pre>\n+ *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n+ *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n+ * </pre>\n+ * \n+ * <p>\n+ * Read more about this interesting implementation of <i>ReturnValues</i>: {@link Mockito#RETURNS_SMART_NULLS}\n+ * \n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class Mockito extends Matchers {\n+    \n+    /**\n+     * Default ReturnValues used by the framework.\n+     * <p>\n+     * {@link ReturnValues} defines the return values of unstubbed invocations. \n+     * <p>\n+     * This implementation first tries the global configuration. \n+     * If there is no global configuration then it uses {@link EmptyReturnValues} (returns zeros, empty collections, nulls, etc.)\n+     */\n+    public static final ReturnValues RETURNS_DEFAULTS = new GloballyConfiguredReturnValues();\n+    \n+    /**\n+     * Optional ReturnValues to be used with {@link Mockito#mock(Class, ReturnValues)}\n+     * <p>\n+     * {@link ReturnValues} defines the return values of unstubbed invocations.\n+     * <p>\n+     * This implementation can be helpful when working with legacy code.\n+     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n+     * This implementation of ReturnValues makes unstubbed methods <b>return SmartNull instead of null</b>.\n+     * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\n+     * <p>\n+     * SmartNullReturnValues first tries to return ordinary return values (see {@link MoreEmptyReturnValues})\n+     * then it tries to return SmartNull. If the return type is final then plain null is returned.\n+     * <p>\n+     * SmartNullReturnValues will be probably the default return values strategy in Mockito 2.0\n+     * <p>\n+     * Example:\n+     * <pre>\n+     *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\n+     *   \n+     *   //calling unstubbed method here:\n+     *   Stuff stuff = mock.getStuff();\n+     *   \n+     *   //using object returned by unstubbed call:\n+     *   stuff.doSomething();\n+     *   \n+     *   //Above doesn't yield NullPointerException this time!\n+     *   //Instead, SmartNullPointerException is thrown. \n+     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n+     * </pre>\n+     */\n+    public static final ReturnValues RETURNS_SMART_NULLS = new SmartNullReturnValues();\n+    \n+    static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n+    private static final Reporter REPORTER = new Reporter();\n+\n+    /**\n+     * Creates mock object of given class or interface.\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param classToMock class or interface to mock\n+     * @return mock object\n+     */\n+    public static <T> T mock(Class<T> classToMock) {\n+        return mock(classToMock, null, null, RETURNS_DEFAULTS);\n+    }\n+    \n+    /**\n+     * Creates mock with a name. Naming mocks can be helpful for debugging. \n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n+     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n+     * <p>\n+     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n+     * <p>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param classToMock class or interface to mock\n+     * @return mock object\n+     */\n+    public static <T> T mock(Class<T> classToMock, String name) {\n+        return mock(classToMock, name, null, RETURNS_DEFAULTS);\n+    }\n+    \n+    /**\n+     * Creates mock with a specified strategy for its return values. \n+     * It's quite advanced feature and typically you don't need it to write decent tests.\n+     * However it can be helpful for working with legacy systems.\n+     * <p>\n+     * Obviously return values are used only when you don't stub the method call.\n+     *\n+     * <pre>\n+     *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n+     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n+     * </pre>\n+     * \n+     * <p>See examples in javadoc for {@link Mockito} class</p>\n+     * \n+     * @param classToMock class or interface to mock\n+     * @param returnValues default return values for unstubbed methods\n+     *\n+     * @return mock object\n+     */\n+    public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n+        return mock(classToMock, null, (T) null, returnValues);\n+    }\n+    \n+    private static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n+        MOCKING_PROGRESS.validateState();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n+        return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n+    }    \n+\n+    /**\n+     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n+     * <p>\n+     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n+     * <p>\n+     * Spying on real objects is often associated with \"partial mocking\" concept. \n+     * However, Mockito spies are not partial mocks. Mockito spy is meant to help testing other classes - not the spy itself. \n+     * Therefore spy will not help if you intend to verify if method calls other method on the same object. \n+     * In this case I suggest being OO/SRPy (for example you might extract new class/interface...)\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     * \n+     *   //optionally, you can stub out some methods:\n+     *   when(spy.size()).thenReturn(100);\n+     * \n+     *   //using the spy calls <b>real</b> methods\n+     *   spy.add(\"one\");\n+     *   spy.add(\"two\");\n+     * \n+     *   //prints \"one\" - the first element of a list\n+     *   System.out.println(spy.get(0));\n+     * \n+     *   //size() method was stubbed - 100 is printed\n+     *   System.out.println(spy.size());\n+     * \n+     *   //optionally, you can verify\n+     *   verify(spy).add(\"one\");\n+     *   verify(spy).add(\"two\");\n+     * </pre>\n+     * \n+     * <h4>Important gotcha on spying real objects!</h4>\n+     * \n+     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n+     * \n+     * <pre>\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *   \n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *   \n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </pre>\n+     * \n+     * 2. Watch out for final methods. \n+     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n+     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n+     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n+     * \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param object\n+     *            to spy on\n+     * @return a spy of the real object\n+     */\n+    public static <T> T spy(T object) {\n+        return mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n+    }\n+\n+    /**\n+     * <pre>\n+     *   //Instead of:\n+     *   stub(mock.count()).toReturn(10);\n+     * \n+     *   //Please do:\n+     *   when(mock.count()).thenReturn(10);\n+     * </pre> \n+     * \n+     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n+     * <p>\n+     * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n+     * <pre>\n+     *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n+     *   stub(          <i>replace with:</i>  when(\n+     *   .toReturn(     <i>replace with:</i>  .thenReturn(\n+     *   .toThrow(      <i>replace with:</i>  .thenThrow(\n+     *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n+     * </pre>\n+     * If you're an existing user then sorry for making your code littered with deprecation warnings. \n+     * This change was required to make Mockito better.\n+     * \n+     * @param methodCall\n+     *            method call\n+     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return (DeprecatedOngoingStubbing) stub();\n+    }\n+    \n+    /**\n+     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n+     * <p>\n+     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n+     * <p>\n+     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n+     * <p>\n+     * Examples:\n+     * \n+     * <pre>\n+     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n+     *\n+     * //you can use flexible argument matchers, e.g:\n+     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n+     *\n+     * //setting exception to be thrown:\n+     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n+     *\n+     * //you can set different behavior for consecutive method calls.\n+     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenThrow(new RuntimeException())\n+     *  .thenReturn(\"foo\");\n+     *  \n+     * //Alternative, shorter version for consecutive stubbing:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenReturn(\"one\", \"two\");\n+     * //is the same as:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenReturn(\"one\")\n+     *  .thenReturn(\"two\");\n+     *\n+     * //shorter version for consecutive method calls throwing exceptions:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenThrow(new RuntimeException(), new NullPointerException();\n+     *   \n+     * </pre>\n+     * \n+     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n+     * <p>\n+     * Stubbing can be overridden: for example common stubbing can go to fixture\n+     * setup but the test methods can override it.\n+     * <p>\n+     * Once stubbed, the method will always return stubbed value regardless\n+     * of how many times it is called.\n+     * <p>\n+     * Last stubbing is more important - when you stubbed the same method with\n+     * the same arguments many times.\n+     * <p>\n+     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n+     * Let's say you've stubbed foo.bar(). \n+     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n+     * If your code doesn't care what get(0) returns then it should not be stubbed. \n+     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+     * \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * @param methodCall method to be stubbed\n+     */\n+    public static <T> NewOngoingStubbing<T> when(T methodCall) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return (NewOngoingStubbing) stub();\n+    }\n+\n+    private static OngoingStubbing stub() {\n+        OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n+        if (stubbing == null) {\n+            MOCKING_PROGRESS.reset();\n+            REPORTER.missingMethodInvocation();\n+        }\n+        return stubbing;\n+    }\n+\n+    /**\n+     * Verifies certain behavior <b>happened once</b> \n+     * <p>\n+     * Alias to <code>verify(mock, times(1))</code> E.g:\n+     * <pre>\n+     *   verify(mock).someMethod(\"some arg\");\n+     * </pre>\n+     * Above is equivalent to:\n+     * <pre>\n+     *   verify(mock, times(1)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * <p>\n+     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n+     * Let's say you've stubbed foo.bar(). \n+     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n+     * If your code doesn't care what get(0) returns then it should not be stubbed. \n+     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+     * \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mock to be verified\n+     * @return mock object itself\n+     */\n+    public static <T> T verify(T mock) {\n+        return verify(mock, times(1));\n+    }\n+    \n+    /**\n+     * TODO javadoc\n+     * \n+     * @param <T>\n+     * @param mock\n+     */\n+    public static <T> void reset(T mock) {\n+        //TODO Perhaps we should validate the state instead of resetting?\n+        MOCKING_PROGRESS.reset();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n+        //TODO Perhaps we should maintain previous ReturnValues?\n+        MockUtil.resetMock(mock, MOCKING_PROGRESS, RETURNS_DEFAULTS);\n+    }\n+\n+ \n+    /**\n+     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n+     * <pre>\n+     *   verify(mock, times(5)).someMethod(\"was called five times\");\n+     *   \n+     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n+     *   \n+     *   //you can use flexible argument matchers, e.g:\n+     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n+     * </pre>\n+     * \n+     * <b>times(1) is the default</b> and can be omitted\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mock to be verified\n+     * @param mode times(x), atLeastOnce() or never()\n+     * \n+     * @return mock object itself\n+     */\n+    public static <T> T verify(T mock, VerificationMode mode) {\n+        if (mock == null) {\n+            REPORTER.nullPassedToVerify();\n+        } else if (!MockUtil.isMock(mock)) {\n+            REPORTER.notAMockPassedToVerify();\n+        }\n+        MOCKING_PROGRESS.verificationStarted(mode);\n+        return mock;\n+    }\n+\n+    /**\n+     * Checks if any of given mocks has any unverified interaction.\n+     * <p>\n+     * You can use this method after you verified your mocks - to make sure that nothing\n+     * else was invoked on your mocks.\n+     * <p>\n+     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n+     * <p>\n+     * Stubbed invocations (if called) are also treated as interactions.\n+     * <p>\n+     * A word of <b>warning</b>: \n+     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n+     * verifyNoMoreInteractions() is not recommended to use in every test method. \n+     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n+     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n+     * <p>\n+     * This method will also detect unverified invocations that occurred before the test method,\n+     * for example: in setUp(), &#064;Before method or in constructor.\n+     * Consider writing nice code that makes interactions only in test methods.\n+     * \n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     * //interactions\n+     * mock.doSomething();\n+     * mock.doSomethingUnexpected();\n+     * \n+     * //verification\n+     * verify(mock).doSomething();\n+     * \n+     * //following will fail because 'doSomethingUnexpected()' is unexpected\n+     * verifyNoMoreInteractions(mock);\n+     * \n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mocks to be verified\n+     */\n+    public static void verifyNoMoreInteractions(Object... mocks) {\n+        assertMocksNotEmpty(mocks);\n+        MOCKING_PROGRESS.validateState();\n+        for (Object mock : mocks) {\n+            try {\n+                if (mock == null) {\n+                    REPORTER.nullPassedToVerifyNoMoreInteractions();\n+                }\n+                MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n+            } catch (NotAMockException e) {\n+                REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Verifies that no interactions happened on given mocks.\n+     * <pre>\n+     *   verifyZeroInteractions(mockOne, mockTwo);\n+     * </pre>\n+     * This method will also detect invocations \n+     * that occurred before the test method, for example: in setUp(), &#064;Before method or in constructor.\n+     * Consider writing nice code that makes interactions only in test methods.  \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mocks to be verified\n+     */\n+    public static void verifyZeroInteractions(Object... mocks) {\n+        verifyNoMoreInteractions(mocks);\n+    }\n+\n+    private static void assertMocksNotEmpty(Object[] mocks) {\n+        if (mocks == null || mocks.length == 0) {\n+            REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n+        }\n+    }\n+\n+    /**\n+     * <pre>\n+     *   //Instead of:\n+     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n+     * \n+     *   //Please do:\n+     *   doThrow(e).when(mock).someVoidMethod();\n+     * </pre> \n+     * \n+     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n+     * <p>\n+     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n+     * \n+     * <pre>\n+     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n+     * \n+     * //you can stub with different behavior for consecutive calls.\n+     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n+     * stubVoid(mock)\n+     *   .toThrow(new RuntimeException())\n+     *   .toReturn()\n+     *   .on().someMethod();\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n+     * \n+     * @param mock\n+     *            to stub\n+     * @return stubbable object that allows stubbing with throwable\n+     */\n+    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n+        MockHandler<T> handler = MockUtil.getMockHandler(mock);\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return handler.voidMethodStubbable(mock);\n+    }\n+    \n+    /**\n+     * Use doThrow() when you want to stub the void method with an exception.\n+     * <p>\n+     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n+     * </pre>\n+     * \n+     * @param toBeThrown to be thrown when the stubbed method is called\n+     * @return stubber - to select a method for stubbing\n+     */\n+    public static Stubber doThrow(Throwable toBeThrown) {\n+        return doAnswer(new ThrowsException(toBeThrown));\n+    }\n+    \n+    /**\n+     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n+     * <p>\n+     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+     * <p>\n+     * Example:\n+     * \n+     * <pre>\n+     *  doAnswer(new Answer() {\n+     *      public Object answer(InvocationOnMock invocation) {\n+     *          Object[] args = invocation.getArguments();\n+     *          Mock mock = invocation.getMock();\n+     *          return null;\n+     *      }})\n+     *  .when(mock).someMethod();\n+     * </pre>\n+     * \n+     * @param answer to answer when the stubbed method is called\n+     * @return stubber - to select a method for stubbing\n+     */\n+    public static Stubber doAnswer(Answer answer) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n+        return new StubberImpl().doAnswer(answer);\n+    }  \n+    \n+    /**\n+     * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b> \n+     * However, there are rare situations when doNothing() comes handy:  \n+     * <p>\n+     * 1. Stubbing consecutive calls on a void method:\n+     * <pre>\n+     *   doNothing().\n+     *   doThrow(new RuntimeException())\n+     *   .when(mock).someVoidMethod();\n+     *   \n+     *   //does nothing the first time:\n+     *   mock.someVoidMethod();\n+     *   \n+     *   //throws RuntimeException the next time:\n+     *   mock.someVoidMethod();\n+     * </pre>\n+     * \n+     * 2. When you spy real objects and you want the void method to do nothing:\n+     * <pre>\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *   \n+     *   //let's make clear() do nothing\n+     *   doNothing().when(spy).clear();\n+     *   \n+     *   spy.add(\"one\");\n+     *   \n+     *   //clear() does nothing, so the list still contains \"one\"\n+     *   spy.clear();\n+     * </pre>\n+     *   \n+     * @return stubber - to select a method for stubbing\n+     */\n+    public static Stubber doNothing() {\n+        return doAnswer(new DoesNothing());\n+    }    \n+    \n+    /**\n+     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n+     * <p>\n+     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe \n+     * and more readable</b> (especially when stubbing consecutive calls). \n+     * <p>\n+     * Here are those rare occasions when doReturn() comes handy:\n+     * <p>\n+     * \n+     * 1. When spying real objects and calling real methods on a spy brings side effects  \n+     * \n+     * <pre>\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *   \n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *   \n+     *   //You have to use doReturn() for stubbing:\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </pre>\n+     * \n+     * 2. Overriding a previous exception-stubbing:\n+     * \n+     * <pre>\n+     *   when(mock.foo()).thenThrow(new RuntimeException());\n+     *   \n+     *   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown. \n+     *   when(mock.foo()).thenReturn(\"bar\");\n+     *   \n+     *   //You have to use doReturn() for stubbing:\n+     *   doReturn(\"bar\").when(mock).foo();\n+     * </pre>\n+     * \n+     * Above scenarios shows a tradeoff of Mockito's ellegant syntax. Note that the scenarios are very rare, though. \n+     * Spying should be sporadic and overriding exception-stubbing is very rare.  \n+     * \n+     * @param toBeReturned to be returned when the stubbed method is called\n+     * @return stubber - to select a method for stubbing\n+     */\n+    public static Stubber doReturn(Object toBeReturned) {\n+        return doAnswer(new Returns(toBeReturned));\n+    }\n+ \n+    /**\n+     * Creates InOrder object that allows verifying mocks in order.\n+     * \n+     * <pre>\n+     *   InOrder inOrder = inOrder(firstMock, secondMock);\n+     *   \n+     *   inOrder.verify(firstMock).add(\"was called first\");\n+     *   inOrder.verify(secondMock).add(\"was called second\");\n+     * </pre>\n+     * \n+     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n+     * but only those that you are interested in testing in order.\n+     * <p>\n+     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n+     *\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param mocks to be verified in order\n+     * \n+     * @return InOrder object to be used to verify in order\n+     */\n+    public static InOrder inOrder(Object... mocks) {\n+        if (mocks == null || mocks.length == 0) {\n+            REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n+        }\n+        for (Object mock : mocks) {\n+            if (mock == null) {\n+                REPORTER.nullPassedWhenCreatingInOrder();\n+            } else if (!MockUtil.isMock(mock)) {\n+                REPORTER.notAMockPassedWhenCreatingInOrder();\n+            }\n+        }\n+        InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n+        return inOrder;\n+    }\n+  \n+    /**\n+     * Allows verifying exact number of invocations. E.g:\n+     * <pre>\n+     *   verify(mock, times(2)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param wantedNumberOfInvocations wanted number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode times(int wantedNumberOfInvocations) {\n+        return VerificationModeFactory.times(wantedNumberOfInvocations);\n+    }\n+    \n+    /**\n+     * Alias to times(0), see {@link Mockito#times(int)}\n+     * <p>\n+     * Verifies that interaction did not happen. E.g:\n+     * <pre>\n+     *   verify(mock, never()).someMethod();\n+     * </pre>\n+     * \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode never() {\n+        return times(0);\n+    }\n+    \n+    /**\n+     * Allows at-least-once verification. E.g:\n+     * <pre>\n+     *   verify(mock, atLeastOnce()).someMethod(\"some arg\");\n+     * </pre>\n+     * Alias to atLeast(1)\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode atLeastOnce() {\n+        return VerificationModeFactory.atLeastOnce();\n+    }\n+\n+    /**\n+     * Allows at-least-x verification. E.g:\n+     * <pre>\n+     *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param minNumberOfInvocations minimum number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode atLeast(int minNumberOfInvocations) {\n+        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n+    }\n+    \n+    /**\n+     * Allows at-most-x verification. E.g:\n+     * <pre>\n+     *   verify(mock, atMost(3)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param maxNumberOfInvocations max number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationMode atMost(int maxNumberOfInvocations) {\n+        return VerificationModeFactory.atMost(maxNumberOfInvocations);\n+    }\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.util;\n-\n-import net.sf.cglib.proxy.Callback;\n-import net.sf.cglib.proxy.Enhancer;\n-import net.sf.cglib.proxy.Factory;\n-\n-import org.mockito.ReturnValues;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.internal.MockHandler;\n-import org.mockito.internal.creation.MethodInterceptorFilter;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n-import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.MockingProgress;\n-\n-public class MockUtil {\n-    \n-    public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String mockName, T optionalInstance, ReturnValues returnValues) {\n-        validateType(classToMock);\n-        MockHandler<T> mockHandler = new MockHandler<T>(new MockName(mockName, classToMock), progress, new MatchersBinder(), returnValues);\n-        MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n-        \n-        T mock = (T) ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n-        filter.setInstance(optionalInstance != null ? optionalInstance : mock);\n-        return mock;\n-    }\n-\n-    private static <T> void validateType(Class<T> classToMock) {\n-        if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n-            new Reporter().cannotMockFinalClass(classToMock);\n-        }\n-    }\n-    \n-    public static <T> MockHandler<T> getMockHandler(T mock) {\n-        if (mock == null) {\n-            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n-        }\n-        \n-        if (isMockitoMock(mock)) {\n-            return getInterceptor(mock).getDelegate();\n-        } else {\n-            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n-        }\n-    }\n-\n-    private static <T> boolean isMockitoMock(T mock) {\n-        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n-    }\n-    \n-    public static boolean isMock(Object mock) {\n-        return mock != null && isMockitoMock(mock);\n-    }\n-    \n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n-        Factory factory = (Factory) mock;\n-        Callback callback = factory.getCallback(0);\n-        if(callback instanceof MethodInterceptorFilter) {\n-            return (MethodInterceptorFilter) callback;\n-        }\n-        return null;\n-    }\n-\n-    public static MockName getMockName(Object mock) {\n-        return getMockHandler(mock).getMockName();\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+\n+import org.mockito.ReturnValues;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.MockHandler;\n+import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+\n+public class MockUtil {\n+\n+    public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String mockName, T optionalInstance,\n+            ReturnValues returnValues) {\n+        validateType(classToMock);\n+        MockHandler<T> mockHandler = new MockHandler<T>(new MockName(mockName, classToMock), progress, new MatchersBinder(), returnValues);\n+        MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n+\n+        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n+        filter.setInstance(optionalInstance != null ? optionalInstance : mock);\n+        return mock;\n+    }\n+\n+    public static <T> void resetMock(T mock, MockingProgress progress, ReturnValues returnValues) {\n+        MockHandler<T> oldMockHandler = (MockHandler<T>) getMockHandler(mock);\n+        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler.getMockName(), progress, new MatchersBinder(), returnValues);\n+        MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>>(Object.class, newMockHandler);\n+        newFilter.setInstance(mock);\n+        ((Factory) mock).setCallback(0, newFilter);\n+    }\n+\n+    private static <T> void validateType(Class<T> classToMock) {\n+        if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n+            new Reporter().cannotMockFinalClass(classToMock);\n+        }\n+    }\n+\n+    public static <T> MockHandler<T> getMockHandler(T mock) {\n+        if (mock == null) {\n+            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n+        }\n+\n+        if (isMockitoMock(mock)) {\n+            return getInterceptor(mock).getDelegate();\n+        } else {\n+            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n+        }\n+    }\n+\n+    private static <T> boolean isMockitoMock(T mock) {\n+        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n+    }\n+\n+    public static boolean isMock(Object mock) {\n+        return mock != null && isMockitoMock(mock);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n+        Factory factory = (Factory) mock;\n+        Callback callback = factory.getCallback(0);\n+        if (callback instanceof MethodInterceptorFilter) {\n+            return (MethodInterceptorFilter<MockHandler<T>>) callback;\n+        }\n+        return null;\n+    }\n+\n+    public static MockName getMockName(Object mock) {\n+        return getMockHandler(mock).getMockName();\n+    }\n }\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.concurrentmockito;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import org.junit.Test;\n-import org.junit.runner.JUnitCore;\n-import org.junit.runner.Result;\n-import org.junit.runner.notification.Failure;\n-import org.mockito.MockitoTest;\n-import org.mockito.exceptions.ReporterTest;\n-import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n-import org.mockito.exceptions.base.MockitoExceptionTest;\n-import org.mockito.exceptions.base.StackTraceRemoverTest;\n-import org.mockito.internal.AllInvocationsFinderTest;\n-import org.mockito.internal.MockHandlerTest;\n-import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n-import org.mockito.internal.invocation.InvocationMatcherTest;\n-import org.mockito.internal.invocation.InvocationTest;\n-import org.mockito.internal.invocation.InvocationsFinderTest;\n-import org.mockito.internal.matchers.EqualsTest;\n-import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.TimesTest;\n-import org.mockito.internal.returnvalues.EmptyReturnValuesTest;\n-import org.mockito.internal.util.ListUtilTest;\n-import org.mockito.internal.util.MockUtilTest;\n-import org.mockito.internal.verification.RegisteredInvocationsTest;\n-import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n-import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n-import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n-import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n-import org.mockitousage.ReplacingObjectMethodsTest;\n-import org.mockitousage.UsingVarargsTest;\n-import org.mockitousage.examples.configure.withbaseclass.ConfiguringDefaultReturnValuesUsingBaseClassTest;\n-import org.mockitousage.examples.configure.withrunner.ConfiguringDefaultReturnValuesUsingRunnerTest;\n-import org.mockitousage.examples.configure.withstaticutility.ConfiguringSelectedMocksToReturnFakesTest;\n-import org.mockitousage.examples.use.ExampleTest;\n-import org.mockitousage.matchers.ComparableMatchersTest;\n-import org.mockitousage.matchers.CustomMatchersTest;\n-import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n-import org.mockitousage.matchers.MatchersTest;\n-import org.mockitousage.matchers.MatchersToStringTest;\n-import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n-import org.mockitousage.misuse.InvalidStateDetectionTest;\n-import org.mockitousage.misuse.InvalidUsageTest;\n-import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n-import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n-import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationChunkTest;\n-import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n-import org.mockitousage.stacktrace.StackTraceFilteringTest;\n-import org.mockitousage.stacktrace.StackTrackeChangingTest;\n-import org.mockitousage.stubbing.BasicStubbingTest;\n-import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n-import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n-import org.mockitousage.verification.AtMostXVerificationTest;\n-import org.mockitousage.verification.BasicVerificationInOrderTest;\n-import org.mockitousage.verification.BasicVerificationTest;\n-import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;\n-import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;\n-import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n-import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n-import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n-import org.mockitousage.verification.RelaxedVerificationInOrderTest;\n-import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n-import org.mockitousage.verification.VerificationInOrderTest;\n-import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n-import org.mockitousage.verification.VerificationUsingMatchersTest;\n-import org.mockitoutil.TestBase;\n-\n-public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n-    \n-    private static class AllTestsRunner extends Thread {\n-        \n-        private boolean failed;\n-\n-        public void run() {\n-            Result result = JUnitCore.runClasses(\n-                    ConfiguringDefaultReturnValuesUsingBaseClassTest.class,\n-                    ConfiguringDefaultReturnValuesUsingRunnerTest.class,\n-                    ConfiguringSelectedMocksToReturnFakesTest.class,\n-                    EqualsTest.class,\n-                    ListUtilTest.class,\n-                    MockingProgressImplTest.class,\n-                    TimesTest.class,\n-                    MockHandlerTest.class,\n-                    AllInvocationsFinderTest.class,\n-                    EmptyReturnValuesTest.class,\n-                    NumberOfInvocationsCheckerTest.class,\n-                    RegisteredInvocationsTest.class,\n-                    MissingInvocationCheckerTest.class,\n-                    NumberOfInvocationsInOrderCheckerTest.class,\n-                    MissingInvocationInOrderCheckerTest.class,\n-                    ClassImposterizerTest.class,\n-                    InvocationMatcherTest.class,\n-                    InvocationsFinderTest.class,\n-                    InvocationTest.class,\n-                    MockitoTest.class,\n-                    MockUtilTest.class,\n-                    ReporterTest.class,\n-                    MockitoAssertionErrorTest.class,\n-                    StackTraceRemoverTest.class,\n-                    MockitoExceptionTest.class,\n-                    StackTraceFilteringTest.class,\n-                    BridgeMethodPuzzleTest.class,\n-                    OverloadingPuzzleTest.class,\n-                    InvalidUsageTest.class,\n-                    UsingVarargsTest.class,\n-                    CustomMatchersTest.class,\n-                    ComparableMatchersTest.class,\n-                    InvalidUseOfMatchersTest.class,\n-                    MatchersTest.class,\n-                    MatchersToStringTest.class,\n-                    VerificationAndStubbingUsingMatchersTest.class,\n-                    BasicStubbingTest.class,\n-                    ReturningDefaultValuesTest.class,\n-                    StubbingWithThrowablesTest.class,\n-                    AtMostXVerificationTest.class,\n-                    BasicVerificationTest.class,\n-                    ExactNumberOfTimesVerificationTest.class,\n-                    VerificationInOrderTest.class,\n-                    NoMoreInteractionsVerificationTest.class,\n-                    SelectedMocksInOrderVerificationTest.class,\n-                    VerificationOnMultipleMocksUsingMatchersTest.class,\n-                    VerificationUsingMatchersTest.class,\n-                    RelaxedVerificationInOrderTest.class,\n-                    DescriptiveMessagesWhenVerificationFailsTest.class,\n-                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n-                    BasicVerificationInOrderTest.class,\n-                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n-                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n-                    InvalidStateDetectionTest.class,\n-                    ReplacingObjectMethodsTest.class,\n-                    StackTrackeChangingTest.class,\n-                    ExampleTest.class,\n-                    PointingStackTraceToActualInvocationTest.class,\n-                    PointingStackTraceToActualInvocationChunkTest.class,\n-                    VerificationInOrderFromMultipleThreadsTest.class\n-                );\n-                \n-                if (!result.wasSuccessful()) {\n-                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n-                    List<Failure> failures = result.getFailures();\n-                    System.err.println(failures.size());\n-                    for (Failure failure : failures) {\n-                        System.err.println(failure.getTrace());\n-                        failed = true;\n-                    }\n-                }\n-        }\n-\n-        public boolean isFailed() {\n-            return failed;\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldRunInMultipleThreads() throws Exception {\n-        //this test ALWAYS fails if there is a single failing unit\n-        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(3));\n-    }\n-    \n-    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n-        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n-        for (int i = 1; i <= numberOfThreads; i++) {\n-            threads.add(new AllTestsRunner());\n-        }\n-\n-        for (Thread t : threads) {\n-            t.start();\n-        }\n-\n-        boolean failed = false;\n-        for (AllTestsRunner t : threads) {\n-            t.join();\n-            failed = failed ? true : t.isFailed();\n-        }\n-        \n-        return failed;\n-    }\n-    \n-    public static void main(String[] args) throws Exception {\n-        int numberOfThreads = 20; \n-        long before = System.currentTimeMillis();\n-        runInMultipleThreads(numberOfThreads);\n-        long after = System.currentTimeMillis();\n-        long executionTime = (after-before)/1000;\n-        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.concurrentmockito;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.junit.runner.JUnitCore;\n+import org.junit.runner.Result;\n+import org.junit.runner.notification.Failure;\n+import org.mockito.MockitoTest;\n+import org.mockito.exceptions.ReporterTest;\n+import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n+import org.mockito.exceptions.base.MockitoExceptionTest;\n+import org.mockito.exceptions.base.StackTraceRemoverTest;\n+import org.mockito.internal.AllInvocationsFinderTest;\n+import org.mockito.internal.MockHandlerTest;\n+import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.invocation.InvocationMatcherTest;\n+import org.mockito.internal.invocation.InvocationTest;\n+import org.mockito.internal.invocation.InvocationsFinderTest;\n+import org.mockito.internal.matchers.EqualsTest;\n+import org.mockito.internal.progress.MockingProgressImplTest;\n+import org.mockito.internal.progress.TimesTest;\n+import org.mockito.internal.returnvalues.EmptyReturnValuesTest;\n+import org.mockito.internal.util.ListUtilTest;\n+import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.verification.RegisteredInvocationsTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n+import org.mockitousage.ReplacingObjectMethodsTest;\n+import org.mockitousage.UsingVarargsTest;\n+import org.mockitousage.examples.configure.withbaseclass.ConfiguringDefaultReturnValuesUsingBaseClassTest;\n+import org.mockitousage.examples.configure.withrunner.ConfiguringDefaultReturnValuesUsingRunnerTest;\n+import org.mockitousage.examples.configure.withstaticutility.ConfiguringSelectedMocksToReturnFakesTest;\n+import org.mockitousage.examples.use.ExampleTest;\n+import org.mockitousage.matchers.ComparableMatchersTest;\n+import org.mockitousage.matchers.CustomMatchersTest;\n+import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n+import org.mockitousage.matchers.MatchersTest;\n+import org.mockitousage.matchers.MatchersToStringTest;\n+import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n+import org.mockitousage.misuse.InvalidStateDetectionTest;\n+import org.mockitousage.misuse.InvalidUsageTest;\n+import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n+import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n+import org.mockitousage.reset.ResetTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationChunkTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n+import org.mockitousage.stacktrace.StackTraceFilteringTest;\n+import org.mockitousage.stacktrace.StackTrackeChangingTest;\n+import org.mockitousage.stubbing.BasicStubbingTest;\n+import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n+import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n+import org.mockitousage.verification.AtMostXVerificationTest;\n+import org.mockitousage.verification.BasicVerificationInOrderTest;\n+import org.mockitousage.verification.BasicVerificationTest;\n+import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;\n+import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;\n+import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n+import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n+import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n+import org.mockitousage.verification.RelaxedVerificationInOrderTest;\n+import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderTest;\n+import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n+import org.mockitousage.verification.VerificationUsingMatchersTest;\n+import org.mockitoutil.TestBase;\n+\n+public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n+    \n+    private static class AllTestsRunner extends Thread {\n+        \n+        private boolean failed;\n+\n+        public void run() {\n+            Result result = JUnitCore.runClasses(\n+                    ConfiguringDefaultReturnValuesUsingBaseClassTest.class,\n+                    ConfiguringDefaultReturnValuesUsingRunnerTest.class,\n+                    ConfiguringSelectedMocksToReturnFakesTest.class,\n+                    EqualsTest.class,\n+                    ListUtilTest.class,\n+                    MockingProgressImplTest.class,\n+                    TimesTest.class,\n+                    MockHandlerTest.class,\n+                    AllInvocationsFinderTest.class,\n+                    EmptyReturnValuesTest.class,\n+                    NumberOfInvocationsCheckerTest.class,\n+                    RegisteredInvocationsTest.class,\n+                    MissingInvocationCheckerTest.class,\n+                    NumberOfInvocationsInOrderCheckerTest.class,\n+                    MissingInvocationInOrderCheckerTest.class,\n+                    ClassImposterizerTest.class,\n+                    InvocationMatcherTest.class,\n+                    InvocationsFinderTest.class,\n+                    InvocationTest.class,\n+                    MockitoTest.class,\n+                    MockUtilTest.class,\n+                    ReporterTest.class,\n+                    MockitoAssertionErrorTest.class,\n+                    StackTraceRemoverTest.class,\n+                    MockitoExceptionTest.class,\n+                    StackTraceFilteringTest.class,\n+                    BridgeMethodPuzzleTest.class,\n+                    OverloadingPuzzleTest.class,\n+                    InvalidUsageTest.class,\n+                    UsingVarargsTest.class,\n+                    CustomMatchersTest.class,\n+                    ComparableMatchersTest.class,\n+                    InvalidUseOfMatchersTest.class,\n+                    MatchersTest.class,\n+                    MatchersToStringTest.class,\n+                    VerificationAndStubbingUsingMatchersTest.class,\n+                    BasicStubbingTest.class,\n+                    ReturningDefaultValuesTest.class,\n+                    StubbingWithThrowablesTest.class,\n+                    AtMostXVerificationTest.class,\n+                    BasicVerificationTest.class,\n+                    ExactNumberOfTimesVerificationTest.class,\n+                    VerificationInOrderTest.class,\n+                    NoMoreInteractionsVerificationTest.class,\n+                    SelectedMocksInOrderVerificationTest.class,\n+                    VerificationOnMultipleMocksUsingMatchersTest.class,\n+                    VerificationUsingMatchersTest.class,\n+                    RelaxedVerificationInOrderTest.class,\n+                    DescriptiveMessagesWhenVerificationFailsTest.class,\n+                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n+                    BasicVerificationInOrderTest.class,\n+                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n+                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n+                    InvalidStateDetectionTest.class,\n+                    ReplacingObjectMethodsTest.class,\n+                    StackTrackeChangingTest.class,\n+                    ExampleTest.class,\n+                    PointingStackTraceToActualInvocationTest.class,\n+                    PointingStackTraceToActualInvocationChunkTest.class,\n+                    VerificationInOrderFromMultipleThreadsTest.class,\n+                    ResetTest.class\n+                );\n+                \n+                if (!result.wasSuccessful()) {\n+                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n+                    List<Failure> failures = result.getFailures();\n+                    System.err.println(failures.size());\n+                    for (Failure failure : failures) {\n+                        System.err.println(failure.getTrace());\n+                        failed = true;\n+                    }\n+                }\n+        }\n+\n+        public boolean isFailed() {\n+            return failed;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRunInMultipleThreads() throws Exception {\n+        //this test ALWAYS fails if there is a single failing unit\n+        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(3));\n+    }\n+    \n+    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n+        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n+        for (int i = 1; i <= numberOfThreads; i++) {\n+            threads.add(new AllTestsRunner());\n+        }\n+\n+        for (Thread t : threads) {\n+            t.start();\n+        }\n+\n+        boolean failed = false;\n+        for (AllTestsRunner t : threads) {\n+            t.join();\n+            failed = failed ? true : t.isFailed();\n+        }\n+        \n+        return failed;\n+    }\n+    \n+    public static void main(String[] args) throws Exception {\n+        int numberOfThreads = 20; \n+        long before = System.currentTimeMillis();\n+        runInMultipleThreads(numberOfThreads);\n+        long after = System.currentTimeMillis();\n+        long executionTime = (after-before)/1000;\n+        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/reset/ResetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.reset;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ResetTest extends TestBase {\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = mock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void shouldClearArgumentMatcherStackSoAbuseOfArgumentMatchersIsNotDetectedAfterReset() {\n+        anyInt(); // abuse of matcher\n+        reset(mock);\n+        mock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void shouldNotThrowUnfinishedVerificationAfterReset() throws Exception {\n+        verify(mock); // unfinished verification\n+        reset(mock);\n+        mock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void shouldResetOngoingStubbingSoThatMoreMeaningfulExceptionsAreRaised() {\n+        mock(IMethods.class);\n+        mock.booleanReturningMethod();\n+        reset(mock);\n+        try {\n+            when(null).thenReturn(\"anything\");\n+            fail();\n+        } catch (MissingMethodInvocationException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveAllStubbing() throws Exception {\n+        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n+        when(mock.objectReturningMethod(200)).thenReturn(200);\n+        reset(mock);\n+        assertNull(mock.objectReturningMethod(200));\n+        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n+    }\n+\n+    @Test\n+    public void shouldRemoveAllInteractions() throws Exception {\n+        mock.simpleMethod(1);\n+        reset(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+\n+    @Test\n+    public void shouldRemoveStubbingToString() throws Exception {\n+        IMethods mockTwo = mock(IMethods.class);\n+        when(mockTwo.toString()).thenReturn(\"test\");\n+        reset(mockTwo);\n+        assertThat(mockTwo.toString(), contains(\"Mock for IMethods\"));\n+    }\n+\n+    @Test\n+    public void shouldStubbingNotBeTreatedAsInteraction() {\n+        when(mock.simpleMethod(\"one\")).thenThrow(new RuntimeException());\n+        doThrow(new RuntimeException()).when(mock).simpleMethod(\"two\");\n+        reset(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+\n+    @Test\n+    public void shouldNotAffectMockName() {\n+        IMethods mock = mock(IMethods.class, \"mockie\");\n+        IMethods mockTwo = mock(IMethods.class);\n+        reset(mock);\n+        assertContains(\"Mock for IMethods\", \"\" + mockTwo);\n+        assertEquals(\"mockie\", \"\" + mock);\n+    }\n+}", "timestamp": 1235075711, "metainfo": ""}