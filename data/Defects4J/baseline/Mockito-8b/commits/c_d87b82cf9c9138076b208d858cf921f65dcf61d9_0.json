{"sha": "d87b82cf9c9138076b208d858cf921f65dcf61d9", "log": "Started using Location instead of LocationImpl where possible", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockito.listeners.InvocationListener;\n \n import java.lang.reflect.Field;\n \n     }\n \n-    public void unfinishedStubbing(LocationImpl location) {\n+    public void unfinishedStubbing(Location location) {\n         throw new UnfinishedStubbingException(join(\n                 \"Unfinished stubbing detected here:\",\n                 location,\n         ));\n     }\n \n-    public void unfinishedVerificationException(LocationImpl location) {\n+    public void unfinishedVerificationException(Location location) {\n         UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                 \"Missing method call for verify(mock) here:\",\n                 location,\n         return join(description.toArray());\n     }\n \n-    public void argumentsAreDifferent(String wanted, String actual, LocationImpl actualLocation) {\n+    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n         String message = join(\"Argument(s) are different! Wanted:\",\n                 wanted,\n                 new LocationImpl(),\n         ));\n     }\n \n-    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, LocationImpl firstUndesired) {\n+    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new TooManyActualInvocations(message);\n     }\n \n     private String createTooManyInvocationsMessage(int wantedCount, int actualCount, PrintableInvocation wanted,\n-            LocationImpl firstUndesired) {\n+            Location firstUndesired) {\n         return join(\n                 wanted.toString(),\n                 \"Wanted \" + Pluralizer.pluralize(wantedCount) + \":\",\n         );\n     }\n \n-    public void neverWantedButInvoked(PrintableInvocation wanted, LocationImpl firstUndesired) {\n+    public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n         throw new NeverWantedButInvoked(join(\n                 wanted.toString(),\n                 \"Never wanted here:\",\n         ));\n     }\n \n-    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, LocationImpl firstUndesired) {\n+    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n     }\n \n     private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n-            LocationImpl lastActualInvocation) {\n+            Location lastActualInvocation) {\n         String ending =\n             (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n \n             return message;\n     }\n \n-    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, LocationImpl lastActualLocation) {\n+    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n \n         throw new TooLittleActualInvocations(message);\n     }\n \n-    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, LocationImpl lastActualLocation) {\n+    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n \n         throw new VerificationInOrderFailure(join(\n                 ));\n     }\n \n-    public void smartNullPointerException(String invocation, LocationImpl location) {\n+    public void smartNullPointerException(String invocation, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new LocationImpl(),\n--- a/src/org/mockito/internal/debugging/Localized.java\n+++ b/src/org/mockito/internal/debugging/Localized.java\n package org.mockito.internal.debugging;\n \n \n+import org.mockito.invocation.Location;\n+\n public class Localized<T> {\n \n     private final T object;\n-    private final LocationImpl location;\n+    private final Location location;\n \n     public Localized(T object) {\n         this.object = object;\n         return object;\n     }\n \n-    public LocationImpl getLocation() {\n+    public Location getLocation() {\n         return location;\n     }\n }\n--- a/src/org/mockito/internal/invocation/InvocationImpl.java\n+++ b/src/org/mockito/internal/invocation/InvocationImpl.java\n import org.mockito.internal.reporting.PrintSettings;\n import org.mockito.invocation.Invocation;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.invocation.Location;\n import org.mockito.invocation.StubInfo;\n \n import java.lang.reflect.Method;\n     private final Object[] arguments;\n     private final Object[] rawArguments;\n \n-    private final LocationImpl location;\n+    private final Location location;\n     private boolean verified;\n     private boolean isIgnoredForVerification;\n \n         return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);\n     }\n \n-    public LocationImpl getLocation() {\n+    public Location getLocation() {\n         return location;\n     }\n \n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.internal.reporting.PrintSettings;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcher implements PrintableInvocation, CapturesArgumensFromInvocation, Serializable {\n         return false;\n     }\n     \n-    public LocationImpl getLocation() {\n+    public Location getLocation() {\n         return invocation.getLocation();\n     }\n \n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class InvocationsFinder {\n \n         return null;\n     }\n \n-    public LocationImpl getLastLocation(List<Invocation> invocations) {\n+    public Location getLastLocation(List<Invocation> invocations) {\n         if (invocations.isEmpty()) {\n             return null;\n         } else {\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n \n import org.hamcrest.*;\n import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.invocation.Location;\n \n @SuppressWarnings(\"unchecked\")\n public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator, Serializable {\n \n     private static final long serialVersionUID = 6748641229659825725L;\n     private final Matcher actualMatcher;\n-    private LocationImpl location;\n+    private Location location;\n \n     public LocalizedMatcher(Matcher actualMatcher) {\n         this.actualMatcher = actualMatcher;\n         actualMatcher.describeTo(description);\n     }\n \n-    public LocationImpl getLocation() {\n+    public Location getLocation() {\n         return location;\n     }\n     \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.internal.listeners.MockingStartedListener;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n     \n     IOngoingStubbing iOngoingStubbing;\n     private Localized<VerificationMode> verificationMode;\n-    private LocationImpl stubbingInProgress = null;\n+    private Location stubbingInProgress = null;\n     private MockingProgressListener listener;\n \n     public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n         \n         //validate stubbing:\n         if (stubbingInProgress != null) {\n-            LocationImpl temp = stubbingInProgress;\n+            Location temp = stubbingInProgress;\n             stubbingInProgress = null;\n             reporter.unfinishedStubbing(temp);\n         }\n         GlobalConfiguration.validate();\n \n         if (verificationMode != null) {\n-            LocationImpl location = verificationMode.getLocation();\n+            Location location = verificationMode.getLocation();\n             verificationMode = null;\n             reporter.unfinishedVerificationException(location);\n         }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.invocation.Location;\n import org.mockito.plugins.MockMaker;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n \n     private final class ThrowingInterceptor implements MockitoInvocationHandler {\n         private final InvocationOnMock invocation;\n-        private final LocationImpl location = new LocationImpl();\n+        private final Location location = new LocationImpl();\n \n         private ThrowingInterceptor(InvocationOnMock invocation) {\n             this.invocation = invocation;\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class AtLeastXNumberOfInvocationsChecker {\n     \n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            LocationImpl lastLocation = finder.getLastLocation(actualInvocations);\n+            Location lastLocation = finder.getLastLocation(actualInvocations);\n             reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        \n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class AtLeastXNumberOfInvocationsInOrderChecker {\n     \n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            LocationImpl lastLocation = finder.getLastLocation(chunk);\n+            Location lastLocation = finder.getLastLocation(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n import java.util.List;\n \n     \n     public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         int actualCount = 0;\n-        LocationImpl lastLocation = null;\n+        Location lastLocation = null;\n         while( actualCount < wantedCount ){\n             Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n             if( next == null ){\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class NumberOfInvocationsChecker {\n     \n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            LocationImpl lastInvocation = finder.getLastLocation(actualInvocations);\n+            Location lastInvocation = finder.getLastLocation(actualInvocations);\n             reporter.tooLittleActualInvocations(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount == 0 && actualCount > 0) {\n-            LocationImpl firstUndesired = actualInvocations.get(wantedCount).getLocation();\n+            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n             reporter.neverWantedButInvoked(wanted, firstUndesired); \n         } else if (wantedCount < actualCount) {\n-            LocationImpl firstUndesired = actualInvocations.get(wantedCount).getLocation();\n+            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n \n public class NumberOfInvocationsInOrderChecker {\n     \n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            LocationImpl lastInvocation = finder.getLastLocation(chunk);\n+            Location lastInvocation = finder.getLastLocation(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount < actualCount) {\n-            LocationImpl firstUndesired = chunk.get(wantedCount).getLocation();\n+            Location firstUndesired = chunk.get(wantedCount).getLocation();\n             reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n--- a/src/org/mockito/invocation/Invocation.java\n+++ b/src/org/mockito/invocation/Invocation.java\n package org.mockito.invocation;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n \n /**\n  * by Szczepan Faber, created at: 3/31/12\n  */\n-public interface Invocation extends InvocationOnMock {\n+public interface Invocation extends InvocationOnMock, PrintableInvocation {\n \n     boolean isVerified();\n \n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldGetLastStackTrace() throws Exception {\n-        LocationImpl last = finder.getLastLocation(invocations);\n+        Location last = finder.getLastLocation(invocations);\n         assertSame(differentMethodInvocation.getLocation(), last);\n         \n         assertNull(finder.getLastLocation(Collections.<InvocationImpl>emptyList()));\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationCheckerTest extends TestBase {\n     class ReporterStub extends Reporter {\n         private Object wanted;\n         private String actual;\n-        private LocationImpl actualLocation;\n+        private Location actualLocation;\n         \n         @Override\n         public void wantedButNotInvoked(PrintableInvocation wanted, List<? extends PrintableInvocation> invocations) {\n             this.wanted = wanted;\n         }\n         \n-        @Override public void argumentsAreDifferent(String wanted, String actual, LocationImpl actualLocation) {\n+        @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n                     this.wanted = wanted;\n                     this.actual = actual;\n                     this.actualLocation = actualLocation;\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationInOrderCheckerTest extends TestBase {\n         private PrintableInvocation previous;\n         private String wantedString;\n         private String actual;\n-        private LocationImpl actualLocation;\n+        private Location actualLocation;\n         \n         @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n             this.wanted = wanted;\n             this.wanted = wanted;\n         }\n \n-        @Override public void argumentsAreDifferent(String wanted, String actual, LocationImpl actualLocation) {\n+        @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n             this.wantedString = wanted;\n             this.actual = actual;\n             this.actualLocation = actualLocation;\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Location;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsCheckerTest extends TestBase {\n         private int wantedCount;\n         private int actualCount;\n         private PrintableInvocation wanted;\n-        private LocationImpl location;\n-        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, LocationImpl lastActualLocation) {\n+        private Location location;\n+        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n                     this.wantedCount = discrepancy.getWantedCount();\n                     this.actualCount = discrepancy.getActualCount();\n                     this.wanted = wanted;\n                     this.location = lastActualLocation;\n         }\n         \n-        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, LocationImpl firstUndesired) {\n+        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n                     this.wantedCount = wantedCount;\n                     this.actualCount = actualCount;\n                     this.wanted = wanted;\n         }\n         \n         @Override\n-        public void neverWantedButInvoked(PrintableInvocation wanted, LocationImpl firstUndesired) {\n+        public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n             this.wanted = wanted;\n             this.location = firstUndesired;\n         }", "timestamp": 1333232968, "metainfo": ""}