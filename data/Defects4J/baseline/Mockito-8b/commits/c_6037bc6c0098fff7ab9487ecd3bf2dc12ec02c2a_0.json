{"sha": "6037bc6c0098fff7ab9487ecd3bf2dc12ec02c2a", "log": "Getting rid of static code  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401330", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoCore {\n \n-    private static final Reporter REPORTER = new Reporter();\n-    public static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n+    private final Reporter reporter = new Reporter();\n+    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n     public <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n-        MOCKING_PROGRESS.validateState();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n-        return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n+        mockingProgress.validateState();\n+        mockingProgress.resetOngoingStubbing();\n+        return MockUtil.createMock(classToMock, mockingProgress, name, optionalInstance, returnValues);\n     }\n     \n     public OngoingStubbing stub() {\n-        OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n+        OngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n         if (stubbing == null) {\n-            MOCKING_PROGRESS.reset();\n-            REPORTER.missingMethodInvocation();\n+            mockingProgress.reset();\n+            reporter.missingMethodInvocation();\n         }\n         return stubbing;\n     }\n \n     @Deprecated\n     public <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n-        MOCKING_PROGRESS.stubbingStarted();\n+        mockingProgress.stubbingStarted();\n         return (DeprecatedOngoingStubbing) stub();\n     }\n \n     public <T> NewOngoingStubbing<T> when(T methodCall) {\n-        MOCKING_PROGRESS.stubbingStarted();\n+        mockingProgress.stubbingStarted();\n         return (NewOngoingStubbing) stub();\n     }\n     \n     \n     public <T> T verify(T mock, VerificationMode mode) {\n         if (mock == null) {\n-            REPORTER.nullPassedToVerify();\n+            reporter.nullPassedToVerify();\n         } else if (!MockUtil.isMock(mock)) {\n-            REPORTER.notAMockPassedToVerify();\n+            reporter.notAMockPassedToVerify();\n         }\n-        MOCKING_PROGRESS.verificationStarted(mode);\n+        mockingProgress.verificationStarted(mode);\n         return mock;\n     }\n     \n     public <T> void reset(T ... mocks) {\n-        MOCKING_PROGRESS.validateState();\n-        MOCKING_PROGRESS.reset();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n+        mockingProgress.validateState();\n+        mockingProgress.reset();\n+        mockingProgress.resetOngoingStubbing();\n         \n         for (T m : mocks) {\n-            MockUtil.resetMock(m, MOCKING_PROGRESS);\n+            MockUtil.resetMock(m, mockingProgress);\n         }\n     }\n     \n     public void verifyNoMoreInteractions(Object... mocks) {\n         assertMocksNotEmpty(mocks);\n-        MOCKING_PROGRESS.validateState();\n+        mockingProgress.validateState();\n         for (Object mock : mocks) {\n             try {\n                 if (mock == null) {\n-                    REPORTER.nullPassedToVerifyNoMoreInteractions();\n+                    reporter.nullPassedToVerifyNoMoreInteractions();\n                 }\n                 MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n             } catch (NotAMockException e) {\n-                REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n+                reporter.notAMockPassedToVerifyNoMoreInteractions();\n             }\n         }\n     }\n     \n     public void assertMocksNotEmpty(Object[] mocks) {\n         if (mocks == null || mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n+            reporter.mocksHaveToBePassedToVerifyNoMoreInteractions();\n         }\n     }\n     \n     public InOrder inOrder(Object... mocks) {\n         if (mocks == null || mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n+            reporter.mocksHaveToBePassedWhenCreatingInOrder();\n         }\n         for (Object mock : mocks) {\n             if (mock == null) {\n-                REPORTER.nullPassedWhenCreatingInOrder();\n+                reporter.nullPassedWhenCreatingInOrder();\n             } else if (!MockUtil.isMock(mock)) {\n-                REPORTER.notAMockPassedWhenCreatingInOrder();\n+                reporter.notAMockPassedWhenCreatingInOrder();\n             }\n         }\n         InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n     }\n     \n     public Stubber doAnswer(Answer answer) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n+        mockingProgress.stubbingStarted();\n+        mockingProgress.resetOngoingStubbing();\n         return new StubberImpl().doAnswer(answer);\n     }\n     \n     public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n         MockHandler<T> handler = MockUtil.getMockHandler(mock);\n-        MOCKING_PROGRESS.stubbingStarted();\n+        mockingProgress.stubbingStarted();\n         return handler.voidMethodStubbable(mock);\n     }\n-\n-}\n+}\n--- a/test/org/mockito/StateMaster.java\n+++ b/test/org/mockito/StateMaster.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.MockitoCore;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n \n public class StateMaster {\n     \n+    private static final ThreadSafeMockingProgress MOCKING_PROGRESS= new ThreadSafeMockingProgress();\n+\n     public static void reset() {\n-        MockitoCore.MOCKING_PROGRESS.reset();\n+        MOCKING_PROGRESS.reset();\n     }\n     \n     public static void validate() {\n-        MockitoCore.MOCKING_PROGRESS.validateState();\n+        MOCKING_PROGRESS.validateState();\n     }\n }\n--- a/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n import static org.mockito.Matchers.*;\n \n import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.mockito.AdditionalMatchers;\n+import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n \n public class InvalidUseOfMatchersTest extends TestBase {\n \n-    private IMethods mock;\n-\n-    @Before\n-    public void setUp() {\n-        StateMaster.reset();\n-        mock = Mockito.mock(IMethods.class);\n-    }\n+    @Mock private IMethods mock;\n \n     @After\n     public void resetState() {\n--- a/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.StateMaster;\n \n     @Mock private WithFinal withFinal;\n     \n-    @Before\n     @After\n     public void resetState() {\n         StateMaster.reset();\n--- a/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n  */\n package org.mockitousage.misuse;\n \n+import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n @SuppressWarnings({\"unchecked\", \"deprecation\"})\n public class InvalidStateDetectionTest extends TestBase {\n \n-    private IMethods mock;\n-\n-    @Before\n+    @Mock private IMethods mock;\n+\n     @After\n     public void resetState() {\n         StateMaster.reset();\n-        mock = mock(IMethods.class);\n     }\n     \n     @Test\n--- a/test/org/mockitousage/misuse/InvalidUsageTest.java\n+++ b/test/org/mockitousage/misuse/InvalidUsageTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.mockito.InOrder;\n+import org.mockito.Mock;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n \n public class InvalidUsageTest extends TestBase {\n \n-    private IMethods mock;\n-    private IMethods mockTwo;\n+    @Mock private IMethods mock;\n+    @Mock private IMethods mockTwo;\n \n-    @Before\n-    public void setup() {\n-        mock = mock(IMethods.class);\n-        mockTwo = mock(IMethods.class);\n-    }\n-    \n     @After\n     public void resetState() {\n         StateMaster.reset();\n--- a/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n+++ b/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n     \n     @Before\n     public void setup() {\n-        resetState();\n         ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n     }\n     ", "timestamp": 1239808775, "metainfo": ""}