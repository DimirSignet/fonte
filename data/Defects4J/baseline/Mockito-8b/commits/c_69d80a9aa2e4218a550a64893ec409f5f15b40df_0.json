{"sha": "69d80a9aa2e4218a550a64893ec409f5f15b40df", "log": "issue 260 : use field name for unnamed mocks", "commit": "\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.*;\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.reflection.FieldReader;\n \n         \n         while (clazz != Object.class) {\n             mockDependentFields.addAll(scanForInjection(testClassInstance, clazz));\n-            mocks.addAll(scanMocks(testClassInstance, clazz));\n+            mocks.addAll(scanAndPrepareMocks(testClassInstance, clazz));\n             clazz = clazz.getSuperclass();\n         }\n         \n      * @param testClassInstance Instance of the test\n      * @param clazz Current class in the hierarchy of the test\n      * @return Fields that depends on Mock\n+     *\n+     * @see #scanAndPrepareMocks(Object, Class)\n      */\n     private Set<Field> scanForInjection(final Object testClassInstance, final Class<?> clazz) {\n         Set<Field> mockDependentFields = new HashSet<Field>();\n         return mockDependentFields;\n     }\n \n-    private Set<Object> scanMocks(final Object testClassInstance, final Class<?> clazz) {\n+    /**\n+     * Scan mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.\n+     *\n+     * <p>\n+     *     Actually the preparation of mocks consists only in defining a MockName if not already set.\n+     * </p>\n+     *\n+     * @param testClassInstance The test instance\n+     * @param clazz The class in the type hierarchy of this instance.\n+     * @return A prepared set of mock\n+     */\n+    private Set<Object> scanAndPrepareMocks(final Object testClassInstance, final Class<?> clazz) {\n         Set<Object> mocks = new HashSet<Object>();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n             FieldReader fieldReader = new FieldReader(testClassInstance, field);\n             if (containsMockOrSpy(field, fieldReader)) {\n-                Object fieldInstance = fieldReader.read();\n-//                boolean wasAccessible = field.isAccessible();\n-//                field.setAccessible(true);\n-//                try {\n-//                    fieldInstance = field.get(testClassInstance);\n-//                } catch (IllegalAccessException e) {\n-//                    throw new MockitoException(\"Problems reading this field dependency \" + field.getName() + \" for injection\", e);\n-//                } finally {\n-//                    field.setAccessible(wasAccessible);\n-//                }\n-                if (fieldInstance != null) {\n-                    mocks.add(fieldInstance);\n+                Object mockInstance = fieldReader.read();\n+\n+                if (mockInstance != null) {\n+                    mockUtil.redefineMockNameIfSurrogate(mockInstance, field.getName());\n+                    mocks.add(mockInstance);\n                 }\n             }\n         }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import org.mockito.MockSettings;\n     public boolean hasInvocationListeners() {\n         return !invocationListeners.isEmpty();\n     }\n+\n+    public void redefineMockName(String newName) {\n+        mockName = new MockName(newName);\n+    }\n }\n \n--- a/src/org/mockito/internal/util/MockName.java\n+++ b/src/org/mockito/internal/util/MockName.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import java.io.Serializable;\n         } else {\n             this.mockName = mockName;\n         }\n+    }\n+\n+    public MockName(String mockName) {\n+        this.mockName = mockName;\n     }\n \n     private static String toInstanceName(Class<?> clazz) {\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.cglib.proxy.Callback;\n     public MockName getMockName(Object mock) {\n         return getMockHandler(mock).getMockSettings().getMockName();\n     }\n+\n+    public void redefineMockNameIfSurrogate(Object mock, String newName) {\n+        if (getMockName(mock).isSurrogate()) {\n+            getMockHandler(mock).getMockSettings().redefineMockName(newName);\n+        }\n+    }\n }\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import org.fest.assertions.Assertions;\n         }\n     }\n \n+    @Test\n+    public void should_redefine_mockName() throws Exception {\n+        mockSettingsImpl.redefineMockName(\"my name is ...\");\n+\n+        assertEquals(\"my name is ...\", mockSettingsImpl.getMockName().toString());\n+    }\n+\n     private InvocationListener getListener(MockSettingsImpl settings) {\n     \treturn settings.getInvocationListeners().iterator().next();\n     }\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n \n package org.mockito.internal.util;\n \n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.Enhancer;\n         assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));\n         assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));\n     }\n+\n+    @Test\n+    public void should_redefine_MockName_if_surrogate() {\n+        List mock = Mockito.mock(List.class);\n+        mockUtil.redefineMockNameIfSurrogate(mock, \"newName\");\n+\n+        Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"newName\");\n+    }\n+\n+    @Test\n+    public void should_not_redefine_MockName_if_surrogate() {\n+        List mock = Mockito.mock(List.class, \"original\");\n+        mockUtil.redefineMockNameIfSurrogate(mock, \"newName\");\n+\n+        Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"original\");\n+    }\n }\n--- a/test/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java\n+++ b/test/org/mockitousage/annotation/InjectionOfInlinedMockDeclarationTest.java\n import org.mockito.runners.MockitoJUnitRunner;\n \n import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.spy;\n \n     @InjectMocks private Receiver receiver;\n     @InjectMocks private Receiver spiedReceiver = spy(new Receiver());\n \n-    private Antena antena = mock(Antena.class);\n+    private Antenna oldAntenna = mock(Antenna.class);\n+    private Antenna satelliteAntenna = mock(Antenna.class);\n+    private Antenna antenna = mock(Antenna.class, \"dvbtAntenna\");\n     private Tuner tuner = spy(new Tuner());\n \n     @Test\n     public void mock_declared_fields_shall_be_injected_too() throws Exception {\n-        assertNotNull(receiver.antena);\n+        assertNotNull(receiver.oldAntenna);\n+        assertNotNull(receiver.satelliteAntenna);\n+        assertNotNull(receiver.dvbtAntenna);\n         assertNotNull(receiver.tuner);\n     }\n \n     @Test\n+    public void unnamed_mocks_should_be_resolved_withe_their_field_names() throws Exception {\n+        assertSame(oldAntenna, receiver.oldAntenna);\n+        assertSame(satelliteAntenna, receiver.satelliteAntenna);\n+    }\n+\n+    @Test\n+    public void named_mocks_should_be_resolved_with_their_name() throws Exception {\n+        assertSame(antenna, receiver.dvbtAntenna);\n+    }\n+\n+\n+    @Test\n     public void inject_mocks_even_in_declared_spy() throws Exception {\n-        assertNotNull(spiedReceiver.antena);\n+        assertNotNull(spiedReceiver.oldAntenna);\n         assertNotNull(spiedReceiver.tuner);\n     }\n \n     // note that static class is not private !!\n     static class Receiver {\n-        Antena antena;\n+        Antenna oldAntenna;\n+        Antenna satelliteAntenna;\n+        Antenna dvbtAntenna;\n         Tuner tuner;\n \n         public boolean tune() { return true; }\n     }\n \n-    private static class Antena { }\n+    private static class Antenna { }\n     private static class Tuner { }\n \n }", "timestamp": 1319810932, "metainfo": ""}