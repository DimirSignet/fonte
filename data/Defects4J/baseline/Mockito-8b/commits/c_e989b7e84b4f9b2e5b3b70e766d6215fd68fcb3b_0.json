{"sha": "e989b7e84b4f9b2e5b3b70e766d6215fd68fcb3b", "log": "minor tweaks regarding field initialization and javadocs", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * a parameterized constructor only or a no-arg constructor only, or both.\n  * All these constructors can be package protected, protected or private, however\n  * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n+ * <u>Beware of private nest static classes too.</u>\n  *\n  * <p>The same stands for setters or fields, they can be declared with private\n  * visibility, Mockito will see them through reflection.\n--- a/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n             SimpleArgumentResolver simpleArgumentResolver = new SimpleArgumentResolver(mockCandidates);\n             FieldInitializationReport report = new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();\n \n-            return report.fieldWasInitialized();\n+            return report.fieldWasInitializedUsingContructorArgs();\n         } catch (MockitoException e) {\n             if(e.getCause() instanceof InvocationTargetException) {\n                 Throwable realCause = e.getCause().getCause();\n                 new Reporter().fieldInitialisationThrewException(field, realCause);\n             }\n+            // other causes should be fine\n             return false;\n         }\n \n--- a/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n \n package org.mockito.internal.util.reflection;\n \n+/**\n+ * Report on field initialization\n+ */\n public class FieldInitializationReport {\n     private Object fieldInstance;\n     private boolean wasInitialized;\n+    private boolean wasInitializedUsingConstructorArgs;\n \n-    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized) {\n+    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized, boolean wasInitializedUsingConstructorArgs) {\n         this.fieldInstance = fieldInstance;\n         this.wasInitialized = wasInitialized;\n+        this.wasInitializedUsingConstructorArgs = wasInitializedUsingConstructorArgs;\n     }\n \n+    /**\n+     * Returns the actual field instance.\n+     *\n+     * @return the actual instance\n+     */\n     public Object fieldInstance() {\n         return fieldInstance;\n     }\n \n+    /**\n+     * Indicate wether the field was created during the process or not.\n+     *\n+     * @return <code>true</code> if created, <code>false</code> if the field did already hold an instance.\n+     */\n     public boolean fieldWasInitialized() {\n         return wasInitialized;\n     }\n \n+    /**\n+     * Indicate wether the field was created using constructor args.\n+     *\n+     * @return <code>true</code> if field was created using constructor parameters.\n+     */\n+    public boolean fieldWasInitializedUsingContructorArgs() {\n+        return wasInitializedUsingConstructorArgs;\n+    }\n+\n+    /**\n+     * Returns the class of the actual instance in the field.\n+     *\n+     * @return Class of the instance\n+     */\n     public Class<?> fieldClass() {\n         return fieldInstance != null ? fieldInstance.getClass() : null;\n     }\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n      *\n      * @param fieldOwner Instance of the test.\n      * @param field Field to be initialize.\n+     * @param argResolver Constructor parameters resolver\n      */\n     public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {\n         this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));\n     }\n \n     /**\n-     * Initialize field if no initialized and return the actual instance.\n+     * Initialize field if not initialized and return the actual instance.\n      *\n      * @return Actual field instance.\n      */\n     private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {\n         Object fieldInstance = field.get(fieldOwner);\n         if(fieldInstance != null) {\n-            return new FieldInitializationReport(fieldInstance, false);\n-        }\n-\n-        instantiator.instantiate();\n-        return new FieldInitializationReport(field.get(fieldOwner), true);\n+            return new FieldInitializationReport(fieldInstance, false, false);\n+        }\n+\n+        return instantiator.instantiate();\n     }\n \n     /**\n     }\n \n     private interface ConstructorInstantiator {\n-        Object instantiate();\n+        FieldInitializationReport instantiate();\n     }\n \n     /**\n             this.field = field;\n         }\n \n-        public Object instantiate() {\n+        public FieldInitializationReport instantiate() {\n             final AccessibilityChanger changer = new AccessibilityChanger();\n             Constructor<?> constructor = null;\n             try {\n                 Object newFieldInstance = constructor.newInstance(noArg);\n                 new FieldSetter(testClass, field).set(newFieldInstance);\n \n-                return field.get(testClass);\n+                return new FieldInitializationReport(field.get(testClass), true, false);\n             } catch (NoSuchMethodException e) {\n                 throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n             } catch (InvocationTargetException e) {\n             this.argResolver = argumentResolver;\n         }\n \n-        public Object instantiate() {\n+        public FieldInitializationReport instantiate() {\n             final AccessibilityChanger changer = new AccessibilityChanger();\n             Constructor<?> constructor = null;\n             try {\n                 Object newFieldInstance = constructor.newInstance(args);\n                 new FieldSetter(testClass, field).set(newFieldInstance);\n \n-                return field.get(testClass);\n+                return new FieldInitializationReport(field.get(testClass), false, true);\n             } catch (IllegalArgumentException e) {\n                 throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n             } catch (InvocationTargetException e) {\n--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n \n         assertSame(backupInstance, report.fieldInstance());\n         assertFalse(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test\n \n         assertNotNull(report.fieldInstance());\n         assertTrue(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test\n \n         assertNotNull(report.fieldInstance());\n         assertTrue(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test\n \n         assertNotNull(report.fieldInstance());\n         assertTrue(report.fieldWasInitialized());\n+        assertFalse(report.fieldWasInitializedUsingContructorArgs());\n     }\n \n     @Test(expected = MockitoException.class)", "timestamp": 1318008210, "metainfo": ""}