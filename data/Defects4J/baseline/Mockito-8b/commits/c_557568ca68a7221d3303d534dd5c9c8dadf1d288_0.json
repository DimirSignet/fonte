{"sha": "557568ca68a7221d3303d534dd5c9c8dadf1d288", "log": "mergin issue 148", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n  */\n package org.mockito;\n \n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.stubbing.Answer;\n+\n import java.io.Serializable;\n-\n-import org.mockito.stubbing.Answer;\n \n /**\n  * Allows mock creation with additional mock settings. \n      * Sets the real implementation to be called when the method is called on a mock object.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings serializable();\n-}\n+    \n+    /**\n+     * Enables real-time logging of method invocations on this mock. Can be used\n+     * during test debugging in order to find wrong interactions with this mock.\n+     * <p>\n+     * Invocations are logged as they happen to the standard output stream.\n+     * <p>\n+     * Calling this method multiple times makes no difference.\n+     * <p>\n+     * Example:\n+     * <pre>\n+     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n+     * </pre>\n+     * \n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings verboseLogging();\n+    \n+    /**\n+     * Registers a listener for method invocations on this mock. The listener is\n+     * notified every time a method on this mock is called.\n+     * <p>\n+     * Multiple listeners may be added, but the same object is only added once.\n+     * The order, in which the listeners are added, is not guaranteed to be the\n+     * order in which the listeners are notified. \n+     * \n+     * Example:\n+     * <pre>\n+     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n+     * </pre>\n+     * \n+     * See the {@link InvocationListener listener interface} for more details.\n+     * \n+     * @param listeners The invocation listeners to add. May not be null.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings invocationListeners(InvocationListener... listeners);\n+}\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.StringJoiner;\n+import org.mockito.listeners.InvocationListener;\n \n import java.lang.reflect.Field;\n import java.util.List;\n                 \"\"), details);\n \n     }\n+\n+    public void invocationListenerDoesNotAcceptNullParameters() {\n+        throw new MockitoException(\"invocationListeners() does not accept null parameters\");\n+    }\n+\n+    public void invocationListenersRequiresAtLeastOneListener() {\n+        throw new MockitoException(\"invocationListeners() requires at least one listener\");\n+    }\n+\n+    public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {\n+        throw new MockitoException(StringJoiner.join(\n+                \"The invocation listener with type \" + listener.getClass().getName(),\n+                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n+    }\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n+package org.mockito.internal;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+\n+import java.util.List;\n+\n+/**\n+ * Handler, that call all listeners wanted for this mock, before delegating it\n+ * to the parameterized handler.\n+ *\n+ * Also imposterize MockHandler, delegate all call of MockHandlerInterface to the real mockHandler\n+ */\n+public class InvocationNotifierHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T>  {\n+\n+    private List<InvocationListener> invocationListeners;\n+    private MockHandler<T> mockHandler;\n+\n+    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsImpl settings) {\n+        this.mockHandler = mockHandler;\n+        this.invocationListeners = settings.getInvocationListeners();\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+        try {\n+            Object returnedValue = mockHandler.handle(invocation);\n+            notifyMethodCall(invocation, returnedValue);\n+            return returnedValue;\n+        } catch (Throwable t){\n+            notifyMethodCallException(invocation, t);\n+            throw t;\n+        }\n+    }\n+\n+\n+\tprivate void notifyMethodCall(Invocation invocation, Object returnValue) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    private void notifyMethodCallException(Invocation invocation, Throwable exception) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    public MockSettingsImpl getMockSettings() {\n+        return mockHandler.getMockSettings();\n+    }\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return mockHandler.voidMethodStubbable(mock);\n+    }\n+\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        mockHandler.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return mockHandler.getInvocationContainer();\n+    }\n+\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n     }\n \n     public Object handle(Invocation invocation) throws Throwable {\n-        if (invocationContainerImpl.hasAnswersForStubbing()) {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n             // stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n-                            .getArgumentMatcherStorage(), invocation);\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n             invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n             return null;\n         }\n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n \n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n-                        invocation);\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n \n         mockingProgress.validateState();\n \n-        //if verificationMode is not null then someone is doing verify()        \n+        // if verificationMode is not null then someone is doing verify()\n         if (verificationMode != null) {\n-            //We need to check if verification was started on the correct mock \n+            // We need to check if verification was started on the correct mock\n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            //TODO: can I avoid this cast here?\n-            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n-                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n+            // TODO: can I avoid this cast here?\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                 verificationMode.verify(data);\n                 return null;\n             } else {\n-                // this means there is an invocation on a different mock. Re-adding verification mode \n+                // this means there is an invocation on a different mock. Re-adding verification mode\n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                 mockingProgress.verificationStarted(verificationMode);\n             }\n             invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n             return ret;\n         }\n-    }\n+\t}\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n     public InvocationContainer getInvocationContainer() {\n         return invocationContainerImpl;\n     }\n-}\n+}\n+\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n import org.mockito.internal.util.MockName;\n+import org.mockito.listeners.InvocationListener;\n import org.mockito.stubbing.Answer;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class MockSettingsImpl implements MockSettings {\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n     private boolean serializable;\n+    private List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public MockSettings serializable() {\n         this.serializable = true;\n     public void initiateMockName(Class classToMock) {\n         mockName = new MockName(name, classToMock);\n     }\n-}\n+\n+\tpublic MockSettings verboseLogging() {\n+        if (!invocationListenersContainsType(VerboseMockInvocationLogger.class)) {\n+            invocationListeners(new VerboseMockInvocationLogger());\n+        }\n+        return this;\n+\t}\n+\n+    public MockSettings invocationListeners(InvocationListener... listeners) {\n+        if (listeners == null || listeners.length == 0) {\n+            new Reporter().invocationListenersRequiresAtLeastOneListener();\n+        }\n+        for (InvocationListener listener : listeners) {\n+            if (listener == null) {\n+                new Reporter().invocationListenerDoesNotAcceptNullParameters();\n+            }\n+            this.invocationListeners.add(listener);\n+        }\n+\t\treturn this;\n+\t}\n+\n+\tprivate boolean invocationListenersContainsType(Class<?> clazz) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+\t\t\tif (listener.getClass().equals(clazz)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+    public List<InvocationListener> getInvocationListeners() {\n+        return this.invocationListeners;\n+    }\n+\n+    public boolean containsInvocationListener(InvocationListener invocationListener) {\n+        return invocationListeners.contains(invocationListener);\n+    }\n+\n+    public boolean hasInvocationListeners() {\n+        return !invocationListeners.isEmpty();\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java\n+package org.mockito.internal.debugging;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+\n+import java.io.PrintStream;\n+\n+/**\n+ * Logs all invocations to standard output.\n+ * \n+ * Used for debugging interactions with a mock. \n+ */\n+public class VerboseMockInvocationLogger implements InvocationListener {\n+\n+    // visible for testing\n+\tfinal PrintStream printStream;\n+\n+\tprivate int mockInvocationsCounter = 0;\n+\n+    public VerboseMockInvocationLogger() {\n+        this(System.out);\n+    }\n+\n+    public VerboseMockInvocationLogger(PrintStream printStream) {\n+        this.printStream = printStream;\n+    }\n+\n+    public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+        printHeader();\n+        printStubInfo(methodInvocationReport);\n+        printInvocation(methodInvocationReport.getInvocation());\n+        printReturnedValueOrThrowable(methodInvocationReport);\n+        printFooter();\n+    }\n+\n+    private void printReturnedValueOrThrowable(MethodInvocationReport methodInvocationReport) {\n+        if (methodInvocationReport.threwException()) {\n+            String message = methodInvocationReport.getThrowable().getMessage() == null ? \"\" : \" with message \" + methodInvocationReport.getThrowable().getMessage();\n+            printlnIndented(\"has thrown: \" + methodInvocationReport.getThrowable().getClass() + message);\n+        } else {\n+            String type = (methodInvocationReport.getReturnedValue() == null) ? \"\" : \" (\" + methodInvocationReport.getReturnedValue().getClass().getName() + \")\";\n+            printlnIndented(\"has returned: \\\"\" + methodInvocationReport.getReturnedValue() + \"\\\"\" + type);\n+        }\n+    }\n+\n+    private void printStubInfo(MethodInvocationReport methodInvocationReport) {\n+        if (methodInvocationReport.getLocationOfStubbing() != null) {\n+            printlnIndented(\"stubbed: \" + methodInvocationReport.getLocationOfStubbing());\n+        }\n+    }\n+\n+    private void printHeader() {\n+\t\tmockInvocationsCounter++;\n+\t\tprintStream.println(\"############ Logging method invocation #\" + mockInvocationsCounter + \" on mock/spy ########\");\n+\t}\n+\n+    private void printInvocation(PrintableInvocation invocation) {\n+\t\tprintStream.println(invocation.toString());\n+//\t\tprintStream.println(\"Handling method call on a mock/spy.\");\n+\t\tprintlnIndented(\"invoked: \" + invocation.getLocation().toString());\n+\t}\n+\n+\tprivate void printFooter() {\n+\t\tprintStream.println(\"\");\n+\t}\n+\t\n+\tprivate void printlnIndented(String message) {\n+\t\tprintStream.println(\"   \" + message);\n+\t}\n+\t\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n+package org.mockito.internal.listeners;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.listeners.MethodInvocationReport;\n+\n+/**\n+ * Report on a method call\n+ */\n+public class NotifiedMethodInvocationReport implements MethodInvocationReport {\n+        private final Invocation invocation;\n+        private Object returnedValue;\n+        private Throwable throwable;\n+\n+\n+        /**\n+         * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n+         *\n+         *\n+         * @param invocation Information on the method call\n+         * @param returnedValue The value returned by the method invocation\n+         */\n+        public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n+            this.invocation = invocation;\n+            this.returnedValue = returnedValue;\n+        }\n+\n+        /**\n+         * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n+         *\n+         *\n+         * @param invocation Information on the method call\n+         * @param throwable Tha throwable raised by the method invocation\n+         */\n+        public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n+            this.invocation = invocation;\n+            this.throwable = throwable;\n+        }\n+\n+        public PrintableInvocation getInvocation() {\n+            return invocation;\n+        }\n+\n+        public Object getReturnedValue() {\n+            return returnedValue;\n+        }\n+\n+        public Throwable getThrowable() {\n+            return throwable;\n+        }\n+\n+        public boolean threwException() {\n+            return throwable != null;\n+        }\n+\n+        public String getLocationOfStubbing() {\n+            return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt();\n+        }\n+\n+\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;\n+\n+            if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;\n+            if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)\n+                return false;\n+            if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;\n+\n+            return true;\n+        }\n+\n+        public int hashCode() {\n+            int result = invocation != null ? invocation.hashCode() : 0;\n+            result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);\n+            result = 31 * result + (throwable != null ? throwable.hashCode() : 0);\n+            return result;\n+        }\n+    }\n--- a/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n+++ b/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n     public void log(Object what) {\n-        System.out.print(what.toString());\n+        System.out.print(what);\n     }\n-}\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import static org.mockito.Mockito.RETURNS_DEFAULTS;\n-import static org.mockito.Mockito.withSettings;\n-\n-import org.mockito.cglib.proxy.*;\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.InvocationNotifierHandler;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.creation.MethodInterceptorFilter;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n \n import java.io.Serializable;\n+\n+import static org.mockito.Mockito.RETURNS_DEFAULTS;\n+import static org.mockito.Mockito.withSettings;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n         settings.initiateMockName(classToMock);\n \n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n-        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n+        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(invocationNotifierHandler, settings);\n         Class<?>[] interfaces = settings.getExtraInterfaces();\n \n         Class<?>[] ancillaryTypes;\n     public MockName getMockName(Object mock) {\n         return getMockHandler(mock).getMockSettings().getMockName();\n     }\n-}\n+}\n--- a/src/org/mockito/internal/util/StringJoiner.java\n+++ b/src/org/mockito/internal/util/StringJoiner.java\n \n     public static String join(Object ... linesToBreak) {\n         StringBuilder out = new StringBuilder(\"\\n\");\n+        return join(out, linesToBreak);\n+    }\n+\n+    private static String join(StringBuilder out, Object[] linesToBreak) {\n         for (Object line : linesToBreak) {\n             out.append(line.toString()).append(\"\\n\");\n         }\n         int lastBreak = out.lastIndexOf(\"\\n\");\n         return out.replace(lastBreak, lastBreak+1, \"\").toString();\n     }\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/listeners/InvocationListener.java\n+/*\n+ * Copyright (c) 2011 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.listeners;\n+\n+import org.mockito.MockSettings;\n+\n+/**\n+ * This listener can be notified of method invocations on a mock.\n+ * \n+ * For this to happen, it must be registered using {@link MockSettings#invocationListeners(InvocationListener...)}.\n+ */\n+public interface InvocationListener {\n+\t\n+\t/**\n+\t * Called after the invocation of the listener's mock if it returned normally.\n+\t *\n+     * <p>\n+     * Exceptions caused by this invocationListener will raise a {@link org.mockito.exceptions.base.MockitoException}.\n+     * </p>\n+\t *\n+\t * @param methodInvocationReport Information about the method call that just happened.\n+     *\n+     * @see MethodInvocationReport\n+\t */\n+\tvoid reportInvocation(MethodInvocationReport methodInvocationReport);\n+}\n--- /dev/null\n+++ b/src/org/mockito/listeners/MethodInvocationReport.java\n+package org.mockito.listeners;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+\n+/**\n+ * Represent a method call on a mock.\n+ *\n+ * <p>\n+ *     Contains the information on the mock, the location of the stub\n+ *     the return value if it returned something (maybe null), or an\n+ *     exception if one was thrown when the method was invoked.\n+ * </p>\n+ */\n+public interface MethodInvocationReport {\n+    /**\n+     * @return Information on the method call, never {@code null}\n+     */\n+    PrintableInvocation getInvocation();\n+\n+    /**\n+     * @return The resulting value of the method invocation, may be <code>null</code>\n+     */\n+    Object getReturnedValue();\n+\n+    /**\n+     * @return The throwable raised by the method invocation, maybe <code>null</code>\n+     */\n+    Throwable getThrowable();\n+\n+    /**\n+     * @return <code>true</code> if an exception was raised, <code>false</code> otherwise\n+     */\n+    boolean threwException();\n+\n+    /**\n+     * @return Location of the stub invocation\n+     */\n+    String getLocationOfStubbing();\n+}\n--- a/test/org/mockito/exceptions/ReporterTest.java\n+++ b/test/org/mockito/exceptions/ReporterTest.java\n package org.mockito.exceptions;\n \n import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockitoutil.TestBase;\n     public void shouldLetPassingNullLastActualStackTrace() throws Exception {\n         new Reporter().tooLittleActualInvocations(new Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);\n     }\n-}\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldThrowCorrectExceptionForNullInvocationListener() throws Exception {\n+    \tnew Reporter().invocationListenerDoesNotAcceptNullParameters();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n+package org.mockito.internal;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.BDDMockito.willThrow;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyList;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+\n+@RunWith(MockitoJUnitRunner.class)\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationNotifierHandlerTest {\n+    private static final String SOME_LOCATION = \"some location\";\n+    private static final RuntimeException SOME_EXCEPTION = new RuntimeException();\n+    private static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();\n+    private static final Answer SOME_ANSWER = mock(Answer.class);\n+\n+\n+    @Mock private InvocationListener listener1;\n+    @Mock private InvocationListener listener2;\n+    @Spy private CustomListener customListener;\n+\n+    @Mock private Invocation invocation;\n+    @Mock private MockHandler mockHandler;\n+\n+    private InvocationNotifierHandler notifier;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        notifier = new InvocationNotifierHandler(\n+                mockHandler,\n+                (MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)\n+        );\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_calling_delegate_handler() throws Throwable {\n+        // given\n+        given(mockHandler.handle(invocation)).willReturn(\"returned value\");\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_called_delegate_handler_returns_ex() throws Throwable {\n+        // given\n+        Exception computedException = new Exception(\"computed\");\n+        given(mockHandler.handle(invocation)).willReturn(computedException);\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it() throws Throwable {\n+        // given\n+        ParseException parseException = new ParseException(\"\", 0);\n+        given(mockHandler.handle(invocation)).willThrow(parseException);\n+\n+        // when\n+        try {\n+            notifier.handle(invocation);\n+        } finally {\n+            // then\n+            verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+            verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+        }\n+    }\n+\n+    @Test\n+    public void should_report_listener_exception() throws Throwable {\n+        willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));\n+\n+        try {\n+            notifier.handle(invocation);\n+        } catch (MockitoException me) {\n+            assertThat(me.getMessage())\n+                    .contains(\"invocation listener\")\n+                    .contains(\"CustomListener\")\n+                    .contains(\"threw an exception\")\n+                    .contains(\"NullPointerException\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() throws Exception {\n+        notifier.getInvocationContainer();\n+        notifier.getMockSettings();\n+        notifier.voidMethodStubbable(mock(IMethods.class));\n+        notifier.setAnswersForStubbing(new ArrayList<Answer>());\n+\n+        verify(mockHandler).getInvocationContainer();\n+        verify(mockHandler).getMockSettings();\n+        verify(mockHandler).voidMethodStubbable(any());\n+        verify(mockHandler).setAnswersForStubbing(anyList());\n+    }\n+\n+    private static class CustomListener implements InvocationListener {\n+        public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+            // nop\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n package org.mockito.internal;\n \n import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.internal.invocation.*;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n import org.mockitoutil.TestBase;\n-@SuppressWarnings({\"unchecked\",\"serial\"})\n+\n+import java.util.Arrays;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings({ \"unchecked\", \"serial\" })\n public class MockHandlerTest extends TestBase {\n-    \n-    @Test\n-    public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n-        //given\n-        Invocation invocation = new InvocationBuilder().toInvocation();\n-        MockHandler handler = new MockHandler();\n-        handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n-        handler.matchersBinder = new MatchersBinder() {\n-            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n-                throw new InvalidUseOfMatchersException();\n-            }\n-        };\n-        \n-        try {\n-            //when\n-            handler.handle(invocation);\n-            \n-            //then\n-            fail();\n-        } catch (InvalidUseOfMatchersException e) {}\n-        \n-        assertNull(handler.mockingProgress.pullVerificationMode());\n-    }\n-}\n+\n+\tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n+\tprivate Invocation invocation = mock(Invocation.class);\n+\n+\n+\t@Test\n+\tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+\t\t// given\n+\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tMockHandler<?> handler = new MockHandler();\n+\t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+\t\thandler.matchersBinder = new MatchersBinder() {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\t\tthrow new InvalidUseOfMatchersException();\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\thandler.handle(invocation);\n+\n+\t\t\t// then\n+\t\t\tfail();\n+\t\t} catch (InvalidUseOfMatchersException e) {\n+\t\t}\n+\n+\t\tassertNull(handler.mockingProgress.pullVerificationMode());\n+\t}\n+\n+\n+\n+\n+\t@Test(expected = MockitoException.class)\n+\tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n+\t\t// given\n+\t\tInvocationListener throwingListener = mock(InvocationListener.class);\n+\t\tdoThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));\n+\t\tMockHandler<?> handler = createCorrectlyStubbedHandler(throwingListener);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\t}\n+\n+\n+\n+\tprivate MockHandler<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n+\t\tMockHandler<?> handler = createHandlerWithListeners(throwingListener);\n+\t\tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+\t\treturn handler;\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandler<?> handler) {\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);\n+\t}\n+\n+\n+\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandler<?> handler, StubbedInvocationMatcher value) {\n+\t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(Invocation.class))).willReturn(value);\n+\t}\n+\n+\n+\n+\n+\tprivate MockHandler<?> createHandlerWithListeners(InvocationListener... listener) {\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tMockHandler<?> handler = new MockHandler(mock(MockSettingsImpl.class));\n+\t\thandler.matchersBinder = mock(MatchersBinder.class);\n+\t\tgiven(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));\n+\t\treturn handler;\n+\t}\n+}\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n  */\n package org.mockito.internal.creation;\n \n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n+import org.mockito.listeners.InvocationListener;\n import org.mockitoutil.TestBase;\n \n import java.util.LinkedList;\n public class MockSettingsImplTest extends TestBase {\n \n     private MockSettingsImpl mockSettingsImpl = new MockSettingsImpl();\n+    \n+    @Mock private InvocationListener invocationListener;\n \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullInterface() {\n         //then\n         assertTrue(mockSettingsImpl.isSerializable());\n     }\n-}\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    /////////////////////////////////////////////////////////////////////////\n+    /////////////////////////////////////////////////////////////////////////\n+    // issue 148\n+\n+\n+    @Test\n+    public void shouldAddVerboseLoggingListener() {\n+        //given\n+        assertFalse(mockSettingsImpl.hasInvocationListeners());\n+\n+        //when\n+        mockSettingsImpl.verboseLogging();\n+\n+        //then\n+        assertContainsType(mockSettingsImpl.getInvocationListeners(), VerboseMockInvocationLogger.class);\n+    }\n+\n+    @Test\n+    public void shouldAddVerboseLoggingListenerOnlyOnce() {\n+    \t//given\n+    \tassertFalse(mockSettingsImpl.hasInvocationListeners());\n+    \t\n+    \t//when\n+    \tmockSettingsImpl.verboseLogging().verboseLogging();\n+    \t\n+    \t//then\n+    \tAssertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowNullListener() {\n+    \tmockSettingsImpl.invocationListeners(null);\n+    }\n+\n+    @Test\n+    public void shouldAddInvocationListener() {\n+    \t//given\n+    \tassertFalse(mockSettingsImpl.hasInvocationListeners());\n+    \t\n+    \t//when\n+    \tmockSettingsImpl.invocationListeners(invocationListener);\n+    \t\n+    \t//then\n+        Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);\n+    }\n+    \n+    @Test\n+    public void canAddDuplicateInvocationListeners_ItsNotOurBusinessThere() {\n+    \t//given\n+    \tassertFalse(mockSettingsImpl.hasInvocationListeners());\n+    \t\n+    \t//when\n+    \tmockSettingsImpl.invocationListeners(invocationListener, invocationListener).invocationListeners(invocationListener);\n+    \t\n+    \t//then\n+    \tAssertions.assertThat(mockSettingsImpl.getInvocationListeners()).containsSequence(invocationListener, invocationListener, invocationListener);\n+    }\n+\n+    @Test\n+    public void shouldReportErrorWhenAddingNoInvocationListeners() throws Exception {\n+        try {\n+            mockSettingsImpl.invocationListeners();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"at least one listener\");\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReportErrorWhenAddingANullInvocationListener() throws Exception {\n+        try {\n+            mockSettingsImpl.invocationListeners(invocationListener, null);\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"does not accept null\");\n+        }\n+    }\n+\n+    private InvocationListener getListener(MockSettingsImpl settings) {\n+    \treturn settings.getInvocationListeners().iterator().next();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.debugging;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.StubInfo;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class VerboseMockInvocationLoggerTest {\n+\n+    private VerboseMockInvocationLogger listener;\n+\n+    private ByteArrayOutputStream output;\n+    private Invocation invocation = new InvocationBuilder().toInvocation();\n+    private PrintableInvocation stubbedInvocation = new InvocationBuilder().toInvocation();\n+\n+    @Before\n+    public void init_Listener() throws Exception {\n+        output = new ByteArrayOutputStream();\n+        listener = new VerboseMockInvocationLogger(new PrintStream(output));\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        System.out.println(output);\n+    }\n+\n+    @Test\n+    public void should_print_to_system_out() {\n+        assertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);\n+    }\n+\n+    @Test\n+    public void should_print_invocation_with_return_value() {\n+        // when\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"return value\"));\n+\n+        // then\n+        assertThat(printed())\n+                .contains(invocation.toString())\n+                .contains(invocation.getLocation().toString())\n+                .contains(\"return value\");\n+    }\n+\n+    @Test\n+    public void should_print_invocation_with_exception() {\n+        // when\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+\n+        // then\n+        assertThat(printed())\n+                .contains(invocation.toString())\n+                .contains(invocation.getLocation().toString())\n+                .contains(ThirdPartyException.class.getName());\n+    }\n+\n+    @Test\n+    public void should_print_if_method_has_not_been_stubbed() throws Exception {\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"whatever\"));\n+\n+        assertThat(printed()).doesNotContain(\"stubbed\");\n+    }\n+\n+    @Test\n+    public void should_print_stubbed_info_if_availbable() throws Exception {\n+        invocation.markStubbed(new StubInfo(stubbedInvocation));\n+\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"whatever\"));\n+\n+        assertThat(printed())\n+                .contains(\"stubbed\")\n+                .contains(stubbedInvocation.getLocation().toString());\n+    }\n+\n+    @Test\n+    public void should_log_count_of_interactions() {\n+        // when & then\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+        assertThat(printed()).contains(\"#1\");\n+\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+        assertThat(printed()).contains(\"#2\");\n+\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+        assertThat(printed()).contains(\"#3\");\n+    }\n+\n+    private String printed() {\n+        return output.toString();\n+    }\n+\n+    private static class ThirdPartyException extends Exception {\n+        private static final long serialVersionUID = 3022739107688491354L;\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n  */\n package org.mockito.internal.invocation;\n \n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+\n import java.lang.reflect.Method;\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.Mockito;\n-import org.mockitousage.IMethods;\n-\n+/**\n+ * Build an invocation.\n+ */\n @SuppressWarnings(\"unchecked\")\n public class InvocationBuilder {\n \n     private Method method;\n     private boolean verified;\n \n+    /**\n+     * Build the invocation\n+     *\n+     * If the method was not specified, use IMethods methods.\n+     *\n+     * @return invocation\n+     */\n     public Invocation toInvocation() {\n         if (method == null) {\n             List<Class> argTypes = new LinkedList<Class>();\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n         assertFalse(mockUtil.isMock(\"i mock a mock\"));\n         assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n     }\n-}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.debugging;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.BDDMockito.willReturn;\n+import static org.mockito.Mockito.*;\n+\n+\n+/**\n+ * Ensures that custom listeners can be registered and will be called every time\n+ * a method on a mock is invoked.\n+ */\n+public class InvocationListenerCallbackTest {\n+\n+    // Cannot use a mockito-mock here: during stubbing, the listener1 will be called\n+    // and mockito will confuse the mocks.\n+    private RememberingListener listener1 = new RememberingListener();\n+    private RememberingListener listener2 = new RememberingListener();\n+\n+    @Test\n+    public void should_call_single_listener_when_mock_return_normally() throws Exception {\n+        // given\n+        Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1));\n+        willReturn(\"basil\").given(foo).giveMeSomeString(\"herb\");\n+\n+        // when\n+        foo.giveMeSomeString(\"herb\");\n+\n+        // then\n+        assertThatHasBeenNotified(listener1, \"basil\", getClass().getSimpleName());\n+    }\n+\n+    @Test\n+    public void should_call_all_listener_when_mock_return_normally() throws Exception {\n+        // given\n+        Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n+        given(foo.giveMeSomeString(\"herb\")).willReturn(\"rosemary\");\n+\n+        // when\n+        foo.giveMeSomeString(\"herb\");\n+\n+        // then\n+        assertThatHasBeenNotified(listener1, \"rosemary\", getClass().getSimpleName());\n+        assertThatHasBeenNotified(listener2, \"rosemary\", getClass().getSimpleName());\n+    }\n+\n+\n+    @Test\n+    public void should_call_all_listener_when_mock_throws_exception() throws Exception {\n+        // given\n+        InvocationListener listener1 = mock(InvocationListener.class, \"listener1\");\n+        InvocationListener listener2 = mock(InvocationListener.class, \"listener2\");\n+        Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n+        doThrow(new OvenNotWorking()).when(foo).doSomething(\"cook\");\n+\n+        // when\n+        try {\n+            foo.doSomething(\"cook\");\n+            fail(\"Exception expected.\");\n+        } catch (OvenNotWorking actualException) {\n+            // then\n+            InOrder orderedVerify = inOrder(listener1, listener2);\n+            orderedVerify.verify(listener1).reportInvocation(any(MethodInvocationReport.class));\n+            orderedVerify.verify(listener2).reportInvocation(any(MethodInvocationReport.class));\n+        }\n+    }\n+\n+    static class OvenNotWorking extends RuntimeException { }\n+\n+    private void assertThatHasBeenNotified(RememberingListener listener, Object returned, String location) {\n+        assertThat(listener.returnValue).isEqualTo(returned);\n+        assertThat(listener.invocation).isNotNull();\n+        assertThat(listener.locationOfStubbing).contains(getClass().getSimpleName());\n+    }\n+\n+    private static class RememberingListener implements InvocationListener {\n+        PrintableInvocation invocation;\n+        Object returnValue;\n+        String locationOfStubbing;\n+\n+        public void reportInvocation(MethodInvocationReport mcr) {\n+            this.invocation = mcr.getInvocation();\n+            this.returnValue = mcr.getReturnedValue();\n+            this.locationOfStubbing = mcr.getLocationOfStubbing();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.debugging;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests the verbose logging of invocation on mock methods.\n+ * \n+ * BEWARE: These tests rely on mocking the standard output. While in a\n+ * single-threaded environment the Before/After-contract ensures, that the\n+ * original output stream is restored, there is no guarantee for this\n+ * in the parallel setting.\n+ * Maybe, the test class should be @Ignore'd by default ...\n+ */\n+@RunWith(MockitoJUnitRunner.class)\n+public class VerboseLoggingOfInvocationsOnMockTest {\n+\n+    private ByteArrayOutputStream output;\n+    private PrintStream original;\n+\n+    @Mock UnrelatedClass unrelatedMock;\n+\n+    @Before\n+\tpublic void setUp() {\n+\t\toriginal = System.out;\n+        output = new ByteArrayOutputStream();\n+        System.setOut(new PrintStream(output));\n+\t}\n+\n+\t@After\n+\tpublic void tearDown() {\n+        System.setOut(original);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotPrintInvocationOnMockWithoutSetting() {\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(\"Klipsch\");\n+\t\tunrelatedMock.unrelatedMethod(\"Apple\");\n+\n+\t\t// then\n+        Assertions.assertThat(printed())\n+                .doesNotContain(mockName(unrelatedMock))\n+                .doesNotContain(\"unrelatedMethod\")\n+                .doesNotContain(\"Apple\");\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintUnstubbedInvocationOnMockToStdOut() {\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\n+\t\t// when\n+\t\tfoo.doSomething(\"Klipsch\");\n+\n+\t\t// then\n+        Assertions.assertThat(printed())\n+                .contains(getClass().getName())\n+                .contains(mockName(foo))\n+\t\t\t\t.contains(\"doSomething\")\n+\t\t\t\t.contains(\"Klipsch\");\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintStubbedInvocationOnMockToStdOut() {\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\t\tgiven(foo.giveMeSomeString(\"Klipsch\")).willReturn(\"earbuds\");\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(\"Klipsch\");\n+\n+\t\t// then\n+        Assertions.assertThat(printed())\n+                .contains(getClass().getName())\n+                .contains(mockName(foo))\n+\t\t\t\t.contains(\"giveMeSomeString\")\n+\t\t\t\t.contains(\"Klipsch\")\n+\t\t\t\t.contains(\"earbuds\");\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintThrowingInvocationOnMockToStdOut() {\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(\"Klipsch\");\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\tfoo.doSomething(\"Klipsch\");\n+\t\t\tfail(\"Exception excepted.\");\n+\t\t} catch (ThirdPartyException e) {\n+\t\t\t// then\n+            Assertions.assertThat(printed())\n+                    .contains(getClass().getName())\n+                    .contains(mockName(foo))\n+\t\t\t\t\t.contains(\"doSomething\")\n+\t\t\t\t\t.contains(\"Klipsch\")\n+                    .contains(ThirdPartyException.class.getName());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintRealInvocationOnSpyToStdOut() {\n+\t\t// given\n+\t\tFooImpl fooSpy = mock(FooImpl.class,\n+\t\t\t\twithSettings().spiedInstance(new FooImpl()).verboseLogging());\n+\t\tdoCallRealMethod().when(fooSpy).doSomething(\"Klipsch\");\n+\t\t\n+\t\t// when\n+\t\tfooSpy.doSomething(\"Klipsch\");\n+\t\t\n+\t\t// then\n+        Assertions.assertThat(printed())\n+                .contains(getClass().getName())\n+                .contains(mockName(fooSpy))\n+\t\t\t\t.contains(\"doSomething\")\n+\t\t\t\t.contains(\"Klipsch\");\n+\t}\n+\n+    @Test\n+\tpublic void usage() {\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\t\tgiven(foo.giveMeSomeString(\"Apple\")).willReturn(\n+                \"earbuds\");\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(\"Shure\");\n+\t\tfoo.giveMeSomeString(\"Apple\");\n+\t\tfoo.doSomething(\"Klipsch\");\n+\t}\n+\n+    private String printed() {\n+        return output.toString();\n+    }\n+\n+    private String mockName(Object mock) {\n+        return new MockUtil().getMockName(mock).toString();\n+    }\n+\n+    private static class UnrelatedClass {\n+        void unrelatedMethod(String anotherStringValue) {\n+        }\n+    }\n+\n+    /**\n+\t * An exception that isn't defined by Mockito or the JDK and therefore does\n+\t * not appear in the logging result by chance alone.\n+\t */\n+\tstatic class ThirdPartyException extends RuntimeException {\n+\t\tprivate static final long serialVersionUID = 2160445705646210847L;\n+\t}\n+\n+\tstatic class FooImpl implements Foo {\n+\t\tpublic String giveMeSomeString(String param) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tpublic void doSomething(String param) {\n+\t\t}\n+\t}\n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n package org.mockitoutil;\n \n import junit.framework.Assert;\n+import org.fest.assertions.Assertions;\n+import org.fest.assertions.Condition;\n import org.hamcrest.Matcher;\n import org.hamcrest.SelfDescribing;\n import org.hamcrest.StringDescription;\n import org.mockito.internal.util.MockUtil;\n \n import java.io.*;\n+import java.util.Collection;\n \n import static org.mockito.Mockito.mock;\n \n \n     public static void assertContains(String sub, String string) {\n         assertTrue(\"\\n\" +\n-                \"This substing:[\" +\n+                \"This substring:[\" +\n                 sub +\n                 \"]\\n\" +\n                 \"should be inside of:[\" +\n \n     public static void assertContainsIgnoringCase(String sub, String string) {\n         assertTrue(\"\\n\" +\n-                \"This substing:\" +\n+                \"This substring:\" +\n                 sub +\n                 \"\\n\" +\n                 \"should be inside of:\" +\n \n     public static void assertNotContains(String sub, String string) {\n         assertFalse(\"\\n\" +\n-                \"This substing:\" +\n+                \"This substring:\" +\n                 sub +\n                 \"\\n\" +\n                 \"should NOT be inside of:\" +\n     protected boolean isMock(Object o) {\n         return new MockUtil().isMock(o);\n     }\n-}\n+\n+    protected void assertContainsType(final Collection<?> list, final Class<?> clazz) {\n+        Assertions.assertThat(list).satisfies(new Condition<Collection<?>>() {\n+            @Override\n+            public boolean matches(Collection<?> objects) {\n+                for (Object object : objects) {\n+                    if (clazz.isAssignableFrom(object.getClass())) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+        });\n+    }\n+}", "timestamp": 1305474930, "metainfo": ""}