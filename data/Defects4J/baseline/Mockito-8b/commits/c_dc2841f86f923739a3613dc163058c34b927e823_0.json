{"sha": "dc2841f86f923739a3613dc163058c34b927e823", "log": "working on TODOs after fixing the stack trace filter/remover bug  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40439", "commit": "\n--- a/test/org/mockito/exceptions/base/HasStackTraceStub.java\n+++ b/test/org/mockito/exceptions/base/HasStackTraceStub.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions.base;\n+\n+import java.util.Arrays;\n \n public class HasStackTraceStub implements HasStackTrace {\n     private StackTraceElement[] stackTrace;\n     public void setStackTrace(StackTraceElement[] stackTrace) {\n         this.stackTrace = stackTrace;\n     }\n+    \n+    public String toString() {\n+        return Arrays.toString(stackTrace);\n+    }\n }\n--- a/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n package org.mockito.exceptions.base;\n \n import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n \n+@SuppressWarnings(\"unchecked\")\n public class StackTraceFilterTest extends TestBase {\n     \n     private StackTraceFilter filter;\n     }\n \n     @Test\n-    public void testShouldFilterStackTrace() {\n-        StackTraceElement first = new StackTraceElement(\"MethodInterceptorFilter\", \"intercept\", \"MethodInterceptorFilter.java\", 49);\n-        StackTraceElement second = new StackTraceElement(\"List$$EnhancerByCGLIB$$2c406024\", \"add\", \"<generated>\", 0);\n-        StackTraceElement third = new StackTraceElement(\"MockitoSampleTest\", \"main\", \"MockitoSampleTest.java\", 100);\n-        \n-        HasStackTraceStub trace = new HasStackTraceStub(first, second, third);\n+    public void testShouldFilterOutCglibGarbage() {\n+        HasStackTrace trace = new TraceBuilder().classes(\n+            \"MockitoSampleTest\",\n+            \"List$$EnhancerByCGLIB$$2c406024\", \n+            \"MethodInterceptorFilter\"\n+        ).toTrace();\n         \n         filter.filterStackTrace(trace);\n         \n-        assertEquals(1, trace.getStackTrace().length);\n-        assertEquals(third, trace.getStackTrace()[0]);\n-        //TODO even though this stuff is tested on functional level, I want some more tests here - the unit test should be complete \n+        assertThat(trace, hasOnlyThoseClassesInStackTrace(\"MockitoSampleTest\"));\n+    }\n+    \n+    @Test\n+    public void testShouldFilterOutMockitoPackage() {\n+        HasStackTrace trace = new TraceBuilder().classes(\n+            \"org.test.MockitoSampleTest\",\n+            \"org.test.TestSupport\",\n+            \"org.mockito.Mockito\", \n+            \"org.test.TestSupport\",\n+            \"org.mockito.Mockito\"\n+        ).toTrace();\n+            \n+        filter.filterStackTrace(trace);\n+        \n+        assertThat(trace, hasOnlyThoseClassesInStackTrace(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n     }\n }\n--- a/test/org/mockito/exceptions/base/TraceBuilder.java\n+++ b/test/org/mockito/exceptions/base/TraceBuilder.java\n \n public class TraceBuilder {\n \n-    private String[] methods;\n-\n-    public TraceBuilder methods(String ... methods) {\n-        this.methods = methods;\n-        return this;\n-    }\n+    private String[] methods = {};\n+    private String[] classes = {};\n \n     public HasStackTrace toTrace() {\n         List<StackTraceElement> trace = toTraceList();\n     }\n \n     public List<StackTraceElement> toTraceList() {\n+        assert methods.length == 0 || classes.length == 0;\n+        \n         List<StackTraceElement> trace = new LinkedList<StackTraceElement>();\n         for (String method : methods) {\n             trace.add(new StackTraceElement(\"SomeClass\", method, \"SomeClass.java\", 50));\n         }\n+        for (String clazz : classes) {\n+            trace.add(new StackTraceElement(clazz, \"someMethod\", clazz + \".java\", 50));\n+        }\n+        \n         Collections.reverse(trace);\n         return trace;\n     }\n+\n+    public TraceBuilder classes(String ... classes) {\n+        this.classes = classes;\n+        return this;\n+    }\n+    \n+    public TraceBuilder methods(String ... methods) {\n+        this.methods = methods;\n+        return this;\n+    }\n }\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n     public static <T> Matcher<Throwable> hasFirstMethodInStackTrace(final String method) {\n         return hasMethodInStackTraceAt(0, method);\n     }\n-    \n-//    public static <T> Matcher<HasStackTrace> hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n-//        return new BaseMatcher<List<StackTraceElement>>() {\n-//    }\n     \n     public static <T> Matcher hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n         return new BaseMatcher() {\n             public void describeTo(Description desc) {\n                 desc.appendText(\"has only those methods in stack trace: \");\n                 desc.appendValue(methods);\n+            }\n+        };\n+    }\n+    \n+    public static <T> Matcher<HasStackTrace> hasOnlyThoseClassesInStackTrace(final String ... classes) {\n+        return new BaseMatcher() {\n+            public boolean matches(Object traceElements) {\n+                StackTraceElement[] trace = ((HasStackTrace) traceElements).getStackTrace();\n+                \n+                if (trace.length != classes.length) {\n+                    return false;\n+                }\n+                    \n+                for (int i = 0; i < trace.length; i++) {\n+                    if (!trace[i].getClassName().equals(classes[i])) {\n+                        return false;\n+                    }\n+                }\n+\n+                return true;\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"has only those classes in stack trace: \");\n+                desc.appendValue(classes);\n             }\n         };\n     }", "timestamp": 1204587855, "metainfo": ""}