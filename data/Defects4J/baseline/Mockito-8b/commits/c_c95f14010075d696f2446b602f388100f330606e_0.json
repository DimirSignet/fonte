{"sha": "c95f14010075d696f2446b602f388100f330606e", "log": "removed some TODOs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4085", "commit": "\n--- a/src/org/mockito/internal/ExpectedInvocation.java\n+++ b/src/org/mockito/internal/ExpectedInvocation.java\n     private final List<IArgumentMatcher> matchers;\n \n     public ExpectedInvocation(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        //TODO let's not allow ExpectedInvocation to accept null matchers\n         this.invocation = invocation;\n         this.matchers = matchers;\n     }\n         return true;\n     }\n \n-    //TODO separate unit test?\n     public String toString() {\n         return invocation.toString(matchers);\n     }\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n     public String toString() {\n         List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n         for (Object arg : this.arguments) {\n-            //TODO lil bit hacky way of using Equals matcher\n             matchers.add(new Equals(arg));\n         }\n         return toString(matchers);\n     }\n     \n+    //TODO don't use matchers to do printing args. there should be separate thing to print that stuff\n     public String toString(List<IArgumentMatcher> matchers) {\n-        //TODO separate unit test?\n         StringBuffer result = new StringBuffer();\n         result.append(getMockAndMethodName());\n         result.append(\"(\");\n     }\n     \n     public String toStringWithArgumentTypes() {\n-        //TODO separate unit test?\n         StringBuilder result = new StringBuilder();\n         result.append(getMockAndMethodName());\n         result.append(\"(\");\n--- a/test/org/mockito/InvocationTest.java\n+++ b/test/org/mockito/InvocationTest.java\n \n import static org.junit.Assert.*;\n \n+import java.util.*;\n+\n import org.junit.*;\n import org.mockito.internal.*;\n \n+@SuppressWarnings(\"unchecked\")\n public class InvocationTest {\n \n     private Invocation call;\n \n     @Before\n     public void setup() throws SecurityException, NoSuchMethodException {\n-        call = new InvocationBuilder().args(\"\").seq(1).toInvocation();\n-        equalCall = new InvocationBuilder().args(\"\").seq(2).toInvocation();\n-        nonEqualCall = new InvocationBuilder().args(\"X\").seq(3).toInvocation();\n+        call            = new InvocationBuilder().args(\" \").mock(\"mock\").seq(1).toInvocation();\n+        equalCall       = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        nonEqualCall    = new InvocationBuilder().args(\"X\").mock(\"mock\").seq(3).toInvocation();\n     }\n \n     @Test\n         assertTrue(call.getSequenceNumber() != equalCall.getSequenceNumber());\n         assertTrue(call.equals(equalCall));\n     }\n+    \n+    @Test\n+    public void shouldBeACitizenOfHashes() {\n+        Map map = new HashMap();\n+        map.put(call, \"one\");\n+        map.put(nonEqualCall, \"two\");\n+        \n+        assertEquals(2, map.size());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodName() {\n+        call = new InvocationBuilder().toInvocation();\n+        assertEquals(\"Object.simpleMethod()\", call.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodArgs() {\n+        call = new InvocationBuilder().args(\"foo\").toInvocation();\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\")\", call.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodIntegerArgAndString() {\n+        call = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1)\", call.toString());\n+    }\n }\n--- a/test/org/mockito/internal/ExpectedInvocationTest.java\n+++ b/test/org/mockito/internal/ExpectedInvocationTest.java\n  */\n package org.mockito.internal;\n \n-import static org.hamcrest.CoreMatchers.equalTo;\n import static org.junit.Assert.*;\n \n-import java.lang.reflect.Method;\n+import java.util.*;\n \n import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n \n+@SuppressWarnings(\"unchecked\")\n public class ExpectedInvocationTest {\n \n     @Test\n-    public void shouldImplementHashcodeToBeHashMapsCitizen() throws Exception {\n-        Object[] args = new Object[] { \"\" };\n-        Method m = Object.class.getMethod(\"equals\", new Class[] { Object.class });\n-        Invocation invocation = new Invocation(null, m, args, 0);\n-        assertThat(new ExpectedInvocation(invocation, null).hashCode(), equalTo(1));\n+    public void shouldBeACitizenOfHashes() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n+        \n+        Map map = new HashMap();\n+        map.put(invocation, \"one\");\n+        map.put(invocationTwo, \"two\");\n+        \n+        assertEquals(2, map.size());\n     }\n     \n     @Test\n-    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws SecurityException, NoSuchMethodException {\n-        Object mock = new Object();\n+    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n+        ExpectedInvocation withOneArg = new ExpectedInvocation(new InvocationBuilder().args(\"test\").toInvocation(), null);\n+        ExpectedInvocation withTwoArgs = new ExpectedInvocation(new InvocationBuilder().args(\"test\", 100).toInvocation(), null);\n \n-        Method dummyMethod = Object.class.getMethod(\"equals\",\n-                new Class[] { Object.class });\n+        assertFalse(withOneArg.equals(null));\n+        assertFalse(withOneArg.equals(withTwoArgs));\n+    }\n+    \n+    @Test\n+    public void shouldEqualWhenMatchersEqual() throws Exception {\n+        IArgumentMatcher m = new Equals(1);\n+        IArgumentMatcher mTwo = new Equals(2);\n+        ExpectedInvocation withMatchers = new ExpectedInvocation(new InvocationBuilder().toInvocation(), Arrays.asList(m));\n+        ExpectedInvocation withEqualMatchers = new ExpectedInvocation(new InvocationBuilder().toInvocation(), Arrays.asList(m));\n+        ExpectedInvocation withoutEqualMatchers = new ExpectedInvocation(new InvocationBuilder().toInvocation(), Arrays.asList(mTwo));\n+        \n+        assertTrue(withMatchers.equals(withEqualMatchers));\n+        assertFalse(withMatchers.equals(withoutEqualMatchers));\n+    }\n+    \n+    @Test\n+    public void shouldToStringWithMatchers() throws Exception {\n+        IArgumentMatcher m = NotNull.NOT_NULL;\n+        ExpectedInvocation notNull = new ExpectedInvocation(new InvocationBuilder().toInvocation(), Arrays.asList(m));\n+        IArgumentMatcher mTwo = new Equals('x');\n+        ExpectedInvocation equals = new ExpectedInvocation(new InvocationBuilder().toInvocation(), Arrays.asList(mTwo));\n \n-        ExpectedInvocation invocationWithOneArg = new ExpectedInvocation(\n-                new Invocation(mock, dummyMethod, new Object[] { \"\" }, 0), null);\n-        ExpectedInvocation invocationWithTwoArgs = new ExpectedInvocation(\n-                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }, 0), null);\n-\n-        assertFalse(invocationWithOneArg.equals(null));\n-        assertFalse(invocationWithOneArg.equals(invocationWithTwoArgs));\n+        assertEquals(\"Object.simpleMethod(notNull())\", notNull.toString());\n+        assertEquals(\"Object.simpleMethod('x')\", equals.toString());\n     }\n }\n--- a/test/org/mockito/internal/InvocationBuilder.java\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.usage.IMethods;\n+import org.mockito.usage.*;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationBuilder {\n     private String methodName = \"simpleMethod\";\n     private int sequenceNumber = 0;\n     private Object[] args = new Object[] {};\n+    private Object mock = \"mock\";\n \n+    //TODO replace occurences of raw creation with builder\n     public Invocation toInvocation() {\n         Method method;\n         List<Class> argTypes = new LinkedList<Class>();\n         try {\n             method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n         } catch (Exception e) {\n-            throw new RuntimeException(e);\n+            throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\n         }\n-        Invocation i = new Invocation(\"mock\", method, args, sequenceNumber);\n+        Invocation i = new Invocation(mock, method, args, sequenceNumber);\n         return i;\n     }\n \n         this.args = args;\n         return this;\n     }\n+\n+    public InvocationBuilder mock(Object mock) {\n+        this.mock = mock;\n+        return this;\n+    }\n }\n--- a/test/org/mockito/usage/IMethods.java\n+++ b/test/org/mockito/usage/IMethods.java\n     void simpleMethod(String argument);\n     \n     void simpleMethod(int argument);\n+    \n+    void simpleMethod(String argOne, Integer argTwo);\n \n     Object threeArgumentMethod(int valueOne, Object valueTwo, String valueThree);\n \n--- a/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n     }\n \n     @Test\n-    public void overriddenInterfaceMethodNotWorking() throws Exception {\n+    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected() throws Exception {\n         DerivedInterface derivedMock = Mockito.mock(DerivedInterface.class);\n         setMock(derivedMock);\n         Message message = new Message();", "timestamp": 1196271896, "metainfo": ""}