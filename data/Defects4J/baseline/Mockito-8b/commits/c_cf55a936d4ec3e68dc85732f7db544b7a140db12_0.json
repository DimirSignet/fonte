{"sha": "cf55a936d4ec3e68dc85732f7db544b7a140db12", "log": "Added better error reporting when arguments don't match. Try it out!  Loads of TODOs are left  --HG-- rename : src/org/mockito/exceptions/verification/InvocationDiffersFromActual.java => src/org/mockito/exceptions/verification/ArgumentsAreDifferentException.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40417", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n         ));\n     }    \n \n-    public void wantedDiffersFromActual(Printable wanted, Printable actual, HasStackTrace actualInvocationStackTrace) {\n-        WantedDiffersFromActual cause1 = new WantedDiffersFromActual(join(\n-                \"Actual invocation:\",\n-                actual.toString()\n+    public void argumentsAreDifferent(Printable wanted, Printable wantedArgs, Printable actualArgs, HasStackTrace actualInvocationStackTrace) {\n+        WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n+                \"All actual arguments:\",\n+                actualArgs.toString()\n             ));\n         \n-        cause1.setStackTrace(actualInvocationStackTrace.getStackTrace());\n-        WantedDiffersFromActual cause = cause1;\n-\n-        throw new InvocationDiffersFromActual(join(\n-                \"Invocation differs from actual\",\n-                \"Wanted invocation:\",\n-                wanted.toString()\n+        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+        \n+        throw new ArgumentsAreDifferentException(join(\n+                \"Argument(s) are different!\",\n+                \"Method: \" + wanted.toString(),\n+                \"All wanted arguments:\",\n+                wantedArgs.toString()\n             ), cause);\n     }\n     \n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/ArgumentsAreDifferentException.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class ArgumentsAreDifferentException extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public ArgumentsAreDifferentException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n package org.mockito.internal.invocation;\n \n import java.lang.reflect.Method;\n+import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.LinkedList;\n import java.util.List;\n \n import org.hamcrest.Description;\n @SuppressWarnings(\"unchecked\")\n public class Invocation implements Printable {\n \n+    private static final String TAB = \"    \";\n     private final int sequenceNumber;\n     private final Object mock;\n     private final Method method;\n     }\n     \n     private List<Matcher> argumentsToMatchers() {\n-        List<Matcher> matchers = new LinkedList<Matcher>();\n-        for (Object arg : this.arguments) {\n+        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n+        for (Object arg : arguments) {\n             if (arg != null && arg.getClass().isArray()) {\n                 matchers.add(new ArrayEquals(arg));\n             } else {\n         }\n         return matchers;\n     }\n+\n+    public String getMethodName() {\n+        //TODO duplicated, unordered\n+        return MockNamer.nameForMock(mock) + \".\" + method.getName() + \"(...)\";\n+    }\n+\n+    public String getTypedArgs() {\n+        StringBuilder result = new StringBuilder();\n+        Class<?>[] types = getMethod().getParameterTypes();\n+        for (int i = 0; i < types.length; i++) {\n+            Class<?> paramType = types[i];\n+            result.append(TAB).append(i+1).append(\": \").append(paramType);\n+            if (i != types.length-1) {\n+                result.append(\"\\n\");\n+            }\n+        } \n+        return result.toString();\n+    }\n+    \n+    public String getArgs() {\n+        return getArgs(argumentsToMatchers());\n+    }\n+\n+    public String getArgs(List<Matcher> matchers) {\n+        //TODO some unit testing please\n+        if (matchers.isEmpty()) {\n+            return TAB + \"<no arguments>\"; \n+        }\n+        \n+        Description d = new StringDescription();\n+        \n+        for(int i = 0; i<matchers.size(); i++) {\n+            d.appendText(TAB);\n+            d.appendText(String.valueOf(i+1));\n+            d.appendText(\": \");\n+            d.appendDescriptionOf(matchers.get(i));\n+            if (i != matchers.size()-1) {\n+                d.appendText(\"\\n\");\n+            }\n+        }\n+\n+        return d.toString();\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n package org.mockito.internal.invocation;\n \n import java.lang.reflect.Method;\n-import java.util.Collections;\n+import java.util.ArrayList;\n import java.util.List;\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.Printable;\n+import org.mockito.internal.matchers.Equals;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcher implements Printable {\n     private final List<Matcher> matchers;\n \n     public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n+        this.invocation = invocation;\n         if (matchers == null) {\n-            throw new IllegalArgumentException(\"matchers cannot be null\");\n+            this.matchers = buildMatchers(invocation);\n+        } else {\n+            this.matchers = matchers;\n         }\n-        this.invocation = invocation;\n-        this.matchers = matchers;\n     }\n     \n     public InvocationMatcher(Invocation invocation) {\n-        this(invocation, Collections.<Matcher>emptyList());\n+        this(invocation, null);\n+    }\n+\n+    private List<Matcher> buildMatchers(Invocation invocation) {\n+        List<Matcher> result = new ArrayList<Matcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n     }\n     \n     public Method getMethod() {\n     public String toStringWithArgumentTypes() {\n         return invocation.toStringWithArgumentTypes();\n     }\n+\n+    public String getMethodName() {\n+        return invocation.getMethodName();\n+    }\n+\n+    public String getTypedArgs() {\n+        return invocation.getTypedArgs();\n+    }\n+    \n+    public String getArgs() {\n+        return invocation.getArgs(matchers);\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsPrinter.java\n+++ b/src/org/mockito/internal/invocation/InvocationsPrinter.java\n public class InvocationsPrinter {\n \n     private final String wanted;\n-    private final String actual;\n+    private final String wantedArgs;\n+    private final String actualArgs;\n \n     public InvocationsPrinter(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        wanted = wantedInvocation.getMethodName();\n         if (wantedInvocation.differsWithArgumentTypes(actualInvocation)) {\n-            wanted = wantedInvocation.toStringWithArgumentTypes();\n-            actual = actualInvocation.toStringWithArgumentTypes();\n+            wantedArgs = wantedInvocation.getTypedArgs();\n+            actualArgs = actualInvocation.getTypedArgs();\n         } else {\n-            wanted = wantedInvocation.toString();\n-            actual = actualInvocation.toString();\n+            wantedArgs = wantedInvocation.getArgs();\n+            actualArgs = actualInvocation.getArgs();\n         }\n     }\n \n     public Printable getWanted() {\n-        return new Printable() {\n-            public String toString() {\n-                return wanted;\n-        }};\n+        return new PrintableString(wanted);\n     }\n \n-    public Printable getActual() {\n-        return new Printable() {\n-            public String toString() {\n-                return actual;\n-        }};\n+    public Printable getWantedArgs() {\n+        return new PrintableString(wantedArgs);\n+    }\n+\n+    public Printable getActualArgs() {\n+        return new PrintableString(actualArgs);\n+    }\n+    \n+    private final class PrintableString implements Printable {\n+        private final String printable;\n+        public PrintableString(String printable) {\n+            this.printable = printable;\n+        }\n+        public String toString() {\n+            return printable;\n+        }\n     }\n }\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n  */\n package org.mockito.internal.invocation;\n \n-import java.util.ArrayList;\n import java.util.List;\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.progress.LastArguments;\n \n @SuppressWarnings(\"unchecked\")\n         List<Matcher> lastMatchers = LastArguments.instance().pullMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n-        List<Matcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n-        \n-        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, processedMatchers);\n+        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);\n         return invocationWithMatchers;\n     }\n \n             }\n         }\n     }\n-    \n-    /**\n-     * if user passed bare arguments then create EqualsMatcher for every argument.\n-     */\n-    private List<Matcher> createEqualsMatchers(Invocation invocation,\n-            List<Matcher> matchers) {\n-        if (matchers != null) {\n-            return matchers;\n-        }\n-        List<Matcher> result = new ArrayList<Matcher>();\n-        for (Object argument : invocation.getArguments()) {\n-            result.add(new Equals(argument));\n-        }\n-        return result;\n-    }\n-}\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n     private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n         if (similar != null) {\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, similar);\n-            reporter.wantedDiffersFromActual(printer.getWanted(), printer.getActual(), similar.getStackTrace());\n+            //TODO smelly\n+            reporter.argumentsAreDifferent(printer.getWanted(), printer.getWantedArgs(), printer.getActualArgs(), similar.getStackTrace());\n         } else {\n             reporter.wantedButNotInvoked(wanted);\n         }\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n \n import static java.util.Arrays.*;\n import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import java.util.HashMap;\n import java.util.Map;\n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcherTest extends TestBase {\n \n-    @Test(expected=IllegalArgumentException.class)\n-    public void shouldScreamWhenMatchersNull() throws Exception {\n-        new InvocationMatcher(new InvocationBuilder().toInvocation(), null);\n+    public void shouldBuildEqualsMatchersWhenNullPassed() throws Exception {\n+        InvocationMatcher m = new InvocationMatcher(new InvocationBuilder().args(\"foo\").toInvocation(), null);\n+        assertThat(m.getMatchers(), collectionHasExactlyInOrder(new Equals(\"foo\")));\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n \n     @Test\n     public void shouldPrintWantedAndActualInvocation() throws Exception {\n-        InvocationMatcher simpleMethod = new InvocationBuilder().simpleMethod().toInvocationMatcher();\n-        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        InvocationMatcher simpleMethod = new InvocationBuilder().simpleMethod().arg(\"test\").toInvocationMatcher();\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().arg(\"foo\").toInvocation();\n+        \n         InvocationsPrinter printer = new InvocationsPrinter(simpleMethod, differentMethod);\n         \n-        assertEquals(\"Object.simpleMethod()\", printer.getWanted().toString());\n-        assertEquals(\"Object.differentMethod()\", printer.getActual().toString());\n+        assertEquals(\"Object.simpleMethod(...)\", printer.getWanted().toString());\n+        assertEquals(\"    1: \\\"test\\\"\", printer.getWantedArgs().toString());\n+        assertEquals(\"    1: \\\"foo\\\"\", printer.getActualArgs().toString());\n     }\n     \n     class Super {\n     }\n \n     @Test\n-    public void shouldPrintSequenceNumbersWhenMatchesButMocksDifferent() throws Exception {\n+    public void shouldPrintTypesWhenOnlyTypesDiffer() throws Exception {\n         Method methodOne = Super.class.getDeclaredMethod(\"test\", Object.class);\n         Method methodTwo = Sub.class.getDeclaredMethod(\"test\", String.class);\n         \n         \n         assertEquals(invocationOne.toString(), invocationTwo.toString());\n         \n-        assertEquals(\"Object.test(class java.lang.Object)\", printer.getWanted().toString());\n-        assertEquals(\"Object.test(class java.lang.String)\", printer.getActual().toString());\n+        assertEquals(\"Object.test(...)\", printer.getWanted().toString());\n+        assertEquals(\"    1: class java.lang.Object\", printer.getWantedArgs().toString());\n+        assertEquals(\"    1: class java.lang.String\", printer.getActualArgs().toString());\n     }\n     \n     class Dummy {\n     }\n     \n     @Test\n-    public void shouldPrintTypesWhenMockArgsAndMethodNameMatchButMethodNotEqual() throws Exception {\n+    public void shouldPrintVarargTypesWhenOnlyTypesDiffer() throws Exception {\n         Method methodOne = Dummy.class.getDeclaredMethod(\"test\", new Object[]{}.getClass());\n         Method methodTwo = Dummy.class.getDeclaredMethod(\"test\", new String[]{}.getClass());\n         \n         \n         assertEquals(invocationOne.toString(), invocationTwo.toString());\n         \n-        assertEquals(\"Object.test(class [Ljava.lang.Object;)\", printer.getWanted().toString());\n-        assertEquals(\"Object.test(class [Ljava.lang.String;)\", printer.getActual().toString());\n+        assertEquals(\"Object.test(...)\", printer.getWanted().toString());\n+        assertEquals(\"    1: class [Ljava.lang.Object;\", printer.getWantedArgs().toString());\n+        assertEquals(\"    1: class [Ljava.lang.String;\", printer.getActualArgs().toString());\n     }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertEquals(wanted, reporterStub.wanted);\n+        assertNull(reporterStub.actualInvocationStackTrace);\n     }\n     \n     @Test\n         \n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n-        assertEquals(wanted.toString(), reporterStub.wanted.toString());\n-        assertEquals(actualInvocation.toString(), reporterStub.actual.toString());\n+        assertNotNull(reporterStub.wanted);\n+        assertNotNull(reporterStub.actualArgs);\n+        assertNotNull(reporterStub.wantedArgs);\n+        \n         assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n     }\n     \n     class ReporterStub extends Reporter {\n         private Object wanted;\n-        private Object actual;\n         private HasStackTrace actualInvocationStackTrace;\n+        private Printable wantedArgs;\n+        private Printable actualArgs;\n         @Override public void wantedButNotInvoked(Printable wanted) {\n             this.wanted = wanted;\n         }\n-        @Override public void wantedDiffersFromActual(Printable wanted, Printable actual, HasStackTrace actualInvocationStackTrace) {\n+        \n+        @Override public void argumentsAreDifferent(Printable wanted, Printable wantedArgs, Printable actualArgs,\n+                HasStackTrace actualInvocationStackTrace) {\n                     this.wanted = wanted;\n-                    this.actual = actual;\n+                    this.wantedArgs = wantedArgs;\n+                    this.actualArgs = actualArgs;\n                     this.actualInvocationStackTrace = actualInvocationStackTrace;\n         }\n     }\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n         };\n     }\n     \n+    //TODO can't you use matchers from hamcrest?\n     public static <T> Matcher<Collection> collectionHas(final T ... elements) {\n         return new BaseMatcher<Collection>() {\n \n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     \n     String differentMethod();\n     \n+    String differentMethod(String argument);\n+    \n     String otherMethod();\n \n     String simpleMethod(String argument);\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n \n         try {\n             verify(mock).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (ArgumentsAreDifferentException e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n         }\n     }\n         try {\n             verify(mock, atLeastOnce()).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (ArgumentsAreDifferentException e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n         }\n     }   \n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n \n         try {\n             verify(mock).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (ArgumentsAreDifferentException e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n         }\n     }\n         try {\n             verify(mock, atLeastOnce()).simpleMethod(999);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (ArgumentsAreDifferentException e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n         }\n     }   \n--- a/test/org/mockitousage/ReflectionMatchersTest.java\n+++ b/test/org/mockitousage/ReflectionMatchersTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n \n @SuppressWarnings(\"all\")\n public class ReflectionMatchersTest extends TestBase {\n         verify(mock).run(refEq(wanted));\n     }\n     \n-    @Test(expected=InvocationDiffersFromActual.class)\n+    @Test(expected=ArgumentsAreDifferentException.class)\n     public void shouldNotMatchWhenFieldValuesDiffer() throws Exception {\n         Child wanted = new Child(1, \"foo\", 2, \"bar XXX\");\n         verify(mock).run(refEq(wanted));\n     }\n     \n-    @Test(expected=InvocationDiffersFromActual.class)\n+    @Test(expected=ArgumentsAreDifferentException.class)\n     public void shouldNotMatchAgain() throws Exception {\n         Child wanted = new Child(1, \"foo\", 999, \"bar\");\n         verify(mock).run(refEq(wanted));\n     }\n     \n-    @Test(expected=InvocationDiffersFromActual.class)\n+    @Test(expected=ArgumentsAreDifferentException.class)\n     public void shouldNotMatchYetAgain() throws Exception {\n         Child wanted = new Child(1, \"XXXXX\", 2, \"bar\");\n         verify(mock).run(refEq(wanted));\n     }\n     \n-    @Test(expected=InvocationDiffersFromActual.class)\n+    @Test(expected=ArgumentsAreDifferentException.class)\n     public void shouldNotMatch() throws Exception {\n         Child wanted = new Child(234234, \"foo\", 2, \"bar\");\n         verify(mock).run(refEq(wanted));\n--- a/test/org/mockitousage/StackTrackeChangingTest.java\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n \n public class StackTrackeChangingTest extends TestBase {\n     \n         try {\n             verifySimpleMethodOnAMock();\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (ArgumentsAreDifferentException e) {\n             assertThat(e, hasMethodInStackTraceAt(0, \"verifySimpleMethodOnAMock\"));\n             assertThat(e, hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n             assertThat(e.getCause(), hasMethodInStackTraceAt(0, \"simpleMethodOnAMock\"));\n--- a/test/org/mockitousage/UsingVarargsTest.java\n+++ b/test/org/mockitousage/UsingVarargsTest.java\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n \n public class UsingVarargsTest extends TestBase {\n \n         try {\n             verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n     }\n \n     @Test\n         try {\n             verify(mock).withBooleanVarargs(3, true, true, true, true);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n     }\n }\n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n import org.mockitousage.IMethods;\n \n         try {\n             verify(sub).say(\"Hello\");\n             fail();\n-        } catch (InvocationDiffersFromActual error) {\n+        } catch (ArgumentsAreDifferentException error) {\n+            //TODO this is no longer valid, because method is different not the args \n             String expected =\n                 \"\\n\" +\n-                \"Invocation differs from actual\" +\n-                \"\\n\" +\n-                \"Wanted invocation:\" +\n+                \"Argument(s) are different!\" +\n                 \"\\n\" +\n-                \"Sub.say(class java.lang.String)\";\n+                \"Method: Sub.say(...)\" +\n+                \"\\n\" +\n+                \"All wanted arguments:\" +\n+                \"\\n\" +\n+                \"    1: class java.lang.String\";\n \n             assertEquals(expected, error.getMessage());\n \n             String expectedCause =\n                 \"\\n\" +\n-                \"Actual invocation:\" +\n+                \"All actual arguments:\" +\n                 \"\\n\" +\n-                \"Sub.say(class java.lang.Object)\";\n+                \"    1: class java.lang.Object\";\n             assertEquals(expectedCause, error.getCause().getMessage());\n         }\n     }\n         try {\n             verify(sub).say(contains(\"world\"));\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n-            assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"1: class java.lang.String\"));\n+            assertThat(e, causeMessageContains(\"1: class java.lang.Object\"));\n         }\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/AssertingMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+import org.mockitousage.IMethods;\n+\n+@Ignore(\"that's just prototyping\")\n+public class AssertingMatchersTest extends TestBase {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    class Article {\n+        \n+        private int pageNumber;\n+        private String headline;\n+        \n+        public Article(int pageNumber, String headline) {\n+            super();\n+            this.pageNumber = pageNumber;\n+            this.headline = headline;\n+        }\n+\n+        public int getPageNumber() {\n+            return pageNumber;\n+        }\n+\n+        public String getHeadline() {\n+            return headline;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldUseCustomCharMatcher1() {\n+        mock.simpleMethod(new Article(12, \"Fabulous article\"));\n+        \n+        Article articleOnPage12 = argThat(new ArgumentMatcher<Article>() {\n+            public boolean matches(Object argument) {\n+                Article o = (Article) argument;\n+                assertEquals(12, o.getPageNumber());\n+                return true;\n+            }} );\n+        \n+        verify(mock).simpleMethod(articleOnPage12);\n+        \n+        //Assertors?\n+        \n+//        verify(mock).simpleMethod(argThat(new ArgumentAssertor<Article>() {\n+//            public void assertArgument(Object argument) {\n+//                Article o = (Article) argument;\n+//                assertEquals(\"two\", o.getHeadline());\n+//            }} ));\n+    }\n+}\n--- a/test/org/mockitousage/matchers/CustomMatchersTest.java\n+++ b/test/org/mockitousage/matchers/CustomMatchersTest.java\n import static org.junit.Assert.*;\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n+import org.hamcrest.Description;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.ArgumentMatcher;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockitousage.IMethods;\n \n public class CustomMatchersTest extends TestBase {\n     }\n     \n     @Test\n-    public void shouldUseCustomCharMatcher1() {\n-        mock.simpleMethod(new Article(12, \"Fabulous article\"));\n-        \n-        Article articleOnPage12 = argThat(new ArgumentMatcher<Article>() {\n-            public boolean matches(Object argument) {\n-                Article o = (Article) argument;\n-                assertEquals(12, o.getPageNumber());\n-                return true;\n-            }} );\n-        \n-        verify(mock).simpleMethod(articleOnPage12);\n-        \n-        //Assertors?\n-        \n-//        verify(mock).simpleMethod(argThat(new ArgumentAssertor<Article>() {\n-//            public void assertArgument(Object argument) {\n-//                Article o = (Article) argument;\n-//                assertEquals(\"two\", o.getHeadline());\n-//            }} ));\n-    }\n-    \n-    @Test\n     public void shouldUseCustomPrimitiveNumberMatchers() {\n         stub(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).toReturn(\"byte\");\n         stub(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).toReturn(\"short\");\n         assertEquals(\"foo\", mock.oneArg(\"foo\"));\n         assertEquals(null, mock.oneArg(\"bar\"));\n     }\n+    \n+    @Test\n+    public void shouldCustomMatcherPrintDecentMessage() {\n+        mock.simpleMethod(\"foo\");\n+\n+        try {\n+            verify(mock).simpleMethod(containsTest());\n+            fail();\n+        } catch (ArgumentsAreDifferentException e) {\n+//            e.printStackTrace();\n+            assertThat(e, messageContains(\"1: String that contains 'xxx'\"));\n+            assertThat(e, causeMessageContains(\"1: \\\"foo\\\"\"));\n+        }\n+    }\n+\n+    private String containsTest() {\n+        return argThat(new IsStringThatContainsXxx());\n+    }\n+    \n+    private final class IsStringThatContainsXxx extends ArgumentMatcher<String> {\n+        public boolean matches(Object argument) {\n+            String arg = (String) argument;\n+            return arg.contains(\"xxx\");\n+        }\n+\n+        @Override\n+        public void describeTo(Description description) {\n+            description.appendText(\"String that contains 'xxx'\");\n+        }\n+    }\n }\n--- a/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n+++ b/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n import org.junit.Test;\n import org.mockito.TestBase;\n import org.mockito.MockitoAnnotations.Mock;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n         }\n \n         public void describeTo(Description d) {\n-            d.appendText(\"<contains 'X'>\");\n+            d.appendText(\"contains 'X'\");\n         }\n     }\n \n         try {\n             verify(mock).simpleMethod(argThat(new ContainsX()));\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.simpleMethod(<contains 'X'>)\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"contains 'X'\"));\n         }\n     }\n }\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockitousage.IMethods;\n \n         try {\n             verify(mock).simpleMethod(\"one\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n         \n         try {\n             verify(mock).simpleMethod(\"two\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n         \n         try {\n             verifyNoMoreInteractions(mock);\n--- a/test/org/mockitousage/verification/BasicVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n import org.mockito.TestBase;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n @SuppressWarnings(\"unchecked\")\n         try {\n             verify(mock).add(\"bar\");\n             fail();\n-        } catch (InvocationDiffersFromActual expected) {}\n+        } catch (ArgumentsAreDifferentException expected) {}\n     }\n \n     @Test\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n         try {\n             verify(mock).twoArgumentMethod(1, 1000);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n+        } catch (ArgumentsAreDifferentException e) {\n             String expected =\n                     \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Wanted invocation:\" +\n-                    \"\\n\" +\n-                    \"IMethods.twoArgumentMethod(1, 1000)\";\n+                    \"Argument(s) are different!\" +\n+                    \"\\n\" +\n+                    \"Method: IMethods.twoArgumentMethod(...)\" +\n+                    \"\\n\" +\n+                    \"All wanted arguments:\" +\n+                    \"\\n\" +\n+                    \"    1: 1\" +\n+                    \"\\n\" +\n+                    \"    2: 1000\";\n \n             assertEquals(expected, e.getMessage());\n \n \n             String expectedCause =\n                     \"\\n\" +\n-                    \"Actual invocation:\" +\n-                    \"\\n\" +\n-                    \"IMethods.twoArgumentMethod(1, 2)\";\n+                    \"All actual arguments:\" +\n+                    \"\\n\" +\n+                    \"    1: 1\" +\n+                    \"\\n\" +\n+                    \"    2: 2\";\n \n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.simpleMethod(\\\"test\\\")\"));\n-            assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"    1: \\\"test\\\"\"));\n+            assertThat(e, causeMessageContains(\"    <no arguments>\"));\n         }\n     }\n \n         try {\n             verify(mock).twoArgumentMethod(3, 1000);\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.twoArgumentMethod(3, 1000)\"));\n-            assertThat(e, causeMessageContains(\"IMethods.twoArgumentMethod(3, 3)\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"1: 3\"));\n+            assertThat(e, messageContains(\"2: 1000\"));\n+            assertThat(e, causeMessageContains(\"1: 3\"));\n+            assertThat(e, causeMessageContains(\"2: 3\"));\n         }\n     }\n \n         try {\n             verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.oneArray([false, false, false])\"));\n-            assertThat(e, causeMessageContains(\"IMethods.oneArray([true, false, false])\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"1: [false, false, false]\"));\n+            assertThat(e, causeMessageContains(\"1: [true, false, false]\"));\n         }\n     }\n \n         try {\n             verify(mock).varargsString(10, \"two\", \"one\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.varargsString(10, \\\"two\\\", \\\"one\\\")\"));\n-            assertThat(e, causeMessageContains(\"IMethods.varargsString(10, \\\"one\\\", \\\"two\\\")\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"1: 10\"));\n+            assertThat(e, messageContains(\"2: \\\"two\\\"\"));\n+            assertThat(e, messageContains(\"3: \\\"one\\\"\"));\n+            \n+            assertThat(e, causeMessageContains(\"1: 10\"));\n+            assertThat(e, causeMessageContains(\"2: \\\"one\\\"\"));\n+            assertThat(e, causeMessageContains(\"3: \\\"two\\\"\"));\n         }\n     }\n \n         mock.simpleMethod(\"foo\");\n \n         try {\n-            verify(mock).simpleMethod(matches(\"burrito\"));\n-            fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.simpleMethod(matches(\\\"burrito\\\"))\"));\n-            assertThat(e, causeMessageContains(\"IMethods.simpleMethod(\\\"foo\\\")\"));\n+            verify(mock).simpleMethod(matches(\"burrito from Exmouth\"));\n+            fail();\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"1: matches(\\\"burrito from Exmouth\\\")\"));\n+            assertThat(e, causeMessageContains(\"1: \\\"foo\\\"\"));\n         }\n     }\n \n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n-        } catch (InvocationDiffersFromActual e) {\n-            assertThat(e, causeMessageContains(\"simpleMethod(null, null)\"));\n+        } catch (ArgumentsAreDifferentException e) {\n+            assertThat(e, causeMessageContains(\"1: null\"));\n+            assertThat(e, causeMessageContains(\"2: null\"));\n         }\n     }\n \n         try {\n             verify(mock).varargs((String[]) new String[] {});\n             fail();\n-        } catch(InvocationDiffersFromActual e) {\n-            assertThat(e, messageContains(\"IMethods.varargs(class [Ljava.lang.String;)\"));\n-            assertThat(e, causeMessageContains(\"IMethods.varargs(class [Ljava.lang.Object;)\"));\n+        } catch(ArgumentsAreDifferentException e) {\n+            assertThat(e, messageContains(\"1: class [Ljava.lang.String;\"));\n+            assertThat(e, causeMessageContains(\"1: class [Ljava.lang.Object;\"));\n         }\n     }\n     \n--- a/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n-import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n \n         mock.threeArgumentMethod(8, new Object(), \"01234\");\n         \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"no match\");\n \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (InvocationDiffersFromActual e) {}\n+        } catch (ArgumentsAreDifferentException e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"123\");\n         ", "timestamp": 1204395345, "metainfo": ""}