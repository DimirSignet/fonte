{"sha": "33923e4e83bedc9c21c07b0cccc422aae68269a5", "log": "Mean check-in (forgive me, the God of CI) Changed a bit stack trace filtering code. The problem with current stack trace filter was that it was not good for some edge cases with spies. Sometimes spy throws exception from real implementation. The idea is to make this exception looking like normal one - without mockito internals on the stack trace. Hence big refactoring and new classes & tests.  --HG-- rename : src/org/mockito/exceptions/base/ConditionalStackTraceFilter.java => src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java rename : src/org/mockito/exceptions/base/StackTraceFilter.java => src/org/mockito/internal/exceptions/base/StackTraceFilter.java rename : test/org/mockito/exceptions/base/ConditionalStackTraceFilterTest.java => test/org/mockito/internal/exceptions/base/ConditionalStackTraceFilterTest.java rename : test/org/mockito/exceptions/base/StackTraceFilterTest.java => test/org/mockito/internal/exceptions/base/StackTraceFilterTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401458", "commit": "\n--- a/src/org/mockito/exceptions/base/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/base/MockitoAssertionError.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions.base;\n+\n+import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n \n \n--- a/src/org/mockito/exceptions/base/MockitoException.java\n+++ b/src/org/mockito/exceptions/base/MockitoException.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions.base;\n+\n+import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n \n public class MockitoException extends RuntimeException {\n--- a/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n \n import junit.framework.ComparisonFailure;\n \n-import org.mockito.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n \n public class ArgumentsAreDifferent extends ComparisonFailure {\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n \n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.exceptions.base.ConditionalStackTraceFilter;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.stubbing.MockitoStubber;\n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         if (mockitoStubber.hasAnswersForStubbing()) {\n             //stubbing voids with stubVoid() or doAnswer() style\n-            Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), methodProxy);\n+            Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n             mockitoStubber.setMethodForStubbing(invocationMatcher);\n             return null;\n         }\n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n \n-        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), methodProxy);\n+        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n         \n         mockingProgress.validateState();\n             mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n             return stubbedAnswer.answer(invocation);\n         } else {\n-            Object ret = null;\n-            try {\n-                ret = mockSettings.getDefaultAnswer().answer(invocation);\n-            } catch (Throwable t) {\n-                //TODO: this needs to be a different filter. \n-//                new ConditionalStackTraceFilter().filter(t);\n-                //The one detects first stack trace element that is mockito internal\n-                //detects last stack trace element that is mockito internal\n-                //removes both of them and all inside\n-                \n-                throw t;\n-            }\n+            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+            \n             //redo setting invocation for potential stubbing in case of partial mocks / spies.\n             //Without it, the real method inside 'when' might have delegated \n             //to other self method and overwrite the intended stubbed method with a different one.\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.exceptions.base.StackTraceFilter;\n \n public class Location  {\n \n     public Location() {\n         StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n         StackTraceFilter filter = new StackTraceFilter();\n-        this.firstTraceElement = filter.filter(stackTrace)[0];\n+        this.firstTraceElement = filter.filter(stackTrace, 1)[0];\n     }\n \n     @Override\n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.exceptions.base;\n+\n+import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.internal.configuration.GlobalConfiguration;\n+\n+public class ConditionalStackTraceFilter {\n+    \n+    private IMockitoConfiguration config = new GlobalConfiguration();\n+    private StackTraceFilter filter = new StackTraceFilter();\n+    \n+    public void filter(Throwable throwable) {\n+        if (!config.cleansStackTrace()) {\n+            return;\n+        }\n+        StackTraceElement[] filtered = filter.filter(throwable.getStackTrace(), 0);\n+        throwable.setStackTrace(filtered);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/base/StackTraceFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.exceptions.base;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class StackTraceFilter {\n+    \n+    public boolean isBad(StackTraceElement e) {\n+        boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n+        boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n+        boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n+        boolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\n+        return (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n+    }\n+\n+    /**\n+     * Example how the filter works (+/- means good/bad):\n+     * [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+]\n+     * Basically removes all bad from the middle. If any good are in the middle of bad those are also removed. \n+     */\n+    public StackTraceElement[] filter(StackTraceElement[] target, int startWith) {\n+        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n+        \n+        int lastBad = -1;\n+        int firstBad = -1;\n+        for (int i = startWith; i < unfilteredStackTrace.size(); i++) {\n+            if (!this.isBad(unfilteredStackTrace.get(i))) {\n+                continue;\n+            }\n+            lastBad = i;\n+            if (firstBad == -1) {\n+                firstBad = i;\n+            }\n+        }\n+        \n+        List<StackTraceElement> top;\n+        if (firstBad != -1) {\n+            top = unfilteredStackTrace.subList(startWith, firstBad);\n+        } else {\n+            top = new LinkedList<StackTraceElement>();\n+        }\n+        \n+        List<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\n+        List<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\n+        filtered.addAll(bottom);\n+        return filtered.toArray(new StackTraceElement[]{});\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n import org.hamcrest.StringDescription;\n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.util.MockUtil;\n     private final Method method;\n     private final Object[] arguments;\n     private final Location location;\n-    private final MethodProxy methodProxy;\n \n     private boolean verified;\n     private boolean verifiedInOrder;\n     private Object[] rawArguments;\n-\n-    public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, MethodProxy methodProxy) {\n+    private final RealMethod realMethod;\n+\n+    public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, RealMethod realMethod) {\n         this.mock = mock;\n         this.method = method;\n+        this.realMethod = realMethod;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n         this.rawArguments = args;\n         this.sequenceNumber = sequenceNumber;\n         this.location = new Location();\n-        this.methodProxy = methodProxy;\n     }\n \n     // expands array varArgs that are given by runtime (1, [a, b]) into true\n     }\n \n     public Object callRealMethod() throws Throwable {\n-        return methodProxy.invokeSuper(mock, arguments);\n+        return realMethod.invoke(mock, arguments);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+\n+public class CGLIBProxyRealMethod implements RealMethod {\n+\n+    private final MethodProxy methodProxy;\n+\n+    public CGLIBProxyRealMethod(MethodProxy methodProxy) {\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    public Object invoke(Object target, Object[] arguments) throws Throwable {\n+        return methodProxy.invokeSuper(target, arguments);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+\n+public class FilteredCGLIBProxyRealMethod implements RealMethod {\n+\n+    private final RealMethod realMethod;\n+\n+    public FilteredCGLIBProxyRealMethod(MethodProxy methodProxy) {\n+        this(new CGLIBProxyRealMethod(methodProxy));\n+    }\n+\n+    public FilteredCGLIBProxyRealMethod(RealMethod realMethod) {\n+        this.realMethod = realMethod;\n+    }\n+\n+    public Object invoke(Object target, Object[] arguments) throws Throwable {\n+        try {\n+            return realMethod.invoke(target, arguments);\n+        } catch (Throwable t) {\n+            new ConditionalStackTraceFilter().filter(t);\n+            throw t;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/RealMethod.java\n+package org.mockito.internal.invocation.realmethod;\n+\n+public interface RealMethod {\n+\n+    Object invoke(Object target, Object[] arguments) throws Throwable;\n+\n+}\n--- a/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n  */\n package org.mockito.internal.stubbing.answers;\n \n-import org.mockito.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n--- /dev/null\n+++ b/test/org/mockito/internal/exceptions/base/ConditionalStackTraceFilterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.exceptions.base;\n+\n+import static org.mockitoutil.ExtraMatchers.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.TraceBuilder;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockitoutil.TestBase;\n+\n+public class ConditionalStackTraceFilterTest extends TestBase {\n+    \n+    private ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n+\n+    @Test\n+    public void shouldNotFilterWhenConfigurationSaysNo() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n+        \n+        Throwable t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\" \n+        ).toThrowable();\n+        \n+        filter.filter(t);\n+        \n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.mockito.Mockito\", \"org.test.MockitoSampleTest\"));\n+    }\n+\n+    @Test\n+    public void shouldFilterWhenConfigurationSaysYes() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n+        \n+        Throwable t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\" \n+        ).toThrowable();\n+        \n+        filter.filter(t);\n+        \n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.test.MockitoSampleTest\"));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/exceptions/base/StackTraceFilterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.exceptions.base;\n+\n+import static org.mockitoutil.ExtraMatchers.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.TraceBuilder;\n+import org.mockitoutil.TestBase;\n+\n+public class StackTraceFilterTest extends TestBase {\n+    \n+    private StackTraceFilter filter = new StackTraceFilter();\n+    \n+    @Test\n+    public void shouldFilterOutCglibGarbage() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+            \"MockitoExampleTest\",\n+            \"List$$EnhancerByMockitoWithCGLIB$$2c406024\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, 0);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"MockitoExampleTest\"));\n+    }\n+    \n+    @Test\n+    public void shouldFilterOutMockitoPackage() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+            \"org.test.MockitoSampleTest\",\n+            \"org.mockito.Mockito\"\n+        ).toTraceArray();\n+            \n+        StackTraceElement[] filtered = filter.filter(t, 0);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\"));\n+    }\n+    \n+    @Test\n+    public void shouldFilterOutTracesMiddleBadTraces() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.test.TestSupport\",\n+                \"org.mockito.Mockito\", \n+                \"org.test.TestSupport\",\n+                \"org.mockito.Mockito\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, 0);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n+    }\n+    \n+    @Test\n+    public void shouldKeepRunners() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.mockito.runners.Runner\",\n+                \"junit.stuff\",\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, 0);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"junit.stuff\", \"org.mockito.runners.Runner\"));\n+    }\n+    \n+    @Test\n+    public void shouldKeepInternalRunners() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.mockito.internal.runners.Runner\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, 0);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"org.mockito.internal.runners.Runner\"));\n+    }\n+    \n+    @Test\n+    public void shouldStartFilteringFromIndex() {\n+        //given\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.test.Good\",\n+                \"org.mockito.internal.Bad\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        int startIndex = 1;\n+        \n+        //when\n+        StackTraceElement[] filtered = filter.filter(t, startIndex);\n+        \n+        //then\n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.Good\"));\n+    }\n+\n+    @Test\n+    public void shouldKeepGoodTraceFromTheTopBecauseSpiesSometimesThrowExceptions() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.good.Trace\",\n+                \"org.yet.another.good.Trace\",\n+                \"org.mockito.internal.to.be.Filtered\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, 0);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.yet.another.good.Trace\",\n+                \"org.good.Trace\"\n+                ));\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n import org.mockitousage.IMethods;\n         assertFalse(invocation.isValidException(new Exception()));\n         assertTrue(invocation.isValidException(new CharacterCodingException()));\n     }\n+    \n+    class Foo {\n+        public String bark() {\n+            return \"woof\";\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToCallRealMethod() throws Throwable {\n+        //when\n+        Invocation invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n+            public Object invoke(Object target, Object[] arguments) throws Throwable {\n+                return new Foo().bark();\n+            }});\n+        //then\n+        assertEquals(\"woof\", invocation.callRealMethod());\n+    }\n }\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.util.MockUtil;\n import org.mockitoutil.TestBase;\n \n         assertNull(values.returnValueFor(Baz.class));\n     }\n \n-    private Invocation invocationOf(Class<?> type, String methodName)\n-            throws NoSuchMethodException {\n-        return new Invocation(new Object(), type.getMethod(methodName,\n-                new Class[0]), new Object[0], 1, null);\n-    }\n-\n     @Test\n     public void shouldReturnTheUsualDefaultValuesForPrimitives()\n             throws Throwable {\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n import org.mockitoutil.TestBase;\n \n public class ReturnsSmartNullsTest extends TestBase {\n-    \n-    private Invocation invocationOf(Class<?> type, String methodName) throws NoSuchMethodException {\n-        return new Invocation(new Object(), type.getMethod(methodName, new Class[0]), new Object[0], 1, null);\n-    }\n     \n     @Test\n     public void shouldReturnTheUsualDefaultValuesForPrimitives() throws Throwable {\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n         protected String getStuff() {\n             return \"foo\";\n         }\n+    }\n+    \n+    class Boo {\n+        public void withLong(long y) {\n+            \n+        }\n+    }\n+    \n+    @Test\n+    public void should() throws Exception {\n+        Boo boo = mock(Boo.class);\n+        boo.withLong(100);\n+        \n+        verify(boo).withLong(new Long(100));\n     }\n \n     Foo mock;\n--- /dev/null\n+++ b/test/org/mockitousage/internal/debugging/LocationTest.java\n+package org.mockitousage.internal.debugging;\n+\n+import org.junit.Test;\n+import org.mockito.internal.debugging.Location;\n+import org.mockitoutil.TestBase;\n+\n+public class LocationTest extends TestBase {\n+\n+    @Test\n+    public void shouldLocationNotContainGetStackTraceMethod() {\n+        assertContains(\"shouldLocationNotContainGetStackTraceMethod\", new Location().toString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/internal/invocation/realmethod/FilteredCGLIBProxyRealMethodTest.java\n+package org.mockitousage.internal.invocation.realmethod;\n+\n+import static org.mockitoutil.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockitoutil.TestBase;\n+\n+public class FilteredCGLIBProxyRealMethodTest extends TestBase {\n+\n+    @Before\n+    public void keepStackTracesClean() {\n+        makeStackTracesClean();\n+    }\n+    \n+    class Foo {\n+        public String throwSomething() {\n+            throw new RuntimeException();\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows() throws Throwable {\n+        //given\n+        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(new RealMethod() {\n+            public Object invoke(Object target, Object[] arguments) throws Throwable {\n+                return new Foo().throwSomething();\n+            }});\n+        \n+        //when\n+        try {\n+            realMethod.invoke(null, null);\n+            fail();\n+        //then\n+        } catch (Exception e) {\n+            assertThat(e, hasMethodInStackTraceAt(0, \"throwSomething\"));\n+            assertThat(e, hasMethodInStackTraceAt(1, \"invoke\"));\n+            assertThat(e, hasMethodInStackTraceAt(2, \"shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows\"));\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n+++ b/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n         }\n     }\n     \n-//    @Test\n-//    TODO: see the TODO comment in MockHandler about extra stack trace filter\n+    @Test\n     public void shouldStackTraceGetFilteredOnUserExceptions() {\n-        spy.getNameButDelegateToMethodThatThrows();\n         try {\n             // when\n             spy.getNameButDelegateToMethodThatThrows();\n                     \"shouldStackTraceGetFilteredOnUserExceptions\"\n                     ));\n         }\n+    }\n+\n+//    @Test //manual verification\n+    public void verifyTheStackTrace() {\n+        spy.getNameButDelegateToMethodThatThrows();\n     }\n \n     @Test\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.MockitoAnnotations;\n import org.mockito.StateMaster;\n import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n \n /**\n  * the easiest way to make sure that tests clean up invalid state is to require\n                 \"\\n\"\n                 , string.contains(sub));\n     }\n+\n+    protected static Invocation invocationOf(Class<?> type, String methodName) throws NoSuchMethodException {\n+        return new Invocation(new Object(), type.getMethod(methodName,\n+                new Class[0]), new Object[0], 1, null);\n+    }\n+    \n+    protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n+        return new Invocation(new Object(), type.getMethod(methodName,\n+                new Class[0]), new Object[0], 1, realMethod);\n+    }\n }", "timestamp": 1243890739, "metainfo": ""}