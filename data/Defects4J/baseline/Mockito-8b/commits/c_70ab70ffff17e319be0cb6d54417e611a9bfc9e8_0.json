{"sha": "70ab70ffff17e319be0cb6d54417e611a9bfc9e8", "log": "Renamed for clarity", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/plugins/DefaultPluginSwitch.java\n+package org.mockito.internal.configuration.plugins;\n+\n+import org.mockito.plugins.PluginSwitch;\n+\n+class DefaultPluginSwitch implements PluginSwitch {\n+    public boolean isEnabled(String pluginClassName) {\n+        return true;\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/plugins/PluginFinder.java\n+++ b/src/org/mockito/internal/configuration/plugins/PluginFinder.java\n \n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.io.IOUtil;\n-import org.mockito.plugins.PluginSwitcher;\n+import org.mockito.plugins.PluginSwitch;\n \n import java.io.InputStream;\n import java.net.URL;\n \n class PluginFinder {\n \n-    private final PluginSwitcher pluginSwitcher;\n+    private final PluginSwitch pluginSwitch;\n \n-    public PluginFinder(PluginSwitcher pluginSwitcher) {\n-        this.pluginSwitcher = pluginSwitcher;\n+    public PluginFinder(PluginSwitch pluginSwitch) {\n+        this.pluginSwitch = pluginSwitch;\n     }\n \n     String findPluginClass(Iterable<URL> resources) {\n                     //If the resource does not have plugin class name we're ignoring it\n                     continue;\n                 }\n-                if (!pluginSwitcher.isEnabled(pluginClassName)) {\n+                if (!pluginSwitch.isEnabled(pluginClassName)) {\n                     continue;\n                 }\n                 return pluginClassName;\n--- a/src/org/mockito/internal/configuration/plugins/PluginLoader.java\n+++ b/src/org/mockito/internal/configuration/plugins/PluginLoader.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n import org.mockito.internal.util.collections.Iterables;\n-import org.mockito.plugins.PluginSwitcher;\n+import org.mockito.plugins.PluginSwitch;\n \n import java.io.IOException;\n import java.net.URL;\n \n class PluginLoader {\n \n-    private final PluginSwitcher pluginSwitcher;\n+    private final PluginSwitch pluginSwitch;\n \n-    public PluginLoader(PluginSwitcher pluginSwitcher) {\n-        this.pluginSwitcher = pluginSwitcher;\n+    public PluginLoader(PluginSwitch pluginSwitch) {\n+        this.pluginSwitch = pluginSwitch;\n     }\n \n     /**\n         //TODO SF refactor\n         List<T> result = new ArrayList<T>();\n         try {\n-            String foundPluginClass = new PluginFinder(pluginSwitcher).findPluginClass(Iterables.toIterable(resources));\n+            String foundPluginClass = new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));\n             if (foundPluginClass != null) {\n                 Class<?> pluginClass = loader.loadClass(foundPluginClass);\n                 Object plugin = pluginClass.newInstance();\n--- a/src/org/mockito/internal/configuration/plugins/PluginRegistry.java\n+++ b/src/org/mockito/internal/configuration/plugins/PluginRegistry.java\n package org.mockito.internal.configuration.plugins;\n \n import org.mockito.plugins.MockMaker;\n-import org.mockito.plugins.PluginSwitcher;\n+import org.mockito.plugins.PluginSwitch;\n import org.mockito.plugins.StackTraceCleanerProvider;\n \n class PluginRegistry {\n \n-    private final PluginSwitcher pluginSwitcher\n-            = new PluginLoader(new DefaultPluginSwitcher()).loadPlugin(PluginSwitcher.class, DefaultPluginSwitcher.class.getName());\n+    private final PluginSwitch pluginSwitch\n+            = new PluginLoader(new DefaultPluginSwitch()).loadPlugin(PluginSwitch.class, DefaultPluginSwitch.class.getName());\n \n     private final MockMaker mockMaker\n-            = new PluginLoader(pluginSwitcher).loadPlugin(MockMaker.class, \"org.mockito.internal.creation.cglib.CglibMockMaker\");\n+            = new PluginLoader(pluginSwitch).loadPlugin(MockMaker.class, \"org.mockito.internal.creation.cglib.CglibMockMaker\");\n \n     private final StackTraceCleanerProvider stackTraceCleanerProvider\n-            = new PluginLoader(pluginSwitcher).loadPlugin(StackTraceCleanerProvider.class, \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\");\n+            = new PluginLoader(pluginSwitch).loadPlugin(StackTraceCleanerProvider.class, \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\");\n \n     /**\n      * The implementation of the stack trace cleaner\n--- /dev/null\n+++ b/src/org/mockito/plugins/PluginSwitch.java\n+package org.mockito.plugins;\n+\n+/**\n+ * Allows switching off the plugins that are discovered on classpath.\n+ * When a particular plugin is switched off, the default Mockito behavior is used.\n+ * For example, if Android's dexmaker MockMaker is switched off,\n+ * Mockito default MockMaker implementation is used {@link org.mockito.plugins.MockMaker}\n+ */\n+public interface PluginSwitch {\n+\n+    /**\n+     * Mockito invokes this method for every plugin found in the classpath\n+     * (except from the {@code PluginSwitch} implementation itself).\n+     * If no custom plugins are discovered this method is not invoked.\n+     */\n+    boolean isEnabled(String pluginClassName);\n+}\n--- /dev/null\n+++ b/subprojects/extTest/src/test/java/org/mockitousage/plugins/switcher/MyPluginSwitch.java\n+package org.mockitousage.plugins.switcher;\n+\n+import org.mockito.plugins.PluginSwitch;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class MyPluginSwitch implements PluginSwitch {\n+\n+    static List<String> invokedFor = new LinkedList<String>();\n+\n+    public boolean isEnabled(String pluginClassName) {\n+        invokedFor.add(pluginClassName);\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/extTest/src/test/java/org/mockitousage/plugins/switcher/PluginSwitchTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.plugins.switcher;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockitousage.plugins.stacktrace.MyStackTraceCleanerProvider;\n+\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+public class PluginSwitchTest {\n+    \n+    @Test\n+    public void plugin_switcher_is_used() {\n+        mock(List.class);\n+        assertEquals(MyPluginSwitch.invokedFor, asList(MyMockMaker.class.getName(), MyStackTraceCleanerProvider.class.getName()));\n+    }\n+\n+    @Test\n+    public void uses_custom_mock_maker() {\n+        //when\n+        MyMockMaker.explosive.set(new Object());\n+\n+        //when\n+        try {\n+            mock(List.class);\n+            fail();\n+        } catch (Exception e) {}\n+    }\n+\n+    @After\n+    public void after() {\n+        MyMockMaker.explosive.remove();\n+    }\n+}\n--- a/test/org/mockito/internal/configuration/plugins/PluginFinderTest.java\n+++ b/test/org/mockito/internal/configuration/plugins/PluginFinderTest.java\n import org.mockito.InjectMocks;\n import org.mockito.Mock;\n import org.mockito.internal.util.io.IOUtil;\n-import org.mockito.plugins.PluginSwitcher;\n+import org.mockito.plugins.PluginSwitch;\n import org.mockitoutil.TestBase;\n \n import java.io.File;\n \n public class PluginFinderTest extends TestBase {\n \n-    @Mock PluginSwitcher switcher;\n+    @Mock\n+    PluginSwitch switcher;\n     @InjectMocks PluginFinder finder;\n     public @Rule TemporaryFolder tmp = new TemporaryFolder();\n ", "timestamp": 1418426972, "metainfo": ""}