{"sha": "297ec0de8b9f3c93f850f41e63045648bb279966", "log": "Added more obvious test for showing correct stack trace elements Made JUnit44 runner working with Junit 4.3 Made StackTraceFilter sensitive to internal runners code (required for making correct navigable stack trace elems in exception messages)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401389", "commit": "\n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n         boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n         boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n         boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n-        return fromMockObject || fromOrgMockito && !isRunner;\n+        boolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\n+        return (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n     }\n \n     public StackTraceElement[] filter(StackTraceElement[] target) {\n--- /dev/null\n+++ b/src/org/mockito/internal/runners/LegacyJUnitRunner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.runners;\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.junit.internal.runners.*;\n+import org.junit.runner.*;\n+import org.junit.runner.manipulation.*;\n+import org.junit.runner.notification.*;\n+\n+/**\n+ * This class is nearly the same as JUnit4ClassRunner (Junit 4.4) that has been made deprecated at JUnit 4.5 by the junit team. \n+ * I need this implementation to provide consistent runner for previous versions of JUnit < 4.5\n+ * Unfortunately I cannot use JUnit4ClassRunner itself because it is not available in JUnit < 4.4\n+ */\n+@SuppressWarnings(\"all\") // suppressing all warnings because it is not really our code.\n+public class LegacyJUnitRunner extends Runner {\n+\n+    private final List<Method> fTestMethods;\n+    private TestClass fTestClass;\n+    private final TestCreationListener testStartedCallback;\n+\n+    public LegacyJUnitRunner(Class<?> klass,\n+            TestCreationListener testStartedCallback)\n+            throws InitializationError {\n+        this.testStartedCallback = testStartedCallback;\n+        fTestClass = new TestClass(klass);\n+        fTestMethods = getTestMethods();\n+        validate();\n+    }\n+\n+    protected List<Method> getTestMethods() {\n+        return fTestClass.getTestMethods();\n+    }\n+\n+    protected void validate() throws InitializationError {\n+        MethodValidator methodValidator = new MethodValidator(fTestClass);\n+        methodValidator.validateMethodsForDefaultRunner();\n+        methodValidator.assertValid();\n+    }\n+\n+    @Override\n+    public void run(final RunNotifier notifier) {\n+        new ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n+            public void run() {\n+                runMethods(notifier);\n+            }\n+        }).runProtected();\n+    }\n+\n+    protected void runMethods(final RunNotifier notifier) {\n+        for (Method method : fTestMethods) {\n+            invokeTestMethod(method, notifier);\n+        }\n+    }\n+\n+    @Override\n+    public Description getDescription() {\n+        Description spec = Description.createSuiteDescription(getName(),\n+                classAnnotations());\n+        List<Method> testMethods = fTestMethods;\n+        for (Method method : testMethods) {\n+            spec.addChild(methodDescription(method));\n+        }\n+        return spec;\n+    }\n+\n+    protected Annotation[] classAnnotations() {\n+        return fTestClass.getJavaClass().getAnnotations();\n+    }\n+\n+    protected String getName() {\n+        return getTestClass().getName();\n+    }\n+\n+    protected Object createTest() throws Exception {\n+        Object test = getTestClass().getConstructor().newInstance();\n+\n+        testStartedCallback.testCreated(test);\n+\n+        return test;\n+    }\n+\n+    protected void invokeTestMethod(Method method, RunNotifier notifier) {\n+        Description description = methodDescription(method);\n+        Object test;\n+        try {\n+            test = createTest();\n+        } catch (InvocationTargetException e) {\n+            testAborted(notifier, description, e.getCause());\n+            return;\n+        } catch (Exception e) {\n+            testAborted(notifier, description, e);\n+            return;\n+        }\n+        TestMethod testMethod = wrapMethod(method);\n+        new MethodRoadie(test, testMethod, notifier, description).run();\n+    }\n+\n+    private void testAborted(RunNotifier notifier, Description description,\n+            Throwable e) {\n+        notifier.fireTestStarted(description);\n+        notifier.fireTestFailure(new Failure(description, e));\n+        notifier.fireTestFinished(description);\n+    }\n+\n+    protected TestMethod wrapMethod(Method method) {\n+        return new TestMethod(method, fTestClass);\n+    }\n+\n+    protected String testName(Method method) {\n+        return method.getName();\n+    }\n+\n+    protected Description methodDescription(Method method) {\n+        return Description.createTestDescription(getTestClass().getJavaClass(),\n+                testName(method), testAnnotations(method));\n+    }\n+\n+    protected Annotation[] testAnnotations(Method method) {\n+        return method.getAnnotations();\n+    }\n+\n+    public void filter(Filter filter) throws NoTestsRemainException {\n+        for (Iterator<Method> iter = fTestMethods.iterator(); iter.hasNext();) {\n+            Method method = iter.next();\n+            if (!filter.shouldRun(methodDescription(method))) {\n+                iter.remove();\n+            }\n+        }\n+        if (fTestMethods.isEmpty()) {\n+            throw new NoTestsRemainException();\n+        }\n+    }\n+\n+    public void sort(final Sorter sorter) {\n+        Collections.sort(fTestMethods, new Comparator<Method>() {\n+            public int compare(Method o1, Method o2) {\n+                return sorter.compare(methodDescription(o1),\n+                        methodDescription(o2));\n+            }\n+        });\n+    }\n+\n+    protected TestClass getTestClass() {\n+        return fTestClass;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/runners/TestCreationListener.java\n+package org.mockito.internal.runners;\n+\n+public interface TestCreationListener {\n+\n+    void testCreated(Object test);\n+\n+}\n--- a/src/org/mockito/runners/MockitoJUnit44Runner.java\n+++ b/src/org/mockito/runners/MockitoJUnit44Runner.java\n  */\n package org.mockito.runners;\n \n-import org.junit.internal.runners.InitializationError;\n-import org.junit.internal.runners.JUnit4ClassRunner;\n-import org.junit.runner.notification.RunNotifier;\n-import org.mockito.Mock;\n-import org.mockito.MockitoAnnotations;\n-import org.mockito.internal.runners.FrameworkUsageValidator;\n+import org.junit.internal.runners.*;\n+import org.junit.runner.*;\n+import org.junit.runner.notification.*;\n+import org.mockito.*;\n+import org.mockito.internal.runners.*;\n+\n \n /**\n  * <b>JUnit 4.4</b> runner initializes mocks annotated with {@link Mock},\n  * </pre>\n  */\n @SuppressWarnings(\"deprecation\")\n-public class MockitoJUnit44Runner extends JUnit4ClassRunner {\n+public class MockitoJUnit44Runner extends Runner {\n+\n+    private LegacyJUnitRunner legacyRunner;\n \n     public MockitoJUnit44Runner(Class<?> klass) throws InitializationError {\n-        super(klass);\n+        legacyRunner = new LegacyJUnitRunner(klass, new TestCreationListener() {\n+            public void testCreated(Object test) {\n+                MockitoAnnotations.initMocks(test);\n+            }\n+        });\n     }\n \n     @Override\n-    protected Object createTest() throws Exception {\n-        Object test = super.createTest();\n-        MockitoAnnotations.initMocks(test);\n-        return test;\n+    public void run(final RunNotifier notifier) {\n+        // add listener that validates framework usage at the end of each test\n+        notifier.addListener(new FrameworkUsageValidator(notifier));\n+\n+        legacyRunner.run(notifier);\n     }\n-    \n+\n     @Override\n-    public void run(final RunNotifier notifier) {\n-        //add listener that validates framework usage at the end of each test\n-        notifier.addListener(new FrameworkUsageValidator(notifier));\n-        \n-        super.run(notifier);\n+    public Description getDescription() {\n+        return legacyRunner.getDescription();\n     }\n }\n--- a/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n     }\n     \n     @Test\n-    public void shouldIgnoreRunners() {\n+    public void shouldKeepRunners() {\n         StackTraceElement[] t = new TraceBuilder().classes(\n                 \"org.mockito.runners.Runner\",\n                 \"junit.stuff\",\n         \n         assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"junit.stuff\", \"org.mockito.runners.Runner\"));\n     }\n+    \n+    @Test\n+    public void shouldKeepInternalRunners() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.mockito.internal.runners.Runner\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"org.mockito.internal.runners.Runner\"));\n+    }\n }\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java\n             assertContains(\"first(\", e.getMessage());\n         }\n     }   \n+    \n+    @Test\n+    public void shouldNotPointStackTracesToRunnersCode() {\n+        try {\n+            verify(mock, times(0)).simpleMethod(1);\n+            fail();\n+        } catch (NeverWantedButInvoked e) {\n+            assertNotContains(\".runners.\", e.getMessage());\n+        }\n+    }   \n }", "timestamp": 1241270385, "metainfo": ""}