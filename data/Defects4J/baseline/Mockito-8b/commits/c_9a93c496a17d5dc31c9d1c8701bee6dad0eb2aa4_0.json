{"sha": "9a93c496a17d5dc31c9d1c8701bee6dad0eb2aa4", "log": "First batch of code related to mocking multiple interfaces  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401415", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/AncillaryTypes.java\n+/**\n+ * \n+ */\n+package org.mockito;\n+\n+/**\n+ *\n+ * @author Karl George Schaefer\n+ */\n+public interface AncillaryTypes {\n+    Class<?>[] implementing();\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return MOCKITO_CORE.mock(classToMock, null, null, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock(classToMock, null, null, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, String name) {\n-        return MOCKITO_CORE.mock(classToMock, name, null, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock(classToMock, null, name, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n-        return MOCKITO_CORE.mock(classToMock, null, (T) null, returnValues);\n+        return MOCKITO_CORE.mock(classToMock, null, null, (T) null, returnValues);\n     }\n     \n     /**\n      * @return a spy of the real object\n      */\n     public static <T> T spy(T object) {\n-        return MOCKITO_CORE.mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock((Class<T>) object.getClass(), null, null, object, RETURNS_DEFAULTS);\n     }\n \n     /**\n--- /dev/null\n+++ b/src/org/mockito/internal/AncillaryTypesImpl.java\n+/**\n+ * \n+ */\n+package org.mockito.internal;\n+\n+import org.mockito.AncillaryTypes;\n+\n+/**\n+ * @author Karl George Schaefer\n+ *\n+ */\n+class AncillaryTypesImpl implements AncillaryTypes {\n+    private Class<?>[] types;\n+    \n+    public AncillaryTypesImpl(Class<?>... types) {\n+        this.types = types;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.mockito.AncillaryTypes#implementing()\n+     */\n+    public Class<?>[] implementing() {\n+        return types;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n \n import java.util.Arrays;\n \n+import org.mockito.AncillaryTypes;\n import org.mockito.InOrder;\n import org.mockito.ReturnValues;\n import org.mockito.exceptions.Reporter;\n     private final Reporter reporter = new Reporter();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n-    public <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n+    public <T> T mock(Class<T> classToMock, AncillaryTypes implementing, String name,\n+            T optionalInstance, ReturnValues returnValues) {\n         mockingProgress.validateState();\n         mockingProgress.resetOngoingStubbing();\n-        return MockUtil.createMock(classToMock, mockingProgress, name, optionalInstance, returnValues);\n+        return MockUtil.createMock(classToMock, implementing, mockingProgress, name,\n+                optionalInstance, returnValues);\n+    }\n+    \n+    public AncillaryTypes implementing(Class<?>...ancillaryTypes) {\n+        return new AncillaryTypesImpl(ancillaryTypes);\n     }\n     \n     public OngoingStubbing stub() {\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n         return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers()) && !type.isAnonymousClass();\n     }\n     \n-    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancilliaryTypes) {\n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n         try {\n             setConstructorsAccessible(mockedType, true);\n-            Class<?> proxyClass = createProxyClass(mockedType);\n+            Class<?> proxyClass = createProxyClass(mockedType, ancillaryTypes);\n             return mockedType.cast(createProxy(proxyClass, interceptor));\n         } finally {\n             setConstructorsAccessible(mockedType, false);\n         }\n     }\n     \n-    private <T> Class<?> createProxyClass(Class<?> mockedType) {\n+    private <T> Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\n         if (mockedType == Object.class) {\n             mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n         }\n         enhancer.setUseFactory(true);\n         if (mockedType.isInterface()) {\n             enhancer.setSuperclass(Object.class);\n-            enhancer.setInterfaces(prepend(mockedType));\n+            enhancer.setInterfaces(prepend(mockedType, interfaces));\n         } else {\n             enhancer.setSuperclass(mockedType);\n+            enhancer.setInterfaces(interfaces);\n         }\n         enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\n         enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\n         }\n         \n         try {\n+            //TODO this can throw IllegalStateException if interfaces is a bad parameter\n+            //1. validate it and throw early\n+            //2. catch and rethrow as MockitoException\n             return enhancer.createClass(); \n         } catch (CodeGenerationException e) {\n             if (Modifier.isPrivate(mockedType.getModifiers())) {\n--- a/src/org/mockito/internal/returnvalues/MockReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/MockReturnValues.java\n             return null;\n         }\n         \n-        return mockitoCore.mock((Class) class1, null, null, this);\n+        return mockitoCore.mock((Class) class1, null, null, null, this);\n     }\n \n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n \n+import org.mockito.AncillaryTypes;\n import org.mockito.ReturnValues;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n \n public class MockUtil {\n \n-    public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String mockName, T optionalInstance,\n-            ReturnValues returnValues) {\n+    public static <T> T createMock(Class<T> classToMock, AncillaryTypes ancillaryTypes, MockingProgress progress, String mockName,\n+            T optionalInstance, ReturnValues returnValues) {\n         validateType(classToMock);\n         MockHandler<T> mockHandler = new MockHandler<T>(new MockName(mockName, classToMock), progress, new MatchersBinder(), returnValues);\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n-\n-        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n+        Class<?>[] interfaces = ancillaryTypes == null ? new Class<?>[0] : ancillaryTypes.implementing();\n+        \n+        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, interfaces);\n         \n         if (optionalInstance != null) {\n             new LenientCopyTool().copyToMock(optionalInstance, mock);\n--- a/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n+++ b/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.creation.jmock;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n \n import java.lang.reflect.Method;\n \n         assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n     }\n     \n+    //TODO: try with 2 the same / different interfaces\n+    @Test\n+    public void ensureMockIsAllTypes() {\n+        SomeClass mock = ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);\n+        \n+        assertThat(mock, is(instanceOf(SomeInterface.class)));\n+    }\n+    \n+    @Test(expected = IllegalStateException.class)\n+    public void shouldThrowWhenClassPassedAsInterface() {\n+        ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeInterface.class, SomeClass.class);\n+    }\n+    \n+    //TODO: different exception\n+    @Test(expected = IllegalStateException.class)\n+    public void shouldThrowWhenNullType() {\n+        ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class, (Class<?>) null);\n+    }\n+    \n+    //TODO: why nulls are ok?\n+    @Test\n+    public void ensureNoProblemsWithNullTypes() {\n+        ClassImposterizer.INSTANCE.imposterise(new MethodInterceptorStub(), SomeClass.class, (Class<?>[]) null);\n+    }\n+    \n     private interface SomeInterface {};\n \n     private class SomeClass {};\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n     \n     @Test\n     public void partialMockInAction() {\n-//        mock = mock(Foo.class)\n+//        mock = mock(Foo.class, configuration() \n+//            .name(\"foo\").defaultBehavior(RETURNS_SMART_NULLS).extraInterfaces()\n+//            .\n //            .withName(\"foo\")\n //            .withDefaultBehavior(RETURNS_SMART_NULLS)\n //            .withInterfaces(Bar.class);", "timestamp": 1241986689, "metainfo": ""}