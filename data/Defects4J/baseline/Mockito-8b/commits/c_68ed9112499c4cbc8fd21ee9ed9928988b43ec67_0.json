{"sha": "68ed9112499c4cbc8fd21ee9ed9928988b43ec67", "log": "enabled test for one of the verifiers, added more TODOs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40319", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n             ), cause);\n     }\n \n-    public void wantedButNotInvoked(String wanted) {\n+    public void wantedButNotInvoked(Object wanted) {\n         throw new WantedButNotInvoked(join(\n                     \"Wanted but not invoked:\",\n-                    wanted\n+                    wanted.toString()\n         ));\n     }\n     \n     //TODO do something about those objects (Printable object)\n-    public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace previousInOrder) {\n+    //TODO previous and previousStackTrace should be the same object\n+    public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace previousStackTrace) {\n         WantedAnywhereAfterFollowingInteraction cause = new WantedAnywhereAfterFollowingInteraction(join(\n                         \"Wanted anywhere AFTER following interaction:\",\n                         previous.toString()));\n-        cause.setStackTrace(previousInOrder.getStackTrace());\n+        cause.setStackTrace(previousStackTrace.getStackTrace());\n         \n         throw new VerifcationInOrderFailed(join(\n                     \"Verification in order failed\",\n                     \"Wanted but not invoked:\",\n                     wanted.toString()\n         ), cause);\n-    }\n-    \n-    public void wantedButNotInvokedInOrder(Object wanted) {\n-        throw new VerifcationInOrderFailed(join(\n-                    \"Verification in order failed\",\n-                    \"Wanted but not invoked:\",\n-                    wanted.toString()\n-        ));\n     }\n \n     public void tooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n     public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n     }\n-\n-    /**\n-     * fills first chunk based on wanted.matches()\n-     */\n-    public List<Invocation> findFirstUnverifiedChunk(List<Invocation> invocations, InvocationMatcher wanted) {\n-        List<Invocation> unverified = removeVerifiedInOrder(invocations);\n-        List<Invocation> firstChunk = new LinkedList<Invocation>();\n-        for (Invocation invocation : unverified) {\n-            if (wanted.matches(invocation)) {\n-                firstChunk.add(invocation);\n-            } else if (firstChunk.isEmpty()) {\n-                firstChunk.add(invocation);\n-                break;\n-            } else {\n-                break;\n-            }\n-        }\n-        return firstChunk;\n-    }\n-    \n \n     public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n--- a/src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java\n         \n         List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n         \n-        if (chunk.size() == 0) {\n-            Invocation previousInOrder = finder.findPreviousInOrder(invocations, wanted);\n-            if (previousInOrder == null) {\n-                reporter.wantedButNotInvokedInOrder(wanted);\n-            } else {\n-                reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getStackTrace());\n-            }\n-        }         \n+        if (!chunk.isEmpty()) {\n+            return;\n+        }\n+        \n+        Invocation previousInOrder = finder.findPreviousInOrder(invocations, wanted);\n+        if (previousInOrder == null) {\n+            reporter.wantedButNotInvoked(wanted);\n+        } else {\n+            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getStackTrace());\n+        }\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static java.util.Arrays.*;\n import static org.junit.Assert.*;\n import static org.mockito.internal.progress.VerificationModeImpl.*;\n import static org.mockito.util.ExtraMatchers.*;\n         \n         actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation), atLeastOnce());\n         assertThat(actual, collectionHasExactlyInOrder(differentMethodInvocation));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstUnverifiedChunk() throws Exception {\n-        List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        \n-        assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstChunkAndSkipVerifiedInvocations() throws Exception {\n-        simpleMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n-        \n-        List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        \n-        assertThat(unverified, collectionHasExactlyInOrder(differentMethodInvocation));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstChunkAndSkipAllInvocations() throws Exception {\n-        simpleMethodInvocation.markVerifiedInOrder();\n-        simpleMethodInvocationTwo.markVerifiedInOrder();\n-        differentMethodInvocation.markVerifiedInOrder();\n-        \n-        List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        \n-        assertTrue(unverified.isEmpty());\n-    }\n-    \n-    @Test\n-    public void shouldFindAllInvocationsBecauseAllMatch() throws Exception {\n-        List<Invocation> unverified = finder.findFirstUnverifiedChunk(\n-                asList(simpleMethodInvocation, simpleMethodInvocationTwo), new InvocationMatcher(simpleMethodInvocation));\n-        \n-        assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n-    }\n-    \n-    @Test\n-    public void shouldReturnFirstUnverifiedInvocationIfNoMatchesFound() throws Exception {\n-        List<Invocation> unverified = finder.findFirstUnverifiedChunk(\n-                asList(differentMethodInvocation), new InvocationMatcher(simpleMethodInvocation));\n-        \n-        assertThat(unverified, collectionHasExactlyInOrder(differentMethodInvocation));\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/verification/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/InvocationsFinderStub.java\n     final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n     List<Invocation> invocations;\n     Invocation firstUnverifiedToReturn;\n-    final List<Invocation> firstUnverifiedChunkToReturn = new LinkedList<Invocation>();\n+    final List<Invocation> allMatchingUnverifiedChunksToReturn = new LinkedList<Invocation>();\n+    Invocation previousInOrderToReturn;\n \n     @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n             VerificationModeImpl mode) {\n         return firstUnverifiedToReturn;\n     }\n     \n-    @Override public List<Invocation> findFirstUnverifiedChunk(List<Invocation> invocations, InvocationMatcher wanted) {\n-        return firstUnverifiedChunkToReturn;\n+    @Override\n+    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {\n+        return allMatchingUnverifiedChunksToReturn;\n+    }\n+    \n+    @Override\n+    public Invocation findPreviousInOrder(List<Invocation> invocations, InvocationMatcher wanted) {\n+        return previousInOrderToReturn;\n     }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n import java.util.LinkedList;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.VerificationModeBuilder;\n \n-@Ignore\n public class MissingInvocationInOrderVerifierTest extends RequiresValidState {\n \n     private MissingInvocationInOrderVerifier verifier;\n     }\n     \n     @Test\n+    public void shouldPassWhenMatchingInteractionFound() throws Exception {\n+        Invocation actual = new InvocationBuilder().toInvocation();\n+        finderStub.allMatchingUnverifiedChunksToReturn.add(actual);\n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n+    }\n+    \n+    @Test\n     public void shouldReportWantedButNotInvoked() throws Exception {\n-        assertTrue(finderStub.firstUnverifiedChunkToReturn.isEmpty());\n+        assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());\n         verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n         \n-        assertEquals(wanted.toString(), reporterStub.wanted);\n+        assertEquals(wanted, reporterStub.wanted);\n     }\n     \n     @Test\n     public void shouldReportWantedDiffersFromActual() throws Exception {\n-        Invocation different = new InvocationBuilder().differentMethod().toInvocation();\n-        finderStub.firstUnverifiedChunkToReturn.add(different);\n+        Invocation previous = new InvocationBuilder().toInvocation();\n+        finderStub.previousInOrderToReturn = previous;\n+        \n         verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n         \n-        assertEquals(wanted.toString(), reporterStub.wanted);\n-        assertEquals(different.toString(), reporterStub.actual);\n-        assertSame(different.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+        assertEquals(wanted, reporterStub.wanted);\n+        assertEquals(previous, reporterStub.previous);\n+        assertSame(previous.getStackTrace(), reporterStub.previousStackTrace);\n     }\n     \n     class ReporterStub extends Reporter {\n-        private String wanted;\n-        private String actual;\n-        private HasStackTrace actualInvocationStackTrace;\n+        private Object wanted;\n+        private Object previous;\n+        private HasStackTrace previousStackTrace;\n \n-        @Override public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace lastVerifiedInOrder) {\n-            this.wanted = wanted.toString();\n+        @Override public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace previousStackTrace) {\n+            this.wanted = wanted;\n+            this.previous = previous;\n+            this.previousStackTrace = previousStackTrace;\n         }\n         \n-        @Override public void wantedDiffersFromActualInOrder(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+        @Override public void wantedButNotInvoked(Object wanted) {\n             this.wanted = wanted;\n-            this.actual = actual;\n-            this.actualInvocationStackTrace = actualInvocationStackTrace;\n         }\n     }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n     }\n     \n     class ReporterStub extends Reporter {\n-        private String wanted;\n+        private Object wanted;\n         private String actual;\n         private HasStackTrace actualInvocationStackTrace;\n-        @Override public void wantedButNotInvoked(String wanted) {\n+        @Override public void wantedButNotInvoked(Object wanted) {\n             this.wanted = wanted;\n         }\n         @Override public void wantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n     \n     @Test\n     public void shouldPassIfWantedIsZeroAndFirstUnverifiedChunkIsEmpty() throws Exception {\n-        assertTrue(finderStub.firstUnverifiedChunkToReturn.isEmpty());\n+        assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());\n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).inOrder());\n     }\n     \n     @Test\n     public void shouldPassIfWantedIsZeroAndFirstUnverifiedChunkDoesNotMatch() throws Exception {\n         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n-        finderStub.firstUnverifiedChunkToReturn.add(differentMethod); \n+        finderStub.allMatchingUnverifiedChunksToReturn.add(differentMethod); \n         \n         assertFalse(wanted.matches(differentMethod));\n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).inOrder());\n     public void shouldReportTooLittleInvocations() throws Exception {\n         Invocation first = new InvocationBuilder().toInvocation();\n         Invocation second = new InvocationBuilder().toInvocation();\n-        finderStub.firstUnverifiedChunkToReturn.addAll(asList(first, second)); \n+        finderStub.allMatchingUnverifiedChunksToReturn.addAll(asList(first, second)); \n         \n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).inOrder());\n         \n     public void shouldReportTooManyInvocations() throws Exception {\n         Invocation first = new InvocationBuilder().toInvocation();\n         Invocation second = new InvocationBuilder().toInvocation();\n-        finderStub.firstUnverifiedChunkToReturn.addAll(asList(first, second)); \n+        finderStub.allMatchingUnverifiedChunksToReturn.addAll(asList(first, second)); \n         \n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n         \n     @Test\n     public void shouldMarkInvocationsAsVerified() throws Exception {\n         Invocation invocation = new InvocationBuilder().toInvocation();\n-        finderStub.firstUnverifiedChunkToReturn.add(invocation);\n+        finderStub.allMatchingUnverifiedChunksToReturn.add(invocation);\n         assertFalse(invocation.isVerifiedInOrder());\n         \n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java\n import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n--- a/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n import org.mockito.InOrder;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n     \n     /* ------------- */\n     \n-    @Test(expected=VerifcationInOrderFailed.class)\n+    @Test(expected=WantedButNotInvoked.class)\n     public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n         inOrder.verify(mockOne).simpleMethod(100);\n     }\n     \n-    @Test(expected=VerifcationInOrderFailed.class)\n+    @Test(expected=WantedButNotInvoked.class)\n     public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n         inOrder.verify(mockOne).oneArg(true);\n     }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedAnywhereAfterFollowingInteraction;\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends RequiresValidState {\n         try {\n             inOrder.verify(one).simpleMethod(999);\n             fail();\n-        } catch (VerifcationInOrderFailed e) {\n+        } catch (WantedButNotInvoked e) {\n             String expected = \n-                    \"\\n\" +\n-                    \"Verification in order failed\" +\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n--- a/test/org/mockitousage/verification/RelaxedVerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/RelaxedVerificationInOrderTest.java\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n /**\n         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n     }\n     \n-    @Test(expected=VerifcationInOrderFailed.class)\n+    @Test(expected=WantedButNotInvoked.class)\n     public void shouldFailOnWrongMethodCalledOnMockTwo() {\n         inOrder.verify(mockTwo, atLeastOnce()).differentMethod();\n     }\n--- a/test/org/mockitousage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/VerificationInOrderTest.java\n import org.mockito.InOrder;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             inOrder.verify(mockOne, atLeastOnce()).differentMethod();\n             fail();\n-        } catch (VerifcationInOrderFailed e) {\n+        } catch (WantedButNotInvoked e) {\n             assertThat(e, messageContains(\"IMethods.differentMethod()\"));\n         }\n     }", "timestamp": 1200962566, "metainfo": ""}