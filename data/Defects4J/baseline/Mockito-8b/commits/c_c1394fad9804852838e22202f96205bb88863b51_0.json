{"sha": "c1394fad9804852838e22202f96205bb88863b51", "log": "Made MockingDetails abstract  --HG-- rename : src/org/mockito/MockingDetails.java => src/org/mockito/internal/util/DefaultMockingDetails.java", "commit": "\n--- a/src/org/mockito/MockingDetails.java\n+++ b/src/org/mockito/MockingDetails.java\n package org.mockito;\n \n+import org.mockito.internal.util.DefaultMockingDetails;\n import org.mockito.internal.util.MockUtil;\n \n /**\n- * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n- * effectively a &ldquo;public&rdquo; version of {@link MockUtil}.\n+ * Class to inspect any object, and identify whether a particular object is either a mock or a spy.\n  */\n-public class MockingDetails {\n+public abstract class MockingDetails {\n     \n-    private Object toInspect;\n-    private MockUtil delegate;\n-\n-    MockingDetails( Object toInspect, MockUtil delegate ){\n-        this.toInspect = toInspect;\n-        this.delegate = delegate;\n-    }\n \n     /**\n      * Create a MockingDetails to inspect a particular Object.\n      * @return\n      */\n     public static MockingDetails of( Object toInspect ){\n-        return new MockingDetails( toInspect, new MockUtil());\n+        return new DefaultMockingDetails( toInspect, new MockUtil());\n     }\n \n     /**\n      * Find out whether the object is a mock.\n-     * @return whether the object is a mock.\n+     * @return true if the object is a mock or a spy.\n      */\n-    public boolean isMock(){\n-        return delegate.isMock( toInspect );\n-    }\n+    public abstract boolean isMock();\n \n     /**\n      * Find out whether the object is a spy.\n-     * @return whether the object is a spy.\n+     * @return true if the object is a spy.\n      */\n-    public boolean isSpy(){\n-        return delegate.isSpy( toInspect );\n-    }\n-\n-\n+    public abstract boolean isSpy();\n }\n \n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *     MockingDetails.of( someObject ).isMock();\n  *     MockingDetails.of( someObject ).isSpy();\n  * </code></pre>\n- * Both the <code>isMock()</code> and <code>isSpy()</code> methods return <code>boolean</code>.\n+ * Both the <code>isMock()</code> and <code>isSpy()</code> methods return <code>boolean</code>.  As a spy\n+ * is considered a special kind of mock, <code>isMock()</code> returns true if the object is a spy.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/DefaultMockingDetails.java\n+package org.mockito.internal.util;\n+\n+import org.mockito.MockingDetails;\n+\n+/**\n+ * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n+ * a wrapper for {@link org.mockito.internal.util.MockUtil}.\n+ */\n+public class DefaultMockingDetails extends MockingDetails {\n+\n+    private Object toInspect;\n+    private MockUtil delegate;\n+\n+    public DefaultMockingDetails(Object toInspect, MockUtil delegate){\n+        this.toInspect = toInspect;\n+        this.delegate = delegate;\n+    }\n+    /**\n+     * Find out whether the object is a mock.\n+     * @return true if the object is a mock or a spy.\n+     */\n+    public boolean isMock(){\n+        return delegate.isMock( toInspect );\n+    }\n+\n+    /**\n+     * Find out whether the object is a spy.\n+     * @return true if the object is a spy.\n+     */\n+    public boolean isSpy(){\n+        return delegate.isSpy( toInspect );\n+    }\n+}\n+\n--- a/test/org/mockito/MockingDetailsTest.java\n+++ b/test/org/mockito/MockingDetailsTest.java\n \n     @Mock TestClass mock1;\n     @Spy TestClass spy1;\n+    TestClass mock2;\n+    TestClass spy2;\n+    TestClass nonMock;\n     \n     @Before\n     public void setUp(){\n         initMocks( this );\n+        mock2 = mock( TestClass.class );\n+        spy2 = spy( new TestClass());\n+        nonMock = new TestClass();\n     }\n     \n     @Test\n \n     @Test\n     public void shouldReturnTrue_FromIsMock_ForDirectMock(){\n-        TestClass mock2 = mock( TestClass.class );\n         assertTrue(MockingDetails.of(mock2).isMock());\n     }\n \n     @Test\n+    public void shouldReturnTrue_FromIsMock_ForAnnotatedSpy(){\n+        assertTrue(MockingDetails.of(spy1).isMock());\n+    }\n+\n+    @Test\n+    public void shouldReturnTrue_FromIsMock_ForDirectSpy(){\n+\n+        assertTrue(MockingDetails.of(spy2).isMock());\n+    }\n+\n+    @Test\n     public void shouldReturnFalse_FromIsMock_ForNonMock(){\n-        TestClass nonMock = new TestClass();\n         assertFalse(MockingDetails.of(nonMock).isMock());\n     }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForAnnotatedMock(){\n+        assertFalse(MockingDetails.of(mock1).isSpy());\n+    }\n+\n+    @Test\n+    public void shouldReturnFalse_FromIsSpy_ForDirectMock(){\n+        assertFalse(MockingDetails.of(mock2).isSpy());\n+    }\n+\n \n     @Test\n     public void shouldReturnTrue_FromIsSpy_ForAnnotatedSpy(){\n \n     @Test\n     public void shouldReturnTrue_FromIsSpy_ForDirectSpy(){\n-        TestClass spy2 = spy( new TestClass());\n         assertTrue(MockingDetails.of(spy2).isSpy());\n     }\n \n     @Test\n-    public void shouldReturnFalse_FromIsSpy_ForNonSpy(){\n-        TestClass nonSpy = new TestClass();\n-        assertFalse(MockingDetails.of(nonSpy).isSpy());\n+    public void shouldReturnFalse_FromIsSpy_ForNonMock(){\n+        assertFalse(MockingDetails.of(nonMock).isSpy());\n     }\n }", "timestamp": 1333332333, "metainfo": ""}