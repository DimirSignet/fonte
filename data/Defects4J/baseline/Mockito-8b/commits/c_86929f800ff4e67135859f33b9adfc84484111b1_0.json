{"sha": "86929f800ff4e67135859f33b9adfc84484111b1", "log": "Fixed issue 122 In order to allow user to use single any() matcher for varargs I introduce anyVararg() matcher Unfortunately, it is not possible to use (Object[]) anyObject() to match any vararg due to the fact that verification picks up extra redundant invocations. Also it would have broken the backwards compatibility.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401617", "commit": "\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n import java.util.Set;\n \n import org.hamcrest.Matcher;\n-import org.mockito.internal.matchers.Any;\n-import org.mockito.internal.matchers.Contains;\n-import org.mockito.internal.matchers.EndsWith;\n-import org.mockito.internal.matchers.Equals;\n-import org.mockito.internal.matchers.InstanceOf;\n-import org.mockito.internal.matchers.Matches;\n-import org.mockito.internal.matchers.NotNull;\n-import org.mockito.internal.matchers.Null;\n-import org.mockito.internal.matchers.Same;\n-import org.mockito.internal.matchers.StartsWith;\n+import org.mockito.internal.matchers.*;\n import org.mockito.internal.matchers.apachecommons.ReflectionEquals;\n import org.mockito.internal.progress.HandyReturnValues;\n import org.mockito.internal.progress.MockingProgress;\n         return (T) reportMatcher(Any.ANY).returnNull();\n     }\n     //TODO: after 1.8 check out Jay Fields' idea on any() matcher\n+\n+    /**\n+     * an vararg\n+     * TODO: javadoc\n+     * <p>\n+     * See examples in javadoc for {@link Matchers} class\n+     *\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T anyVararg() {\n+        return (T) reportMatcher(AnyVararg.ANY_VARARG).returnNull();\n+    }\n     \n     /**\n      * any kind object, not necessary of the given class.\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/ArgumentsComparator.java\n+package org.mockito.internal.invocation;\n+\n+import org.hamcrest.Matcher;\n+import org.mockito.internal.matchers.MatcherDecorator;\n+import org.mockito.internal.matchers.VarargMatcher;\n+\n+import java.util.List;\n+\n+public class ArgumentsComparator {\n+    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n+        Object[] actualArgs = actual.getArguments();\n+        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);\n+    }\n+\n+    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {\n+        if (actualArgs.length != invocationMatcher.getMatchers().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < actualArgs.length; i++) {\n+            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //ok, this method is a little bit messy but the vararg business unfortunately is messy...  \n+    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n+        if (!actual.getMethod().isVarArgs()) {\n+            //if the method is not vararg forget about it\n+            return false;\n+        }\n+\n+        //we must use raw arguments, not arguments...\n+        Object[] rawArgs = actual.getRawArguments();\n+        List<Matcher> matchers = invocationMatcher.getMatchers();\n+\n+        if (rawArgs.length != matchers.size()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < rawArgs.length; i++) {\n+            Matcher m = matchers.get(i);\n+            //it's a vararg because it's the last array in the arg list\n+            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {\n+                Matcher actualMatcher;\n+                //this is necessary as the framework often decorates matchers\n+                if (m instanceof MatcherDecorator) {\n+                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n+                } else {\n+                    actualMatcher = m;\n+                }\n+                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n+                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n+                    return false;\n+                }\n+            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n+            } else if (!m.matches(rawArgs[i])){\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n                 && hasSameMethod(actual)\n-                && (argumentsMatch(actual.getArguments()));\n+                && new ArgumentsComparator().argumentsMatch(this, actual);\n     }\n \n-    private boolean argumentsMatch(Object[] actualArgs) {\n-        if (actualArgs.length != matchers.size()) {\n-            return false;\n-        }\n-        for (int i = 0; i < actualArgs.length; i++) {\n-            if (!matchers.get(i).matches(actualArgs[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-    \n     private boolean safelyArgumentsMatch(Object[] actualArgs) {\n         try {\n-            return argumentsMatch(actualArgs);\n+            return new ArgumentsComparator().argumentsMatch(this, actualArgs);\n         } catch (Throwable t) {\n             return false;\n         }\n         final boolean isUnverified = !candidate.isVerified();\n         final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n         final boolean methodEquals = hasSameMethod(candidate);\n-        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());        \n-        \n-        if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\n-            return true;\n-        }\n-        \n-        return false;\n+        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n+\n+        return methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs;\n+\n     }\n \n     public boolean hasSameMethod(Invocation candidate) {\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/AnyVararg.java\n+package org.mockito.internal.matchers;\n+\n+import org.hamcrest.Matcher;\n+import org.mockito.ArgumentMatcher;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AnyVararg extends ArgumentMatcher implements VarargMatcher {\n+\n+    public static final Matcher ANY_VARARG = new AnyVararg();\n+\n+    public boolean matches(Object arg) {\n+        return true;\n+    }\n+}\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments {\n+public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator {\n \n     private final Matcher actualMatcher;\n     private Location location;\n     }\n \n     public void _dont_implement_Matcher___instead_extend_BaseMatcher_() {\n-        // yeah right...\n+        // yeah right\n     }\n \n     public boolean matches(Object item) {\n     }\n \n     public boolean typeMatches(Object object) {\n-        if (actualMatcher instanceof ContainsExtraTypeInformation) {\n-            return ((ContainsExtraTypeInformation) actualMatcher).typeMatches(object);\n-        } else {\n-            return false;\n-        }\n+        return actualMatcher instanceof ContainsExtraTypeInformation\n+                && ((ContainsExtraTypeInformation) actualMatcher).typeMatches(object);\n     }\n \n     public void captureFrom(Object argument) {\n             ((CapturesArguments) actualMatcher).captureFrom(argument);\n         }\n     }\n+\n+    //TODO: refactor other 'delegated interfaces' to use the MatcherDecorator feature\n+    public Matcher getActualMatcher() {\n+        return actualMatcher;\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/MatcherDecorator.java\n+package org.mockito.internal.matchers;\n+\n+import org.hamcrest.Matcher;\n+\n+public interface MatcherDecorator {\n+    Matcher getActualMatcher();\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/VarargMatcher.java\n+package org.mockito.internal.matchers;\n+\n+public interface VarargMatcher {\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n+package org.mockito.internal.invocation;\n+\n+import org.mockitoutil.TestBase;\n+import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n+import org.mockito.Mock;\n+import org.mockitousage.IMethods;\n+\n+import java.util.List;\n+import static java.util.Arrays.asList;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ArgumentsComparatorTest extends TestBase {\n+\n+    @Mock IMethods mock;\n+    ArgumentsComparator comparator = new ArgumentsComparator();\n+    \n+    @Test\n+    public void shouldKnowWhenArgumentsMatch() {\n+        //given\n+        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"1\", 100).toInvocationMatcher();\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n+\n+    @Test\n+    public void shouldKnowWhenArgsDifferent() {\n+        //given\n+        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\", 100).toInvocationMatcher();\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldKnowWhenActualArgsSizeIsDifferent() {\n+        //given\n+        Invocation invocation = new InvocationBuilder().args(\"100\", 100).toInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\").toInvocationMatcher();\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldKnowWhenMatchersSizeIsDifferent() {\n+        //given\n+        Invocation invocation = new InvocationBuilder().args(\"100\").toInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\", 100).toInvocationMatcher();\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldKnowWhenVarargsMatch() {\n+        //given\n+        mock.varargs(\"1\", \"2\", \"3\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), Any.ANY, new InstanceOf(String.class)));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n+\n+    @Test\n+    public void shouldKnowWhenVarargsDifferent() {\n+        //given\n+        mock.varargs(\"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"100\"), Any.ANY));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldNotAllowAnyObjectMatchEntireVararg() {\n+        //given\n+        mock.varargs(\"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(Any.ANY));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldAllowAnyVarargMatchEntireVararg() {\n+        //given\n+        mock.varargs(\"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n+\n+    @Test\n+    public void shouldNotAllowAnyObjectWithMixedVarargs() {\n+        //given\n+        mock.mixedVarargs(1, \"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldAllowAnyObjectWithMixedVarargs() {\n+        //given\n+        mock.mixedVarargs(1, \"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), AnyVararg.ANY_VARARG));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n+\n+    @Test\n+    public void shouldNotMatchWhenSomeOtherArgumentDoesNotMatch() {\n+        //given\n+        mock.mixedVarargs(1, \"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(100), AnyVararg.ANY_VARARG));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs() {\n+        //given\n+        mock.mixedVarargs(1, \"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertFalse(match);\n+    }\n+\n+    @Test\n+    public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull() {\n+        //given\n+        mock.mixedVarargs(null, null, \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(null), AnyVararg.ANY_VARARG));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n+\n+    @Test\n+    public void shouldMatchAnyVarargEvenIfMatcherIsDecorated() {\n+        //given\n+        mock.varargs(\"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n+\n+        //when\n+        boolean match = comparator.argumentsMatch(invocationMatcher, invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static java.util.Arrays.*;\n-import static org.mockitoutil.ExtraMatchers.*;\n-\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n import org.hamcrest.Matcher;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n+import org.mockito.internal.matchers.AnyVararg;\n import org.mockito.internal.matchers.CapturingMatcher;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.NotNull;\n import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n import org.mockitousage.IMethods;\n+import static org.mockitoutil.ExtraMatchers.hasExactlyInOrder;\n import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+import static java.util.Arrays.asList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcherTest extends TestBase {\n         //given\n         Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         CapturingMatcher capturingMatcher = new CapturingMatcher();\n-        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) Arrays.asList(new Equals(\"1\"), capturingMatcher));        \n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), capturingMatcher));\n         \n         //when\n         invocationMatcher.captureArgumentsFrom(invocation);\n         assertEquals(1, capturingMatcher.getAllValues().size());\n         assertEquals(100, capturingMatcher.getLastValue());\n     }\n+\n+    @Test\n+    public void shouldMatchVarargsUsingAnyVarargs() throws Exception {\n+        //given\n+        mock.varargs(\"1\", \"2\");\n+        Invocation invocation = getLastInvocation();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));\n+\n+        //when\n+        boolean match = invocationMatcher.matches(invocation);\n+\n+        //then\n+        assertTrue(match);\n+    }\n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     \n     void varargs(String ... string);\n \n+    void mixedVarargs(Object i, String ... string);\n+\n     List<String> listReturningMethod(Object ... objects);\n     \n     LinkedList<String> linkedListReturningMethod();\n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n       \n     }\n \n+    public void mixedVarargs(Object i, String... string) {\n+    }\n+\n     public List<String> listReturningMethod(Object... objects) {\n         return null;\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/varargs/VarargsAndAnyObjectPicksUpExtraInvocationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs.varargs;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockitoutil.TestBase;\n+\n+public class VarargsAndAnyObjectPicksUpExtraInvocationsTest extends TestBase {\n+    public interface TableBuilder {\n+        void newRow(String trAttributes, String... cells);\n+    }\n+\n+    @Mock\n+    TableBuilder table;\n+\n+    @Test\n+    public void shouldVerifyCorrectlyWithAnyVarargs() {\n+        //when\n+        table.newRow(\"qux\", \"foo\", \"bar\", \"baz\");\n+        table.newRow(\"abc\", \"def\");\n+        \n+        //then\n+        verify(table, times(2)).newRow(anyString(), (String[]) anyVararg());\n+    }\n+\n+    @Test\n+    public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument() {\n+        //when\n+        table.newRow(\"x\", \"foo\", \"bar\", \"baz\");\n+        table.newRow(\"x\", \"def\");\n+\n+        //then\n+        verify(table, times(2)).newRow(eq(\"x\"), (String[]) anyVararg());\n+    }\n+\n+    @Test\n+    public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs() {\n+        //when\n+        table.newRow(\"qux\", \"foo\", \"bar\", \"baz\");\n+        table.newRow(\"abc\", \"def\");\n+        \n+        //then\n+        verify(table).newRow(anyString(), eq(\"foo\"), anyString(), anyString());\n+        verify(table).newRow(anyString(), anyString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyObjectTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.bugs.varargs;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockitoutil.TestBase;\n+\n+//see issue 62\n+public class VarargsNotPlayingWithAnyObjectTest extends TestBase {\n+\n+    interface VarargMethod {\n+        Object run(String... args);\n+    }\n+    \n+    @Mock VarargMethod mock;\n+\n+    @Test\n+    public void shouldMatchAnyVararg() {\n+        mock.run(\"a\", \"b\");\n+\n+        verify(mock).run(anyString(), anyString());\n+        verify(mock).run((String) anyObject(), (String) anyObject());\n+\n+        verify(mock).run((String[]) anyVararg());\n+        \n+        verify(mock, never()).run();\n+        verify(mock, never()).run(anyString(), eq(\"f\"));\n+    }\n+\n+    //we cannot use anyObject() for entire varargs because it makes the verification pick up extra invocations\n+    //see other tests in this package\n+    @Test\n+    public void shouldNotAllowUsingAnyObjectForVarArgs() {\n+        mock.run(\"a\", \"b\");\n+\n+        try {\n+            verify(mock).run((String[]) anyObject());\n+            fail();\n+        } catch (AssertionError e) {}\n+    }\n+\n+    @Test\n+    public void shouldStubUsingAnyVarargs() {\n+        when(mock.run((String[]) anyVararg())).thenReturn(\"foo\");\n+        \n+        assertEquals(\"foo\", mock.run(\"a\", \"b\"));\n+    }\n+}", "timestamp": 1255875442, "metainfo": ""}