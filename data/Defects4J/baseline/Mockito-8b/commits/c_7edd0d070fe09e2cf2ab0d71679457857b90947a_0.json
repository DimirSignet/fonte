{"sha": "7edd0d070fe09e2cf2ab0d71679457857b90947a", "log": "when number of invocations don't match, provided cause with stack trace to actual invocation  --HG-- rename : src/org/mockito/exceptions/UndesiredInvocation.java => src/org/mockito/exceptions/cause/UndesiredInvocation.java rename : src/org/mockito/exceptions/WantedDiffersFromActual.java => src/org/mockito/exceptions/cause/WantedDiffersFromActual.java rename : test/org/mockitousage/verification/NiceMessagesOnStrictOrderErrorsTest.java => test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java rename : test/org/mockitousage/verification/NiceMessagesWhenVerificationFailsTest.java => test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40146", "commit": "\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n \n import static org.mockito.exceptions.Strings.join;\n \n+import org.mockito.exceptions.cause.*;\n+\n /**\n  * All messages in one place makes it easier to tune and amend the text. \n- * Once exception messages are sorted we can inline that stuff.\n  */\n public class Exceptions {\n     \n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ));\n     }\n+    \n+    public static void tooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n+        TooLittleInvocations cause = null;\n+        if (lastActualInvocationStackTrace != null) {\n+            cause = new TooLittleInvocations(join(\"Too little invocations:\"));\n+            cause.setStackTrace(lastActualInvocationStackTrace.getStackTrace());\n+        }\n+        \n+        throw new NumberOfInvocationsError(join(\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);  \n+    }\n \n-    public static void noMoreInteractionsWanted(String unexpected, String message) {\n-        throw new VerificationError(join(\n-                message,\n-                \"Unexpected: \" + unexpected\n-        ));\n-    }\n-    \n     public static void noMoreInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n         UndesiredInvocation cause = buildCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n         throw new VerificationError(join(\"No more interactions wanted\"), cause);\n                 \"Should be something like that: verify(mock).doSomething()\"\n         ));\n     }\n-\n }\n--- a/src/org/mockito/exceptions/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/MockitoAssertionError.java\n     \n     public MockitoAssertionError(String message, Throwable cause) {\n         this(message);\n-        this.initCause(cause);\n-        \n-        CommonStackTraceRemover remover = new CommonStackTraceRemover();\n-        remover.remove(this, Arrays.asList(cause.getStackTrace()));\n+\n+        if (cause != null) {\n+            this.initCause(cause);\n+            CommonStackTraceRemover remover = new CommonStackTraceRemover();\n+            remover.remove(this, Arrays.asList(cause.getStackTrace()));\n+        }\n     }\n \n     public StackTraceElement[] getUnfilteredStackTrace() {\n--- a/src/org/mockito/exceptions/NumberOfInvocationsError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsError.java\n     public NumberOfInvocationsError(String message) {\n         super(message);\n     }\n+\n+    public NumberOfInvocationsError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/cause/TooLittleInvocations.java\n+package org.mockito.exceptions.cause;\n+\n+import org.mockito.exceptions.MockitoException;\n+\n+public class TooLittleInvocations extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public TooLittleInvocations(String message) {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/cause/UndesiredInvocation.java\n+package org.mockito.exceptions.cause;\n+\n+import org.mockito.exceptions.MockitoException;\n+\n+public class UndesiredInvocation extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public UndesiredInvocation(String message) {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/cause/WantedDiffersFromActual.java\n+package org.mockito.exceptions.cause;\n+\n+import org.mockito.exceptions.MockitoException;\n+\n+public class WantedDiffersFromActual extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public WantedDiffersFromActual(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     }\n \n     void checkForWrongNumberOfInvocations(ExpectedInvocation wanted, VerifyingMode mode) {\n-        if (mode.orderOfInvocationsMatters()) {\n+        if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n             return;\n         }\n         \n         int actualCount = registeredInvocations.countActual(wanted);\n         Integer wantedCount = mode.wantedCount();\n-        boolean atLeastOnce = mode.atLeastOnceMode();\n         \n-        if (!atLeastOnce && actualCount != wantedCount) {\n+        if (actualCount < wantedCount) {\n+            HasStackTrace lastInvocationStackTrace = registeredInvocations.getLastInvocationStackTrace(wanted);\n+            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocationStackTrace);\n+        } else if (actualCount > wantedCount) {\n+//            registeredInvocations.findFirstUndesiredInvocation(wanted, mode);\n             Exceptions.numberOfInvocationsDiffers(wantedCount, actualCount, wanted.toString());\n         }\n     }\n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n package org.mockito.internal;\n \n import java.util.*;\n+\n+import org.mockito.exceptions.HasStackTrace;\n \n public class RegisteredInvocations {\n     \n         }\n         return null;\n     }\n-}\n+\n+    public HasStackTrace getLastInvocationStackTrace(ExpectedInvocation wanted) {\n+        Invocation lastMatching = null;\n+        for (Invocation registered : registeredInvocations) {\n+            if (wanted.matches(registered)) {\n+                lastMatching = registered;\n+            }\n+        }\n+        return lastMatching != null ? lastMatching.getStackTrace() : null;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/exceptions/ExceptionsTest.java\n+package org.mockito.exceptions;\n+\n+import org.junit.Test;\n+\n+\n+public class ExceptionsTest {\n+\n+    @Test(expected=NumberOfInvocationsError.class)\n+    public void shouldLetPassingNullLastActualStackTrace() throws Exception {\n+        Exceptions.tooLittleActualInvocations(1, 2, \"wanted\", null);\n+    }\n+}\n--- a/test/org/mockito/exceptions/MockitoAssertionErrorTest.java\n+++ b/test/org/mockito/exceptions/MockitoAssertionErrorTest.java\n             assertEquals(\"throwIt\", e.getUnfilteredStackTrace()[0].getMethodName());\n         }\n     }\n+    \n+    @Test\n+    public void shouldNotInitCauseWhenCauseIsNull() {\n+        new MockitoAssertionError(\"test\", null);\n+    }\n }\n--- a/test/org/mockito/internal/MockitoBehaviorTest.java\n+++ b/test/org/mockito/internal/MockitoBehaviorTest.java\n         \n         behavior.checkForWrongNumberOfInvocations(invocation, inOrder);\n     }\n+    \n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n+        ExpectedInvocation invocation = new ExpectedInvocation(new InvocationBuilder().toInvocation());\n+        MockitoBehavior behavior = new MockitoBehavior();\n+        \n+        VerifyingMode inOrder = VerifyingMode.atLeastOnce();\n+        \n+        behavior.checkForWrongNumberOfInvocations(invocation, inOrder);\n+    }\n }\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n                     AtLeastOnceVerificationTest.class, \n                     BasicVerificationTest.class, \n                     ExactNumberOfTimesVerificationTest.class, \n-                    NiceMessagesWhenVerificationFailsTest.class, \n+                    DescriptiveMessagesWhenVerificationFailsTest.class, \n                     NoMoreInteractionsVerificationTest.class, \n                     VerificationInOrderMixedWithOrdiraryVerificationTest.class, \n                     VerificationInOrderTest.class, \n                     MockitoTest.class,\n                     InvalidUsageTest.class,\n                     InvalidUseOfMatchersTest.class,\n-                    NiceMessagesOnStrictOrderErrorsTest.class,\n+                    DescriptiveMessagesOnStrictOrderErrorsTest.class,\n                     InvalidStateDetectionTest.class,\n                     StackTrackeFilteringTest.class\n                 );\n--- /dev/null\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n+import org.mockito.util.RequiresValidState;\n+import org.mockitousage.IMethods;\n+\n+public class DescriptiveMessagesOnStrictOrderErrorsTest extends RequiresValidState {\n+    \n+    private IMethods one;\n+    private IMethods two;\n+    private IMethods three;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setup() {\n+        one = Mockito.mock(IMethods.class);\n+        two = Mockito.mock(IMethods.class);\n+        three = Mockito.mock(IMethods.class);\n+        \n+        one.simpleMethod(1);\n+        one.simpleMethod(11);\n+        two.simpleMethod(2);\n+        two.simpleMethod(2);\n+        three.simpleMethod();\n+        \n+        strictly = createStrictOrderVerifier(one, two, three);\n+    }\n+    \n+    @Test\n+    public void shouldPrintStrictVerificationError() {\n+        try {\n+            strictly.verify(one).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Strict order verification failed\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods.simpleMethod(999)\" + \n+            \t\t\"\\n\" +\n+            \t\t\"Actual: IMethods.simpleMethod(1)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintWantedMethodWhenEverythingElseIsVerified() {\n+        strictly.verify(one).simpleMethod(1);\n+        strictly.verify(one).simpleMethod(11);\n+        strictly.verify(two, 2).simpleMethod(2);\n+        strictly.verify(three).simpleMethod();\n+        try {\n+            strictly.verify(three).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(999)\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPrintWrongNumberOfInvocations() {\n+        strictly.verify(one).simpleMethod(1);\n+        strictly.verify(one).simpleMethod(11);\n+        try {\n+            strictly.verify(two, 1).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 1 time but was 2\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintSequenceNumberWhenMocksAndMethodsAreTheSame() {\n+        StateResetter.reset();\n+        one = mock(IMethods.class);\n+        two = mock(IMethods.class);\n+        \n+        one.simpleMethod();\n+        two.simpleMethod();\n+        \n+        strictly = createStrictOrderVerifier(one, two);\n+        \n+        try {\n+            strictly.verify(two).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +    \n+                    \"Strict order verification failed\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods#3.simpleMethod()\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods#1.simpleMethod()\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+import static org.mockito.CrazyMatchers.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.*;\n+import org.mockito.exceptions.cause.*;\n+import org.mockito.util.RequiresValidState;\n+import org.mockitousage.IMethods;\n+\n+public class DescriptiveMessagesWhenVerificationFailsTest extends RequiresValidState {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodName() {\n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"Wanted but not invoked:\" +\n+            \t\t\"\\n\" +\n+            \t\t\"IMethods.simpleMethod()\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    private class SomeClass {\n+        public String toString() {\n+            return \"SomeClass instance\";\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodNameAndArguments() {\n+        try {\n+            verify(mock).threeArgumentMethod(12, new SomeClass(), \"xx\");\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.threeArgumentMethod(12, SomeClass instance, \\\"xx\\\")\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintActualAndWantedWhenTheDifferenceIsAboutArguments() {\n+        mock.oneArg(true);\n+        mock.twoArgumentMethod(1, 2);\n+        \n+        verify(mock).oneArg(true);\n+        try {\n+            verify(mock).twoArgumentMethod(1, 1000);\n+            fail();\n+        } catch (VerificationError e) {\n+            String expected = \n+                    \"\\n\" +\n+                    \"Invocation differs from actual\" +\n+                    \"\\n\" +\n+                    \"Wanted invocation:\" +\n+                    \"\\n\" +\n+                    \"IMethods.twoArgumentMethod(1, 1000)\";\n+            \n+            assertEquals(expected, e.getMessage());\n+            \n+            assertEquals(e.getCause().getClass(), WantedDiffersFromActual.class);\n+            \n+            String expectedCause =\n+                    \"\\n\" +\n+                    \"Actual invocation:\" +\n+                    \"\\n\" +\n+                    \"IMethods.twoArgumentMethod(1, 2)\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());      \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintActualAndWantedWhenActualMethodNameAndWantedMethodNameAreTheSame() {\n+        mock.simpleMethod();\n+        \n+        try {\n+            verify(mock).simpleMethod(\"test\");\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.simpleMethod(\\\"test\\\")\"));\n+            assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n+        }\n+    }    \n+    \n+    @Test\n+    public void shouldTreatFirstUnverifiedInvocationAsActualInvocation() {\n+        mock.oneArg(true);\n+        mock.simpleMethod();\n+        mock.differentMethod();\n+        mock.twoArgumentMethod(1, 2);\n+        \n+        try {\n+            verify(mock).oneArg(true);\n+            verify(mock).differentMethod();\n+            verify(mock).threeArgumentMethod(1, \"2\", \"3\");\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.threeArgumentMethod(1, \\\"2\\\", \\\"3\\\")\"));\n+            assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments() {\n+        mock.twoArgumentMethod(1, 1);\n+        mock.twoArgumentMethod(2, 2);\n+        mock.twoArgumentMethod(3, 3);\n+        \n+        verify(mock).twoArgumentMethod(1, 1);\n+        verify(mock).twoArgumentMethod(2, 2);\n+        try {\n+            verify(mock).twoArgumentMethod(3, 1000);\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.twoArgumentMethod(3, 1000)\"));\n+            assertThat(e, causeMessageContains(\"IMethods.twoArgumentMethod(3, 3)\"));\n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintFirstUnexpectedInvocation() {\n+        mock.oneArg(true);\n+        mock.oneArg(false);\n+        mock.threeArgumentMethod(1, \"2\", \"3\");\n+        \n+        verify(mock).oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError e) {\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"No more interactions wanted\";\n+            assertEquals(expectedMessage, e.getMessage());         \n+\n+            assertEquals(e.getCause().getClass(), UndesiredInvocation.class);\n+            \n+            String expectedCause =\n+            \t\t\"\\n\" +\n+            \t\t\"Undesired invocation:\" +\n+            \t\t\"\\n\" +\n+            \t\t\"IMethods.oneArg(false)\";\n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintFirstUnexpectedInvocationWhenVerifyingZeroInteractions() {\n+        mock.twoArgumentMethod(1, 2);\n+        mock.threeArgumentMethod(1, \"2\", \"3\");\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (VerificationError e) {\n+            String expected = \n+                    \"\\n\" +\n+                    \"Zero interactions wanted\";\n+\n+            assertEquals(e.getMessage(), expected);\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Undesired invocation:\" +\n+                \"\\n\" +\n+                \"IMethods.twoArgumentMethod(1, 2)\";\n+            \n+            assertEquals(e.getCause().getMessage(), expectedCause);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodNameWhenVerifyingAtLeastOnce() throws Exception {\n+        try {\n+            verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.twoArgumentMethod(1, 2)\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodWhenMatcherUsed() throws Exception {\n+        try {\n+            verify(mock, atLeastOnce()).twoArgumentMethod(anyInt(), eq(100));\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                \"\\n\" +\n+                \"Wanted but not invoked:\" +\n+                \"\\n\" +\n+                \"IMethods.twoArgumentMethod(<any>, 100)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodWhenMissingInvocationWithArrayMatcher() {\n+        mock.oneArray(new boolean[] { true, false, false });\n+        \n+        try {\n+            verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.oneArray([false, false, false])\"));\n+            assertThat(e, causeMessageContains(\"IMethods.oneArray([true, false, false])\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodWhenMissingInvocationWithVarargMatcher() {\n+        mock.varargsString(10, \"one\", \"two\");\n+        \n+        try {\n+            verify(mock).varargsString(10, \"two\", \"one\");\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.varargsString(10, \\\"two\\\", \\\"one\\\")\"));\n+            assertThat(e, causeMessageContains(\"IMethods.varargsString(10, \\\"one\\\", \\\"two\\\")\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodWhenMissingInvocationWithMatcher() {\n+        mock.simpleMethod(\"foo\");\n+        \n+        try {\n+            verify(mock).simpleMethod(matches(\"burrito\"));\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, messageContains(\"IMethods.simpleMethod(matches(\\\"burrito\\\"))\"));\n+            assertThat(e, causeMessageContains(\"IMethods.simpleMethod(\\\"foo\\\")\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintNullArguments() throws Exception {\n+        mock.simpleMethod(null, null);\n+        try {\n+            verify(mock).simpleMethod(\"test\");\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, causeMessageContains(\"simpleMethod(null, null)\"));\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n+import static org.mockito.util.ExtraMatchers.*;\n import static org.junit.Assert.*;\n \n import java.util.LinkedList;\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.NumberOfInvocationsError;\n+import org.mockito.exceptions.*;\n+import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.util.RequiresValidState;\n \n @SuppressWarnings(\"unchecked\")\n         \t\t\"\\n\" +\n         \t\t\"Wanted 100 times but was 3\";\n             assertEquals(expected, e.getMessage());\n+            \n+            assertEquals(TooLittleInvocations.class, e.getCause().getClass());\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Too little invocations:\";\n+            assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n     \n             Mockito.verify(mock, 15).clear();\n             fail();\n         } catch (NumberOfInvocationsError e) {\n-            assertTrue(e.getMessage().endsWith(\"Wanted 15 times but was 0\"));\n+            assertThat(e, messageContains(\"Wanted 15 times but was 0\"));\n         }\n     }\n     \n             Mockito.verify(mock, 15).clear();\n             fail();\n         } catch (NumberOfInvocationsError e) {\n-            assertTrue(e.getMessage().endsWith(\"Wanted 15 times but was 1\"));\n+            assertThat(e, messageContains(\"Wanted 15 times but was 1\"));\n         }\n     }\n     \n         try {\n             Mockito.verify(mock, 0).clear();\n             fail();\n-        } catch (NumberOfInvocationsError e) {}\n+        } catch (NumberOfInvocationsError e) {\n+            assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n+        }\n     }\n     \n     @Test", "timestamp": 1197216811, "metainfo": ""}