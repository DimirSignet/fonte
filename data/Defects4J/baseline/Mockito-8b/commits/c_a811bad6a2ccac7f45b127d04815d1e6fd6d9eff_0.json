{"sha": "a811bad6a2ccac7f45b127d04815d1e6fd6d9eff", "log": "Made DeepStubsSerializableTest pass - unfortunately GenericMetadataSupportTest fails", "commit": "\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n @Incubating\n public abstract class GenericMetadataSupport implements Serializable {\n \n+\n     // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n     /**\n         for (int i = 0; i < actualTypeArguments.length; i++) {\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n+            SerializableTypeVariable serializableTypeVariable = new SerializableTypeVariable(typeParameter);\n \n             if (actualTypeArgument instanceof WildcardType) {\n-                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n+                contextualActualTypeParameters.put(serializableTypeVariable, boundsOf((WildcardType) actualTypeArgument));\n+            } else if (actualTypeArgument instanceof ParameterizedType) {\n+                contextualActualTypeParameters.put(serializableTypeVariable, new SerializableParameterizedType((ParameterizedType) actualTypeArgument));\n             } else {\n-                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n+                contextualActualTypeParameters.put(serializableTypeVariable, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n         for (TypeVariable typeParameter : typeParameters) {\n-            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n+            contextualActualTypeParameters.put(new SerializableTypeVariable(typeParameter), boundsOf(typeParameter));\n             // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n         }\n     }\n         if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n             return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n         }\n-        return new TypeVarBoundedType(typeParameter);\n+        return new SerializableBoundedType(new TypeVarBoundedType(typeParameter));\n     }\n \n     /**\n             return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n         }\n \n-        return wildCardBoundedType;\n+        return new SerializableBoundedType(wildCardBoundedType);\n     }\n \n \n \n             Type actualType = getActualTypeArgumentFor(typeParameter);\n \n-            actualTypeArguments.put(typeParameter, actualType);\n+            actualTypeArguments.put(new SerializableTypeVariable(typeParameter), actualType);\n             // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n         }\n \n         }\n     }\n \n-\n     /**\n      * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n      *\n         private final TypeVariable[] typeParameters;\n \n         public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n-            this.parameterizedType = parameterizedType;\n-            this.typeParameters = typeParameters;\n+            this.parameterizedType = new SerializableParameterizedType(parameterizedType);\n+            this.typeParameters = fromArray(typeParameters);\n             this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n \n             readTypeParameters();\n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class TypeVarBoundedType implements BoundedType {\n+    public static class TypeVarBoundedType implements BoundedType, Serializable {\n         private TypeVariable typeVariable;\n \n \n         public TypeVarBoundedType(TypeVariable typeVariable) {\n-            this.typeVariable = typeVariable;\n+            this.typeVariable = new SerializableTypeVariable(typeVariable);\n         }\n \n         /**\n         }\n     }\n \n+    private static class SerializableBound implements Type, Serializable {\n+\n+        private Class classBound;\n+\n+        private SerializableParameterizedType serializableParameterizedType;\n+\n+        public SerializableBound(Type type){\n+            if(type instanceof Class){\n+                classBound = (Class) type;\n+            } else if(type instanceof ParameterizedType) {\n+                serializableParameterizedType = new SerializableParameterizedType((ParameterizedType) type);\n+            }\n+        }\n+\n+    }\n+\n+\n+    private static class SerializableTypeVariable implements TypeVariable, Serializable {\n+\n+        private Class genericDeclaration;\n+        private String name;\n+        private SerializableBound[] bounds;\n+\n+        public SerializableTypeVariable(TypeVariable typeVariable){\n+            this.genericDeclaration = (Class) typeVariable.getGenericDeclaration();\n+            this.name = typeVariable.getName();\n+            this.bounds = convertToSerializableArray(typeVariable);\n+        }\n+\n+        @Override\n+        public Type[] getBounds() {\n+            return bounds;\n+        }\n+\n+        @Override\n+        public GenericDeclaration getGenericDeclaration() {\n+            return genericDeclaration;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+    }\n+\n+    private static SerializableBound[] convertToSerializableArray(TypeVariable typeVariable) {\n+        SerializableBound[] bounds = new SerializableBound[typeVariable.getBounds().length];\n+        for (int i = 0; i < typeVariable.getBounds().length; i++) {\n+            bounds[i] =  new SerializableBound(typeVariable.getBounds()[i]);\n+        }\n+        return bounds;\n+    }\n+    private static SerializableBound[] convertToSerializableArray(BoundedType boundedType) {\n+        SerializableBound[] bounds = new SerializableBound[boundedType.interfaceBounds().length];\n+        for (int i = 0; i < boundedType.interfaceBounds().length; i++) {\n+            bounds[i] =  new SerializableBound(boundedType.interfaceBounds()[i]);\n+        }\n+        return bounds;\n+    }\n+\n+    private static <T> Class[] fromArrayToArrayOfClass(T[] objects) {\n+        Class[] elements = new Class[objects.length];\n+        for (int i = 0; i < objects.length; i++) {\n+            elements[i] = objects[i].getClass();\n+        }\n+        return elements;\n+    }\n+\n+    private static SerializableTypeVariable[] fromArray(TypeVariable[] typeVariables){\n+        SerializableTypeVariable[] serializableTypeVariables = new SerializableTypeVariable[typeVariables.length];\n+        for (int i = 0; i < typeVariables.length; i++) {\n+            serializableTypeVariables[i] = new SerializableTypeVariable(typeVariables[i]);\n+        }\n+        return serializableTypeVariables;\n+    }\n+\n+    private static class SerializableParameterizedType implements ParameterizedType, Serializable {\n+\n+        private final Class[] actualTypeArguments;\n+\n+        private final Class rawType;\n+\n+        private final Class ownerType;\n+\n+        public SerializableParameterizedType(ParameterizedType parameterizedType){\n+            actualTypeArguments = fromArrayToArrayOfClass(parameterizedType.getActualTypeArguments());\n+            rawType = (Class) parameterizedType.getRawType();\n+            ownerType = (Class) parameterizedType.getOwnerType();\n+        }\n+\n+        @Override\n+        public Type[] getActualTypeArguments() {\n+            return actualTypeArguments;\n+        }\n+\n+        @Override\n+        public Type getRawType() {\n+            return rawType;\n+        }\n+\n+        @Override\n+        public Type getOwnerType() {\n+            return ownerType;\n+        }\n+    }\n+\n+    private static class SerializableBoundedType implements BoundedType, Serializable {\n+\n+        private final SerializableBound firstBound;\n+\n+        private final SerializableBound[] interfaceBounds;\n+\n+        private SerializableBoundedType(BoundedType boundedType) {\n+            this.firstBound = new SerializableBound(boundedType.firstBound());\n+            this.interfaceBounds = convertToSerializableArray(boundedType);\n+        }\n+\n+        @Override\n+        public Type firstBound() {\n+            return firstBound;\n+        }\n+\n+        @Override\n+        public Type[] interfaceBounds() {\n+            return interfaceBounds;\n+        }\n+    }\n+\n }\n \n \n--- a/test/org/mockitousage/stubbing/DeepStubsSerializableTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubsSerializableTest.java\n     }\n \n \t@Test\n-\t@Ignore\n \tpublic void should_serialize_and_deserialize_map_mocked_by_deep_stubs() throws Exception {\n \t\t// given\n \t\tMap map = Mockito.mock(Map.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());", "timestamp": 1394496004, "metainfo": ""}