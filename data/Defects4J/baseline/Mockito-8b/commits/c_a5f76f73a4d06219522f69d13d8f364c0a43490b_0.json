{"sha": "a5f76f73a4d06219522f69d13d8f364c0a43490b", "log": "Merge pull request #13 from MariusVolkhart/removeMercurialLeftovers  Remove old Hg artifacts", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockito.stubbing.*;\n+import org.mockito.verification.After;\n import org.mockito.verification.Timeout;\n+import org.mockito.verification.VerificationAfterDelay;\n import org.mockito.verification.VerificationMode;\n import org.mockito.verification.VerificationWithTimeout;\n \n     \n     /**\n      * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n-     * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent\n+     * interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent\n      * conditions.\n+     * <p>\n+     * This differs from {@link Mockito#after after()} in that after() will wait the full period, unless\n+     * the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon\n+     * as verification passes, producing different behaviour when used with times(2), for example, which can pass \n+     * and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until\n+     * times(2) failed, and then fail.\n      * <p>\n      * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n      * <p>\n      *   //above is an alias to:\n      *   verify(mock, timeout(100).times(1)).someMethod();\n      *   \n-     *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n+     *   //passes as soon as someMethod() has been called 2 times before the given timeout\n      *   verify(mock, timeout(100).times(2)).someMethod();\n      *\n-     *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n+     *   //equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout\n      *   verify(mock, timeout(100).atLeast(2)).someMethod();\n      *   \n      *   //verifies someMethod() within given time span using given verification mode\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n-     * @param millis - time span in millisecond\n+     * @param millis - time span in milliseconds\n      * \n      * @return verification mode\n      */\n     public static VerificationWithTimeout timeout(int millis) {\n         return new Timeout(millis, VerificationModeFactory.times(1));\n-    }       \n+    }\n+    \n+    /**\n+     * Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired\n+     * interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent\n+     * conditions.\n+     * <p>\n+     * This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout() \n+     * will stop early as soon as verification passes, producing different behaviour when used with times(2), for example,\n+     * which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would\n+     * run the full time, which point it will fail, as times(2) has failed.\n+     * <p>\n+     * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n+     * <p>\n+     * Not yet implemented to work with InOrder verification.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   //passes after 100ms, if someMethod() has only been called once at that time. \n+     *   verify(mock, after(100)).someMethod();\n+     *   //above is an alias to:\n+     *   verify(mock, after(100).times(1)).someMethod();\n+     *   \n+     *   //passes if someMethod() is called <b>*exactly*</b> 2 times after the given timespan\n+     *   verify(mock, after(100).times(2)).someMethod();\n+     *\n+     *   //passes if someMethod() has not been called after the given timespan\n+     *   verify(mock, after(100).never()).someMethod();\n+     *   \n+     *   //verifies someMethod() after a given time span using given verification mode\n+     *   //useful only if you have your own custom verification modes.\n+     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();\n+     * </code></pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param millis - time span in milliseconds\n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationAfterDelay after(int millis) {\n+        return new After(millis, VerificationModeFactory.times(1));\n+    }\n     \n     /**\n      * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n      * <p>\n      * Examples of incorrect use:\n      * <pre class=\"code\"><code class=\"java\">\n-     * //Oups, someone forgot thenReturn() part:\n+     * //Oops, someone forgot thenReturn() part:\n      * when(mock.get());\n      * \n-     * //Oups, someone put the verified method call inside verify() where it should be outside:\n+     * //Oops, someone put the verified method call inside verify() where it should be outside:\n      * verify(mock.execute());\n      * \n-     * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:\n+     * //Oops, someone has used EasyMock for too long and forgot to specify the method to verify:\n      * verify(mock);\n      * </code></pre>\n      * \n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"\"), details);\n     }\n \n-    public void atMostShouldNotBeUsedWithTimeout() {\n+    public void atMostAndNeverShouldNotBeUsedWithTimeout() {\n         throw new FriendlyReminderException(join(\"\",\n                 \"Don't panic! I'm just a friendly reminder!\",\n-                \"timeout() should not be used with atMost() because...\",\n+                \"timeout() should not be used with atMost() or never() because...\",\n                 \"...it does not make much sense - the test would have passed immediately in concurency\",\n                 \"We kept this method only to avoid compilation errors when upgrading Mockito.\",\n                 \"In future release we will remove timeout(x).atMost(y) from the API.\",\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.verification.VerificationMode;\n+\n+/**\n+ * Verifies that another verification mode (the delegate) is satisfied within a certain timeframe\n+ * (before timeoutMillis has passed, measured from the call to verify()), and either returns immediately\n+ * once it does, or waits until it is definitely satisfied once the full time has passed.\n+ */\n+public class VerificationOverTimeImpl implements VerificationMode {\n+\n+    private final int pollingPeriodMillis;\n+    private final int durationMillis;\n+    private final VerificationMode delegate;\n+    private final boolean returnOnSuccess;\n+    \n+    /**\n+     * Create this verification mode, to be used to verify invocation ongoing data later.\n+     *\n+     * @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied\n+     * @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied\n+     * @param delegate The verification mode to delegate overall success or failure to\n+     * @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in\n+     *                        {@link org.mockito.verification.VerificationWithTimeout}, or to only return once\n+     *                        the delegate is satisfied and the full duration has passed (as in\n+     *                        {@link org.mockito.verification.VerificationAfterDelay}).\n+     */\n+    public VerificationOverTimeImpl(int pollingPeriodMillis, int durationMillis, VerificationMode delegate, boolean returnOnSuccess) {\n+        this.pollingPeriodMillis = pollingPeriodMillis;\n+        this.durationMillis = durationMillis;\n+        this.delegate = delegate;\n+        this.returnOnSuccess = returnOnSuccess;\n+    }\n+\n+    /**\n+     * Verify the given ongoing verification data, and confirm that it satisfies the delegate verification mode\n+     * before the full duration has passed.\n+     *\n+     * In practice, this polls the delegate verification mode until it is satisfied. If it is not satisfied once\n+     * the full duration has passed, the last error returned by the delegate verification mode will be thrown\n+     * here in turn. This may be thrown early if the delegate is unsatisfied and the verification mode is known\n+     * to never recover from this situation (e.g. {@link AtMost}).\n+     *\n+     * If it is satisfied before the full duration has passed, behaviour is dependent on the returnOnSuccess parameter\n+     * given in the constructor. If true, this verification mode is immediately satisfied once the delegate is. If\n+     * false, this verification mode is not satisfied until the delegate is satisfied and the full time has passed.\n+     *\n+     * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n+     */\n+    public void verify(VerificationData data) {\n+        MockitoAssertionError error = null;\n+        \n+        long startTime = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - startTime <= durationMillis) {\n+            try {\n+                delegate.verify(data);\n+                \n+                if (returnOnSuccess) {\n+                    return;\n+                } else {\n+                    error = null;\n+                }\n+            } catch (MockitoAssertionError e) {\n+                if (canRecoverFromFailure(delegate)) {\n+                    error = e;\n+                    sleep(pollingPeriodMillis);\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        }\n+        \n+        if (error != null) {\n+            throw error;\n+        }\n+    }\n+\n+    protected boolean canRecoverFromFailure(VerificationMode verificationMode) {\n+        return !(verificationMode instanceof AtMost || verificationMode instanceof NoMoreInteractions);\n+    }\n+\n+    private void sleep(int sleep) {\n+        try {\n+            Thread.sleep(sleep);\n+        } catch (InterruptedException ie) {\n+            // oups. not much luck.\n+        }\n+    }\n+    \n+    public int getPollingPeriod() {\n+        return pollingPeriodMillis;\n+    }\n+    \n+    public int getDuration() {\n+        return durationMillis;\n+    }\n+    \n+    public VerificationMode getDelegate() {\n+        return delegate;\n+    }\n+    \n+}\n--- a/src/org/mockito/stubbing/Answer.java\n+++ b/src/org/mockito/stubbing/Answer.java\n  *     Object answer(InvocationOnMock invocation) {\n  *         Object[] args = invocation.getArguments();\n  *         Object mock = invocation.getMock();\n- *         return \"called with arguments: \" + args;\n+ *         return \"called with arguments: \" + Arrays.toString(args);\n  *     }\n  * });\n  * \n- * //Following prints \"called with arguments: foo\"\n+ * //Following prints \"called with arguments: [foo]\"\n  * System.out.println(mock.someMethod(\"foo\"));\n  * </code></pre>\n  * \n--- /dev/null\n+++ b/src/org/mockito/verification/After.java\n+package org.mockito.verification;\n+\n+import org.mockito.internal.verification.VerificationOverTimeImpl;\n+\n+/**\n+ * See the javadoc for {@link VerificationAfterDelay}\n+ * <p>\n+ * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n+ * See javadoc for {@link VerificationWithTimeout}\n+ */  \n+public class After extends VerificationWrapper<VerificationOverTimeImpl> implements VerificationAfterDelay {\n+    \n+    /**\n+     * See the javadoc for {@link VerificationAfterDelay}\n+     * <p>\n+     * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n+     * See javadoc for {@link VerificationWithTimeout}\n+     */\n+    public After(int delayMillis, VerificationMode verificationMode) {\n+        this(10, delayMillis, verificationMode);\n+    }\n+    \n+    public After(int pollingPeriod, int delayMillis, VerificationMode verificationMode) {\n+        super(new VerificationOverTimeImpl(pollingPeriod, delayMillis, verificationMode, false));\n+    }\n+    \n+    @Override\n+    protected VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode) {\n+        return new After(wrappedVerification.getPollingPeriod(), wrappedVerification.getDuration(), verificationMode);\n+    }\n+\n+}\n--- a/src/org/mockito/verification/Timeout.java\n+++ b/src/org/mockito/verification/Timeout.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.verification;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.misusing.FriendlyReminderException;\n-import org.mockito.internal.verification.VerificationModeFactory;\n-import org.mockito.internal.verification.VerificationWithTimeoutImpl;\n-import org.mockito.internal.verification.api.VerificationData;\n-\n+import org.mockito.internal.verification.VerificationOverTimeImpl;\n /**\n  * See the javadoc for {@link VerificationWithTimeout}\n  * <p>\n  * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n  * See javadoc for {@link VerificationWithTimeout}\n  */\n-public class Timeout implements VerificationWithTimeout {\n-\n-    VerificationWithTimeoutImpl impl;\n-\n+public class Timeout extends VerificationWrapper<VerificationOverTimeImpl> implements VerificationWithTimeout {\n+    \n     /**\n      * See the javadoc for {@link VerificationWithTimeout}\n      * <p>\n     /**\n      * See the javadoc for {@link VerificationWithTimeout}\n      */\n-    Timeout(int treshhold, int millis, VerificationMode delegate) {\n-        this.impl = new VerificationWithTimeoutImpl(treshhold, millis, delegate);\n+    Timeout(int pollingPeriodMillis, int millis, VerificationMode delegate) {\n+        super(new VerificationOverTimeImpl(pollingPeriodMillis, millis, delegate, true));\n     }\n-\n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n-    public void verify(VerificationData data) {\n-        impl.verify(data);\n+    \n+    @Override\n+    protected VerificationMode copySelfWithNewVerificationMode(VerificationMode newVerificationMode) {\n+        return new Timeout(wrappedVerification.getPollingPeriod(), wrappedVerification.getDuration(), newVerificationMode);\n     }\n-\n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n-    public VerificationMode atLeast(int minNumberOfInvocations) {\n-        return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeast(minNumberOfInvocations));\n-    }\n-\n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n-    public VerificationMode atLeastOnce() {\n-        return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeastOnce());\n-    }\n-\n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n+    \n     public VerificationMode atMost(int maxNumberOfInvocations) {\n-        new Reporter().atMostShouldNotBeUsedWithTimeout();\n+        new Reporter().atMostAndNeverShouldNotBeUsedWithTimeout();\n         return null;\n     }\n \n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n     public VerificationMode never() {\n-        return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(0));\n+        new Reporter().atMostAndNeverShouldNotBeUsedWithTimeout();\n+        return null;\n     }\n \n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n-    public VerificationMode only() {\n-        return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.only());\n-    }\n-\n-    /**\n-     * See the javadoc for {@link VerificationWithTimeout}\n-     */\n-    public VerificationMode times(int wantedNumberOfInvocations) {\n-        return new Timeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(wantedNumberOfInvocations));\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/verification/VerificationAfterDelay.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.verification;\n+\n+import org.mockito.Mockito;\n+\n+\n+/**\n+ * VerificationAfterDelay is a {@link VerificationMode} that allows combining existing verification modes with an initial delay, e.g. \n+ * <pre class=\"code\"><code class=\"java\">\n+ * verify(mock, after(100).atMost(5)).foo();\n+ * \n+ * verify(mock, after(100).never()).bar();\n+ * \n+ * verify(mock, after(200).atLeastOnce()).baz();\n+ * </code></pre>\n+ * \n+ * This is similar to {@link VerificationWithTimeout timeout()} except the assertion will not terminate until either the condition is \n+ * definitively failed, or the full time has elapsed (whereas timeout() will also stop if the conditions is true at any point, as is\n+ * typically the case with never() etc initially). \n+ * \n+ * <p>\n+ * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n+ *\n+ */\n+public interface VerificationAfterDelay extends VerificationMode {\n+    \n+    /**\n+     * Verifies that there are exactly N invocations during the given period. This will wait the full period given.\n+     */\n+    public VerificationMode times(int wantedNumberOfInvocations);\n+\n+    /**\n+     * Allows verification that there are no invocations at any point during the given period. This will wait the \n+     * full period given, unless an invocation occurs (in which case there will be immediate failure)\n+     */\n+    public VerificationMode never();\n+    \n+    /**\n+     * Verifies that there is at least 1 invocation during the given period. This will wait the full period given.\n+     */\n+    public VerificationMode atLeastOnce();\n+    \n+    /**\n+     * Verifies that there is are least N invocations during the given period. This will wait the full period given.\n+     */\n+    public VerificationMode atLeast(int minNumberOfInvocations);\n+    \n+    /**\n+     * Verifies that there is are most N invocations during the given period. This will wait the full period given,\n+     * unless too many invocations occur (in which case there will be an immediate failure)\n+     */\n+    public VerificationMode atMost(int maxNumberOfInvocations);\n+    \n+    /**\n+     * Verifies that there the given method is invoked and is the only method invoked. This will wait the full \n+     * period given, unless another method is invoked (in which case there will be an immediate failure)\n+     */\n+    public VerificationMode only();\n+    \n+}\n--- a/src/org/mockito/verification/VerificationWithTimeout.java\n+++ b/src/org/mockito/verification/VerificationWithTimeout.java\n  * \n  * verify(mock, timeout(200).atLeastOnce()).baz();\n  * </code></pre>\n+ * \n+ * This is similar to {@link VerificationAfterDelay after()} except this assertion will immediately pass if it becomes true at any point,\n+ * whereas after() will wait the full period. Assertions which are consistently expected to be initially true and potentially become false \n+ * are deprecated below, and after() should be used instead.\n  * \n  * <p>\n  * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n     public VerificationMode times(int wantedNumberOfInvocations);\n     \n     /**\n-     * Alias to times(0), see {@link #times(int)}\n+     * @deprecated\n+     * Validation with timeout combined with never simply does not make sense, as never() will typically immediately pass,\n+     * and therefore not wait the timeout. The behaviour you may be looking for is actually provided by after().never(). \n      * <p>\n-     * Verifies that interaction did not happen within given timeout. E.g:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   verify(mock, timeout(100).never()).someMethod();\n-     * </code></pre>\n-     * \n+     * To avoid compilation errors upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n      * <p>\n-     * If you want to verify there were NO interactions with the mock \n-     * check out {@link Mockito#verifyNoMoreInteractions(Object...)}\n+     * In a future release we will remove timeout(x).atMost(y) and timeout(x).never() from the API.\n      * <p>\n-     * See examples in javadoc for {@link Mockito} class\n+     * Do you want to find out more? See <a href=\"http://code.google.com/p/mockito/issues/detail?id=235\">issue 235</a>\n      * \n      * @return verification mode\n      */\n+    @Deprecated    \n     public VerificationMode never();\n     \n     /**\n-     * Allows at-least-once verification withing given timeout. E.g:\n+     * Allows at-least-once verification within given timeout. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, timeout(100).atLeastOnce()).someMethod(\"some arg\");\n      * </code></pre>\n     public VerificationMode atLeastOnce();\n \n     /**\n-     * Allows at-least-x verification withing given timeout. E.g:\n+     * Allows at-least-x verification within given timeout. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, timeout(100).atLeast(3)).someMethod(\"some arg\");\n      * </code></pre>\n      * @deprecated\n      *\n      * <b>Deprecated</b>\n-     * validation with timeout combined with atMost simply does not make sense...\n-     * The test would have passed immediately in the concurrent environment\n+     * Validation with timeout combined with never simply does not make sense, as atMost() will typically immediately pass,\n+     * and therefore not wait the timeout. The behaviour you may be looking for is actually provided by after().atMost(). \n      * <p>\n-     * To avoid compilation erros upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n+     * To avoid compilation errors upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n      * <p>\n-     * In future release we will remove timeout(x).atMost(y) from the API.\n+     * In a future release we will remove timeout(x).atMost(y) and timeout(x).never() from the API.\n      * <p>\n      * Do you want to find out more? See <a href=\"http://code.google.com/p/mockito/issues/detail?id=235\">issue 235</a>\n      *\n--- /dev/null\n+++ b/src/org/mockito/verification/VerificationWrapper.java\n+package org.mockito.verification;\n+\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.internal.verification.api.VerificationData;\n+\n+public abstract class VerificationWrapper<WrapperType extends VerificationMode> implements VerificationMode {\n+\n+    protected final WrapperType wrappedVerification;\n+\n+    public VerificationWrapper(WrapperType wrappedVerification) {\n+        this.wrappedVerification = wrappedVerification;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        wrappedVerification.verify(data);\n+    } \n+    \n+    protected abstract VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode);\n+\n+    public VerificationMode times(int wantedNumberOfInvocations) {\n+        return copySelfWithNewVerificationMode(VerificationModeFactory.times(wantedNumberOfInvocations));\n+    }\n+    \n+    public VerificationMode never() {\n+        return copySelfWithNewVerificationMode(VerificationModeFactory.atMost(0));\n+    }\n+\n+    public VerificationMode atLeastOnce() {\n+        return copySelfWithNewVerificationMode(VerificationModeFactory.atLeastOnce());\n+    }\n+\n+    public VerificationMode atLeast(int minNumberOfInvocations) {\n+        return copySelfWithNewVerificationMode(VerificationModeFactory.atLeast(minNumberOfInvocations));\n+    }\n+\n+    public VerificationMode atMost(int maxNumberOfInvocations) {\n+        return copySelfWithNewVerificationMode(VerificationModeFactory.atMost(maxNumberOfInvocations));\n+    }\n+\n+    public VerificationMode only() {\n+        return copySelfWithNewVerificationMode(VerificationModeFactory.only());\n+    }\n+    \n+}\n--- a/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n  */\n package org.mockito.internal.util.reflection;\n \n-import org.junit.Test;\n-\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n-\n-import static org.fest.assertions.Assertions.assertThat;\n-import static org.junit.Assert.fail;\n-import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;\n+import org.junit.Test;\n \n @SuppressWarnings(\"unused\")\n public class GenericMetadataSupportTest {\n \n     private Method firstNamedMethod(String methodName, Class<?> clazz) {\n         for (Method method : clazz.getMethods()) {\n-            if (method.getName().contains(methodName)) {\n+            boolean protect_against_different_jdk_ordering_avoiding_bridge_methods = !method.isBridge();\n+            if (method.getName().contains(methodName) && protect_against_different_jdk_ordering_avoiding_bridge_methods) {\n                 return method;\n             }\n         }\n         throw new IllegalStateException(\"The method : '\" + methodName + \"' do not exist in '\" + clazz.getSimpleName() + \"'\");\n     }\n-\n-\n }\n--- a/test/org/mockito/verification/TimeoutTest.java\n+++ b/test/org/mockito/verification/TimeoutTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.verification;\n \n import static org.mockito.Mockito.*;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.internal.verification.AtLeast;\n-import org.mockito.internal.verification.AtMost;\n import org.mockito.internal.verification.Only;\n import org.mockito.internal.verification.Times;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockitoutil.TestBase;\n \n-@SuppressWarnings(\"unchecked\")\n public class TimeoutTest extends TestBase {\n     \n     @Mock VerificationMode mode;\n     MockitoAssertionError error = new MockitoAssertionError(\"\"); \n \n     @Test\n-    public void shouldPassWhenVerificationPasses() {\n+    public void should_pass_when_verification_passes() {\n         Timeout t = new Timeout(1, 3, mode);\n         \n         doNothing().when(mode).verify(data);\n     }\n     \n     @Test\n-    public void shouldFailBecauseVerificationFails() {\n+    public void should_fail_because_verification_fails() {\n         Timeout t = new Timeout(1, 2, mode);\n         \n         doThrow(error).\n         doThrow(error).\n-        doThrow(error).        \n+        doThrow(error).\n         when(mode).verify(data);\n         \n         try {\n     }\n     \n     @Test\n-    public void shouldPassEvenIfFirstVerificationFails() {\n-        Timeout t = new Timeout(1, 2, mode);\n+    public void should_pass_even_if_first_verification_fails() {\n+        Timeout t = new Timeout(1, 5, mode);\n         \n         doThrow(error).\n         doThrow(error).\n-        doNothing().    \n+        doNothing().\n         when(mode).verify(data);\n         \n         t.verify(data);\n     }\n \n     @Test\n-    public void shouldTryToVerifyCorrectNumberOfTimes() {\n-        Timeout t = new Timeout(1, 4, mode);\n+    public void should_try_to_verify_correct_number_of_times() {\n+        Timeout t = new Timeout(10, 50, mode);\n         \n         doThrow(error).when(mode).verify(data);\n         \n         try {\n             t.verify(data);\n             fail();\n-        } catch (MockitoAssertionError e) {};\n+        } catch (MockitoAssertionError e) {}\n         \n         verify(mode, times(5)).verify(data);\n     }\n     \n     @Test\n-    public void shouldCreateCorrectType() {\n+    public void should_create_correctly_configured_timeout() {\n         Timeout t = new Timeout(25, 50, mode);\n         \n-        assertCorrectMode(t.atLeastOnce(), Timeout.class, 50, 25, AtLeast.class);\n-        assertCorrectMode(t.atLeast(5), Timeout.class, 50, 25, AtLeast.class);\n-        assertCorrectMode(t.times(5), Timeout.class, 50, 25, Times.class);\n-        assertCorrectMode(t.never(), Timeout.class, 50, 25, Times.class);\n-        assertCorrectMode(t.only(), Timeout.class, 50, 25, Only.class);\n+        assertTimeoutCorrectlyConfigured(t.atLeastOnce(), Timeout.class, 50, 25, AtLeast.class);\n+        assertTimeoutCorrectlyConfigured(t.atLeast(5), Timeout.class, 50, 25, AtLeast.class);\n+        assertTimeoutCorrectlyConfigured(t.times(5), Timeout.class, 50, 25, Times.class);\n+        assertTimeoutCorrectlyConfigured(t.only(), Timeout.class, 50, 25, Only.class);\n     }\n     \n-    private void assertCorrectMode(VerificationMode t, Class expectedType, int expectedTimeout, int expectedTreshold, Class expectedDelegateType) {\n+    private void assertTimeoutCorrectlyConfigured(VerificationMode t, Class<?> expectedType, int expectedTimeout, int expectedPollingPeriod, Class<?> expectedDelegateType) {\n         assertEquals(expectedType, t.getClass());\n-        assertEquals(expectedTimeout, ((Timeout) t).impl.getTimeout());\n-        assertEquals(expectedTreshold, ((Timeout) t).impl.getTreshhold());\n-        assertEquals(expectedDelegateType, ((Timeout) t).impl.getDelegate().getClass());\n+        assertEquals(expectedTimeout, ((Timeout) t).wrappedVerification.getDuration());\n+        assertEquals(expectedPollingPeriod, ((Timeout) t).wrappedVerification.getPollingPeriod());\n+        assertEquals(expectedDelegateType, ((Timeout) t).wrappedVerification.getDelegate().getClass());\n     }\n }\n--- a/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n+++ b/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {\n \n \tint nThreads = 1;\n-\tstatic final int TEST_MILLIS = 1000;\n+\t\n+\tstatic final int TIMES = 100;\n \tstatic final int INTERVAL_MILLIS = 10;\n-\tstatic final int TIMES = TEST_MILLIS / INTERVAL_MILLIS;\n \n \tITarget target = Mockito.mock(ITarget.class);\n \tExecutorService fixedThreadPool;\n \t}\n \n \t@Test\n-\tpublic void testInvocationConcurrently() throws Exception {\n+\tpublic void shouldSuccessfullyVerifyConcurrentInvocationsWithTimeout() throws Exception {\n+        int potentialOverhead = 1000; // Leave 1000ms extra before timing out as leeway for test overheads\n+        int expectedMaxTestLength = TIMES * INTERVAL_MILLIS + potentialOverhead;\n+\n \t\treset(target);\n \t\tstartInvocations();\n-\t\tverify(target, timeout(TEST_MILLIS).times(TIMES*nThreads)).targetMethod(\"arg\");\n+\t\t\n+\t\tverify(target, timeout(expectedMaxTestLength).times(TIMES * nThreads)).targetMethod(\"arg\");\n \t\tverifyNoMoreInteractions(target);\n \t}\n \n \t\t}\n \n \t}\n-\n \t\n \tpublic class TargetInvoker implements Callable<Object> {\n \n--- /dev/null\n+++ b/test/org/mockitousage/bugs/TimeoutWithAtMostOrNeverShouldBeDisabledTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.misusing.FriendlyReminderException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+//see issue 235\n+@SuppressWarnings(\"deprecation\")\n+public class TimeoutWithAtMostOrNeverShouldBeDisabledTest extends TestBase {\n+\n+    @Mock IMethods mock;\n+\n+    @Test\n+    public void shouldDisableTimeoutForAtMost() {\n+        try {\n+            verify(mock, timeout(30000).atMost(1)).simpleMethod();\n+            fail();\n+        } catch (FriendlyReminderException e) {}\n+    }\n+\n+    @Test\n+    public void shouldDisableTimeoutForNever() {\n+        try {\n+            verify(mock, timeout(30000).never()).simpleMethod();\n+            fail();\n+        } catch (FriendlyReminderException e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationAfterDelayTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.verification;\n+\n+import static org.mockito.Mockito.after;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockitoutil.TestBase;\n+\n+public class VerificationAfterDelayTest extends TestBase {\n+    \n+    @Rule\n+    public ExpectedException expected = ExpectedException.none();\n+\n+    @Mock\n+    private List<String> mock;\n+\n+    private List<Exception> exceptions = new LinkedList<Exception>();\n+\n+    @After\n+    public void teardown() {\n+        // making sure there are no threading related exceptions\n+        assertTrue(exceptions.isEmpty());\n+    }\n+\n+    @Test\n+    public void shouldVerifyNormallyWithSpecificTimes() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(20);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        verify(mock, after(50).times(1)).clear();\n+    }\n+\n+    @Test\n+    public void shouldVerifyNormallyWithAtLeast() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(20);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        verify(mock, after(100).atLeast(1)).clear();\n+    }\n+\n+    @Test\n+    public void shouldFailVerificationWithWrongTimes() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(20);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        verify(mock, times(0)).clear();\n+        \n+        expected.expect(MockitoAssertionError.class);\n+        verify(mock, after(50).times(2)).clear();\n+    }\n+\n+    @Test\n+    public void shouldWaitTheFullTimeIfTheTestCouldPass() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(50);\n+\n+        // when\n+        t.start();\n+\n+        // then        \n+        long startTime = System.currentTimeMillis();\n+        \n+        try {\n+            verify(mock, after(100).atLeast(2)).clear();\n+            fail();\n+        } catch (MockitoAssertionError e) {}\n+        \n+        assertTrue(System.currentTimeMillis() - startTime >= 100);\n+    }\n+    \n+    @Test(timeout=100)\n+    public void shouldStopEarlyIfTestIsDefinitelyFailed() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(50);\n+        \n+        // when\n+        t.start();\n+        \n+        // then\n+        expected.expect(MockitoAssertionError.class);\n+        verify(mock, after(10000).never()).clear();\n+    }\n+\n+    private Thread waitAndExerciseMock(final int sleep) {\n+        Thread t = new Thread() {\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    Thread.sleep(sleep);\n+                } catch (InterruptedException e) {\n+                    exceptions.add(e);\n+                    throw new RuntimeException(e);\n+                }\n+                mock.clear();\n+            }\n+        };\n+        return t;\n+    }\n+}\n--- a/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n+++ b/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.*;\n \n-@SuppressWarnings(\"unchecked\")\n public class VerificationWithTimeoutTest extends TestBase {\n \n-    List exceptions = new LinkedList();\n+    List<Exception> exceptions = new LinkedList<Exception>();\n     \n     @After\n     public void after() {\n     }\n     \n     @Mock\n-    private List mock;\n+    private List<String> mock;\n \n     @Test\n     public void shouldVerifyWithTimeout() throws Exception {\n         t2.start();\n         \n         //then\n-        verify(mock, timeout(1).never()).clear();\n-        verify(mock, timeout(100).times(2)).clear();\n+        verify(mock, timeout(50).atLeast(1)).clear();\n+        verify(mock, timeout(50).times(2)).clear();\n         verifyNoMoreInteractions(mock);\n     }\n     \n         t2.start();\n         \n         //then\n-        verify(mock, timeout(1).never()).clear();\n+        verify(mock, timeout(50).atLeast(1)).clear();\n         try {\n             verify(mock, timeout(100).times(3)).clear();\n             fail();\n     @Test\n     public void shouldAllowMixingOnlyWithTimeoutAndFail() throws Exception {\n         //given\n-        Thread t1 = waitAndExerciseMock(20);        \n+        Thread t1 = waitAndExerciseMock(20);\n         \n         //when\n         t1.start();\n     @Test\n     public void shouldAllowTimeoutVerificationInOrder() throws Exception {\n         //given\n-        Thread t1 = waitAndExerciseMock(20);        \n+        Thread t1 = waitAndExerciseMock(20);\n         \n         //when\n         t1.start();\n         InOrder inOrder = inOrder(mock);\n         inOrder.verify(mock).add(anyString());\n         inOrder.verify(mock, never()).clear();\n-        inOrder.verify(mock, timeout(40)).clear();                             \n+        inOrder.verify(mock, timeout(40)).clear();\n     }\n \n     private Thread waitAndExerciseMock(final int sleep) {", "timestamp": 1384333945, "metainfo": ""}