{"sha": "f920e3a4aa523b5a189cd29b9fe92a62c7e5595f", "log": "issue 238 : moved spy on injected mocks handling, cleaned some code  --HG-- branch : issue 238 : constructor injection", "commit": "\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n         AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n         Class<?> clazz = testClass.getClass();\n \n-        //below can be removed later, when we get rid of deprecated stuff\n+        //below can be removed later, when we get read rid of deprecated stuff\n         if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n             //this means user has his own annotation engine and we have to respect that.\n             //we will do annotation processing the old way so that we are backwards compatible\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n package org.mockito.internal.configuration;\n \n import org.mockito.internal.configuration.injection.MockInjection;\n-import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n-import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n-import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n-import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n \n import java.lang.reflect.Field;\n-import java.util.Comparator;\n import java.util.Set;\n \n /**\n- * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n+ * Inject mock/spies dependencies for fields annotated with &#064;InjectMocks\n  * <p/>\n  * See {@link org.mockito.MockitoAnnotations}\n  */\n public class DefaultInjectionEngine {\n-\n-    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n-    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n-        public int compare(Field field1, Field field2) {\n-            Class<?> field1Type = field1.getType();\n-            Class<?> field2Type = field2.getType();\n-\n-            if(field1Type.isAssignableFrom(field2Type)) {\n-                return 1;\n-            }\n-            if(field2Type.isAssignableFrom(field1Type)) {\n-                return -1;\n-            }\n-            return 0;\n-        }\n-    };\n-\n \n     public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {\n         MockInjection.onFields(needingInjection, testClassInstance)\n                 .withMocks(mocks)\n                 .tryConstructorInjection()\n                 .tryPropertyOrFieldInjection()\n+                .handleSpyAnnotation()\n                 .apply();\n     }\n \n-\n-\n-    /*\n-        XXX         Attention en fait le SpyAnnotationEngine peut tenter d'instancier le field\n-                    annot\u00e9 par @InjectMocks\n-\n-        Solution :  Dans SpyAnnotationEngine, ne pas essayer d'instancier un field annot\u00e9 par @InjectMocks\n-        Drawbacks : il faut g\u00e9rer de mani\u00e8re particuli\u00e8re le @Spy depuis DefaultInjectionEngine\n-     */\n-\n-    /*\n-        XXX :   Autre soucis qui arrive avec l'injection par constructeur de @InjectMocks\n-                il faut pte pr\u00e9voir le nettoyage des instances\n-     */\n-\n-\n }\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n     private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n         Class<?> classContext = clazz;\n         while (classContext != Object.class) {\n-            //this injects mocks\n-            Field[] fields = classContext.getDeclaredFields();\n-            for (Field field : fields) {\n-                if (field.isAnnotationPresent(InjectMocks.class)) {\n-                    assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n-                    injectMocks(testInstance);\n-                }\n-            }\n+            injectMocks(testInstance);\n             classContext = classContext.getSuperclass();\n         }\n     }\n      */\n     public void injectMocks(final Object testClass) {\n         Class<?> clazz = testClass.getClass();\n-        Set<Field> mockDependents = new HashSet<Field>();\n+        Set<Field> mockDependentFields = new HashSet<Field>();\n         Set<Object> mocks = new HashSet<Object>();\n         \n         while (clazz != Object.class) {\n-            mockDependents.addAll(scanForInjection(testClass, clazz));\n+            mockDependentFields.addAll(scanForInjection(testClass, clazz));\n             mocks.addAll(scanMocks(testClass, clazz));\n             clazz = clazz.getSuperclass();\n         }\n         \n-        new DefaultInjectionEngine().injectMocksOnFields(mockDependents, mocks, testClass);\n+        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClass);\n     }\n \n     /**\n      * @param clazz\n      * @return\n      */\n-    private static Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n-        Set<Field> testedFields = new HashSet<Field>();\n+    private Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n+        Set<Field> mockDependentFields = new HashSet<Field>();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n             if (null != field.getAnnotation(InjectMocks.class)) {\n-                testedFields.add(field);\n+                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n+                mockDependentFields.add(field);\n             }\n         }\n \n-        return testedFields;\n+        return mockDependentFields;\n     }\n \n-    private static Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n+    private Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n         Set<Object> mocks = new HashSet<Object>();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n                 try {\n                     fieldInstance = field.get(testClass);\n                 } catch (IllegalAccessException e) {\n-                    throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+                    throw new MockitoException(\"Problems reading this field dependency \" + field.getName() + \" for injection\", e);\n                 } finally {\n                     field.setAccessible(wasAccessible);\n                 }\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n \n import static org.mockito.Mockito.withSettings;\n \n+/**\n+ * Process fields annotated with &#64;Spy.\n+ *\n+ * <p>\n+ * Will try transform the field in a spy as with <code>Mockito.spy()</code>.\n+ * </p>\n+ *\n+ * <p>\n+ * If the field is not initialized, will try to initialize it, with a no-arg constructor.\n+ * </p>\n+ *\n+ * <p>\n+ * If the field is also annotated with the <strong>compatible</strong> &#64;InjectMocks then the field will be ignored,\n+ * The injection engine will handle this specific case.\n+ * </p>\n+ *\n+ * <p>This engine will fail, if the field is also annotated with incompatible Mockito annotations.\n+ */\n @SuppressWarnings({\"unchecked\"})\n public class SpyAnnotationEngine implements AnnotationEngine {\n \n     public Object createMockFor(Annotation annotation, Field field) {\n         return null;\n     }\n-    \n-    @SuppressWarnings(\"deprecation\")\n+\n+    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n     public void process(Class<?> context, Object testInstance) {\n         Field[] fields = context.getDeclaredFields();\n         for (Field field : fields) {\n-            if (field.isAnnotationPresent(Spy.class)) {\n-                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n+                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                 Object instance = null;\n                 try {\n                     FieldInitializationReport report = new FieldInitializer(testInstance, field).initialize();\n                 try {\n                     if (new MockUtil().isMock(instance)) {\n                         // instance has been spied earlier\n+                        // for example happens when MockitoAnnotations.initMocks is called two times.\n                         Mockito.reset(instance);\n                     } else {\n                         field.setAccessible(true);\n     }\n     \n     //TODO duplicated elsewhere\n-    void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n+    void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n         for (Class u : undesiredAnnotations) {\n             if (field.isAnnotationPresent(u)) {\n                 new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n--- a/src/org/mockito/internal/configuration/injection/MockInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n         private Set<Field> fields = new HashSet<Field>();\n         private Set<Object> mocks = new HashSet<Object>();\n         private Object fieldOwner;\n-        private MockInjectionStrategy injectionStrategies;\n+        private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n+        private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n \n         private OngoingMockInjection(Field field, Object fieldOwner) {\n             this(Collections.singleton(field), fieldOwner);\n         }\n \n         public OngoingMockInjection tryConstructorInjection() {\n-            appendStrategy(new ConstructorInjection());\n+            injectionStrategies.thenTry(new ConstructorInjection());\n             return this;\n         }\n \n         public OngoingMockInjection tryPropertyOrFieldInjection() {\n-            appendStrategy(new PropertyAndSetterInjection());\n+            injectionStrategies.thenTry(new PropertyAndSetterInjection());\n             return this;\n         }\n \n-        private void appendStrategy(MockInjectionStrategy strategy) {\n-            if(injectionStrategies == null) {\n-                injectionStrategies = strategy;\n-            } else {\n-                injectionStrategies.thenTry(strategy);\n-            }\n-\n+        public OngoingMockInjection handleSpyAnnotation() {\n+            postInjectionStrategies.thenTry(new SpyOnInjectedFieldsHandler());\n+            return this;\n         }\n \n         public void apply() {\n             for (Field field : fields) {\n                 injectionStrategies.process(field, fieldOwner, mocks);\n+                postInjectionStrategies.process(field, fieldOwner, mocks);\n             }\n         }\n     }\n--- a/src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java\n  * Injector strategy contract\n  */\n public abstract class MockInjectionStrategy {\n+\n+    /**\n+     * NOP Strategy that will always try the next strategy.\n+     */\n+    public static final MockInjectionStrategy nop() {\n+        return new MockInjectionStrategy() {\n+            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+                return false;\n+            }\n+        };\n+    }\n+\n \n     private MockInjectionStrategy nextStrategy;\n \n      * @return The passed strategy instance to allow chaining.\n      */\n     public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n-        nextStrategy = strategy;\n+        if(nextStrategy != null) {\n+            nextStrategy.thenTry(strategy);\n+        } else {\n+            nextStrategy = strategy;\n+        }\n         return strategy;\n     }\n \n     protected abstract boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates);\n \n     private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n-        return nextStrategy != null && nextStrategy.processInjection(field, fieldOwner, mockCandidates);\n+        return nextStrategy != null && nextStrategy.process(field, fieldOwner, mockCandidates);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldReader;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+import static org.mockito.Mockito.withSettings;\n+\n+/**\n+ * Handler for field annotated with &#64;InjectMocks and &#64;Spy.\n+ *\n+ * <p>\n+ * The handler assumes that field initialization AND injection already happened.\n+ * So if the field is still null, then nothing will happen there.\n+ * </p>\n+ */\n+public class SpyOnInjectedFieldsHandler extends MockInjectionStrategy {\n+\n+    @Override\n+    protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        FieldReader fieldReader = new FieldReader(fieldOwner, field);\n+\n+        // TODO refoctor : code duplicated in SpyAnnotationEngine\n+        if(!fieldReader.isNull() && field.isAnnotationPresent(Spy.class)) {\n+            try {\n+                Object instance = fieldReader.read();\n+                if (new MockUtil().isMock(instance)) {\n+                    // A. instance has been spied earlier\n+                    // B. protect against multiple use of MockitoAnnotations.initMocks()\n+                    Mockito.reset(instance);\n+                } else {\n+                    new FieldSetter(fieldOwner, field).set(\n+                        Mockito.mock(instance.getClass(), withSettings()\n+                            .spiedInstance(instance)\n+                            .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n+                            .name(field.getName()))\n+                    );\n+                }\n+            } catch (Exception e) {\n+                throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n+            }\n+        }\n+\n+        return false;\n+    }\n+}\n--- a/src/org/mockito/internal/util/reflection/FieldReader.java\n+++ b/src/org/mockito/internal/util/reflection/FieldReader.java\n  */\n package org.mockito.internal.util.reflection;\n \n+import org.mockito.exceptions.base.MockitoException;\n+\n import java.lang.reflect.Field;\n-\n-import org.mockito.exceptions.base.MockitoException;\n \n public class FieldReader {\n \n     }\n \n     public boolean isNull() {\n+            return read() == null;\n+    }\n+\n+    public Object read() {\n         try {\n-            return field.get(target) == null;\n+            return field.get(target);\n         } catch (Exception e) {\n             throw new MockitoException(\"Cannot read state from field: \" + field + \", on instance: \" + target);\n         }\n--- a/test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java\n     }\n \n     @Test\n-    @Ignore(\"Works must be done on the spy annotation engine and the injection engine\")\n     public void objects_created_with_constructor_initialization_can_be_spied() throws Exception {\n         assertFalse(mockUtil.isMock(articleManager));\n         assertTrue(mockUtil.isMock(spiedArticleManager));", "timestamp": 1301247019, "metainfo": ""}