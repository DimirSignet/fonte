{"sha": "845aa65b68aafb02f9f1017d39571624a0b3f46e", "log": "Made verbose stack traces visible when working with Mockito codebase Added new configuration option - turning off internal stack trace cleaning logic  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401315", "commit": "\n--- a/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n     public AnnotationEngine getAnnotationEngine() {\n         return new DefaultAnnotationEngine();\n     }\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.configuration.IMockitoConfiguration#cleansStackTrace()\n+     */\n+    public boolean cleansStackTrace() {\n+        return true;\n+    }\n }\n--- a/src/org/mockito/configuration/IMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/IMockitoConfiguration.java\n      * See javadoc for {@link IMockitoConfiguration}\n      */\n     AnnotationEngine getAnnotationEngine();\n+\n+    /**\n+     * This should be turned on unless you're a Mockito developer and you wish\n+     * to have verbose (read: messy) stack traces that only few understand (eg:\n+     * Mockito developers)\n+     * <p>\n+     * See javadoc for {@link IMockitoConfiguration}\n+     * \n+     * @return if Mockito should clean stack traces\n+     */\n+    boolean cleansStackTrace();\n }\n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n import java.util.Arrays;\n import java.util.List;\n \n+import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.internal.configuration.GlobalConfiguration;\n+\n public class StackTraceFilter {\n+    \n+    private IMockitoConfiguration config = new GlobalConfiguration();\n     \n     public boolean isLastStackElementToRemove(StackTraceElement e) {\n         boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n     }\n \n     public StackTraceElement[] filterStackTrace(StackTraceElement[] target) {\n+        if (!config.cleansStackTrace()) {\n+            return target;\n+        }\n+            \n         List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n         \n         int lastToRemove = -1;\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n     \n     private static ThreadLocal<IMockitoConfiguration> globalConfiguration = new ThreadLocal<IMockitoConfiguration>();\n \n+    //back door for testing\n+    IMockitoConfiguration getIt() {\n+        return globalConfiguration.get();\n+    }\n+    \n     public GlobalConfiguration() {\n         //Configuration should be loaded only once but I cannot really test it\n         if (globalConfiguration.get() == null) {\n-            globalConfiguration.set(getConfig());\n+            globalConfiguration.set(createConfig());\n         }\n     }\n     \n     @SuppressWarnings(\"deprecation\")\n-    IMockitoConfiguration getConfig() {\n+    private IMockitoConfiguration createConfig() {\n         IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration() {\n             @Override public ReturnValues getReturnValues() {\n                 //For now, let's leave the deprecated way of getting return values, \n             return defaultConfiguration;\n         }\n     }\n-\n+    \n     public static void validate() {\n         new GlobalConfiguration();\n     }\n     public AnnotationEngine getAnnotationEngine() {\n         return globalConfiguration.get().getAnnotationEngine();\n     }\n+\n+    public boolean cleansStackTrace() {\n+        return globalConfiguration.get().cleansStackTrace();\n+    }\n }\n--- a/test/org/mockito/configuration/MockitoConfiguration.java\n+++ b/test/org/mockito/configuration/MockitoConfiguration.java\n @SuppressWarnings(\"deprecation\")\n public class MockitoConfiguration extends DefaultMockitoConfiguration implements IMockitoConfiguration {\n \n-    private static ReturnValues overriddenReturnValues = null;\n+    private ReturnValues overriddenReturnValues = null;\n+    private boolean cleansStackTrace;\n \n     //for testing purposes, allow to override the configuration\n-    public static void overrideReturnValues(ReturnValues returnValues) {\n-        MockitoConfiguration.overriddenReturnValues = returnValues;\n+    public void overrideReturnValues(ReturnValues returnValues) {\n+        this.overriddenReturnValues = returnValues;\n+    }\n+\n+    //for testing purposes, allow to override the configuration\n+    public void overrideCleansStackTrace(boolean cleansStackTrace) {\n+        this.cleansStackTrace = cleansStackTrace;\n     }\n \n     @Override\n             }\n         };\n     }\n+    \n+    @Override\n+    public boolean cleansStackTrace() {\n+        return cleansStackTrace;\n+    }\n }\n--- a/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n \n import static org.mockitoutil.ExtraMatchers.*;\n \n-import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n public class StackTraceFilterTest extends TestBase {\n     \n-    private StackTraceFilter filter;\n+    private StackTraceFilter filter = new StackTraceFilter();\n     \n-    @Before\n-    public void setup() {\n-        filter = new StackTraceFilter();\n-    }\n-\n     @Test\n     public void testShouldFilterOutCglibGarbage() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n+        \n         Throwable t = new TraceBuilder().classes(\n             \"MockitoExampleTest\",\n             \"List$$EnhancerByMockitoWithCGLIB$$2c406024\", \n     \n     @Test\n     public void testShouldFilterOutMockitoPackage() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n+        \n         Throwable t = new TraceBuilder().classes(\n             \"org.test.MockitoSampleTest\",\n             \"org.test.TestSupport\",\n         \n         assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n     }\n+    \n+    @Test\n+    public void testShouldNotFilterWhenConfigurationSaysNo() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n+        \n+        Throwable t = new TraceBuilder().classes(\n+            \"org.test.MockitoSampleTest\",\n+            \"org.mockito.Mockito\" \n+        ).toThrowable();\n+            \n+        filter.filterStackTrace(t);\n+        \n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.mockito.Mockito\", \"org.test.MockitoSampleTest\"));\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/ConfigurationAccess.java\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.configuration.MockitoConfiguration;\n+\n+public class ConfigurationAccess {\n+\n+    public static MockitoConfiguration getConfig() {\n+        return (MockitoConfiguration) new GlobalConfiguration().getIt();\n+    }\n+}\n--- a/test/org/mockitousage/configuration/MockitoConfigurationTest.java\n+++ b/test/org/mockitousage/configuration/MockitoConfigurationTest.java\n \n import static org.mockito.Mockito.*;\n \n-import org.junit.After;\n import org.junit.Test;\n import org.mockito.ReturnValues;\n-import org.mockito.configuration.MockitoConfiguration;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class MockitoConfigurationTest extends TestBase {\n     \n-    @After\n-    public void cleanUpConfig() {\n-        MockitoConfiguration.overrideReturnValues(null);\n-    }\n-    \n     @Test\n     public void shouldReadConfigurationClassFromClassPath() {\n-        MockitoConfiguration.overrideReturnValues(new ReturnValues() {\n+        ConfigurationAccess.getConfig().overrideReturnValues(new ReturnValues() {\n             public Object valueFor(InvocationOnMock invocation) {\n                 return \"foo\";\n             }});\n--- a/test/org/mockitousage/stacktrace/ClickableStackTracesTest.java\n+++ b/test/org/mockitousage/stacktrace/ClickableStackTracesTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class ClickableStackTracesTest extends TestBase {\n     \n-    private IMethods mock;\n+    @Mock private IMethods mock;\n \n     @Before\n     public void setup() {\n-        mock = Mockito.mock(IMethods.class);\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n     }\n \n     private void callMethodOnMock(String param) {\n--- a/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n+++ b/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @Mock private IMethods mock;\n \n+    @Before\n+    public void setupCleanStackTraces() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n+    }\n+    \n     @After\n     public void resetState() {\n         StateMaster.reset();\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.InOrder;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n @RunWith(MockitoJUnitRunner.class)\n public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {\n     \n-    private IMethods mock;\n-    private IMethods mockTwo;\n+    @Mock private IMethods mock;\n+    @Mock private IMethods mockTwo;\n     private InOrder inOrder;\n \n     @Before\n     public void setup() {\n-        mock = Mockito.mock(IMethods.class);\n-        mockTwo = Mockito.mock(IMethods.class);\n         inOrder = inOrder(mock, mockTwo);\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n         \n         firstChunk();\n         secondChunk();\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationInOrderTest.java\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.InOrder;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n @RunWith(MockitoJUnitRunner.class)\n public class PointingStackTraceToActualInvocationInOrderTest extends TestBase {\n     \n-    private IMethods mock;\n-    private IMethods mockTwo;\n+    @Mock private IMethods mock;\n+    @Mock private IMethods mockTwo;\n     private InOrder inOrder;\n \n     @Before\n     public void setup() {\n-        mock = Mockito.mock(IMethods.class);\n-        mockTwo = Mockito.mock(IMethods.class);\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n+        \n         inOrder = inOrder(mock, mockTwo);\n         \n         first();\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockito.runners.MockitoJUnit44Runner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n @RunWith(MockitoJUnit44Runner.class)\n public class PointingStackTraceToActualInvocationTest extends TestBase {\n     \n-    private IMethods mock;\n-    private IMethods mockTwo;\n+    @Mock private IMethods mock;\n+    @Mock private IMethods mockTwo;\n \n     @Before\n     public void setup() {\n-        mock = Mockito.mock(IMethods.class);\n-        mockTwo = Mockito.mock(IMethods.class);\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n         \n         first();\n         second();\n--- a/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n+++ b/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.InOrder;\n-import org.mockito.Mockito;\n+import org.mockito.Mock;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class StackTraceFilteringTest extends TestBase {\n     \n-    private IMethods mock;\n+    @Mock private IMethods mock;\n \n     @After\n     public void resetState() {\n     @Before\n     public void setup() {\n         resetState();\n-        mock = Mockito.mock(IMethods.class);\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n     }\n     \n     @Test\n--- a/test/org/mockitousage/stubbing/SmartNullsStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/SmartNullsStubbingTest.java\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     @Before\n     public void setup() {\n         mock = mock(IMethods.class, Mockito.RETURNS_SMART_NULLS);\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n     }\n     \n     public IMethods unstubbedMethodInvokedHere(IMethods mock) {\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import junit.framework.Assert;\n \n import org.hamcrest.Matcher;\n+import org.junit.After;\n import org.junit.Before;\n import org.mockito.MockitoAnnotations;\n import org.mockito.StateMaster;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n \n /**\n  * the easiest way to make sure that tests clean up invalid state is to require\n  */\n public class TestBase extends Assert {\n \n+    @After\n+    public void cleanUpConfigInAnyCase() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n+        ConfigurationAccess.getConfig().overrideReturnValues(null);\n+    }\n+    \n     @Before\n     public void init() {\n         StateMaster.validate();", "timestamp": 1239701327, "metainfo": ""}