{"sha": "f123fe1a1936767a2f79459921ac6ebe0061d79c", "log": "removed TABs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40487", "commit": "\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n      * @return <code>null</code>.\n      */\n     @SuppressWarnings(\"unchecked\")\n-\tpublic static <T> T anyObject() {\n+    public static <T> T anyObject() {\n         return (T) reportMatcher(Any.ANY).returnNull();\n     }\n \n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     }\n \n     protected String toString(List<Matcher> matchers) {\n-    \tString method = qualifiedMethodName();\n-    \tString invocation = method + getArgumentsLine(matchers);\n-    \tif (invocation.length() <= MAX_LINE_LENGTH) {\n-    \t\treturn invocation;\n-    \t} else {\n-    \t\treturn method + getArgumentsBlock(matchers);\n-    \t}\n+        String method = qualifiedMethodName();\n+        String invocation = method + getArgumentsLine(matchers);\n+        if (invocation.length() <= MAX_LINE_LENGTH) {\n+            return invocation;\n+        } else {\n+            return method + getArgumentsBlock(matchers);\n+        }\n     }\n \n     private String qualifiedMethodName() {\n     }\n     \n     private String getArgumentsBlock(List<Matcher> matchers) {\n-    \tDescription result = new StringDescription();\n-    \tresult.appendList(\"(\\n    \", \",\\n    \", \"\\n);\", matchers);\n-    \treturn result.toString();\n+        Description result = new StringDescription();\n+        result.appendList(\"(\\n    \", \",\\n    \", \"\\n);\", matchers);\n+        return result.toString();\n     }\n     \n     protected List<Matcher> argumentsToMatchers() {\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n         return false;\n     }\n \n-\tpublic boolean hasSameMethod(Invocation candidate) {\n-\t\treturn invocation.getMethod().equals(candidate.getMethod());\n-\t}\n+    public boolean hasSameMethod(Invocation candidate) {\n+        return invocation.getMethod().equals(candidate.getMethod());\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n     }\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-    \tInvocation firstSimilar = null;\n+        Invocation firstSimilar = null;\n         for (Invocation invocation : invocations) {\n-        \tif (!wanted.hasSimilarMethod(invocation)) {\n-        \t\tcontinue;\n-        \t}\n-        \tif (firstSimilar == null) {\n-        \t\tfirstSimilar = invocation;\n-        \t}\n-        \tif (wanted.hasSameMethod(invocation)) {\n-        \t\treturn invocation;\n-        \t}\n+            if (!wanted.hasSimilarMethod(invocation)) {\n+                continue;\n+            }\n+            if (firstSimilar == null) {\n+                firstSimilar = invocation;\n+            }\n+            if (wanted.hasSameMethod(invocation)) {\n+                return invocation;\n+            }\n         }\n         \n         return firstSimilar;\n--- a/test/org/mockito/TestBase.java\n+++ b/test/org/mockito/TestBase.java\n         MockitoAnnotations.initMocks(this);\n     }\n     \n-\t//I'm really tired of matchers, enter the assertor!\n-\tprotected <T> void assertThat(T o, Assertor<T> a) {\n-\t\ta.assertValue(o);\n-\t}\n-\t\n-\tprotected <T> void assertThat(T actual, Matcher<T> m) {\n-\t\torg.junit.Assert.assertThat(actual, m);\n-\t}\n-\t\n-\tprotected <T> void assertThat(String message, T actual, Matcher<T> m) {\n-\t\torg.junit.Assert.assertThat(message, actual, m);\n-\t}\n-\t\n+    //I'm really tired of matchers, enter the assertor!\n+    protected <T> void assertThat(T o, Assertor<T> a) {\n+        a.assertValue(o);\n+    }\n+    \n+    protected <T> void assertThat(T actual, Matcher<T> m) {\n+        org.junit.Assert.assertThat(actual, m);\n+    }\n+    \n+    protected <T> void assertThat(String message, T actual, Matcher<T> m) {\n+        org.junit.Assert.assertThat(message, actual, m);\n+    }\n+    \n     protected void assertContains(String expectedSubstring, String target) {\n-\t\tassertTrue(\"This substring:\\n\" + expectedSubstring\n-\t\t\t\t+ \"\\nshould exist somewhere here:\\n\" + target, \n-\t\t\t\ttarget.contains(expectedSubstring));\n-\t}\n+        assertTrue(\"This substring:\\n\" + expectedSubstring\n+                + \"\\nshould exist somewhere here:\\n\" + target, \n+                target.contains(expectedSubstring));\n+    }\n \n-\tpublic static <T> Assertor<Throwable> messageContains(final String text) {\n+    public static <T> Assertor<Throwable> messageContains(final String text) {\n         return new Assertor<Throwable>() {\n-        \tpublic void assertValue(Throwable value) {\n-        \t\tassertTrue(\"This substring: \\n\" + text + \n-        \t\t\t\t\"\\nshould occur in this exception message:\" + value.getMessage()\n-        \t\t\t\t, ((Throwable) value).getMessage().contains(text));\n-        \t}\n+            public void assertValue(Throwable value) {\n+                assertTrue(\"This substring: \\n\" + text + \n+                        \"\\nshould occur in this exception message:\" + value.getMessage()\n+                        , ((Throwable) value).getMessage().contains(text));\n+            }\n         };\n     }\n     \n     public static <T> Assertor<Throwable> causeMessageContains(final String text) {\n         return new Assertor<Throwable>() {\n-        \tpublic void assertValue(Throwable value) {\n-        \t\tThrowable cause = ((Throwable) value).getCause();\n-        \t\tassertNotNull(\"Exception cause should not be null\", cause);\n-        \t\tassertTrue(\"\\nException message >>>\" + cause.getMessage() + \"\\n>>> should contain: \" + text,\n-        \t\t\t\tcause.getMessage().contains(text));\n-        \t}\n+            public void assertValue(Throwable value) {\n+                Throwable cause = ((Throwable) value).getCause();\n+                assertNotNull(\"Exception cause should not be null\", cause);\n+                assertTrue(\"\\nException message >>>\" + cause.getMessage() + \"\\n>>> should contain: \" + text,\n+                        cause.getMessage().contains(text));\n+            }\n         };\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     public void shouldPrintArgumentsInMultilinesWhenGetsTooBig() {\n         invocation = new InvocationBuilder().args(\"veeeeery long string that makes it ugly in one line\", 1).toInvocation();\n         assertEquals(\"Object.simpleMethod(\" +\n-        \t\t\"\\n\" +\n-        \t\t\"    \\\"veeeeery long string that makes it ugly in one line\\\",\" +\n-        \t\t\"\\n\" +\n-        \t\t\"    1\" +\n-        \t\t\"\\n\" +\n-        \t\t\");\", invocation.toString());\n+                \"\\n\" +\n+                \"    \\\"veeeeery long string that makes it ugly in one line\\\",\" +\n+                \"\\n\" +\n+                \"    1\" +\n+                \"\\n\" +\n+                \");\", invocation.toString());\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n     \n     @Test\n     public void shouldFindFirstSimilarInvocationByName() throws Exception {\n-    \tInvocation overloadedSimpleMethod = new InvocationBuilder().simpleMethod().arg(\"test\").toInvocation();\n-    \t\n-    \tInvocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod), atLeastOnce());\n-    \tassertSame(found, simpleMethodInvocation);\n+        Invocation overloadedSimpleMethod = new InvocationBuilder().simpleMethod().arg(\"test\").toInvocation();\n+        \n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod), atLeastOnce());\n+        assertSame(found, simpleMethodInvocation);\n     }\n     \n     @Test\n         \n         invocations.add(overloadedDifferentMethod);\n         \n-\t\tInvocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod), atLeastOnce());\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod), atLeastOnce());\n         assertSame(found, overloadedDifferentMethod);\n     }\n     \n--- a/test/org/mockito/util/Assertor.java\n+++ b/test/org/mockito/util/Assertor.java\n package org.mockito.util;\n \n public interface Assertor<T> {\n-\t\n-\tvoid assertValue(T value);\n+    \n+    void assertValue(T value);\n }\n--- a/test/org/mockitousage/matchers/MatchersTest.java\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n             verify(mock).oneArray(aryEq(nullArray));\n             fail();\n         } catch (WantedButNotInvoked e) {\n-        \tassertThat(e, messageContains(\"oneArray(null)\"));\n+            assertThat(e, messageContains(\"oneArray(null)\"));\n         }\n     }\n \n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n         mock.varargs(\"this is very long string\", \"this is another very long string\");\n \n         try {\n-        \tverify(mock).varargs(\"this is very long string\", \"this is another very long string\", \"this is yet another very long string\");\n-            fail();\n-        } catch (ArgumentsAreDifferent e) {\n-        \t//TODO for every case when wanted and actual are shown, the arg list has to be consistently printed\n-        \t//(e.g. if one invocation is multiline, the the other one has to to be printed in multilines as well)\n+            verify(mock).varargs(\"this is very long string\", \"this is another very long string\", \"this is yet another very long string\");\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            //TODO for every case when wanted and actual are shown, the arg list has to be consistently printed\n+            //(e.g. if one invocation is multiline, the the other one has to to be printed in multilines as well)\n             String expected =\n                     \"\\n\" +\n                     \"Argument(s) are different! Wanted:\" +", "timestamp": 1206218272, "metainfo": ""}