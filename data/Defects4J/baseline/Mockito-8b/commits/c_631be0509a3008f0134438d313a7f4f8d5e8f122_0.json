{"sha": "631be0509a3008f0134438d313a7f4f8d5e8f122", "log": "Added support for unmockable types while dealing with generic return types  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n     \n     private static final long serialVersionUID = -6926328908792880098L;\n     \n-    private Answer<Object> delegate = new ReturnsEmptyValues();\n+    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n \n     private MockitoLogger logger = new ConsoleMockitoLogger();\n \n         return recordDeepStubMock(invocation, container);\n     }\n \n-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n+    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) throws Throwable {\n         final Object mock = createGenericsAwareMock(invocation);\n \n         container.addAnswer(new Answer<Object>() {\n         return mock;\n     }\n \n-    private Object createGenericsAwareMock(InvocationOnMock invocation) {\n+    private Object createGenericsAwareMock(InvocationOnMock invocation) throws Throwable {\n         Type genericReturnType = invocation.getMethod().getGenericReturnType();\n \n         if (genericReturnType instanceof Class) {\n             return mock((Class<?>) genericReturnType, this);\n         }\n \n-        MockitoGenericMetadata mockitoGenericMetadata =\n+        MockitoGenericMetadata returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n-        return mockitoGenericMetadata.toMock(this);\n-\n-        // throw new MockitoException(\"[Work In Progress] Can't mock the return type : \" + genericReturnType);\n+        Object mock = returnTypeGenericMetadata.toMock(this);\n+        if (mock == null) {\n+            return delegate.returnValueFor(returnTypeGenericMetadata.rawType());\n+        }\n+        return mock;\n     }\n \n     private MockitoGenericMetadata actualParameterizedType(Object mock) {\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n \n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n \n+import static org.fest.assertions.Assertions.assertThat;\n import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n import static org.mockito.Mockito.mock;\n \n @SuppressWarnings(\"unused\")\n public class ReturnsDeepStubsTest {\n-    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n-        E get();\n-    }\n-    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n-        E get();\n-    }\n-    interface ListOfNumbers extends List<Number> {}\n-    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+    interface ListOfInteger extends List<Integer> {}\n \n     interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n         Set<Number> remove(Object key); // override with fixed ParameterizedType\n         List<? super Number> returningWildcard();\n+        Map<String, K> returningNonMockableNestedGeneric();\n         K returningK();\n         <O extends K> List<O> paramTypeWithTypeParams();\n         <S extends Appendable, T extends S> T twoTypeParams(S s);\n     }\n \n     @Test\n-    @Ignore(\"TODO WildCard\")\n     public void returning_deep_stubs_3() throws Exception {\n         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n \n         List<? super Integer> objects = mock.returningWildcard();\n         Number n = (Number) mock.returningWildcard().get(45);\n+        n.floatValue();\n+    }\n+\n+    @Test\n+    public void return_default_value_on_non_mockable_nested_generic() throws Exception {\n+        GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+        ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);\n+\n+        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();\n+        assertThat(listOfInteger.get(25)).isEqualTo(0);\n     }\n \n     @Test(expected = ClassCastException.class)", "timestamp": 1343830342, "metainfo": ""}