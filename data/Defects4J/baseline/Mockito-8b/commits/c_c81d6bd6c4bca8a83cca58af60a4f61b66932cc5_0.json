{"sha": "c81d6bd6c4bca8a83cca58af60a4f61b66932cc5", "log": "Refactorings around configuration loading  --HG-- rename : test/org/mockitousage/stubbing/GloballyConfiguredReturnValuesTest.java => test/org/mockitousage/configuration/GloballyConfiguredReturnValuesTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401170", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n-import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.HandyReturnValues;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.OngoingStubbing;\n     }\n     \n     private static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n-        //TODO test\n-        GlobalConfiguration.init();\n         MOCKING_PROGRESS.validateState();\n         MOCKING_PROGRESS.resetOngoingStubbing();\n         return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.IMockitoConfiguration;\n+import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+\n+public class ClassPathLoader {\n+    \n+    /**\n+     * @param defaultConfiguration - to be used if no config found on classpath\n+     * @return\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    public IMockitoConfiguration loadConfiguration(IMockitoConfiguration defaultConfiguration) {\n+        //Trying to get config from classpath\n+        Class configClass = null;\n+        try {\n+            configClass = (Class) Class.forName(\"org.mockito.MockitoConfiguration\");\n+        } catch (ClassNotFoundException e) {\n+            //that's ok, it means there is no global config, using default one. \n+            return defaultConfiguration;\n+        }\n+        \n+        try {\n+            return (IMockitoConfiguration) configClass.newInstance();\n+        } catch (ClassCastException e) {\n+            throw new MockitoConfigurationException(\"\\n\" +\n+                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n+        } catch (Exception e) {\n+            throw new MockitoConfigurationException(\"\\n\" +\n+                    \"Unable to instantianate org.mockito.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n package org.mockito.internal.configuration;\n \n import org.mockito.IMockitoConfiguration;\n-import org.mockito.exceptions.misusing.MockitoConfigurationException;\n+import org.mockito.ReturnValues;\n \n-public class GlobalConfiguration {\n+public class GlobalConfiguration implements IMockitoConfiguration {\n     \n-    private static IMockitoConfiguration globalConfiguration;\n-    private static boolean initialized = false;\n+    private static ThreadLocal<IMockitoConfiguration> globalConfiguration = new ThreadLocal<IMockitoConfiguration>();\n \n-    @SuppressWarnings(\"unchecked\")\n-    private static IMockitoConfiguration readFromClasspath() {\n-        //Trying to get config from classpath\n-        Class configClass = null;\n-        try {\n-            configClass = (Class) Class.forName(\"org.mockito.MockitoConfiguration\");\n-        } catch (ClassNotFoundException e) {\n-            //that's ok, it means there is no global config, \n-            return null;\n-        }\n-        \n-        try {\n-            return (IMockitoConfiguration) configClass.newInstance();\n-        } catch (ClassCastException e) {\n-            throw new MockitoConfigurationException(\"\\n\" +\n-                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n-        } catch (Exception e) {\n-            throw new MockitoConfigurationException(\"\\n\" +\n-                    \"Unable to instantianate org.mockito.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n+    public GlobalConfiguration() {\n+        //Configuration should be loaded only once but I cannot really test it\n+        if (globalConfiguration.get() == null) {\n+            globalConfiguration.set(getConfig());\n         }\n     }\n-\n-    public static IMockitoConfiguration getConfig() {\n-        if (!initialized) {\n-            throw new IllegalStateException(\"Something went wrong. GlobalConfiguration should be initialised by now.\\n\" +\n-                \"Please report issue at http://mockito.org or write an email to mockito@googlegroups.com\");\n-        }\n-        return globalConfiguration;\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    IMockitoConfiguration getConfig() {\n+        IMockitoConfiguration defaultConfiguration = new IMockitoConfiguration() {\n+            public ReturnValues getReturnValues() {\n+                //For now, let's leave the deprecated way of getting return values, \n+                //it will go away, replaced simply by return new DefaultReturnValues()\n+                return Configuration.instance().getReturnValues();\n+            }\n+        };\n+        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration(defaultConfiguration);\n+        return config;\n     }\n \n-    public static void init() {\n-        if (!initialized) {\n-            globalConfiguration = readFromClasspath();\n-            initialized = true;\n-        }\n+    public ReturnValues getReturnValues() {\n+        return globalConfiguration.get().getReturnValues();\n+    }\n+\n+    public static void validate() {\n+        new GlobalConfiguration();\n     }\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n package org.mockito.internal.progress;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n     }\n \n     public void validateState() {\n+        //State is cool when GlobalConfiguration is already loaded\n+        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.MockitoConfiguration class \n+        GlobalConfiguration.validate();\n+        \n         if (verificationMode != null) {\n             verificationMode = null;\n             reporter.unfinishedVerificationException();\n--- a/src/org/mockito/internal/returnvalues/GloballyConfiguredReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/GloballyConfiguredReturnValues.java\n package org.mockito.internal.returnvalues;\n \n import org.mockito.ReturnValues;\n-import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.invocation.InvocationOnMock;\n \n public class GloballyConfiguredReturnValues implements ReturnValues {\n     \n     public Object valueFor(InvocationOnMock invocation) {\n-        if (GlobalConfiguration.getConfig() != null) {\n-            return GlobalConfiguration.getConfig().getReturnValues().valueFor(invocation);\n-        }\n-        \n-        //For now, let's leave the deprecated way of getting return values, \n-        //it will go away, replaced simply by return new DefaultReturnValues()\n-        return Configuration.instance().getReturnValues().valueFor(invocation);\n+        return new GlobalConfiguration().getReturnValues().valueFor(invocation);\n     }\n }\n--- a/test/org/mockito/MockitoConfiguration.java\n+++ b/test/org/mockito/MockitoConfiguration.java\n     public static void overrideReturnValues(ReturnValues returnValues) {\n         MockitoConfiguration.overridden = returnValues;\n     }\n-\n+    \n     public ReturnValues getReturnValues() {\n         if (overridden == null) {\n             return Configuration.instance().getReturnValues();\n--- a/test/org/mockito/configuration/experimental/ConfigurationTest.java\n+++ b/test/org/mockito/configuration/experimental/ConfigurationTest.java\n  */\n package org.mockito.configuration.experimental;\n \n-import static org.mockito.Mockito.*;\n-\n-import org.junit.After;\n import org.junit.Test;\n-import org.mockito.MockitoConfiguration;\n-import org.mockito.ReturnValues;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.invocation.InvocationOnMock;\n-import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class ConfigurationTest extends TestBase {\n             assertThat(e, messageContains(\"Cannot set null ReturnValues!\"));\n         }\n     }\n-   \n-    @Test\n-    public void shouldReadConfigurationClassFromClassPath() {\n-        MockitoConfiguration.overrideReturnValues(new ReturnValues() {\n-            public Object valueFor(InvocationOnMock invocation) {\n-                return \"foo\";\n-            }});\n-\n-        IMethods mock = mock(IMethods.class); \n-        assertEquals(\"foo\", mock.simpleMethod());\n-    }\n-    \n-    @After\n-    public void cleanUpConfig() {\n-        MockitoConfiguration.overrideReturnValues(null);\n-    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/configuration/GloballyConfiguredReturnValuesTest.java\n+package org.mockitousage.configuration;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.ReturnValues;\n+import org.mockito.configuration.experimental.ConfigurationSupport;\n+import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"deprecation\")\n+public class GloballyConfiguredReturnValuesTest extends TestBase {\n+    \n+    public class HardCodedReturnValues implements ReturnValues {\n+        private final String returnValue;\n+\n+        public HardCodedReturnValues(String returnValue) {\n+            this.returnValue = returnValue;\n+        }\n+\n+        public Object valueFor(InvocationOnMock invocation) {\n+            return returnValue;\n+        }\n+    }\n+\n+    @Test\n+    public void shouldUseCurrentlyConfiguredReturnValuesEvenIfTheyChangeAtRuntime() throws Exception {\n+        ReturnValues returnsEdam = new HardCodedReturnValues(\"edam\");\n+        ReturnValues returnsCheddar = new HardCodedReturnValues(\"cheddar\");\n+        IMethods mock = Mockito.mock(IMethods.class, new GloballyConfiguredReturnValues());\n+        \n+        ConfigurationSupport.getConfiguration().setReturnValues(returnsEdam);\n+        \n+        ConfigurationSupport.getConfiguration().getReturnValues();\n+        \n+        assertEquals(\"edam\", mock.simpleMethod());\n+        \n+        ConfigurationSupport.getConfiguration().setReturnValues(returnsCheddar);\n+        \n+        assertEquals(\"cheddar\", mock.simpleMethod());\n+    }\n+    \n+    @After\n+    public void resetReturnValues() {\n+        ConfigurationSupport.getConfiguration().resetReturnValues();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/configuration/MockitoConfigurationTest.java\n+package org.mockitousage.configuration;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.MockitoConfiguration;\n+import org.mockito.ReturnValues;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class MockitoConfigurationTest extends TestBase {\n+    \n+    @After\n+    public void cleanUpConfig() {\n+        MockitoConfiguration.overrideReturnValues(null);\n+    }\n+    \n+    @Test\n+    public void shouldReadConfigurationClassFromClassPath() {\n+        MockitoConfiguration.overrideReturnValues(new ReturnValues() {\n+            public Object valueFor(InvocationOnMock invocation) {\n+                return \"foo\";\n+            }});\n+\n+        IMethods mock = mock(IMethods.class); \n+        assertEquals(\"foo\", mock.simpleMethod());\n+    }\n+}", "timestamp": 1231628452, "metainfo": ""}