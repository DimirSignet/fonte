{"sha": "10b3f4deea6a9c90e2a42e8872757af83e45c3ce", "log": "Test-Fix: Cannot mock a listener, because Mockito will get confused about the method that was stubbed.  --HG-- branch : issue148 extra : transplant_source : %3C2%F8%A3%B4%7F%21%CAmz%C1%FA%1E%84.%0F3%A9%7F%C3", "commit": "\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n package org.mockitousage.debugging;\n \n import static org.mockito.BDDMockito.given;\n-import static org.mockito.Matchers.contains;\n import static org.mockito.Matchers.eq;\n import static org.mockito.Matchers.isA;\n import static org.mockito.Mockito.doThrow;\n \n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.internal.matchers.Contains;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.matchers.InstanceOf;\n import org.mockito.invocation.InvocationListener;\n import org.mockitousage.debugging.VerboseLoggingOfInvocationsOnMockTest.ThirdPartyException;\n import org.mockitoutil.TestBase;\n \t@Test\n \tpublic void givenInvocationReturningValue_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n \t\t// given\n-\t\tInvocationListener listener = mock(InvocationListener.class);\n+\t\t// Cannot use a mockito-mock here: during stubbing, the listener will be called\n+\t\t// and mockito will confuse the mocks.\n+\t\tRememberingListener listener = new RememberingListener();\n \t\tFoo foo = mock(Foo.class, withSettings().callback(listener));\n \t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n \n \t\t// when\n \t\tfoo.giveMeSomeString(SOME_STRING_ARGUMENT);\n \n-\t\t// then\n-\t\tverify(listener).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),\n-\t\t\t\tcontains(getClass().getSimpleName().toString()));\n+\t\tassertHasBeenNotified(listener, new InstanceOf(PrintableInvocation.class),\n+\t\t\t\tnew Equals(SOME_RETURN_VALUE), new Contains(getClass().getSimpleName().toString()));\n \t}\n \n \t@Test\n \tpublic void givenInvocationReturningValue_shouldCallMultipleListeners() throws Exception {\n \t\t// given\n-\t\tInvocationListener listener1 = mock(InvocationListener.class);\n-\t\tInvocationListener listener2 = mock(InvocationListener.class);\n+\t\t// Cannot use a mockito-mock here: during stubbing, the listener will be called\n+\t\t// and mockito will confuse the mocks.\n+\t\tRememberingListener listener1 = new RememberingListener();\n+\t\tRememberingListener listener2 = new RememberingListener();\n \t\tFoo foo = mock(Foo.class, withSettings().callback(listener1).callback(listener2));\n \t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n \n \t\tfoo.giveMeSomeString(SOME_STRING_ARGUMENT);\n \n \t\t// then\n-\t\tverify(listener1).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),\n-\t\t\t\tisA(String.class));\n-\t\tverify(listener2).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),\n-\t\t\t\tisA(String.class));\n+\t\tassertHasBeenNotified(listener1, new InstanceOf(PrintableInvocation.class),\n+\t\t\t\tnew Equals(SOME_RETURN_VALUE), new Contains(getClass().getSimpleName().toString()));\n+\t\tassertHasBeenNotified(listener2, new InstanceOf(PrintableInvocation.class),\n+\t\t\t\tnew Equals(SOME_RETURN_VALUE), new Contains(getClass().getSimpleName().toString()));\n \t}\n \n \t@Test\n \t\t\t\t\tisA(String.class));\n \t\t}\n \t}\n+\t\n+\tprivate void assertHasBeenNotified(RememberingListener listener, InstanceOf m, Equals m2, Contains m3) {\n+\t\tassertThat(listener.invocation, m);\n+\t\tassertThat(listener.returnValue, m2);\n+\t\tassertThat(listener.locationOfStubbing, m3);\n+\t}\n+\n+\tstatic class RememberingListener implements InvocationListener {\n+\t\t\n+\t\tPrintableInvocation invocation;\n+\t\tObject returnValue;\n+\t\tString locationOfStubbing;\n+\n+\t\tpublic void invokingWithReturnValue(PrintableInvocation invocation, Object returnValue,\n+\t\t\t\tString locationOfStubbing) {\n+\t\t\tthis.invocation = invocation;\n+\t\t\tthis.returnValue = returnValue;\n+\t\t\tthis.locationOfStubbing = locationOfStubbing;\n+\t\t}\n+\n+\t\tpublic void invokingWithException(PrintableInvocation invocation, Exception exception, String locationOfStubbing) {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t\t\n+\t}\n }", "timestamp": 1298493023, "metainfo": ""}