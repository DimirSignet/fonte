{"sha": "427bc00158d56d9e11ac49c76104b40e4a6e4b66", "log": "Unfortunetly meaty checkin but things got out of hand during Easter... Further work on exposing an MockSettingsInfo. Encountered few obstacles and did some refactorings along the way. Stopped using the class array in few place in favor of a Collection - MockMaker interface has changed in due course. Fixed the javadoc a bit. There's still long way to get the MockSettings cleaned up but I'm getting there. The purpose is to avoid casting to our internal type (MockSettingsImpl) and use the information provided by the interface MockSettingsInfo. MockSettingsInfo is an interface exposed when we created MockMaker API.", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n      *\n      * @since 1.9.5\n      */\n-    MockSettings forwardTo(Object delegate) ;\n+    MockSettings forwardTo(Object delegate);\n }\n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n package org.mockito.internal;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.invocation.Invocation;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.invocation.MockitoInvocationHandler;\n+import org.mockito.mock.MockSettingsInfo;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n     private List<InvocationListener> invocationListeners;\n     private MockHandler<T> mockHandler;\n \n-    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsImpl settings) {\n+    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsInfo settings) {\n         this.mockHandler = mockHandler;\n         this.invocationListeners = settings.getInvocationListeners();\n     }\n         }\n \t}\n \n-    public MockSettingsImpl getMockSettings() {\n+    public MockSettingsInfo getMockSettings() {\n         return mockHandler.getMockSettings();\n     }\n \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  */\n package org.mockito.internal;\n \n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.invocation.Invocation;\n-import org.mockito.invocation.MockitoInvocationHandler;\n+import org.mockito.mock.MockSettingsInfo;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n     MatchersBinder matchersBinder = new MatchersBinder();\n     MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n \n-    private final MockSettingsImpl mockSettings;\n+    private final MockSettingsInfo mockSettings;\n \n-    public MockHandler(MockSettingsImpl mockSettings) {\n+    public MockHandler(MockSettingsInfo mockSettings) {\n         this.mockSettings = mockSettings;\n         this.mockingProgress = new ThreadSafeMockingProgress();\n         this.matchersBinder = new MatchersBinder();\n         this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n-    }\n-\n-    // for tests\n-    MockHandler() {\n-        this(new MockSettingsImpl());\n-    }\n-\n-    public MockHandler(MockHandlerInterface<T> oldMockHandler) {\n-        this(oldMockHandler.getMockSettings());\n     }\n \n     public Object handle(Invocation invocation) throws Throwable {\n         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n     }\n \n-    public MockSettingsImpl getMockSettings() {\n+    public MockSettingsInfo getMockSettings() {\n         return mockSettings;\n     }\n \n--- a/src/org/mockito/internal/MockHandlerInterface.java\n+++ b/src/org/mockito/internal/MockHandlerInterface.java\n import java.util.List;\n \n import org.mockito.Incubating;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.invocation.Invocation;\n import org.mockito.invocation.MockitoInvocationHandler;\n+import org.mockito.mock.MockSettingsInfo;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n @SuppressWarnings(\"unchecked\")\n public interface MockHandlerInterface<T> extends MockitoInvocationHandler {\n \n-    MockSettingsImpl getMockSettings();\n+    MockSettingsInfo getMockSettings();\n \n     VoidMethodStubbable<T> voidMethodStubbable(T mock);\n     \n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n     public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n-        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n+        T mock = mockUtil.createMock(classToMock, mockSettings);\n         mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n         return mock;\n     }\n--- a/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration.injection.filter;\n \n import org.mockito.internal.util.MockUtil;\n--- a/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n         if (isAnnotatedByMockOrSpy(field)) {\n             return instance;\n         } else if (isMockOrSpy(instance)) {\n-            mockUtil.redefineMockNameIfSurrogate(instance, field.getName());\n+            mockUtil.maybeRedefineMockName(instance, field.getName());\n             return instance;\n         }\n         return null;\n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.mock.MockSettingsInfo;\n \n+import java.util.Set;\n+\n /**\n  * A MockMaker that uses cglib to generate mocks on a JVM.\n  */\n public final class CglibMockMaker implements MockMaker {\n \n-    public <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n+    public <T> T createMock(Class<T> typeToMock, Set<Class> extraInterfaces,\n             MockitoInvocationHandler handler, MockSettingsInfo settings) {\n         MockHandlerInterface mockitoHandler = cast(handler);\n         return ClassImposterizer.INSTANCE.imposterise(\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.stubbing.Answer;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n import java.util.List;\n+import java.util.Set;\n+\n+import static org.mockito.internal.util.collections.Sets.newSet;\n \n @SuppressWarnings(\"unchecked\")\n public class MockSettingsImpl implements MockSettings {\n \n     private static final long serialVersionUID = 4475297236197939568L;\n-    private Class<?>[] extraInterfaces;\n+    private Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n     private String name;\n     private Object spiedInstance;\n     private Object delegatedInstance;\n         return this;\n     }\n \n-    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n+    public MockSettings extraInterfaces(Class... extraInterfaces) {\n         if (extraInterfaces == null || extraInterfaces.length == 0) {\n             new Reporter().extraInterfacesRequiresAtLeastOneInterface();\n         }\n \n-        for (Class<?> i : extraInterfaces) {\n+        for (Class i : extraInterfaces) {\n             if (i == null) {\n                 new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n             } else if (!i.isInterface()) {\n                 new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n             }\n         }\n-        this.extraInterfaces = extraInterfaces;\n+        this.extraInterfaces = newSet(extraInterfaces);\n         return this;\n     }\n \n         return mockName;\n     }\n \n-    public Class<?>[] getExtraInterfaces() {\n+    public MockName mockName() {\n+        return mockName;\n+    }\n+\n+    public Set<Class> getExtraInterfaces() {\n         return extraInterfaces;\n     }\n \n     }\n \n \tpublic MockSettings forwardTo(Object delegatedInstance) {\n-\t\tthis.delegatedInstance = delegatedInstance ;\n-\t\treturn defaultAnswer(new ForwardsInvocations(this.delegatedInstance)) ;\n+\t\tthis.delegatedInstance = delegatedInstance;\n+\t\treturn defaultAnswer(new ForwardsInvocations(this.delegatedInstance));\n \t}\n }\n \n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.jmock;\n \n import org.mockito.cglib.core.CodeGenerationException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.Collection;\n import java.util.List;\n \n import static org.mockito.internal.util.StringJoiner.join;\n     \n     public boolean canImposterise(Class<?> type) {\n         return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n+    }\n+\n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n+        return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n     }\n     \n     public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n+\n+import java.util.Collection;\n \n @SuppressWarnings(\"unchecked\")\n public class MockCreationValidator {\n         }\n     }\n \n-    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n+    public void validateExtraInterfaces(Class classToMock, Collection<Class> extraInterfaces) {\n         if (extraInterfaces == null) {\n             return;\n         }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.collections.ArrayUtils;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockito.mock.MockSettingsInfo;\n import org.mockito.plugins.MockMaker;\n \n import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n         this(new MockCreationValidator());\n     }\n \n-    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n+    public <T> T createMock(Class<T> classToMock, MockSettingsInfo settingsInfo) {\n+        MockSettingsImpl settings = (MockSettingsImpl) settingsInfo;\n         creationValidator.validateType(classToMock);\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n         creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n \n         InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n                 new MockHandler<T>(settings), settings);\n-        Class<?>[] extraInterfaces = prepareAncillaryTypes(settings);\n+        Set<Class> extraInterfaces = prepareAncillaryTypes(settings);\n         T mock = mockMaker.createMock(classToMock, extraInterfaces, mockHandler, settings);\n \n         Object spiedInstance = settings.getSpiedInstance();\n         return mock;\n     }\n \n-    private Class<?>[] prepareAncillaryTypes(MockSettingsImpl settings) {\n-        Class<?>[] interfaces = settings.getExtraInterfaces();\n+    private Set<Class> prepareAncillaryTypes(MockSettingsImpl settings) {\n+        Set<Class> interfaces = settings.getExtraInterfaces();\n \n-        Class<?>[] ancillaryTypes;\n-        if (settings.isSerializable()) {\n-            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n-        } else {\n-            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n+        Set<Class> ancillaryTypes = new HashSet<Class>(interfaces);\n+        if(settings.isSerializable()) {\n+            ancillaryTypes.add(Serializable.class);\n         }\n         if (settings.getSpiedInstance() != null) {\n-            ancillaryTypes = new ArrayUtils().concat(ancillaryTypes, MockitoSpy.class);\n+            ancillaryTypes.add(MockitoSpy.class);\n         }\n         return ancillaryTypes;\n     }\n \n     public <T> void resetMock(T mock) {\n         InvocationNotifierHandler oldHandler = (InvocationNotifierHandler) getMockHandler(mock);\n-        MockSettingsImpl settings = oldHandler.getMockSettings();\n+        MockSettingsInfo settings = oldHandler.getMockSettings();\n         InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n                 new MockHandler<T>(settings), settings);\n         mockMaker.resetMock(mock, newHandler, settings);\n         return getMockHandler(mock).getMockSettings().getMockName();\n     }\n \n-    public void redefineMockNameIfSurrogate(Object mock, String newName) {\n+    public void maybeRedefineMockName(Object mock, String newName) {\n         if (getMockName(mock).isSurrogate()) {\n             getMockHandler(mock).getMockSettings().redefineMockName(newName);\n         }\n--- a/src/org/mockito/internal/util/collections/ArrayUtils.java\n+++ b/src/org/mockito/internal/util/collections/ArrayUtils.java\n @SuppressWarnings(\"unchecked\")\n public class ArrayUtils {\n \n-    // TODO don't use typed arguments ?\n-    public Class<?>[] concat(Class<?>[] interfaces, Class<?>... clazz) {\n-        int interfacesCount = interfaces.length;\n-        int appendedCount = clazz.length;\n-        Class[] out = new Class[interfacesCount + appendedCount];\n-        System.arraycopy(interfaces, 0, out, 0, interfacesCount);\n-        System.arraycopy(clazz, 0, out, interfacesCount, appendedCount);\n-        return out;\n-    }\n-\n     public <T> boolean isEmpty(T[] array) {\n         return array == null || array.length == 0;\n     }\n--- a/src/org/mockito/internal/util/collections/Sets.java\n+++ b/src/org/mockito/internal/util/collections/Sets.java\n package org.mockito.internal.util.collections;\n \n \n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n import java.util.Set;\n+\n+import static java.util.Arrays.asList;\n \n public abstract class Sets {\n     public static Set<Object> newMockSafeHashSet(Iterable<Object> mocks) {\n     public static IdentitySet newIdentitySet() {\n         return new IdentitySet();\n     }\n+\n+    public static <T> Set<T> newSet(T ... elements) {\n+        if (elements == null) {\n+            throw new IllegalArgumentException(\"Expected an array of elements (or empty array) but received a null.\");\n+        }\n+        return new LinkedHashSet<T>(asList(elements));\n+    }\n }\n--- a/src/org/mockito/mock/MockSettingsInfo.java\n+++ b/src/org/mockito/mock/MockSettingsInfo.java\n package org.mockito.mock;\n \n import org.mockito.Incubating;\n+import org.mockito.internal.util.MockName;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.List;\n+import java.util.Set;\n \n /**\n- * Informs about the mock settings\n+ * Informs about the mock settings. An immutable view of {@link org.mockito.MockSettings}.\n  */\n @Incubating\n public interface MockSettingsInfo {\n \n     /**\n-     * if the mock is serializable\n+     * if the mock is serializable, see {@link org.mockito.MockSettings#serializable}.\n      */\n     boolean isSerializable();\n+\n+    /**\n+     * the invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n+     */\n+    List<InvocationListener> getInvocationListeners();\n+\n+    /**\n+     * the default answer for this mock, see {@link org.mockito.MockSettings#defaultAnswer}.\n+     */\n+    Answer getDefaultAnswer();\n+\n+    /**\n+     * the name of this mock, as printed on verification errors; see {@link org.mockito.MockSettings#name}.\n+     */\n+    MockName getMockName();\n+\n+    void redefineMockName(String newName);\n+\n+    Set<Class> getExtraInterfaces();\n+\n+    Object getSpiedInstance();\n+\n+    //TODO SF - forward needs to be consistently named with delegate\n+    //also figure this thing out.\n+    Object getDelegatedInstance();\n }\n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n import org.mockito.Incubating;\n import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.mock.MockSettingsInfo;\n+\n+import java.util.Set;\n \n /**\n  * The facility to create mocks.\n      */\n     <T> T createMock(\n             Class<T> typeToMock,\n-            Class<?>[] extraInterfaces,\n+            Set<Class> extraInterfaces,\n             MockitoInvocationHandler handler,\n             MockSettingsInfo settings\n     );\n \n     /**\n-     * Returns the handler for the {@code mock}. The passed mock object is guaranteed to be a Mockito mock,\n-     * created by the {@link #createMock} method.\n+     * Returns the handler for the {@code mock}.\n      *\n      * @param mock The mock instance.\n-     * @return should never return null.\n+     * @return may return null - it means that there is no handler attached to provided object.\n+     *   This means the passed object is not really a Mockito mock.\n      * @since 1.9.5\n      */\n     MockitoInvocationHandler getHandler(Object mock);\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n \t\t// given\n \t\tInvocation invocation = new InvocationBuilder().toInvocation();\n \t\t@SuppressWarnings(\"rawtypes\")\n-\t\tMockHandler<?> handler = new MockHandler();\n+\t\tMockHandler<?> handler = new MockHandler(new MockSettingsImpl());\n \t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n \t\thandler.matchersBinder = new MatchersBinder() {\n \t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n         mockSettingsImpl.extraInterfaces(List.class, Set.class);\n         \n         //then\n-        assertEquals(List.class, mockSettingsImpl.getExtraInterfaces()[0]);\n-        assertEquals(Set.class, mockSettingsImpl.getExtraInterfaces()[1]);\n+        assertEquals(2, mockSettingsImpl.getExtraInterfaces().size());\n+        assertTrue(mockSettingsImpl.getExtraInterfaces().contains(List.class));\n+        assertTrue(mockSettingsImpl.getExtraInterfaces().contains(Set.class));\n     }\n \n     @Test\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import static java.util.Arrays.asList;\n \n @SuppressWarnings(\"unchecked\")\n public class MockCreationValidatorTest extends TestBase {\n     public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n         try {\n             //when\n-            validator.validateExtraInterfaces(IMethods.class, new Class<?>[] {IMethods.class});\n+            validator.validateExtraInterfaces(IMethods.class, (Collection) asList(IMethods.class));\n             fail();\n         } catch (MockitoException e) {\n             //then\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n import org.mockitoutil.TestBase;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n+import java.util.Set;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n         public void validateType(Class classToMock) {\n             typeValidated = true;\n         }\n-        public void validateExtraInterfaces(Class classToMock, Class ... interfaces) {\n+        public void validateExtraInterfaces(Class classToMock, Collection<Class> interfaces) {\n             extraInterfacesValidated = true;\n         }\n     }\n     @Test\n     public void should_redefine_MockName_if_surrogate() {\n         List mock = Mockito.mock(List.class);\n-        mockUtil.redefineMockNameIfSurrogate(mock, \"newName\");\n+        mockUtil.maybeRedefineMockName(mock, \"newName\");\n \n         Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"newName\");\n     }\n     @Test\n     public void should_not_redefine_MockName_if_surrogate() {\n         List mock = Mockito.mock(List.class, \"original\");\n-        mockUtil.redefineMockNameIfSurrogate(mock, \"newName\");\n+        mockUtil.maybeRedefineMockName(mock, \"newName\");\n \n         Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"original\");\n     }", "timestamp": 1333987116, "metainfo": ""}