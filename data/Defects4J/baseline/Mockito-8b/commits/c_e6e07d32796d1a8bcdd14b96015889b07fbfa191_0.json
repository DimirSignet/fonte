{"sha": "e6e07d32796d1a8bcdd14b96015889b07fbfa191", "log": "more work on javadocs simplified the stack filtering code and made it working on different vms (linux) - thanks for help Hudson  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401463", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n     /**\n      * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n      * <p>\n-     * As usual you are going to read the partial mock warning:\n-     * Object oriented programming is more less tackling complexity by dividing the complexity and placing it in separate, specific objects.\n-     * Partial mock is a sign that the code is not well designed. \n-     * It usually means that the complexity has been moved to a different method on the same object.\n-     * Partial mocks are useful when dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * I wouldn't use them for new code.\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * Trust me, this is not the way you want to design your application. \n+     * <p>\n+     * However, there are rare cases when partial mocks come handy: \n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * I wouldn't use partial mocks in new code, though.\n      * <p>\n      * Enough warnings about partial mocks, see an example how spiedInstance() works:\n      * <pre>\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n      * <p>\n      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n      * <p>\n-     * Spying on real objects is often associated with \"partial mocking\" concept. \n-     * However, Mockito spies are not partial mocks. Mockito spy is meant to help testing other classes - not the spy itself. \n-     * Therefore spy will not help if you intend to verify if method calls other method on the same object. \n-     * In this case I suggest being OO/SRPy (for example you might extract new class/interface...)\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * Trust me, this is not the way you want to design your application. \n+     * <p>\n+     * However, there are rare cases when partial mocks come handy: \n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * I wouldn't use partial mocks in new code, though.\n      * <p>\n      * Example:\n      * \n     /**\n      * Use doCallRealMethod() when you want to call the real implementation of a method.\n      * <p>\n-     *      * As usual you are going to read the partial mock warning:\n-     * Object oriented programming is more less tackling complexity by dividing the complexity and placing it in separate, specific objects.\n-     * Partial mock is a sign that the code is not well designed. \n-     * It usually means that the complexity has been moved to a different method on the same object.\n-     * Partial mocks are useful when dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * I wouldn't use them for new code.\n-\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * Trust me, this is not the way you want to design your application. \n+     * <p>\n+     * However, there are rare cases when partial mocks come handy: \n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * I wouldn't use partial mocks in new code, though.\n+     * <p>\n+     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks\n      * <p>\n      * Example:\n      * <pre>\n      *   // this will call the real implementation of Foo.someVoidMethod()\n      *   mock.someVoidMethod();\n      * </pre>\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n      *\n      * @return stubber - to select a method for stubbing\n      */\n      *      }})\n      *  .when(mock).someMethod();\n      * </pre>\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n      * \n      * @param answer to answer when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      *   //clear() does nothing, so the list still contains \"one\"\n      *   spy.clear();\n      * </pre>\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n      *   \n      * @return stubber - to select a method for stubbing\n      */\n      * \n      * Above scenarios shows a tradeoff of Mockito's ellegant syntax. Note that the scenarios are very rare, though. \n      * Spying should be sporadic and overriding exception-stubbing is very rare.  \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n      * \n      * @param toBeReturned to be returned when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      * but only those that you are interested in testing in order.\n      * <p>\n      * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n-     *\n+     * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * \n      * @param mocks to be verified in order\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n     public Location() {\n         StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n         StackTraceFilter filter = new StackTraceFilter();\n-        this.firstTraceElement = filter.filter(stackTrace, 1)[0];\n+        this.firstTraceElement = filter.filter(stackTrace, false)[0];\n     }\n \n     @Override\n--- a/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java\n+++ b/src/org/mockito/internal/exceptions/base/ConditionalStackTraceFilter.java\n         if (!config.cleansStackTrace()) {\n             return;\n         }\n-        StackTraceElement[] filtered = filter.filter(throwable.getStackTrace(), 0);\n+        StackTraceElement[] filtered = filter.filter(throwable.getStackTrace(), true);\n         throwable.setStackTrace(filtered);\n     }\n }\n--- a/src/org/mockito/internal/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/internal/exceptions/base/StackTraceFilter.java\n      * [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+]\n      * Basically removes all bad from the middle. If any good are in the middle of bad those are also removed. \n      */\n-    public StackTraceElement[] filter(StackTraceElement[] target, int startWith) {\n+    public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n         //TODO: after 1.8 profile\n         List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n         \n         int lastBad = -1;\n         int firstBad = -1;\n-        for (int i = startWith; i < unfilteredStackTrace.size(); i++) {\n+        for (int i = 0; i < unfilteredStackTrace.size(); i++) {\n             if (!this.isBad(unfilteredStackTrace.get(i))) {\n                 continue;\n             }\n         }\n         \n         List<StackTraceElement> top;\n-        if (firstBad != -1) {\n-            top = unfilteredStackTrace.subList(startWith, firstBad);\n+        if (keepTop && firstBad != -1) {\n+            top = unfilteredStackTrace.subList(0, firstBad);\n         } else {\n             top = new LinkedList<StackTraceElement>();\n         }\n--- a/src/org/mockito/internal/progress/NewOngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/NewOngoingStubbing.java\n      */\n     NewOngoingStubbing<T> thenThrow(Throwable... throwables);\n \n-    /**\n-     * TODO: partial mocks warning\n-     * Sets the real implementation to be called when the method is called on a mock object.  E.g.:\n+    /**     \n+     * Sets the real implementation to be called when the method is called on a mock object.\n+     * <p>\n+     * TODO: polish the partial mocks warning\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * Trust me, this is not the way you want to design your application. \n+     * <p>\n+     * However, there are rare cases when partial mocks come handy: \n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * I wouldn't use partial mocks in new code, though.\n+     * <p>\n      * <pre>\n      * when(mock.someMethod()).thenCallRealMethod();\n      * </pre>\n--- a/test/org/mockito/internal/exceptions/base/StackTraceFilterTest.java\n+++ b/test/org/mockito/internal/exceptions/base/StackTraceFilterTest.java\n             \"List$$EnhancerByMockitoWithCGLIB$$2c406024\"\n         ).toTraceArray();\n         \n-        StackTraceElement[] filtered = filter.filter(t, 0);\n+        StackTraceElement[] filtered = filter.filter(t, false);\n         \n         assertThat(filtered, hasOnlyThoseClasses(\"MockitoExampleTest\"));\n     }\n             \"org.mockito.Mockito\"\n         ).toTraceArray();\n             \n-        StackTraceElement[] filtered = filter.filter(t, 0);\n+        StackTraceElement[] filtered = filter.filter(t, false);\n         \n         assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\"));\n     }\n                 \"org.mockito.Mockito\"\n         ).toTraceArray();\n         \n-        StackTraceElement[] filtered = filter.filter(t, 0);\n+        StackTraceElement[] filtered = filter.filter(t, false);\n         \n         assertThat(filtered, hasOnlyThoseClasses(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n     }\n                 \"org.mockito.Mockito\"\n         ).toTraceArray();\n         \n-        StackTraceElement[] filtered = filter.filter(t, 0);\n+        StackTraceElement[] filtered = filter.filter(t, false);\n         \n         assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"junit.stuff\", \"org.mockito.runners.Runner\"));\n     }\n                 \"org.test.MockitoSampleTest\"\n         ).toTraceArray();\n         \n-        StackTraceElement[] filtered = filter.filter(t, 0);\n+        StackTraceElement[] filtered = filter.filter(t, false);\n         \n         assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"org.mockito.internal.runners.Runner\"));\n     }\n     \n     @Test\n-    public void shouldStartFilteringFromIndex() {\n+    public void shouldStartFilteringAndKeepTop() {\n         //given\n         StackTraceElement[] t = new TraceBuilder().classes(\n                 \"org.test.Good\",\n                 \"org.test.MockitoSampleTest\"\n         ).toTraceArray();\n         \n-        int startIndex = 1;\n-        \n         //when\n-        StackTraceElement[] filtered = filter.filter(t, startIndex);\n+        StackTraceElement[] filtered = filter.filter(t, true);\n         \n         //then\n-        assertThat(filtered, hasOnlyThoseClasses(\"org.test.Good\"));\n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"org.test.Good\"));\n     }\n \n     @Test\n-    public void shouldKeepGoodTraceFromTheTopBecauseSpiesSometimesThrowExceptions() {\n+    public void shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions() {\n         StackTraceElement[] t = new TraceBuilder().classes(\n                 \"org.good.Trace\",\n                 \"org.yet.another.good.Trace\",\n                 \"org.test.MockitoSampleTest\"\n         ).toTraceArray();\n         \n-        StackTraceElement[] filtered = filter.filter(t, 0);\n+        StackTraceElement[] filtered = filter.filter(t, true);\n         \n         assertThat(filtered, hasOnlyThoseClasses(\n                 \"org.test.MockitoSampleTest\",\n     @Test\n     public void shouldReturnEmptyArrayWhenInputIsEmpty() throws Exception {\n         //when\n-        StackTraceElement[] filtered = filter.filter(new StackTraceElement[0], 0);\n+        StackTraceElement[] filtered = filter.filter(new StackTraceElement[0], false);\n         //then\n         assertEquals(0, filtered.length);\n     }", "timestamp": 1244067152, "metainfo": ""}