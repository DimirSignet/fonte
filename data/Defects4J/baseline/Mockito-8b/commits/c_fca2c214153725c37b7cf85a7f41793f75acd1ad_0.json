{"sha": "fca2c214153725c37b7cf85a7f41793f75acd1ad", "log": "removed some TODOs and @Ignore's  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401171", "commit": "\n--- a/src/org/mockito/IMockitoConfiguration.java\n+++ b/src/org/mockito/IMockitoConfiguration.java\n  * <p>\n  * <b>org.mockito.MockitoConfiguration</b> must implement IMockitoConfiguration or extend {@link DefaultMockitoConfiguration}\n  * <p>\n- *  \n+ * Mockito will store single instance of org.mockito.MockitoConfiguration per thread (using ThreadLocal). \n+ * For sanity of your tests, don't make the implementation stateful.   \n  * \n  */\n public interface IMockitoConfiguration {\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n      * @return\n      */\n     @SuppressWarnings({\"unchecked\"})\n-    public IMockitoConfiguration loadConfiguration(IMockitoConfiguration defaultConfiguration) {\n+    public IMockitoConfiguration loadConfiguration() {\n         //Trying to get config from classpath\n         Class configClass = null;\n         try {\n             configClass = (Class) Class.forName(\"org.mockito.MockitoConfiguration\");\n         } catch (ClassNotFoundException e) {\n             //that's ok, it means there is no global config, using default one. \n-            return defaultConfiguration;\n+            return null;\n         }\n         \n         try {\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n                 return Configuration.instance().getReturnValues();\n             }\n         };\n-        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration(defaultConfiguration);\n-        return config;\n+        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n+        if (config != null) {\n+            return config;\n+        } else {\n+            return defaultConfiguration;\n+        }\n     }\n \n     public ReturnValues getReturnValues() {\n--- a/test/org/junit/mockito/ExperimentalMockitoJUnitRunnerTest.java\n+++ b/test/org/junit/mockito/ExperimentalMockitoJUnitRunnerTest.java\n public class ExperimentalMockitoJUnitRunnerTest extends TestBase {\n     \n     @Mock private IMethods mock;\n+    \n     private ExperimentalMockitoJUnitRunner runner;\n     private MockitoLoggerStub loggerStub;\n     private RunNotifier notifier;\n--- a/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n         } catch (UnfinishedVerificationException e) {}\n     }\n     \n-    @Ignore\n+    @Ignore(\"let's not implement it...\")\n     @Test\n     public void shouldFailAndShowWhereMatchersAreMisused() {\n         misplacedArgumentMatcher();\n--- a/test/org/mockitousage/misuse/RestrictedObjectMethodsTest.java\n+++ b/test/org/mockitousage/misuse/RestrictedObjectMethodsTest.java\n     @Ignore\n     @Test\n     public void shouldNotAllowVerifyingRestrictedMethods() {\n-        //TODO exception message should mention those methods are not verifiable\n+        //TODO after 1.7 exception message should mention those methods are not verifiable\n         verify(mock).toString();\n         verify(mock).hashCode();\n         verify(mock).equals(null);", "timestamp": 1231629239, "metainfo": ""}