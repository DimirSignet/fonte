{"sha": "60f0c0c767879989d40d7846054cfc1df64e76af", "log": "Started using the new Invocation interface where possible.", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n+import org.mockito.invocation.Invocation;\n import org.mockito.listeners.InvocationListener;\n \n import java.lang.reflect.Field;\n                 ));\n     }\n \n-    public void noMoreInteractionsWanted(InvocationImpl undesired, List<VerificationAwareInvocation> invocations) {\n+    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n         ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n         String scenario = scenarioPrinter.print(invocations);\n \n         ));\n     }\n \n-    public void noMoreInteractionsWantedInOrder(InvocationImpl undesired) {\n+    public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n--- a/src/org/mockito/internal/InOrderImpl.java\n+++ b/src/org/mockito/internal/InOrderImpl.java\n import org.mockito.InOrder;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.InOrderWrapper;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n /**\n         return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));\n     }\n \n-    public boolean isVerified(InvocationImpl i) {\n+    public boolean isVerified(Invocation i) {\n         return inOrderContext.isVerified(i);\n     }\n \n-    public void markVerified(InvocationImpl i) {\n+    public void markVerified(Invocation i) {\n         inOrderContext.markVerified(i);\n     }\n \n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.progress.IOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.*;\n import org.mockito.verification.VerificationMode;\n \n      * For testing purposes only. Is not the part of main API.\n      * @return last invocation\n      */\n-    public InvocationImpl getLastInvocation() {\n+    public Invocation getLastInvocation() {\n         OngoingStubbingImpl ongoingStubbing = ((OngoingStubbingImpl) mockingProgress.pullOngoingStubbing());\n-        List<InvocationImpl> allInvocations = ongoingStubbing.getRegisteredInvocations();\n+        List<Invocation> allInvocations = ongoingStubbing.getRegisteredInvocations();\n         return allInvocations.get(allInvocations.size()-1);\n     }\n \n     public Object[] ignoreStubs(Object... mocks) {\n         for (Object m : mocks) {\n             InvocationContainer invocationContainer = new MockUtil().getMockHandler(m).getInvocationContainer();\n-            List<InvocationImpl> ins = invocationContainer.getInvocations();\n-            for (InvocationImpl in : ins) {\n+            List<Invocation> ins = invocationContainer.getInvocations();\n+            for (Invocation in : ins) {\n                 if (in.stubInfo() != null) {\n                     in.ignoreForVerification();\n                 }\n--- a/src/org/mockito/internal/debugging/FindingsListener.java\n+++ b/src/org/mockito/internal/debugging/FindingsListener.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public interface FindingsListener {\n-    void foundStubCalledWithDifferentArgs(InvocationImpl unused, InvocationMatcher unstubbed);\n+    void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed);\n \n-    void foundUnusedStub(InvocationImpl unused);\n+    void foundUnusedStub(Invocation unused);\n \n     void foundUnstubbed(InvocationMatcher unstubbed);\n }\n--- a/src/org/mockito/internal/debugging/LoggingListener.java\n+++ b/src/org/mockito/internal/debugging/LoggingListener.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.invocation.Invocation;\n \n import static org.mockito.internal.util.StringJoiner.join;\n \n         this.logger = logger;\n     }\n \n-    public void foundStubCalledWithDifferentArgs(InvocationImpl unused, InvocationMatcher unstubbed) {\n+    public void foundStubCalledWithDifferentArgs(Invocation unused, InvocationMatcher unstubbed) {\n         logger.log(join(\n                 \" *** Stubbing warnings from Mockito: *** \",\n                 \"\",\n                 \"\"));\n     }\n \n-    public void foundUnusedStub(InvocationImpl unused) {\n+    public void foundUnusedStub(Invocation unused) {\n         logger.log(\"This stubbing was never used   \" + unused.getLocation() + \"\\n\");\n     }\n \n--- a/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+++ b/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.UnusedStubsFinder;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n \n     public String printInvocations(Object ... mocks) {\n         String out = \"\";\n-        List<InvocationImpl> invocations = allInvocationsFinder.find(asList(mocks));\n+        List<Invocation> invocations = allInvocationsFinder.find(asList(mocks));\n         out += line(\"********************************\");\n         out += line(\"*** Mockito interactions log ***\");\n         out += line(\"********************************\");\n--- a/src/org/mockito/internal/debugging/WarningsCollector.java\n+++ b/src/org/mockito/internal/debugging/WarningsCollector.java\n  */\n package org.mockito.internal.debugging;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.UnusedStubsFinder;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n import org.mockito.internal.listeners.CollectCreatedMocks;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.invocation.Invocation;\n \n import java.util.LinkedList;\n import java.util.List;\n     }\n \n     public String getWarnings() {\n-        List<InvocationImpl> unused = new UnusedStubsFinder().find(createdMocks);\n-        List<InvocationImpl> all = new AllInvocationsFinder().find(createdMocks);\n+        List<Invocation> unused = new UnusedStubsFinder().find(createdMocks);\n+        List<Invocation> all = new AllInvocationsFinder().find(createdMocks);\n         List<InvocationMatcher> allInvocationMatchers = InvocationMatcher.createFrom(all);\n \n         String warnings = new WarningsPrinterImpl(unused, allInvocationMatchers, false).print();\n--- a/src/org/mockito/internal/debugging/WarningsFinder.java\n+++ b/src/org/mockito/internal/debugging/WarningsFinder.java\n \n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n import java.util.Iterator;\n import java.util.LinkedList;\n \n @SuppressWarnings(\"unchecked\")\n public class WarningsFinder {\n-    private final List<InvocationImpl> baseUnusedStubs;\n+    private final List<Invocation> baseUnusedStubs;\n     private final List<InvocationMatcher> baseAllInvocations;\n \n-    public WarningsFinder(List<InvocationImpl> unusedStubs, List<InvocationMatcher> allInvocations) {\n+    public WarningsFinder(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations) {\n         this.baseUnusedStubs = unusedStubs;\n         this.baseAllInvocations = allInvocations;\n     }\n     \n     public void find(FindingsListener findingsListener) {\n-        List<InvocationImpl> unusedStubs = new LinkedList(this.baseUnusedStubs);\n+        List<Invocation> unusedStubs = new LinkedList(this.baseUnusedStubs);\n         List<InvocationMatcher> allInvocations = new LinkedList(this.baseAllInvocations);\n \n-        Iterator<InvocationImpl> unusedIterator = unusedStubs.iterator();\n+        Iterator<Invocation> unusedIterator = unusedStubs.iterator();\n         while(unusedIterator.hasNext()) {\n-            InvocationImpl unused = unusedIterator.next();\n+            Invocation unused = unusedIterator.next();\n             Iterator<InvocationMatcher> unstubbedIterator = allInvocations.iterator();\n             while(unstubbedIterator.hasNext()) {\n                 InvocationMatcher unstubbed = unstubbedIterator.next();\n--- a/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n import org.mockito.internal.util.SimpleMockitoLogger;\n+import org.mockito.invocation.Invocation;\n \n public class WarningsPrinterImpl {\n \n     private final boolean warnAboutUnstubbed;\n     private WarningsFinder finder;\n \n-    public WarningsPrinterImpl(List<InvocationImpl> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n+    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n         this(unusedStubs, unstubbedInvocations, false);\n     }\n \n-    public WarningsPrinterImpl(List<InvocationImpl> unusedStubs, List<InvocationMatcher> allInvocations, boolean warnAboutUnstubbed) {\n+    public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> allInvocations, boolean warnAboutUnstubbed) {\n         this(warnAboutUnstubbed, new WarningsFinder(unusedStubs, allInvocations));\n     }\n \n--- a/src/org/mockito/internal/invocation/ArgumentsComparator.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsComparator.java\n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.MatcherDecorator;\n import org.mockito.internal.matchers.VarargMatcher;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class ArgumentsComparator {\n-    public boolean argumentsMatch(InvocationMatcher invocationMatcher, InvocationImpl actual) {\n+    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n         Object[] actualArgs = actual.getArguments();\n         return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);\n     }\n     }\n \n     //ok, this method is a little bit messy but the vararg business unfortunately is messy...      \n-    private boolean varArgsMatch(InvocationMatcher invocationMatcher, InvocationImpl actual) {\n+    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n         if (!actual.getMethod().isVarArgs()) {\n             //if the method is not vararg forget about it\n             return false;\n--- a/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n+++ b/src/org/mockito/internal/invocation/CapturesArgumensFromInvocation.java\n package org.mockito.internal.invocation;\n \n \n+import org.mockito.invocation.Invocation;\n+\n public interface CapturesArgumensFromInvocation {\n     \n-    void captureArgumentsFrom(InvocationImpl i);\n+    void captureArgumentsFrom(Invocation i);\n     \n }\n--- a/src/org/mockito/internal/invocation/InvocationMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationMarker.java\n import java.util.List;\n \n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class InvocationMarker {\n \n-    public void markVerified(List<InvocationImpl> invocations, CapturesArgumensFromInvocation wanted) {\n-        for (InvocationImpl invocation : invocations) {\n+    public void markVerified(List<Invocation> invocations, CapturesArgumensFromInvocation wanted) {\n+        for (Invocation invocation : invocations) {\n             markVerified(invocation, wanted);\n         }\n     }\n \n-\tpublic void markVerified(InvocationImpl invocation, CapturesArgumensFromInvocation wanted) {\n+\tpublic void markVerified(Invocation invocation, CapturesArgumensFromInvocation wanted) {\n \t\tinvocation.markVerified();\n \t\twanted.captureArgumentsFrom(invocation);\n \t}\n \n-    public void markVerifiedInOrder(List<InvocationImpl> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {\n+    public void markVerifiedInOrder(List<Invocation> chunk, CapturesArgumensFromInvocation wanted, InOrderContext context) {\n         markVerified(chunk, wanted);\n         \n         for (InvocationImpl i : chunk) {\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.internal.reporting.PrintSettings;\n+import org.mockito.invocation.Invocation;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcher implements PrintableInvocation, CapturesArgumensFromInvocation, Serializable {\n \n     private static final long serialVersionUID = -3047126096857467610L;\n-    private final InvocationImpl invocation;\n+    private final Invocation invocation;\n     private final List<Matcher> matchers;\n \n-    public InvocationMatcher(InvocationImpl invocation, List<Matcher> matchers) {\n+    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n         this.invocation = invocation;\n         if (matchers.isEmpty()) {\n             this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n         }\n     }\n     \n-    public InvocationMatcher(InvocationImpl invocation) {\n+    public InvocationMatcher(Invocation invocation) {\n         this(invocation, Collections.<Matcher>emptyList());\n     }\n \n         return invocation.getMethod();\n     }\n     \n-    public InvocationImpl getInvocation() {\n+    public Invocation getInvocation() {\n         return this.invocation;\n     }\n     \n         return new PrintSettings().print(matchers, invocation);\n     }\n \n-    public boolean matches(InvocationImpl actual) {\n+    public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n                 && hasSameMethod(actual)\n                 && new ArgumentsComparator().argumentsMatch(this, actual);\n      * similar means the same method name, same mock, unverified \n      * and: if arguments are the same cannot be overloaded\n      */\n-    public boolean hasSimilarMethod(InvocationImpl candidate) {\n+    public boolean hasSimilarMethod(Invocation candidate) {\n         String wantedMethodName = getMethod().getName();\n         String currentMethodName = candidate.getMethod().getName();\n         \n         return !overloadedButSameArgs;\n     }\n \n-    public boolean hasSameMethod(InvocationImpl candidate) {\n+    public boolean hasSameMethod(Invocation candidate) {\n         //not using method.equals() for 1 good reason:\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         return invocation.getLocation();\n     }\n \n-    public void captureArgumentsFrom(InvocationImpl i) {\n+    public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n             if (m instanceof CapturesArguments && i.getArguments().length > k) {\n         }\n     }\n \n-    public static List<InvocationMatcher> createFrom(List<InvocationImpl> invocations) {\n+    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();\n \n-        for (InvocationImpl i : invocations) {\n+        for (Invocation i : invocations) {\n             out.add(new InvocationMatcher(i));\n         }\n \n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class InvocationsFinder {\n \n-    public List<InvocationImpl> findInvocations(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n+    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n         return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n     }\n \n-    public List<InvocationImpl> findAllMatchingUnverifiedChunks(List<InvocationImpl> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {\n-        List<InvocationImpl> unverified = removeVerifiedInOrder(invocations, orderingContext);\n+    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext orderingContext) {\n+        List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);\n         return ListUtil.filter(unverified, new RemoveNotMatching(wanted));\n     }\n \n      * if wanted is 1 and mode is times(x), where x != 2 then returns\n      * 1,1,1\n      */\n-    public List<InvocationImpl> findMatchingChunk(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n-        List<InvocationImpl> unverified = removeVerifiedInOrder(invocations, context);\n-        List<InvocationImpl> firstChunk = getFirstMatchingChunk(wanted, unverified);\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        List<Invocation> unverified = removeVerifiedInOrder(invocations, context);\n+        List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n         \n         if (wantedCount != firstChunk.size()) {\n             return this.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n         }\n     }\n \n-    private List<InvocationImpl> getFirstMatchingChunk(InvocationMatcher wanted, List<InvocationImpl> unverified) {\n-        List<InvocationImpl> firstChunk = new LinkedList<InvocationImpl>();\n-        for (InvocationImpl invocation : unverified) {\n+    private List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {\n+        List<Invocation> firstChunk = new LinkedList<Invocation>();\n+        for (Invocation invocation : unverified) {\n             if (wanted.matches(invocation)) {\n                 firstChunk.add(invocation);\n             } else if (!firstChunk.isEmpty()) {\n         return firstChunk;\n     }\n     \n-    public InvocationImpl findFirstMatchingUnverifiedInvocation( List<InvocationImpl> invocations, InvocationMatcher wanted, InOrderContext context ){\n-        for( InvocationImpl invocation : removeVerifiedInOrder( invocations, context )){\n+    public Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){\n+        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){\n             if( wanted.matches( invocation )){\n                 return invocation;\n             }\n         return null;\n     }\n     \n-    public InvocationImpl findSimilarInvocation(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n-        InvocationImpl firstSimilar = null;\n+    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n+        Invocation firstSimilar = null;\n         for (InvocationImpl invocation : invocations) {\n             if (!wanted.hasSimilarMethod(invocation)) {\n                 continue;\n         return firstSimilar;\n     }\n     \n-    public InvocationImpl findFirstUnverified(List<InvocationImpl> invocations) {\n+    public Invocation findFirstUnverified(List<Invocation> invocations) {\n         return findFirstUnverified(invocations, null);\n     }\n     \n-    InvocationImpl findFirstUnverified(List<InvocationImpl> invocations, Object mock) {\n-        for (InvocationImpl i : invocations) {\n+    Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {\n+        for (Invocation i : invocations) {\n             boolean mockIsValid = mock == null || mock == i.getMock();\n             if (!i.isVerified() && mockIsValid) {\n                 return i;\n         return null;\n     }\n \n-    public LocationImpl getLastLocation(List<InvocationImpl> invocations) {\n+    public LocationImpl getLastLocation(List<Invocation> invocations) {\n         if (invocations.isEmpty()) {\n             return null;\n         } else {\n-            InvocationImpl last = invocations.get(invocations.size() - 1);\n+            Invocation last = invocations.get(invocations.size() - 1);\n             return last.getLocation();\n         }\n     }\n     \n-    public InvocationImpl findPreviousVerifiedInOrder(List<InvocationImpl> invocations, InOrderContext context) {\n-        LinkedList<InvocationImpl> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));\n+    public InvocationImpl findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n+        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));\n         \n         if (verifiedOnly.isEmpty()) {\n             return null;\n         }\n     }\n     \n-    private List<InvocationImpl> removeVerifiedInOrder(List<InvocationImpl> invocations, InOrderContext orderingContext) {\n-        List<InvocationImpl> unverified = new LinkedList<InvocationImpl>();\n-        for (InvocationImpl i : invocations) {\n+    private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations, InOrderContext orderingContext) {\n+        List<Invocation> unverified = new LinkedList<Invocation>();\n+        for (Invocation i : invocations) {\n             if (orderingContext.isVerified(i)) {\n                 unverified.clear();\n             } else {\n         return unverified;\n     }\n     \n-    private class RemoveNotMatching implements Filter<InvocationImpl> {\n+    private class RemoveNotMatching implements Filter<Invocation> {\n         private final InvocationMatcher wanted;\n \n         private RemoveNotMatching(InvocationMatcher wanted) {\n             this.wanted = wanted;\n         }\n \n-        public boolean isOut(InvocationImpl invocation) {\n+        public boolean isOut(Invocation invocation) {\n             return !wanted.matches(invocation);\n         }\n     }\n \n-    private class RemoveUnverifiedInOrder implements Filter<InvocationImpl> {\n+    private class RemoveUnverifiedInOrder implements Filter<Invocation> {\n         private final InOrderContext orderingContext;\n \n         public RemoveUnverifiedInOrder(InOrderContext orderingContext) {\n             this.orderingContext = orderingContext;\n         }\n \n-        public boolean isOut(InvocationImpl invocation) {\n+        public boolean isOut(Invocation invocation) {\n             return !orderingContext.isVerified(invocation);\n         }\n     }\n      * @param context\n      * @param orderedInvocations\n      */\n-    public InvocationImpl findFirstUnverifiedInOrder(InOrderContext context, List<InvocationImpl> orderedInvocations) {\n-        InvocationImpl candidate = null;\n-        for(InvocationImpl i : orderedInvocations) {\n+    public Invocation findFirstUnverifiedInOrder(InOrderContext context, List<Invocation> orderedInvocations) {\n+        Invocation candidate = null;\n+        for(Invocation i : orderedInvocations) {\n             if (!context.isVerified(i)) {\n                 candidate = candidate != null ? candidate : i;\n             } else {\n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.invocation.Invocation;\n \n import java.io.Serializable;\n import java.util.List;\n \n     private static final long serialVersionUID = -311433939339443463L;\n \n-    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, InvocationImpl invocation) {\n+    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n         List<LocalizedMatcher> lastMatchers = argumentMatcherStorage.pullLocalizedMatchers();\n         validateMatchers(invocation, lastMatchers);\n \n         return invocationWithMatchers;\n     }\n \n-    private void validateMatchers(InvocationImpl invocation, List<LocalizedMatcher> lastMatchers) {\n+    private void validateMatchers(Invocation invocation, List<LocalizedMatcher> lastMatchers) {\n         if (!lastMatchers.isEmpty()) {\n             int recordedMatchersSize = lastMatchers.size();\n             int expectedMatchersSize = invocation.getArguments().length;\n--- a/src/org/mockito/internal/invocation/UnusedStubsFinder.java\n+++ b/src/org/mockito/internal/invocation/UnusedStubsFinder.java\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.*;\n \n      * \n      * @param mocks\n      */\n-    public List<InvocationImpl> find(List<?> mocks) {\n-        List<InvocationImpl> unused = new LinkedList<InvocationImpl>();\n+    public List<Invocation> find(List<?> mocks) {\n+        List<Invocation> unused = new LinkedList<Invocation>();\n         for (Object mock : mocks) {\n             MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(mock);\n             List<StubbedInvocationMatcher> fromSingleMock = handler.getInvocationContainer().getStubbedInvocations();\n--- a/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.*;\n \n      * @param mocks mocks\n      * @return invocations\n      */\n-    public List<InvocationImpl> find(List<?> mocks) {\n-        Set<InvocationImpl> invocationsInOrder = new TreeSet<InvocationImpl>(new SequenceNumberComparator());\n+    public List<Invocation> find(List<?> mocks) {\n+        Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n         for (Object mock : mocks) {\n             MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(mock);\n-            List<InvocationImpl> fromSingleMock = handler.getInvocationContainer().getInvocations();\n+            List<Invocation> fromSingleMock = handler.getInvocationContainer().getInvocations();\n             invocationsInOrder.addAll(fromSingleMock);\n         }\n         \n         return new LinkedList<InvocationImpl>(invocationsInOrder);\n     }\n \n-    private final class SequenceNumberComparator implements Comparator<InvocationImpl> {\n-        public int compare(InvocationImpl o1, InvocationImpl o2) {\n+    private final class SequenceNumberComparator implements Comparator<Invocation> {\n+        public int compare(Invocation o1, Invocation o2) {\n             return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());\n         }\n     }\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n \n package org.mockito.internal.invocation.finder;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n  */\n public class VerifiableInvocationsFinder {\n \n-    public List<InvocationImpl> find(List<?> mocks) {\n-        List<InvocationImpl> invocations = new AllInvocationsFinder().find(mocks);\n+    public List<Invocation> find(List<?> mocks) {\n+        List<Invocation> invocations = new AllInvocationsFinder().find(mocks);\n         return ListUtil.filter(invocations, new RemoveIgnoredForVerification());\n     }\n \n-    static class RemoveIgnoredForVerification implements ListUtil.Filter<InvocationImpl>{\n-        public boolean isOut(InvocationImpl i) {\n+    static class RemoveIgnoredForVerification implements ListUtil.Filter<Invocation>{\n+        public boolean isOut(Invocation i) {\n             return i.isIgnoredForVerification();\n         }\n     }\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n package org.mockito.internal.progress;\n \n import org.mockito.MockSettings;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n \n     void stubbingStarted();\n \n-    void stubbingCompleted(InvocationImpl invocation);\n+    void stubbingCompleted(Invocation invocation);\n     \n     void validateState();\n \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.Localized;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.internal.listeners.MockingStartedListener;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n         getArgumentMatcherStorage().validateState();\n     }\n \n-    public void stubbingCompleted(InvocationImpl invocation) {\n+    public void stubbingCompleted(Invocation invocation) {\n         stubbingInProgress = null;\n     }\n     \n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n import java.io.Serializable;\n \n import org.mockito.MockSettings;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.listeners.MockingProgressListener;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n         threadSafely().validateState();\n     }\n \n-    public void stubbingCompleted(InvocationImpl invocation) {\n+    public void stubbingCompleted(Invocation invocation) {\n         threadSafely().stubbingCompleted(invocation);\n     }\n     \n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.invocation.ArgumentsProcessor;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.matchers.MatchersPrinter;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.util.Arrays;\n import java.util.LinkedList;\n         this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n     }\n \n-    public String print(List<Matcher> matchers, InvocationImpl invocation) {\n+    public String print(List<Matcher> matchers, Invocation invocation) {\n         MatchersPrinter matchersPrinter = new MatchersPrinter();\n         String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName();\n         String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);\n         }\n     }\n \n-    public String print(InvocationImpl invocation) {\n+    public String print(Invocation invocation) {\n         return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);\n     }\n \n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n package org.mockito.internal.reporting;\n \n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n /**\n  * Makes sure both wanted and actual are printed consistently (single line or multiline)\n     private final String wanted;\n     private final String actual;\n \n-    public SmartPrinter(InvocationMatcher wanted, InvocationImpl actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n+    public SmartPrinter(InvocationMatcher wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n         PrintSettings printSettings = new PrintSettings();\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n         printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n--- a/src/org/mockito/internal/stubbing/InvocationContainer.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainer.java\n  */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n //TODO move to different package\n public interface InvocationContainer {\n-    List<InvocationImpl> getInvocations();\n+    List<Invocation> getInvocations();\n \n     List<StubbedInvocationMatcher> getStubbedInvocations();\n }\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.answers.AnswersValidator;\n import org.mockito.internal.verification.RegisteredInvocations;\n+import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n     }\n \n     public void addAnswer(Answer answer, boolean isConsecutive) {\n-        InvocationImpl invocation = invocationForStubbing.getInvocation();\n+        Invocation invocation = invocationForStubbing.getInvocation();\n         mockingProgress.stubbingCompleted(invocation);\n         AnswersValidator answersValidator = new AnswersValidator();\n         answersValidator.validate(answer, invocation);\n         return \"invocationForStubbing: \" + invocationForStubbing;\n     }\n \n-    public List<InvocationImpl> getInvocations() {\n+    public List<Invocation> getInvocations() {\n         return registeredInvocations.getAll();\n     }\n \n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n package org.mockito.internal.stubbing;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.DeprecatedOngoingStubbing;\n import org.mockito.stubbing.OngoingStubbing;\n         return new ConsecutiveStubbing<T>(invocationContainerImpl);\n     }\n \n-    public List<InvocationImpl> getRegisteredInvocations() {\n+    public List<Invocation> getRegisteredInvocations() {\n         //TODO interface for tests\n         return invocationContainerImpl.getInvocations();\n     }\n--- a/src/org/mockito/internal/verification/AtLeast.java\n+++ b/src/org/mockito/internal/verification/AtLeast.java\n import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.checkers.AtLeastXNumberOfInvocationsInOrderChecker;\n import org.mockito.internal.verification.checkers.MissingInvocationChecker;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class AtLeast implements VerificationInOrderMode, VerificationMode {\n     }\n     \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<InvocationImpl> allInvocations = data.getAllInvocations();\n+        List<Invocation> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n--- a/src/org/mockito/internal/verification/AtMost.java\n+++ b/src/org/mockito/internal/verification/AtMost.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class AtMost implements VerificationMode {\n     }\n \n     public void verify(VerificationData data) {\n-        List<InvocationImpl> invocations = data.getAllInvocations();\n+        List<Invocation> invocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         InvocationsFinder finder = new InvocationsFinder();\n-        List<InvocationImpl> found = finder.findInvocations(invocations, wanted);\n+        List<Invocation> found = finder.findInvocations(invocations, wanted);\n         int foundSize = found.size();\n         if (foundSize > maxNumberOfInvocations) {\n             new Reporter().wantedAtMostX(maxNumberOfInvocations, foundSize);\n--- a/src/org/mockito/internal/verification/Calls.java\n+++ b/src/org/mockito/internal/verification/Calls.java\n package org.mockito.internal.verification;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n import org.mockito.internal.verification.checkers.*;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n import java.util.List;\n     }\n \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<InvocationImpl> allInvocations = data.getAllInvocations();\n+        List<Invocation> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n--- a/src/org/mockito/internal/verification/InOrderContextImpl.java\n+++ b/src/org/mockito/internal/verification/InOrderContextImpl.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.collections.IdentitySet;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class InOrderContextImpl implements InOrderContext {\n     \n     final IdentitySet verified = new IdentitySet();\n \n-    public boolean isVerified(InvocationImpl invocation) {\n+    public boolean isVerified(Invocation invocation) {\n         return verified.contains(invocation);\n     }\n \n-    public void markVerified(InvocationImpl i) {\n+    public void markVerified(Invocation i) {\n         verified.add(i);\n     }\n }\n--- a/src/org/mockito/internal/verification/InOrderWrapper.java\n+++ b/src/org/mockito/internal/verification/InOrderWrapper.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.InOrderImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.finder.VerifiableInvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n import java.util.List;\n     }\n \n     public void verify(VerificationData data) {\n-        List<InvocationImpl> invocations = new VerifiableInvocationsFinder().find(inOrder.getMocksToBeVerifiedInOrder());\n+        List<Invocation> invocations = new VerifiableInvocationsFinder().find(inOrder.getMocksToBeVerifiedInOrder());\n         VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl(inOrder, invocations, data.getWanted());\n         mode.verifyInOrder(dataInOrder);\n     }\n--- a/src/org/mockito/internal/verification/NoMoreInteractions.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractions.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class NoMoreInteractions implements VerificationMode, VerificationInOrderMode {\n \n     @SuppressWarnings(\"unchecked\")\n     public void verify(VerificationData data) {\n-        InvocationImpl unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n+        Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n         if (unverified != null) {\n             new Reporter().noMoreInteractionsWanted(unverified, (List) data.getAllInvocations());\n         }\n     }\n \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<InvocationImpl> invocations = data.getAllInvocations();\n-        InvocationImpl unverified = new InvocationsFinder().findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);\n+        List<Invocation> invocations = data.getAllInvocations();\n+        Invocation unverified = new InvocationsFinder().findFirstUnverifiedInOrder(data.getOrderingContext(), invocations);\n         \n         if (unverified != null) {\n             new Reporter().noMoreInteractionsWantedInOrder(unverified);\n--- a/src/org/mockito/internal/verification/Only.java\n+++ b/src/org/mockito/internal/verification/Only.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class Only implements VerificationMode {\n \t@SuppressWarnings(\"unchecked\")\n     public void verify(VerificationData data) {\n \t\tInvocationMatcher wantedMatcher = data.getWanted();\n-\t\tList<InvocationImpl> invocations = data.getAllInvocations();\n-\t\tList<InvocationImpl> chunk = finder.findInvocations(invocations,wantedMatcher);\n+\t\tList<Invocation> invocations = data.getAllInvocations();\n+\t\tList<Invocation> chunk = finder.findInvocations(invocations,wantedMatcher);\n \t\tif (invocations.size() != 1 && chunk.size() > 0) {\t\t\t\n-\t\t\tInvocationImpl unverified = finder.findFirstUnverified(invocations);\n+\t\t\tInvocation unverified = finder.findFirstUnverified(invocations);\n \t\t\treporter.noMoreInteractionsWanted(unverified, (List) invocations);\n \t\t} else if (invocations.size() != 1 || chunk.size() == 0) {\n \t\t\treporter.wantedButNotInvoked(wantedMatcher);\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockito.invocation.Invocation;\n \n import java.io.Serializable;\n import java.util.Collections;\n public class RegisteredInvocations implements Serializable {\n \n     private static final long serialVersionUID = -2674402327380736290L;\n-    private final List<InvocationImpl> invocations = Collections.synchronizedList(new LinkedList<InvocationImpl>());\n+    private final List<Invocation> invocations = Collections.synchronizedList(new LinkedList<Invocation>());\n \n-    public void add(InvocationImpl invocation) {\n+    public void add(Invocation invocation) {\n         invocations.add(invocation);\n     }\n \n         }\n     }\n \n-    public List<InvocationImpl> getAll() {\n-    \tList<InvocationImpl> copiedList;\n+    public List<Invocation> getAll() {\n+    \tList<Invocation> copiedList;\n     \tsynchronized (invocations) {\n \t\t\tcopiedList = new LinkedList<InvocationImpl>(invocations) ;\n \t\t}\n         return invocations.isEmpty();\n     }\n \n-    private static class RemoveToString implements Filter<InvocationImpl> {\n-        public boolean isOut(InvocationImpl invocation) {\n+    private static class RemoveToString implements Filter<Invocation> {\n+        public boolean isOut(Invocation invocation) {\n             return new ObjectMethodsGuru().isToString(invocation.getMethod());\n         }\n     }\n--- a/src/org/mockito/internal/verification/Times.java\n+++ b/src/org/mockito/internal/verification/Times.java\n import java.util.List;\n \n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.internal.verification.api.VerificationDataInOrder;\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderChecker;\n import org.mockito.internal.verification.checkers.NumberOfInvocationsChecker;\n import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderChecker;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class Times implements VerificationInOrderMode, VerificationMode {\n     }\n     \n     public void verifyInOrder(VerificationDataInOrder data) {\n-        List<InvocationImpl> allInvocations = data.getAllInvocations();\n+        List<Invocation> allInvocations = data.getAllInvocations();\n         InvocationMatcher wanted = data.getWanted();\n         \n         if (wantedCount > 0) {\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.stubbing.InvocationContainer;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n \n public class VerificationDataImpl implements VerificationData {\n \n         this.assertWantedIsVerifiable();\n     }\n \n-    public List<InvocationImpl> getAllInvocations() {\n+    public List<Invocation> getAllInvocations() {\n         return invocations.getInvocations();\n     }\n \n--- a/src/org/mockito/internal/verification/api/InOrderContext.java\n+++ b/src/org/mockito/internal/verification/api/InOrderContext.java\n  */\n package org.mockito.internal.verification.api;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.invocation.Invocation;\n \n public interface InOrderContext {\n \n-    boolean isVerified(InvocationImpl invocation);\n+    boolean isVerified(Invocation invocation);\n \n-    void markVerified(InvocationImpl i);\n+    void markVerified(Invocation i);\n \n }\n--- a/src/org/mockito/internal/verification/api/VerificationData.java\n+++ b/src/org/mockito/internal/verification/api/VerificationData.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public interface VerificationData {\n \n-    List<InvocationImpl> getAllInvocations();\n+    List<Invocation> getAllInvocations();\n \n     InvocationMatcher getWanted();   \n     \n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrder.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public interface VerificationDataInOrder {\n \n-    List<InvocationImpl> getAllInvocations();\n+    List<Invocation> getAllInvocations();\n \n     InvocationMatcher getWanted();   \n     \n--- a/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n+++ b/src/org/mockito/internal/verification/api/VerificationDataInOrderImpl.java\n \n import java.util.List;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n public class VerificationDataInOrderImpl implements VerificationDataInOrder {\n \n     private final InOrderContext inOrder;\n-    private final List<InvocationImpl> allInvocations;\n+    private final List<Invocation> allInvocations;\n     private final InvocationMatcher wanted;\n \n-    public VerificationDataInOrderImpl(InOrderContext inOrder, List<InvocationImpl> allInvocations, InvocationMatcher wanted) {\n+    public VerificationDataInOrderImpl(InOrderContext inOrder, List<Invocation> allInvocations, InvocationMatcher wanted) {\n         this.inOrder = inOrder;\n         this.allInvocations = allInvocations;\n         this.wanted = wanted;        \n     }\n \n-    public List<InvocationImpl> getAllInvocations() {\n+    public List<Invocation> getAllInvocations() {\n         return allInvocations;\n     }\n \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.invocation.Invocation;\n \n public class AtLeastXNumberOfInvocationsChecker {\n     \n     InvocationsFinder finder = new InvocationsFinder();\n     InvocationMarker invocationMarker = new InvocationMarker();\n \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class AtLeastXNumberOfInvocationsInOrderChecker {\n     \n         this.orderingContext = orderingContext;\n     }\n \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<InvocationImpl> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, orderingContext);\n         \n         int actualCount = chunk.size();\n         \n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool;\n+import org.mockito.invocation.Invocation;\n \n public class MissingInvocationChecker {\n     \n         this.reporter = reporter;\n     }\n     \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n-        List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted) {\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n         if (actualInvocations.isEmpty()) {\n-            InvocationImpl similar = finder.findSimilarInvocation(invocations, wanted);\n+            Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n             if (similar != null) {\n                 ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n                 Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool;\n+import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n \n public class MissingInvocationInOrderChecker {\n         this.reporter = reporter;\n     }\n     \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, VerificationMode mode, InOrderContext context) {\n-        List<InvocationImpl> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode, InOrderContext context) {\n+        List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted, context);\n         \n         if (!chunk.isEmpty()) {\n             return;\n              * is missing, then this method checks if the arguments are different or if the order\n              * is not invoked.\n              */\n-             List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n+             List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n              if (actualInvocations == null || actualInvocations.isEmpty())  {\n-                 InvocationImpl similar = finder.findSimilarInvocation(invocations, wanted);\n+                 Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n                  if (similar != null) {\n                      Integer[] indicesOfSimilarMatchingArguments =\n                              new ArgumentMatchingTool().getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(),\n--- a/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n import java.util.List;\n \n         this.marker = marker;\n     }\n     \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         int actualCount = 0;\n         LocationImpl lastLocation = null;\n         while( actualCount < wantedCount ){\n-            InvocationImpl next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n+            Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n             if( next == null ){\n                 reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );\n             }\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.invocation.Invocation;\n \n public class NumberOfInvocationsChecker {\n     \n         this.finder = finder;\n     }\n     \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount) {\n-        List<InvocationImpl> actualInvocations = finder.findInvocations(invocations, wanted);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n public class NumberOfInvocationsInOrderChecker {\n     \n         this.reporter = reporter;\n     }\n     \n-    public void check(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n-        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount, context);\n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount, context);\n         \n         int actualCount = chunk.size();\n         \n--- a/test/org/mockito/internal/AllInvocationsFinderTest.java\n+++ b/test/org/mockito/internal/AllInvocationsFinderTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.finder.AllInvocationsFinder;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n         mockTwo.simpleMethod(200);\n         mockOne.simpleMethod(300);\n         \n-        List<InvocationImpl> invocations = finder.find(asList(mockOne, mockTwo));\n+        List<Invocation> invocations = finder.find(asList(mockOne, mockTwo));\n         \n         assertEquals(3, invocations.size());\n         assertArgumentEquals(100, invocations.get(0));\n     public void shouldNotCountDuplicatedInteractions() throws Exception {\n         mockOne.simpleMethod(100);\n \n-        List<InvocationImpl> invocations = finder.find(asList(mockOne, mockOne, mockOne));\n+        List<Invocation> invocations = finder.find(asList(mockOne, mockOne, mockOne));\n \n         assertEquals(1, invocations.size());\n     }\n \n-    private void assertArgumentEquals(Object argumentValue, InvocationImpl invocation) {\n+    private void assertArgumentEquals(Object argumentValue, Invocation invocation) {\n         assertEquals(argumentValue, invocation.getArguments()[0]);\n     }\n }\n--- a/test/org/mockito/internal/InOrderImplTest.java\n+++ b/test/org/mockito/internal/InOrderImplTest.java\n \n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     public void shouldMarkVerifiedInOrder() throws Exception {\n         //given\n         InOrderImpl impl = new InOrderImpl((List) asList(mock));\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         assertFalse(impl.isVerified(i));\n         \n         //when\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.invocation.Invocation;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.listeners.MethodInvocationReport;\n import org.mockitoutil.TestBase;\n \t\tMockHandler<?> handler = new MockHandler();\n \t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n \t\thandler.matchersBinder = new MatchersBinder() {\n-\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, InvocationImpl invocation) {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n \t\t\t\tthrow new InvalidUseOfMatchersException();\n \t\t\t}\n \t\t};\n--- a/test/org/mockito/internal/debugging/WarningsFinderTest.java\n+++ b/test/org/mockito/internal/debugging/WarningsFinderTest.java\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     @Test\n     public void shouldPrintUnusedStub() {\n         // given\n-        InvocationImpl unusedStub = new InvocationBuilder().simpleMethod().toInvocation();\n+        Invocation unusedStub = new InvocationBuilder().simpleMethod().toInvocation();\n \n         // when\n         WarningsFinder finder = new WarningsFinder(asList(unusedStub), Arrays.<InvocationMatcher>asList());\n     @Test\n     public void shouldPrintStubWasUsedWithDifferentArgs() {\n         // given\n-        InvocationImpl stub = new InvocationBuilder().arg(\"foo\").mock(mock).toInvocation();\n+        Invocation stub = new InvocationBuilder().arg(\"foo\").mock(mock).toInvocation();\n         InvocationMatcher wrongArg = new InvocationBuilder().arg(\"bar\").mock(mock).toInvocationMatcher();\n \n         // when\n--- a/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n+++ b/test/org/mockito/internal/exceptions/util/ScenarioPrinterTest.java\n import java.util.List;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n     @Test\n     public void shouldPrintInvocations() {\n         //given\n-        InvocationImpl verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n-        InvocationImpl unverified = new InvocationBuilder().differentMethod().toInvocation();\n+        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n+        Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();\n         \n         //when\n         String out = sp.print((List) asList(verified, unverified));\n     @Test\n     public void shouldNotPrintInvocationsWhenSingleUnwanted() {\n         //given\n-        InvocationImpl unverified = new InvocationBuilder().differentMethod().toInvocation();\n+        Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();\n         \n         //when\n         String out = sp.print((List) asList(unverified));\n--- a/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n+++ b/test/org/mockito/internal/invocation/ArgumentsComparatorTest.java\n  */\n package org.mockito.internal.invocation;\n \n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n import org.junit.Test;\n import org.mockito.internal.matchers.*;\n     @Test\n     public void shouldKnowWhenArgumentsMatch() {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"1\", 100).toInvocationMatcher();\n \n         //when\n     @Test\n     public void shouldKnowWhenArgsDifferent() {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\", 100).toInvocationMatcher();\n \n         //when\n     @Test\n     public void shouldKnowWhenActualArgsSizeIsDifferent() {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().args(\"100\", 100).toInvocation();\n+        Invocation invocation = new InvocationBuilder().args(\"100\", 100).toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\").toInvocationMatcher();\n \n         //when\n     @Test\n     public void shouldKnowWhenMatchersSizeIsDifferent() {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().args(\"100\").toInvocation();\n+        Invocation invocation = new InvocationBuilder().args(\"100\").toInvocation();\n         InvocationMatcher invocationMatcher = new InvocationBuilder().args(\"100\", 100).toInvocationMatcher();\n \n         //when\n     public void shouldKnowWhenVarargsMatch() {\n         //given\n         mock.varargs(\"1\", \"2\", \"3\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), Any.ANY, new InstanceOf(String.class)));\n \n         //when\n     public void shouldKnowWhenVarargsDifferent() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"100\"), Any.ANY));\n \n         //when\n     public void shouldNotAllowAnyObjectMatchEntireVararg() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(Any.ANY));\n \n         //when\n     public void shouldAllowAnyVarargMatchEntireVararg() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldNotAllowAnyObjectWithMixedVarargs() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));\n \n         //when\n     public void shouldAllowAnyObjectWithMixedVarargs() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldNotMatchWhenSomeOtherArgumentDoesNotMatch() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(100), AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs() {\n         //given\n         mock.mixedVarargs(1, \"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));\n \n         //when\n     public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull() {\n         //given\n         mock.mixedVarargs(null, null, \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(null), AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldMatchAnyVarargEvenIfMatcherIsDecorated() {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n \n         //when\n--- a/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMarkerTest.java\n import org.junit.Test;\n import org.mockito.internal.util.ObjectBox;\n import org.mockito.internal.verification.InOrderContextImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class InvocationMarkerTest extends TestBase {\n     public void shouldMarkInvocationAsVerified() {\n         //given\n         InvocationMarker marker = new InvocationMarker();\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n         assertFalse(i.isVerified());\n         \n     public void shouldCaptureArguments() {\n         //given\n         InvocationMarker marker = new InvocationMarker();\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         final ObjectBox box = new ObjectBox();\n         CapturesArgumensFromInvocation c = new CapturesArgumensFromInvocation() {\n-            public void captureArgumentsFrom(InvocationImpl i) {\n+            public void captureArgumentsFrom(Invocation i) {\n                 box.put(i);\n             }};\n         \n         //given\n         InOrderContextImpl context = new InOrderContextImpl();\n         InvocationMarker marker = new InvocationMarker();\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();\n         assertFalse(context.isVerified(i));\n         assertFalse(i.isVerified());\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.matchers.NotNull;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n \n     @Test\n     public void shouldBeACitizenOfHashes() throws Exception {\n-        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n-        InvocationImpl invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n         \n         Map map = new HashMap();\n         map.put(new InvocationMatcher(invocation), \"one\");\n     \n     @Test\n     public void shouldKnowIfIsSimilarTo() throws Exception {\n-        InvocationImpl same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n+        Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n         assertTrue(simpleMethod.hasSimilarMethod(same));\n         \n-        InvocationImpl different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n+        Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(different));\n     }\n     \n     @Test\n     public void shouldNotBeSimilarToVerifiedInvocation() throws Exception {\n-        InvocationImpl verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n+        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(verified));\n     }\n        \n     @Test\n     public void shouldNotBeSimilarIfMocksAreDifferent() throws Exception {\n-        InvocationImpl onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));\n     }    \n     \n         String sameArg = \"test\";\n         \n         InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();\n-        InvocationImpl overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n+        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n         \n         assertFalse(invocation.hasSimilarMethod(overloadedInvocation));\n     } \n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n         \n         InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg(\"foo\").toInvocationMatcher();\n-        InvocationImpl overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n+        Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n         \n         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n     @Test\n     public void shouldCaptureArgumentsFromInvocation() throws Exception {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n+        Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         CapturingMatcher capturingMatcher = new CapturingMatcher();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), capturingMatcher));\n         \n     public void shouldMatchVarargsUsingAnyVarargs() throws Exception {\n         //given\n         mock.varargs(\"1\", \"2\");\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));\n \n         //when\n     public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n         //given\n         mock.varargs();\n-        InvocationImpl invocation = getLastInvocation();\n+        Invocation invocation = getLastInvocation();\n \n         //when\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n     @Test\n     public void shouldCreateFromInvocations() throws Exception {\n         //given\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         //when\n         List<InvocationMatcher> out = InvocationMatcher.createFrom(asList(i));\n         //then\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings({\"unchecked\"})\n public class InvocationTest extends TestBase {\n \n-    private InvocationImpl invocation;\n+    private Invocation invocation;\n \n     @Before\n     public void setup() throws Exception {\n \n     @Test\n     public void shouldKnowIfIsEqualTo() {\n-        InvocationImpl equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n-        InvocationImpl nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n-        InvocationImpl withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n+        Invocation equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+        Invocation nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n+        Invocation withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n \n         assertFalse(invocation.equals(null));\n         assertFalse(invocation.equals(\"\"));\n     \n     @Test\n     public void shouldEqualToNotConsiderSequenceNumber() {\n-        InvocationImpl equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        Invocation equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n         \n         assertTrue(invocation.equals(equal));\n         assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());\n     \n     @Test\n     public void shouldTransformArgumentsToMatchers() throws Exception {\n-        InvocationImpl i = new InvocationBuilder().args(\"foo\", new String[]{\"bar\"}).toInvocation();\n+        Invocation i = new InvocationBuilder().args(\"foo\", new String[]{\"bar\"}).toInvocation();\n         List matchers = ArgumentsProcessor.argumentsToMatchers(i.getArguments());\n \n         assertEquals(2, matchers.size());\n     @Test\n     public void shouldBeAbleToCallRealMethod() throws Throwable {\n         //when\n-        InvocationImpl invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n+        Invocation invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n             public Object invoke(Object target, Object[] arguments) throws Throwable {\n                 return new Foo().bark();\n             }});\n     @Test\n     public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n         //given\n-        InvocationImpl invocationOnInterface = new InvocationBuilder().toInvocation();\n+        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n \n         try {\n             //when\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n \n public class InvocationsFinderTest extends TestBase {\n     \n-    private LinkedList<InvocationImpl> invocations = new LinkedList<InvocationImpl>();\n-    private InvocationImpl simpleMethodInvocation;\n-    private InvocationImpl simpleMethodInvocationTwo;\n-    private InvocationImpl differentMethodInvocation;\n+    private LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n     private InvocationsFinder finder;\n     InOrderContext context = new InOrderContextImpl();\n     \n \n     @Test\n     public void shouldFindActualInvocations() throws Exception {\n-        List<InvocationImpl> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));\n         assertThat(actual, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n         actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));\n     \n     @Test\n     public void shouldFindFirstSimilarInvocationByName() throws Exception {\n-        InvocationImpl overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg(\"test\").toInvocation();\n+        Invocation overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg(\"test\").toInvocation();\n         \n-        InvocationImpl found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));\n         assertSame(found, simpleMethodInvocation);\n     }\n     \n     @Test\n     public void shouldFindInvocationWithTheSameMethod() throws Exception {\n-        InvocationImpl overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg(\"test\").toInvocation();\n+        Invocation overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg(\"test\").toInvocation();\n         \n         invocations.add(overloadedDifferentMethod);\n         \n-        InvocationImpl found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));\n         assertSame(found, overloadedDifferentMethod);\n     }\n     \n     \n     @Test\n     public void shouldFindAllMatchingUnverifiedChunks() throws Exception {\n-        List<InvocationImpl> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n+        List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);\n         assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n         context.markVerified(simpleMethodInvocation);\n     \n     @Test\n     public void shouldFindMatchingChunk() throws Exception {\n-        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n     \n     @Test\n     public void shouldReturnAllChunksWhenModeIsAtLeastOnce() throws Exception {\n-        InvocationImpl simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n+        Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n     public void shouldReturnAllChunksWhenWantedCountDoesntMatch() throws Exception {\n-        InvocationImpl simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n+        Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        List<InvocationImpl> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n     public void shouldFindPreviousInOrder() throws Exception {\n-        InvocationImpl previous = finder.findPreviousVerifiedInOrder(invocations, context);\n+        Invocation previous = finder.findPreviousVerifiedInOrder(invocations, context);\n         assertNull(previous);\n         \n         context.markVerified(simpleMethodInvocation);\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n public class AnswersValidatorTest extends TestBase {\n \n     private AnswersValidator validator = new AnswersValidator();\n-    private InvocationImpl invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+    private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n \n     @Test\n     public void shouldValidateNullThrowable() throws Throwable {\n     @Test\n     public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\n         //given\n-        InvocationImpl inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n         try {\n             //when\n             validator.validate(new CallsRealMethods(), inovcationOnIterface);\n         //given\n         ArrayList mock = mock(ArrayList.class);\n         mock.clear();\n-        InvocationImpl invocationOnClass = getLastInvocation();\n+        Invocation invocationOnClass = getLastInvocation();\n         //when\n         validator.validate(new CallsRealMethods(), invocationOnClass);\n         //then no exception is thrown\n--- a/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/MethodInfoTest.java\n package org.mockito.internal.stubbing.answers;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n \n import java.nio.charset.CharacterCodingException;\n \n     @Test\n     public void shouldKnowValidThrowables() throws Exception {\n         //when\n-        InvocationImpl invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n         MethodInfo info = new MethodInfo(invocation);\n \n         //then\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n import java.util.*;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n import static org.mockito.Mockito.mock;\n         //given\n         Date d = mock(Date.class);\n         d.compareTo(new Date());\n-        InvocationImpl compareTo = this.getLastInvocation();\n+        Invocation compareTo = this.getLastInvocation();\n \n         //when\n         Object result = values.answer(compareTo);\n--- a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class NoMoreInteractionsTest extends TestBase {\n     public void shouldVerifyInOrder() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         assertFalse(context.isVerified(i));\n         \n         try {\n     public void shouldVerifyInOrderAndPass() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        InvocationImpl i = new InvocationBuilder().toInvocation();\n+        Invocation i = new InvocationBuilder().toInvocation();\n         context.markVerified(i);\n         assertTrue(context.isVerified(i));\n         \n     public void shouldVerifyInOrderMultipleInvoctions() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        InvocationImpl i = new InvocationBuilder().seq(1).toInvocation();\n-        InvocationImpl i2 = new InvocationBuilder().seq(2).toInvocation();\n+        Invocation i = new InvocationBuilder().seq(1).toInvocation();\n+        Invocation i2 = new InvocationBuilder().seq(2).toInvocation();\n \n         //when\n         context.markVerified(i2);\n     public void shouldVerifyInOrderMultipleInvoctionsAndThrow() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n-        InvocationImpl i = new InvocationBuilder().seq(1).toInvocation();\n-        InvocationImpl i2 = new InvocationBuilder().seq(2).toInvocation();\n+        Invocation i = new InvocationBuilder().seq(1).toInvocation();\n+        Invocation i2 = new InvocationBuilder().seq(2).toInvocation();\n         \n         try {\n             //when     \n--- a/test/org/mockito/internal/verification/OnlyTest.java\n+++ b/test/org/mockito/internal/verification/OnlyTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoAssertionError;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.invocation.Invocation;\n \n public class OnlyTest {\n \n     Only only = new Only();\n     \n     public class VerificationDataStub implements VerificationData {\n-        private final InvocationImpl invocation;\n+        private final Invocation invocation;\n         private final InvocationMatcher wanted;\n \n-        public VerificationDataStub(InvocationMatcher wanted, InvocationImpl invocation) {\n+        public VerificationDataStub(InvocationMatcher wanted, Invocation invocation) {\n             this.invocation = invocation;\n             this.wanted = wanted;\n         }\n \n-        public List<InvocationImpl> getAllInvocations() {\n+        public List<Invocation> getAllInvocations() {\n             return Arrays.asList(invocation);\n         }\n \n     @Test\n     public void shouldMarkAsVerified() {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n         assertFalse(invocation.isVerified());\n         \n         //when\n     @Test\n     public void shouldNotMarkAsVerifiedWhenAssertionFailed() {\n         //given\n-        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n         assertFalse(invocation.isVerified());\n         \n         //when\n--- a/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class RegisteredInvocationsTest extends TestBase {\n     \n     @Test\n     public void shouldNotReturnToStringMethod() throws Exception {\n-        InvocationImpl toString = new InvocationBuilder().method(\"toString\").toInvocation();\n-        InvocationImpl simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+        Invocation toString = new InvocationBuilder().method(\"toString\").toInvocation();\n+        Invocation simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n         \n         invocations.add(toString);\n         invocations.add(simpleMethod);\n--- a/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsCheckerTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.internal.invocation.*;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class AtLeastXNumberOfInvocationsCheckerTest extends TestBase {\n         //given\n         AtLeastXNumberOfInvocationsChecker c = new AtLeastXNumberOfInvocationsChecker();\n         c.invocationMarker = Mockito.mock(InvocationMarker.class);\n-        InvocationImpl invocation = new InvocationBuilder().simpleMethod().toInvocation();\n-        InvocationImpl invocationTwo = new InvocationBuilder().differentMethod().toInvocation();\n+        Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();\n \n         //when\n         c.check(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1);\n--- a/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n \n class InvocationsFinderStub extends InvocationsFinder {\n     \n-    InvocationImpl similarToReturn;\n-    InvocationImpl firstUnverifiedToReturn;\n+    Invocation similarToReturn;\n+    Invocation firstUnverifiedToReturn;\n     InvocationImpl previousInOrderToReturn;\n     \n-    final List<InvocationImpl> actualToReturn = new LinkedList<InvocationImpl>();\n-    final List<InvocationImpl> validMatchingChunkToReturn = new LinkedList<InvocationImpl>();\n-    final List<InvocationImpl> allMatchingUnverifiedChunksToReturn = new LinkedList<InvocationImpl>();\n+    final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n+    final List<Invocation> validMatchingChunkToReturn = new LinkedList<Invocation>();\n+    final List<Invocation> allMatchingUnverifiedChunksToReturn = new LinkedList<Invocation>();\n     \n-    List<InvocationImpl> invocations;\n+    List<Invocation> invocations;\n     \n     @Override\n-    public List<InvocationImpl> findAllMatchingUnverifiedChunks(List<InvocationImpl> invocations, InvocationMatcher wanted, InOrderContext context) {\n+    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context) {\n         return allMatchingUnverifiedChunksToReturn;\n     }\n     \n     @Override\n-    public List<InvocationImpl> findMatchingChunk(List<InvocationImpl> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         return validMatchingChunkToReturn;\n     }\n \n-    @Override public List<InvocationImpl> findInvocations(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n+    @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n         this.invocations = invocations;\n         return actualToReturn;\n     }\n     \n-    @Override public InvocationImpl findSimilarInvocation(List<InvocationImpl> invocations, InvocationMatcher wanted) {\n+    @Override public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n         this.invocations = invocations;\n         return similarToReturn;\n     }\n     \n-    @Override public InvocationImpl findFirstUnverified(List<InvocationImpl> invocations) {\n+    @Override public Invocation findFirstUnverified(List<Invocation> invocations) {\n         this.invocations = invocations;\n         return firstUnverifiedToReturn;\n     }\n     \n     @Override\n-    public InvocationImpl findPreviousVerifiedInOrder(List<InvocationImpl> invocations, InOrderContext context) {\n+    public InvocationImpl findPreviousVerifiedInOrder(List<Invocation> invocations, InOrderContext context) {\n         return previousInOrderToReturn;\n     }\n }\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationCheckerTest extends TestBase {\n     private ReporterStub reporterStub;\n     \n     private InvocationMatcher wanted;\n-    private List<InvocationImpl> invocations;\n+    private List<Invocation> invocations;\n \n     @Before\n     public void setup() {\n     @Test\n     public void shouldReportWantedInvocationDiffersFromActual() {\n         assertTrue(finderStub.actualToReturn.isEmpty());\n-        InvocationImpl actualInvocation = new InvocationBuilder().toInvocation();\n+        Invocation actualInvocation = new InvocationBuilder().toInvocation();\n         finderStub.similarToReturn = actualInvocation;\n         \n         checker.check(invocations, wanted);\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class MissingInvocationInOrderCheckerTest extends TestBase {\n     private MissingInvocationInOrderChecker checker;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n-    private LinkedList<InvocationImpl> invocations;\n+    private LinkedList<Invocation> invocations;\n     private InvocationsFinderStub finderStub;\n     private InOrderContext context = new InOrderContextImpl();\n     \n \n     @Test\n     public void shouldPassWhenMatchingInteractionFound() throws Exception {\n-        InvocationImpl actual = new InvocationBuilder().toInvocation();\n+        Invocation actual = new InvocationBuilder().toInvocation();\n         finderStub.allMatchingUnverifiedChunksToReturn.add(actual);\n         \n         checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsCheckerTest extends TestBase {\n     private NumberOfInvocationsChecker checker;\n     private ReporterStub reporterStub;\n     private InvocationMatcher wanted;\n-    private LinkedList<InvocationImpl> invocations;\n+    private LinkedList<Invocation> invocations;\n     private InvocationsFinderStub finderStub;\n     \n     @Before\n \n     @Test\n     public void shouldReportWithLastInvocationStackTrace() throws Exception {\n-        InvocationImpl first = new InvocationBuilder().toInvocation();\n-        InvocationImpl second = new InvocationBuilder().toInvocation();\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n         \n         finderStub.actualToReturn.addAll(asList(first, second));\n         \n     \n     @Test\n     public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n-        InvocationImpl first = new InvocationBuilder().toInvocation();\n-        InvocationImpl second = new InvocationBuilder().toInvocation();\n-        InvocationImpl third = new InvocationBuilder().toInvocation();\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        Invocation third = new InvocationBuilder().toInvocation();\n         \n         finderStub.actualToReturn.addAll(asList(first, second, third));\n         \n     \n     @Test\n     public void shouldReportNeverWantedButInvoked() throws Exception {\n-        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n         finderStub.actualToReturn.add(invocation);\n         \n         checker.check(invocations, wanted, 0);\n     \n     @Test\n     public void shouldMarkInvocationsAsVerified() throws Exception {\n-        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n         finderStub.actualToReturn.add(invocation);\n         assertFalse(invocation.isVerified());\n         \n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n+import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsInOrderCheckerTest extends TestBase {\n     private NumberOfInvocationsInOrderChecker checker;\n     private Reporter reporter;\n     private InvocationMatcher wanted;\n-    private LinkedList<InvocationImpl> invocations;\n+    private LinkedList<Invocation> invocations;\n     private InvocationsFinderStub finderStub;\n     private InOrderContext context = new InOrderContextImpl();\n     \n     \n     @Test\n     public void shouldReportTooLittleInvocations() throws Exception {\n-        InvocationImpl first = new InvocationBuilder().toInvocation();\n-        InvocationImpl second = new InvocationBuilder().toInvocation();\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n     \n     @Test\n     public void shouldReportTooManyInvocations() throws Exception {\n-        InvocationImpl first = new InvocationBuilder().toInvocation();\n-        InvocationImpl second = new InvocationBuilder().toInvocation();\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n     \n     @Test\n     public void shouldMarkAsVerifiedInOrder() throws Exception {\n-        InvocationImpl invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n         assertFalse(context.isVerified(invocation));\n         finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n         \n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.internal.invocation.SerializableMethod;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n \n import java.io.*;\n import java.util.Collection;\n         new StateMaster().reset();\n     }\n     \n-    protected InvocationImpl getLastInvocation() {\n+    protected Invocation getLastInvocation() {\n         return new MockitoCore().getLastInvocation();\n     }\n \n                 , string.contains(sub));\n     }\n     \n-    protected static InvocationImpl invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n+    protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n         Class[] types = new Class[args.length];\n         for (int i = 0; i < args.length; i++) {\n             types[i] = args[i].getClass();\n                 types)), args, 1, null);\n     }\n \n-    protected static InvocationImpl invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n+    protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n         return new InvocationImpl(new Object(), new SerializableMethod(type.getMethod(methodName,\n                 new Class[0])), new Object[0], 1, realMethod);\n     }", "timestamp": 1333231930, "metainfo": ""}