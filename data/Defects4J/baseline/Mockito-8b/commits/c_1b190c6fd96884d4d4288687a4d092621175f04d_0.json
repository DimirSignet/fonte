{"sha": "1b190c6fd96884d4d4288687a4d092621175f04d", "log": "enabled test for showing right cause in case of failed verification in order  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40316", "commit": "\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationInOrderTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationInOrderTest.java\n import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n \n-@Ignore\n public class PointingStackTraceToActualInvocationInOrderTest extends RequiresValidState {\n     \n     private IMethods mock;\n     }\n     \n     @Test\n-    public void shouldPointStackTraceToActualInvocation() {\n+    public void shouldPointStackTraceToPreviousVerified() {\n         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         inOrder.verify(mockTwo).simpleMethod(anyInt());\n         \n             inOrder.verify(mock).simpleMethod(999);\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToThirdMethod() {\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        \n+        try {\n+            inOrder.verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n         }\n     }\n     \n     @Test\n-    public void shouldPointToActualInvocation() {\n-        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+    public void shouldPointToSecondMethod() {\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n         \n         try {\n-            inOrder.verify(mockTwo).simpleMethod(999);\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n     }\n     \n     @Test\n-    public void shouldPointToUnverifiedInvocation() {\n-        inOrder.verify(mock).simpleMethod(anyInt());\n-        inOrder.verify(mockTwo).simpleMethod(anyInt());\n-        inOrder.verify(mock).simpleMethod(anyInt());\n-        \n+    public void shouldPointToFirstMethodBecauseOfTooManyActualInvocations() {\n         try {\n-            inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n+            inOrder.verify(mock, times(0)).simpleMethod(anyInt());\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n-            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n         }\n-    }\n+    }    \n     \n     @Test\n-    public void shouldPointToTooManyInvocationsChunk() {\n+    public void shouldPointToSecondMethodBecauseOfTooManyActualInvocations() {\n         inOrder.verify(mock).simpleMethod(anyInt());\n         \n         try {\n     }\n     \n     @Test\n-    public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n+    public void shouldPointToFourthMethodBecauseOfTooLittleActualInvocations() {\n         inOrder.verify(mock).simpleMethod(anyInt());\n         inOrder.verify(mockTwo).simpleMethod(anyInt());\n         inOrder.verify(mock).simpleMethod(anyInt());", "timestamp": 1200957419, "metainfo": ""}