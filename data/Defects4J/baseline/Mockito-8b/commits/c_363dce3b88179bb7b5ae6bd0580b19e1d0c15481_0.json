{"sha": "363dce3b88179bb7b5ae6bd0580b19e1d0c15481", "log": "refactored some responsibility to InvocationMatcherFactory  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40155", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationMatcher.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+\n+public class InvocationMatcher {\n+\n+    protected final Invocation invocation;\n+    protected final List<IArgumentMatcher> matchers;\n+\n+    public InvocationMatcher(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        if (matchers == null) {\n+            throw new IllegalArgumentException(\"matchers cannot be null\");\n+        }\n+        this.invocation = invocation;\n+        this.matchers = matchers;\n+    }\n+    \n+    public InvocationMatcher(Invocation invocation) {\n+        this(invocation, Collections.<IArgumentMatcher>emptyList());\n+    }\n+\n+    public boolean matches(Invocation actual) {\n+        return this.invocation.getMock().equals(\n+                actual.getMock())\n+                && this.invocation.getMethod().equals(actual.getMethod())\n+                && matches(actual.getArguments());\n+    }\n+\n+    private boolean matches(Object[] arguments) {\n+        if (arguments.length != matchers.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!matchers.get(i).matches(arguments[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    public String toStringWithSequenceNumber() {\n+        return this.invocation.toStringWithSequenceNumber(matchers);\n+    }\n+    \n+    public String toString() {\n+        return invocation.toString(matchers);\n+    }\n+\n+    public Method getMethod() {\n+        return invocation.getMethod();\n+    }\n+    \n+    public Invocation getInvocation() {\n+        return this.invocation;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationMatcherFactory.java\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.*;\n+\n+public class InvocationMatcherFactory {\n+\n+    public InvocationMatcher create(Object proxy, Method method, Object[] args) {\n+        Invocation invocation = new Invocation(proxy, method, args, MockitoState.instance().nextSequenceNumber());\n+        \n+        List<IArgumentMatcher> lastMatchers = LastArguments.instance().pullMatchers();\n+        validateMatchers(invocation, lastMatchers);\n+\n+        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n+        \n+        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, processedMatchers);\n+        return invocationWithMatchers;\n+    }\n+\n+    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) throws InvalidUseOfMatchersException {\n+        if (matchers != null) {\n+            if (matchers.size() != invocation.getArguments().length) {\n+                throw new InvalidUseOfMatchersException(\n+                        + invocation.getArguments().length\n+                        + \" matchers expected, \" + matchers.size()\n+                        + \" recorded.\");\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * if user passed bare arguments then create EqualsMatcher for every argument\n+     */\n+    private List<IArgumentMatcher> createEqualsMatchers(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        if (matchers != null) {\n+            return matchers;\n+        }\n+        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n+    }\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n package org.mockito.internal;\n \n import java.lang.reflect.Method;\n-import java.util.*;\n-\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.internal.matchers.*;\n+import java.util.List;\n \n public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n     private final MockitoBehavior<T> behavior = new MockitoBehavior<T>();\n     private final Stubber stubber = new Stubber();\n+    private final InvocationMatcherFactory invocationMatcherFactory = new InvocationMatcherFactory();\n     \n-    /**\n-     * if user passed bare arguments then create EqualsMatcher for every argument\n-     */\n-    private List<IArgumentMatcher> createEqualsMatchers(Invocation invocation,\n-            List<IArgumentMatcher> matchers) {\n-        if (matchers != null) {\n-            return matchers;\n-        }\n-        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n-        for (Object argument : invocation.getArguments()) {\n-            result.add(new Equals(argument));\n-        }\n-        return result;\n-    }\n-\n-    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) throws InvalidUseOfMatchersException {\n-        if (matchers != null) {\n-            if (matchers.size() != invocation.getArguments().length) {\n-                throw new InvalidUseOfMatchersException(\n-                        + invocation.getArguments().length\n-                        + \" matchers expected, \" + matchers.size()\n-                        + \" recorded.\");\n-            }\n-        }\n-    }\n-\n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         if (stubber.hasThrowableForVoidMethod()) {\n-            ExpectedInvocation invocationWithMatchers = expectedInvocation(proxy, method, args);\n-            stubber.addVoidMethodForThrowable(invocationWithMatchers);\n+            InvocationMatcher invocationMatcher = invocationMatcherFactory.create(proxy, method, args);\n+            stubber.addVoidMethodForThrowable(invocationMatcher);\n             return null;\n         }\n         \n         VerifyingMode verifyingMode = MockitoState.instance().pullVerifyingMode();\n         MockitoState.instance().validateState();\n         \n-        ExpectedInvocation invocationWithMatchers = expectedInvocation(proxy, method, args);\n+        InvocationMatcher invocationWithMatchers = invocationMatcherFactory.create(proxy, method, args);\n         \n         if (verifyingMode != null) {\n             behavior.verify(invocationWithMatchers, verifyingMode);\n         MockitoState.instance().reportControlForStubbing(this);\n         \n         return stubber.resultFor(invocationWithMatchers.getInvocation());\n-    }\n-\n-    private ExpectedInvocation expectedInvocation(Object proxy, Method method, Object[] args) {\n-        Invocation invocation = new Invocation(proxy, method, args, MockitoState.instance().nextSequenceNumber());\n-        \n-        List<IArgumentMatcher> lastMatchers = LastArguments.instance().pullMatchers();\n-        validateMatchers(invocation, lastMatchers);\n-\n-        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n-        \n-        ExpectedInvocation invocationWithMatchers = new ExpectedInvocation(invocation, processedMatchers);\n-        return invocationWithMatchers;\n     }\n \n     public void verifyNoMoreInteractions() {\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n     private T mock;\n     \n-    public void addInvocation(ExpectedInvocation invocation) {\n+    public void addInvocation(InvocationMatcher invocation) {\n         this.registeredInvocations.add(invocation.getInvocation());\n     }\n \n-    public void verify(ExpectedInvocation wanted, VerifyingMode mode) {\n+    public void verify(InvocationMatcher wanted, VerifyingMode mode) {\n         checkOrderOfInvocations(wanted, mode);\n         checkForMissingInvocation(wanted, mode);\n         checkForWrongNumberOfInvocations(wanted, mode);        \n         registeredInvocations.markInvocationsAsVerified(wanted, mode);\n     }\n     \n-    private void checkForMissingInvocation(ExpectedInvocation wanted, VerifyingMode mode) {\n+    private void checkForMissingInvocation(InvocationMatcher wanted, VerifyingMode mode) {\n         int actualCount = registeredInvocations.countActual(wanted);\n         Integer wantedCount = mode.wantedCount();\n         boolean atLeastOnce = mode.atLeastOnceMode();\n         }\n     }\n \n-    void checkForWrongNumberOfInvocations(ExpectedInvocation wanted, VerifyingMode mode) {\n+    void checkForWrongNumberOfInvocations(InvocationMatcher wanted, VerifyingMode mode) {\n         if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n             return;\n         }\n         }\n     }\n \n-    private void reportMissingInvocationError(ExpectedInvocation wanted) {\n+    private void reportMissingInvocationError(InvocationMatcher wanted) {\n         Invocation actual = registeredInvocations.findActualInvocation(wanted);\n         \n         if (actual != null) {\n         }\n     }\n \n-    private void reportDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation) {\n+    private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n         String wanted = wantedInvocation.toString();\n         String actual = actualInvocation.toString();\n         if (wanted.equals(actual)) {\n         Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n     }\n     \n-    private void reportStrictOrderDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation) {\n+    private void reportStrictOrderDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n         String wanted = wantedInvocation.toString();\n         String actual = actualInvocation.toString();\n         boolean sameMocks = wantedInvocation.getInvocation().getMock().equals(actualInvocation.getMock());\n     }\n \n     //TODO Cyclomatic Complexity = 10 :|\n-    private void checkOrderOfInvocations(ExpectedInvocation wanted, VerifyingMode mode) {\n+    private void checkOrderOfInvocations(InvocationMatcher wanted, VerifyingMode mode) {\n         if (!mode.orderOfInvocationsMatters()) {\n             return;\n         }\n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n         registeredInvocations.remove(registeredInvocations.size()-1);\n     }\n     \n-    public void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode mode) {\n+    public void markInvocationsAsVerified(InvocationMatcher expected, VerifyingMode mode) {\n         if (mode.wantedCountIsZero()) {\n             return;\n         }\n         return chunks;\n     }\n     \n-    public Invocation findActualInvocation(ExpectedInvocation wanted) {\n+    public Invocation findActualInvocation(InvocationMatcher wanted) {\n         Invocation actualbyName = null;\n         for (Invocation registered : registeredInvocations) {\n             String wantedMethodName = wanted.getMethod().getName();\n         return actualbyName != null ? actualbyName : getFirstUnverified();\n     }\n \n-    public int countActual(ExpectedInvocation wanted) {\n+    public int countActual(InvocationMatcher wanted) {\n         int actual = 0;\n         for (Invocation registeredInvocation : registeredInvocations) {\n             if (wanted.matches(registeredInvocation)) {\n         return null;\n     }\n \n-    public HasStackTrace getLastInvocationStackTrace(ExpectedInvocation wanted) {\n+    public HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted) {\n         Invocation lastMatching = null;\n         for (Invocation registered : registeredInvocations) {\n             if (wanted.matches(registered)) {\n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n \n-    public HasStackTrace getFirstUndesiredInvocationStackTrace(ExpectedInvocation wanted, VerifyingMode mode) {\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, VerifyingMode mode) {\n         int counter = 0;\n         for (Invocation registered : registeredInvocations) {\n             if (wanted.matches(registered)) {\n--- a/src/org/mockito/internal/StubbedInvocation.java\n+++ b/src/org/mockito/internal/StubbedInvocation.java\n package org.mockito.internal;\n \n \n-public class StubbedInvocation extends ExpectedInvocation {\n+public class StubbedInvocation extends InvocationMatcher {\n \n     private final Result result;\n \n-    public StubbedInvocation(ExpectedInvocation invocation, Result result) {\n+    public StubbedInvocation(InvocationMatcher invocation, Result result) {\n         super(invocation.invocation, invocation.matchers);\n         this.result = result;\n     }\n--- a/src/org/mockito/internal/Stubber.java\n+++ b/src/org/mockito/internal/Stubber.java\n \n public class Stubber {\n \n-    private ExpectedInvocation invocationForStubbing;\n+    private InvocationMatcher invocationForStubbing;\n     private LinkedList<StubbedInvocation> stubbed = new LinkedList<StubbedInvocation>();\n     private Throwable throwableForVoidMethod;\n     \n         addResult(Result.createThrowResult(throwable));\n     }\n \n-    public void addVoidMethodForThrowable(ExpectedInvocation invocationWithMatchers) {\n+    public void addVoidMethodForThrowable(InvocationMatcher invocationWithMatchers) {\n         this.invocationForStubbing = invocationWithMatchers;\n         this.addThrowable(throwableForVoidMethod);\n         throwableForVoidMethod = null;\n         return false;\n     }\n \n-    public void setInvocationForPotentialStubbing(ExpectedInvocation invocation) {\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n         this.invocationForStubbing = invocation;\n     }\n \n--- a/test/org/mockito/internal/InvocationBuilder.java\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n         return this;\n     }\n \n-    public ExpectedInvocation toExpecteInvocation() {\n-        return new ExpectedInvocation(toInvocation());\n+    public InvocationMatcher toMatchingInvocation() {\n+        return new InvocationMatcher(toInvocation());\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/InvocationMatcherTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n+import org.mockito.util.RequiresValidState;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationMatcherTest extends RequiresValidState {\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldScreamWhenMatchersNull() throws Exception {\n+        new InvocationMatcher(new InvocationBuilder().toInvocation(), null);\n+    }\n+    \n+    @Test\n+    public void shouldBeACitizenOfHashes() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n+        \n+        Map map = new HashMap();\n+        map.put(new InvocationMatcher(invocation), \"one\");\n+        map.put(new InvocationMatcher(invocationTwo), \"two\");\n+        \n+        assertEquals(2, map.size());\n+    }\n+    \n+    @Test\n+    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n+        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n+        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n+\n+        assertFalse(withOneArg.equals(null));\n+        assertFalse(withOneArg.equals(withTwoArgs));\n+    }\n+    \n+    @Test\n+    public void shouldToStringWithMatchers() throws Exception {\n+        IArgumentMatcher m = NotNull.NOT_NULL;\n+        InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));\n+        IArgumentMatcher mTwo = new Equals('x');\n+        InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));\n+\n+        assertEquals(\"Object.simpleMethod(notNull())\", notNull.toString());\n+        assertEquals(\"Object.simpleMethod('x')\", equals.toString());\n+    }\n+}\n--- a/test/org/mockito/internal/MockitoBehaviorTest.java\n+++ b/test/org/mockito/internal/MockitoBehaviorTest.java\n \n     @Test\n     public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n-        ExpectedInvocation invocation = new ExpectedInvocation(new InvocationBuilder().toInvocation());\n+        InvocationMatcher invocation = new InvocationMatcher(new InvocationBuilder().toInvocation());\n         MockitoBehavior behavior = new MockitoBehavior();\n         \n         VerifyingMode inOrder = VerifyingMode.inOrder(1, Arrays.asList(new Object()));\n     \n     @Test\n     public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n-        ExpectedInvocation invocation = new ExpectedInvocation(new InvocationBuilder().toInvocation());\n+        InvocationMatcher invocation = new InvocationMatcher(new InvocationBuilder().toInvocation());\n         MockitoBehavior behavior = new MockitoBehavior();\n         \n         VerifyingMode inOrder = VerifyingMode.atLeastOnce();\n--- a/test/org/mockito/internal/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/RegisteredInvocationsTest.java\n     public void shouldGetTwoUnverifiedInvocationChunks() throws Exception {\n         Object mock = new Object();\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n         \n         List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n         \n     public void shouldGetOneUnverifiedInvocationChunk() throws Exception {\n         Object mock = new Object();\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), inOrder(null, asList(mock)));\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(differentMethodInvocation), inOrder(null, asList(mock)));\n         \n         List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n         \n     public void shouldNotGetAnyInvocationChunks() throws Exception {\n         Object mock = new Object();\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), inOrder(null, asList(mock)));\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation), inOrder(null, asList(mock)));\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(differentMethodInvocation), inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), inOrder(null, asList(mock)));\n         \n         List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(inOrder(null, asList(mock)));\n         \n     \n     @Test\n     public void shouldMarkAllsimpleMethodAsVerified() throws Exception {\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation),times(2));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation),times(2));\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(0).isVerified());\n     \n     @Test\n     public void shouldMarkAllsimpleMethodAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), atLeastOnce());\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(0).isVerified());\n     \n     @Test\n     public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), times(0));\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), times(0));\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(false, invocations.get(0).isVerified());\n     public void shouldMarkAsVerifedAllInvocationsFromFirstChunk() throws Exception {\n         VerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n         assertTrue(mode.orderOfInvocationsMatters());\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(null), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(null), mode);\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(0).isVerified());\n         assertTrue(mode.orderOfInvocationsMatters());\n         \n         Invocation doesntMatter = null;\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter), mode);\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(2).isVerified());\n         assertTrue(mode.orderOfInvocationsMatters());\n         \n         Invocation doesntMatter = null;\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter), mode);\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter), mode);\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n+        registered.markInvocationsAsVerified(new InvocationMatcher(doesntMatter), mode);\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(3).isVerified());\n     public void shouldGetFirstUnverifiedInvocation() throws Exception {\n         assertSame(simpleMethodInvocation, registered.getFirstUnverified());\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation), atLeastOnce());\n+        registered.markInvocationsAsVerified(new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertSame(differentMethodInvocation, registered.getFirstUnverified());\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation), atLeastOnce());\n+        registered.markInvocationsAsVerified(new InvocationMatcher(differentMethodInvocation), atLeastOnce());\n         assertNull(registered.getFirstUnverified());\n     }\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n-        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new ExpectedInvocation(simpleMethodInvocation), VerifyingMode.times(0));\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerifyingMode.times(0));\n         HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n-        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new ExpectedInvocation(simpleMethodInvocation), VerifyingMode.times(1));\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerifyingMode.times(1));\n         HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsTwo() throws Exception {\n-        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new ExpectedInvocation(simpleMethodInvocation), VerifyingMode.times(2));\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerifyingMode.times(2));\n         HasStackTrace expected = simpleMethodInvocationThree.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n--- a/test/org/mockito/internal/StubberTest.java\n+++ b/test/org/mockito/internal/StubberTest.java\n     @Test\n     public void shouldFinishStubbingBeforeValidatingThrowable() throws Exception {\n         Stubber s = new Stubber();\n-        s.setInvocationForPotentialStubbing(new InvocationBuilder().toExpecteInvocation());\n+        s.setInvocationForPotentialStubbing(new InvocationBuilder().toMatchingInvocation());\n         \n         MockitoState.instance().stubbingStarted();\n         try {\n             MockitoState.instance().validateState();\n         }\n     }\n+    \n+    @Test\n+    public void shouldFinishStubbingOnAddingReturnValue() throws Exception {\n+        Stubber s = new Stubber();\n+        s.setInvocationForPotentialStubbing(new InvocationBuilder().toMatchingInvocation());\n+        \n+        MockitoState.instance().stubbingStarted();\n+        s.addReturnValue(\"test\");\n+        MockitoState.instance().validateState();\n+    }\n }\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n                     MockitoSampleTest.class, \n                     EqualsTest.class, \n                     CglibTest.class, \n-                    ExpectedInvocationTest.class, \n+                    InvocationMatcherTest.class, \n                     InvocationChunkTest.class, \n                     MockFactoryTest.class, \n                     MockitoBehaviorTest.class, ", "timestamp": 1197324407, "metainfo": ""}