{"sha": "d5d05a27375f2d8b76607d80f4c2925e2908962e", "log": "Moved configuration to appropriate package Moved experimental runner yet again in some different package I will break the build but I have no choice (stupid svn)  --HG-- rename : src/org/mockito/AnnotationEngine.java => src/org/mockito/configuration/AnnotationEngine.java rename : src/org/mockito/DefaultMockitoConfiguration.java => src/org/mockito/configuration/DefaultMockitoConfiguration.java rename : src/org/mockito/IMockitoConfiguration.java => src/org/mockito/configuration/IMockitoConfiguration.java rename : test/org/mockito/internal/experimental/VerboseMockitoJUnitRunnerTest.java => test/org/junit/mockito/experimental/VerboseMockitoJUnitRunnerTest.java rename : test/org/mockito/MockitoConfiguration.java => test/org/mockito/configuration/MockitoConfiguration.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401209", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n import java.util.Arrays;\n \n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n import java.lang.annotation.Target;\n import java.lang.reflect.Field;\n \n+import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.runners.MockitoJUnit44Runner;\n--- a/src/org/mockito/ReturnValues.java\n+++ b/src/org/mockito/ReturnValues.java\n  */\n package org.mockito;\n \n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n--- /dev/null\n+++ b/src/org/mockito/configuration/AnnotationEngine.java\n+package org.mockito.configuration;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Configures mock creation logic behind &#064;Mock annotations\n+ * <p>\n+ * If you are interested then see implementations or source code of {@link MockitoAnnotations#initMocks(Object)}\n+ */\n+public interface AnnotationEngine {\n+\n+    /**\n+     * Usually the implementation checks the annotation  \n+     * and then creates a mock object for specified field.\n+     * <p>\n+     * You don't need to set the mock on the field. Mockito does it for you. \n+     * If in doubts look for implementations of this interface.\n+     * \n+     * @param annotation annotation on the field, for example &#064;Mock\n+     * @param field field to create mock object for\n+     * @return mock created for specified field. Can be null - then Mockito will not initialize the field\n+     */\n+    Object createMockFor(Annotation annotation, Field field);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n+package org.mockito.configuration;\n+\n+import org.mockito.ReturnValues;\n+import org.mockito.internal.configuration.DefaultAnnotationEngine;\n+import org.mockito.internal.returnvalues.EmptyReturnValues;\n+\n+/**\n+ * DefaultConfiguration of Mockito framework\n+ * <p>\n+ * Currently it doesn't have many configuration options but it will probably change if future.\n+ * <p>\n+ * See javadocs for {@link IMockitoConfiguration} on info how to configure Mockito\n+ */\n+public class DefaultMockitoConfiguration implements IMockitoConfiguration {\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.IMockitoConfiguration#getReturnValues()\n+     */\n+    public ReturnValues getReturnValues() {\n+        return new EmptyReturnValues();\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.mockito.IMockitoConfiguration#getAnnotationEngine()\n+     */\n+    public AnnotationEngine getAnnotationEngine() {\n+        return new DefaultAnnotationEngine();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/configuration/IMockitoConfiguration.java\n+package org.mockito.configuration;\n+\n+import org.mockito.ReturnValues;\n+import org.mockito.internal.returnvalues.EmptyReturnValues;\n+\n+/**\n+ * Use it to configure Mockito. For now there are not many configuration options but it may change in future.\n+ * <p>\n+ * In most cases you don't really need to configure Mockito. For example in case of working with legacy code, \n+ * when you might want to have different 'mocking style' this interface might be helpful. \n+ * A reason of configuring Mockito might be if you disagree with the {@link EmptyReturnValues} unstubbed mocks return.\n+ * <p>\n+ * To configure Mockito create exactly <b>org.mockito.configuration.MockitoConfiguration</b> class that implements this interface.\n+ * <p>\n+ * Configuring Mockito is completely <b>optional</b> - nothing happens if there isn't any <b>org.mockito.configuration.MockitoConfiguration</b> on the classpath. \n+ * <p>\n+ * <b>org.mockito.configuration.MockitoConfiguration</b> must implement IMockitoConfiguration or extend {@link DefaultMockitoConfiguration}\n+ * <p>\n+ * Mockito will store single instance of org.mockito.configuration.MockitoConfiguration per thread (using ThreadLocal). \n+ * For sanity of your tests, don't make the implementation stateful.\n+ * <p>\n+ * If you have comments on Mockito configuration feature don't hesitate to write to mockito@googlegroups.com\n+ */\n+public interface IMockitoConfiguration {\n+\n+    /**\n+     * Allows configuring the default return values of unstubbed invocations\n+     * <p>\n+     * See javadoc for {@link IMockitoConfiguration}\n+     */\n+    ReturnValues getReturnValues();\n+\n+    /**\n+     * Configures annotations for mocks\n+     * <p>\n+     * See javadoc for {@link IMockitoConfiguration}\n+     */\n+    AnnotationEngine getAnnotationEngine();\n+}\n--- a/src/org/mockito/configuration/experimental/ConfigurationSupport.java\n+++ b/src/org/mockito/configuration/experimental/ConfigurationSupport.java\n \n import java.lang.reflect.Modifier;\n \n-import org.mockito.DefaultMockitoConfiguration;\n-import org.mockito.IMockitoConfiguration;\n import org.mockito.Mockito;\n import org.mockito.ReturnValues;\n+import org.mockito.configuration.DefaultMockitoConfiguration;\n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.configuration.MockitoConfiguration;\n import org.mockito.internal.returnvalues.EmptyReturnValues;\n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n package org.mockito.internal.configuration;\n \n-import org.mockito.IMockitoConfiguration;\n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n \n public class ClassPathLoader {\n         //Trying to get config from classpath\n         Class configClass = null;\n         try {\n-            configClass = (Class) Class.forName(\"org.mockito.MockitoConfiguration\");\n+            configClass = (Class) Class.forName(\"org.mockito.configuration.MockitoConfiguration\");\n         } catch (ClassNotFoundException e) {\n             //that's ok, it means there is no global config, using default one. \n             return null;\n                     \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n         } catch (Exception e) {\n             throw new MockitoConfigurationException(\"\\n\" +\n-                    \"Unable to instantianate org.mockito.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n+                    \"Unable to instantianate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n         }\n     }\n }\n--- a/src/org/mockito/internal/configuration/Configuration.java\n+++ b/src/org/mockito/internal/configuration/Configuration.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.DefaultMockitoConfiguration;\n-import org.mockito.IMockitoConfiguration;\n import org.mockito.ReturnValues;\n+import org.mockito.configuration.DefaultMockitoConfiguration;\n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.base.MockitoException;\n \n /**\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n \n-import org.mockito.AnnotationEngine;\n import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockito.MockitoAnnotations;\n+import org.mockito.configuration.AnnotationEngine;\n \n /**\n  * Initializes fields annotated with &#064;Mock\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n package org.mockito.internal.configuration;\n \n-import org.mockito.AnnotationEngine;\n-import org.mockito.DefaultMockitoConfiguration;\n-import org.mockito.IMockitoConfiguration;\n import org.mockito.ReturnValues;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.configuration.DefaultMockitoConfiguration;\n+import org.mockito.configuration.IMockitoConfiguration;\n \n /**\n- * Thread-safe wrapper on user-defined org.mockito.MockitoConfiguration implementation\n+ * Thread-safe wrapper on user-defined org.mockito.configuration.MockitoConfiguration implementation\n  */\n public class GlobalConfiguration implements IMockitoConfiguration {\n     \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n \n     public void validateState() {\n         //State is cool when GlobalConfiguration is already loaded\n-        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.MockitoConfiguration class \n+        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class \n         GlobalConfiguration.validate();\n         \n         if (verificationMode != null) {\n--- a/src/org/mockito/internal/returnvalues/GloballyConfiguredReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/GloballyConfiguredReturnValues.java\n  */\n package org.mockito.internal.returnvalues;\n \n-import org.mockito.IMockitoConfiguration;\n import org.mockito.ReturnValues;\n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.invocation.InvocationOnMock;\n \n--- a/src/org/mockito/internal/returnvalues/SmartNullReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/SmartNullReturnValues.java\n import net.sf.cglib.proxy.MethodInterceptor;\n import net.sf.cglib.proxy.MethodProxy;\n \n-import org.mockito.IMockitoConfiguration;\n import org.mockito.Mockito;\n import org.mockito.ReturnValues;\n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.cause.BecauseThisMethodWasNotStubbed;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n--- /dev/null\n+++ b/test/org/junit/mockito/experimental/VerboseMockitoJUnitRunnerTest.java\n+package org.junit.mockito.experimental;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.mockito.experimental.VerboseMockitoJUnitRunner.JunitTestBody;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class VerboseMockitoJUnitRunnerTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+    \n+    private VerboseMockitoJUnitRunner runner;\n+    private MockitoLoggerStub loggerStub;\n+    private RunNotifier notifier;\n+\n+    @Before\n+    public void setup() throws InitializationError {\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        runner = new VerboseMockitoJUnitRunner(this.getClass(), loggerStub);\n+    }\n+    \n+    //TODO after 1.7 refactor it to override-and-subclass\n+    @Test(expected=RunWasCalled.class)\n+    public void shouldRunTests() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                throw new RunWasCalled();\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                //this is what happens when the test runs:\n+                //first, unused stubbing:\n+                unusedStubbingThatQualifiesForWarning();\n+                //then, let's make the test fail so that warnings are printed\n+                notifier.fireTestFailure(null);\n+                //assert\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n+                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                callUnstubbedMethodThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this method was not stubbed\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(456);\"));\n+                assertThat(loggedInfo, contains(\".callUnstubbedMethodThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                someStubbing();\n+                callStubbedMethodWithDifferentArgs();\n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - stubbed method called with different arguments\"));\n+                assertThat(loggedInfo, contains(\"Stubbed this way:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(789);\"));\n+                assertThat(loggedInfo, contains(\".someStubbing(\"));\n+                \n+                assertThat(loggedInfo, contains(\"But called with different arguments:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(10);\"));\n+                assertThat(loggedInfo, contains(\".callStubbedMethodWithDifferentArgs(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldNotLogAnythingWhenStubCalledCorrectly() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod(1)).thenReturn(\"foo\");\n+                mock.simpleMethod(1);\n+\n+                notifier.fireTestFailure(null);\n+                \n+                assertEquals(\"\", loggerStub.getLoggedInfo());\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldNotLogWhenTestPasses() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod()).thenReturn(\"foo\");\n+                \n+                notifier.fireTestFinished(null);\n+                \n+                assertEquals(\"\", loggerStub.getLoggedInfo());\n+            }\n+        });\n+    }\n+    \n+    \n+    public void shouldClearDebuggingDataAfterwards() throws Exception {\n+        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n+        \n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                unusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                assertTrue(debuggingInfo.hasData());\n+            }\n+        });\n+        \n+        assertFalse(debuggingInfo.hasData());\n+    }    \n+\n+    private void unusedStubbingThatQualifiesForWarning() {\n+        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n+    }\n+\n+    private void callUnstubbedMethodThatQualifiesForWarning() {\n+        mock.simpleMethod(456);\n+    }\n+    \n+    private void someStubbing() {\n+        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n+    }\n+    \n+    private void callStubbedMethodWithDifferentArgs() {\n+        mock.simpleMethod(10);\n+    }\n+    \n+    public class MockitoLoggerStub extends MockitoLoggerImpl {\n+        \n+        StringBuilder loggedInfo = new StringBuilder();\n+        \n+        public void log(Object what) {\n+            super.log(what);\n+            loggedInfo.append(what);\n+        }\n+\n+        public String getLoggedInfo() {\n+            return loggedInfo.toString();\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    private static class RunWasCalled extends RuntimeException {}; \n+}\n--- /dev/null\n+++ b/test/org/mockito/configuration/MockitoConfiguration.java\n+package org.mockito.configuration;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+import org.mockito.Mockito;\n+import org.mockito.ReturnValues;\n+import org.mockito.internal.configuration.Configuration;\n+import org.mockito.internal.configuration.DefaultAnnotationEngine;\n+import org.mockitousage.configuration.SmartMock;\n+\n+@SuppressWarnings(\"deprecation\")\n+public class MockitoConfiguration extends DefaultMockitoConfiguration implements IMockitoConfiguration {\n+\n+    private static ReturnValues overriddenReturnValues = null;\n+\n+    //for testing purposes, allow to override the configuration\n+    public static void overrideReturnValues(ReturnValues returnValues) {\n+        MockitoConfiguration.overriddenReturnValues = returnValues;\n+    }\n+\n+    @Override\n+    public ReturnValues getReturnValues() {\n+        if (overriddenReturnValues == null) {\n+            return Configuration.instance().getReturnValues();\n+        } else {\n+            return overriddenReturnValues;\n+        }\n+    }\n+    \n+    @Override\n+    public AnnotationEngine getAnnotationEngine() {\n+        return new DefaultAnnotationEngine() {\n+            @Override\n+            public Object createMockFor(Annotation annotation, Field field) {\n+                if (annotation instanceof SmartMock) {\n+                    return Mockito.mock(field.getType(), Mockito.RETURNS_SMART_NULLS);\n+                } else {\n+                    return super.createMockFor(annotation, field);\n+                }\n+            }\n+        };\n+    }\n+}\n--- a/test/org/mockitousage/configuration/MockitoConfigurationTest.java\n+++ b/test/org/mockitousage/configuration/MockitoConfigurationTest.java\n \n import org.junit.After;\n import org.junit.Test;\n-import org.mockito.MockitoConfiguration;\n import org.mockito.ReturnValues;\n+import org.mockito.configuration.MockitoConfiguration;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.mockito.experimental.VerboseMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n-import org.mockito.internal.experimental.VerboseMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.mockito.experimental.VerboseMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.internal.experimental.VerboseMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n ", "timestamp": 1232113728, "metainfo": ""}