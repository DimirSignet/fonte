{"sha": "380dcaaf05c73285c9f454e253b41430081694ca", "log": "Changed timesNow to calls, and added tests with mixed verification modes  --HG-- branch : issue296 rename : src/org/mockito/internal/verification/TimesNow.java => src/org/mockito/internal/verification/Calls.java rename : test/org/mockitousage/verification/VerificationInOrderWithTimesNowTest.java => test/org/mockitousage/verification/VerificationInOrderWithCallsTest.java", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     /**\n      * Allows non-greedy verification in order.  For example\n      * <pre class=\"code\"><code class=\"java\">\n-     *   inOrder.verify( mock, timesNow( 2 )).someMethod( \"some arg\" );\n+     *   inOrder.verify( mock, calls( 2 )).someMethod( \"some arg\" );\n      * </code></pre>\n      * <ul>\n      * <li>will not fail if the method is called 3 times, unlike times( 2 )</li>\n      * @param wantedNumberOfInvocations number of invocations to verify\n      * @return  verification mode\n      */\n-    public static VerificationMode timesNow( int wantedNumberOfInvocations ){\n-        return VerificationModeFactory.timesNow( wantedNumberOfInvocations );\n+    public static VerificationMode calls( int wantedNumberOfInvocations ){\n+        return VerificationModeFactory.calls( wantedNumberOfInvocations );\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/Calls.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrder;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.checkers.*;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+public class Calls implements VerificationMode, VerificationInOrderMode {\n+\n+    final int wantedCount;\n+\n+    public Calls(int wantedNumberOfInvocations) {\n+        if( wantedNumberOfInvocations <= 0 ) {\n+            throw new MockitoException( \"Negative and zero values are not allowed here\" );\n+        }\n+        this.wantedCount = wantedNumberOfInvocations;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        throw new MockitoException( \"calls is only intended to work with InOrder\" );\n+    }\n+\n+    public void verifyInOrder(VerificationDataInOrder data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        missingInvocation.check( allInvocations, wanted, this, data.getOrderingContext());\n+        NonGreedyNumberOfInvocationsInOrderChecker numberOfCalls = new NonGreedyNumberOfInvocationsInOrderChecker();\n+        numberOfCalls.check( allInvocations, wanted, wantedCount, data.getOrderingContext());\n+    }    \n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count (non-greedy): \" + wantedCount;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n         return new Times(wantedNumberOfInvocations);\n     }\n \n-    public static TimesNow timesNow( int wantedNumberOfInvocations ) {\n-        return new TimesNow( wantedNumberOfInvocations );\n+    public static Calls calls(int wantedNumberOfInvocations) {\n+        return new Calls( wantedNumberOfInvocations );\n     }\n \n     public static NoMoreInteractions noMoreInteractions() {\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderWithCallsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class VerificationInOrderWithCallsTest extends TestBase {\n+\n+    @Mock private IMethods mockOne;\n+    @Mock private IMethods mockTwo;\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    @Test\n+    public void shouldFailWhenMethodNotCalled(){\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCalledTooFewTimes(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+        exceptionRule.expectMessage( \"Wanted 2 times\" );\n+        exceptionRule.expectMessage( \"But was 1 time\" );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.voidMethod()\" );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+    }\n+    \n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg(1);\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(2)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifyNoMoreInteractions(mockOne);\n+        verifyNoMoreInteractions(mockTwo);\n+        verifier.verifyNoMoreInteractions();\n+    }\n+    \n+    \n+    @Test\n+    public void shouldAllowFewerCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        \n+        exceptionRule.expect( NoInteractionsWanted.class );\n+        verifyNoMoreInteractions( mockOne );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+\n+        exceptionRule.expect( NoInteractionsWanted.class );\n+        verifyNoMoreInteractions( mockOne );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+\n+        exceptionRule.expect(NoInteractionsWanted.class);\n+        verifyNoMoreInteractions( mockTwo );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, calls(1)).voidMethod();\n+        verifier.verify( mockTwo, calls(1)).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithCallsAfterUseOfTimes(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, times(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithCallsAfterUseOfAtLeast(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );\n+        verifier.verify( mockOne, calls(2)).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithTimesAfterUseOfCalls(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, times(2)).oneArg( 2 );\n+        verifier.verify( mockOne, times(1)).oneArg( 1 );\n+\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithAtLeastAfterUseOfCalls(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 2 );\n+        verifier.verify( mockOne, atLeast(1)).oneArg( 1 );\n+    }\n+\n+    @Test\n+    public void shouldVerifyWithTimesAfterCallsInSameChunk(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, calls(1)).oneArg( 1 );\n+        verifier.verify( mockOne, times(2)).oneArg( 1 );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsWithZeroArgument(){\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+        verifier.verify( mockOne, calls(0)).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsWithNegativeArgument(){\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+        verifier.verify( mockOne, calls(-1)).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateCallsForNonInOrderVerification(){\n+        mockOne.voidMethod();\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"calls is only intended to work with InOrder\" );\n+        verify( mockOne, calls(1)).voidMethod();\n+    }\n+}", "timestamp": 1324937916, "metainfo": ""}