{"sha": "71ed6be90d3f3eac95955a9d31fa5f8348c71206", "log": "killing down the verificationModeDecoder  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40978", "commit": "\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderChecker.java\n         this.reporter = reporter;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, Times mode) {\n-        VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n-        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode.wantedCount());\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, wantedCount);\n         \n         boolean noMatchFound = chunk.size() == 0;\n-        if (decoder.neverWanted() && noMatchFound) {\n+        if (wantedCount == 0 && noMatchFound) {\n             return;\n         }\n         \n         int actualCount = chunk.size();\n         \n-        if (decoder.tooLittleActualInvocations(actualCount)) {\n+        if (wantedCount > actualCount) {\n             HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n-            reporter.tooLittleActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted, lastInvocation);\n-        } else if (decoder.tooManyActualInvocations(actualCount)) {\n-            HasStackTrace firstUndesired = chunk.get(mode.wantedCount()).getStackTrace();\n-            reporter.tooManyActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted, firstUndesired);\n+            reporter.tooLittleActualInvocationsInOrder(wantedCount, actualCount, wanted, lastInvocation);\n+        } else if (wantedCount < actualCount) {\n+            HasStackTrace firstUndesired = chunk.get(wantedCount).getStackTrace();\n+            reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n         for (Invocation i : chunk) {\n--- a/src/org/mockito/internal/verification/Times.java\n+++ b/src/org/mockito/internal/verification/Times.java\n             missingInvocation.verify(allInvocations, wanted, this);\n         }\n         NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();\n-        numberOfCalls.verify(allInvocations, wanted, this);\n+        numberOfCalls.verify(allInvocations, wanted, wantedCount);\n     }\n     \n     @Override\n--- a/src/org/mockito/internal/verification/VerificationModeDecoder.java\n+++ b/src/org/mockito/internal/verification/VerificationModeDecoder.java\n         this.mode = mode;\n     }\n \n-    public boolean tooLittleActualInvocations(int actualCount) {\n-        return mode.wantedCount() > actualCount; \n-    }\n-\n-    public boolean tooManyActualInvocations(int actualCount) {\n-        return mode.wantedCount() < actualCount;\n-    }\n-    \n     public boolean neverWanted() {\n         return mode.wantedCount() == 0;\n     }\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsInOrderCheckerTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockitoutil.TestBase;\n \n public class NumberOfInvocationsInOrderCheckerTest extends TestBase {\n     @Test\n     public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {\n         assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());\n-        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).inOrder());\n+        verifier.verify(invocations, wanted, 0);\n     }\n     \n     @Test\n     public void shouldPassIfChunkMatches() throws Exception {\n         finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());\n         \n-        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+        verifier.verify(invocations, wanted, 1);\n     }\n     \n     @Test\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n-            verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).inOrder());\n+            verifier.verify(invocations, wanted, 4);\n             fail();\n         } catch (VerifcationInOrderFailure e) {\n             assertThat(e, messageContains(\"Wanted 4 times but was 2\"));\n         finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n         \n         try {\n-            verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+            verifier.verify(invocations, wanted, 1);\n             fail();\n         } catch (VerifcationInOrderFailure e) {\n             assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n         assertFalse(invocation.isVerifiedInOrder());\n         finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n         \n-        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+        verifier.verify(invocations, wanted, 1);\n         \n         assertTrue(invocation.isVerifiedInOrder());\n     }\n--- a/test/org/mockito/internal/verification/VerificationModeDecoderTest.java\n+++ b/test/org/mockito/internal/verification/VerificationModeDecoderTest.java\n     \n     private VerificationModeDecoder decode(Times mode) {\n         return new VerificationModeDecoder(mode);\n-    }\n-    \n-    @Test\n-    public void shouldKnowIfTooLittleActualInvocations() throws Exception {\n-        assertTrue(decode(VerificationModeFactory.times(1)).tooLittleActualInvocations(0));\n-        assertTrue(decode(VerificationModeFactory.times(10)).tooLittleActualInvocations(9));\n-        \n-        assertFalse(decode(VerificationModeFactory.times(0)).tooLittleActualInvocations(0));\n-        assertFalse(decode(VerificationModeFactory.times(1)).tooLittleActualInvocations(1));\n-        assertFalse(decode(VerificationModeFactory.times(1)).tooLittleActualInvocations(2));\n-    }\n-    \n-    @Test\n-    public void shouldKnowIfTooManyActualInvocations() throws Exception {\n-        assertTrue(decode(VerificationModeFactory.times(0)).tooManyActualInvocations(1));\n-        assertTrue(decode(VerificationModeFactory.times(10)).tooManyActualInvocations(11));\n-        \n-        assertFalse(decode(VerificationModeFactory.times(0)).tooManyActualInvocations(0));\n-        assertFalse(decode(VerificationModeFactory.times(1)).tooManyActualInvocations(1));\n-        assertFalse(decode(VerificationModeFactory.times(2)).tooManyActualInvocations(1));\n     }\n     \n     @Test", "timestamp": 1223982837, "metainfo": ""}