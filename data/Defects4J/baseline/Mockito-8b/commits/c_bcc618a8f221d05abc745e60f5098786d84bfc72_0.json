{"sha": "bcc618a8f221d05abc745e60f5098786d84bfc72", "log": "refactored static Exceptions class into proper Reporter class  --HG-- rename : src/org/mockito/exceptions/Exceptions.java => src/org/mockito/exceptions/Reporter.java rename : test/org/mockito/exceptions/ExceptionsTest.java => test/org/mockito/exceptions/ReporterTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40185", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n+    \n+    private static final Reporter reporter = new Reporter();\n     \n     static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n         \n         OngoingStubbing stubable = mockingProgress.pullStubable();\n         if (stubable == null) {\n-            Exceptions.missingMethodInvocation();\n+            reporter.missingMethodInvocation();\n         }\n         return stubable;\n     }\n \n     private static void assertMocksNotEmpty(Object[] mocks) {\n         if (mocks.length == 0) {\n-            Exceptions.mocksHaveToBePassedAsArguments();\n+            reporter.mocksHaveToBePassedAsArguments();\n         }\n     }\n \n \n     public static Strictly createStrictOrderVerifier(Object ... mocks) {\n         if (mocks.length == 0) {\n-            Exceptions.mocksHaveToBePassedWhenCreatingStrictly();\n+            reporter.mocksHaveToBePassedWhenCreatingStrictly();\n         }\n         StrictOrderVerifier strictOrderVerifier = new StrictOrderVerifier();\n         for (Object mock : mocks) {\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n \n import java.util.*;\n \n-import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.progress.VerificationMode;\n \n class StrictOrderVerifier implements Strictly {\n     \n-    List<Object> mocksToBeVerifiedSrictly = new LinkedList<Object>();\n+    private final Reporter reporter = new Reporter();\n+    private final List<Object> mocksToBeVerifiedSrictly = new LinkedList<Object>();\n     \n     public <T> T verify(T mock) {\n         return this.verify(mock, 1);\n     \n     public <T> T verify(T mock, VerificationMode verificationMode) {\n         if (!mocksToBeVerifiedSrictly.contains(mock)) {\n-            Exceptions.strictlyRequiresFamiliarMock();\n+            reporter.strictlyRequiresFamiliarMock();\n         }\n         return Mockito.verify(mock, VerificationMode.strict(verificationMode.wantedCount(), mocksToBeVerifiedSrictly));\n     }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/Reporter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+import static org.mockito.exceptions.StringJoiner.join;\n+\n+import org.mockito.exceptions.cause.*;\n+import org.mockito.exceptions.misusing.*;\n+import org.mockito.exceptions.parents.*;\n+import org.mockito.exceptions.verification.*;\n+\n+/**\n+ * One of the key points of mocking library is proper verification/exception\n+ * messages. All messages in one place makes it easier to tune and amend.\n+ */\n+public class Reporter {\n+    \n+    private String pluralize(int number) {\n+        return number == 1 ? \"1 time\" : number + \" times\";\n+    }\n+\n+    public void mocksHaveToBePassedAsArguments() {\n+        throw new MockitoException(join(\n+                \"Method requires arguments.\",\n+                \"Pass mocks that should be verified, e.g:\",\n+                \"verifyNoMoreInteractions(mockOne, mockTwo)\"\n+                ));\n+    }\n+\n+    public void strictlyRequiresFamiliarMock() {\n+        throw new MockitoException(join(\n+                \"Strictly can only verify mocks that were passed in during creation of Strictly. E.g:\",\n+                \"strictly = createStrictOrderVerifier(mockOne)\",\n+                \"strictly.verify(mockOne).doStuff()\"\n+                ));\n+    }\n+\n+    public void mocksHaveToBePassedWhenCreatingStrictly() {\n+        throw new MockitoException(join(\n+                \"Method requires arguments.\",\n+                \"Pass mocks that require strict order verification, e.g:\",\n+                \"createStrictOrderVerifier(mockOne, mockTwo)\"\n+                ));\n+    }\n+\n+    public void checkedExceptionInvalid(Throwable t) {\n+        throw new MockitoException(join(\n+        \t\t\"Checked exception is invalid for this method\",\n+        \t\t\"Invalid: \" + t\n+        \t\t));\n+    }\n+\n+    public void cannotStubWithNullThrowable() {\n+        throw new MockitoException(join(\n+                \"Cannot stub with null throwable\"\n+                ));\n+        \n+    }\n+    \n+    public void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+        WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n+                \"Actual invocation:\",\n+                actual\n+            ));\n+            \n+        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+        \n+        throw new VerificationError(join(\n+                \"Invocation differs from actual\",\n+                \"Wanted invocation:\",\n+                wanted\n+            ), cause);\n+    }\n+    \n+    public void wantedButNotInvoked(String wanted) {\n+        throw new VerificationError(join(\n+                    \"Wanted but not invoked:\",\n+                    wanted        \n+        ));\n+    }\n+    \n+    public void numberOfInvocationsDiffers(int wantedCount, int actualCount, String wanted) {\n+        throw new NumberOfInvocationsError(join(\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ));\n+    }\n+\n+    public void tooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n+        FirstUndesiredInvocation cause = new FirstUndesiredInvocation(join(\"First undesired invocation:\"));\n+        cause.setStackTrace(firstUndesired.getStackTrace());\n+        \n+        throw new TooManyActualInvocationsError(join(\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);\n+    }\n+    \n+    public void tooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n+        TooLittleInvocations cause = null;\n+        if (lastActualInvocationStackTrace != null) {\n+            cause = new TooLittleInvocations(join(\"Too little invocations:\"));\n+            cause.setStackTrace(lastActualInvocationStackTrace.getStackTrace());\n+        }\n+        \n+        throw new TooLittleActualInvocationsError(join(\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);  \n+    }\n+\n+    public void noMoreInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n+        UndesiredInvocation cause = buildUndesiredInvocationCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n+        throw new VerificationError(join(\"No more interactions wanted\"), cause);\n+    }\n+    \n+    public void zeroInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n+        UndesiredInvocation cause = buildUndesiredInvocationCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n+        throw new VerificationError(join(\"Zero interactions wanted\"), cause);\n+    }\n+\n+    private UndesiredInvocation buildUndesiredInvocationCause(HasStackTrace actualInvocationStackTrace, String ... messageLines) {\n+        UndesiredInvocation cause = new UndesiredInvocation(join(messageLines));\n+        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+        return cause;\n+    }\n+\n+    public void unfinishedStubbing() {\n+        throw new UnfinishedStubbingException(join(\n+                \"Unifinished stubbing detected, e.g. toReturn() is missing\",\n+                \"Examples of proper stubbing:\",\n+                \"stub(mock.isOk()).andReturn(true);\",\n+                \"stub(mock.isOk()).andThrows(exception);\",\n+                \"stubVoid(mock).toThrow(exception).on().someMethod();\"\n+        ));\n+    }\n+\n+    public void missingMethodInvocation() {\n+        throw new MissingMethodInvocationException(join(\n+                \"stub() requires an argument which has to be a proper method call on a mock object\"\n+        ));\n+    }\n+\n+    public void unfinishedVerificationException() {\n+        throw new UnfinishedVerificationException(join(\n+                \"Previous verify(mock) doesn't have a method call.\",\n+                \"Should be something like that: verify(mock).doSomething()\"\n+        ));\n+    }\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import java.util.Arrays;\n import java.util.List;\n \n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.creation.MockAwareInvocationHandler;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n     private VerifyingRecorder createRecorder() {\n         InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder());\n         InvocationsMarker marker = new InvocationsMarker();\n-        List<Verifier> verifiers = Arrays.asList(new MissingInvocationVerifier(), new NumberOfInvocationsVerifier());\n+        List<Verifier> verifiers = Arrays.asList(new MissingInvocationVerifier(), new NumberOfInvocationsVerifier(new Reporter()));\n         return new VerifyingRecorder(chunker, marker, verifiers);\n     }\n \n--- a/src/org/mockito/internal/invocation/InvocationsCalculator.java\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculator.java\n \n     private List<Invocation> invocations = new LinkedList<Invocation>();\n \n+    public InvocationsCalculator() {}\n+    \n     public InvocationsCalculator(List<Invocation> invocations) {\n         this.invocations.addAll(invocations);\n     }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n  */\n package org.mockito.internal.progress;\n \n-import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.Reporter;\n \n @SuppressWarnings(\"unchecked\")\n public class MockingProgressImpl implements MockingProgress {\n+    \n+    private final Reporter reporter = new Reporter();\n     \n     private OngoingStubbing ongoingStubbing;\n     private VerificationMode verificationMode;\n     public void validateState() {\n         if (verificationMode != null) {\n             verificationMode = null;\n-            Exceptions.unfinishedVerificationException();\n+            reporter.unfinishedVerificationException();\n         }\n         \n         if (stubbingInProgress) {\n             stubbingInProgress = false;\n-            Exceptions.unfinishedStubbing();\n+            reporter.unfinishedStubbing();\n         }\n     }\n \n         verificationMode = null;\n         invocationSequenceNumber = 1;\n     }\n-}\n+}\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n \n import java.util.LinkedList;\n \n-import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n \n public class Stubber {\n \n+    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n+    private final Reporter reporter = new Reporter();\n+    private final MockingProgress mockingProgress;\n+    \n     private InvocationMatcher invocationForStubbing;\n-    private LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private Throwable throwableForVoidMethod;\n-    private final MockingProgress mockingProgress;\n     \n     public Stubber(MockingProgress mockingProgress) {\n         this.mockingProgress = mockingProgress;\n     \n     private void validateThrowable(Throwable throwable) {\n         if (throwable == null) {\n-            Exceptions.cannotStubWithNullThrowable();\n+            reporter.cannotStubWithNullThrowable();\n         }\n \n         if (throwable instanceof RuntimeException || throwable instanceof Error) {\n         }\n     \n         if (!isValidCheckedException(throwable)) {\n-            Exceptions.checkedExceptionInvalid(throwable);\n+            reporter.checkedExceptionInvalid(throwable);\n         }\n     }\n \n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n \n public class MissingInvocationVerifier implements Verifier {\n+    \n+    private final Reporter reporter = new Reporter();\n \n     public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n         int actualCount = calculator.countActual(wanted);\n         \n         if (actual != null) {\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n-            Exceptions.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n+            reporter.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n         } else {\n-            Exceptions.wantedButNotInvoked(wanted.toString());\n+            reporter.wantedButNotInvoked(wanted.toString());\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n+    \n+    private final Reporter reporter;\n+\n+    public NumberOfInvocationsVerifier(Reporter reporter) {\n+        this.reporter = reporter;\n+    }\n \n     public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n         if (mode.atLeastOnceMode()) {\n         \n         if (actualCount < wantedCount) {\n             HasStackTrace lastInvocation = calculator.getLastInvocationStackTrace(wanted);\n-            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n+            reporter.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n             HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(wanted, mode);\n-            Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n+            reporter.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n public class VerifyingRecorder {\n \n     private final LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();\n+    private final Reporter reporter = new Reporter();\n+    \n     private final InvocationsMarker marker;\n     private final List<Verifier> verifiers;\n     private final InvocationsChunker chunker;\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n-            Exceptions.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n+            reporter.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n     }\n     \n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n-            Exceptions.zeroInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n+            reporter.zeroInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/exceptions/ReporterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+\n+public class ReporterTest extends RequiresValidState {\n+\n+    @Test(expected=TooLittleActualInvocationsError.class)\n+    public void shouldLetPassingNullLastActualStackTrace() throws Exception {\n+        new Reporter().tooLittleActualInvocations(1, 2, \"wanted\", null);\n+    }\n+}\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n  */\n package org.mockito.internal.verification;\n \n+import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationMode.times;\n+\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n \n-@SuppressWarnings(\"unchecked\")\n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n \n     private NumberOfInvocationsVerifier verifier;\n-    //TODO other tests\n+    private InvocationsCalculatorStub calculatorStub;\n+    private InvocationMatcher wanted;\n     \n     @Before\n     public void setup() {\n-        verifier = new NumberOfInvocationsVerifier();\n+        verifier = new NumberOfInvocationsVerifier(new Reporter());\n+        calculatorStub = new InvocationsCalculatorStub();\n+        wanted = new InvocationBuilder().toInvocationMatcher();\n     }\n \n     @Test\n     public void shouldNotCheckForWrongNumberOfModificationsWhenAtLeastOnceVerification() throws Exception {\n-        verifier.verify(null, null, VerificationMode.atLeastOnce());\n+        verifier.verify(null, null, atLeastOnce());\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void shouldReportTooLittleInvocations() throws Exception {\n+        verifier.verify(calculatorStub, wanted, times(4));\n+        \n+    }\n+    \n+    class InvocationsCalculatorStub extends InvocationsCalculator {\n+        private InvocationMatcher wanted;\n+        @Override\n+        public int countActual(InvocationMatcher wanted) {\n+            this.wanted = wanted;\n+            return 5;\n+        }\n     }\n }", "timestamp": 1197642734, "metainfo": ""}