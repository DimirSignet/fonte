{"sha": "80279d6b0928f5af520dfe3bc10e0bcd46f64516", "log": "Got rid of all warnings. Minor changes to exception messages  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4060", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n package org.mockito;\n \n-import java.util.*;\n-\n-import org.mockito.exceptions.*;\n+import org.mockito.exceptions.MissingMethodInvocationException;\n import org.mockito.internal.*;\n \n @SuppressWarnings(\"unchecked\")\n         return MockUtil.getControl(mock);\n     }\n \n-    //TODO experimental in order syntax (I know is ugly)\n-    public static <T> T verifyInOrder(T mock, int exactNumberOfInvocations) {\n-        //TODO validate mocks\n-        return mock;\n-    }\n-\n-    public static <T> T verifyInOrder(T mock) {\n-        //TODO validate mocks\n-        return mock;\n+    public static StrictOrderVerifier strictOrderVerifier(Object ... mocks) {\n+        for (Object mock : mocks) {\n+            MockUtil.validateMock(mock);\n+        }\n+        return new StrictOrderVerifier();\n     }\n }\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n package org.mockito.exceptions;\n+\n+import org.mockito.internal.InvocationWithMatchers;\n \n \n public class NumberOfInvocationsAssertionError extends MockitoAssertionError {\n \n     private static final long serialVersionUID = 1L;\n \n-    public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked) {\n-        super(\"Expected to be invoked \" + expectedInvoked + \" times but was \" + actuallyInvoked);\n+    public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked, InvocationWithMatchers invocation) {\n+        super(  \"\\n\" +\n+                invocation.toString() +\n+        \t\t\"\\n\" +\n+        \t\t\"Expected \" + pluralize(expectedInvoked) + \" but was \" + actuallyInvoked);\n     }\n-}\n+\n+    private static String pluralize(int expectedInvoked) {\n+        return expectedInvoked == 1 ? \"1 time\" : expectedInvoked + \" times\";\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/StrictVerificationError.java\n+package org.mockito.exceptions;\n+\n+public class StrictVerificationError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public StrictVerificationError() {\n+        super(\"blah\");\n+    }\n+}\n--- a/src/org/mockito/internal/InvocationWithMatchers.java\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n         StringBuilder result = new StringBuilder();\n         result.append(invocation.getMockAndMethodName());\n         result.append(\"(\");\n-        for (Class paramType : invocation.getMethod().getParameterTypes()) {\n+        for (Class<?> paramType : invocation.getMethod().getParameterTypes()) {\n             result.append(paramType);\n             result.append(\", \");\n         }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n             int expectedInvoked = verifyingMode.getExactNumberOfInvocations();\n             \n             if (actuallyInvoked != expectedInvoked) {\n-                throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked);\n+                throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, invocation);\n             } \n         } else {\n             if (actuallyInvoked == 0) {\n                 InvocationWithMatchers similarInvocation = findSimilarInvocation(invocation);\n                 String message = \n                     \"\\n\" +\n-                    \"Invocation differs from actual:\" +\n+                    \"Invocation differs from actual\" +\n                     \"\\n\";\n                 \n                 String expected = invocation.toString();\n--- a/src/org/mockito/internal/ObjenesisClassInstantiator.java\n+++ b/src/org/mockito/internal/ObjenesisClassInstantiator.java\n \n public class ObjenesisClassInstantiator {\n \n-    public static Object newInstance(Class clazz) throws InstantiationException {\n+    public static Object newInstance(Class<?> clazz) throws InstantiationException {\n         return ObjenesisHelper.newInstance(clazz);\n     }\n }\n--- a/src/org/mockito/internal/Result.java\n+++ b/src/org/mockito/internal/Result.java\n  */\n package org.mockito.internal;\n \n-\n+@SuppressWarnings(\"unchecked\")\n public class Result implements IAnswer {\n \n     private IAnswer value;\n--- /dev/null\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n+package org.mockito.internal;\n+\n+import org.mockito.Mockito;\n+\n+public class StrictOrderVerifier {\n+    \n+    public <T> T verify(T mock) {\n+        return Mockito.verify(mock);\n+    }\n+    \n+    public <T> T verify(T mock, int exactNumberOfInvocations) {\n+        return Mockito.verify(mock, exactNumberOfInvocations);\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        MockitoState.instance().checkForUnfinishedVerification();\n+    }\n+}\n--- a/src/org/mockito/internal/ToTypeMappings.java\n+++ b/src/org/mockito/internal/ToTypeMappings.java\n         primitiveToWrapperType.put(Double.TYPE, Double.class);\n     }\n     \n-    public static Object emptyReturnValueFor(Class type) {\n+    public static Object emptyReturnValueFor(Class<?> type) {\n         return emptyReturnValueToType.get(type);\n     }\n     \n--- a/src/org/mockito/internal/matchers/InstanceOf.java\n+++ b/src/org/mockito/internal/matchers/InstanceOf.java\n \n     private final Class<?> clazz;\n \n-    public InstanceOf(Class clazz) {\n+    public InstanceOf(Class<?> clazz) {\n         this.clazz = clazz;\n     }\n \n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         Mockito.stubVoid(notMock);\n     }\n     \n+    @Test(expected=NotAMockException.class)\n+    public void shouldValidateMockWhenEnablingStrictChecking() {\n+        Mockito.strictOrderVerifier(notMock);\n+    }\n+    \n     @Test\n     public void shouldDetectUnfinishedVerification() {\n         verify(mock);\n--- a/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n         } catch (VerificationAssertionError error) {\n             String expected = \n                 \"\\n\" +\n-        \t\t\"Invocation differs from actual:\" +\n+        \t\t\"Invocation differs from actual\" +\n         \t\t\"\\n\" +\n         \t\t\"Expected: DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$Message)\" +\n         \t\t\"\\n\" +\n--- a/test/org/mockito/usage/stubbing/ReturningDefaultValuesTest.java\n+++ b/test/org/mockito/usage/stubbing/ReturningDefaultValuesTest.java\n \n import static org.junit.Assert.*;\n \n-import java.lang.reflect.*;\n import java.util.*;\n \n import org.junit.Test;\n--- a/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n package org.mockito.usage.verification;\n \n-import static org.hamcrest.CoreMatchers.equalTo;\n import static org.junit.Assert.*;\n \n import java.util.LinkedList;\n \n-import org.junit.Test;\n+import org.junit.*;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.NumberOfInvocationsAssertionError;\n \n @SuppressWarnings(\"unchecked\")\n public class ExactNumberOfTimesVerificationTest {\n \n+    private LinkedList mock;\n+    \n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(LinkedList.class); \n+    }\n+    \n     @Test\n     public void shouldVerifyActualNumberOfInvocationsSmallerThanExpected() throws Exception {\n-        LinkedList mock = Mockito.mock(LinkedList.class);\n         mock.clear();\n         mock.clear();\n         mock.clear();\n         try {\n             Mockito.verify(mock, 100).clear();\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 100 times but was 3\"));\n+        } catch (NumberOfInvocationsAssertionError e) {\n+            String expected = \n+                \"\\n\" +\n+                \"LinkedList.clear()\" +\n+        \t\t\"\\n\" +\n+        \t\t\"Expected 100 times but was 3\";\n+            assertEquals(expected, e.getMessage());\n         }\n     }\n     \n     @Test\n     public void shouldVerifyActualNumberOfInvocationsLargerThanExpected() throws Exception {\n-        LinkedList mock = Mockito.mock(LinkedList.class);\n         mock.clear();\n         mock.clear();\n         mock.clear();\n         try {\n             Mockito.verify(mock, 1).clear();\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 1 times but was 3\"));\n+        } catch (NumberOfInvocationsAssertionError e) {\n+            String expected = \n+                \"\\n\" +\n+                \"LinkedList.clear()\" +\n+                \"\\n\" +\n+                \"Expected 1 time but was 3\";\n+            assertEquals(expected, e.getMessage());\n         }\n     }\n     \n     @Test\n     public void shouldVerifyProperlyIfMethodWasNotInvoked() throws Exception {\n-        LinkedList mock = Mockito.mock(LinkedList.class);\n-\n         Mockito.verify(mock, 0).clear();\n         try {\n             Mockito.verify(mock, 15).clear();\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 15 times but was 0\"));\n+        } catch (NumberOfInvocationsAssertionError e) {\n+            assertTrue(e.getMessage().endsWith(\"Expected 15 times but was 0\"));\n         }\n     }\n     \n     @Test\n     public void shouldVerifyProperlyIfMethodWasInvokedOnce() throws Exception {\n-        LinkedList mock = Mockito.mock(LinkedList.class);\n-\n         mock.clear();\n         \n         Mockito.verify(mock, 1).clear();\n         try {\n             Mockito.verify(mock, 15).clear();\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 15 times but was 1\"));\n+        } catch (NumberOfInvocationsAssertionError e) {\n+            assertTrue(e.getMessage().endsWith(\"Expected 15 times but was 1\"));\n         }\n     }\n     \n     @Test\n     public void shouldNotCountInStubbedInvocations() throws Exception {\n-        LinkedList mock = Mockito.mock(LinkedList.class);\n-        \n         Mockito.stub(mock.add(\"test\")).andReturn(false);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-                    \"Invocation differs from actual:\" +\n+                    \"Invocation differs from actual\" +\n                     \"\\n\" +\n                     \"Expected: IMethods.twoArgumentMethod(1, 1000)\" +\n                     \"\\n\" +\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-                    \"Invocation differs from actual:\" +\n+                    \"Invocation differs from actual\" +\n                     \"\\n\" +\n                     \"Expected: IMethods.simpleMethod(\\\"test\\\")\" +\n                     \"\\n\" +\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-                    \"Invocation differs from actual:\" +\n+                    \"Invocation differs from actual\" +\n                     \"\\n\" +\n                     \"Expected: IMethods.twoArgumentMethod(3, 1000)\" +\n                     \"\\n\" +\n--- /dev/null\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.usage.verification;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.mockito.internal.StrictOrderVerifier;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class VerificationInOrderMixedWithOrdiraryVerificationTest {\n+    \n+    private LinkedList list;\n+    private HashMap map;\n+    private HashSet set;\n+    private StrictOrderVerifier strictly;\n+\n+    @Before\n+    public void setUp() {\n+        list = mock(LinkedList.class);\n+        map = mock(HashMap.class);\n+        set = mock(HashSet.class);\n+\n+        list.add(\"one\");\n+        map.put(\"two\", \"two\");\n+        list.add(\"three and four\");\n+        list.add(\"three and four\");\n+        map.put(\"five\", \"five\");\n+        set.add(\"six\");\n+        \n+        strictly = strictOrderVerifier(list, map, set);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrder() {\n+        strictly.verify(list).add(\"one\");\n+        strictly.verify(map).put(\"two\", \"two\");\n+        strictly.verify(list).add(\"three and four\");\n+        strictly.verify(map).put(\"five\", \"five\");\n+        strictly.verify(set).add(\"six\");\n+    } \n+    \n+    //TODO add some more testing about it... what about a case when verifier gets different mock (not strict)?\n+    \n+}\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n  */\n package org.mockito.usage.verification;\n \n-import static org.mockito.Mockito.mock;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n \n import java.util.*;\n \n import org.junit.*;\n-import org.mockito.Mockito;\n import org.mockito.exceptions.*;\n+import org.mockito.internal.StrictOrderVerifier;\n \n @SuppressWarnings(\"unchecked\")  \n public class VerificationInOrderTest {\n     private LinkedList list;\n     private HashMap map;\n     private HashSet set;\n+    private StrictOrderVerifier strictly;\n \n     @Before\n     public void setUp() {\n         list.add(\"three and four\");\n         map.put(\"five\", \"five\");\n         set.add(\"six\");\n+        \n+        strictly = strictOrderVerifier(list, map, set);\n     }\n-\n+    \n     @Test\n     public void shouldVerifyInOrder() {\n-        Mockito.verifyInOrder(list).add(\"one\");\n-        Mockito.verifyInOrder(map).put(\"one\", \"two\");\n-        Mockito.verifyInOrder(list).add(\"three and four\");\n-        Mockito.verifyInOrder(map).put(\"five\", \"five\");\n-        Mockito.verifyInOrder(set).add(\"six\");\n+        strictly.verify(list).add(\"one\");\n+        strictly.verify(map).put(\"two\", \"two\");\n+        strictly.verify(list).add(\"three and four\");\n+        strictly.verify(map).put(\"five\", \"five\");\n+        strictly.verify(set).add(\"six\");\n+        strictly.verifyNoMoreInteractions();\n     } \n \n     @Test\n     public void shouldVerifyInOrderWithExactNumberOfInvocations() {\n-        Mockito.verifyInOrder(list, 1).add(\"one\");\n-        Mockito.verifyInOrder(map).put(\"one\", \"two\");\n-        Mockito.verifyInOrder(list, 2).add(\"three and four\");\n-        Mockito.verifyInOrder(map, 1).put(\"five\", \"five\");\n-        Mockito.verifyInOrder(set, 1).add(\"six\");\n+        strictly.verify(list, 1).add(\"one\");\n+        strictly.verify(map).put(\"two\", \"two\");\n+        strictly.verify(list, 2).add(\"three and four\");\n+        strictly.verify(map, 1).put(\"five\", \"five\");\n+        strictly.verify(set, 1).add(\"six\");\n+        strictly.verifyNoMoreInteractions();\n     }  \n     \n-    @Ignore\n     @Test(expected = VerificationAssertionError.class)\n     public void shouldFailOnOrdinaryVerificationError() {\n-        Mockito.verifyInOrder(list).add(\"xxx\");\n+        strictly.verify(list).add(\"xxx\");\n+    }\n+    \n+    @Test(expected = NumberOfInvocationsAssertionError.class)\n+    public void shouldFailOnExactNumberOfInvocations() {\n+        strictly.verify(list, 2).add(\"xxx\");\n     }\n     \n     @Ignore\n-    @Test(expected = NumberOfInvocationsAssertionError.class)\n-    public void shouldFailOnExactNumberOfInvocations() {\n-        Mockito.verifyInOrder(list, 2).add(\"xxx\");\n+    @Test\n+    public void shouldFailOnWrongOrder() {\n+        strictly.verify(list, 1).add(\"one\");\n+        strictly.verify(map).put(\"two\", \"two\");\n+        try {\n+            strictly.verify(map, 1).put(\"five\", \"five\");\n+            fail();\n+        } catch (StrictVerificationError e) {\n+//            String expected = \"\\n\" +\n+//                    \"Expected next invocation:\" +\n+//                    \"\\n\" +\n+//                    \"HashMap.put(\\\"five\\\", \\\"five\\\")\" +\n+//                    \"\\n\" +\n+//                  \"Actual next invocation:\" +\n+//                  \"\\n\" +\n+//                  \"LinkedList.add(\\\"three and four\\\")\" +\n+//                  \"\\n\";\n+//            assertEquals(expected, e.getMessage());\n+        }\n     }\n }", "timestamp": 1195926400, "metainfo": ""}