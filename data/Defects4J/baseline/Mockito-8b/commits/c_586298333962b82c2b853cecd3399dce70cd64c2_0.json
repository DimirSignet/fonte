{"sha": "586298333962b82c2b853cecd3399dce70cd64c2", "log": "verifiers tests and refactorings  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40198", "commit": "\n--- a/src/org/mockito/internal/progress/VerificationMode.java\n+++ b/src/org/mockito/internal/progress/VerificationMode.java\n         return wantedInvocationCount != null && wantedInvocationCount == 0;\n     }\n     \n+    public boolean isExplicit() {\n+        return verification == Verification.EXPLICIT;\n+    }\n+    \n+    public boolean missingMethodMode() {\n+        return isExplicit() && (atLeastOnceMode() || wantedInvocationCount == 1);\n+    }\n+    \n     @Override\n     public String toString() {\n         return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedInSequence;\n     }\n-\n-    public boolean isExplicit() {\n-        return verification == Verification.EXPLICIT;\n-    }\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n \n public class MissingInvocationVerifier implements Verifier {\n     \n-    private final Reporter reporter = new Reporter();\n-    private final InvocationsCalculator calculator = new InvocationsCalculator();\n+    private final Reporter reporter;\n+    private final InvocationsCalculator calculator;\n     \n+    public MissingInvocationVerifier() {\n+        this(new InvocationsCalculator(), new Reporter());\n+    }\n+    \n+    public MissingInvocationVerifier(InvocationsCalculator calculator, Reporter reporter) {\n+        this.calculator = calculator;\n+        this.reporter = reporter;\n+    }\n+\n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n-        if (!mode.isExplicit()) {\n+        if (!mode.missingMethodMode()) {\n             return;\n         }\n         \n         int actualCount = calculator.countActual(invocations, wanted);\n-        Integer wantedCount = mode.wantedCount();\n-        boolean atLeastOnce = mode.atLeastOnceMode();\n-               \n-        if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n+        if (actualCount == 0) {\n             reportMissingInvocationError(invocations, wanted);\n         }\n     }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n     }\n     \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n-        if (mode.atLeastOnceMode() || !mode.isExplicit()) {\n+        if (mode.numberOfInvocationsMode()) {\n             return;\n         }\n         \n         int actualCount = calculator.countActual(invocations, wanted);\n-        Integer wantedCount = mode.wantedCount();\n+        int wantedCount = mode.wantedCount();\n         \n         if (actualCount < wantedCount) {\n             HasStackTrace lastInvocation = calculator.getLastInvocationStackTrace(invocations, wanted);\n--- a/test/org/mockito/internal/progress/VerificationModeTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.parents.MockitoException;\n import org.mockito.internal.progress.VerificationMode;\n+import static org.mockito.internal.progress.VerificationMode.*;\n \n public class VerificationModeTest extends RequiresValidState {\n \n+    //TODO add non trivial tests\n     @Test\n     public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n-        VerificationMode mode = VerificationMode.atLeastOnce();\n+        VerificationMode mode = atLeastOnce();\n         assertTrue(mode.atLeastOnceMode());\n         \n-        mode = VerificationMode.times(50);\n+        mode = times(50);\n         assertFalse(mode.atLeastOnceMode());\n     }\n     \n     @Test\n     public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n         try {\n-            VerificationMode.times(-50);\n+            times(-50);\n             fail();\n         } catch (MockitoException e) {\n             assertEquals(\"Negative value is not allowed here\", e.getMessage());\n         }\n     }\n+    \n+    @Test\n+    public void shouldKnowIfIsMissingMethodMode() throws Exception {\n+        assertTrue(atLeastOnce().missingMethodMode());\n+        assertTrue(times(1).missingMethodMode());\n+        \n+        assertFalse(noMoreInteractions().missingMethodMode());\n+        assertFalse(times(0).missingMethodMode());\n+        assertFalse(times(2).missingMethodMode());\n+    }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n package org.mockito.internal.verification;\n \n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationMode.noMoreInteractions;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n-\n \n public class MissingInvocationVerifierTest extends RequiresValidState {\n \n-    //TODO more tests\n+    private MissingInvocationVerifier verifier;\n+    private InvocationsCalculatorStub calculatorStub;\n+    private ReporterStub reporterStub;\n+    \n+    private InvocationMatcher wanted;\n+    private List<Invocation> invocations;\n+\n+    @Before\n+    public void setup() {\n+        calculatorStub = new InvocationsCalculatorStub();\n+        reporterStub = new ReporterStub();\n+        verifier = new MissingInvocationVerifier(calculatorStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = asList(new InvocationBuilder().toInvocation());\n+    }\n+    \n     @Test\n-    public void shouldVerifyOnlyWhenModeIsExplicit() {\n-        MissingInvocationVerifier verifier = new MissingInvocationVerifier();\n-        verifier.verify(null, null, VerificationMode.noMoreInteractions());\n+    public void shouldNeverVerifyWhenModeIsNotMissingMethodMode() {\n+        verifier.verify(null, null, noMoreInteractions());\n+    }\n+    \n+    @Test\n+    public void shouldAskCalculatorForActualNumberOfInvocations() {\n+        calculatorStub.actualCountToReturn = 1;\n+        verifier.verify(invocations, wanted, atLeastOnce());\n+        \n+        assertSame(invocations, calculatorStub.invocations);\n+        assertSame(wanted, calculatorStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldPassBecauseActualInvocationFound() {\n+        calculatorStub.actualCountToReturn = 1;\n+        verifier.verify(invocations, wanted, atLeastOnce());\n+    }\n+    \n+    @Test\n+    public void shouldAskCalculatorForActualInvocationAndReportWantedButNotInvoked() {\n+        calculatorStub.actualCountToReturn = 0;\n+        calculatorStub.actualInvocationToReturn = null;\n+        verifier.verify(invocations, wanted, VerificationMode.atLeastOnce());\n+        \n+        assertSame(invocations, calculatorStub.invocations);\n+        assertSame(wanted, calculatorStub.wanted);\n+        \n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedInvocationDiffersFromActual() {\n+        calculatorStub.actualCountToReturn = 0;\n+        Invocation actualInvocation = new InvocationBuilder().toInvocation();\n+        calculatorStub.actualInvocationToReturn = actualInvocation;\n+        verifier.verify(invocations, wanted, VerificationMode.atLeastOnce());\n+        \n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+        assertEquals(actualInvocation.toString(), reporterStub.actual);\n+        assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    class InvocationsCalculatorStub extends InvocationsCalculator {\n+        private List<Invocation> invocations;\n+        private InvocationMatcher wanted;\n+        private int actualCountToReturn;\n+        private Invocation actualInvocationToReturn;\n+        @Override public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n+            this.invocations = invocations;\n+            this.wanted = wanted;\n+            return actualCountToReturn;\n+        }\n+        @Override public Invocation findActualInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n+            this.invocations = invocations;\n+            this.wanted = wanted;\n+            return actualInvocationToReturn;\n+        }\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private String wanted;\n+        private String actual;\n+        private HasStackTrace actualInvocationStackTrace;\n+        @Override public void wantedButNotInvoked(String wanted) {\n+            this.wanted = wanted;\n+        }\n+        @Override public void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+                    this.wanted = wanted;\n+                    this.actual = actual;\n+                    this.actualInvocationStackTrace = actualInvocationStackTrace;\n+        }\n     }\n }\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n     private NoMoreInvocationsVerifier verifier;\n     private InvocationsCalculatorStub calculator;\n     private ReporterStub reporterStub;\n-    private Invocation returnedByCalculator;\n \n     @Before\n     public void setup() {\n         calculator = new InvocationsCalculatorStub();\n         reporterStub = new ReporterStub();\n         verifier = new NoMoreInvocationsVerifier(calculator, reporterStub);\n-        returnedByCalculator = new InvocationBuilder().toInvocation();\n     }\n     \n     @Test\n     \n     @Test\n     public void shouldPassVerification() throws Exception {\n-        returnedByCalculator = null;\n+        calculator.invocationToReturn = null;\n         verifier.verify(null, null, VerificationMode.noMoreInteractions());\n     }\n     \n     @Test\n     public void shouldReportError() throws Exception {\n+        Invocation firstUnverified = new InvocationBuilder().toInvocation();\n+        calculator.invocationToReturn = firstUnverified;\n         List<Invocation> invocations = asList(new InvocationBuilder().toInvocation());\n-        returnedByCalculator = new InvocationBuilder().toInvocation();\n         \n         verifier.verify(invocations, null, VerificationMode.noMoreInteractions());\n         \n         assertSame(invocations, calculator.invocations);\n-        assertEquals(returnedByCalculator.toString(), reporterStub.undesired);\n-        assertSame(returnedByCalculator.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+        \n+        assertEquals(firstUnverified.toString(), reporterStub.undesired);\n+        assertSame(firstUnverified.getStackTrace(), reporterStub.actualInvocationStackTrace);\n     }\n     \n     class InvocationsCalculatorStub extends InvocationsCalculator {\n         private List<Invocation> invocations;\n+        private Invocation invocationToReturn;\n         @Override public Invocation getFirstUnverified(List<Invocation> invocations) {\n             this.invocations = invocations;\n-            return returnedByCalculator;\n+            return invocationToReturn;\n         }\n     }\n     \n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n     private NumberOfInvocationsVerifier verifier;\n     private InvocationsCalculatorStub calculatorStub;\n     private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private List<Invocation> invocations;\n     \n     @Before\n     public void setup() {\n         reporterStub = new ReporterStub();\n         calculatorStub = new InvocationsCalculatorStub();\n         verifier = new NumberOfInvocationsVerifier(reporterStub, calculatorStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = asList(new InvocationBuilder().toInvocation());\n     }\n \n     @Test\n     \n     @Test\n     public void shouldVerifyOnlyWhenModeIsExplicit() {\n+        //TODO refactor to VM\n         verifier.verify(null, null, VerificationMode.noMoreInteractions());\n     }\n \n     @Test\n     public void shouldCountActualInvocations() throws Exception {\n-        InvocationMatcher wanted = new InvocationBuilder().toInvocationMatcher();\n-        verifier.verify(asList(wanted.getInvocation()), wanted, times(4));\n-        assertSame(wanted, calculatorStub.wantedForCountingActual);\n+        verifier.verify(invocations, wanted, times(4));\n+        assertSame(wanted, calculatorStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldAskCalculatorToCountActual() throws Exception {\n+        VerificationMode mode = times(1);\n+        calculatorStub.actualCountToReturn = 1;\n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(invocations, calculatorStub.invocations);\n+        assertSame(wanted, calculatorStub.wanted);\n     }\n     \n     @Test\n     public void shouldReportTooLittleInvocations() throws Exception {\n-        InvocationMatcher wanted = new InvocationBuilder().toInvocationMatcher();\n         VerificationMode mode = times(10);\n-        verifier.verify(asList(wanted.getInvocation()), wanted, mode);\n+        calculatorStub.actualCountToReturn = 5;\n+        MockitoException lastInvocation = new MockitoException(\"\");\n+        calculatorStub.invocationTraceToReturn = lastInvocation;\n         \n-        assertSame(wanted, calculatorStub.wantedForGettingTrace);\n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(invocations, calculatorStub.invocations);\n+        assertSame(wanted, calculatorStub.wanted);\n         \n         assertEquals(5, reporterStub.actualCount);\n         assertEquals(10, reporterStub.wantedCount);\n         assertEquals(wanted.toString(), reporterStub.wanted);\n         \n-        HasStackTrace fromCalculator = calculatorStub.lastInvocation;\n-        assertSame(fromCalculator, reporterStub.stackTrace);\n+        assertSame(lastInvocation, reporterStub.stackTrace);\n     }\n     \n     @Test\n     public void shouldReportTooManyInvocations() throws Exception {\n-        InvocationMatcher wanted = new InvocationBuilder().toInvocationMatcher();\n         VerificationMode mode = times(0);\n-        verifier.verify(asList(wanted.getInvocation()), wanted, mode);\n+        calculatorStub.actualCountToReturn = 5;\n+        MockitoException firstUndesiredInvocation = new MockitoException(\"\");\n+        calculatorStub.invocationTraceToReturn = firstUndesiredInvocation;\n         \n-        assertSame(wanted, calculatorStub.wantedForGettingTrace);\n+        verifier.verify(invocations, wanted, mode);\n+        \n+        assertSame(invocations, calculatorStub.invocations);\n+        assertSame(wanted, calculatorStub.wanted);\n+        \n         assertSame(mode, calculatorStub.mode);\n         \n         assertEquals(5, reporterStub.actualCount);\n         assertEquals(0, reporterStub.wantedCount);\n         assertEquals(wanted.toString(), reporterStub.wanted);\n         \n-        HasStackTrace fromCalculator = calculatorStub.firstUndesired;\n-        assertSame(fromCalculator, reporterStub.stackTrace);\n+        assertSame(firstUndesiredInvocation, reporterStub.stackTrace);\n     }\n     \n     class InvocationsCalculatorStub extends InvocationsCalculator {\n-        private final HasStackTrace firstUndesired = new MockitoException(\"\");\n-        private final HasStackTrace lastInvocation = new MockitoException(\"\");\n+        private HasStackTrace invocationTraceToReturn;\n+        private int actualCountToReturn;\n \n-        private InvocationMatcher wantedForCountingActual;\n-        private InvocationMatcher wantedForGettingTrace;\n+        private InvocationMatcher wanted;\n         private VerificationMode mode;\n+        private List<Invocation> invocations;\n         @Override\n         public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n-            this.wantedForCountingActual = wanted;\n-            return 5;\n+            this.invocations = invocations;\n+            this.wanted = wanted;\n+            return actualCountToReturn;\n         }\n         \n         @Override public HasStackTrace getFirstUndesiredInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n-            wantedForGettingTrace = wanted;\n+            this.wanted = wanted;\n             this.mode = mode;\n-            return firstUndesired;\n+            return invocationTraceToReturn;\n         }\n         \n         @Override\n         public HasStackTrace getLastInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n-            wantedForGettingTrace = wanted;\n-            return lastInvocation;\n+            this.wanted = wanted;\n+            return invocationTraceToReturn;\n         }\n     }\n     ", "timestamp": 1197670605, "metainfo": ""}