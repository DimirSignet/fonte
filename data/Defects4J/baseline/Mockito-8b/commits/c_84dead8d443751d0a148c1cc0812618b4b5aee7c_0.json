{"sha": "84dead8d443751d0a148c1cc0812618b4b5aee7c", "log": "A bucket of cold water. The MockitoInvocationHandler interface does not make much sense yet. Internally we cast it anyway to an internal type. This means that this API is not yet ready to be completely public. No problem, though, I made the MockitoInvocationHandler a marker interface. The contract of the MockMaker at the moment is that it should not create own instances of MockitoInvocationHandler. Instead, it should keep hold on the instance that is provided by Mockito. Documented this contract in the MockMaker interface.  Down the road MockHandlerInterface will merge into MockitoInvocationHandler and the invocation API will be completely open. For now what we have should do.", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  * @param <T>\n  *            type of mock object to handle\n  */\n-public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T> {\n+public class MockHandler<T> implements MockHandlerInterface<T> {\n \n     private static final long serialVersionUID = -2917871070982574165L;\n \n--- a/src/org/mockito/internal/MockHandlerInterface.java\n+++ b/src/org/mockito/internal/MockHandlerInterface.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n import java.util.List;\n \n+import org.mockito.Incubating;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n @SuppressWarnings(\"unchecked\")\n-public interface MockHandlerInterface<T> {\n+public interface MockHandlerInterface<T> extends MockitoInvocationHandler {\n \n     MockSettingsImpl getMockSettings();\n \n     void setAnswersForStubbing(List<Answer> answers);\n \n     InvocationContainer getInvocationContainer();\n+\n+    /**\n+     * Takes an invocation object and handles it.\n+     * <p>\n+     * The default implementation provided by Mockito handles invocations by recording\n+     * method calls on mocks for further verification, captures the stubbing information when mock is stubbed,\n+     * returns the stubbed values for invocations that have been stubbed, and much more.\n+     *\n+     * @param invocation The invocation to handle\n+     * @return Result\n+     * @throws Throwable Throwable\n+     */\n+    @Incubating\n+    Object handle(Invocation invocation) throws Throwable;\n }\n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n \n import org.mockito.cglib.proxy.Callback;\n import org.mockito.cglib.proxy.Factory;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.MockHandlerInterface;\n import org.mockito.plugins.MockMaker;\n import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n \n     public <T> T createMock(Class<T> typeToMock, Class<?>[] extraInterfaces,\n             MockitoInvocationHandler handler, MockSettingsInfo settings) {\n+        MockHandlerInterface mockitoHandler = cast(handler);\n         return ClassImposterizer.INSTANCE.imposterise(\n-                new MethodInterceptorFilter(handler, settings), typeToMock, extraInterfaces);\n+                new MethodInterceptorFilter(mockitoHandler, settings), typeToMock, extraInterfaces);\n     }\n-    \n+\n+    private MockHandlerInterface cast(MockitoInvocationHandler handler) {\n+        if (!(handler instanceof MockHandlerInterface)) {\n+            throw new MockitoException(\"At the moment you cannot provide own implementations of MockitoInvocationHandler.\" +\n+                    \"\\nPlease see the javadocs for the MockMaker interface.\");\n+        }\n+        return (MockHandlerInterface) handler;\n+    }\n+\n     public void resetMock(Object mock, MockitoInvocationHandler newHandler, MockSettingsInfo settings) {\n-        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(newHandler, settings));\n+        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));\n     }\n \n     public MockitoInvocationHandler getHandler(Object mock) {\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n \n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.MockHandlerInterface;\n import org.mockito.invocation.Invocation;\n import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private static final long serialVersionUID = 6182795666612683784L;\n-    private final MockitoInvocationHandler handler;\n+    private final MockHandlerInterface handler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n     private final MockSettingsInfo mockSettings;\n \n-    public MethodInterceptorFilter(MockitoInvocationHandler handler, MockSettingsInfo mockSettings) {\n+    public MethodInterceptorFilter(MockHandlerInterface handler, MockSettingsInfo mockSettings) {\n         this.handler = handler;\n         this.mockSettings = mockSettings;\n     }\n--- a/src/org/mockito/invocation/MockitoInvocationHandler.java\n+++ b/src/org/mockito/invocation/MockitoInvocationHandler.java\n \n /**\n  * Mockito handler of an invocation on a mock. This is a core part of the API, the heart of Mockito.\n- * This type might be interesting for developers wishing to extend Mockito.\n  * See also the {@link org.mockito.plugins.MockMaker}.\n  * <p>\n- * Takes an invocation object and handles it.\n- * The Invocation instance should be created by the {@link org.mockito.plugins.MockMaker}.\n- * <p>\n- * The default implementation provided by Mockito handles invocations by recording\n- * method calls on mocks for further verification, captures the stubbing information when mock is stubbed,\n- * returns the stubbed values for invocations that have been stubbed, and much more.\n+ * This api is work in progress, hence a marker interface.\n  */\n @Incubating\n-public interface MockitoInvocationHandler extends Serializable {\n-\n-    /**\n-     * Handles the invocation.\n-     *\n-     * @param invocation The invocation to handle\n-     * @return Result\n-     * @throws Throwable Throwable\n-     */\n-    @Incubating\n-    Object handle(Invocation invocation) throws Throwable;\n-\n-}\n+public interface MockitoInvocationHandler extends Serializable {}\n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n /**\n  * The facility to create mocks.\n  *\n- * <p>By default, an internal cglib/asm based implementation is used.</p>\n+ * <p>By default, an internal cglib/asm/objenesis based implementation is used.</p>\n  *\n- * <p>It is possible to configure your own mock maker so that dynamic proxies are created without cglib/asm.\n+ * <p>{@code MockMaker} is an extension point that makes it possible to use custom dynamic proxies\n+ * and avoid using the default cglib/asm/objenesis implementation.\n  * For example, the android users can use a MockMaker that can work with Dalvik virtual machine\n  * and hence bring Mockito to android apps developers.</p>\n  *\n- * <p>Can load available mockito extensions. Currently Mockito only have one extension point the\n- * {@link MockMaker}. This extension point allows a user to provide his own bytecode engine to build mocks.</p>\n+ * <h3>Implementing custom {@code MockMaker}</h3>\n+ *\n+ * <ul>\n+ *     <li>Implement {@link #createMock)}. Do not provide your own implementation of  </li>\n+ *     <li></li>\n+ *     <li></li>\n+ * </ul>\n+ *\n+ * <h3>Using the extension point</h3>\n  *\n  * <p>Suppose you wrote an extension to create mocks with some <em>Awesome</em> library, in order to tell\n  * Mockito to use it you need to put in your classpath\n  *\n  * @see org.mockito.mock.MockSettingsInfo\n  * @see org.mockito.invocation.MockitoInvocationHandler\n- * @see org.mockito.internal.configuration.ClassPathLoader\n  * @since 1.9.5\n  */\n @Incubating\n public interface MockMaker {\n \n     /**\n-     * Returns a new instance of {@code typeToMock} that implements the\n-     * interfaces of {@code extraInterfaces}. Invocations to the methods of the\n-     * returned instance will be delegated to {@code handler}.\n+     * If you want to provide your own implementation of {@code MockMaker} this method should:\n+     * <ul>\n+     *     <li>Create a proxy object that implements {@code typeToMock} and potentially also {@code extraInterfaces}.</li>\n+     *     <li>You may use the information from {@code settings} to configure your proxy object.</li>\n+     *     <li>Your proxy object should carry the {@code hander} with it. For example, if you generate byte code\n+     *     to create the proxy you could generate an extra field to keep the {@code hanlder} with the generated object.\n+     *     Your implementation of {@code MockHandler} is required to provide this instance of {@code handler} when\n+     *     {@link #getHandler(Object)} is called.\n+     *     </li>\n+     * </ul>\n      *\n-     * @param typeToMock The type to imposterize, could be a <strong>class</strong> or an <strong>interface</strong>.\n-     * @param extraInterfaces Interfaces the mock should implements as well, never <code>null</code>.\n-     * @param handler Handler of every invocation on the mock.\n+     * @param typeToMock The type of the mock, could be a <strong>class</strong> or an <strong>interface</strong>.\n+     * @param extraInterfaces Interfaces the mock should implements as well,\n+     *                        never <code>null</code>, interfaces only (no classes).\n+     * @param handler See {@link MockitoInvocationHandler}.\n+     *                <b>Do not</b> provide your own implementation at this time. Make sure your implementation of\n+     *                {@link #getHandler(Object)} will return this instance.\n      * @param settings Mock creation settings.\n      * @param <T> Type of the mock to return, actually the <code>typeToMock</code>.\n      * @return The mock instance.\n     );\n \n     /**\n-     * Returns the handler for the {@code mock}, or null if {@code mock} was not\n-     * a mock object created by {@link #createMock(Class, Class[], MockitoInvocationHandler, MockSettingsInfo)}.\n+     * Returns the handler for the {@code mock}. The passed mock object is guaranteed to be a Mockito mock,\n+     * created by the {@link #createMock} method.\n      *\n      * @param mock The mock instance.\n-     * @return The invocation handler if this object is a mock, otherwise <code>null</code>.\n+     * @return should never return null.\n      * @since 1.9.5\n      */\n     MockitoInvocationHandler getHandler(Object mock);\n      * stubbing and verification. In order to reset the mock, we pass\n      * a new instance of the invocation handler.</p>\n      *\n-     * @param mock The mock instance whose invocation handler shall be replaced.\n+     * <p>Your implementation should make sure the {@code newHandler} is correctly associated to passed {@code mock}</p>\n+     *\n+     * @param mock The mock instance whose invocation handler is to be replaced.\n      * @param newHandler The new invocation handler instance.\n-     * @param settings The mock settings.\n+     * @param settings The mock settings - should you need to access some of the mock creation details.\n      * @since 1.9.5\n      */\n     void resetMock(\n--- a/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/MethodInterceptorFilterTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.invocation.InvocationImpl;\n-import org.mockito.invocation.MockitoInvocationHandler;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.MockitoMethod;\n \n public class MethodInterceptorFilterTest extends TestBase {\n \n-    MockitoInvocationHandler handler = Mockito.mock(MockitoInvocationHandler.class);\n+    MockHandlerInterface handler = Mockito.mock(MockHandlerInterface.class);\n     MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n \n     @Before", "timestamp": 1333913025, "metainfo": ""}