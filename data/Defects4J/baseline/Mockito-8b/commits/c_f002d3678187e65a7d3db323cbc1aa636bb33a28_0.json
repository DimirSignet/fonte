{"sha": "f002d3678187e65a7d3db323cbc1aa636bb33a28", "log": "removed some unnecessary code moved classes around  --HG-- rename : test/org/mockito/internal/verification/InvocationsFinderStub.java => test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java rename : test/org/mockito/internal/verification/MissingInvocationCheckerTest.java => test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java rename : test/org/mockito/internal/verification/MissingInvocationInOrderCheckerTest.java => test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java rename : test/org/mockito/internal/verification/NumberOfInvocationsCheckerTest.java => test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java rename : test/org/mockito/internal/verification/NumberOfInvocationsInOrderCheckerTest.java => test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40984", "commit": "\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n \n public class AtLeastXNumberOfInvocationsChecker {\n     \n-    private final Reporter reporter;\n-    private final InvocationsFinder finder;\n+    private final Reporter reporter = new Reporter();\n+    private final InvocationsFinder finder = new InvocationsFinder();\n \n-    //TODO remove constructors if unit test not necessary\n-    public AtLeastXNumberOfInvocationsChecker() {\n-        this(new Reporter(), new InvocationsFinder());\n-    }\n-    \n-    AtLeastXNumberOfInvocationsChecker(Reporter reporter, InvocationsFinder finder) {\n-        this.reporter = reporter;\n-        this.finder = finder;\n-    }\n-    \n     //TODO check coverage\n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n \n public class AtLeastXNumberOfInvocationsInOrderChecker {\n     \n-    private final Reporter reporter;\n-    private final InvocationsFinder finder;\n-    \n-    public AtLeastXNumberOfInvocationsInOrderChecker() {\n-        this(new InvocationsFinder(), new Reporter());\n-    }\n-    \n-    public AtLeastXNumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n-        this.finder = finder;\n-        this.reporter = reporter;\n-    }\n+    private final Reporter reporter = new Reporter();\n+    private final InvocationsFinder finder = new InvocationsFinder();\n     \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n         List<Invocation> chunk = finder.findAllMatchingUnverifiedChunks(invocations, wanted);\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n         this(new InvocationsFinder(), new Reporter());\n     }\n     \n-    public MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n+    MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n         this.finder = finder;\n         this.reporter = reporter;\n     }\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n         this(new InvocationsFinder(), new Reporter());\n     }\n     \n-    public MissingInvocationInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n+    MissingInvocationInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n         this.finder = finder;\n         this.reporter = reporter;\n     }\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n         this(new Reporter(), new InvocationsFinder());\n     }\n     \n-    public NumberOfInvocationsChecker(Reporter reporter, InvocationsFinder finder) {\n+    NumberOfInvocationsChecker(Reporter reporter, InvocationsFinder finder) {\n         this.reporter = reporter;\n         this.finder = finder;\n     }\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n         this(new InvocationsFinder(), new Reporter());\n     }\n     \n-    public NumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n+    NumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter) {\n         this.finder = finder;\n         this.reporter = reporter;\n     }\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.progress.TimesTest;\n import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n-import org.mockito.internal.verification.MissingInvocationCheckerTest;\n-import org.mockito.internal.verification.MissingInvocationInOrderCheckerTest;\n-import org.mockito.internal.verification.NumberOfInvocationsCheckerTest;\n-import org.mockito.internal.verification.NumberOfInvocationsInOrderCheckerTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n import org.mockitousage.ReplacingObjectMethodsTest;\n import org.mockitousage.UsingVarargsTest;\n import org.mockitousage.examples.configure.withbaseclass.ConfiguringDefaultReturnValuesUsingBaseClassTest;\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/checkers/InvocationsFinderStub.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification.checkers;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+\n+class InvocationsFinderStub extends InvocationsFinder {\n+    \n+    Invocation similarToReturn;\n+    Invocation firstUnverifiedToReturn;\n+    Invocation previousInOrderToReturn;\n+    \n+    final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n+    final List<Invocation> validMatchingChunkToReturn = new LinkedList<Invocation>();\n+    final List<Invocation> allMatchingUnverifiedChunksToReturn = new LinkedList<Invocation>();\n+    \n+    List<Invocation> invocations;\n+    \n+    @Override\n+    public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {\n+        return allMatchingUnverifiedChunksToReturn;\n+    }\n+    \n+    @Override\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount) {\n+        return validMatchingChunkToReturn;\n+    }\n+\n+    @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n+        this.invocations = invocations;\n+        return actualToReturn;\n+    }\n+    \n+    @Override public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n+        this.invocations = invocations;\n+        return similarToReturn;\n+    }\n+    \n+    @Override public Invocation findFirstUnverified(List<Invocation> invocations) {\n+        this.invocations = invocations;\n+        return firstUnverifiedToReturn;\n+    }\n+    \n+    @Override\n+    public Invocation findPreviousVerifiedInOrder(List<Invocation> invocations) {\n+        return previousInOrderToReturn;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification.checkers;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockitoutil.TestBase;\n+\n+public class MissingInvocationCheckerTest extends TestBase {\n+\n+    private MissingInvocationChecker checker;\n+    \n+    private InvocationsFinderStub finderStub;\n+    private ReporterStub reporterStub;\n+    \n+    private InvocationMatcher wanted;\n+    private List<Invocation> invocations;\n+\n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        checker = new MissingInvocationChecker(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = asList(new InvocationBuilder().toInvocation());\n+    }\n+    \n+    @Test\n+    public void shouldAskFinderForActualInvocations() {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        checker.check(invocations, wanted);\n+        \n+        assertSame(invocations, finderStub.invocations);\n+    }\n+    \n+    @Test\n+    public void shouldPassBecauseActualInvocationFound() {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        checker.check(invocations, wanted);\n+    }\n+    \n+    @Test\n+    public void shouldAskAnalyzerForSimilarInvocation() {\n+        checker.check(invocations, wanted);\n+        \n+        assertSame(invocations, finderStub.invocations);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() {\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        finderStub.similarToReturn = null;\n+        \n+        checker.check(invocations, wanted);\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+        assertNull(reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedInvocationDiffersFromActual() {\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        Invocation actualInvocation = new InvocationBuilder().toInvocation();\n+        finderStub.similarToReturn = actualInvocation;\n+        \n+        checker.check(invocations, wanted);\n+        \n+        assertNotNull(reporterStub.wanted);\n+        assertNotNull(reporterStub.actual);\n+        \n+        assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private PrintableInvocation wanted;\n+        private PrintableInvocation actual;\n+        private HasStackTrace actualInvocationStackTrace;\n+        @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n+            this.wanted = wanted;\n+        }\n+        \n+        @Override public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, HasStackTrace actualInvocationStackTrace) {\n+                    this.wanted = wanted;\n+                    this.actual = actual;\n+                    this.actualInvocationStackTrace = actualInvocationStackTrace;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification.checkers;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+import org.mockitoutil.TestBase;\n+\n+public class MissingInvocationInOrderCheckerTest extends TestBase {\n+\n+    private MissingInvocationInOrderChecker checker;\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        checker = new MissingInvocationInOrderChecker(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }                                                                    \n+\n+    @Test\n+    public void shouldPassWhenMatchingInteractionFound() throws Exception {\n+        Invocation actual = new InvocationBuilder().toInvocation();\n+        finderStub.allMatchingUnverifiedChunksToReturn.add(actual);\n+        \n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() throws Exception {\n+        assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());\n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedDiffersFromActual() throws Exception {\n+        Invocation previous = new InvocationBuilder().toInvocation();\n+        finderStub.previousInOrderToReturn = previous;\n+        \n+        checker.check(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+        assertEquals(previous, reporterStub.previous);\n+        assertSame(previous.getStackTrace(), reporterStub.previousStackTrace);\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private PrintableInvocation wanted;\n+        private PrintableInvocation previous;\n+        private HasStackTrace previousStackTrace;\n+        \n+        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, HasStackTrace previousStackTrace) {\n+            this.wanted = wanted;\n+            this.previous = previous;\n+            this.previousStackTrace = previousStackTrace;\n+        }\n+        \n+        @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n+            this.wanted = wanted;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification.checkers;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockitoutil.TestBase;\n+\n+public class NumberOfInvocationsCheckerTest extends TestBase {\n+\n+    private NumberOfInvocationsChecker checker;\n+    //TODO checkers should not be verifiers\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        checker = new NumberOfInvocationsChecker(reporterStub, finderStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }\n+\n+    @Test\n+    public void shouldReportTooLittleActual() throws Exception {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        checker.check(invocations, wanted, 100);\n+        \n+        assertEquals(1, reporterStub.actualCount);\n+        assertEquals(100, reporterStub.wantedCount);\n+        assertEquals(wanted, reporterStub.wanted);\n+    }\n+\n+    @Test\n+    public void shouldReportWithLastInvocationStackTrace() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        \n+        finderStub.actualToReturn.addAll(asList(first, second));\n+        \n+        checker.check(invocations, wanted, 100);\n+        \n+        assertSame(second.getStackTrace(), reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {\n+        assertTrue(finderStub.actualToReturn.isEmpty());\n+        \n+        checker.check(invocations, wanted, 100);\n+        \n+        assertNull(reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        Invocation third = new InvocationBuilder().toInvocation();\n+        \n+        finderStub.actualToReturn.addAll(asList(first, second, third));\n+        \n+        checker.check(invocations, wanted, 2);\n+        \n+        assertSame(third.getStackTrace(), reporterStub.stackTrace);\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyActual() throws Exception {\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n+        \n+        checker.check(invocations, wanted, 1);\n+        \n+        assertEquals(2, reporterStub.actualCount);\n+        assertEquals(1, reporterStub.wantedCount);\n+        assertEquals(wanted, reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportNeverWantedButInvoked() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        finderStub.actualToReturn.add(invocation);\n+        \n+        checker.check(invocations, wanted, 0);\n+        \n+        assertEquals(wanted, reporterStub.wanted);\n+        assertEquals(invocation.getStackTrace(), reporterStub.stackTrace);\n+    }\n+    \n+       //TODO verify this test makes sense\n+//    @Test\n+//    public void shouldMarkInvocationsAsVerified() throws Exception {\n+//        Invocation invocation = new InvocationBuilder().toInvocation();\n+//        finderStub.actualToReturn.add(invocation);\n+//        assertFalse(invocation.isVerified());\n+//        \n+//        checker.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n+//        \n+//        assertTrue(invocation.isVerified());\n+//    }\n+    \n+    class ReporterStub extends Reporter {\n+        private int wantedCount;\n+        private int actualCount;\n+        private PrintableInvocation wanted;\n+        private HasStackTrace stackTrace;\n+        @Override public void tooLittleActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace lastActualInvocationStackTrace) {\n+                    this.wantedCount = wantedCount;\n+                    this.actualCount = actualCount;\n+                    this.wanted = wanted;\n+                    this.stackTrace = lastActualInvocationStackTrace;\n+        }\n+        \n+        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+                    this.wantedCount = wantedCount;\n+                    this.actualCount = actualCount;\n+                    this.wanted = wanted;\n+                    this.stackTrace = firstUndesired;\n+        }\n+        \n+        @Override\n+        public void neverWantedButInvoked(PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+            this.wanted = wanted;\n+            this.stackTrace = firstUndesired;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderCheckerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification.checkers;\n+\n+import static java.util.Arrays.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockitoutil.TestBase;\n+\n+public class NumberOfInvocationsInOrderCheckerTest extends TestBase {\n+\n+    private NumberOfInvocationsInOrderChecker checker;\n+    private Reporter reporter;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporter = new Reporter();\n+        finderStub = new InvocationsFinderStub();\n+        checker = new NumberOfInvocationsInOrderChecker(finderStub, reporter);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }\n+    \n+    @Test\n+    public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {\n+        assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());\n+        checker.check(invocations, wanted, 0);\n+    }\n+    \n+    @Test\n+    public void shouldPassIfChunkMatches() throws Exception {\n+        finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());\n+        \n+        checker.check(invocations, wanted, 1);\n+    }\n+    \n+    @Test\n+    public void shouldReportTooLittleInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n+        \n+        try {\n+            checker.check(invocations, wanted, 4);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e, messageContains(\"Wanted 4 times but was 2\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n+        \n+        try {\n+            checker.check(invocations, wanted, 1);\n+            fail();\n+        } catch (VerifcationInOrderFailure e) {\n+            assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifiedInOrder() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        assertFalse(invocation.isVerifiedInOrder());\n+        finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n+        \n+        checker.check(invocations, wanted, 1);\n+        \n+        assertTrue(invocation.isVerifiedInOrder());\n+    }\n+}", "timestamp": 1223983603, "metainfo": ""}