{"sha": "bc5349d3e90f127e3fdeb0cf1debbc70eba21992", "log": "JUnit @Rule implementation added  Fixes #85", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;\n import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.rules.MockitoJUnitRule;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockito.stubbing.*;\n import org.mockito.verification.After;\n  * MockitoAnnotations.initMocks(testClass);\n  * </code></pre>\n  *\n- * You can use built-in runner: {@link MockitoJUnitRunner}.\n+ * You can use built-in runner: {@link MockitoJUnitRunner} or a rule: {@link MockitoJUnitRule}.\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n  *\n  *\n  * <p>\n  * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.\n- * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner}.\n+ * Just like for &#064;{@link Mock} annotation you can use the built-in runner: {@link MockitoJUnitRunner} or rule:\n+ * {@link MockitoJUnitRule}.\n  * <p>\n  *\n  *\n  * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields\n  * using <b>constructor</b> injection, <b>setter</b> injection, or <b>field</b> injection.\n  * <p>\n- * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)} or {@link MockitoJUnitRunner}.\n+ * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)}, {@link MockitoJUnitRunner}\n+ * or {@link MockitoJUnitRule}.\n  * <p>\n  * Read more about available tricks and the rules of injection in the javadoc for {@link InjectMocks}\n  * <pre class=\"code\"><code class=\"java\">\n      * For example, one of the users wanted to put <code>validateMockitoUsage()</code> in his <code>&#064;After</code> method\n      * so that he knows immediately when he misused Mockito.\n      * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.\n-     * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner will always fail in the test method with defect\n+     * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner and rule will always fail in the test method with defect\n      * whereas ordinary 'next-time' validation might fail the <b>next</b> test method.\n      * But even though JUnit might report next test as red, don't worry about it\n      * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.\n      * <p>\n-     * <b>Built-in runner: {@link MockitoJUnitRunner}</b> does validateMockitoUsage() after each test method.\n+     * <b>Both built-in runner: {@link MockitoJUnitRunner} and rule: {@link MockitoJUnitRule}</b> do validateMockitoUsage() after each test method.\n      * <p>\n      * Bear in mind that <b>usually you don't have to <code>validateMockitoUsage()</code></b>\n      * and framework validation triggered on next-time basis should be just enough,\n--- /dev/null\n+++ b/src/org/mockito/internal/rules/JUnitRule.java\n+package org.mockito.internal.rules;\n+\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Internal implementation.\n+ */\n+public class JUnitRule {\n+    private Object object;\n+\n+    public JUnitRule(Object object) {\n+        this.object = object;\n+    }\n+\n+    public Statement apply(final Statement base, Description description) {\n+        return new Statement() {\n+            @Override\n+            public void evaluate() throws Throwable {\n+                MockitoAnnotations.initMocks(object);\n+                base.evaluate();\n+                Mockito.validateMockitoUsage();\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/rules/JunitRuleImpl.java\n+package org.mockito.internal.rules;\n+\n+/**\n+ * Created by jerzy on 2014-09-19.\n+ */\n+public class JunitRuleImpl {\n+}\n--- /dev/null\n+++ b/src/org/mockito/rules/MockitoJUnitRule.java\n+package org.mockito.rules;\n+\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+import org.mockito.internal.rules.JUnitRule;\n+\n+import static org.mockito.internal.util.Checks.checkNotNull;\n+\n+/**\n+ * The MockitoJUnitRule Rule can be used instead of {@link org.mockito.runners.MockitoJUnitRunner}.\n+ *\n+ * This rule adds following behavior:\n+ * <ul>\n+ *   <li>\n+ *      Initializes mocks annotated with {@link org.mockito.Mock},\n+ *      so that explicit usage of {@link org.mockito.MockitoAnnotations#initMocks(Object)} is not necessary.\n+ *      Mocks are initialized before each test method.\n+ *   <li>\n+ *      validates framework usage after each test method. See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ * </ul>\n+ * Example use:\n+ * <pre class=\"code\"><code class=\"java\">\n+ * public class ExampleTest {\n+ *\n+ *     &#064;Rule\n+ *     public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);</b>\n+ *\n+ *     &#064;Mock\n+ *     private List list;\n+ *\n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * </code></pre>\n+ */\n+public class MockitoJUnitRule implements TestRule {\n+\n+    private JUnitRule jUnitRule;\n+\n+    public MockitoJUnitRule(Object object) {\n+        checkNotNull(object, \"Rule target\");\n+        this.jUnitRule = new JUnitRule(object);\n+    }\n+\n+    public Statement apply(final Statement base, Description description) {\n+        return jUnitRule.apply(base, description);\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/rules/InjectTestCase.java\n+package org.mockito.internal.rules;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+\n+@Ignore(\"used internally by JUnitRuleTest\")\n+public class InjectTestCase {\n+\n+    @Mock\n+    private Injected injected;\n+\n+    @InjectMocks\n+    private InjectInto injectInto;\n+\n+    @Test\n+    public void dummy() throws Exception {\n+    }\n+\n+    public void unfinishedStubbingThrowsException() throws Exception {\n+        Mockito.when(injected.stringMethod());\n+    }\n+\n+    public Injected getInjected() {\n+        return injected;\n+    }\n+\n+    public InjectInto getInjectInto() {\n+        return injectInto;\n+    }\n+\n+    private static class Injected {\n+        public String stringMethod() {\n+            return \"string\";\n+        }\n+    }\n+\n+    private static class InjectInto {\n+        private Injected injected;\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/rules/JUnitRuleTest.java\n+package org.mockito.internal.rules;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n+\n+public class JUnitRuleTest {\n+\n+    private JUnitRule jUnitRule;\n+    private InjectTestCase injectTestCase;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        injectTestCase = new InjectTestCase();\n+        jUnitRule = new JUnitRule(injectTestCase);\n+    }\n+\n+    @Test\n+    public void testInject() throws Throwable {\n+        jUnitRule.apply(new DummyStatement(), Description.EMPTY).evaluate();\n+        assertNotNull(\"\", injectTestCase.getInjected());\n+        assertNotNull(\"\", injectTestCase.getInjectInto());\n+    }\n+\n+    @Test\n+    public void testThrowAnException() throws Throwable {\n+        try {\n+            jUnitRule.apply(new ExceptionStatement(), Description.EMPTY).evaluate();\n+            fail(\"Should throw exception\");\n+        } catch (RuntimeException e) {\n+            assertEquals(\"Correct message\", \"Statement exception\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testMockitoValidation() throws Throwable {\n+        try {\n+            jUnitRule.apply(new UnfinishedStubbingStatement(), Description.EMPTY).evaluate();\n+            fail(\"Should detect unvalid Mockito usage\");\n+        } catch (UnfinishedStubbingException e) {\n+        }\n+    }\n+\n+    private static class DummyStatement extends Statement {\n+        @Override\n+        public void evaluate() throws Throwable {\n+        }\n+    }\n+\n+    private static class ExceptionStatement extends Statement {\n+        @Override\n+        public void evaluate() throws Throwable {\n+            throw new RuntimeException(\"Statement exception\");\n+        }\n+    }\n+\n+    private static class UnfinishedStubbingStatement extends Statement {\n+        @Override\n+        public void evaluate() throws Throwable {\n+            InjectTestCase injectTestCase = new InjectTestCase();\n+            MockitoAnnotations.initMocks(injectTestCase);\n+            injectTestCase.unfinishedStubbingThrowsException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/rules/MockitoJUnitRuleTest.java\n+package org.mockito.rules;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+\n+import static org.junit.Assert.*;\n+\n+public class MockitoJUnitRuleTest {\n+\n+    @Rule\n+    public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);\n+\n+    @Mock\n+    private Injected injected;\n+\n+    @InjectMocks\n+    private InjectInto injectInto;\n+\n+    @Test\n+    public void testInjectMocks() throws Exception {\n+        assertNotNull(\"Mock created\", injected);\n+        assertNotNull(\"Object created\", injectInto);\n+        assertEquals(\"A injected into B\", injected, injectInto.getInjected());\n+\n+    }\n+\n+    @Test\n+    public void testThrowExceptionWhenNullTarget() throws Exception {\n+        try {\n+            new MockitoJUnitRule(null);\n+            fail();\n+        } catch (NullPointerException e) {\n+            assertEquals(\"valid message\", \"Rule target should not be null\", e.getMessage());\n+        }\n+    }\n+\n+    private static class Injected {\n+    }\n+\n+    private static class InjectInto {\n+\n+        private Injected injected;\n+\n+        public Injected getInjected() {\n+            return injected;\n+        }\n+    }\n+}", "timestamp": 1412622213, "metainfo": ""}