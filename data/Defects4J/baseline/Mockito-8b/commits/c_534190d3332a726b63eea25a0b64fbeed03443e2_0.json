{"sha": "534190d3332a726b63eea25a0b64fbeed03443e2", "log": "Sorted out exceptions for strict verification errors  --HG-- rename : src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java => src/org/mockito/exceptions/NumberOfInvocationsError.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4096", "commit": "\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n  */\n package org.mockito.exceptions;\n \n+import org.mockito.internal.Invocation;\n \n /**\n- * All messages in one place makes it easier to tune \n- * and amend the text.\n+ * All messages in one place makes it easier to tune and amend the text. \n+ * Once exception messages are sorted we can inline that stuff.\n  */\n public class Exceptions {\n     \n+    public static final String STRICT_DISCREPANCY = \"Strict order verification failed\";\n+    public static final String REGULAR_DISCREPANCY = \"Invocation differs from actual\";\n+\n     private static String join(String ... linesToBreak) {\n         StringBuilder out = new StringBuilder(\"\\n\");\n         for (String line : linesToBreak) {\n         }\n         int lastBreak = out.lastIndexOf(\"\\n\");\n         return out.replace(lastBreak, lastBreak+1, \"\").toString();\n+    }\n+\n+    private static String pluralize(int number) {\n+        return number == 1 ? \"1 time\" : number + \" times\";\n     }\n \n     public static void mocksHaveToBePassedAsArguments() {\n                     wanted        \n         ));\n     }\n+\n+    public static void numberOfInvocationsDiffers(int wantedCount, int actualCount, String wanted) {\n+        throw new NumberOfInvocationsError(join(\n+                wanted,\n+                \"Expected \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ));\n+    }\n+\n+    public static void noMoreInteractionsWanted(Invocation unexpected, String message) {\n+        throw new VerificationError(join(\n+                message,\n+                \"Unexpected: \" + unexpected.toString()\n+        ));\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsError.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+public class NumberOfInvocationsError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public NumberOfInvocationsError(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n public class MockitoBehavior<T> {\n \n-    private T mock;\n-    \n     private RegisteredInvocations registeredInvocations = new RegisteredInvocations(new AllInvocationsFinder());\n     private Map<ExpectedInvocation, Result> results = new HashMap<ExpectedInvocation, Result>();\n \n+    private T mock;\n     private ExpectedInvocation invocationForStubbing;\n     \n     public void addInvocation(ExpectedInvocation invocation) {\n         }\n     }\n \n-    void checkForWrongNumberOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) throws NumberOfInvocationsAssertionError {\n+    void checkForWrongNumberOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n         if (verifyingMode.orderOfInvocationsMatters()) {\n             return;\n         }\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n         \n         if (!atLeastOnce && actuallyInvoked != expectedInvoked) {\n-            throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, expected.toString());\n+            Exceptions.numberOfInvocationsDiffers(expectedInvoked, actuallyInvoked, expected.toString());\n         }\n     }\n \n-    private void reportMissingInvocationError(ExpectedInvocation wanted) throws VerificationError {\n+    private void reportMissingInvocationError(ExpectedInvocation wanted) {\n         Invocation actual = registeredInvocations.findSimilarInvocation(wanted);\n         \n         if (actual != null) {\n-            reportDiscrepancy(wanted, actual, \"Invocation differs from actual\");\n+            reportDiscrepancy(wanted, actual, Exceptions.REGULAR_DISCREPANCY);\n         } else {\n             Exceptions.wantedButNotInvoked(wanted.toString());\n         }\n         List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n         \n         if (mode.expectedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n-            throw new NumberOfInvocationsAssertionError(0, chunks.get(0).getCount(), wanted.toString());\n+            Exceptions.numberOfInvocationsDiffers(0, chunks.get(0).getCount(), wanted.toString());\n         } else if (mode.expectedCountIsZero()) {\n             return;\n         }\n         }\n         \n         if (!wanted.matches(chunks.get(0).getInvocation())) {\n-            reportDiscrepancy(wanted, chunks.get(0).getInvocation(), \"Strict order verification failed\");\n+            reportDiscrepancy(wanted, chunks.get(0).getInvocation(), Exceptions.STRICT_DISCREPANCY);\n         }\n         \n         if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.expectedCount()) {\n-//            Exceptions.numberOfInvocationsDiffers();\n-            throw new NumberOfInvocationsAssertionError(mode.expectedCount(), chunks.get(0).getCount(), wanted.toString());\n+            Exceptions.numberOfInvocationsDiffers(mode.expectedCount(), chunks.get(0).getCount(), wanted.toString());\n         }\n     }\n \n         verifyNoMoreInteractions(\"Zero interactions expected\");\n     }\n     \n-    private void verifyNoMoreInteractions(String verificationErrorMessage) {\n+    private void verifyNoMoreInteractions(String message) {\n         Invocation unverified = registeredInvocations.getFirstUnverified();\n         if (unverified != null) {\n-            String mockName = Namer.nameForMock(mock);\n-            throw new VerificationError(\n-                    \"\\n\" +\n-                    verificationErrorMessage + \" on \" + mockName +\n-                    \"\\n\" +\n-                    \"Unexpected: \" + unverified.toString());\n+            Exceptions.noMoreInteractionsWanted(unverified, message);\n         }\n     }\n \n--- a/test/org/mockito/usage/verification/BasicVerificationTest.java\n+++ b/test/org/mockito/usage/verification/BasicVerificationTest.java\n         try {\n             verify(mock).clear();\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {};\n+        } catch (NumberOfInvocationsError e) {};\n     }\n \n     @Test\n--- a/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.NumberOfInvocationsAssertionError;\n+import org.mockito.exceptions.NumberOfInvocationsError;\n \n @SuppressWarnings(\"unchecked\")\n public class ExactNumberOfTimesVerificationTest {\n         try {\n             Mockito.verify(mock, 100).clear();\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {\n+        } catch (NumberOfInvocationsError e) {\n             String expected = \n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n         try {\n             Mockito.verify(mock, 1).clear();\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {\n+        } catch (NumberOfInvocationsError e) {\n             String expected = \n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n         try {\n             Mockito.verify(mock, 15).clear();\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {\n+        } catch (NumberOfInvocationsError e) {\n             assertTrue(e.getMessage().endsWith(\"Expected 15 times but was 0\"));\n         }\n     }\n         try {\n             Mockito.verify(mock, 15).clear();\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {\n+        } catch (NumberOfInvocationsError e) {\n             assertTrue(e.getMessage().endsWith(\"Expected 15 times but was 1\"));\n         }\n     }\n         try {\n             Mockito.verify(mock, 0).clear();\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {}\n+        } catch (NumberOfInvocationsError e) {}\n     }\n     \n     @Test\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-            \t\t\"No more interactions expected on IMethods\" +\n+            \t\t\"No more interactions expected\" +\n             \t\t\"\\n\" +\n             \t\t\"Unexpected: IMethods.oneArg(false)\";\n             assertEquals(expectedMessage, actualMessage);         \n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n-                    \"Zero interactions expected on IMethods\" +\n+                    \"Zero interactions expected\" +\n                     \"\\n\" +\n                     \"Unexpected: IMethods.twoArgumentMethod(1, 2)\";\n             assertEquals(expectedMessage, actualMessage);         \n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n         } catch (VerificationError e) {}\n     }\n     \n-    @Test(expected=NumberOfInvocationsAssertionError.class)\n+    @Test(expected=NumberOfInvocationsError.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationExpected() {\n         strictly.verify(mockOne, 0).simpleMethod(1);\n     }\n     \n-    @Test(expected=NumberOfInvocationsAssertionError.class)\n+    @Test(expected=NumberOfInvocationsError.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationExpectedAgain() {\n         strictly.verify(mockOne, 2).simpleMethod(1);\n     }\n         try {\n             strictly.verify(mockTwo, 3).simpleMethod(2);\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {}\n+        } catch (NumberOfInvocationsError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, 0).simpleMethod(2);\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {}\n+        } catch (NumberOfInvocationsError e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne, 0).simpleMethod(4);\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {}\n+        } catch (NumberOfInvocationsError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne, 2).simpleMethod(4);\n             fail();\n-        } catch (NumberOfInvocationsAssertionError e) {}\n+        } catch (NumberOfInvocationsError e) {}\n     }    \n     \n     /* ------------- */", "timestamp": 1196376295, "metainfo": ""}