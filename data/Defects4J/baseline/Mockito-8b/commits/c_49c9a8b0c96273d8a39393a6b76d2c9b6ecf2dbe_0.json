{"sha": "49c9a8b0c96273d8a39393a6b76d2c9b6ecf2dbe", "log": "Made the exception better for wrongly written concurrency tests Related to issue 203  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%402058", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n         throw new WrongTypeOfReturnValue(join(\n                 actualType + \" cannot be returned by \" + methodName + \"()\",\n-                methodName + \"() should return \" + expectedType\n+                methodName + \"() should return \" + expectedType,\n+                \"***\",\n+                \"This exception *might* occur in wrongly written multi-threaded tests.\",\n+                \"Please refer to Mockito FAQ on limitations of concurrency testing.\",\n+                \"\"\n                 ));\n     }\n \n--- /dev/null\n+++ b/test/org/mockitousage/bugs/MultithreadedStubbingHalfManualTest.java\n+package org.mockitousage.bugs;\n+\n+import static java.util.Collections.synchronizedList;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+/**\n+ * Race condition test in Mockito.\n+ *\n+ * @author Ivan Koblik\n+ */\n+@Ignore\n+public class MultithreadedStubbingHalfManualTest {\n+\n+    /**\n+     * Class with two methods, one of them is repeatedly mocked while another is repeatedly called.\n+     */\n+    public interface ToMock {\n+        public Integer getValue(Integer param);\n+\n+        public List<Integer> getValues(Integer param);\n+    }\n+\n+    /**\n+     * Thread pool for concurrent invocations.\n+     */\n+    private Executor executor;\n+\n+    private List exceptions = synchronizedList(new LinkedList());\n+\n+    @Before\n+    public void setUp() {\n+        this.executor = Executors.newSingleThreadExecutor();\n+    }\n+\n+    /**\n+     * The returned runnable simply calls ToMock.getValues(int).\n+     *\n+     * @param toMock The mocked object\n+     * @return The runnable.\n+     */\n+    private Runnable getConflictingRunnable(final ToMock toMock) {\n+        return new Runnable() {\n+            public void run() {\n+                while (true) {\n+                    try {\n+                        Thread.sleep((long) (Math.random() * 10));\n+                    } catch (InterruptedException e) {\n+                    }\n+                    if (!toMock.getValues(0).isEmpty()) {\n+                        fail(\"Shouldn't happen, were just making sure it wasn't optimized away...\");\n+                    }\n+                }\n+            }\n+        };\n+    }\n+\n+    @Test\n+    //this problem shows at 4 out of 5 executions\n+    //it is not strictly a bug because Mockito does not support simultanous stubbing (see FAQ)\n+    //however I decided to synchronize some calls in order to make the exceptions nicer \n+    public void tryToRevealTheProblem() {\n+        ToMock toMock = mock(ToMock.class);\n+        for (int i = 0; i < 100; i++) {\n+            int j = i % 11;\n+\n+            // Repeated mocking\n+            when(toMock.getValue(i)).thenReturn(j);\n+            //TODO make it also showing errors for doReturn()\n+//            doReturn(j).when(toMock).getValue(i);\n+\n+            while (true) {\n+                try {\n+                    // Scheduling invocation\n+                    this.executor.execute(getConflictingRunnable(toMock));\n+                    break;\n+                } catch (RejectedExecutionException ex) {\n+                    fail();\n+                }\n+            }\n+\n+            try {\n+                Thread.sleep(10 / ((i % 10) + 1));\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+}", "timestamp": 1282078291, "metainfo": ""}