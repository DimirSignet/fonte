{"sha": "5a52c029cee21e8b50a6e50e3a5bba14634e79d7", "log": "gc'ed some TODOs  --HG-- rename : test/org/mockito/internal/stubbing/MockitoStubberTest.java => test/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java", "commit": "\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n \n package org.mockito;\n \n-import static org.mockito.Mockito.*;\n-\n-import java.util.List;\n-\n import org.junit.Test;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.times;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoTest extends TestBase {\n         assertEquals(Mockito.RETURNS_DEFAULTS, settings.getDefaultAnswer());\n     }\n     \n-    //TODO: after 1.8 stack filter does not work very well when it comes to threads?\n+    //TODO: stack filter does not work very well when it comes to threads?\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.stubbing;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.invocation.Invocation;\n+import org.mockitoutil.TestBase;\n+\n+public class InvocationContainerImplStubbingTest extends TestBase {\n+\n+    private InvocationContainerImpl invocationContainerImpl;\n+    private InvocationContainerImpl invocationContainerImplStubOnly;\n+    private MockingProgress state;\n+    private Invocation simpleMethod;\n+\n+    @Before\n+    public void setup() {\n+        state = new MockingProgressImpl();\n+\n+        invocationContainerImpl = new InvocationContainerImpl(state, new MockSettingsImpl());\n+        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+\n+        invocationContainerImplStubOnly =\n+          new InvocationContainerImpl(state, new MockSettingsImpl().stubOnly());\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+\n+        simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+    }\n+\n+    @Test\n+    public void should_finish_stubbing_when_wrong_throwable_is_set() throws Exception {\n+        state.stubbingStarted();\n+        try {\n+            invocationContainerImpl.addAnswer(new ThrowsException(new Exception()));\n+            fail();\n+        } catch (MockitoException e) {\n+            state.validateState();\n+        }\n+    }\n+\n+    @Test\n+    public void should_finish_stubbing_on_adding_return_value() throws Exception {\n+        state.stubbingStarted();\n+        invocationContainerImpl.addAnswer(new Returns(\"test\"));\n+        state.validateState();\n+    }\n+\n+    @Test\n+    public void should_get_results_for_methods() throws Throwable {\n+        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        invocationContainerImpl.addAnswer(new Returns(\"simpleMethod\"));\n+\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));\n+\n+        assertEquals(\"simpleMethod\", invocationContainerImpl.answerTo(simpleMethod));\n+\n+        try {\n+            invocationContainerImpl.answerTo(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_get_results_for_methods_stub_only() throws Throwable {\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        invocationContainerImplStubOnly.addAnswer(new Returns(\"simpleMethod\"));\n+\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        invocationContainerImplStubOnly.addAnswer(new ThrowsException(new MyException()));\n+\n+        assertEquals(\"simpleMethod\", invocationContainerImplStubOnly.answerTo(simpleMethod));\n+\n+        try {\n+            invocationContainerImplStubOnly.answerTo(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_add_throwable_for_void_method() throws Throwable {\n+        invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new MyException()));\n+        invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));\n+\n+        try {\n+            invocationContainerImpl.answerTo(simpleMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_validate_throwable_for_void_method() throws Throwable {\n+        invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new Exception()));\n+\n+        try {\n+            invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @Test\n+    public void should_validate_throwable() throws Throwable {\n+        try {\n+            invocationContainerImpl.addAnswer(new ThrowsException(null));\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    class MyException extends RuntimeException {};\n+}\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n     }\n \n     @Test\n-    //TODO split into separate\n     public void should_return_mock_value_for_interface() throws Exception {\n         Object interfaceMock = values.returnValueFor(FooInterface.class);\n         assertTrue(new MockUtil().isMock(interfaceMock));", "timestamp": 1347832311, "metainfo": ""}