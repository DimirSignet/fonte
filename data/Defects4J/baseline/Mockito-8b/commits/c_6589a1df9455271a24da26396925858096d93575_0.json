{"sha": "6589a1df9455271a24da26396925858096d93575", "log": "committed patch for feature #16 adds toAnwswer() stubbing mode where you can specify any callback  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40659", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal;\n-\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import net.sf.cglib.proxy.MethodProxy;\n-\n-import org.mockito.internal.configuration.Configuration;\n-import org.mockito.internal.creation.ClassNameFinder;\n-import org.mockito.internal.creation.MockAwareInterceptor;\n-import org.mockito.internal.invocation.AllInvocationsFinder;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.OngoingStubbing;\n-import org.mockito.internal.progress.VerificationModeImpl;\n-import org.mockito.internal.stubbing.DontThrow;\n-import org.mockito.internal.stubbing.Stubber;\n-import org.mockito.internal.stubbing.VoidMethodStubbable;\n-import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n-import org.mockito.internal.verification.MissingInvocationVerifier;\n-import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n-import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifier;\n-import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n-import org.mockito.internal.verification.Verifier;\n-import org.mockito.internal.verification.VerifyingRecorder;\n-\n-/**\n- * Invocation handler set on mock objects.\n- *\n- * @param <T> type of mock object to handle\n- */\n-public class MockHandler<T> implements MockAwareInterceptor<T> {\n-\n-    private final VerifyingRecorder verifyingRecorder;\n-    private final Stubber stubber;\n-    private final MatchersBinder matchersBinder;\n-    private final MockingProgress mockingProgress;\n-    private final String mockName;\n-    \n-    private T mock;\n-    \n-    public MockHandler(String mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n-        this.mockName = mockName;\n-        this.mockingProgress = mockingProgress;\n-        this.matchersBinder = matchersBinder;\n-        stubber = new Stubber(mockingProgress);\n-        \n-        verifyingRecorder = createRecorder(); \n-    }\n-\n-    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n-        if (stubber.hasThrowableForVoidMethod()) {\n-            Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n-            stubber.addVoidMethodForThrowable(invocationMatcher);\n-            return null;\n-        }\n-        \n-        VerificationModeImpl verificationMode = mockingProgress.pullVerificationMode();\n-        mockingProgress.validateState();\n-        \n-        Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n-        \n-        if (verificationMode != null) {\n-            verifyingRecorder.verify(invocationMatcher, verificationMode);\n-            return Configuration.instance().getReturnValues().valueFor(invocationMatcher.getInvocation());\n-        }\n-        \n-        stubber.setInvocationForPotentialStubbing(invocationMatcher);\n-        verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n-\n-        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n-        \n-        return stubber.resultFor(invocationMatcher.getInvocation());\n-    }\n-\n-    public void verifyNoMoreInteractions() {\n-        verifyingRecorder.verify(VerificationModeImpl.noMoreInteractions());\n-    }\n-    \n-    public VoidMethodStubbable<T> voidMethodStubbable() {\n-        return new VoidMethodStubbableImpl();\n-    }\n-    \n-    public void setMock(T mock) {\n-        this.mock = mock;\n-    }\n-\n-    public List<Invocation> getRegisteredInvocations() {\n-        return verifyingRecorder.getRegisteredInvocations();\n-    }\n-    \n-    public String getMockName() {\n-        if (mockName != null) {\n-            return mockName;\n-        } else {\n-            return toInstanceName(ClassNameFinder.classNameForMock(mock));\n-        }\n-    }\n-    \n-    //lower case first letter\n-    private String toInstanceName(String className) {\n-        return className.substring(0, 1).toLowerCase() + className.substring(1);\n-    }\n-\n-    private VerifyingRecorder createRecorder() {\n-        List<Verifier> verifiers = Arrays.asList(\n-                new MissingInvocationInOrderVerifier(),\n-                new NumberOfInvocationsInOrderVerifier(),\n-                new MissingInvocationVerifier(),\n-                new NumberOfInvocationsVerifier(),\n-                new NoMoreInvocationsVerifier());\n-        return new VerifyingRecorder(new AllInvocationsFinder(), verifiers);\n-    }\n-    \n-    private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n-        public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n-            stubber.addThrowableForVoidMethod(throwable);\n-            return this;\n-        }\n-        \n-        public VoidMethodStubbable<T> toReturn() {\n-            stubber.addThrowableForVoidMethod(DontThrow.DONT_THROW);\n-            return this;\n-        }\n-        \n-        public T on() {\n-            return mock;\n-        }\n-    }\n-\n-    private class OngoingStubbingImpl implements OngoingStubbing<T> {\n-        public OngoingStubbing<T> toReturn(Object value) {\n-            verifyingRecorder.eraseLastInvocation();\n-            stubber.addReturnValue(value);\n-            return new ConsecutiveStubbing();\n-        }\n-\n-        public OngoingStubbing<T> toThrow(Throwable throwable) {\n-            verifyingRecorder.eraseLastInvocation();\n-            stubber.addThrowable(throwable);\n-            return new ConsecutiveStubbing();\n-        }\n-    }\n-    \n-    private class ConsecutiveStubbing implements OngoingStubbing<T> {\n-        public OngoingStubbing<T> toReturn(Object value) {\n-            stubber.addConsecutiveReturnValue(value);\n-            return this;\n-        }\n-\n-        public OngoingStubbing<T> toThrow(Throwable throwable) {\n-            stubber.addConsecutiveThrowable(throwable);\n-            return this;\n-        }\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+import org.mockito.internal.configuration.Configuration;\n+import org.mockito.internal.creation.ClassNameFinder;\n+import org.mockito.internal.creation.MockAwareInterceptor;\n+import org.mockito.internal.invocation.AllInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.stubbing.Answer;\n+import org.mockito.internal.stubbing.DontThrow;\n+import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n+import org.mockito.internal.verification.MissingInvocationVerifier;\n+import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n+import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifier;\n+import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n+import org.mockito.internal.verification.Verifier;\n+import org.mockito.internal.verification.VerifyingRecorder;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ *\n+ * @param <T> type of mock object to handle\n+ */\n+public class MockHandler<T> implements MockAwareInterceptor<T> {\n+\n+    private final VerifyingRecorder verifyingRecorder;\n+    private final Stubber stubber;\n+    private final MatchersBinder matchersBinder;\n+    private final MockingProgress mockingProgress;\n+    private final String mockName;\n+\n+    private T mock;\n+\n+    public MockHandler(String mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n+        this.mockName = mockName;\n+        this.mockingProgress = mockingProgress;\n+        this.matchersBinder = matchersBinder;\n+        stubber = new Stubber(mockingProgress);\n+\n+        verifyingRecorder = createRecorder();\n+    }\n+\n+    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n+        if (stubber.hasThrowableForVoidMethod()) {\n+            Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n+            stubber.addVoidMethodForThrowable(invocationMatcher);\n+            return null;\n+        }\n+\n+        VerificationModeImpl verificationMode = mockingProgress.pullVerificationMode();\n+        mockingProgress.validateState();\n+\n+        Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n+\n+        if (verificationMode != null) {\n+            verifyingRecorder.verify(invocationMatcher, verificationMode);\n+            return Configuration.instance().getReturnValues().valueFor(invocationMatcher.getInvocation());\n+        }\n+\n+        stubber.setInvocationForPotentialStubbing(invocationMatcher);\n+        verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n+\n+        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n+\n+        return stubber.resultFor(invocationMatcher.getInvocation());\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        verifyingRecorder.verify(VerificationModeImpl.noMoreInteractions());\n+    }\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable() {\n+        return new VoidMethodStubbableImpl();\n+    }\n+\n+    public void setMock(T mock) {\n+        this.mock = mock;\n+    }\n+\n+    public List<Invocation> getRegisteredInvocations() {\n+        return verifyingRecorder.getRegisteredInvocations();\n+    }\n+\n+    public String getMockName() {\n+        if (mockName != null) {\n+            return mockName;\n+        } else {\n+            return toInstanceName(ClassNameFinder.classNameForMock(mock));\n+        }\n+    }\n+\n+    //lower case first letter\n+    private String toInstanceName(String className) {\n+        return className.substring(0, 1).toLowerCase() + className.substring(1);\n+    }\n+\n+    private VerifyingRecorder createRecorder() {\n+        List<Verifier> verifiers = Arrays.asList(\n+                new MissingInvocationInOrderVerifier(),\n+                new NumberOfInvocationsInOrderVerifier(),\n+                new MissingInvocationVerifier(),\n+                new NumberOfInvocationsVerifier(),\n+                new NoMoreInvocationsVerifier());\n+        return new VerifyingRecorder(new AllInvocationsFinder(), verifiers);\n+    }\n+\n+    private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n+        public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n+            stubber.addThrowableForVoidMethod(throwable);\n+            return this;\n+        }\n+\n+        public VoidMethodStubbable<T> toReturn() {\n+            stubber.addThrowableForVoidMethod(DontThrow.DONT_THROW);\n+            return this;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public VoidMethodStubbable<T> toAnswer(Answer answer) {\n+            stubber.addThrowableForVoidMethod(new DontThrow(answer));\n+            return this;\n+        }\n+\n+        public T on() {\n+            return mock;\n+        }\n+    }\n+\n+    private class OngoingStubbingImpl implements OngoingStubbing<T> {\n+        public OngoingStubbing<T> toReturn(Object value) {\n+            verifyingRecorder.eraseLastInvocation();\n+            stubber.addReturnValue(value);\n+            return new ConsecutiveStubbing();\n+        }\n+\n+        public OngoingStubbing<T> toThrow(Throwable throwable) {\n+            verifyingRecorder.eraseLastInvocation();\n+            stubber.addThrowable(throwable);\n+            return new ConsecutiveStubbing();\n+        }\n+\n+        public OngoingStubbing<T> toAnswer(Answer<T> answer) {\n+            verifyingRecorder.eraseLastInvocation();\n+            stubber.addAnswer(answer);\n+            return new ConsecutiveStubbing();\n+        }\n+    }\n+\n+    private class ConsecutiveStubbing implements OngoingStubbing<T> {\n+        public OngoingStubbing<T> toReturn(Object value) {\n+            stubber.addConsecutiveReturnValue(value);\n+            return this;\n+        }\n+\n+        public OngoingStubbing<T> toThrow(Throwable throwable) {\n+            stubber.addConsecutiveThrowable(throwable);\n+            return this;\n+        }\n+\n+        public OngoingStubbing<T> toAnswer(Answer<T> answer) {\n+            stubber.addConsecutiveAnswer(answer);\n+            return this;\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/progress/OngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.progress;\n-\n-import org.mockito.Mockito;\n-\n-/**\n- * Stubs with return value or exception. E.g:\n- * \n- * <pre>\n- * stub(mock.someMethod()).toReturn(10);\n- * \n- * //you can use flexible argument matchers, e.g:\n- * stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n- * \n- * //setting exception to be thrown:\n- * stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n- * \n- * //you can stub with different behavior for consecutive method calls.\n- * //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.   \n- * stub(mock.someMethod(\"some arg\"))\n- *  .toThrow(new RuntimeException())\n- *  .toReturn(\"foo\");\n- * \n- * </pre>\n- * \n- * See examples in javadoc for {@link Mockito#stub}\n- */\n-public interface OngoingStubbing<T> {\n-\n-    /**\n-     * Stub mock object with given return value. E.g:\n-     * <pre>\n-     * stub(mock.someMethod()).toReturn(10);\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito#stub}\n-     * \n-     * @param value return value\n-     * @return ongoingStubbing object that allows stubbing consecutive calls\n-     */\n-    OngoingStubbing<T> toReturn(T value);\n-\n-    /**\n-     * Stub mock object with throwable that will be thrown on method invocation. E.g:\n-     * <pre>\n-     * stub(mock.someMethod()).toThrow(new RuntimeException());\n-     * </pre>\n-     *\n-     * If throwable is a checked exception then it has to \n-     * match one of the checked exceptions of method signature.\n-     * \n-     * See examples in javadoc for {@link Mockito#stub}\n-     * \n-     * @param throwable to be thrown on method invocation\n-     * @return ongoingStubbing object that allows stubbing consecutive calls\n-     */\n-    OngoingStubbing<T> toThrow(Throwable throwable);\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import org.mockito.Mockito;\n+import org.mockito.internal.stubbing.Answer;\n+\n+/**\n+ * Stubs with return value or exception. E.g:\n+ *\n+ * <pre>\n+ * stub(mock.someMethod()).toReturn(10);\n+ *\n+ * //you can use flexible argument matchers, e.g:\n+ * stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n+ *\n+ * //setting exception to be thrown:\n+ * stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n+ *\n+ * //you can stub with different behavior for consecutive method calls.\n+ * //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.\n+ * stub(mock.someMethod(\"some arg\"))\n+ *  .toThrow(new RuntimeException())\n+ *  .toReturn(\"foo\");\n+ *\n+ * </pre>\n+ *\n+ * See examples in javadoc for {@link Mockito#stub}\n+ */\n+public interface OngoingStubbing<T> {\n+\n+    /**\n+     * Stub mock object with given return value. E.g:\n+     * <pre>\n+     * stub(mock.someMethod()).toReturn(10);\n+     * </pre>\n+     *\n+     * See examples in javadoc for {@link Mockito#stub}\n+     *\n+     * @param value return value\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    OngoingStubbing<T> toReturn(T value);\n+\n+    /**\n+     * Stub mock object with throwable that will be thrown on method invocation. E.g:\n+     * <pre>\n+     * stub(mock.someMethod()).toThrow(new RuntimeException());\n+     * </pre>\n+     *\n+     * If throwable is a checked exception then it has to\n+     * match one of the checked exceptions of method signature.\n+     *\n+     * See examples in javadoc for {@link Mockito#stub}\n+     *\n+     * @param throwable to be thrown on method invocation\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    OngoingStubbing<T> toThrow(Throwable throwable);\n+\n+    /**\n+     * Stub mock object with a custom answer. E.g:\n+     * <pre>\n+     * stub(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n+     *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n+     *         return (Integer) invocation.getArguments()[0];\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param answer the custom answer to execute.\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    OngoingStubbing<T> toAnswer(Answer<T> answer);\n }\n--- a/src/org/mockito/internal/stubbing/Answer.java\n+++ b/src/org/mockito/internal/stubbing/Answer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.stubbing;\n-\n-/**\n- * Used to answer expected calls.\n- * @param <T> the type to return.\n- */\n-public interface Answer<T> {\n-\n-    /**\n-     * @return the value to be returned\n-     * @throws Throwable the throwable to be thrown\n-     */\n-    T answer() throws Throwable;\n-}\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+\n+/**\n+ * Used to answer expected calls.\n+ *\n+ * @param <T> the type to return.\n+ */\n+public interface Answer<T> {\n+\n+    /**\n+     * @param invocation the invocation on the mock.\n+     *\n+     * @return the value to be returned\n+     *\n+     * @throws Throwable the throwable to be thrown\n+     */\n+    T answer(InvocationOnMock invocation) throws Throwable;\n+}\n--- a/src/org/mockito/internal/stubbing/AnswerFactory.java\n+++ b/src/org/mockito/internal/stubbing/AnswerFactory.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.stubbing;\n-\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTraceThrowableWrapper;\n-import org.mockito.exceptions.base.StackTraceFilter;\n-import org.mockito.internal.invocation.Invocation;\n-\n-@SuppressWarnings(\"unchecked\")\n-public class AnswerFactory {\n-\n-    private final StackTraceFilter filter;\n-    private final Reporter reporter;\n-    \n-    public AnswerFactory(StackTraceFilter filter) {\n-        this.filter = filter;\n-        this.reporter = new Reporter();\n-    }\n-    \n-    public Answer createReturningAnswer(final Object value) {\n-        return new Answer<Object>() {\n-            public Object answer() throws Throwable {\n-                return value;\n-            }\n-        };\n-    }\n-    \n-    public Answer createThrowingAnswer(final Throwable throwable, Invocation invocation) {\n-        validateThrowable(throwable, invocation);\n-        return new Answer<Object>() {\n-            public Object answer() throws Throwable {\n-                if (throwable == DontThrow.DONT_THROW) {\n-                    return null;\n-                }\n-                Throwable filtered = throwable.fillInStackTrace();\n-                filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));\n-                throw filtered;\n-            }\n-        };\n-    }\n-    \n-    private void validateThrowable(Throwable throwable, Invocation invocation) {\n-        if (throwable == null) {\n-            reporter.cannotStubWithNullThrowable();\n-        }\n-\n-        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n-            return;\n-        }\n-    \n-        if (!invocation.isValidException(throwable)) {\n-            reporter.checkedExceptionInvalid(throwable);\n-        }\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTraceThrowableWrapper;\n+import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AnswerFactory {\n+\n+    private final StackTraceFilter filter;\n+    private final Reporter reporter;\n+\n+    public AnswerFactory(StackTraceFilter filter) {\n+        this.filter = filter;\n+        this.reporter = new Reporter();\n+    }\n+\n+    public Answer createReturningAnswer(final Object value) {\n+        return new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return value;\n+            }\n+        };\n+    }\n+\n+    public Answer createThrowingAnswer(final Throwable throwable, Invocation invocation) {\n+        validateThrowable(throwable, invocation);\n+        return new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                if (throwable instanceof DontThrow) {\n+                    return ((DontThrow) throwable).getAnswer().answer(invocation);\n+                }\n+                Throwable filtered = throwable.fillInStackTrace();\n+                filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));\n+                throw filtered;\n+            }\n+        };\n+    }\n+\n+    private void validateThrowable(Throwable throwable, Invocation invocation) {\n+        if (throwable == null) {\n+            reporter.cannotStubWithNullThrowable();\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+\n+        if (!invocation.isValidException(throwable)) {\n+            reporter.checkedExceptionInvalid(throwable);\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/DontThrow.java\n+++ b/src/org/mockito/internal/stubbing/DontThrow.java\n  */\n package org.mockito.internal.stubbing;\n \n+import org.mockito.invocation.InvocationOnMock;\n+\n+@SuppressWarnings(\"unchecked\")\n public class DontThrow extends RuntimeException {\n     private static final long serialVersionUID = 1L;\n-    public static final DontThrow DONT_THROW = new DontThrow();\n+    public static final DontThrow DONT_THROW = new DontThrow(null);\n+    private Answer answer;\n+\n+    public DontThrow(Answer answer) {\n+        if (answer == null) {\n+            answer = new Answer() {\n+                public Object answer(InvocationOnMock invocation) throws Throwable {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        this.answer = answer;\n+    }\n+\n+    public Answer getAnswer() {\n+        return answer;\n+    }\n+\n+    public boolean hasAnswer() {\n+        return answer != null;\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.stubbing;\n-\n-import java.util.LinkedList;\n-\n-import org.mockito.internal.invocation.InvocationMatcher;\n-\n-@SuppressWarnings(\"unchecked\")\n-public class StubbedInvocationMatcher extends InvocationMatcher {\n-\n-    private final LinkedList<Answer> answers = new LinkedList<Answer>();\n-    \n-    public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n-        super(invocation.getInvocation(), invocation.getMatchers());\n-        this.answers.add(answer);\n-    }\n-\n-    public Object answer() throws Throwable {\n-        return answers.size() == 1 ? answers.getFirst().answer() : answers.removeFirst().answer();\n-    }\n-\n-    public void addAnswer(Answer answer) {\n-        answers.add(answer);\n-    }\n-    \n-    @Override\n-    public String toString() {\n-        return super.toString() + \" stubbed with: \" + answers;\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import java.util.LinkedList;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbedInvocationMatcher extends InvocationMatcher {\n+\n+    private final LinkedList<Answer> answers = new LinkedList<Answer>();\n+\n+    public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n+        super(invocation.getInvocation(), invocation.getMatchers());\n+        this.answers.add(answer);\n+    }\n+\n+    public Object answer(Invocation invocation) throws Throwable {\n+        return answers.size() == 1 ? answers.getFirst().answer(invocation) : answers.removeFirst().answer(invocation);\n+    }\n+\n+    public void addAnswer(Answer answer) {\n+        answers.add(answer);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return super.toString() + \" stubbed with: \" + answers;\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.stubbing;\n-\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import org.mockito.exceptions.base.StackTraceFilter;\n-import org.mockito.internal.configuration.Configuration;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.progress.MockingProgress;\n-\n-@SuppressWarnings(\"unchecked\")\n-public class Stubber {\n-\n-    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n-    private final MockingProgress mockingProgress;\n-    private final List<Throwable> throwablesForVoidMethod = new ArrayList<Throwable>();\n-    private final AnswerFactory answerFactory = new AnswerFactory(new StackTraceFilter());\n-    \n-    private InvocationMatcher invocationForStubbing;\n-    \n-    public Stubber(MockingProgress mockingProgress) {\n-        this.mockingProgress = mockingProgress;\n-    }\n-\n-    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n-        this.invocationForStubbing = invocation;\n-    }\n-    \n-    public void addReturnValue(Object value) {\n-        mockingProgress.stubbingCompleted();\n-        Answer answer = answerFactory.createReturningAnswer(value);\n-        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-    }\n-    \n-    public void addThrowable(Throwable throwable) {\n-        mockingProgress.stubbingCompleted();\n-        Answer answer = answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation());\n-        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-    }\n-    \n-    public void addConsecutiveReturnValue(Object value) {\n-        stubbed.getFirst().addAnswer(answerFactory.createReturningAnswer(value));\n-    }\n-\n-    public void addConsecutiveThrowable(Throwable throwable) {\n-        stubbed.getFirst().addAnswer(answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation()));\n-    }    \n-\n-    public Object resultFor(Invocation invocation) throws Throwable {\n-        for (StubbedInvocationMatcher s : stubbed) {\n-            if (s.matches(invocation)) {\n-                return s.answer();\n-            }\n-        }\n-        return Configuration.instance().getReturnValues().valueFor(invocation);\n-    }\n-\n-    public void addThrowableForVoidMethod(Throwable throwable) {\n-        throwablesForVoidMethod.add(throwable);\n-    }\n-\n-    public boolean hasThrowableForVoidMethod() {\n-        return !throwablesForVoidMethod.isEmpty();\n-    }\n-    \n-    public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {\n-        invocationForStubbing = voidMethodInvocationMatcher;\n-        assert hasThrowableForVoidMethod();\n-        for (int i = 0; i < throwablesForVoidMethod.size(); i++) {\n-            Throwable throwable = throwablesForVoidMethod.get(i);\n-            if (i == 0) {\n-                addThrowable(throwable);\n-            } else {\n-                addConsecutiveThrowable(throwable);\n-            }\n-        }\n-        throwablesForVoidMethod.clear();\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.configuration.Configuration;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.MockingProgress;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class Stubber {\n+\n+    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n+    private final MockingProgress mockingProgress;\n+    private final List<Throwable> throwablesForVoidMethod = new ArrayList<Throwable>();\n+    private final AnswerFactory answerFactory = new AnswerFactory(new StackTraceFilter());\n+\n+    private InvocationMatcher invocationForStubbing;\n+\n+    public Stubber(MockingProgress mockingProgress) {\n+        this.mockingProgress = mockingProgress;\n+    }\n+\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        this.invocationForStubbing = invocation;\n+    }\n+\n+    public void addReturnValue(Object value) {\n+        mockingProgress.stubbingCompleted();\n+        Answer answer = answerFactory.createReturningAnswer(value);\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+    }\n+\n+    public void addThrowable(Throwable throwable) {\n+        mockingProgress.stubbingCompleted();\n+        Answer answer = answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation());\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+    }\n+\n+    public void addAnswer(Answer answer) {\n+        mockingProgress.stubbingCompleted();\n+        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+    }\n+\n+    public void addConsecutiveReturnValue(Object value) {\n+        stubbed.getFirst().addAnswer(answerFactory.createReturningAnswer(value));\n+    }\n+\n+    public void addConsecutiveThrowable(Throwable throwable) {\n+        stubbed.getFirst()\n+                .addAnswer(answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation()));\n+    }\n+\n+    public void addConsecutiveAnswer(Answer answer) {\n+        stubbed.getFirst().addAnswer(answer);\n+    }\n+\n+    public Object resultFor(Invocation invocation) throws Throwable {\n+        for (StubbedInvocationMatcher s : stubbed) {\n+            if (s.matches(invocation)) {\n+                return s.answer(invocation);\n+            }\n+        }\n+        return Configuration.instance().getReturnValues().valueFor(invocation);\n+    }\n+\n+    public void addThrowableForVoidMethod(Throwable throwable) {\n+        throwablesForVoidMethod.add(throwable);\n+    }\n+\n+    public boolean hasThrowableForVoidMethod() {\n+        return !throwablesForVoidMethod.isEmpty();\n+    }\n+\n+    public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {\n+        invocationForStubbing = voidMethodInvocationMatcher;\n+        assert hasThrowableForVoidMethod();\n+        for (int i = 0; i < throwablesForVoidMethod.size(); i++) {\n+            Throwable throwable = throwablesForVoidMethod.get(i);\n+            if (i == 0) {\n+                addThrowable(throwable);\n+            } else {\n+                addConsecutiveThrowable(throwable);\n+            }\n+        }\n+        throwablesForVoidMethod.clear();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n \n /**\n  * Stubs void method with an exception. E.g:\n- * \n+ *\n  * <pre>\n  * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n- * \n+ *\n  * //you can stub with different behavior for consecutive method calls.\n- * //Last stubbing (e.g: toReturn()) determines the behavior for further consecutive calls.   \n+ * //Last stubbing (e.g: toReturn()) determines the behavior for further consecutive calls.\n  * stub(mock)\n  *  .toThrow(new RuntimeException())\n  *  .toReturn()\n  *  .on().someMethod();\n  * </pre>\n- * \n+ *\n  * See examples in javadoc for {@link Mockito#stubVoid}\n  */\n public interface VoidMethodStubbable<T> {\n \n     /**\n      * Stubs void method with an exception. E.g:\n-     * \n+     *\n      * <pre>\n      * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n      * </pre>\n-     * \n-     * If throwable is a checked exception then it has to \n+     *\n+     * If throwable is a checked exception then it has to\n      * match one of the checked exceptions of method signature.\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito#stubVoid}\n-     * \n-     * @param throwable\n-     *            to be thrown on method invocation\n-     * \n+     *\n+     * @param throwable to be thrown on method invocation\n+     *\n      * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n      */\n     VoidMethodStubbable<T> toThrow(Throwable throwable);\n-    \n+\n     /**\n      * Stubs void method to 'just return' (e.g. to <b>not</b> to throw any exception)\n      * <p>\n      *   .toThrow(new RuntimeException())\n      *   .on().foo(10);\n      * </pre>\n-     * <ul> \n+     * <ul>\n      * <li>first time foo(10) is called the mock will 'just return' (e.g. don't throw any exception)</li>\n      * <li>second time foo(10) is called the mock will throw RuntimeException</li>\n      * <li>every consecutive time foo(10) is called the mock will throw RuntimeException</li>\n-     * </ul> \n+     * </ul>\n      * <p>\n      * See examples in javadoc for {@link Mockito#stubVoid}\n-     * \n-     * @return VoidMethodStubbable - typically to choose void method and finish stubbing \n+     *\n+     * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n      */\n     VoidMethodStubbable<T> toReturn();\n-    \n+\n+    /**\n+     * Stubs void method to execute a custom answer.\n+     * <p>\n+     * For Example:\n+     * <pre>\n+     * stubVoid(mock)\n+     *   .toAnswer(new Answer() {\n+     *                 public Object answer(InvocationOnMOck invocation) {\n+     *                     Visitor v = (Visitor) invocation.getArguments()[0];\n+     *                     v.visitMock(invocation.getMock());\n+     *\n+     *                     return null;\n+     *                 }\n+     *             })\n+     *    .on().accept(any());\n+     * </pre>\n+     *\n+     * @param answer the custom answer to execute.\n+     *\n+     * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n+     */\n+    VoidMethodStubbable<T> toAnswer(Answer<T> answer);\n+\n     /**\n      * Choose void method for stubbing. E.g:\n-     * \n+     *\n      * <pre>\n      * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod(\"some arg\");\n      * </pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito#stubVoid}\n-     * \n+     *\n      * @return mock object itself\n      */\n     T on();\n--- a/test/org/mockito/internal/stubbing/AnswerFactoryTest.java\n+++ b/test/org/mockito/internal/stubbing/AnswerFactoryTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n-package org.mockito.internal.stubbing;\n-\n-import static org.mockito.util.ExtraMatchers.*;\n-\n-import java.io.IOException;\n-import java.nio.charset.CharacterCodingException;\n-import java.util.Arrays;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.TestBase;\n-import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.base.StackTraceFilter;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-\n-@SuppressWarnings(\"unchecked\")\n-public class AnswerFactoryTest extends TestBase {\n-\n-    private StackTraceFilterStub filterStub;\n-    private AnswerFactory factory;\n-\n-    @Before\n-    public void setup() {\n-        this.filterStub = new StackTraceFilterStub();\n-        this.factory = new AnswerFactory(filterStub);\n-    }\n-    \n-    @Test\n-    public void shouldCreateReturnResult() throws Throwable {\n-        Answer result = factory.createReturningAnswer(\"lol\");\n-        assertEquals(\"lol\", result.answer());\n-    }\n-    \n-    @Test(expected=RuntimeException.class)\n-    public void shouldCreateThrowResult() throws Throwable {\n-        factory.createThrowingAnswer(new RuntimeException(), null).answer();\n-    }\n-    \n-    @Test\n-    public void shouldFilterStackTraceWhenCreatingThrowResult() throws Throwable {\n-        Answer result = factory.createThrowingAnswer(new RuntimeException(), null);\n-        try {\n-            result.answer(); \n-            fail();\n-        } catch (RuntimeException e) {\n-            assertTrue(Arrays.equals(filterStub.hasStackTrace.getStackTrace(), e.getStackTrace()));\n-            assertThat(e, hasFirstMethodInStackTrace(\"answer\"));\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldValidateNullThrowable() throws Throwable {\n-        try {\n-            factory.createThrowingAnswer(null, null);\n-            fail();\n-        } catch (MockitoException e) {}\n-    }\n-    \n-    @Test\n-    public void shouldAllowSettingProperCheckedException() throws Throwable {\n-        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n-        factory.createThrowingAnswer(new CharacterCodingException(), invocation);\n-    }\n-    \n-    @Test(expected=MockitoException.class)\n-    public void shouldValidateCheckedException() throws Throwable {\n-        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n-        factory.createThrowingAnswer(new IOException(), invocation);\n-    }\n-\n-    class StackTraceFilterStub extends StackTraceFilter {\n-        HasStackTrace hasStackTrace;\n-        @Override public void filterStackTrace(HasStackTrace hasStackTrace) {\n-            this.hasStackTrace = hasStackTrace;\n-        }\n-    }\n-}\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+import java.util.Arrays;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AnswerFactoryTest extends TestBase {\n+\n+    private StackTraceFilterStub filterStub;\n+    private AnswerFactory factory;\n+\n+    @Before\n+    public void setup() {\n+        this.filterStub = new StackTraceFilterStub();\n+        this.factory = new AnswerFactory(filterStub);\n+    }\n+\n+    @Test\n+    public void shouldCreateReturnResult() throws Throwable {\n+        Answer result = factory.createReturningAnswer(\"lol\");\n+        assertEquals(\"lol\", result.answer(null));\n+    }\n+\n+    @Test(expected = RuntimeException.class)\n+    public void shouldCreateThrowResult() throws Throwable {\n+        factory.createThrowingAnswer(new RuntimeException(), null).answer(null);\n+    }\n+\n+    @Test\n+    public void shouldFilterStackTraceWhenCreatingThrowResult() throws Throwable {\n+        Answer result = factory.createThrowingAnswer(new RuntimeException(), null);\n+        try {\n+            result.answer(null);\n+            fail();\n+        } catch (RuntimeException e) {\n+            assertTrue(Arrays.equals(filterStub.hasStackTrace.getStackTrace(), e.getStackTrace()));\n+            assertThat(e, hasFirstMethodInStackTrace(\"answer\"));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldValidateNullThrowable() throws Throwable {\n+        try {\n+            factory.createThrowingAnswer(null, null);\n+            fail();\n+        } catch (MockitoException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAllowSettingProperCheckedException() throws Throwable {\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        factory.createThrowingAnswer(new CharacterCodingException(), invocation);\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldValidateCheckedException() throws Throwable {\n+        Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+        factory.createThrowingAnswer(new IOException(), invocation);\n+    }\n+\n+    class StackTraceFilterStub extends StackTraceFilter {\n+        HasStackTrace hasStackTrace;\n+\n+        @Override\n+        public void filterStackTrace(HasStackTrace hasStackTrace) {\n+            this.hasStackTrace = hasStackTrace;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n+package org.mockitousage.stubbing;\n+\n+import org.junit.Test;\n+import static org.mockito.Mockito.*;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockito.TestBase;\n+import org.mockito.internal.stubbing.Answer;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithCustomAnswerTest extends TestBase {\n+    @Mock\n+    private IMethods mock;\n+\n+    @Test\n+    public void shouldAnswer() throws Exception {\n+        stub(mock.simpleMethod(anyString())).toAnswer(new Answer<String>() {\n+            public String answer(InvocationOnMock invocation) throws Throwable {\n+                String arg = (String) invocation.getArguments()[0];\n+\n+                return invocation.getMethod().getName() + \"-\" + arg;\n+            }\n+        });\n+\n+        assertEquals(\"simpleMethod-test\", mock.simpleMethod(\"test\"));\n+    }\n+\n+    @Test\n+    public void shouldAnswerConsecutively() throws Exception {\n+        stub(mock.simpleMethod())\n+                .toAnswer(new Answer<String>() {\n+                    public String answer(InvocationOnMock invocation) throws Throwable {\n+                        return invocation.getMethod().getName();\n+                    }\n+                })\n+                .toReturn(\"Hello\")\n+                .toAnswer(new Answer<String>() {\n+                    public String answer(InvocationOnMock invocation) throws Throwable {\n+                        return invocation.getMethod().getName() + \"-1\";\n+                    }\n+                });\n+\n+        assertEquals(\"simpleMethod\", mock.simpleMethod());\n+        assertEquals(\"Hello\", mock.simpleMethod());\n+        assertEquals(\"simpleMethod-1\", mock.simpleMethod());\n+        assertEquals(\"simpleMethod-1\", mock.simpleMethod());\n+    }\n+\n+    @Test\n+    public void shoudAnswerVoidMethod() throws Exception {\n+        RecordCall recordCall = new RecordCall();\n+\n+        stubVoid(mock).toAnswer(recordCall).on().voidMethod();\n+\n+        mock.voidMethod();\n+        assertTrue(recordCall.isCalled());\n+    }\n+\n+    @Test\n+    public void shouldAnswerVoidMethodConsecutively() throws Exception {\n+        RecordCall call1 = new RecordCall();\n+        RecordCall call2 = new RecordCall();\n+\n+        stubVoid(mock).toAnswer(call1)\n+                .toThrow(new UnsupportedOperationException())\n+                .toAnswer(call2)\n+                .on().voidMethod();\n+\n+        mock.voidMethod();\n+        assertTrue(call1.isCalled());\n+        assertFalse(call2.isCalled());\n+\n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+\n+        mock.voidMethod();\n+        assertTrue(call2.isCalled());\n+\n+    }\n+\n+    private static class RecordCall implements Answer {\n+        private boolean called = false;\n+\n+        public boolean isCalled() {\n+            return called;\n+        }\n+\n+        public Object answer(InvocationOnMock invocation) throws Throwable {\n+            called = true;\n+            return null;\n+        }\n+    }\n+\n+}", "timestamp": 1214497298, "metainfo": ""}