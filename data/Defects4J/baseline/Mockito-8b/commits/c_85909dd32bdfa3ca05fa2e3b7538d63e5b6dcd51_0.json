{"sha": "85909dd32bdfa3ca05fa2e3b7538d63e5b6dcd51", "log": "name refactoring  --HG-- rename : src/org/mockito/internal/state/LastArguments.java => src/org/mockito/internal/progress/LastArguments.java rename : src/org/mockito/internal/state/MockingProgress.java => src/org/mockito/internal/progress/MockingProgress.java rename : src/org/mockito/internal/state/MockingProgressImpl.java => src/org/mockito/internal/progress/MockingProgressImpl.java rename : src/org/mockito/internal/state/OngoingStubbing.java => src/org/mockito/internal/progress/OngoingStubbing.java rename : src/org/mockito/internal/state/OngoingVerifyingMode.java => src/org/mockito/internal/progress/OngoingVerifyingMode.java rename : src/org/mockito/internal/state/ThreadSafeMockingProgress.java => src/org/mockito/internal/progress/ThreadSafeMockingProgress.java rename : test/org/mockito/internal/state/MockingProgressImplTest.java => test/org/mockito/internal/progress/MockingProgressImplTest.java rename : test/org/mockito/internal/state/OngoingVerifyingModeTest.java => test/org/mockito/internal/progress/OngoingVerifyingModeTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40165", "commit": "\n--- a/src/org/mockito/CrazyMatchers.java\n+++ b/src/org/mockito/CrazyMatchers.java\n package org.mockito;\n \n import org.mockito.internal.matchers.*;\n-import org.mockito.internal.state.LastArguments;\n+import org.mockito.internal.progress.LastArguments;\n \n public class CrazyMatchers {\n     \n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n package org.mockito;\n \n import org.mockito.internal.matchers.*;\n-import org.mockito.internal.state.LastArguments;\n+import org.mockito.internal.progress.LastArguments;\n \n public class Matchers {\n     /**\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.creation.MockFactory;\n import org.mockito.internal.creation.ObjectMethodsFilter;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.state.*;\n+import org.mockito.internal.progress.*;\n import org.mockito.internal.stubbing.VoidMethodStubable;\n \n @SuppressWarnings(\"unchecked\")\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n import java.util.*;\n \n import org.mockito.exceptions.Exceptions;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n class StrictOrderVerifier implements Strictly {\n     \n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n  */\n package org.mockito;\n \n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public interface Strictly {\n \n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.state.MockingProgress;\n-import org.mockito.internal.state.OngoingStubbing;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n import org.mockito.internal.stubbing.EmptyReturnValues;\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n--- a/src/org/mockito/internal/creation/MockFactory.java\n+++ b/src/org/mockito/internal/creation/MockFactory.java\n \n /**\n  * Factory generating a mock for a class.\n- * <p>\n- * Note that this class is stateful\n  */\n public class MockFactory<T> {\n \n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.IArgumentMatcher;\n-import org.mockito.internal.state.LastArguments;\n+import org.mockito.internal.progress.LastArguments;\n \n public class MatchersBinder {\n \n--- /dev/null\n+++ b/src/org/mockito/internal/progress/LastArguments.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Stack;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.And;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.internal.matchers.Not;\n+import org.mockito.internal.matchers.Or;\n+\n+public class LastArguments {\n+    \n+    private static ThreadLocal<LastArguments> INSTANCE = new ThreadLocal<LastArguments>();\n+    \n+    private Stack<IArgumentMatcher> matcherStack = new Stack<IArgumentMatcher>();\n+\n+    public static LastArguments instance() {\n+        if (INSTANCE.get() == null) {\n+            INSTANCE.set(new LastArguments()); \n+        }\n+        \n+        return INSTANCE.get();\n+    }\n+    \n+    public void reportMatcher(IArgumentMatcher matcher) {\n+        matcherStack.push(matcher);\n+    }\n+\n+    public List<IArgumentMatcher> pullMatchers() {\n+        if (matcherStack.isEmpty()) {\n+            return null;\n+        }\n+        \n+        ArrayList<IArgumentMatcher> matchers = new ArrayList<IArgumentMatcher>(matcherStack);\n+        matcherStack.clear();\n+        return matchers;\n+    }\n+\n+    public void reportAnd(int count) {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found for And(?).\");\n+        matcherStack.push(new And(popLastArgumentMatchers(count)));\n+    }\n+\n+    public void reportNot() {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found for Not(?).\");\n+        matcherStack.push(new Not(popLastArgumentMatchers(1).get(0)));\n+    }\n+\n+    private List<IArgumentMatcher> popLastArgumentMatchers(int count) {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n+        assertState(matcherStack.size() >= count,\n+                \"\" + count + \" matchers expected, \" + matcherStack.size() + \" recorded.\");\n+        List<IArgumentMatcher> result = new LinkedList<IArgumentMatcher>();\n+        result.addAll(matcherStack.subList(matcherStack.size() - count, matcherStack.size()));\n+        for (int i = 0; i < count; i++) {\n+            matcherStack.pop();\n+        }\n+        return result;\n+    }\n+\n+    private void assertState(boolean toAssert, String message) {\n+        if (!toAssert) {\n+            matcherStack.clear();\n+            throw new InvalidUseOfMatchersException(message);\n+        }\n+    }\n+\n+    public void reportOr(int count) {\n+        assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n+        matcherStack.push(new Or(popLastArgumentMatchers(count)));\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n+package org.mockito.internal.progress;\n+\n+\n+\n+//TODO verificationMode instead verifying\n+@SuppressWarnings(\"unchecked\")\n+public interface MockingProgress {\n+\n+    void reportStubable(OngoingStubbing ongoingStubbing);\n+\n+    OngoingStubbing pullStubable();\n+\n+    void verifyingStarted(OngoingVerifyingMode verifyingMode);\n+\n+    OngoingVerifyingMode pullVerifyingMode();\n+\n+    void stubbingStarted();\n+\n+    void stubbingCompleted();\n+    \n+    int nextSequenceNumber();\n+\n+    void validateState();\n+\n+    void reset();\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import org.mockito.exceptions.Exceptions;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockingProgressImpl implements MockingProgress {\n+    \n+    private OngoingStubbing ongoingStubbing;\n+    private OngoingVerifyingMode ongoingVerifyingMode;\n+    private int invocationSequenceNumber = 1;\n+    private boolean stubbingInProgress = false;\n+\n+    public void reportStubable(OngoingStubbing ongoingStubbing) {\n+        this.ongoingStubbing = ongoingStubbing;\n+    }\n+\n+    public OngoingStubbing pullStubable() {\n+        OngoingStubbing temp = ongoingStubbing;\n+        ongoingStubbing = null;\n+        return temp;\n+    }\n+    \n+    public void verifyingStarted(OngoingVerifyingMode verify) {\n+        validateState();\n+        ongoingVerifyingMode = verify;\n+    }\n+\n+    public OngoingVerifyingMode pullVerifyingMode() {\n+        OngoingVerifyingMode temp = ongoingVerifyingMode;\n+        ongoingVerifyingMode = null;\n+        return temp;\n+    }\n+\n+    public int nextSequenceNumber() {\n+        return invocationSequenceNumber++;\n+    }\n+\n+    public void stubbingStarted() {\n+        validateState();\n+        stubbingInProgress = true;\n+    }\n+\n+    public void validateState() {\n+        if (ongoingVerifyingMode != null) {\n+            ongoingVerifyingMode = null;\n+            Exceptions.unfinishedVerificationException();\n+        }\n+        \n+        if (stubbingInProgress) {\n+            stubbingInProgress = false;\n+            Exceptions.unfinishedStubbing();\n+        }\n+    }\n+\n+    public void stubbingCompleted() {\n+        stubbingInProgress = false;\n+    }\n+    \n+    public String toString() {\n+        return  \"ongoingStubbing: \" + ongoingStubbing + \n+        \", ongoingVerifyingMode: \" + ongoingVerifyingMode +\n+        \", invocationSequenceNumber: \" + invocationSequenceNumber +\n+        \", stubbingInProgress: \" + stubbingInProgress;\n+    }\n+\n+    public void reset() {\n+        stubbingInProgress = false;\n+        ongoingVerifyingMode = null;\n+        invocationSequenceNumber = 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+public interface OngoingStubbing<T> {\n+\n+    void andReturn(T value);\n+\n+    void andThrow(Throwable throwable);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/OngoingVerifyingMode.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.mockito.exceptions.parents.MockitoException;\n+\n+public class OngoingVerifyingMode {\n+\n+    private final Integer wantedInvocationCount;\n+    private final List<Object> mocksToBeVerifiedInSequence;\n+\n+    private OngoingVerifyingMode(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n+        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+        this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n+    }\n+    \n+    public static OngoingVerifyingMode atLeastOnce() {\n+        return new OngoingVerifyingMode(null, Collections.emptyList());\n+    }\n+\n+    public static OngoingVerifyingMode times(int wantedNumberOfInvocations) {\n+        return new OngoingVerifyingMode(wantedNumberOfInvocations, Collections.emptyList());\n+    }\n+    \n+    /**\n+     * Don't use OngoingVerifyingMode class directly. \n+     * <p>\n+     * Use Mockito.atLeastOnce() and Mockito.times()\n+     */\n+    public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n+    \n+    public static OngoingVerifyingMode inOrder(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n+        return new OngoingVerifyingMode(wantedNumberOfInvocations, mocksToBeVerifiedInOrder);\n+    }\n+\n+    public boolean atLeastOnceMode() {\n+        return wantedInvocationCount == null;\n+    }\n+\n+    public Integer wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+\n+    public List<Object> getAllMocksToBeVerifiedInSequence() {\n+        return mocksToBeVerifiedInSequence;\n+    }\n+\n+    public boolean orderOfInvocationsMatters() {\n+        return !mocksToBeVerifiedInSequence.isEmpty();\n+    }\n+\n+    public boolean wantedCountIsZero() {\n+        return wantedInvocationCount != null && wantedInvocationCount == 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ThreadSafeMockingProgress implements MockingProgress {\n+    \n+    private static ThreadLocal<MockingProgress> mockingProgress = new ThreadLocal<MockingProgress>();\n+\n+    static MockingProgress threadSafely() {\n+        if (mockingProgress.get() == null) {\n+            mockingProgress.set(new MockingProgressImpl());\n+        }\n+        return mockingProgress.get();\n+    }\n+    \n+    public void reportStubable(OngoingStubbing ongoingStubbing) {\n+        threadSafely().reportStubable(ongoingStubbing);\n+    }\n+\n+    public OngoingStubbing pullStubable() {\n+        return threadSafely().pullStubable();\n+    }\n+    \n+    public void verifyingStarted(OngoingVerifyingMode verify) {\n+        threadSafely().verifyingStarted(verify);\n+    }\n+\n+    public OngoingVerifyingMode pullVerifyingMode() {\n+        return threadSafely().pullVerifyingMode();\n+    }\n+\n+    public int nextSequenceNumber() {\n+        return threadSafely().nextSequenceNumber();\n+    }\n+\n+    public void stubbingStarted() {\n+        threadSafely().stubbingStarted();\n+    }\n+\n+    public void validateState() {\n+        threadSafely().validateState();\n+    }\n+\n+    public void stubbingCompleted() {\n+        threadSafely().stubbingCompleted();\n+    }\n+    \n+    public String toString() {\n+        return threadSafely().toString();\n+    }\n+\n+    public void reset() {\n+        threadSafely().reset();\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n import org.mockito.exceptions.Exceptions;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.MockingProgress;\n+import org.mockito.internal.progress.MockingProgress;\n \n public class Stubber {\n \n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.exceptions.Exceptions;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class MissingInvocationVerifier implements Verifier {\n \n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n import org.mockito.exceptions.Exceptions;\n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n \n--- a/src/org/mockito/internal/verification/OrderOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/OrderOfInvocationsVerifier.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationChunk;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class OrderOfInvocationsVerifier implements Verifier {\n \n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n import org.mockito.internal.invocation.InvocationChunk;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class RegisteredInvocations {\n     \n--- a/src/org/mockito/internal/verification/Verifier.java\n+++ b/src/org/mockito/internal/verification/Verifier.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n \n public interface Verifier {\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class VerifyingRecorder<T> {\n \n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.state.*;\n+import org.mockito.internal.progress.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MockControlTest extends RequiresValidState {\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+public class MockingProgressImplTest extends RequiresValidState {\n+\n+    private MockingProgress mockingProgress;\n+\n+    @Before\n+    public void setup() {\n+        mockingProgress = new MockingProgressImpl();\n+    }\n+    \n+    @Test\n+    public void shouldSwitchVerifyingMode() throws Exception {\n+        assertNull(mockingProgress.pullVerifyingMode());\n+        \n+        OngoingVerifyingMode mode = OngoingVerifyingMode.times(19);\n+        \n+        mockingProgress.verifyingStarted(mode);\n+        \n+        assertSame(mode, mockingProgress.pullVerifyingMode());\n+    }\n+    \n+    @Test\n+    public void shouldCheckIfVerificationWasFinished() throws Exception {\n+        mockingProgress.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+        try {\n+            mockingProgress.verifyingStarted(OngoingVerifyingMode.atLeastOnce());\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/OngoingVerifyingModeTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+public class OngoingVerifyingModeTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n+        OngoingVerifyingMode mode = OngoingVerifyingMode.atLeastOnce();\n+        assertTrue(mode.atLeastOnceMode());\n+        \n+        mode = OngoingVerifyingMode.times(50);\n+        assertFalse(mode.atLeastOnceMode());\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            OngoingVerifyingMode.times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.state.MockingProgressImpl;\n+import org.mockito.internal.progress.MockingProgressImpl;\n import org.mockito.internal.stubbing.Stubber;\n \n public class StubberTest extends RequiresValidState{\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n \n import org.junit.*;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n \n @SuppressWarnings(\"unchecked\")\n--- a/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/verification/RegisteredInvocationsTest.java\n import static java.util.Arrays.asList;\n import static java.util.Collections.EMPTY_LIST;\n import static org.junit.Assert.*;\n-import static org.mockito.internal.state.OngoingVerifyingMode.*;\n+import static org.mockito.internal.progress.OngoingVerifyingMode.*;\n \n import java.util.*;\n \n import org.mockito.internal.invocation.InvocationChunk;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n-import org.mockito.internal.state.OngoingVerifyingMode;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n import org.mockito.internal.verification.RegisteredInvocations;\n \n @SuppressWarnings(\"unchecked\")\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n-import org.mockito.internal.state.MockingProgressImplTest;\n-import org.mockito.internal.state.OngoingVerifyingModeTest;\n+import org.mockito.internal.progress.MockingProgressImplTest;\n+import org.mockito.internal.progress.OngoingVerifyingModeTest;\n import org.mockito.internal.stubbing.EmptyReturnValuesTest;\n import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;", "timestamp": 1197407739, "metainfo": ""}