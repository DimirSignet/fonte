{"sha": "c69a4d39130e291b56131fdf03c807b48be77eab", "log": "changed the interface so that it is possible to fluently configure mocks (name, returnValues, etc...)  --HG-- rename : test/org/mockitousage/AnnotationsTest.java => test/org/mockitousage/basicapi/AnnotationsTest.java rename : test/org/mockitousage/MocksCreationTest.java => test/org/mockitousage/basicapi/MocksCreationTest.java rename : test/org/mockitousage/ReplacingObjectMethodsTest.java => test/org/mockitousage/basicapi/ReplacingObjectMethodsTest.java rename : test/org/mockitousage/reset/ResetTest.java => test/org/mockitousage/basicapi/ResetTest.java rename : test/org/mockitousage/UsingVarargsTest.java => test/org/mockitousage/basicapi/UsingVarargsTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401416", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/MockSettings.java\n+package org.mockito;\n+\n+public interface MockSettings {\n+    \n+    MockSettings extraInterfaces(Class<?>... interfaces);\n+\n+    MockSettings name(String name);\n+\n+    MockSettings defaultBehavior(ReturnValues returnValues);\n+    \n+    //TODO: hide spiedInstance?\n+    MockSettings spiedInstance(Object object);\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n \n import org.mockito.internal.MockitoCore;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.returnvalues.EmptyReturnValues;\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return MOCKITO_CORE.mock(classToMock, null, null, null, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock(classToMock, configureWith().defaultBehavior(RETURNS_DEFAULTS));\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, String name) {\n-        return MOCKITO_CORE.mock(classToMock, null, name, null, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock(classToMock, configureWith().name(name).defaultBehavior(RETURNS_DEFAULTS));\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n-        return MOCKITO_CORE.mock(classToMock, null, null, (T) null, returnValues);\n+        return MOCKITO_CORE.mock(classToMock, configureWith().defaultBehavior(returnValues));\n+    }\n+    \n+    //TODO: javadoc\n+    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n+        return MOCKITO_CORE.mock(classToMock, mockSettings);\n     }\n     \n     /**\n      * @return a spy of the real object\n      */\n     public static <T> T spy(T object) {\n-        return MOCKITO_CORE.mock((Class<T>) object.getClass(), null, null, object, RETURNS_DEFAULTS);\n+        return MOCKITO_CORE.mock((Class<T>) object.getClass(), configureWith().spiedInstance(object).defaultBehavior(RETURNS_DEFAULTS));\n     }\n \n     /**\n     public static void validateMockitoUsage() {\n         MOCKITO_CORE.validateMockitoUsage();\n     }\n+\n+    public static MockSettings configureWith() {\n+        return new MockSettingsImpl();\n+    }\n }\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n \n import org.mockito.AncillaryTypes;\n import org.mockito.InOrder;\n-import org.mockito.ReturnValues;\n+import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n     private final Reporter reporter = new Reporter();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n-    public <T> T mock(Class<T> classToMock, AncillaryTypes implementing, String name,\n-            T optionalInstance, ReturnValues returnValues) {\n+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n         mockingProgress.validateState();\n         mockingProgress.resetOngoingStubbing();\n-        return MockUtil.createMock(classToMock, implementing, mockingProgress, name,\n-                optionalInstance, returnValues);\n+        return MockUtil.createMock(classToMock, mockingProgress, (MockSettingsImpl) mockSettings);\n     }\n     \n     public AncillaryTypes implementing(Class<?>...ancillaryTypes) {\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n+package org.mockito.internal.creation;\n+\n+import org.mockito.MockSettings;\n+import org.mockito.ReturnValues;\n+\n+public class MockSettingsImpl implements MockSettings {\n+\n+    private ReturnValues returnValues;\n+    private Class<?>[] extraInterfaces;\n+    private String name;\n+    private Object spiedInstance;\n+\n+    public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n+        this.extraInterfaces = extraInterfaces;\n+        return this;\n+    }\n+\n+    public String getMockName() {\n+        return name;\n+    }\n+\n+    public ReturnValues getReturnValues() {\n+        return returnValues;\n+    }\n+\n+    public Class<?>[] getExtraInterfaces() {\n+        return extraInterfaces;\n+    }\n+\n+    public Object getSpiedInstance() {\n+        return spiedInstance;\n+    }\n+\n+    public MockSettings defaultBehavior(ReturnValues returnValues) {\n+        this.returnValues = returnValues;\n+        return this;\n+    }\n+\n+    public MockSettings name(String name) {\n+        this.name = name;\n+        return this;\n+    }\n+\n+    public MockSettings spiedInstance(Object spiedInstance) {\n+        this.spiedInstance = spiedInstance;\n+        return this;\n+    }\n+}\n--- a/src/org/mockito/internal/returnvalues/MockReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/MockReturnValues.java\n \n import org.mockito.ReturnValues;\n import org.mockito.internal.MockitoCore;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.invocation.InvocationOnMock;\n \n             return null;\n         }\n         \n-        return mockitoCore.mock((Class) class1, null, null, null, this);\n+        return mockitoCore.mock((Class) class1, new MockSettingsImpl().defaultBehavior(this));\n     }\n-\n-}\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n \n-import org.mockito.AncillaryTypes;\n-import org.mockito.ReturnValues;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n \n public class MockUtil {\n \n-    public static <T> T createMock(Class<T> classToMock, AncillaryTypes ancillaryTypes, MockingProgress progress, String mockName,\n-            T optionalInstance, ReturnValues returnValues) {\n+    public static <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\n         validateType(classToMock);\n-        MockHandler<T> mockHandler = new MockHandler<T>(new MockName(mockName, classToMock), progress, new MatchersBinder(), returnValues);\n+        MockName mockName = new MockName(settings.getMockName(), classToMock);\n+        MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings.getReturnValues());\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n-        Class<?>[] interfaces = ancillaryTypes == null ? new Class<?>[0] : ancillaryTypes.implementing();\n+        Class<?>[] ancillaryTypes = settings.getExtraInterfaces();\n+        Class<?>[] interfaces = ancillaryTypes == null ? new Class<?>[0] : ancillaryTypes;\n+        Object optionalInstance = settings.getSpiedInstance();\n         \n         T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, interfaces);\n         \n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n-import org.mockitousage.ReplacingObjectMethodsTest;\n-import org.mockitousage.UsingVarargsTest;\n+import org.mockitousage.basicapi.ReplacingObjectMethodsTest;\n+import org.mockitousage.basicapi.ResetTest;\n+import org.mockitousage.basicapi.UsingVarargsTest;\n import org.mockitousage.examples.configure.withbaseclass.ConfiguringDefaultReturnValuesUsingBaseClassTest;\n import org.mockitousage.examples.configure.withrunner.ConfiguringDefaultReturnValuesUsingRunnerTest;\n import org.mockitousage.examples.configure.withstaticutility.ConfiguringSelectedMocksToReturnFakesTest;\n import org.mockitousage.misuse.InvalidUsageTest;\n import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n-import org.mockitousage.reset.ResetTest;\n import org.mockitousage.stacktrace.ClickableStackTracesTest;\n import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n import org.mockitousage.stacktrace.StackTraceFilteringTest;\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/AnnotationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AnnotationsTest extends TestBase {\n+\n+    @Mock List list;\n+    @Mock final Map map = new HashMap();\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    @MockitoAnnotations.Mock List listTwo;\n+    \n+    @Before\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+    \n+    @Test\n+    public void shouldInitMocks() throws Exception {\n+        list.clear();\n+        map.clear();\n+        listTwo.clear();\n+        \n+        verify(list).clear();\n+        verify(map).clear();\n+        verify(listTwo).clear();\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenInitializingMocksForNullClass() throws Exception {\n+        try {\n+            MockitoAnnotations.initMocks(null);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\",\n+                    e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldLookForAnnotatedMocksInSuperClasses() throws Exception {\n+        Sub sub = new Sub();\n+        MockitoAnnotations.initMocks(sub);\n+        \n+        assertNotNull(sub.getMock());\n+        assertNotNull(sub.getBaseMock());\n+        assertNotNull(sub.getSuperBaseMock());\n+    }\n+    \n+    class SuperBase {\n+        @Mock private IMethods mock;\n+        \n+        public IMethods getSuperBaseMock() {\n+            return mock;\n+        }\n+    }\n+    \n+    class Base extends SuperBase {\n+        @Mock private IMethods mock;\n+        \n+        public IMethods getBaseMock() {\n+            return mock;\n+        }\n+    }\n+    \n+    class Base2 extends SuperBase {\n+        @Mock private IMethods mock;\n+        \n+        public IMethods getBaseMock() {\n+            return mock;\n+        }\n+    }\n+    \n+    class Sub extends Base {\n+        @Mock private IMethods mock;\n+        \n+        public IMethods getMock() {\n+            return mock;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class MockingMultipleInterfacesTest extends TestBase {\n+\n+    class Foo {}\n+    interface IFoo {}\n+    interface IBar {}\n+    \n+    @Test\n+    public void shouldAllowMultipleInterfaces() {\n+        //when\n+        Foo mock = mock(Foo.class, configureWith().extraInterfaces(IFoo.class, IBar.class));\n+        \n+        //then\n+        assertThat(mock, is(IFoo.class));\n+        assertThat(mock, is(IBar.class));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MocksCreationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitoutil.TestBase;\n+\n+public class MocksCreationTest extends TestBase {\n+\n+    private class HasPrivateConstructor {};\n+    \n+    @Test\n+    public void shouldCreateMockWhenConstructorIsPrivate() {\n+        assertNotNull(Mockito.mock(HasPrivateConstructor.class));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/ReplacingObjectMethodsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitoutil.TestBase;\n+\n+public class ReplacingObjectMethodsTest extends TestBase {\n+\n+    private interface DummyInterface {}\n+    private class DummyClass {}\n+    \n+    @Test\n+    public void shouldProvideMockyImplementationOfToString() {\n+        DummyClass dummyClass = Mockito.mock(DummyClass.class);\n+        assertEquals(\"Mock for DummyClass, hashCode: \" + dummyClass.hashCode(), dummyClass.toString());\n+        DummyInterface dummyInterface = Mockito.mock(DummyInterface.class);\n+        assertEquals(\"Mock for DummyInterface, hashCode: \" + dummyInterface.hashCode(), dummyInterface.toString());\n+    }\n+    \n+    @Test \n+    public void shouldReplaceObjectMethods() {\n+        Object mock = Mockito.mock(ObjectMethodsOverridden.class);\n+        Object otherMock = Mockito.mock(ObjectMethodsOverridden.class);\n+        \n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock, not(equalTo(otherMock)));\n+        \n+        assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n+        \n+        assertContains(\"Mock for ObjectMethodsOverridden\", mock.toString());\n+    }\n+    \n+    @Test \n+    public void shouldReplaceObjectMethodsWhenOverridden() {\n+        Object mock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n+        Object otherMock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n+        \n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock, not(equalTo(otherMock)));\n+        \n+        assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n+        \n+        assertContains(\"Mock for ObjectMethodsOverriddenSubclass\", mock.toString());\n+    }\n+    \n+    public static class ObjectMethodsOverridden {\n+        public boolean equals(Object o) {\n+            throw new RuntimeException(\"Should not be called. MethodInterceptorFilter provides implementation\");\n+        }\n+        public int hashCode() {\n+            throw new RuntimeException(\"Should not be called. MethodInterceptorFilter provides implementation\");\n+        }\n+        public String toString() {\n+            throw new RuntimeException(\"Should not be called. MethodInterceptorFilter provides implementation\");\n+        }\n+    }\n+    \n+    public static class ObjectMethodsOverriddenSubclass extends ObjectMethodsOverridden {\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/ResetTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class ResetTest extends TestBase {\n+\n+    @Mock private IMethods mock;\n+    @Mock private IMethods mockTwo;\n+    \n+    @Test\n+    public void shouldResetOngoingStubbingSoThatMoreMeaningfulExceptionsAreRaised() {\n+        mock(IMethods.class);\n+        mock.booleanReturningMethod();\n+        reset(mock);\n+        try {\n+            when(null).thenReturn(\"anything\");\n+            fail();\n+        } catch (MissingMethodInvocationException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveAllStubbing() throws Exception {\n+        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n+        when(mock.objectReturningMethod(200)).thenReturn(200);\n+        reset(mock);\n+        assertNull(mock.objectReturningMethod(200));\n+        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n+    }\n+\n+    @Test\n+    public void shouldRemoveAllInteractions() throws Exception {\n+        mock.simpleMethod(1);\n+        reset(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+\n+    @Test\n+    public void shouldRemoveStubbingToString() throws Exception {\n+        IMethods mockTwo = mock(IMethods.class);\n+        when(mockTwo.toString()).thenReturn(\"test\");\n+        reset(mockTwo);\n+        assertContains(\"Mock for IMethods\", mockTwo.toString());\n+    }\n+\n+    @Test\n+    public void shouldStubbingNotBeTreatedAsInteraction() {\n+        when(mock.simpleMethod(\"one\")).thenThrow(new RuntimeException());\n+        doThrow(new RuntimeException()).when(mock).simpleMethod(\"two\");\n+        reset(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+\n+    @Test\n+    public void shouldNotAffectMockName() {\n+        IMethods mock = mock(IMethods.class, \"mockie\");\n+        IMethods mockTwo = mock(IMethods.class);\n+        reset(mock);\n+        assertContains(\"Mock for IMethods\", \"\" + mockTwo);\n+        assertEquals(\"mockie\", \"\" + mock);\n+    }\n+    \n+    @Test\n+    public void shouldResetMultipleMocks() {\n+        mock.simpleMethod();\n+        mockTwo.simpleMethod();\n+        reset(mock, mockTwo);\n+        verifyNoMoreInteractions(mock, mockTwo);\n+    }\n+    \n+    @Test\n+    public void shouldValidateStateWhenResetting() {\n+        //invalid verify:\n+        verify(mock);\n+        \n+        try {\n+            reset(mockTwo);\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldMaintainPreviousReturnValuesStrategy() {\n+        //given\n+        mock = mock(IMethods.class, RETURNS_MOCKS);\n+        //when\n+        reset(mock);\n+        //then\n+        assertNotNull(mock.iMethodsReturningMethod());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/UsingVarargsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.ArrayList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n+import org.mockitoutil.TestBase;\n+\n+public class UsingVarargsTest extends TestBase {\n+\n+    private interface IVarArgs {\n+        void withStringVarargs(int value, String... s);\n+        String withStringVarargsReturningString(int value, String... s);\n+        void withObjectVarargs(int value, Object... o);\n+        boolean withBooleanVarargs(int value, boolean... b);\n+    }\n+    \n+    IVarArgs mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IVarArgs.class);\n+    }\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void shouldStubStringVarargs() {\n+        when(mock.withStringVarargsReturningString(1)).thenReturn(\"1\");\n+        when(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).thenReturn(\"2\");\n+        \n+        RuntimeException expected = new RuntimeException();\n+        stubVoid(mock).toThrow(expected).on().withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+\n+        assertEquals(\"1\", mock.withStringVarargsReturningString(1));\n+        assertEquals(null, mock.withStringVarargsReturningString(2));\n+        \n+        assertEquals(\"2\", mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\", \"4\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"9999\"));\n+        \n+        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"9999\");\n+        mock.withStringVarargs(9999, \"1\", \"2\", \"3\", \"4\");\n+        \n+        try {\n+            mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(expected, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldStubBooleanVarargs() {\n+        when(mock.withBooleanVarargs(1)).thenReturn(true);\n+        when(mock.withBooleanVarargs(1, true, false)).thenReturn(true);\n+        \n+        assertEquals(true, mock.withBooleanVarargs(1));\n+        assertEquals(false, mock.withBooleanVarargs(9999));\n+        \n+        assertEquals(true, mock.withBooleanVarargs(1, true, false));\n+        assertEquals(false, mock.withBooleanVarargs(1, true, false, true));\n+        assertEquals(false, mock.withBooleanVarargs(2, true, false));\n+        assertEquals(false, mock.withBooleanVarargs(1, true));\n+        assertEquals(false, mock.withBooleanVarargs(1, false, false));\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStringVarargs() {\n+        mock.withStringVarargs(1);\n+        mock.withStringVarargs(2, \"1\", \"2\", \"3\");\n+        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+\n+        verify(mock).withStringVarargs(1);\n+        verify(mock).withStringVarargs(2, \"1\", \"2\", \"3\");\n+        try {\n+            verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {}\n+    }\n+\n+    @Test\n+    public void shouldVerifyObjectVarargs() {\n+        mock.withObjectVarargs(1);\n+        mock.withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n+        mock.withObjectVarargs(3, new Integer(1));\n+\n+        verify(mock).withObjectVarargs(1);\n+        verify(mock).withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+\n+    @Test\n+    public void shouldVerifyBooleanVarargs() {\n+        mock.withBooleanVarargs(1);\n+        mock.withBooleanVarargs(2, true, false, true);\n+        mock.withBooleanVarargs(3, true, true, true);\n+\n+        verify(mock).withBooleanVarargs(1);\n+        verify(mock).withBooleanVarargs(2, true, false, true);\n+        try {\n+            verify(mock).withBooleanVarargs(3, true, true, true, true);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyWithAnyObject() {\n+        Foo foo = Mockito.mock(Foo.class);\n+        foo.varArgs(\"\");        \n+        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n+        Mockito.verify(foo).varArgs((String) Mockito.anyObject());\n+    }   \n+    \n+    @Test\n+    public void shouldVerifyWithNullVarArgArray() {\n+        Foo foo = Mockito.mock(Foo.class);\n+        foo.varArgs((String[]) null);    \n+        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n+        Mockito.verify(foo).varArgs((String[]) null);\n+    }  \n+    \n+    public class Foo {      \n+        public void varArgs(String... args) {}       \n+    }\n+    \n+    interface MixedVarargs {\n+        String doSomething(String one, String... varargs);\n+        String doSomething(String one, String two, String... varargs);\n+    }\n+\n+    @SuppressWarnings(\"all\")\n+    @Test\n+    //See bug #31\n+    public void shouldStubCorrectlyWhenMixedVarargsUsed() {\n+        MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n+        when(mixedVarargs.doSomething(\"hello\", null)).thenReturn(\"hello\");\n+        when(mixedVarargs.doSomething(\"goodbye\", null)).thenReturn(\"goodbye\");\n+\n+        String result = mixedVarargs.doSomething(\"hello\", null);\n+        assertEquals(\"hello\", result);\n+        \n+        verify(mixedVarargs).doSomething(\"hello\", null);\n+    }\n+    \n+    @SuppressWarnings(\"all\")\n+    @Test\n+    public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed() {\n+        MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n+        when(mixedVarargs.doSomething(\"one\", \"two\", null)).thenReturn(\"hello\");\n+        when(mixedVarargs.doSomething(\"1\", \"2\", null)).thenReturn(\"goodbye\");\n+\n+        String result = mixedVarargs.doSomething(\"one\", \"two\", null);\n+        assertEquals(\"hello\", result);\n+    }\n+}", "timestamp": 1241991207, "metainfo": ""}