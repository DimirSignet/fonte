{"sha": "a10d9c323124ca47f7d57d4545f4d9f5587f7da5", "log": "Added some code to make it easy for incoming feature (smarter printing verbose types for arguments)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401473", "commit": "\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n package org.mockito.internal.verification.argumentmatching;\n \n+import java.util.LinkedList;\n import java.util.List;\n \n import org.hamcrest.Matcher;\n+import org.hamcrest.StringDescription;\n \n @SuppressWarnings(\"unchecked\")\n public class ArgumentMatchingTool {\n \n+    /**\n+     * Suspiciously not matching arguments are those that don't much BUT the toString() representation is the same.\n+     * \n+     * @param matchers\n+     * @param arguments\n+     * @return\n+     */\n     public Matcher[] getSuspiciouslyNotMatchingArgs(List<Matcher> matchers, Object[] arguments) {\n-        return new Matcher[0];\n+        if (matchers.size() != arguments.length) {\n+            return new Matcher[0];\n+        }\n+        \n+        List<Matcher> suspicious = new LinkedList<Matcher>();\n+        int i = 0;\n+        for (Matcher m : matchers) {\n+            if (!safelyMatches(m, arguments[i]) && toStringEquals(m, arguments[i])) {\n+                suspicious.add(m);\n+            }\n+            i++;\n+        }\n+        return suspicious.toArray(new Matcher[0]);\n+    }\n+\n+    private boolean safelyMatches(Matcher m, Object arg) {\n+        try {\n+            return m.matches(arg);\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    private boolean toStringEquals(Matcher m, Object arg) {\n+        return StringDescription.toString(m).equals(arg.toString());\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java\n+package org.mockito.internal.verification.argumentmatching;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+import org.mockito.internal.matchers.Equals;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ArgumentMatchingToolTest {\n+\n+    private ArgumentMatchingTool tool = new ArgumentMatchingTool();\n+\n+    @Test\n+    public void shouldNotFindAnySuspiciousMatchersWhenNumberOfArgumentsDoesntMatch() {\n+        //given\n+        List<Matcher> matchers = (List) Arrays.asList(new Equals(1));\n+\n+        //when\n+        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10, 20});\n+        \n+        //then\n+        assertEquals(0, suspicious.length);\n+    }\n+\n+    @Test\n+    public void shouldNotFindAnySuspiciousMatchersWhenArgumentsMatch() {\n+        //given\n+        List<Matcher> matchers = (List) Arrays.asList(new Equals(10), new Equals(20));\n+        \n+        //when\n+        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10, 20});\n+        \n+        //then\n+        assertEquals(0, suspicious.length);\n+    }\n+    \n+    @Test\n+    public void shouldFindSuspiciousMatchers() {\n+        //given\n+        Equals matcherInt20 = new Equals(20);\n+        Long longPretendingAnInt = new Long(20);\n+        \n+        //when\n+        List<Matcher> matchers = (List) Arrays.asList(new Equals(10), matcherInt20);\n+        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10, longPretendingAnInt});\n+        \n+        //then\n+        assertEquals(1, suspicious.length);\n+        assertEquals(matcherInt20, suspicious[0]);\n+    }\n+    \n+    @Test\n+    public void shouldUseMatchersSafely() {\n+        //given\n+        List<Matcher> matchers = (List) Arrays.asList(new BaseMatcher() {\n+            public boolean matches(Object item) {\n+                throw new ClassCastException(\"nasty matcher\");\n+            }\n+\n+            public void describeTo(Description description) {\n+            }});\n+        \n+        //when\n+        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10});\n+        \n+        //then\n+        assertEquals(0, suspicious.length);\n+    }\n+}", "timestamp": 1244237561, "metainfo": ""}