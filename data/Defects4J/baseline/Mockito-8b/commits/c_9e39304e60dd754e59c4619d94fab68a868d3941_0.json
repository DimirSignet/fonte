{"sha": "9e39304e60dd754e59c4619d94fab68a868d3941", "log": "sorted out documentation  --HG-- rename : src/org/mockito/internal/progress/VerificationMode.java => src/org/mockito/internal/progress/VerificationModeImpl.java rename : test/org/mockito/internal/progress/VerificationModeTest.java => test/org/mockito/internal/progress/VerificationModeImplTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40225", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n \n /**\n      * See examples {@link Mockito}\n      * \n      * @param mock to be verified\n-     * @param mode - times(x) or atLeastOnce()\n+     * @param mode times(x) or atLeastOnce()\n      * \n      * @return mock object itself\n      */\n      * See examples {@link Mockito}\n      * \n      * @param mock to stub\n-     * @return\n+     * @return stubbable object that allows stubbing with throwable\n      */\n     public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n         MockHandler<T> handler = MockUtil.getMockHandler(mock);\n      * @return verification mode\n      */\n     public static VerificationMode atLeastOnce() {\n-        return VerificationMode.atLeastOnce();\n+        return VerificationModeImpl.atLeastOnce();\n     }\n \n     /**\n      * @return verification mode\n      */\n     public static VerificationMode times(int wantedNumberOfInvocations) {\n-        return VerificationMode.times(wantedNumberOfInvocations);\n+        return VerificationModeImpl.times(wantedNumberOfInvocations);\n     }\n }\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n class StrictOrderVerifier implements Strictly {\n     \n     }\n     \n     public <T> T verify(T mock) {\n-        return this.verify(mock, VerificationMode.times(1));\n+        return this.verify(mock, VerificationModeImpl.times(1));\n     }\n     \n-    public <T> T verify(T mock, VerificationMode verificationMode) {\n+    public <T> T verify(T mock, VerificationMode mode) {\n         if (!mocksToBeVerifiedSrictly.contains(mock)) {\n             reporter.strictlyRequiresFamiliarMock();\n         }\n-        return Mockito.verify(mock, VerificationMode.strict(verificationMode.wantedCount(), mocksToBeVerifiedSrictly));\n+        Integer wantedCount = ((VerificationModeImpl) mode).wantedCount();\n+        return Mockito.verify(mock, VerificationModeImpl.strict(wantedCount, mocksToBeVerifiedSrictly));\n     }\n }\n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n      * See examples {@link Mockito}\n      * \n      * @param mock to be verified\n-     * @param mode - times(x) or atLeastOnce()\n+     * @param mode times(x) or atLeastOnce()\n      * \n      * @return mock object itself\n      */\n-    <T> T verify(T mock, VerificationMode verificationMode);\n+    <T> T verify(T mock, VerificationMode mode);\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.EmptyReturnValues;\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n             return null;\n         }\n         \n-        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+        VerificationModeImpl verificationMode = mockingProgress.pullVerificationMode();\n         mockingProgress.validateState();\n         \n         Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n     }\n \n     public void verifyNoMoreInteractions() {\n-        verifyingRecorder.verify(VerificationMode.noMoreInteractions());\n+        verifyingRecorder.verify(VerificationModeImpl.noMoreInteractions());\n     }\n     \n     public void andReturn(T value) {\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n import java.util.List;\n \n import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n /**\n  * Provides handful of methods to search and count invocations\n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n \n-    public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         int counter = 0;\n         for (Invocation invocation : invocations) {\n             if (wanted.matches(invocation)) {\n--- a/src/org/mockito/internal/invocation/InvocationsMarker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsMarker.java\n \n import java.util.List;\n \n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n //TODO name\n public class InvocationsMarker {\n \n     public void markInvocationsAsVerified(List<Invocation> invocations,\n-            InvocationMatcher wanted, VerificationMode mode) {\n+            InvocationMatcher wanted, VerificationModeImpl mode) {\n         if (mode.wantedCountIsZero()) {\n             return;\n         }\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n \n     void verificationStarted(VerificationMode verificationMode);\n \n-    VerificationMode pullVerificationMode();\n+    VerificationModeImpl pullVerificationMode();\n \n     void stubbingStarted();\n \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n     private final Reporter reporter = new Reporter();\n     \n     private OngoingStubbing ongoingStubbing;\n-    private VerificationMode verificationMode;\n+    private VerificationModeImpl verificationMode;\n     private int invocationSequenceNumber = 1;\n     private boolean stubbingInProgress = false;\n \n     \n     public void verificationStarted(VerificationMode verify) {\n         validateState();\n-        verificationMode = verify;\n+        verificationMode = (VerificationModeImpl) verify;\n     }\n \n-    public VerificationMode pullVerificationMode() {\n-        VerificationMode temp = verificationMode;\n+    public VerificationModeImpl pullVerificationMode() {\n+        VerificationModeImpl temp = verificationMode;\n         verificationMode = null;\n         return temp;\n     }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n         threadSafely().verificationStarted(verify);\n     }\n \n-    public VerificationMode pullVerificationMode() {\n+    public VerificationModeImpl pullVerificationMode() {\n         return threadSafely().pullVerificationMode();\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+/**\n+ * Holds additional information regarding verification.\n+ * <p> \n+ * Implements marking interface which hides details from Mockito users. \n+ */\n+public class VerificationModeImpl implements VerificationMode {\n+    \n+    enum Verification { EXPLICIT, NO_MORE_WANTED };\n+    \n+    private final Integer wantedInvocationCount;\n+    private final List<Object> mocksToBeVerifiedStrictly;\n+    private final Verification verification;\n+    \n+    private VerificationModeImpl(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedStrictly, Verification verification) {\n+        if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        assert mocksToBeVerifiedStrictly != null;\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+        this.mocksToBeVerifiedStrictly = mocksToBeVerifiedStrictly;\n+        this.verification = verification;\n+    }\n+    \n+    public static VerificationModeImpl atLeastOnce() {\n+        return new VerificationModeImpl(null, Collections.emptyList(), Verification.EXPLICIT);\n+    }\n+\n+    public static VerificationModeImpl times(int wantedNumberOfInvocations) {\n+        return new VerificationModeImpl(wantedNumberOfInvocations, Collections.emptyList(), Verification.EXPLICIT);\n+    }\n+\n+    public static VerificationModeImpl strict(Integer wantedNumberOfInvocations, List<Object> mocksToBeVerifiedStrictly) {\n+        assert !mocksToBeVerifiedStrictly.isEmpty();\n+        return new VerificationModeImpl(wantedNumberOfInvocations, mocksToBeVerifiedStrictly, Verification.EXPLICIT);\n+    }\n+    \n+    public static VerificationModeImpl noMoreInteractions() {\n+        return new VerificationModeImpl(null, Collections.emptyList(), Verification.NO_MORE_WANTED);\n+    }\n+\n+    public Integer wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+\n+    public List<Object> getAllMocksToBeVerifiedStrictly() {\n+        return mocksToBeVerifiedStrictly;\n+    }\n+\n+    public boolean wantedCountIsZero() {\n+        return wantedInvocationCount != null && wantedInvocationCount == 0;\n+    }\n+\n+    public boolean atLeastOnceMode() {\n+        return wantedInvocationCount == null && verification == Verification.EXPLICIT;\n+    }\n+\n+    public boolean strictMode() {\n+        return !mocksToBeVerifiedStrictly.isEmpty();\n+    }\n+\n+    public boolean explicitMode() {\n+        return verification == Verification.EXPLICIT;\n+    }\n+    \n+    public boolean missingMethodMode() {\n+        return explicitMode() && (atLeastOnceMode() || wantedInvocationCount == 1);\n+    }\n+\n+    public boolean exactNumberOfInvocationsMode() {\n+        return !atLeastOnceMode() && explicitMode();\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedStrictly;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.invocation.InvocationsPrinter;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class MissingInvocationVerifier implements Verifier {\n     \n         this.reporter = reporter;\n     }\n \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         if (!mode.missingMethodMode()) {\n             return;\n         }\n--- a/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NoMoreInvocationsVerifier implements Verifier {\n \n         this.reporter = reporter;\n     }\n \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         if (mode.explicitMode()) {\n             return;\n         }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n     \n         this.analyzer = analyzer;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         if (!mode.exactNumberOfInvocationsMode()) {\n             return;\n         }\n--- a/src/org/mockito/internal/verification/Verifier.java\n+++ b/src/org/mockito/internal/verification/Verifier.java\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public interface Verifier {\n-    void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode);\n+    void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode);\n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class VerifyingRecorder {\n \n         return registeredInvocations;\n     }\n     \n-    public void verify(VerificationMode mode) {\n+    public void verify(VerificationModeImpl mode) {\n         verify(null, mode);\n     }\n     \n-    public void verify(InvocationMatcher wanted, VerificationMode mode) {\n+    public void verify(InvocationMatcher wanted, VerificationModeImpl mode) {\n         List<Invocation> invocations = getInvocationsForEvaluation(mode);\n         \n         for (Verifier verifier : verifiers) {\n         }\n     }\n     \n-    private List<Invocation> getInvocationsForEvaluation(VerificationMode mode) {\n+    private List<Invocation> getInvocationsForEvaluation(VerificationModeImpl mode) {\n         if (mode.strictMode()) {\n-            return chunker.getFirstUnverifiedInvocationChunk(mode.getAllMocksToBeVerifiedInSequence());\n+            return chunker.getFirstUnverifiedInvocationChunk(mode.getAllMocksToBeVerifiedStrictly());\n         } else {\n             return registeredInvocations;\n         }\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgressImpl;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n @SuppressWarnings(\"unchecked\")\n public class MockHandlerTest extends RequiresValidState {\n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         MockingProgressImpl state = new MockingProgressImpl();\n-        state.verificationStarted(VerificationMode.atLeastOnce());\n+        state.verificationStarted(VerificationModeImpl.atLeastOnce());\n         MockHandler handler = new MockHandler(state, new ExceptionThrowingBinder());\n         \n         try {\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.base.HasStackTrace;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class InvocationsAnalyzerTest extends RequiresValidState {\n     \n     \n     @Test\n     public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n-        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n+        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(0));\n         HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test\n     public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n-        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n+        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(1));\n         HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n-        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n+        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(2));\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n-        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n+        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeImpl.times(100));\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n package org.mockito.internal.invocation;\n \n import static org.junit.Assert.assertEquals;\n-import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n-import static org.mockito.internal.progress.VerificationMode.times;\n+import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationModeImpl.times;\n \n import java.util.Arrays;\n import java.util.List;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.progress.VerificationModeBuilder;\n \n public class InvocationsMarkerTest extends RequiresValidState {\n     \n     @Test\n     public void shouldMarkAsVerifedStrictlyAllInvocationsFromChunk() throws Exception {\n-        VerificationMode mode = new VerificationModeBuilder().strict();\n+        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n         Invocation doesntMatter = null;\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n         \n     \n     @Test\n     public void shouldMarkAsVerifedAllInvocationsFromThirdChunk() throws Exception {\n-        VerificationMode mode = new VerificationModeBuilder().strict();\n+        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n         \n         Invocation doesntMatter = null;\n         marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n--- a/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n     public void shouldStartVerificationAndPullVerificationMode() throws Exception {\n         assertNull(mockingProgress.pullVerificationMode());\n         \n-        VerificationMode mode = VerificationMode.times(19);\n+        VerificationModeImpl mode = VerificationModeImpl.times(19);\n         \n         mockingProgress.verificationStarted(mode);\n         \n     \n     @Test\n     public void shouldCheckIfVerificationWasFinished() throws Exception {\n-        mockingProgress.verificationStarted(VerificationMode.atLeastOnce());\n+        mockingProgress.verificationStarted(VerificationModeImpl.atLeastOnce());\n         try {\n-            mockingProgress.verificationStarted(VerificationMode.atLeastOnce());\n+            mockingProgress.verificationStarted(VerificationModeImpl.atLeastOnce());\n             fail();\n         } catch (MockitoException e) {}\n     }\n--- a/test/org/mockito/internal/progress/VerificationModeBuilder.java\n+++ b/test/org/mockito/internal/progress/VerificationModeBuilder.java\n \n public class VerificationModeBuilder {\n \n-    public VerificationMode strict() {\n-        return VerificationMode.strict(null, Arrays.asList(new Object()));\n+    public VerificationModeImpl strict() {\n+        return VerificationModeImpl.strict(null, Arrays.asList(new Object()));\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationModeImpl.noMoreInteractions;\n+import static org.mockito.internal.progress.VerificationModeImpl.strict;\n+import static org.mockito.internal.progress.VerificationModeImpl.times;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class VerificationModeImplTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n+        VerificationModeImpl mode = atLeastOnce();\n+        assertTrue(mode.atLeastOnceMode());\n+        \n+        mode = times(50);\n+        assertFalse(mode.atLeastOnceMode());\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfIsMissingMethodMode() throws Exception {\n+        assertTrue(atLeastOnce().missingMethodMode());\n+        assertTrue(times(1).missingMethodMode());\n+        \n+        assertFalse(noMoreInteractions().missingMethodMode());\n+        assertFalse(times(0).missingMethodMode());\n+        assertFalse(times(2).missingMethodMode());\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfIsExactNumberOfInvocationsMode() throws Exception {\n+        assertTrue(times(0).exactNumberOfInvocationsMode());\n+        assertTrue(times(1).exactNumberOfInvocationsMode());\n+        assertTrue(times(2).exactNumberOfInvocationsMode());\n+        \n+        assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n+        assertFalse(atLeastOnce().exactNumberOfInvocationsMode());\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfWantedCountIsZero() throws Exception {\n+        assertTrue(times(0).wantedCountIsZero());\n+        \n+        assertFalse(times(1).wantedCountIsZero());\n+        assertFalse(times(2).wantedCountIsZero());\n+        assertFalse(atLeastOnce().wantedCountIsZero());\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfIsStrict() throws Exception {\n+        assertTrue(strict(1, asList(new Object())).strictMode());\n+        \n+        assertFalse(times(0).strictMode());\n+        assertFalse(times(2).strictMode());\n+        assertFalse(atLeastOnce().strictMode());\n+        assertFalse(noMoreInteractions().strictMode());\n+    }\n+    \n+    @Test\n+    public void shouldKnowIfIsAtLeastOnceMode() throws Exception {\n+        assertTrue(atLeastOnce().atLeastOnceMode());\n+        \n+        assertFalse(times(0).atLeastOnceMode());\n+        assertFalse(times(2).atLeastOnceMode());\n+        assertFalse(noMoreInteractions().atLeastOnceMode());\n+    }\n+}\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n import static java.util.Arrays.asList;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n-import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n-import static org.mockito.internal.progress.VerificationMode.noMoreInteractions;\n+import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationModeImpl.noMoreInteractions;\n \n import java.util.List;\n \n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class MissingInvocationVerifierTest extends RequiresValidState {\n \n     public void shouldAskAnalyzerForActualInvocationAndReportWantedButNotInvoked() {\n         analyzerStub.actualCountToReturn = 0;\n         analyzerStub.actualInvocationToReturn = null;\n-        verifier.verify(invocations, wanted, VerificationMode.atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertSame(invocations, analyzerStub.invocations);\n         assertSame(wanted, analyzerStub.wanted);\n         analyzerStub.actualCountToReturn = 0;\n         Invocation actualInvocation = new InvocationBuilder().toInvocation();\n         analyzerStub.actualInvocationToReturn = actualInvocation;\n-        verifier.verify(invocations, wanted, VerificationMode.atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertEquals(wanted.toString(), reporterStub.wanted);\n         assertEquals(actualInvocation.toString(), reporterStub.actual);\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NoMoreInvocationsVerifierTest extends RequiresValidState {\n \n     \n     @Test\n     public void shouldNeverVerifyWhenVerificationIsExplicit() throws Exception {\n-        verifier.verify(null, null, VerificationMode.atLeastOnce());\n+        verifier.verify(null, null, VerificationModeImpl.atLeastOnce());\n     }\n     \n     @Test\n     public void shouldPassVerification() throws Exception {\n         analyzer.invocationToReturn = null;\n-        verifier.verify(null, null, VerificationMode.noMoreInteractions());\n+        verifier.verify(null, null, VerificationModeImpl.noMoreInteractions());\n     }\n     \n     @Test\n         analyzer.invocationToReturn = firstUnverified;\n         List<Invocation> invocations = asList(new InvocationBuilder().toInvocation());\n         \n-        verifier.verify(invocations, null, VerificationMode.noMoreInteractions());\n+        verifier.verify(invocations, null, VerificationModeImpl.noMoreInteractions());\n         \n         assertSame(invocations, analyzer.invocations);\n         \n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n import static java.util.Arrays.asList;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n-import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n-import static org.mockito.internal.progress.VerificationMode.times;\n+import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n+import static org.mockito.internal.progress.VerificationModeImpl.times;\n \n import java.util.List;\n \n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsAnalyzer;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n \n     \n     @Test\n     public void shouldAskAnalyzerToCountActual() throws Exception {\n-        VerificationMode mode = times(1);\n+        VerificationModeImpl mode = times(1);\n         analyzerStub.actualCountToReturn = 1;\n         verifier.verify(invocations, wanted, mode);\n         \n     \n     @Test\n     public void shouldReportTooLittleInvocations() throws Exception {\n-        VerificationMode mode = times(10);\n+        VerificationModeImpl mode = times(10);\n         analyzerStub.actualCountToReturn = 5;\n         MockitoException lastInvocation = new MockitoException(\"\");\n         analyzerStub.invocationTraceToReturn = lastInvocation;\n     \n     @Test\n     public void shouldReportTooManyInvocations() throws Exception {\n-        VerificationMode mode = times(0);\n+        VerificationModeImpl mode = times(0);\n         analyzerStub.actualCountToReturn = 5;\n         MockitoException firstUndesiredInvocation = new MockitoException(\"\");\n         analyzerStub.invocationTraceToReturn = firstUndesiredInvocation;\n         private int actualCountToReturn;\n \n         private InvocationMatcher wanted;\n-        private VerificationMode mode;\n+        private VerificationModeImpl mode;\n         private List<Invocation> invocations;\n         @Override\n         public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n             return actualCountToReturn;\n         }\n         \n-        @Override public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        @Override public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n             this.wanted = wanted;\n             this.mode = mode;\n             return invocationTraceToReturn;\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n-import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.progress.VerificationModeBuilder;\n \n public class VerifyingRecorderTest extends RequiresValidState {\n     public void shouldMarkInvocationsAsVerified() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        VerificationMode mode = VerificationMode.atLeastOnce();\n+        VerificationModeImpl mode = VerificationModeImpl.atLeastOnce();\n         recorder.verify(differentMethod, mode);\n         \n         assertThat(markerStub.invocations, collectionHasExactlyInOrder(simpleMethod));\n     public void shouldVerify() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        VerificationMode mode = VerificationMode.atLeastOnce();\n+        VerificationModeImpl mode = VerificationModeImpl.atLeastOnce();\n         recorder.verify(differentMethod, mode);\n         \n         assertEquals(verifierStub.mode, mode);\n     public void shouldVerifyStrictly() {\n         recorder.recordInvocation(simpleMethod);\n         \n-        VerificationMode mode = new VerificationModeBuilder().strict();\n+        VerificationModeImpl mode = new VerificationModeBuilder().strict();\n         recorder.verify(differentMethod, mode);\n         \n         assertEquals(verifierStub.mode, mode);\n     \n     @Test\n     public void shouldNotMarkInvocationsAsVerifiedWhenModeIsNotExplicit() {\n-        VerificationMode mode = VerificationMode.noMoreInteractions();\n+        VerificationModeImpl mode = VerificationModeImpl.noMoreInteractions();\n         recorder.verify(mode);\n         assertNull(markerStub.mode);\n     }\n     class InvocationsMarkerStub extends InvocationsMarker {\n         private List<Invocation> invocations;\n         private InvocationMatcher wanted;\n-        private VerificationMode mode;\n-        @Override public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        private VerificationModeImpl mode;\n+        @Override public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n             this.invocations = invocations;\n             this.wanted = wanted;\n             this.mode = mode;\n     class VerifierStub implements Verifier {\n         private List<Invocation> invocations;\n         private InvocationMatcher wanted;\n-        private VerificationMode mode;\n-        public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        private VerificationModeImpl mode;\n+        public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n             this.invocations = invocations;\n             this.wanted = wanted;\n             this.mode = mode;\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.VerificationModeTest;\n+import org.mockito.internal.progress.VerificationModeImplTest;\n import org.mockito.internal.stubbing.EmptyReturnValuesTest;\n import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n import org.mockitousage.binding.BridgeMethodPuzzleTest;\n                     NumberOfInvocationsVerifierTest.class, \n                     MockingProgressImplTest.class, \n                     EmptyReturnValuesTest.class, \n-                    VerificationModeTest.class, \n+                    VerificationModeImplTest.class, \n                     InvocationTest.class, \n                     MockUtilTest.class, \n                     MockitoAssertionErrorTest.class, ", "timestamp": 1197930415, "metainfo": ""}