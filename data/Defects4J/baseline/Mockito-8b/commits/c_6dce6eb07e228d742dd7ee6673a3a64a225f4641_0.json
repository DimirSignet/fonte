{"sha": "6dce6eb07e228d742dd7ee6673a3a64a225f4641", "log": "Refactored the code to have less explicit static state", "commit": "\n--- a/src/org/mockito/internal/configuration/plugins/PluginRegistry.java\n+++ b/src/org/mockito/internal/configuration/plugins/PluginRegistry.java\n import org.mockito.plugins.PluginSwitcher;\n import org.mockito.plugins.StackTraceCleanerProvider;\n \n-/**\n- * Access to Mockito behavior that can be reconfigured by plugins\n- */\n-public class PluginRegistry {\n+class PluginRegistry {\n \n-    private static final PluginSwitcher pluginSwitcher\n+    private final PluginSwitcher pluginSwitcher\n             = new PluginLoader(new DefaultPluginSwitcher()).loadPlugin(PluginSwitcher.class, DefaultPluginSwitcher.class.getName());\n \n-    private static final MockMaker mockMaker\n+    private final MockMaker mockMaker\n             = new PluginLoader(pluginSwitcher).loadPlugin(MockMaker.class, \"org.mockito.internal.creation.cglib.CglibMockMaker\");\n \n-    private static final StackTraceCleanerProvider stackTraceCleanerProvider\n+    private final StackTraceCleanerProvider stackTraceCleanerProvider\n             = new PluginLoader(pluginSwitcher).loadPlugin(StackTraceCleanerProvider.class, \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\");\n \n     /**\n      * The implementation of the stack trace cleaner\n      */\n-    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n+    StackTraceCleanerProvider getStackTraceCleanerProvider() {\n         //TODO we should throw some sensible exception if this is null.\n         return stackTraceCleanerProvider;\n     }\n      * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n      * {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p>\n      */\n-    public static MockMaker getMockMaker() {\n+    MockMaker getMockMaker() {\n         return mockMaker;\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/plugins/Plugins.java\n+package org.mockito.internal.configuration.plugins;\n+\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.plugins.StackTraceCleanerProvider;\n+\n+/**\n+ * Access to Mockito behavior that can be reconfigured by plugins\n+ */\n+public class Plugins {\n+\n+    private static PluginRegistry registry = new PluginRegistry();\n+\n+    /**\n+     * The implementation of the stack trace cleaner\n+     */\n+    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n+        return registry.getStackTraceCleanerProvider();\n+    }\n+\n+    /**\n+     * Returns the implementation of the mock maker available for the current runtime.\n+     *\n+     * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n+     * {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p>\n+     */\n+    public static MockMaker getMockMaker() {\n+        return registry.getMockMaker();\n+    }\n+}\n--- a/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n+++ b/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n package org.mockito.internal.exceptions.stacktrace;\n \n import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n-import org.mockito.internal.configuration.ClassPathLoader;\n-import org.mockito.internal.configuration.plugins.PluginRegistry;\n+import org.mockito.internal.configuration.plugins.Plugins;\n \n import java.io.Serializable;\n import java.util.ArrayList;\n     static final long serialVersionUID = -5499819791513105700L;\n \n     private static final StackTraceCleaner CLEANER =\n-            PluginRegistry.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());\n+            Plugins.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());\n     \n     /**\n      * Example how the filter works (+/- means good/bad):\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.Mockito;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.configuration.ClassPathLoader;\n-import org.mockito.internal.configuration.plugins.PluginRegistry;\n+import org.mockito.internal.configuration.plugins.Plugins;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.handler.MockHandlerFactory;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n \n-    private static final MockMaker mockMaker = PluginRegistry.getMockMaker();\n+    private static final MockMaker mockMaker = Plugins.getMockMaker();\n \n     public boolean isTypeMockable(Class<?> type) {\n       return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());", "timestamp": 1418426971, "metainfo": ""}