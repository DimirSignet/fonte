{"sha": "f31aafb2bf62fc1374fc9557c2c832e13b51e1d9", "log": "added missing tests and some documentation  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40215", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n  */\n public class InvocationsAnalyzer {\n \n-    //TODO add missing tests\n     public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n         int actual = 0;\n-        for (Invocation registeredInvocation : invocations) {\n-            if (wanted.matches(registeredInvocation)) {\n+        for (Invocation invocation : invocations) {\n+            if (wanted.matches(invocation)) {\n                 actual++;\n             }\n         }\n \n     public Invocation findActualInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n         Invocation actualbyName = null;\n-        for (Invocation registered : invocations) {\n+        for (Invocation invocation : invocations) {\n             String wantedMethodName = wanted.getMethod().getName();\n-            String registeredInvocationName = registered.getMethod().getName();\n-            if (wantedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n-                actualbyName = registered;\n+            String currentMethodName = invocation.getMethod().getName();\n+            if (wantedMethodName.equals(currentMethodName) && !invocation.isVerified()) {\n+                actualbyName = invocation;\n+                break;\n             }\n         }\n         \n         return null;\n     }\n     \n-    public HasStackTrace findLastInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n+    public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n         Invocation lastMatching = null;\n-        for (Invocation registered : invocations) {\n-            if (wanted.matches(registered)) {\n-                lastMatching = registered;\n+        for (Invocation invocation : invocations) {\n+            if (wanted.matches(invocation)) {\n+                lastMatching = invocation;\n             }\n         }\n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n \n-    public HasStackTrace findFirstUndesiredInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n         int counter = 0;\n-        for (Invocation registered : invocations) {\n-            if (wanted.matches(registered)) {\n+        for (Invocation invocation : invocations) {\n+            if (wanted.matches(invocation)) {\n                 counter++;\n                 if (counter > mode.wantedCount()) {\n-                    return registered.getStackTrace();\n+                    return invocation.getStackTrace();\n                 }\n             }\n         }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         int wantedCount = mode.wantedCount();\n         \n         if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocation = analyzer.findLastInvocationStackTrace(invocations, wanted);\n+            HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(invocations, wanted);\n             reporter.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n-            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationStackTrace(invocations, wanted, mode);\n+            HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, wanted, mode);\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n     public InvocationBuilder differentMethod() {\n         return this.method(\"differentMethod\");\n     }\n+\n+    public InvocationBuilder otherMethod() {\n+        return this.method(\"otherMethod\");\n+    }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.*;\n import static org.junit.Assert.assertSame;\n \n import java.util.Arrays;\n     \n     @Test\n     public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n-        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n+        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n         HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test\n     public void shouldFindFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n-        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n+        HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n         HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n-        analyzer.findFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n+        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n-        analyzer.findFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n+        analyzer.findFirstUndesiredInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n+    }\n+    \n+    @Test\n+    public void shouldCountActualInvocations() throws Exception {\n+        int simpleInvocationCount = 2;\n+        assertEquals(simpleInvocationCount, analyzer.countActual(invocations, new InvocationMatcher(simpleMethodInvocation)));\n+        \n+        int differentInvocationCount = 1;\n+        assertEquals(differentInvocationCount, analyzer.countActual(invocations, new InvocationMatcher(differentMethodInvocation)));\n+    }\n+    \n+    @Test\n+    public void shouldFindActualInvocationByName() throws Exception {\n+        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        assertSame(found, simpleMethodInvocation);\n+    }\n+    \n+    @Test\n+    public void shouldFindActualUnverifiedInvocationByName() throws Exception {\n+        simpleMethodInvocation.markVerified();\n+        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        assertSame(found, simpleMethodInvocationTwo);\n+    }\n+    \n+    @Test\n+    public void shouldFindActualInvocationByGettingFirstUnverified() throws Exception {\n+        simpleMethodInvocation.markVerified();\n+        simpleMethodInvocationTwo.markVerified();\n+        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        assertSame(found, differentMethodInvocation);\n+    }\n+    \n+    @Test\n+    public void shouldNotFindActualInvocationBecauseAllAreVerified() throws Exception {\n+        simpleMethodInvocation.markVerified();\n+        simpleMethodInvocationTwo.markVerified();\n+        differentMethodInvocation.markVerified();\n+        \n+        Invocation found = analyzer.findActualInvocation(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        assertNull(found);\n+    }\n+    \n+    @Test\n+    public void shouldFindLastMatchingInvocationTrace() throws Exception {\n+        HasStackTrace found = analyzer.findLastMatchingInvocationTrace(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        assertSame(simpleMethodInvocationTwo.getStackTrace(), found);\n+        \n+        found = analyzer.findLastMatchingInvocationTrace(invocations, new InvocationMatcher(differentMethodInvocation));\n+        assertSame(differentMethodInvocation.getStackTrace(), found);\n+    }\n+    \n+    @Test\n+    public void shouldNotFindLastMatchingInvocationTrace() throws Exception {\n+        InvocationMatcher doesntMatch = new InvocationBuilder().otherMethod().toInvocationMatcher();\n+        HasStackTrace found = analyzer.findLastMatchingInvocationTrace(invocations, doesntMatch);\n+        assertNull(found);\n     }\n }\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n             return actualCountToReturn;\n         }\n         \n-        @Override public HasStackTrace findFirstUndesiredInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+        @Override public HasStackTrace findFirstUndesiredInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n             this.wanted = wanted;\n             this.mode = mode;\n             return invocationTraceToReturn;\n         }\n         \n         @Override\n-        public HasStackTrace findLastInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n+        public HasStackTrace findLastMatchingInvocationTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n             this.wanted = wanted;\n             return invocationTraceToReturn;\n         }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     String simpleMethod();\n     \n     String differentMethod();\n+    \n+    String otherMethod();\n \n     String simpleMethod(String argument);\n     ", "timestamp": 1197743232, "metainfo": ""}