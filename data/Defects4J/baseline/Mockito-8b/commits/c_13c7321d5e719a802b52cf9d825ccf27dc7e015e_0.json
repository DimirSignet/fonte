{"sha": "13c7321d5e719a802b52cf9d825ccf27dc7e015e", "log": "changes for issue 178, change to DefaultMockingDetail and a simple test", "commit": "\n--- a/src/org/mockito/MockingDetails.java\n+++ b/src/org/mockito/MockingDetails.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n+\n+import java.util.Collection;\n+\n+import org.mockito.invocation.Invocation;\n \n /**\n  * Provides mocking information.\n      *\n      * @since 1.9.5\n      */\n-    boolean isSpy();\n+    boolean isSpy();\n+    \n+    /**\n+     * Provides a collection of methods indicating the invocations of the object\n+     * @return collection of Invocation representing the invocations \n+     * for the object.\n+     *\n+     * @since 1.9.x\n+     */\n+    Collection<Invocation> getInvocations();\n }\n--- a/src/org/mockito/internal/util/DefaultMockingDetails.java\n+++ b/src/org/mockito/internal/util/DefaultMockingDetails.java\n  */\n package org.mockito.internal.util;\n \n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n import org.mockito.MockingDetails;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.invocation.Invocation;\n \n /**\n  * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n      */\n     public boolean isSpy(){\n         return delegate.isSpy( toInspect );\n+    }\n+    \n+    public Collection<Invocation> getInvocations() {\n+    \treturn delegate.getMockHandler(toInspect).getInvocationContainer().getInvocations();\n     }\n }\n \n--- /dev/null\n+++ b/test/org/mockito/MockingDetailsTest.java\n+package org.mockito;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.internal.MockitoCore;\n+import org.mockito.invocation.Invocation;\n+\n+import static org.mockito.Mockito.*;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class MockingDetailsTest {\n+\t\n+\t@Test\n+\tpublic void testGetInvocations() {\n+\t\tList<String> methodsInvoked = new ArrayList<String>() {{\n+\t\t\tadd(\"add\");\n+\t\t\tadd(\"remove\");\n+\t\t\tadd(\"clear\");\n+\t\t}};\n+\t\t\n+\t\tList<String> mockedList = (List<String>) mock(List.class);\n+\t\t\n+\t\tmockedList.add(\"one\");\n+\t\tmockedList.remove(0);\n+\t\tmockedList.clear();\n+\t\t\n+\t\tMockingDetails mockingDetails = new MockitoCore().mockingDetails(mockedList);\n+\t\tCollection<Invocation> invocations = mockingDetails.getInvocations();\n+\t\t\n+\t\tassertNotNull(invocations);\n+\t\tassertEquals(invocations.size(),3);\n+\t\tfor (Invocation method : invocations) {\n+\t\t\tassertTrue(methodsInvoked.contains(method.getMethod().getName()));\n+\t\t\tif (method.getMethod().getName().equals(\"add\")) {\n+\t\t\t\tassertEquals(method.getArguments().length,1);\n+\t\t\t\tassertEquals(method.getArguments()[0],\"one\");\n+\t\t\t}\n+\t\t}\t\n+\t}\n+}", "timestamp": 1367121123, "metainfo": ""}