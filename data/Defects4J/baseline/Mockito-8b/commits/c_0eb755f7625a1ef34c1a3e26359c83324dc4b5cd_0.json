{"sha": "0eb755f7625a1ef34c1a3e26359c83324dc4b5cd", "log": "Few Javadoc tweaks as proposed by Ivan Hristov ---------------- Few Javadoc tweaks as proposed by Ivan Hristov ---------------- Few Javadoc tweaks as proposed by Ivan Hristov", "commit": "\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n \n /**\n  * Use it to capture argument values for further assertions.\n+ *\n  * <p>\n  * Mockito verifies argument values in natural java style: by using an equals() method.\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * </code></pre>\n  *\n  * <p>\n- * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n+ * <strong>Warning:</strong> it is recommended to use ArgumentCaptor with verification <strong>but not</strong> with stubbing.\n  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n+ *\n  * <p>\n  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n  * Both techniques can be used for making sure certain arguments where passed to mocks. \n  * <li>you just need it to assert on argument values to complete verification</li>\n  * </ul>\n  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n+ *\n  * <p>\n- * This utility class <b>*don't do any type checks*</b>, the generic signatures are only there to avoid casting\n+ * This utility class <strong>*don't do any type checks*</strong>, the generic signatures are only there to avoid casting\n  * in your code. If you want specific types, then you should do that the captured values.\n  * This behavior might change (type checks could be added) in a\n  * future major release.\n+ *\n  * <p>\n- * There is an <b>annotation</b> that you might find useful: &#64;{@link Captor}\n+ * There is an <strong>annotation</strong> that you might find useful: &#64;{@link Captor}\n+ *\n  * <p>\n- * See the full documentation on Mockito in javadoc for {@link Mockito} class.    \n+ * See the full documentation on Mockito in javadoc for {@link Mockito} class.\n+ *\n+ * @see Captor\n  */\n public class ArgumentCaptor<T> {\n     \n--- a/src/org/mockito/Captor.java\n+++ b/src/org/mockito/Captor.java\n \n /**\n  * Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n+ *\n  * <p>Example:\n  * <pre class=\"code\"><code class=\"java\">\n  * public class Test{\n  *    }\n  * }\n  * </code></pre>\n+ *\n  * <p>\n  * One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n+ *\n+ * @see ArgumentCaptor\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.FIELD)\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n \n import java.lang.annotation.Documented;\n import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n \n /**\n+ * Mark a field on which injection should be performed.\n+ *\n  * <ul>\n  * <li>Allows shorthand mock and spy injection.</li>\n  * <li>Minimizes repetitive mock and spy injection.</li>\n  *     In these cases, you will have to satisfy dependencies yourself.</p></li>\n  *\n  *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n- *     then (using name if there is several property of the same type).\n+ *     then, if there is several property of the same type, by the match of the property name and the mock name.\n  *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  *\n  *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n- *     then (using name if there is several property of the same type).\n+ *     then, if there is several property of the same type, by the match of the field name and the mock name.\n  *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  * </ol>\n  *   public class ArticleManagerTest extends SampleBaseTestCase {\n  *\n  *       &#064;Mock private ArticleCalculator calculator;\n- *       &#064;Mock private ArticleDatabase database;\n+ *       &#064;Mock(name = \"database\") private ArticleDatabase dbMock; // note the mock name attribute\n  *       &#064;Spy private UserProvider userProvider = new ConsumerUserProvider();\n  *\n  *       &#064;InjectMocks private ArticleManager manager;\n  * <p>Property setter injection will happen here :</p>\n  * <pre class=\"code\"><code class=\"java\">\n  *   public class ArticleManager {\n- *       ArticleManager() {\n- *           // no-arg constructor\n- *       }\n+ *       // no-arg constructor\n+ *       ArticleManager() {  }\n  *\n- *       void setDatabase(ArticleDatabase database) {\n- *           // setter\n- *       }\n+ *       // setter\n+ *       void setDatabase(ArticleDatabase database) { }\n+ *\n+ *       // setter\n+ *       void setCalculator(ArticleCalculator calculator) { }\n  *   }\n  * </code></pre>\n  *\n  * </p>\n  *\n  * <p>\n- * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated objects.\n- * A <code>MockitoJUnitRunner</code> can also be used to initialize mocks instead of the &#64;Before approach.\n- * <p>\n- *\n- * <p>\n+ * <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.\n  * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n  * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.\n- * You can also put initMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link org.mockito.runners.MockitoJUnitRunner}\n+ * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in\n+ * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n+ *\n+ * @see Mock\n+ * @see Spy\n+ * @see MockitoAnnotations#initMocks(Object)\n+ * @see org.mockito.runners.MockitoJUnitRunner\n  */\n @Documented\n-@Target( { FIELD })\n-@Retention(RetentionPolicy.RUNTIME)\n+@Target(FIELD)\n+@Retention(RUNTIME)\n public @interface InjectMocks {}\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n  */\n package org.mockito;\n \n-import org.mockito.runners.MockitoJUnitRunner;\n-\n import java.lang.annotation.Documented;\n import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n \n /**\n+ * Mark a field as a mock.\n+ *\n  * <ul>\n  * <li>Allows shorthand mock creation.</li>\n  * <li>Minimizes repetitive mock creation code.</li>\n  *   public class ArticleManagerTest extends SampleBaseTestCase {\n  *\n  *       &#064;Mock private ArticleCalculator calculator;\n- *       &#064;Mock(name = \"dbMock\") private ArticleDatabase database;\n+ *       &#064;Mock(name = \"database\") private ArticleDatabase dbMock;\n  *       &#064;Mock(answer = RETURNS_MOCKS) private UserProvider userProvider;\n  *       &#064;Mock(extraInterfaces = {Queue.class, Observer.class}) private  articleMonitor;\n  *\n  *   }\n  * </code></pre>\n  *\n- * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated mocks.\n  * <p>\n+ * <strong><code>MockitoAnnotations.initMocks(this)</code></strong> method has to be called to initialize annotated objects.\n  * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n  * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.\n- * You can also put initMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link MockitoJUnitRunner}\n+ * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in\n+ * {@link org.mockito.runners.MockitoJUnitRunner}.\n+ * </p>\n+ *\n+ * @see Mockito#mock(Class)\n+ * @see Spy\n+ * @see InjectMocks\n+ * @see MockitoAnnotations#initMocks(Object)\n+ * @see org.mockito.runners.MockitoJUnitRunner\n  */\n-@Target( { FIELD })\n-@Retention(RetentionPolicy.RUNTIME)\n+@Target(FIELD)\n+@Retention(RUNTIME)\n @Documented\n public @interface Mock {\n \n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n package org.mockito;\n \n import java.lang.annotation.*;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n \n /**\n  * Allows shorthand wrapping of field instances in an spy object.\n  * Bar spyOnFoo = Mockito.spy(new Bar());\n  * </code></pre>\n  *\n- * <b>The field annotated with &#064;Spy can be initialized by Mockito if a zero argument constructor\n+ * <p>\n+ * <strong>The field annotated with &#064;Spy can be initialized by Mockito if a zero argument constructor\n  * can be found in the type (even private). <u>But Mockito cannot instantiate inner classes, local classes,\n- * abstract classes and interfaces.</u></b>\n+ * abstract classes and interfaces.</u></strong>\n  *\n- * <b>The field annotated with &#064;Spy can be initiatialized explicitly at declaration point.\n- * Alternatively, if you don't provide the instance Mockito will try to find zero argument constructor (even private) and create an instance for you.\n- * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></b>\n+ * <strong>The field annotated with &#064;Spy can be initialized explicitly at declaration point.\n+ * Alternatively, if you don't provide the instance Mockito will try to find zero argument constructor (even private)\n+ * and create an instance for you.\n+ * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></strong>\n  *\n  * For example this class can be instantiated by Mockito :\n  * <pre class=\"code\"><code class=\"java\">public class Bar {\n  *    public Bar(String publicConstructorWithOneArg) {}\n  * }</code></pre>\n  * </p>\n- * \n+ *\n+ * <h4>Important gotcha on spying real objects!</h4>\n+ * <ol>\n+ * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n+ * Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>\n+ * family of methods for stubbing. Example:\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   List list = new LinkedList();\n+ *   List spy = spy(list);\n+ *\n+ *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+ *   when(spy.get(0)).thenReturn(\"foo\");\n+ *\n+ *   //You have to use doReturn() for stubbing\n+ *   doReturn(\"foo\").when(spy).get(0);\n+ * </code></pre>\n+ * </li>\n+ *\n+ * <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.\n+ * So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction\n+ * and their effect on real instance state.\n+ * The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,\n+ * you won't see any effects on the real instance.</li>\n+ *\n+ * <li>Watch out for final methods.\n+ * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n+ * Also you won't be able to verify those method as well.\n+ * </li>\n+ * </ol>\n+ *\n  * <p>\n- * <b>Warning</b> if you call <code>MockitoAnnotations.initMocks(this)</code> in a\n- * super class <b>constructor</b> then this will not work. It is because fields\n+ * <strong>One last warning :</strong> if you call <code>MockitoAnnotations.initMocks(this)</code> in a\n+ * super class <strong>constructor</strong> then this will not work. It is because fields\n  * in subclass are only instantiated after super class constructor has returned.\n  * It's better to use &#64;Before.\n+ * <strong>Instead</strong> you can also put initMocks() in your JUnit runner (&#064;RunWith) or use the built-in\n+ * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n+ *\n+ * @see Mockito#spy(Object)\n+ * @see Mock\n+ * @see InjectMocks\n+ * @see MockitoAnnotations#initMocks(Object)\n+ * @see org.mockito.runners.MockitoJUnitRunner\n  */\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.FIELD)\n+@Retention(RUNTIME)\n+@Target(FIELD)\n @Documented\n-public @interface Spy {\n-}\n+public @interface Spy { }", "timestamp": 1333134599, "metainfo": ""}