{"sha": "0464f5657dc8c76a4ff209a2cf7fd6312885cdc3", "log": "fix for issue 236 : mocks are injected a bit less aggressively", "commit": "\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n import java.lang.reflect.Field;\n import java.util.Arrays;\n import java.util.Comparator;\n+import java.util.HashSet;\n import java.util.Set;\n \n /**\n             Class<?> field2Type = field2.getType();\n \n             if(field1Type.isAssignableFrom(field2Type)) {\n-                return -1;\n+                return 1;\n             }\n             if(field2Type.isAssignableFrom(field1Type)) {\n-                return 1;\n+                return -1;\n             }\n             return 0;\n         }\n     };\n \n-    // for each tested\n-    // - for each field of tested\n-    //   - find mock candidate by type\n-    //   - if more than *one* find mock candidate on name\n-    //   - if one mock candidate then set mock\n-    //   - else don't fail, user will then provide dependencies\n-    public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\n-        for (Field field : testClassFields) {\n-            Object fieldInstance = null;\n+    /**\n+     * Inject mocks in injectMocksFields, and initialize them if needed.\n+     *\n+     * <p>\n+     * <u>Algorithm :<br></u>\n+     * for each field annotated by @InjectMocks\n+     *   <ul>\n+     *   <li>copy mocks set\n+     *   <li>initialize field annotated by @InjectMocks\n+     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n+     *     <ul>\n+     *     <li>find mock candidate by type\n+     *     <li>if more than *one* candidate find mock candidate on name\n+     *     <li>if one mock candidate then\n+     *       <ul>\n+     *       <li>set mock by property setter if possible\n+     *       <li>else set mock by field injection\n+     *       </ul>\n+     *     <li>remove mock from mocks copy (mocks are just injected once)\n+     *     <li>else don't fail, user will then provide dependencies\n+     *     </ul>\n+     *   </ul>\n+     * </p>\n+     *\n+     * @param injectMocksFields Fields annotated by @InjectMocks\n+     * @param mocks Mocks\n+     * @param testClassInstance The test class instance\n+     */\n+    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n+        for (Field field : injectMocksFields) {\n+            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n+            Object injectMocksFieldInstance = null;\n             try {\n-                fieldInstance = new FieldInitializer(testClass, field).initialize();\n+                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n             } catch (MockitoException e) {\n                 new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n             }\n \n             // for each field in the class hierarchy\n-            Class<?> fieldClass = fieldInstance.getClass();\n+            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n             while (fieldClass != Object.class) {\n-                injectMockCandidate(fieldClass, mocks, fieldInstance);\n+                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n                 fieldClass = fieldClass.getSuperclass();\n             }\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n-        Arrays.sort(declaredFields, supertypesLast);\n-\n-        for(Field field : declaredFields) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+            mocks.remove(injected);\n         }\n     }\n \n+    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n+        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n+        Arrays.sort(declaredFields, supertypesLast);\n+        return declaredFields;\n+    }\n+\n }\n--- a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n             final Object matchingMock = mocks.iterator().next();\n \n             return new OngoingInjecter() {\n-                public boolean thenInject() {\n+                public Object thenInject() {\n                     try {\n                         if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\n                     } catch (Exception e) {\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                     }\n-                    return true;\n+                    return matchingMock;\n                 }\n             };\n         }\n \n         return new OngoingInjecter() {\n-            public boolean thenInject() {\n-                return false;\n+            public Object thenInject() {\n+                return null;\n             }\n         };\n \n--- a/src/org/mockito/internal/configuration/injection/OngoingInjecter.java\n+++ b/src/org/mockito/internal/configuration/injection/OngoingInjecter.java\n      * Please check the actual implementation.\n      * </p>\n      *\n-     * @return <code>true</code> if injected, <code>false</code> otherwise.\n+     * @return the mock that was injected, <code>null</code> otherwise.\n      */\n-    boolean thenInject();\n+    Object thenInject();\n \n-}\n+}\n--- a/test/org/mockitousage/bugs/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java\n+++ b/test/org/mockitousage/bugs/InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java\n package org.mockitousage.bugs;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.mockito.InjectMocks;\n @RunWith(MockitoJUnitRunner.class)\n public class InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest {\n \n+    private static final Object REFERENCE = new Object();\n+\n     @Mock private Bean mockedBean;\n+\n     @InjectMocks private Service illegalInjectionExample = new Service();\n-\n-    private Object reference = new Object();\n \n     @Test\n     public void just_for_information_fields_are_read_in_declaration_order_see_Service() {\n     }\n \n     @Test\n-    @Ignore\n-    public void test() {\n-        assertSame(reference, illegalInjectionExample.mockShouldNotGoInHere);\n+    public void mock_should_be_injected_once_and_in_the_best_matching_type() {\n+        assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);\n         assertSame(mockedBean, illegalInjectionExample.mockShouldGoInHere);\n     }\n \n-    public class Bean {}\n+    public static class Bean {}\n+    public static class Service {\n \n-    public class Service {\n-\n-        public final Object mockShouldNotGoInHere = reference;\n+        public final Object mockShouldNotGoInHere = REFERENCE;\n \n         public Bean mockShouldGoInHere;\n ", "timestamp": 1292872266, "metainfo": ""}