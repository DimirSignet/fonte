{"sha": "a0c927bdbfd0030deeb2458c71bc6da6c91e87af", "log": "fixed #11 It's not perfect, though. If a class is from signed package AND is also package protected then it's not gonna work anyway.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40604", "commit": "\n--- a/src/org/mockito/internal/creation/MockFactory.java\n+++ b/src/org/mockito/internal/creation/MockFactory.java\n import java.util.List;\n \n import net.sf.cglib.core.CollectionUtils;\n+import net.sf.cglib.core.DefaultNamingPolicy;\n+import net.sf.cglib.core.NamingPolicy;\n+import net.sf.cglib.core.Predicate;\n import net.sf.cglib.core.VisibilityPredicate;\n import net.sf.cglib.proxy.Callback;\n import net.sf.cglib.proxy.Enhancer;\n         Enhancer enhancer = createEnhancer(toMock);\n         enhancer.setCallbackType(filter.getClass());\n \n+        if (toMock.getSigners() != null) {\n+            //TODO think about a test that can cover this scenario\n+            enhancer.setNamingPolicy(ALLOWS_MOCKING_CLASSES_IN_SIGNED_PACKAGES);\n+        }\n+\n         Class mockClass = enhancer.createClass();\n+        \n         Enhancer.registerCallbacks(mockClass, new Callback[] { filter });\n \n         Factory mock = createMock(mockClass);\n         mock.getCallback(0);\n         return mock;\n     }\n+    \n+    private static final NamingPolicy ALLOWS_MOCKING_CLASSES_IN_SIGNED_PACKAGES = new DefaultNamingPolicy() {\n+        @Override\n+        public String getClassName(String prefix, String source, Object key, Predicate names) {\n+            return \"codegen.\" + super.getClassName(prefix, source, key, names);\n+        }\n+    };\n }", "timestamp": 1209310890, "metainfo": ""}