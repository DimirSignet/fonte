{"sha": "dda1c41ea0fe96abfe62bb1bfd1e1d51d2c5c509", "log": "Added reporting on answer misuse. Plus some more use cases.  --HG-- rename : src/org/mockito/internal/util/ArrayUtils.java => src/org/mockito/internal/util/collections/ArrayUtils.java", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     public int invalidArgumentIndexRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n         throw new MockitoException(\n                 join(\"Invalid argument index for the current invocation of method : \",\n-                     \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName(),\n+                     \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n                      \"\",\n                      (willReturnLastParameter ?\n                              \"Last parameter wanted\" :\n-                             \"Wanted parameter at position \" + argumentIndex) + possibleArgumentTypesOf(invocation),\n+                             \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n                      \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n                      \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n                      \"\"));\n     private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n         Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n         if (parameterTypes.length == 0) {\n-            return new StringBuilder(\" but the method has no arguments.\\n\");\n+            return new StringBuilder(\"the method has no arguments.\\n\");\n         }\n \n-        StringBuilder stringBuilder = new StringBuilder(\" but possible argument indexes for this method are :\\n\");\n+        StringBuilder stringBuilder = new StringBuilder(\"the possible argument indexes for this method are :\\n\");\n         for (int i = 0, parameterTypesLength = parameterTypes.length; i < parameterTypesLength; i++) {\n-            stringBuilder.append(\"    [\").append(i).append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n+            stringBuilder.append(\"    [\").append(i);\n+\n+            if (invocation.getMethod().isVarArgs() && i == parameterTypesLength - 1) {\n+                stringBuilder.append(\"+] \").append(parameterTypes[i].getComponentType().getSimpleName()).append(\"  <- Vararg\").append(\"\\n\");\n+            } else {\n+                stringBuilder.append(\"] \").append(parameterTypes[i].getSimpleName()).append(\"\\n\");\n+            }\n         }\n         return stringBuilder;\n     }\n \n-\n+    public void wrongTypeOfArgumentToReturn(InvocationOnMock invocation, String expectedType, Class actualType, int argumentIndex) {\n+        throw new WrongTypeOfReturnValue(join(\n+                \"The argument of type '\" + actualType.getSimpleName() + \"' cannot be returned because the following \",\n+                \"method should return the type '\" + expectedType + \"'\",\n+                \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n+                \"\",\n+                \"The reason for this error can be :\",\n+                \"1. The wanted argument position is incorrect.\",\n+                \"2. The answer is used on the wrong interaction.\",\n+                \"\",\n+                \"Position of the wanted argument is \" + argumentIndex + \" and \" + possibleArgumentTypesOf(invocation),\n+                \"***\",\n+                \"However if you're still unsure why you're getting above error read on.\",\n+                \"Due to the nature of the syntax above problem might occur because:\",\n+                \"1. This exception *might* occur in wrongly written multi-threaded tests.\",\n+                \"   Please refer to Mockito FAQ on limitations of concurrency testing.\",\n+                \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n+                \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n+                \"\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/internal/invocation/ArgumentsProcessor.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsProcessor.java\n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n+import org.mockito.internal.util.collections.ArrayUtils;\n \n import java.util.ArrayList;\n import java.util.List;\n public class ArgumentsProcessor {\n     // expands array varArgs that are given by runtime (1, [a, b]) into true\n     // varArgs (1, a, b);\n-    static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n-        if (!isVarArgs || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n+    public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n+        if (!isVarArgs || new ArrayUtils().isEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n             return args == null ? new Object[0] : args;\n         }\n \n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.answers.ReturnsIdentity;\n \n public class AnswersValidator {\n \n     private Reporter reporter = new Reporter();\n     \n-    public void validate(Answer<?> answer, Invocation theInvocation) {\n-        MethodInfo invocation = new MethodInfo(theInvocation);\n+    public void validate(Answer<?> answer, Invocation invocation) {\n+        MethodInfo methodInfo = new MethodInfo(invocation);\n         if (answer instanceof ThrowsException) {\n-            validateException((ThrowsException) answer, invocation);\n+            validateException((ThrowsException) answer, methodInfo);\n         }\n         \n         if (answer instanceof Returns) {\n-            validateReturnValue((Returns) answer, invocation);\n+            validateReturnValue((Returns) answer, methodInfo);\n         }\n         \n         if (answer instanceof DoesNothing) {\n-            validateDoNothing((DoesNothing) answer, invocation);\n+            validateDoNothing((DoesNothing) answer, methodInfo);\n         }\n         \n         if (answer instanceof CallsRealMethods) {\n-            validateMockingConcreteClass((CallsRealMethods) answer, invocation);\n+            validateMockingConcreteClass((CallsRealMethods) answer, methodInfo);\n         }\n+\n+        if (answer instanceof ReturnsIdentity) {\n+            ReturnsIdentity returnsIdentity = (ReturnsIdentity) answer;\n+            validateReturnArgIdentity(returnsIdentity, invocation);\n+        }\n+    }\n+\n+    private void validateReturnArgIdentity(ReturnsIdentity returnsIdentity, Invocation invocation) {\n+        returnsIdentity.validateIndexWithinInvocationRange(invocation);\n+\n+        MethodInfo methodInfo = new MethodInfo(invocation);\n+        if (!methodInfo.isValidReturnType(returnsIdentity.returnedTypeOnSignature(invocation))) {\n+            new Reporter().wrongTypeOfArgumentToReturn(invocation, methodInfo.printMethodReturnType(),\n+                                                       returnsIdentity.returnedTypeOnSignature(invocation),\n+                                                       returnsIdentity.wantedArgumentIndex());\n+        }\n+\n     }\n \n     private void validateMockingConcreteClass(CallsRealMethods answer, MethodInfo methodInfo) {\n--- a/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+++ b/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n     }\n \n     public boolean isValidReturnType(Class clazz) {\n-        if (method.getReturnType().isPrimitive()) {\n-            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n+        if (method.getReturnType().isPrimitive() || clazz.isPrimitive()) {\n+            return Primitives.primitiveTypeOf(clazz) == Primitives.primitiveTypeOf(method.getReturnType());\n         } else {\n             return method.getReturnType().isAssignableFrom(clazz);\n         }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.util.collections.ArrayUtils;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n import org.mockito.plugins.MockMaker;\n \n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import java.util.HashMap;\n @SuppressWarnings(\"unchecked\")\n public class Primitives {\n     \n+    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n+        if(clazz.isPrimitive()) {\n+            return clazz;\n+        }\n+        return (Class<T>) primitiveTypes.get(clazz);\n+    }\n+\n     public static boolean isPrimitiveWrapper(Class<?> type) {\n         return wrapperReturnValues.containsKey(type);\n     }\n-    \n+\n     public static <T> T primitiveWrapperOf(Class<T> type) {\n         return (T) wrapperReturnValues.get(type);\n     }\n-    \n-    public static <T> Class<T> primitiveTypeOf(Class<T> clazz) {\n-        return (Class<T>) primitiveTypes.get(clazz);\n-    }\n-    \n+\n     public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n         return (T) primitiveValues.get(primitiveType);\n     }\n-    \n+    private static Map<Class<?>, Class<?>> wrapperTypes = new HashMap<Class<?>, Class<?>>();\n+    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n     private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n-    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n     private static Map<Class<?>, Object> primitiveValues = new HashMap<Class<?>, Object>();\n-    \n+\n+    static {\n+        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n+        primitiveTypes.put(Character.class, Character.TYPE);\n+        primitiveTypes.put(Byte.class, Byte.TYPE);\n+        primitiveTypes.put(Short.class, Short.TYPE);\n+        primitiveTypes.put(Integer.class, Integer.TYPE);\n+        primitiveTypes.put(Long.class, Long.TYPE);\n+        primitiveTypes.put(Float.class, Float.TYPE);\n+        primitiveTypes.put(Double.class, Double.TYPE);\n+    }\n+\n     static {\n         wrapperReturnValues.put(Boolean.class, Boolean.FALSE);\n         wrapperReturnValues.put(Character.class, new Character((char) 0));\n         wrapperReturnValues.put(Long.class, new Long(0));\n         wrapperReturnValues.put(Float.class, new Float(0));\n         wrapperReturnValues.put(Double.class, new Double(0));\n-    }\n-    \n-    static {\n-        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n-        primitiveTypes.put(Character.class, Character.TYPE);\n-        primitiveTypes.put(Byte.class, Byte.TYPE);\n-        primitiveTypes.put(Short.class, Short.TYPE);\n-        primitiveTypes.put(Integer.class, Integer.TYPE);\n-        primitiveTypes.put(Long.class, Long.TYPE);\n-        primitiveTypes.put(Float.class, Float.TYPE);\n-        primitiveTypes.put(Double.class, Double.TYPE);\n     }\n \n     static {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/collections/ArrayUtils.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.collections;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ArrayUtils {\n+\n+    // TODO don't use typed arguments ?\n+    public Class<?>[] concat(Class<?>[] interfaces, Class<?>... clazz) {\n+        int interfacesCount = interfaces.length;\n+        int appendedCount = clazz.length;\n+        Class[] out = new Class[interfacesCount + appendedCount];\n+        System.arraycopy(interfaces, 0, out, 0, interfacesCount);\n+        System.arraycopy(clazz, 0, out, interfacesCount, appendedCount);\n+        return out;\n+    }\n+\n+    public <T> boolean isEmpty(T[] array) {\n+        return array == null || array.length == 0;\n+    }\n+\n+}\n--- a/src/org/mockito/stubbing/answers/ReturnsIdentity.java\n+++ b/src/org/mockito/stubbing/answers/ReturnsIdentity.java\n \n     public static final int LAST_ARGUMENT = -1;\n \n-    private final int argumentIndex;\n+    private final int wantedArgumentIndex;\n \n     /**\n      * Build the identity answer to return the argument at the given position in the argument array.\n      *\n-     * @param argumentIndex The position of the argument identity to return in the invocation.\n+     * @param wantedArgumentIndex The position of the argument identity to return in the invocation.\n      *                      Using <code>-1</code> indicates the last argument.\n      */\n-    public ReturnsIdentity(int argumentIndex) {\n-        this.argumentIndex = checkWithinAllowedRange(argumentIndex);\n+    public ReturnsIdentity(int wantedArgumentIndex) {\n+        this.wantedArgumentIndex = checkWithinAllowedRange(wantedArgumentIndex);\n     }\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-        return willReturnLastArg() ?\n-                lastArgumentOf(invocation) :\n+        validateIndexWithinInvocationRange(invocation);\n+        return invocation.getArguments()[actualArgumentIndex(invocation)];\n+    }\n+\n+\n+    private int actualArgumentIndex(InvocationOnMock invocation) {\n+        return returningLastArg() ?\n+                lastArgumentIndexOf(invocation) :\n                 argumentIndexOf(invocation);\n     }\n \n-    private boolean willReturnLastArg() {\n-        return argumentIndex == LAST_ARGUMENT;\n+    private boolean returningLastArg() {\n+        return wantedArgumentIndex == LAST_ARGUMENT;\n     }\n \n-    private Object argumentIndexOf(InvocationOnMock invocation) {\n-        Object[] arguments = invocation.getArguments();\n-        return arguments[checkWithinInvocationRange(invocation, argumentIndex)];\n+    private int argumentIndexOf(InvocationOnMock invocation) {\n+        return wantedArgumentIndex;\n     }\n \n-    private Object lastArgumentOf(InvocationOnMock invocation) {\n-        Object[] arguments = invocation.getArguments();\n-        return arguments[checkWithinInvocationRange(invocation, arguments.length - 1)];\n+    private int lastArgumentIndexOf(InvocationOnMock invocation) {\n+        return invocation.getArguments().length - 1;\n     }\n \n     private int checkWithinAllowedRange(int argumentIndex) {\n-        if (argumentIndex < -1) {\n+        if (argumentIndex != LAST_ARGUMENT && argumentIndex < 0) {\n             new Reporter().invalidArgumentRangeAtIdentityAnswerCreationTime();\n         }\n         return argumentIndex;\n     }\n \n-    private int checkWithinInvocationRange(InvocationOnMock invocation, int actualArgumentIndex) {\n-        if (actualArgumentIndex < 0 || invocation.getArguments().length <= actualArgumentIndex) {\n-            new Reporter().invalidArgumentIndexRangeAtInvocationTime(invocation, willReturnLastArg(), argumentIndex);\n+    public int wantedArgumentIndex() {\n+        return wantedArgumentIndex;\n+    }\n+\n+    public void validateIndexWithinInvocationRange(InvocationOnMock invocation) {\n+        if (!argumentIndexInRange(invocation)) {\n+            new Reporter().invalidArgumentIndexRangeAtInvocationTime(invocation,\n+                                                                     returningLastArg(),\n+                                                                     wantedArgumentIndex);\n+        }\n+    }\n+\n+    private boolean argumentIndexInRange(InvocationOnMock invocation) {\n+        int actualArgumentIndex = actualArgumentIndex(invocation);\n+        if (actualArgumentIndex < 0) {\n+            return false;\n+        }\n+        if (!invocation.getMethod().isVarArgs()) {\n+            return invocation.getArguments().length > actualArgumentIndex;\n+        }\n+        // for all varargs accepts positive ranges\n+        return true;\n+    }\n+\n+    public Class returnedTypeOnSignature(InvocationOnMock invocation) {\n+        int actualArgumentIndex = actualArgumentIndex(invocation);\n+\n+        if(!invocation.getMethod().isVarArgs()) {\n+            return invocation.getMethod().getParameterTypes()[actualArgumentIndex];\n         }\n \n-        return actualArgumentIndex;\n+        Class<?>[] parameterTypes = invocation.getMethod().getParameterTypes();\n+        int varargPosition = parameterTypes.length - 1;\n+\n+        if(actualArgumentIndex < varargPosition) {\n+            return parameterTypes[actualArgumentIndex];\n+        } else {\n+            return parameterTypes[varargPosition].getComponentType();\n+        }\n     }\n-\n }\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n import java.util.LinkedList;\n import java.util.List;\n \n+import static java.util.Arrays.asList;\n+\n /**\n  * Build an invocation.\n  */\n     private Object mock = Mockito.mock(IMethods.class);\n     private Method method;\n     private boolean verified;\n+    private List<Class<?>> argTypes;\n \n     /**\n      * Build the invocation\n      */\n     public Invocation toInvocation() {\n         if (method == null) {\n-            List<Class> argTypes = new LinkedList<Class>();\n-            for (Object arg : args) {\n-                if (arg == null) {\n-                    argTypes.add(Object.class);\n-                } else {\n-                    argTypes.add(arg.getClass());\n+            if (argTypes == null) {\n+                argTypes = new LinkedList<Class<?>>();\n+                for (Object arg : args) {\n+                    if (arg == null) {\n+                        argTypes.add(Object.class);\n+                    } else {\n+                        argTypes.add(arg.getClass());\n+                    }\n                 }\n             }\n-            \n+\n             try {\n                 method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n             } catch (Exception e) {\n     public InvocationBuilder differentMethod() {\n         return this.method(\"differentMethod\");\n     }\n+\n+    public InvocationBuilder argTypes(Class<?>... argTypes) {\n+        this.argTypes = asList(argTypes);\n+        return this;\n+    }\n }\n--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n+import org.mockito.internal.MockitoCore;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.invocation.Invocation;\n import org.mockito.stubbing.answers.ReturnsIdentity;\n-import org.mockitoutil.TestBase;\n \n import java.io.IOException;\n import java.nio.charset.CharacterCodingException;\n import java.util.ArrayList;\n \n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n import static org.mockito.Mockito.mock;\n \n @SuppressWarnings(\"unchecked\")\n-public class AnswersValidatorTest extends TestBase {\n+public class AnswersValidatorTest {\n \n     private AnswersValidator validator = new AnswersValidator();\n     private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n     public void should_allow_correct_type_of_return_value() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().simpleMethod().toInvocation());\n         validator.validate(new Returns(false), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n-        validator.validate(new Returns(new Boolean(true)), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n+        validator.validate(new Returns(Boolean.TRUE), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n         validator.validate(new Returns(1), new InvocationBuilder().method(\"integerReturningMethod\").toInvocation());\n         validator.validate(new Returns(1L), new InvocationBuilder().method(\"longReturningMethod\").toInvocation());\n         validator.validate(new Returns(1L), new InvocationBuilder().method(\"longObjectReturningMethod\").toInvocation());\n     @Test\n     public void should_fail_when_calling_real_method_on_interface() throws Throwable {\n         //given\n-        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        Invocation invocationOnInterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n         try {\n             //when\n-            validator.validate(new CallsRealMethods(), inovcationOnIterface);\n+            validator.validate(new CallsRealMethods(), invocationOnInterface);\n             //then\n             fail();\n         } catch (MockitoException e) {}\n         //given\n         ArrayList mock = mock(ArrayList.class);\n         mock.clear();\n-        Invocation invocationOnClass = getLastInvocation();\n+        Invocation invocationOnClass = new MockitoCore().getLastInvocation();\n         //when\n         validator.validate(new CallsRealMethods(), invocationOnClass);\n         //then no exception is thrown\n     }\n \n+    @Test\n+    public void should_allow_possible_argument_types() throws Exception {\n+        validator.validate(\n+                new ReturnsIdentity(0),\n+                new InvocationBuilder().method(\"intArgumentReturningInt\").argTypes(int.class).arg(1000).toInvocation()\n+        );\n+        validator.validate(\n+                new ReturnsIdentity(0),\n+                new InvocationBuilder().method(\"toString\").argTypes(String.class).arg(\"whatever\").toInvocation()\n+        );\n+        validator.validate(\n+                new ReturnsIdentity(2),\n+                new InvocationBuilder().method(\"varargsObject\")\n+                                       .argTypes(int.class, Object[].class)\n+                                       .args(1000, \"Object\", \"Object\")\n+                                       .toInvocation()\n+        );\n+        validator.validate(\n+                new ReturnsIdentity(1),\n+                new InvocationBuilder().method(\"threeArgumentMethod\")\n+                                       .argTypes(int.class, Object.class, String.class)\n+                                       .args(1000, \"Object\", \"String\")\n+                                       .toInvocation()\n+        );\n+    }\n+\n+    @Test\n+    public void should_fail_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {\n+        try {\n+            validator.validate(new ReturnsIdentity(30), new InvocationBuilder().method(\"oneArg\").arg(\"A\").toInvocation());\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"invalid argument index\")\n+                    .containsIgnoringCase(\"iMethods.oneArg\")\n+                    .containsIgnoringCase(\"[0] String\")\n+                    .containsIgnoringCase(\"position\")\n+                    .contains(\"30\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation() throws Throwable {\n+        try {\n+            validator.validate(\n+                    new ReturnsIdentity(ReturnsIdentity.LAST_ARGUMENT),\n+                    new InvocationBuilder().simpleMethod().toInvocation()\n+            );\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"invalid argument index\")\n+                    .containsIgnoringCase(\"iMethods.simpleMethod\")\n+                    .containsIgnoringCase(\"no arguments\")\n+                    .containsIgnoringCase(\"last parameter wanted\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type() throws Throwable {\n+        try {\n+            validator.validate(\n+                    new ReturnsIdentity(2),\n+                    new InvocationBuilder().method(\"varargsReturningString\")\n+                                           .argTypes(Object[].class)\n+                                           .args(\"anyString\", new Object(), \"anyString\")\n+                                           .toInvocation()\n+            );\n+            fail();\n+        } catch (WrongTypeOfReturnValue e) {\n+            assertThat(e.getMessage())\n+                    .containsIgnoringCase(\"argument of type\")\n+                    .containsIgnoringCase(\"Object\")\n+                    .containsIgnoringCase(\"varargsReturningString\")\n+                    .containsIgnoringCase(\"should return\")\n+                    .containsIgnoringCase(\"String\")\n+                    .containsIgnoringCase(\"possible argument indexes\");\n+        }\n+    }\n+\n }\n--- a/test/org/mockito/internal/util/ArrayUtilsTest.java\n+++ b/test/org/mockito/internal/util/ArrayUtilsTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.fest.assertions.Assertions;\n import org.junit.Test;\n+import org.mockito.internal.util.collections.ArrayUtils;\n import org.mockitoutil.TestBase;\n \n import java.io.Serializable;\n--- a/test/org/mockito/stubbing/answers/ReturnsIdentityTest.java\n+++ b/test/org/mockito/stubbing/answers/ReturnsIdentityTest.java\n package org.mockito.stubbing.answers;\n \n import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockitousage.IMethods;\n \n import java.lang.reflect.Method;\n \n         }\n     }\n \n-\t@Test\n-\tpublic void should_raise_an_exception_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {\n-        try {\n-            new ReturnsIdentity(30).answer(new InvocationBuilder().method(\"oneArg\").arg(\"A\").toInvocation());\n-            fail();\n-        } catch (Exception e) {\n-            assertThat(e.getMessage())\n-                    .containsIgnoringCase(\"invalid argument index\")\n-                    .containsIgnoringCase(\"iMethods.oneArg\")\n-                    .containsIgnoringCase(\"[0] String\")\n-                    .containsIgnoringCase(\"position\")\n-                    .contains(\"30\");\n-        }\n+\tprivate static InvocationOnMock invocationWith(final String... parameters) {\n+        return new InvocationOnMock() {\n+\n+            public Object getMock() {\n+                return null;\n+            }\n+\n+            public Method getMethod() {\n+                try {\n+                    return IMethods.class.getDeclaredMethod(\"varargsReturningString\", Object[].class);\n+                } catch (NoSuchMethodException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            public Object[] getArguments() {\n+                return parameters;\n+            }\n+\n+            public Object callRealMethod() throws Throwable {\n+                return null;\n+            }\n+        };\n     }\n \n-\t@Test\n-\tpublic void should_raise_an_exception_if_index_is_not_in_range_for_no_arg_invocation() throws Throwable {\n-        try {\n-            new ReturnsIdentity(ReturnsIdentity.LAST_ARGUMENT).answer(new InvocationBuilder().method(\"simpleMethod\").toInvocation());\n-            fail();\n-        } catch (Exception e) {\n-            assertThat(e.getMessage())\n-                    .containsIgnoringCase(\"invalid argument index\")\n-                    .containsIgnoringCase(\"iMethods.simpleMethod\")\n-                    .containsIgnoringCase(\"no arguments\")\n-                    .containsIgnoringCase(\"last parameter wanted\");\n-        }\n-    }\n-\n-\tprivate static InvocationOnMock invocationWith(final String... parameters) {\n-\t\t@SuppressWarnings(\"serial\")\n-\t\tInvocationOnMock invocation = new InvocationOnMock() {\n-\n-\t\t\tpublic Object getMock() {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tpublic Method getMethod() {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n-\t\t\tpublic Object[] getArguments() {\n-\t\t\t\treturn parameters;\n-\t\t\t}\n-\n-\t\t\tpublic Object callRealMethod() throws Throwable {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t};\n-\t\treturn invocation;\n-\t}\n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     Object varargsObject(int i, Object... object);\n     \n     int varargs(Object ... object);\n-    \n+\n+    String varargsReturningString(Object ... object);\n+\n     int varargs(String ... string);\n \n     void mixedVarargs(Object i, String ... string);\n \n     void intArgumentMethod(int i);\n \n+    int intArgumentReturningInt(int i);\n+\n     boolean equals(String str);\n \n     boolean equals();\n \n     int hashCode(String str);\n+\n+    int toIntPrimitive(Integer i);\n+\n+    Integer toIntWrapper(int i);\n }\n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n         return -1;\n     }\n \n+    public String varargsReturningString(Object... object) {\n+        return null;\n+    }\n+\n     public int varargs(String... string) {\n         return -1;\n     }\n       \n     }\n \n+    public int intArgumentReturningInt(int i) {\n+        return 0;\n+    }\n+\n     public boolean equals(String str) {\n         return false;\n     }\n     public int hashCode(String str) {\n         return 0;\n     }\n+\n+    public int toIntPrimitive(Integer i) {\n+        return 0;\n+    }\n+\n+    public Integer toIntWrapper(int i) {\n+        return null;\n+    }\n }\n--- a/test/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithAdditionalAnswers.java\n import org.mockitousage.IMethods;\n \n import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.AdditionalAnswers.returnsArgAtPosition;\n import static org.mockito.AdditionalAnswers.returnsFirstArg;\n import static org.mockito.AdditionalAnswers.returnsLastArg;\n import static org.mockito.AdditionalAnswers.returnsSecondArg;\n import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyInt;\n import static org.mockito.Matchers.anyObject;\n import static org.mockito.Matchers.anyString;\n import static org.mockito.Matchers.anyVararg;\n \n     @Test\n     public void can_return_expanded_arguments_of_invocation() throws Exception {\n-        given(iMethods.objectReturningMethod(anyVararg())).will(returnsSecondArg());\n+        given(iMethods.varargsObject(eq(1), anyVararg())).will(returnsArgAtPosition(3));\n \n-        assertThat(iMethods.objectReturningMethod(\"bob\", \"alice\", \"carl\")).isEqualTo(\"alice\");\n+        assertThat(iMethods.varargsObject(1, \"bob\", \"alexander\", \"alice\", \"carl\")).isEqualTo(\"alice\");\n+    }\n+\n+    @Test\n+    public void can_return_primitives_or_wrappers() throws Exception {\n+        given(iMethods.toIntPrimitive(anyInt())).will(returnsFirstArg());\n+        given(iMethods.toIntWrapper(anyInt())).will(returnsFirstArg());\n+\n+        assertThat(iMethods.toIntPrimitive(1)).isEqualTo(1);\n+        assertThat(iMethods.toIntWrapper(1)).isEqualTo(1);\n     }\n }", "timestamp": 1333555185, "metainfo": ""}