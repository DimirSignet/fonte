{"sha": "97194a6efa55ccaaec277fab470c076cb448c003", "log": "removed deprecation warnings javadoc fixes added package.html  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40841", "commit": "\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n  * \n  * List mock = mock(List.class);\n  * \n- * stub(mock.addAll(argThat(new IsListOfTwoElements()))).toReturn(true);\n+ * when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n  * \n  * mock.addAll(Arrays.asList(&quot;one&quot;, &quot;two&quot;));\n  * \n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  * {@link Mockito} extends Matchers so to get access to matchers just import Mockito class statically.\n  * <pre>\n  *  //stubbing using anyInt() argument matcher\n- *  stub(mockedList.get(anyInt())).toReturn(\"element\");\n+ *  when(mockedList.get(anyInt())).thenReturn(\"element\");\n  *  \n  *  //following prints \"element\"\n  *  System.out.println(mockedList.get(999));\n  *   \n  *   List mock = mock(List.class);\n  *   \n- *   stub(mock.addAll(argThat(new IsListOfTwoElements()))).toReturn(true);\n+ *   when(mock.addAll(argThat(new IsListOfTwoElements()))).thenReturn(true);\n  *   \n  *   mock.addAll(Arrays.asList(\"one\", \"two\"));\n  *   \n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * LinkedList mockedList = mock(LinkedList.class);\n  * \n  * //stubbing\n- * stub(mockedList.get(0)).toReturn(\"first\");\n- * stub(mockedList.get(1)).toThrow(new RuntimeException());\n+ * when(mockedList.get(0)).thenReturn(\"first\");\n+ * when(mockedList.get(1)).thenThrow(new RuntimeException());\n  * \n  * //following prints \"first\"\n  * System.out.println(mockedList.get(0));\n  * \n  * <pre>\n  * //stubbing using built-in anyInt() argument matcher\n- * stub(mockedList.get(anyInt())).toReturn(\"element\");\n+ * when(mockedList.get(anyInt())).thenReturn(\"element\");\n  * \n  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n- * stub(mockedList.contains(argThat(isValid()))).toReturn(\"element\");\n+ * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n  * \n  * //following prints \"element\"\n  * System.out.println(mockedList.get(999));\n  * <p>\n  * \n  * <pre>\n- * stub(mock.someMethod(\"some arg\"))\n- *   .toThrow(new RuntimeException())\n- *   .toReturn(\"foo\");\n+ * when(mock.someMethod(\"some arg\"))\n+ *   .thenThrow(new RuntimeException())\n+ *   .thenReturn(\"foo\");\n  * \n  * //First call: throws runtime exception:\n  * mock.someMethod(\"some arg\");\n  * any decent (clean & simple) code.\n  * \n  * <pre>\n- * stub(mock.someMethod(anyString())).toAnswer(new Answer() {\n+ * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n  *     Object answer(InvocationOnMock invocation) {\n  *         Object[] args = invocation.getArguments();\n  *         Object mock = invocation.getMock();\n  * \n  * <h3> 12. (**Totally New**) doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n  * \n- * Stubbing voids requires different approach from {@link Mockito#stub(Object)} because the compiler does not like void methods inside brackets...\n+ * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n  * <p>\n  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n  * The main reason is improved readability and consistency with the family of doAnswer() methods.\n  *   List spy = spy(list);\n  * \n  *   //optionally, you can stub out some methods:\n- *   stub(spy.size()).toReturn(100);\n+ *   when(spy.size()).thenReturn(100);\n  * \n  *   //using the spy calls <b>real</b> methods\n  *   spy.add(\"one\");\n  * \n  * <h4>Important gotcha on spying real objects!</h4>\n  * \n- * Sometimes it's impossible to use {@link Mockito#stub(Object)} for stubbing spies. Example:\n+ * Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n  * \n  * <pre>\n  *   List list = new LinkedList();\n  *   List spy = spy(list);\n  *   \n  *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n- *   stub(spy.get(0)).toReturn(\"foo\");\n+ *   when(spy.get(0)).thenReturn(\"foo\");\n  *   \n  *   //You have to use doReturn() for stubbing\n  *   doReturn(\"foo\").when(spy).get(0);\n      *   List spy = spy(list);\n      * \n      *   //optionally, you can stub out some methods:\n-     *   stub(spy.size()).toReturn(100);\n+     *   when(spy.size()).thenReturn(100);\n      * \n      *   //using the spy calls <b>real</b> methods\n      *   spy.add(\"one\");\n      * \n      * <h4>Important gotcha on spying real objects!</h4>\n      * \n-     * Sometimes it's impossible to use {@link Mockito#stub(Object)} for stubbing spies. Example:\n+     * Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n      * \n      * <pre>\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n      *   \n      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   stub(spy.get(0)).toReturn(\"foo\");\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n      *   \n      *   //You have to use doReturn() for stubbing\n      *   doReturn(\"foo\").when(spy).get(0);\n      * <p>\n      * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\". E.g:\n      * <p>\n-     * If you're familiar with Mockito then know that when() is a successor of {@link Mockito#stub()}\n+     * when() is a successor of {@link Mockito#stub()}\n      * \n      * <pre>\n      * when(mock.someMethod()).thenReturn(10);\n      * \n      * //you can stub with different behavior for consecutive calls.\n      * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n-     * stub(mock)\n+     * stubVoid(mock)\n      *   .toThrow(new RuntimeException())\n      *   .toReturn()\n      *   .on().someMethod();\n     /**\n      * Use doThrow() when you want to stub the void method with an exception.\n      * <p>\n-     * Stubbing voids requires different approach from {@link Mockito#stub(Object)} because the compiler does not like void methods inside brackets...\n+     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n      * <p>\n      * Example:\n      * \n     /**\n      * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n      * <p>\n-     * Stubbing voids requires different approach from {@link Mockito#stub(Object)} because the compiler does not like void methods inside brackets...\n+     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n      * <p>\n      * Example:\n      * \n     }    \n     \n     /**\n-     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#stub(Object)}.\n-     * <p>\n-     * Beware that {@link Mockito#stub(Object)} is <b>always recommended</b> for stubbing because it is argument type-safe \n+     * Use doReturn() in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n+     * <p>\n+     * Beware that {@link Mockito#when(Object)} is <b>always recommended</b> for stubbing because it is argument type-safe \n      * and more readable (especially when stubbing consecutive calls). \n      * <p>\n      * However, there are occasions when doReturn() comes handy:\n      *   List spy = spy(list);\n      *   \n      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   stub(spy.get(0)).toReturn(\"foo\");\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n      *   \n      *   //You have to use doReturn() for stubbing:\n      *   doReturn(\"foo\").when(spy).get(0);\n      * 2. Overriding a previous exception-stubbing:\n      * \n      * <pre>\n-     *   stub(mock.foo()).toThrow(new RuntimeException());\n+     *   when(mock.foo()).thenThrow(new RuntimeException());\n      *   \n      *   //Impossible: the exception-stubbed foo() method is really called so RuntimeException is thrown. \n-     *   stub(mock.foo()).toReturn(\"bar\");\n+     *   when(mock.foo()).thenReturn(\"bar\");\n      *   \n      *   //You have to use doReturn() for stubbing:\n      *   doReturn(\"bar\").when(mock).foo();\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"Unifinished stubbing detected!\",\n                 \"E.g. toReturn() may be missing.\",\n                 \"Examples of correct stubbing:\",\n-                \"    stub(mock.isOk()).toReturn(true);\",\n-                \"    stub(mock.isOk()).toThrow(exception);\",\n+                \"    when(mock.isOk()).thenReturn(true);\",\n+                \"    when(mock.isOk()).thenThrow(exception);\",\n                 \"    doThrow(exception).when(mock).someVoidMethod();\"\n         ));\n     }\n \n     public void missingMethodInvocation() {\n         throw new MissingMethodInvocationException(join(\n-                \"stub() requires an argument which has to be a method call on a mock.\",\n-                \"For example:\",\n-                \"    stub(mock.getArticles()).toReturn(articles);\"\n+                \"when() requires an argument which has to be a method call on a mock.\",\n+                \"For example:\",\n+                \"    when(mock.getArticles()).thenReturn(articles);\"\n         ));\n     }\n \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n         verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n \n-        mockingProgress.reportOngoingStubbing(new DeprecatedOngoingStubbingImpl());\n+        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n \n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n         if (answer != null) {\n         }\n     }\n \n-    //@Deprecated - remove when stub...toReturn disappears\n-    private class DeprecatedOngoingStubbingImpl implements DeprecatedOngoingStubbing<T> {\n-        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n-            return toAnswer(new Returns(value));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n-            return toAnswer(new ThrowsException(throwable));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            verifyingRecorder.eraseLastInvocation();\n-            mockitoStubber.addAnswer(answer);\n-            return new DeprecatedConsecutiveStubbing();\n-        }\n-    }\n-\n-    //@Deprecated - remove when stub...toReturn disappears\n-    private class DeprecatedConsecutiveStubbing implements DeprecatedOngoingStubbing<T> {\n-        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n-            return toAnswer(new Returns(value));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n-            return toAnswer(new ThrowsException(throwable));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            mockitoStubber.addConsecutiveAnswer(answer);\n-            return this;\n-        }\n-    }\n-    \n-    private class OngoingStubbingImpl implements NewOngoingStubbing<T> {\n+    private class OngoingStubbingImpl implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n         public NewOngoingStubbing<T> thenReturn(Object value) {\n             return thenAnswer(new Returns(value));\n         }\n             mockitoStubber.addAnswer(answer);\n             return new ConsecutiveStubbing();\n         }\n-    }\n-\n-    private class ConsecutiveStubbing implements NewOngoingStubbing<T> {\n+\n+        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n+            return toAnswer(new Returns(value));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+            return toAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+            verifyingRecorder.eraseLastInvocation();\n+            mockitoStubber.addAnswer(answer);\n+            return new ConsecutiveStubbing();\n+        }\n+    }\n+\n+    private class ConsecutiveStubbing implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n         public NewOngoingStubbing<T> thenReturn(Object value) {\n             return thenAnswer(new Returns(value));\n         }\n         }\n \n         public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+            mockitoStubber.addConsecutiveAnswer(answer);\n+            return this;\n+        }\n+        \n+        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n+            return toAnswer(new Returns(value));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+            return toAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n             mockitoStubber.addConsecutiveAnswer(answer);\n             return this;\n         }\n--- a/src/org/mockito/internal/progress/NewOngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/NewOngoingStubbing.java\n     /**\n      * Sets a generic Answer for the method. E.g:\n      * <pre>\n-     * when(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n+     * when(mock.someMethod(10)).thenAnswer(new Answer&lt;Integer&gt;() {\n      *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n      *         return (Integer) invocation.getArguments()[0];\n      *     }\n--- a/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n  *\n  * //you can stub with different behavior for consecutive method calls.\n  * //Last stubbing (e.g: toReturn()) determines the behavior for further consecutive calls.\n- * stub(mock)\n+ * stubVoid(mock)\n  *  .toThrow(new RuntimeException())\n  *  .toReturn()\n  *  .on().someMethod();\n--- a/src/org/mockito/stubbing/Answer.java\n+++ b/src/org/mockito/stubbing/Answer.java\n  * Example:\n  * \n  * <pre>\n- * stub(mock.someMethod(anyString())).toAnswer(new Answer() {\n+ * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n  *     Object answer(InvocationOnMock invocation) {\n  *         Object[] args = invocation.getArguments();\n  *         Object mock = invocation.getMock();\n--- a/test/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java\n+++ b/test/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java\n     private void performTest() throws InterruptedException {\n         mock = mock(IMethods.class);\n         \n-        stub(mock.simpleMethod(\"foo\"))\n-            .toReturn(\"foo\")\n-            .toReturn(\"bar\")\n-            .toReturn(\"baz\")\n-            .toReturn(\"foo\")\n-            .toReturn(\"bar\")\n-            .toReturn(\"baz\");\n+        when(mock.simpleMethod(\"foo\"))\n+            .thenReturn(\"foo\")\n+            .thenReturn(\"bar\")\n+            .thenReturn(\"baz\")\n+            .thenReturn(\"foo\")\n+            .thenReturn(\"bar\")\n+            .thenReturn(\"baz\");\n         \n         final Thread[] listeners = new Thread[100];\n         for (int i = 0; i < listeners.length; i++) {\n--- a/test/org/concurrentmockito/ThreadsStubSharedMockTest.java\n+++ b/test/org/concurrentmockito/ThreadsStubSharedMockTest.java\n                 @SuppressWarnings(\"deprecation\")\n                 @Override\n                 public void run() {\n-                    stub(mock.simpleMethod(getId()))\n-                        .toReturn(getId() + \"\")\n-                        .toReturn(\"foo\")\n-                        .toReturn(\"bar\");\n+                    when(mock.simpleMethod(getId()))\n+                        .thenReturn(getId() + \"\")\n+                        .thenReturn(\"foo\")\n+                        .thenReturn(\"bar\");\n                         \n                     stubVoid(mock)\n                         .toThrow(new RuntimeException(getId() + \"\"))\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n     @Test\n     public void shouldRemoveStubbableFromProgressAfterStubbing() {\n         List mock = Mockito.mock(List.class);\n-        Mockito.stub(mock.add(\"test\")).toReturn(true);\n+        Mockito.when(mock.add(\"test\")).thenReturn(true);\n         \n         assertNull(Mockito.MOCKING_PROGRESS.pullOngoingStubbing());\n     }\n--- a/test/org/mockitousage/SpyingOnRealObjectsTest.java\n+++ b/test/org/mockitousage/SpyingOnRealObjectsTest.java\n     @Test\n     public void shouldStub() {\n         spy.add(\"one\");\n-        stub(spy.get(0))\n-            .toReturn(\"1\")\n-            .toReturn(\"1 again\");\n+        when(spy.get(0))\n+            .thenReturn(\"1\")\n+            .thenReturn(\"1 again\");\n                \n         assertEquals(\"1\", spy.get(0));\n         assertEquals(\"1 again\", spy.get(0));\n     \n     @Test\n     public void shouldAllowOverridingStubs() {\n-        stub(spy.contains(anyObject())).toReturn(true);\n-        stub(spy.contains(\"foo\")).toReturn(false);\n+        when(spy.contains(anyObject())).thenReturn(true);\n+        when(spy.contains(\"foo\")).thenReturn(false);\n         \n         assertTrue(spy.contains(\"bar\"));\n         assertFalse(spy.contains(\"foo\"));\n--- a/test/org/mockitousage/UsingVarargsTest.java\n+++ b/test/org/mockitousage/UsingVarargsTest.java\n     @SuppressWarnings(\"deprecation\")\n     @Test\n     public void shouldStubStringVarargs() {\n-        stub(mock.withStringVarargsReturningString(1)).toReturn(\"1\");\n-        stub(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).toReturn(\"2\");\n+        when(mock.withStringVarargsReturningString(1)).thenReturn(\"1\");\n+        when(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).thenReturn(\"2\");\n         \n         RuntimeException expected = new RuntimeException();\n         stubVoid(mock).toThrow(expected).on().withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n     \n     @Test\n     public void shouldStubBooleanVarargs() {\n-        stub(mock.withBooleanVarargs(1)).toReturn(true);\n-        stub(mock.withBooleanVarargs(1, true, false)).toReturn(true);\n+        when(mock.withBooleanVarargs(1)).thenReturn(true);\n+        when(mock.withBooleanVarargs(1, true, false)).thenReturn(true);\n         \n         assertEquals(true, mock.withBooleanVarargs(1));\n         assertEquals(false, mock.withBooleanVarargs(9999));\n--- a/test/org/mockitousage/examples/use/ExampleTest.java\n+++ b/test/org/mockitousage/examples/use/ExampleTest.java\n \n     @Test\n     public void managerCountsArticlesAndSavesThemInTheDatabase() {\n-        stub(mockCalculator.countArticles(\"Guardian\")).toReturn(12);\n-        stub(mockCalculator.countArticlesInPolish(anyString())).toReturn(5);\n+        when(mockCalculator.countArticles(\"Guardian\")).thenReturn(12);\n+        when(mockCalculator.countArticlesInPolish(anyString())).thenReturn(5);\n \n         articleManager.updateArticleCounters(\"Guardian\");\n         \n         Article articleTwo = new Article();\n         Article articleThree = new Article();\n         \n-        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).toReturn(1);\n-        stub(mockCalculator.countNumberOfRelatedArticles(articleTwo)).toReturn(12);\n-        stub(mockCalculator.countNumberOfRelatedArticles(articleThree)).toReturn(0);\n+        when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);\n+        when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);\n+        when(mockCalculator.countNumberOfRelatedArticles(articleThree)).thenReturn(0);\n         \n-        stub(mockDatabase.getArticlesFor(\"Guardian\")).toReturn(Arrays.asList(articleOne, articleTwo, articleThree)); \n+        when(mockDatabase.getArticlesFor(\"Guardian\")).thenReturn(Arrays.asList(articleOne, articleTwo, articleThree)); \n         \n         articleManager.updateRelatedArticlesCounters(\"Guardian\");\n \n         Article articleOne = new Article();\n         Article articleTwo = new Article();\n         \n-        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).toReturn(1);\n-        stub(mockCalculator.countNumberOfRelatedArticles(articleTwo)).toReturn(12);\n+        when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);\n+        when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);\n         \n-        stub(mockDatabase.getArticlesFor(\"Guardian\")).toReturn(Arrays.asList(articleOne, articleTwo)); \n+        when(mockDatabase.getArticlesFor(\"Guardian\")).thenReturn(Arrays.asList(articleOne, articleTwo)); \n         \n         articleManager.updateRelatedArticlesCounters(\"Guardian\");\n \n--- a/test/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java\n+++ b/test/org/mockitousage/matchers/AnyXMatchersAcceptNullsTest.java\n \n     @Test\n     public void shouldAnyXMatchersAcceptNull() {\n-        stub(mock.oneArg(anyObject())).toReturn(\"0\");\n-        stub(mock.oneArg(anyString())).toReturn(\"1\");\n-        stub(mock.forList(anyList())).toReturn(\"2\");\n-        stub(mock.forMap(anyMap())).toReturn(\"3\");\n-        stub(mock.forCollection(anyCollection())).toReturn(\"4\");\n+        when(mock.oneArg(anyObject())).thenReturn(\"0\");\n+        when(mock.oneArg(anyString())).thenReturn(\"1\");\n+        when(mock.forList(anyList())).thenReturn(\"2\");\n+        when(mock.forMap(anyMap())).thenReturn(\"3\");\n+        when(mock.forCollection(anyCollection())).thenReturn(\"4\");\n         \n         assertEquals(\"0\", mock.oneArg((Object) null));\n         assertEquals(\"1\", mock.oneArg((String) null));\n     \n     @Test\n     public void shouldAnyPrimiteWraperMatchersAcceptNull() {\n-        stub(mock.forInteger(anyInt())).toReturn(\"0\");\n-        stub(mock.forCharacter(anyChar())).toReturn(\"1\");\n-        stub(mock.forShort(anyShort())).toReturn(\"2\");\n-        stub(mock.forByte(anyByte())).toReturn(\"3\");\n-        stub(mock.forBoolean(anyBoolean())).toReturn(\"4\");\n-        stub(mock.forLong(anyLong())).toReturn(\"5\");\n-        stub(mock.forFloat(anyFloat())).toReturn(\"6\");\n-        stub(mock.forDouble(anyDouble())).toReturn(\"7\");\n+        when(mock.forInteger(anyInt())).thenReturn(\"0\");\n+        when(mock.forCharacter(anyChar())).thenReturn(\"1\");\n+        when(mock.forShort(anyShort())).thenReturn(\"2\");\n+        when(mock.forByte(anyByte())).thenReturn(\"3\");\n+        when(mock.forBoolean(anyBoolean())).thenReturn(\"4\");\n+        when(mock.forLong(anyLong())).thenReturn(\"5\");\n+        when(mock.forFloat(anyFloat())).thenReturn(\"6\");\n+        when(mock.forDouble(anyDouble())).thenReturn(\"7\");\n         \n         assertEquals(\"0\", mock.forInteger(null));\n         assertEquals(\"1\", mock.forCharacter(null));\n--- a/test/org/mockitousage/matchers/CustomMatchersTest.java\n+++ b/test/org/mockitousage/matchers/CustomMatchersTest.java\n \n     @Test\n     public void shouldUseCustomBooleanMatcher() {\n-        stub(mock.oneArg(booleanThat(new IsAnyBoolean()))).toReturn(\"foo\");\n+        when(mock.oneArg(booleanThat(new IsAnyBoolean()))).thenReturn(\"foo\");\n         \n         assertEquals(\"foo\", mock.oneArg(true));\n         assertEquals(\"foo\", mock.oneArg(false));\n     \n     @Test\n     public void shouldUseCustomCharMatcher() {\n-        stub(mock.oneArg(charThat(new IsSorZ()))).toReturn(\"foo\");\n+        when(mock.oneArg(charThat(new IsSorZ()))).thenReturn(\"foo\");\n       \n         assertEquals(\"foo\", mock.oneArg('s'));\n         assertEquals(\"foo\", mock.oneArg('z'));\n     \n     @Test\n     public void shouldUseCustomPrimitiveNumberMatchers() {\n-        stub(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).toReturn(\"byte\");\n-        stub(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).toReturn(\"short\");\n-        stub(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).toReturn(\"int\");\n-        stub(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).toReturn(\"long\");\n-        stub(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).toReturn(\"float\");\n-        stub(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).toReturn(\"double\");\n+        when(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).thenReturn(\"byte\");\n+        when(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).thenReturn(\"short\");\n+        when(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).thenReturn(\"int\");\n+        when(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).thenReturn(\"long\");\n+        when(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).thenReturn(\"float\");\n+        when(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).thenReturn(\"double\");\n         \n         assertEquals(\"byte\", mock.oneArg((byte) 0));\n         assertEquals(\"short\", mock.oneArg((short) 1));\n          \n     @Test\n     public void shouldUseCustomObjectMatcher() {\n-        stub(mock.oneArg(argThat(new ContainsFoo()))).toReturn(\"foo\");\n+        when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn(\"foo\");\n         \n         assertEquals(\"foo\", mock.oneArg(\"foo\"));\n         assertEquals(null, mock.oneArg(\"bar\"));\n--- a/test/org/mockitousage/matchers/GenericMatchersTest.java\n+++ b/test/org/mockitousage/matchers/GenericMatchersTest.java\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     public void shouldCompile() {\n-        stub(sorter.convertDate(new Date())).toReturn(\"one\");\n-        stub(sorter.convertDate((Date) anyObject())).toReturn(\"two\");\n+        when(sorter.convertDate(new Date())).thenReturn(\"one\");\n+        when(sorter.convertDate((Date) anyObject())).thenReturn(\"two\");\n \n         //following requires warning suppression but allows setting anyList()\n-        stub(sorter.sort(anyList())).toReturn(null);\n+        when(sorter.sort(anyList())).thenReturn(null);\n     }\n }\n--- a/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n+++ b/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n \n     @Test\n     public void shouldAcceptHamcrestMatcher() {\n-        stub(mock.simpleMethod(argThat(new ContainsX()))).toReturn(\"X\");\n+        when(mock.simpleMethod(argThat(new ContainsX()))).thenReturn(\"X\");\n         assertNull(mock.simpleMethod(\"blah\"));\n         assertEquals(\"X\", mock.simpleMethod(\"blah X blah\"));\n     }\n--- a/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n \n     @Test\n     public void shouldDetectWrongNumberOfMatchersWhenStubbing() {\n-        Mockito.stub(mock.threeArgumentMethod(1, \"2\", \"3\")).toReturn(null);\n+        Mockito.when(mock.threeArgumentMethod(1, \"2\", \"3\")).thenReturn(null);\n         try {\n-            Mockito.stub(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).toReturn(null);\n+            Mockito.when(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).thenReturn(null);\n             fail();\n         } catch (InvalidUseOfMatchersException e) {}\n     }\n--- a/test/org/mockitousage/matchers/MatchersTest.java\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n \n     @Test\n     public void andOverloaded() {\n-        stub(mock.oneArg(and(eq(false), eq(false)))).toReturn(\"0\");\n-        stub(mock.oneArg(and(eq((byte) 1), eq((byte) 1)))).toReturn(\"1\");\n-        stub(mock.oneArg(and(eq('a'), eq('a')))).toReturn(\"2\");\n-        stub(mock.oneArg(and(eq((double) 1), eq((double) 1)))).toReturn(\"3\");\n-        stub(mock.oneArg(and(eq((float) 1), eq((float) 1)))).toReturn(\"4\");\n-        stub(mock.oneArg(and(eq((int) 1), eq((int) 1)))).toReturn(\"5\");\n-        stub(mock.oneArg(and(eq((long) 1), eq((long) 1)))).toReturn(\"6\");\n-        stub(mock.oneArg(and(eq((short) 1), eq((short) 1)))).toReturn(\"7\");\n-        stub(mock.oneArg(and(Matchers.contains(\"a\"), Matchers.contains(\"d\")))).toReturn(\"8\");\n-        stub(mock.oneArg(and(isA(Class.class), eq(Object.class)))).toReturn(\"9\");\n+        when(mock.oneArg(and(eq(false), eq(false)))).thenReturn(\"0\");\n+        when(mock.oneArg(and(eq((byte) 1), eq((byte) 1)))).thenReturn(\"1\");\n+        when(mock.oneArg(and(eq('a'), eq('a')))).thenReturn(\"2\");\n+        when(mock.oneArg(and(eq((double) 1), eq((double) 1)))).thenReturn(\"3\");\n+        when(mock.oneArg(and(eq((float) 1), eq((float) 1)))).thenReturn(\"4\");\n+        when(mock.oneArg(and(eq((int) 1), eq((int) 1)))).thenReturn(\"5\");\n+        when(mock.oneArg(and(eq((long) 1), eq((long) 1)))).thenReturn(\"6\");\n+        when(mock.oneArg(and(eq((short) 1), eq((short) 1)))).thenReturn(\"7\");\n+        when(mock.oneArg(and(Matchers.contains(\"a\"), Matchers.contains(\"d\")))).thenReturn(\"8\");\n+        when(mock.oneArg(and(isA(Class.class), eq(Object.class)))).thenReturn(\"9\");\n \n         assertEquals(\"0\", mock.oneArg(false));\n         assertEquals(null, mock.oneArg(true));\n     \n     @Test\n     public void orOverloaded() {\n-        stub(mock.oneArg(or(eq(false), eq(true)))).toReturn(\"0\");\n-        stub(mock.oneArg(or(eq((byte) 1), eq((byte) 2)))).toReturn(\"1\");\n-        stub(mock.oneArg(or(eq((char) 1), eq((char) 2)))).toReturn(\"2\");\n-        stub(mock.oneArg(or(eq((double) 1), eq((double) 2)))).toReturn(\"3\");\n-        stub(mock.oneArg(or(eq((float) 1), eq((float) 2)))).toReturn(\"4\");\n-        stub(mock.oneArg(or(eq((int) 1), eq((int) 2)))).toReturn(\"5\");\n-        stub(mock.oneArg(or(eq((long) 1), eq((long) 2)))).toReturn(\"6\");\n-        stub(mock.oneArg(or(eq((short) 1), eq((short) 2)))).toReturn(\"7\");\n-        stub(mock.oneArg(or(eq(\"asd\"), eq(\"jkl\")))).toReturn(\"8\");\n-        stub(mock.oneArg(or(eq(this.getClass()), eq(Object.class)))).toReturn(\"9\");\n+        when(mock.oneArg(or(eq(false), eq(true)))).thenReturn(\"0\");\n+        when(mock.oneArg(or(eq((byte) 1), eq((byte) 2)))).thenReturn(\"1\");\n+        when(mock.oneArg(or(eq((char) 1), eq((char) 2)))).thenReturn(\"2\");\n+        when(mock.oneArg(or(eq((double) 1), eq((double) 2)))).thenReturn(\"3\");\n+        when(mock.oneArg(or(eq((float) 1), eq((float) 2)))).thenReturn(\"4\");\n+        when(mock.oneArg(or(eq((int) 1), eq((int) 2)))).thenReturn(\"5\");\n+        when(mock.oneArg(or(eq((long) 1), eq((long) 2)))).thenReturn(\"6\");\n+        when(mock.oneArg(or(eq((short) 1), eq((short) 2)))).thenReturn(\"7\");\n+        when(mock.oneArg(or(eq(\"asd\"), eq(\"jkl\")))).thenReturn(\"8\");\n+        when(mock.oneArg(or(eq(this.getClass()), eq(Object.class)))).thenReturn(\"9\");\n \n         assertEquals(\"0\", mock.oneArg(true));\n         assertEquals(\"0\", mock.oneArg(false));\n \n     @Test\n     public void notOverloaded() {\n-        stub(mock.oneArg(not(eq(false)))).toReturn(\"0\");\n-        stub(mock.oneArg(not(eq((byte) 1)))).toReturn(\"1\");\n-        stub(mock.oneArg(not(eq('a')))).toReturn(\"2\");\n-        stub(mock.oneArg(not(eq((double) 1)))).toReturn(\"3\");\n-        stub(mock.oneArg(not(eq((float) 1)))).toReturn(\"4\");\n-        stub(mock.oneArg(not(eq((int) 1)))).toReturn(\"5\");\n-        stub(mock.oneArg(not(eq((long) 1)))).toReturn(\"6\");\n-        stub(mock.oneArg(not(eq((short) 1)))).toReturn(\"7\");\n-        stub(mock.oneArg(not(Matchers.contains(\"a\")))).toReturn(\"8\");\n-        stub(mock.oneArg(not(isA(Class.class)))).toReturn(\"9\");\n+        when(mock.oneArg(not(eq(false)))).thenReturn(\"0\");\n+        when(mock.oneArg(not(eq((byte) 1)))).thenReturn(\"1\");\n+        when(mock.oneArg(not(eq('a')))).thenReturn(\"2\");\n+        when(mock.oneArg(not(eq((double) 1)))).thenReturn(\"3\");\n+        when(mock.oneArg(not(eq((float) 1)))).thenReturn(\"4\");\n+        when(mock.oneArg(not(eq((int) 1)))).thenReturn(\"5\");\n+        when(mock.oneArg(not(eq((long) 1)))).thenReturn(\"6\");\n+        when(mock.oneArg(not(eq((short) 1)))).thenReturn(\"7\");\n+        when(mock.oneArg(not(Matchers.contains(\"a\")))).thenReturn(\"8\");\n+        when(mock.oneArg(not(isA(Class.class)))).thenReturn(\"9\");\n \n         assertEquals(\"0\", mock.oneArg(true));\n         assertEquals(null, mock.oneArg(false));\n \n     @Test\n     public void lessOrEqualOverloaded() {\n-        stub(mock.oneArg(leq((byte) 1))).toReturn(\"1\");\n-        stub(mock.oneArg(leq((double) 1))).toReturn(\"3\");\n-        stub(mock.oneArg(leq((float) 1))).toReturn(\"4\");\n-        stub(mock.oneArg(leq((int) 1))).toReturn(\"5\");\n-        stub(mock.oneArg(leq((long) 1))).toReturn(\"6\");\n-        stub(mock.oneArg(leq((short) 1))).toReturn(\"7\");\n-        stub(mock.oneArg(leq(new BigDecimal(\"1\")))).toReturn(\"8\");\n+        when(mock.oneArg(leq((byte) 1))).thenReturn(\"1\");\n+        when(mock.oneArg(leq((double) 1))).thenReturn(\"3\");\n+        when(mock.oneArg(leq((float) 1))).thenReturn(\"4\");\n+        when(mock.oneArg(leq((int) 1))).thenReturn(\"5\");\n+        when(mock.oneArg(leq((long) 1))).thenReturn(\"6\");\n+        when(mock.oneArg(leq((short) 1))).thenReturn(\"7\");\n+        when(mock.oneArg(leq(new BigDecimal(\"1\")))).thenReturn(\"8\");\n \n         assertEquals(\"1\", mock.oneArg((byte) 1));\n         assertEquals(null, mock.oneArg((byte) 2));\n \n     @Test\n     public void lessThanOverloaded() {\n-        stub(mock.oneArg(lt((byte) 1))).toReturn(\"1\");\n-        stub(mock.oneArg(lt((double) 1))).toReturn(\"3\");\n-        stub(mock.oneArg(lt((float) 1))).toReturn(\"4\");\n-        stub(mock.oneArg(lt((int) 1))).toReturn(\"5\");\n-        stub(mock.oneArg(lt((long) 1))).toReturn(\"6\");\n-        stub(mock.oneArg(lt((short) 1))).toReturn(\"7\");\n-        stub(mock.oneArg(lt(new BigDecimal(\"1\")))).toReturn(\"8\");\n+        when(mock.oneArg(lt((byte) 1))).thenReturn(\"1\");\n+        when(mock.oneArg(lt((double) 1))).thenReturn(\"3\");\n+        when(mock.oneArg(lt((float) 1))).thenReturn(\"4\");\n+        when(mock.oneArg(lt((int) 1))).thenReturn(\"5\");\n+        when(mock.oneArg(lt((long) 1))).thenReturn(\"6\");\n+        when(mock.oneArg(lt((short) 1))).thenReturn(\"7\");\n+        when(mock.oneArg(lt(new BigDecimal(\"1\")))).thenReturn(\"8\");\n \n         assertEquals(\"1\", mock.oneArg((byte) 0));\n         assertEquals(null, mock.oneArg((byte) 1));\n \n     @Test\n     public void greaterOrEqualMatcherOverloaded() {\n-        stub(mock.oneArg(geq((byte) 1))).toReturn(\"1\");\n-        stub(mock.oneArg(geq((double) 1))).toReturn(\"3\");\n-        stub(mock.oneArg(geq((float) 1))).toReturn(\"4\");\n-        stub(mock.oneArg(geq((int) 1))).toReturn(\"5\");\n-        stub(mock.oneArg(geq((long) 1))).toReturn(\"6\");\n-        stub(mock.oneArg(geq((short) 1))).toReturn(\"7\");\n-        stub(mock.oneArg(geq(new BigDecimal(\"1\")))).toReturn(\"8\");\n+        when(mock.oneArg(geq((byte) 1))).thenReturn(\"1\");\n+        when(mock.oneArg(geq((double) 1))).thenReturn(\"3\");\n+        when(mock.oneArg(geq((float) 1))).thenReturn(\"4\");\n+        when(mock.oneArg(geq((int) 1))).thenReturn(\"5\");\n+        when(mock.oneArg(geq((long) 1))).thenReturn(\"6\");\n+        when(mock.oneArg(geq((short) 1))).thenReturn(\"7\");\n+        when(mock.oneArg(geq(new BigDecimal(\"1\")))).thenReturn(\"8\");\n \n         assertEquals(\"1\", mock.oneArg((byte) 2));\n         assertEquals(null, mock.oneArg((byte) 0));\n \n     @Test\n     public void greaterThanMatcherOverloaded() {\n-        stub(mock.oneArg(gt((byte) 1))).toReturn(\"1\");\n-        stub(mock.oneArg(gt((double) 1))).toReturn(\"3\");\n-        stub(mock.oneArg(gt((float) 1))).toReturn(\"4\");\n-        stub(mock.oneArg(gt((int) 1))).toReturn(\"5\");\n-        stub(mock.oneArg(gt((long) 1))).toReturn(\"6\");\n-        stub(mock.oneArg(gt((short) 1))).toReturn(\"7\");\n-        stub(mock.oneArg(gt(new BigDecimal(\"1\")))).toReturn(\"8\");\n+        when(mock.oneArg(gt((byte) 1))).thenReturn(\"1\");\n+        when(mock.oneArg(gt((double) 1))).thenReturn(\"3\");\n+        when(mock.oneArg(gt((float) 1))).thenReturn(\"4\");\n+        when(mock.oneArg(gt((int) 1))).thenReturn(\"5\");\n+        when(mock.oneArg(gt((long) 1))).thenReturn(\"6\");\n+        when(mock.oneArg(gt((short) 1))).thenReturn(\"7\");\n+        when(mock.oneArg(gt(new BigDecimal(\"1\")))).thenReturn(\"8\");\n \n         assertEquals(\"1\", mock.oneArg((byte) 2));\n         assertEquals(null, mock.oneArg((byte) 1));\n \n     @Test\n     public void compareToMatcher() {\n-        stub(mock.oneArg(cmpEq(new BigDecimal(\"1.5\")))).toReturn(\"0\");\n+        when(mock.oneArg(cmpEq(new BigDecimal(\"1.5\")))).thenReturn(\"0\");\n \n         assertEquals(\"0\", mock.oneArg(new BigDecimal(\"1.50\")));\n         assertEquals(null, mock.oneArg(new BigDecimal(\"1.51\")));\n     \n     @Test\n     public void anyStringMatcher() {\n-        stub(mock.oneArg(anyString())).toReturn(\"1\");\n+        when(mock.oneArg(anyString())).thenReturn(\"1\");\n         \n         assertEquals(\"1\", mock.oneArg(\"\"));\n         assertEquals(\"1\", mock.oneArg(\"any string\"));\n \n     @Test\n     public void anyMatcher() {\n-        stub(mock.oneArg(anyBoolean())).toReturn(\"0\");\n-        stub(mock.oneArg(anyByte())).toReturn(\"1\");\n-        stub(mock.oneArg(anyChar())).toReturn(\"2\");\n-        stub(mock.oneArg(anyDouble())).toReturn(\"3\");\n-        stub(mock.oneArg(anyFloat())).toReturn(\"4\");\n-        stub(mock.oneArg(anyInt())).toReturn(\"5\");\n-        stub(mock.oneArg(anyLong())).toReturn(\"6\");\n-        stub(mock.oneArg(anyShort())).toReturn(\"7\");\n-        stub(mock.oneArg((String) anyObject())).toReturn(\"8\");\n-        stub(mock.oneArg(anyObject())).toReturn(\"9\");\n+        when(mock.oneArg(anyBoolean())).thenReturn(\"0\");\n+        when(mock.oneArg(anyByte())).thenReturn(\"1\");\n+        when(mock.oneArg(anyChar())).thenReturn(\"2\");\n+        when(mock.oneArg(anyDouble())).thenReturn(\"3\");\n+        when(mock.oneArg(anyFloat())).thenReturn(\"4\");\n+        when(mock.oneArg(anyInt())).thenReturn(\"5\");\n+        when(mock.oneArg(anyLong())).thenReturn(\"6\");\n+        when(mock.oneArg(anyShort())).thenReturn(\"7\");\n+        when(mock.oneArg((String) anyObject())).thenReturn(\"8\");\n+        when(mock.oneArg(anyObject())).thenReturn(\"9\");\n         \n         assertEquals(\"0\", mock.oneArg(true));\n         assertEquals(\"0\", mock.oneArg(false));\n     @Test\n     public void shouldArrayEqualsDealWithNullArray() throws Exception {\n         Object[] nullArray = null;\n-        stub(mock.oneArray(aryEq(nullArray))).toReturn(\"null\");\n+        when(mock.oneArray(aryEq(nullArray))).thenReturn(\"null\");\n \n         assertEquals(\"null\", mock.oneArray(nullArray));\n \n \n     @Test\n     public void arrayEqualsMatcher() {\n-        stub(mock.oneArray(aryEq(new boolean[] { true, false, false }))).toReturn(\"0\");\n-        stub(mock.oneArray(aryEq(new byte[] { 1 }))).toReturn(\"1\");\n-        stub(mock.oneArray(aryEq(new char[] { 1 }))).toReturn(\"2\");\n-        stub(mock.oneArray(aryEq(new double[] { 1 }))).toReturn(\"3\");\n-        stub(mock.oneArray(aryEq(new float[] { 1 }))).toReturn(\"4\");\n-        stub(mock.oneArray(aryEq(new int[] { 1 }))).toReturn(\"5\");\n-        stub(mock.oneArray(aryEq(new long[] { 1 }))).toReturn(\"6\");\n-        stub(mock.oneArray(aryEq(new short[] { 1 }))).toReturn(\"7\");\n-        stub(mock.oneArray(aryEq(new String[] { \"Test\" }))).toReturn(\"8\");\n-        stub(mock.oneArray(aryEq(new Object[] { \"Test\", new Integer(4) }))).toReturn(\"9\");\n+        when(mock.oneArray(aryEq(new boolean[] { true, false, false }))).thenReturn(\"0\");\n+        when(mock.oneArray(aryEq(new byte[] { 1 }))).thenReturn(\"1\");\n+        when(mock.oneArray(aryEq(new char[] { 1 }))).thenReturn(\"2\");\n+        when(mock.oneArray(aryEq(new double[] { 1 }))).thenReturn(\"3\");\n+        when(mock.oneArray(aryEq(new float[] { 1 }))).thenReturn(\"4\");\n+        when(mock.oneArray(aryEq(new int[] { 1 }))).thenReturn(\"5\");\n+        when(mock.oneArray(aryEq(new long[] { 1 }))).thenReturn(\"6\");\n+        when(mock.oneArray(aryEq(new short[] { 1 }))).thenReturn(\"7\");\n+        when(mock.oneArray(aryEq(new String[] { \"Test\" }))).thenReturn(\"8\");\n+        when(mock.oneArray(aryEq(new Object[] { \"Test\", new Integer(4) }))).thenReturn(\"9\");\n \n         assertEquals(\"0\", mock.oneArray(new boolean[] { true, false, false }));\n         assertEquals(\"1\", mock.oneArray(new byte[] { 1 }));\n \n     @Test\n     public void greaterOrEqualMatcher() {\n-        stub(mock.oneArg(geq(7))).toReturn(\">= 7\");\n-        stub(mock.oneArg(lt(7))).toReturn(\"< 7\");\n+        when(mock.oneArg(geq(7))).thenReturn(\">= 7\");\n+        when(mock.oneArg(lt(7))).thenReturn(\"< 7\");\n \n         assertEquals(\">= 7\", mock.oneArg(7));\n         assertEquals(\">= 7\", mock.oneArg(8));\n \n     @Test\n     public void greaterThanMatcher() {\n-        stub(mock.oneArg(gt(7))).toReturn(\"> 7\");\n-        stub(mock.oneArg(leq(7))).toReturn(\"<= 7\");\n+        when(mock.oneArg(gt(7))).thenReturn(\"> 7\");\n+        when(mock.oneArg(leq(7))).thenReturn(\"<= 7\");\n \n         assertEquals(\"> 7\", mock.oneArg(8));\n         assertEquals(\"> 7\", mock.oneArg(9));\n \n     @Test\n     public void lessOrEqualMatcher() {\n-        stub(mock.oneArg(leq(7))).toReturn(\"<= 7\");\n-        stub(mock.oneArg(gt(7))).toReturn(\"> 7\");\n+        when(mock.oneArg(leq(7))).thenReturn(\"<= 7\");\n+        when(mock.oneArg(gt(7))).thenReturn(\"> 7\");\n \n         assertEquals(\"<= 7\", mock.oneArg(7));\n         assertEquals(\"<= 7\", mock.oneArg(6));\n \n     @Test\n     public void lessThanMatcher() {\n-        stub(mock.oneArg(lt(7))).toReturn(\"< 7\");\n-        stub(mock.oneArg(geq(7))).toReturn(\">= 7\");\n+        when(mock.oneArg(lt(7))).thenReturn(\"< 7\");\n+        when(mock.oneArg(geq(7))).thenReturn(\">= 7\");\n \n         assertEquals(\"< 7\", mock.oneArg(5));\n         assertEquals(\"< 7\", mock.oneArg(6));\n \n     @Test\n     public void orMatcher() {\n-        stub(mock.oneArg(anyInt())).toReturn(\"other\");\n-        stub(mock.oneArg(or(eq(7), eq(9)))).toReturn(\"7 or 9\");\n+        when(mock.oneArg(anyInt())).thenReturn(\"other\");\n+        when(mock.oneArg(or(eq(7), eq(9)))).thenReturn(\"7 or 9\");\n \n         assertEquals(\"other\", mock.oneArg(10));\n         assertEquals(\"7 or 9\", mock.oneArg(7));\n \n     @Test\n     public void nullMatcher() {\n-        stub(mock.threeArgumentMethod(eq(1), isNull(), eq(\"\"))).toReturn(\"1\");\n-        stub(mock.threeArgumentMethod(eq(1), not(isNull()), eq(\"\"))).toReturn(\"2\");\n+        when(mock.threeArgumentMethod(eq(1), isNull(), eq(\"\"))).thenReturn(\"1\");\n+        when(mock.threeArgumentMethod(eq(1), not(isNull()), eq(\"\"))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.threeArgumentMethod(1, null, \"\"));\n         assertEquals(\"2\", mock.threeArgumentMethod(1, new Object(), \"\"));\n \n     @Test\n     public void notNullMatcher() {\n-        stub(mock.threeArgumentMethod(eq(1), notNull(), eq(\"\"))).toReturn(\"1\");\n-        stub(mock.threeArgumentMethod(eq(1), not(isNotNull()), eq(\"\"))).toReturn(\"2\");\n+        when(mock.threeArgumentMethod(eq(1), notNull(), eq(\"\"))).thenReturn(\"1\");\n+        when(mock.threeArgumentMethod(eq(1), not(isNotNull()), eq(\"\"))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.threeArgumentMethod(1, new Object(), \"\"));\n         assertEquals(\"2\", mock.threeArgumentMethod(1, null, \"\"));\n \n     @Test\n     public void findMatcher() {\n-        stub(mock.oneArg(find(\"([a-z]+)\\\\d\"))).toReturn(\"1\");\n+        when(mock.oneArg(find(\"([a-z]+)\\\\d\"))).thenReturn(\"1\");\n \n         assertEquals(\"1\", mock.oneArg(\"ab12\"));\n         assertEquals(null, mock.oneArg(\"12345\"));\n \n     @Test\n     public void matchesMatcher() {\n-        stub(mock.oneArg(matches(\"[a-z]+\\\\d\\\\d\"))).toReturn(\"1\");\n-        stub(mock.oneArg(matches(\"\\\\d\\\\d\\\\d\"))).toReturn(\"2\");\n+        when(mock.oneArg(matches(\"[a-z]+\\\\d\\\\d\"))).thenReturn(\"1\");\n+        when(mock.oneArg(matches(\"\\\\d\\\\d\\\\d\"))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(\"a12\"));\n         assertEquals(\"2\", mock.oneArg(\"131\"));\n \n     @Test\n     public void containsMatcher() {\n-        stub(mock.oneArg(Matchers.contains(\"ell\"))).toReturn(\"1\");\n-        stub(mock.oneArg(Matchers.contains(\"ld\"))).toReturn(\"2\");\n+        when(mock.oneArg(Matchers.contains(\"ell\"))).thenReturn(\"1\");\n+        when(mock.oneArg(Matchers.contains(\"ld\"))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(\"hello\"));\n         assertEquals(\"2\", mock.oneArg(\"world\"));\n \n     @Test\n     public void startsWithMatcher() {\n-        stub(mock.oneArg(startsWith(\"ab\"))).toReturn(\"1\");\n-        stub(mock.oneArg(startsWith(\"bc\"))).toReturn(\"2\");\n+        when(mock.oneArg(startsWith(\"ab\"))).thenReturn(\"1\");\n+        when(mock.oneArg(startsWith(\"bc\"))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(\"ab quake\"));\n         assertEquals(\"2\", mock.oneArg(\"bc quake\"));\n \n     @Test\n     public void endsWithMatcher() {\n-        stub(mock.oneArg(Matchers.endsWith(\"ab\"))).toReturn(\"1\");\n-        stub(mock.oneArg(Matchers.endsWith(\"bc\"))).toReturn(\"2\");\n+        when(mock.oneArg(Matchers.endsWith(\"ab\"))).thenReturn(\"1\");\n+        when(mock.oneArg(Matchers.endsWith(\"bc\"))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(\"xab\"));\n         assertEquals(\"2\", mock.oneArg(\"xbc\"));\n \n     @Test\n     public void deltaMatcher() {\n-        stub(mock.oneArg(eq(1.0D, 0.1D))).toReturn(\"1\");\n-        stub(mock.oneArg(eq(2.0D, 0.1D))).toReturn(\"2\");\n-        stub(mock.oneArg(eq(1.0F, 0.1F))).toReturn(\"3\");\n-        stub(mock.oneArg(eq(2.0F, 0.1F))).toReturn(\"4\");\n-        stub(mock.oneArg(eq(2.0F, 0.1F))).toReturn(\"4\");\n+        when(mock.oneArg(eq(1.0D, 0.1D))).thenReturn(\"1\");\n+        when(mock.oneArg(eq(2.0D, 0.1D))).thenReturn(\"2\");\n+        when(mock.oneArg(eq(1.0F, 0.1F))).thenReturn(\"3\");\n+        when(mock.oneArg(eq(2.0F, 0.1F))).thenReturn(\"4\");\n+        when(mock.oneArg(eq(2.0F, 0.1F))).thenReturn(\"4\");\n \n         assertEquals(\"1\", mock.oneArg(1.0));\n         assertEquals(\"1\", mock.oneArg(0.91));\n         assertEquals(one, two);\n         assertEquals(two, three);\n \n-        stub(mock.oneArg(same(one))).toReturn(\"1\");\n-        stub(mock.oneArg(same(two))).toReturn(\"2\");\n+        when(mock.oneArg(same(one))).thenReturn(\"1\");\n+        when(mock.oneArg(same(two))).thenReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(one));\n         assertEquals(\"2\", mock.oneArg(two));\n--- a/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n+++ b/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n     \n     @Test\n     public void shouldStubUsingMatchers() {\n-        stub(one.simpleMethod(2)).toReturn(\"2\");\n-        stub(two.simpleMethod(anyString())).toReturn(\"any\");\n-        stub(three.simpleMethod(startsWith(\"test\"))).toThrow(new RuntimeException());\n+        when(one.simpleMethod(2)).thenReturn(\"2\");\n+        when(two.simpleMethod(anyString())).thenReturn(\"any\");\n+        when(three.simpleMethod(startsWith(\"test\"))).thenThrow(new RuntimeException());\n \n         assertEquals(null, one.simpleMethod(1));\n         assertEquals(\"2\", one.simpleMethod(2));\n     @Test\n     public void shouldVerifyUsingMatchers() {\n         stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);\n-        stub(three.varargsObject(5, \"first arg\", \"second arg\")).toReturn(\"stubbed\");\n+        when(three.varargsObject(5, \"first arg\", \"second arg\")).thenReturn(\"stubbed\");\n \n         try {\n             one.oneArg(true);\n--- a/test/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java\n+++ b/test/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java\n \n //        verify(mock).varargs(\"test\", anyString());\n \n-//        stub(\"x\").toReturn(\"x\");\n+//        when(\"x\").thenReturn(\"x\");\n \n-//        stub(mock.simpleMethod());\n-//        stub(mock.differentMethod()).toReturn(\"\");\n+//        when(mock.simpleMethod());\n+//        when(mock.differentMethod()).thenReturn(\"\");\n     } \n     \n     @Test(expected=NotAMockException.class)\n--- a/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n     \n     @Test\n     public void shouldDetectUnfinishedStubbing() {\n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnMethodCallOnMock(), UnfinishedStubbingException.class);\n \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnStub(), UnfinishedStubbingException.class);\n         \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnStubVoid(), UnfinishedStubbingException.class);\n         \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnVerify(), UnfinishedStubbingException.class);\n         \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnVerifyInOrder(), UnfinishedStubbingException.class);\n         \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);\n         \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);\n \n-        stub(mock.simpleMethod());\n+        when(mock.simpleMethod());\n         detects(new OnDoAnswer(), UnfinishedStubbingException.class);\n     }\n     \n     \n     private static class OnStub implements DetectsInvalidState {\n         public void detect(IMethods mock) {\n-            stub(mock);\n+            when(mock);\n         }\n     }\n     \n--- a/test/org/mockitousage/misuse/InvalidUsageTest.java\n+++ b/test/org/mockitousage/misuse/InvalidUsageTest.java\n     \n     @Test(expected=MissingMethodInvocationException.class)\n     public void shouldReportMissingMethodInvocationWhenStubbing() {\n-        stub(mock.simpleMethod()).toReturn(\"this stubbing is required to make sure Stubbable is pulled\");\n-        stub(\"\".toString()).toReturn(\"x\");\n+        when(mock.simpleMethod()).thenReturn(\"this stubbing is required to make sure Stubbable is pulled\");\n+        when(\"\".toString()).thenReturn(\"x\");\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n-        stub(mock.simpleMethod()).toThrow(new Exception());\n+        when(mock.simpleMethod()).thenThrow(new Exception());\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowable() throws Exception {\n-        stub(mock.simpleMethod()).toThrow(null);\n+        when(mock.simpleMethod()).thenThrow(null);\n     }    \n     \n     final class FinalClass {}\n--- a/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n+++ b/test/org/mockitousage/stacktrace/StackTraceFilteringTest.java\n     @Test\n     public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler() {\n         try {\n-            stub(mock.oneArg(true)).toThrow(new Exception());\n+            when(mock.oneArg(true)).thenThrow(new Exception());\n             fail();\n         } catch (MockitoException expected) {\n             assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromMockHandler\"));\n     \n     @Test\n     public void shouldShowProperExceptionStackTrace() throws Exception {\n-        stub(mock.simpleMethod()).toThrow(new RuntimeException());\n+        when(mock.simpleMethod()).thenThrow(new RuntimeException());\n \n         try {\n             mock.simpleMethod();\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n     \n     @Test\n     public void shouldEvaluateLatestStubbingFirst() throws Exception {\n-        stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);\n-        stub(mock.objectReturningMethod(200)).toReturn(200);\n+        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n+        when(mock.objectReturningMethod(200)).thenReturn(200);\n         \n         assertEquals(200, mock.objectReturningMethod(200));\n         assertEquals(100, mock.objectReturningMethod(666));\n     \n     @Test\n     public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n-        stub(mock.booleanReturningMethod()).toReturn(true);\n+        when(mock.booleanReturningMethod()).thenReturn(true);\n         \n         mock.booleanReturningMethod();\n         \n         \n         List<Sub> subs = null;\n         //can I somehow avoid a cast here:\n-        stub(mockTwo.getList()).toReturn((List) subs);\n+        when(mockTwo.getList()).thenReturn((List) subs);\n     }\n     \n     @Test\n     public void shouldAllowStubbingToString() throws Exception {\n         IMethods mockTwo = mock(IMethods.class);\n-        stub(mockTwo.toString()).toReturn(\"test\");\n+        when(mockTwo.toString()).thenReturn(\"test\");\n         \n         assertThat(mock.toString(), contains(\"Mock for IMethods\"));\n         assertEquals(\"test\", mockTwo.toString());\n     @SuppressWarnings(\"deprecation\")\n     @Test\n     public void shouldStubbingWithThrowableFailVerification() {\n-        stub(mock.simpleMethod(\"one\")).toThrow(new RuntimeException());\n+        when(mock.simpleMethod(\"one\")).thenThrow(new RuntimeException());\n         stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod(\"two\");\n         \n         verifyZeroInteractions(mock);\n--- a/test/org/mockitousage/stubbing/StubbingConsecutiveReturnValuesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingConsecutiveReturnValuesTest.java\n    \n     @Test\n     public void shouldReturnConsecutiveValues() throws Exception {\n-        stub(mock.simpleMethod())\n-            .toReturn(\"one\")\n-            .toReturn(\"two\")\n-            .toReturn(\"three\");\n+        when(mock.simpleMethod())\n+            .thenReturn(\"one\")\n+            .thenReturn(\"two\")\n+            .thenReturn(\"three\");\n         \n         assertEquals(\"one\", mock.simpleMethod());\n         assertEquals(\"two\", mock.simpleMethod());\n     \n     @Test\n     public void shouldThrowConsecutively() throws Exception {\n-        stub(mock.simpleMethod())\n-            .toThrow(new RuntimeException())\n-            .toThrow(new IllegalArgumentException())\n-            .toThrow(new NullPointerException());\n+        when(mock.simpleMethod())\n+            .thenThrow(new RuntimeException())\n+            .thenThrow(new IllegalArgumentException())\n+            .thenThrow(new NullPointerException());\n \n         try {\n             mock.simpleMethod();\n     \n     @Test\n     public void shouldMixConsecutiveReturnsWithExcepions() throws Exception {\n-        stub(mock.simpleMethod())\n-            .toThrow(new IllegalArgumentException())\n-            .toReturn(\"one\")\n-            .toThrow(new NullPointerException())\n-            .toReturn(null);\n+        when(mock.simpleMethod())\n+            .thenThrow(new IllegalArgumentException())\n+            .thenReturn(\"one\")\n+            .thenThrow(new NullPointerException())\n+            .thenReturn(null);\n         \n         try {\n             mock.simpleMethod();\n     \n     @Test(expected=MockitoException.class)\n     public void shouldValidateConsecutiveException() throws Exception {\n-        stub(mock.simpleMethod())\n-            .toReturn(\"one\")\n-            .toThrow(new Exception());\n+        when(mock.simpleMethod())\n+            .thenReturn(\"one\")\n+            .thenThrow(new Exception());\n     }\n     \n     @Test\n--- a/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n \n     @Test\n     public void shouldAnswer() throws Exception {\n-        stub(mock.simpleMethod(anyString())).toAnswer(new Answer<String>() {\n+        when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {\n             public String answer(InvocationOnMock invocation) throws Throwable {\n                 String arg = (String) invocation.getArguments()[0];\n \n \n     @Test\n     public void shouldAnswerConsecutively() throws Exception {\n-        stub(mock.simpleMethod())\n-                .toAnswer(new Answer<String>() {\n+        when(mock.simpleMethod())\n+                .thenAnswer(new Answer<String>() {\n                     public String answer(InvocationOnMock invocation) throws Throwable {\n                         return invocation.getMethod().getName();\n                     }\n                 })\n-                .toReturn(\"Hello\")\n-                .toAnswer(new Answer<String>() {\n+                .thenReturn(\"Hello\")\n+                .thenAnswer(new Answer<String>() {\n                     public String answer(InvocationOnMock invocation) throws Throwable {\n                         return invocation.getMethod().getName() + \"-1\";\n                     }\n--- a/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n     @Test\n     public void shouldStubWithThrowable() throws Exception {\n         IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n-        stub(mock.add(\"throw\")).toThrow(expected);\n+        when(mock.add(\"throw\")).thenThrow(expected);\n         \n         try {\n             mock.add(\"throw\");\n     \n     @Test\n     public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {\n-        stub(mock.get(1)).toThrow(new ExceptionOne());\n-        \n-        try {\n-            stub(mock.get(1)).toThrow(new ExceptionTwo());\n+        when(mock.get(1)).thenThrow(new ExceptionOne());\n+        \n+        try {\n+            when(mock.get(1)).thenThrow(new ExceptionTwo());\n             fail();\n         } catch (ExceptionOne e) {}\n     }   \n         Reader reader = mock(Reader.class);\n         IOException ioException = new IOException();\n         \n-        stub(reader.read()).toThrow(ioException);\n+        when(reader.read()).thenThrow(ioException);\n         \n         try {\n             reader.read();\n     public void shouldAllowSettingError() throws Exception {\n         Error error = new Error();\n         \n-        stub(mock.add(\"quake\")).toThrow(error);\n+        when(mock.add(\"quake\")).thenThrow(error);\n         \n         try {\n             mock.add(\"quake\");\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n-        stub(mock.add(\"monkey island\")).toThrow(new Exception());\n+        when(mock.add(\"monkey island\")).thenThrow(new Exception());\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowable() throws Exception {\n-        stub(mock.add(\"monkey island\")).toThrow(null);\n+        when(mock.add(\"monkey island\")).thenThrow(null);\n     }    \n     \n     @Test\n     public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n-        stub(mock.add(\"ExceptionOne\")).toThrow(new ExceptionOne());\n-        stub(mock.getLast()).toReturn(\"last\");\n+        when(mock.add(\"ExceptionOne\")).thenThrow(new ExceptionOne());\n+        when(mock.getLast()).thenReturn(\"last\");\n         stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();\n         \n         stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();\n-        stub(mockTwo.containsValue(\"ExceptionFour\")).toThrow(new ExceptionFour());\n-        stub(mockTwo.get(\"Are you there?\")).toReturn(\"Yes!\");\n+        when(mockTwo.containsValue(\"ExceptionFour\")).thenThrow(new ExceptionFour());\n+        when(mockTwo.get(\"Are you there?\")).thenReturn(\"Yes!\");\n \n         assertNull(mockTwo.get(\"foo\"));\n         assertTrue(mockTwo.keySet().isEmpty());\n     \n     @Test\n     public void shouldStubbingWithThrowableBeVerifiable() {\n-        stub(mock.size()).toThrow(new RuntimeException());\n+        when(mock.size()).thenThrow(new RuntimeException());\n         stubVoid(mock).toThrow(new RuntimeException()).on().clone();\n         \n         try {\n     \n     @Test\n     public void shouldStubbingWithThrowableFailVerification() {\n-        stub(mock.size()).toThrow(new RuntimeException());\n+        when(mock.size()).thenThrow(new RuntimeException());\n         stubVoid(mock).toThrow(new RuntimeException()).on().clone();\n         \n         verifyZeroInteractions(mock);\n--- a/test/org/mockitousage/verification/BasicVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n \n     @Test\n     public void shouldVerifyStubbedMethods() throws Exception {\n-        stub(mock.add(\"test\")).toReturn(Boolean.FALSE);\n+        when(mock.add(\"test\")).thenReturn(Boolean.FALSE);\n         \n         mock.add(\"test\");\n         \n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n \n     @Test\n     public void shouldNotCountInStubbedInvocations() throws Exception {\n-        stub(mock.add(\"test\")).toReturn(false);\n-        stub(mock.add(\"test\")).toReturn(true);\n+        when(mock.add(\"test\")).thenReturn(false);\n+        when(mock.add(\"test\")).thenReturn(true);\n \n         mock.add(\"test\");\n         mock.add(\"test\");\n--- a/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n \n     @Test\n     public void shouldStubbingNotRegisterRedundantInteractions() throws Exception {\n-        stub(mock.add(\"one\")).toReturn(true);\n-        stub(mock.add(\"two\")).toReturn(true);\n+        when(mock.add(\"one\")).thenReturn(true);\n+        when(mock.add(\"two\")).thenReturn(true);\n \n         mock.add(\"one\");\n         ", "timestamp": 1220038263, "metainfo": ""}