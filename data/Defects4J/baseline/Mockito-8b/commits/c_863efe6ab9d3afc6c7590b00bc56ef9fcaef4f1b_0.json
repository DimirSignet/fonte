{"sha": "863efe6ab9d3afc6c7590b00bc56ef9fcaef4f1b", "log": "mean check-in coz I was off-line some refactorings/rename jobs around added javadocs about SmartNulls  --HG-- rename : src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java => src/org/junit/mockito/ExperimentalMockitoJUnitRunner.java rename : src/org/mockito/internal/progress/EmptyReturnValues.java => src/org/mockito/internal/progress/HandyReturnValues.java rename : test/org/mockito/runners/ExperimentalMockitoJUnitRunnerTest.java => test/org/junit/mockito/ExperimentalMockitoJUnitRunnerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401136", "commit": "\n--- /dev/null\n+++ b/src/org/junit/mockito/ExperimentalMockitoJUnitRunner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.junit.mockito;\n+\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.BlockJUnit4ClassRunner;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+/**\n+ * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n+ * <p>\n+ * Does what {@link MockitoJUnitRunner} does plus warns when stubbing\n+ * TODO copy-paste stuff from web here  \n+ */\n+public class ExperimentalMockitoJUnitRunner extends MockitoJUnitRunner {\n+\n+    private final MockitoLogger logger;\n+    \n+    public ExperimentalMockitoJUnitRunner(Class<?> klass) throws InitializationError {\n+        this(klass, new MockitoLoggerImpl());\n+    }\n+    \n+    public ExperimentalMockitoJUnitRunner(Class<?> klass, MockitoLogger logger) throws InitializationError {\n+        super(klass);\n+        this.logger = logger;\n+    }\n+    \n+    //this is what is really executed when the test runs\n+    static interface JunitTestBody {\n+        void run(RunNotifier notifier);\n+    }\n+    \n+    @Override\n+    public void run(RunNotifier notifier) {\n+        this.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                ExperimentalMockitoJUnitRunner.super.run(notifier);\n+            }\n+        });\n+    }\n+    \n+    public void run(RunNotifier notifier, JunitTestBody junitTestBody) {\n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n+        \n+        beforeRun(notifier, debuggingInfo);\n+        \n+        junitTestBody.run(notifier);\n+        \n+        afterRun(debuggingInfo);\n+    }\n+\n+    private void afterRun(final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.clearData();\n+    }\n+\n+    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.collectData();\n+\n+        RunListener listener = new RunListener() {\n+            @Override public void testFailure(Failure failure) throws Exception {\n+                debuggingInfo.printWarnings(logger);\n+            }\n+        };\n+        \n+        notifier.addListener(listener);\n+    }\n+}\n--- a/src/org/mockito/AdditionalMatchers.java\n+++ b/src/org/mockito/AdditionalMatchers.java\n import org.mockito.internal.matchers.GreaterThan;\n import org.mockito.internal.matchers.LessOrEqual;\n import org.mockito.internal.matchers.LessThan;\n-import org.mockito.internal.progress.EmptyReturnValues;\n+import org.mockito.internal.progress.HandyReturnValues;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n \n         return reportMatcher(new EqualsWithDelta(value, delta)).returnZero();\n     }\n     \n-    private static EmptyReturnValues reportMatcher(ArgumentMatcher<?> matcher) {\n+    private static HandyReturnValues reportMatcher(ArgumentMatcher<?> matcher) {\n         return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n     }\n }\n--- a/src/org/mockito/DefaultMockitoConfiguration.java\n+++ b/src/org/mockito/DefaultMockitoConfiguration.java\n \n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.configuration.ReturnValues;\n-import org.mockito.internal.configuration.DefaultReturnValues;\n+import org.mockito.internal.returnvalues.EmptyReturnValues;\n \n //TODO javadocs\n //TODO test\n public class DefaultMockitoConfiguration implements IMockitoConfiguration {\n \n     public ReturnValues getReturnValues() {\n-        return new DefaultReturnValues();\n+        return new EmptyReturnValues();\n     }\n }\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n import org.mockito.internal.matchers.Same;\n import org.mockito.internal.matchers.StartsWith;\n import org.mockito.internal.matchers.apachecommons.ReflectionEquals;\n-import org.mockito.internal.progress.EmptyReturnValues;\n+import org.mockito.internal.progress.HandyReturnValues;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n \n         return reportMatcher(matcher).returnZero();\n     }\n \n-    private static EmptyReturnValues reportMatcher(Matcher<?> matcher) {\n+    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n         return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n     }\n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n import java.util.Arrays;\n \n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.configuration.ReturnValues;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n+import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n+import org.mockito.internal.returnvalues.MoreEmptyReturnValues;\n import org.mockito.internal.returnvalues.SmartNullReturnValues;\n-import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.Returns;\n import org.mockito.internal.stubbing.Stubber;\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n-    //TODO the name of this constant may change\n-    public static final ReturnValues USING_GLOBAL_CONFIG = new GloballyConfiguredReturnValues();\n-    //TODO the name of this constant may change\n-    public static final ReturnValues SMART_NULLS = new SmartNullReturnValues();\n+    /**\n+     * Default ReturnValues used by the framework.\n+     * <p>\n+     * {@link ReturnValues} defines the return values of unstubbed calls. \n+     * <p>\n+     * This implementation first tries the global configuration (see {@link IMockitoConfiguration}). \n+     * If there is no global configuration then it uses {@link HandyReturnValues} (returns zeros, empty collections, nulls, etc.)\n+     */\n+    public static final ReturnValues RETURNS_DEFAULTS = new GloballyConfiguredReturnValues();\n+    \n+    /**\n+     * Optional ReturnValues to be used with {@link Mockito#mock(Class, ReturnValues)}\n+     * <p>\n+     * {@link ReturnValues} defines the return values of unstubbed calls.\n+     * <p>\n+     * This implementation can be helpful when working with legacy code.\n+     * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n+     * This implementation of ReturnValues makes unstubbed methods <b>return SmartNulls instead of nulls</b>.\n+     * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\n+     * <p>\n+     * SmartNullReturnValues first tries to return ordinary return values (see {@link MoreEmptyReturnValues})\n+     * then it tries to return SmartNull. If the return type is final then plain null is returned.\n+     * <p>\n+     * SmartNullReturnValues will be probably the default return values strategy in Mockito 2.0 \n+     */\n+    public static final ReturnValues RETURNS_SMART_NULLS = new SmartNullReturnValues();\n     \n     static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n     private static final Reporter REPORTER = new Reporter();\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return mock(classToMock, null, null, USING_GLOBAL_CONFIG);\n+        return mock(classToMock, null, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, String name) {\n-        return mock(classToMock, name, null, USING_GLOBAL_CONFIG);\n+        return mock(classToMock, name, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n     }\n     \n     private static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n+        //TODO test\n+        GlobalConfiguration.init();\n         MOCKING_PROGRESS.validateState();\n         MOCKING_PROGRESS.resetOngoingStubbing();\n         return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n      * @return a spy of the real object\n      */\n     public static <T> T spy(T object) {\n-        return mock((Class<T>) object.getClass(), null, object, USING_GLOBAL_CONFIG);\n+        return mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n     }\n \n     /**\n--- a/src/org/mockito/configuration/IMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/IMockitoConfiguration.java\n package org.mockito.configuration;\n \n //TODO javadocs\n-//TODO test\n+//TODO move to org.mockito for consistency\n+/**\n+ * Use it to configure Mockito.\n+ * <p>\n+ * To configure Mockito globally create exactly org.mockito.MockitoConfiguration class that implements this interface.\n+ * <p>\n+ * This is completely <b>optional</b> - nothing happens if there isn't any org.mockito.MockitoConfiguration class.\n+ */\n public interface IMockitoConfiguration {\n \n     ReturnValues getReturnValues();\n--- a/src/org/mockito/configuration/experimental/ConfigurationSupport.java\n+++ b/src/org/mockito/configuration/experimental/ConfigurationSupport.java\n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.configuration.ReturnValues;\n import org.mockito.internal.configuration.Configuration;\n-import org.mockito.internal.configuration.DefaultReturnValues;\n import org.mockito.internal.configuration.MockitoConfiguration;\n+import org.mockito.internal.returnvalues.EmptyReturnValues;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n @SuppressWarnings(\"deprecation\")\n public class ConfigurationSupport {\n     \n-    private static final ReturnValues DEFAULT_RETURN_VALUES = new DefaultReturnValues();\n+    private static final ReturnValues DEFAULT_RETURN_VALUES = new EmptyReturnValues();\n     \n     /**\n      * this is what Mockito returns by default for given invocation \n--- /dev/null\n+++ b/src/org/mockito/exceptions/misusing/MockitoConfigurationException.java\n+package org.mockito.exceptions.misusing;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class MockitoConfigurationException extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public MockitoConfigurationException(String message) {\n+        super(message);\n+    }\n+\n+    public MockitoConfigurationException(String message, Exception cause) {\n+        super(message, cause);\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n package org.mockito.internal.configuration;\n \n import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.exceptions.misusing.MockitoConfigurationException;\n \n public class GlobalConfiguration {\n     \n     private static IMockitoConfiguration globalConfiguration;\n-    private static boolean loaded = false;\n+    private static boolean initialized = false;\n \n-    static {\n-        //TODO how bad is it? What happens if some exception is thrown?\n-        if (!loaded) {\n-            globalConfiguration = readFromClasspath();\n-            loaded = true;\n-        }\n-    }\n-    \n     @SuppressWarnings(\"unchecked\")\n     private static IMockitoConfiguration readFromClasspath() {\n         //Trying to get config from classpath\n         try {\n             return (IMockitoConfiguration) configClass.newInstance();\n         } catch (ClassCastException e) {\n-            throw new RuntimeException(\"MockitoConfiguration class should implement org.mockito.configuration.IMockitoConfiguration interface.\");\n+            throw new MockitoConfigurationException(\"\\n\" +\n+                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n         } catch (Exception e) {\n-            throw new RuntimeException(\"Unable to instantianate MockitoConfiguration class. Does it have a public, no-arg constructor?\", e);\n+            throw new MockitoConfigurationException(\"\\n\" +\n+                    \"Unable to instantianate org.mockito.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n         }\n     }\n \n     public static IMockitoConfiguration getConfig() {\n+        if (!initialized) {\n+            //TODO check email of mockito group\n+            throw new IllegalStateException(\"Something went wrong. GlobalConfiguration should be initialised by now.\\n\" +\n+                \"Please report issue at http://mockito.org or write an email to mockito@googlegroups.com\");\n+        }\n         return globalConfiguration;\n     }\n+\n+    public static void init() {\n+        if (!initialized) {\n+            globalConfiguration = readFromClasspath();\n+            initialized = true;\n+        }\n+    }\n }\n--- a/src/org/mockito/internal/debugging/WarningsPrinter.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinter.java\n             logger.log(join(\n                 \"[Mockito] Warning - this method was not stubbed:\",\n                 i,\n-                \"Click here:\",\n                 i.getInvocation().getStackTrace().getStackTrace()[0],\n                 \"\"));\n         }\n             logger.log(join(\n                 \"[Mockito] Warning - this stub was not used:\",\n                 i,\n-                \"Click here:\",\n                 i.getStackTrace().getStackTrace()[0],\n                 \"\"));\n         }\n                             \"[Mockito] Warning - stubbed method called with different arguments.\",\n                             \"Stubbed this way:\",\n                             unused,\n-                            \"Click here:\",\n                             unused.getStackTrace().getStackTrace()[0],\n                             \"\",\n                             \"But called with different arguments:\",\n                             unstubbed,\n-                            \"Click here:\",\n                             unstubbed.getInvocation().getStackTrace().getStackTrace()[0],\n                             \"\"));\n                     \n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorage.java\n @SuppressWarnings(\"unchecked\")\n public interface ArgumentMatcherStorage {\n \n-    EmptyReturnValues reportMatcher(Matcher matcher);\n+    HandyReturnValues reportMatcher(Matcher matcher);\n \n     List<Matcher> pullMatchers();\n \n-    EmptyReturnValues reportAnd();\n+    HandyReturnValues reportAnd();\n \n-    EmptyReturnValues reportNot();\n+    HandyReturnValues reportNot();\n \n-    EmptyReturnValues reportOr();\n+    HandyReturnValues reportOr();\n \n     void validateState();\n \n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n     /* (non-Javadoc)\n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportMatcher(org.hamcrest.Matcher)\n      */\n-    public EmptyReturnValues reportMatcher(Matcher matcher) {\n+    public HandyReturnValues reportMatcher(Matcher matcher) {\n         matcherStack.push(matcher);\n-        return new EmptyReturnValues();\n+        return new HandyReturnValues();\n     }\n \n     /* (non-Javadoc)\n     /* (non-Javadoc)\n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportAnd()\n      */\n-    public EmptyReturnValues reportAnd() {\n+    public HandyReturnValues reportAnd() {\n         assertState(!matcherStack.isEmpty(), \"No matchers found for And(?).\");\n         matcherStack.push(new And(popLastArgumentMatchers(2)));\n-        return new EmptyReturnValues();\n+        return new HandyReturnValues();\n     }\n \n     /* (non-Javadoc)\n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportNot()\n      */\n-    public EmptyReturnValues reportNot() {\n+    public HandyReturnValues reportNot() {\n         assertState(!matcherStack.isEmpty(), \"No matchers found for Not(?).\");\n         matcherStack.push(new Not(popLastArgumentMatchers(1).get(0)));\n-        return new EmptyReturnValues();\n+        return new HandyReturnValues();\n     }\n \n     private List<Matcher> popLastArgumentMatchers(int count) {\n     /* (non-Javadoc)\n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportOr()\n      */\n-    public EmptyReturnValues reportOr() {\n+    public HandyReturnValues reportOr() {\n         assertState(!matcherStack.isEmpty(), \"No matchers found.\");\n         matcherStack.push(new Or(popLastArgumentMatchers(2)));\n-        return new EmptyReturnValues();\n+        return new HandyReturnValues();\n     }\n \n     /* (non-Javadoc)\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/HandyReturnValues.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class HandyReturnValues {\n+\n+    public byte returnZero() {\n+        return 0;\n+    }\n+\n+    public char returnChar() {\n+        return 0;\n+    }\n+\n+    public <T> T returnNull() {\n+        return null;\n+    }\n+\n+    public boolean returnFalse() {\n+        return false;\n+    }\n+\n+    public String returnString() {\n+        return \"\";\n+    }\n+\n+    public Map returnMap() {\n+        return new HashMap();\n+    }\n+\n+    public List returnList() {\n+        return new LinkedList();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/returnvalues/EmptyReturnValues.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.returnvalues;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.mockito.configuration.ReturnValues;\n+import org.mockito.internal.creation.ClassNameFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.Primitives;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+/**\n+ * Used by default by every Mockito mock.\n+ * <ul>\n+ * <li>\n+ *  Returns appropriate primitive for primitive-returning methods\n+ * </li>\n+ * <li>\n+ *  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n+ * </li>\n+ * <li>\n+ *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n+ * </li>\n+ * <li>\n+ *  Returns description of mock for toString() method\n+ * </li>\n+ * <li>\n+ *  Returns null for everything else\n+ * </li>\n+ * </ul>\n+ */\n+public class EmptyReturnValues implements ReturnValues {\n+    \n+    /* (non-Javadoc)\n+     * @see org.mockito.configuration.ReturnValues#valueFor(org.mockito.invocation.InvocationOnMock)\n+     */\n+    public Object valueFor(InvocationOnMock invocation) {\n+        if (Invocation.isToString(invocation)) {\n+            Object mock = invocation.getMock();\n+            String mockDescription = \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n+            return mockDescription;\n+        }\n+        \n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        return returnValueFor(returnType);\n+    }\n+    \n+    Object returnValueFor(Class<?> type) {\n+        if (type.isPrimitive()) {\n+            return primitiveOf(type);\n+        } else if (Primitives.isPrimitiveWrapper(type)) {\n+            return Primitives.primitiveWrapperOf(type);\n+        //new instances are used instead of Collections.emptyList(), etc.\n+        //to avoid UnsupportedOperationException if code under test modifies returned collection\n+        } else if (type == Collection.class) {\n+            return new LinkedList<Object>();\n+        } else if (type == Set.class) {\n+            return new HashSet<Object>();\n+        } else if (type == HashSet.class) {\n+            return new HashSet<Object>();\n+        } else if (type == SortedSet.class) {\n+            return new TreeSet<Object>();\n+        } else if (type == TreeSet.class) {\n+            return new TreeSet<Object>();\n+        } else if (type == LinkedHashSet.class) {\n+            return new LinkedHashSet<Object>();\n+        } else if (type == List.class) {\n+            return new LinkedList<Object>();\n+        } else if (type == LinkedList.class) {\n+            return new LinkedList<Object>();\n+        } else if (type == ArrayList.class) {\n+            return new ArrayList<Object>();\n+        } else if (type == Map.class) {\n+            return new HashMap<Object, Object>();\n+        } else if (type == HashMap.class) {\n+            return new HashMap<Object, Object>();\n+        } else if (type == SortedMap.class) {\n+            return new TreeMap<Object, Object>();\n+        } else if (type == TreeMap.class) {\n+            return new TreeMap<Object, Object>();\n+        } else if (type == LinkedHashMap.class) {\n+            return new LinkedHashMap<Object, Object>();\n+        }       \n+        //Let's not care about the rest of collections.\n+        return null;\n+    }\n+\n+    private Object primitiveOf(Class<?> type) {\n+        if (type == Boolean.TYPE) {\n+            return false;\n+        } else if (type == Character.TYPE) {\n+            return (char) 0;\n+        } else {\n+            return 0;\n+        } \n+    }\n+}\n--- a/src/org/mockito/internal/returnvalues/GloballyConfiguredReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/GloballyConfiguredReturnValues.java\n         }\n         \n         //For now, let's leave the deprecated way of getting return values, \n-        //it will go away, though\n+        //it will go away, replaced simply by return new DefaultReturnValues()\n         return Configuration.instance().getReturnValues().valueFor(invocation);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/returnvalues/MoreEmptyReturnValues.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.returnvalues;\n+\n+import org.mockito.configuration.ReturnValues;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+/**\n+ * Will be used by default by every Mockito 2.0 mock.\n+ * <ul>\n+ * <li>\n+ *  Returns appropriate primitive for primitive-returning methods\n+ * </li>\n+ * <li>\n+ *  Returns consistent values for primitive wrapper classes (e.g. int-returning method retuns 0 <b>and</b> Integer-returning method returns 0, too)\n+ * </li>\n+ * <li>\n+ *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n+ * </li>\n+ * <li>\n+ *  Returns empty array for array-returning methods\n+ * </li>\n+ * <li>\n+ *  Returns \"\" for String-returning method\n+ * </li>\n+ * <li>\n+ *  Returns description of mock for toString() method\n+ * </li>\n+ * <li>\n+ *  Returns null for everything else\n+ * </li>\n+ * </ul>\n+ */\n+public class MoreEmptyReturnValues implements ReturnValues {\n+    \n+    private ReturnValues delegate = new EmptyReturnValues();\n+    \n+    /* (non-Javadoc)\n+     * @see org.mockito.configuration.ReturnValues#valueFor(org.mockito.invocation.InvocationOnMock)\n+     */\n+    public Object valueFor(InvocationOnMock invocation) {\n+        Object ret = delegate.valueFor(invocation);\n+        if (ret != null) {\n+            return ret;\n+        }\n+\n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        return returnValueFor(returnType);\n+    }\n+    \n+    Object returnValueFor(Class<?> type) {\n+        if (type == String.class) {\n+            return \"\";\n+        } else if (type == Object.class) {\n+            return new Object();\n+        } else if (type.isArray()) {\n+            //TODO is it possible to dynamically create array?\n+            return null;\n+//            System.out.println(type. getConstructors()[0].getParameterTypes());\n+//            try {\n+//                return type.newInstance();\n+//            } catch (Exception e) {\n+//                throw new RuntimeException(e);\n+//            }\n+        }\n+        return null;\n+    }\n+}\n--- a/src/org/mockito/internal/returnvalues/SmartNullReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/SmartNullReturnValues.java\n import net.sf.cglib.proxy.MethodInterceptor;\n import net.sf.cglib.proxy.MethodProxy;\n \n+import org.mockito.Mockito;\n+import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.configuration.ReturnValues;\n import org.mockito.exceptions.cause.BecauseThisMethodWasNotStubbed;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n-import org.mockito.internal.configuration.DefaultReturnValues;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.invocation.InvocationOnMock;\n \n+/**\n+ * Optional ReturnValues to be used with {@link Mockito#mock(Class, ReturnValues)}\n+ * <p>\n+ * {@link ReturnValues} defines the return values of unstubbed calls.\n+ * <p>\n+ * This implementation can be helpful when working with legacy code.\n+ * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.\n+ * This implementation of ReturnValues makes unstubbed methods return SmartNulls instead of nulls.\n+ * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.\n+ * <p>\n+ * SmartNullReturnValues first tries to return ordinary return values (see {@link MoreEmptyReturnValues})\n+ * then it tries to return SmartNull. If the return type is final then plain null is returned.\n+ * <p>\n+ * If you would like to apply this return values strategy globally have a look at {@link IMockitoConfiguration} class\n+ * <p>\n+ * SmartNullReturnValues will be probably the default return values strategy in Mockito 2.0\n+ */\n public class SmartNullReturnValues implements ReturnValues {\n \n-    private final ReturnValues delegate = new DefaultReturnValues();\n+    private final ReturnValues delegate = new MoreEmptyReturnValues();\n \n     public Object valueFor(InvocationOnMock invocation) {\n-        //TODO add more NullObjects\n         Object defaultReturnValue = delegate.valueFor(invocation);\n         if (defaultReturnValue != null) {\n             return defaultReturnValue;\n         Class<?> type = invocation.getMethod().getReturnType();\n         if (ClassImposterizer.INSTANCE.canImposterise(type)) {\n             return ClassImposterizer.INSTANCE.imposterise(new MethodInterceptor() {\n-                Exception whenCreated = new BecauseThisMethodWasNotStubbed(\"\\nBecause this method was not stubbed:\");\n+                Exception whenCreated = new BecauseThisMethodWasNotStubbed(\"\\nBecause this method was not stubbed correctly:\");\n                 public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n                     throw new SmartNullPointerException(\"\\nYou have a NullPointerException here:\", whenCreated);\n                 }}, type);\n--- a/src/org/mockito/runners/MockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/MockitoJUnitRunner.java\n import org.junit.runners.model.Statement;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n-\n-//TODO validate state in the runner?\n \n /**\n  * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n  *         list.add(100);\n  *     }\n  * }\n- * <p>\n- * \n  * </pre>\n  */\n public class MockitoJUnitRunner extends BlockJUnit4ClassRunner {\n         MockitoAnnotations.initMocks(target);\n         return super.withBefores(method, target, statement);\n     }\n-}\n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.exceptions.base.StackTraceRemoverTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.MockHandlerTest;\n-import org.mockito.internal.configuration.DefaultReturnValuesTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n import org.mockito.internal.progress.TimesTest;\n+import org.mockito.internal.returnvalues.EmptyReturnValuesTest;\n import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n import org.mockito.internal.verification.RegisteredInvocationsTest;\n                     TimesTest.class,\n                     MockHandlerTest.class,\n                     AllInvocationsFinderTest.class,\n-                    DefaultReturnValuesTest.class,\n+                    EmptyReturnValuesTest.class,\n                     NumberOfInvocationsCheckerTest.class,\n                     RegisteredInvocationsTest.class,\n                     MissingInvocationCheckerTest.class,\n--- /dev/null\n+++ b/test/org/junit/mockito/ExperimentalMockitoJUnitRunnerTest.java\n+package org.junit.mockito;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.mockito.ExperimentalMockitoJUnitRunner.JunitTestBody;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class ExperimentalMockitoJUnitRunnerTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+    private ExperimentalMockitoJUnitRunner runner;\n+    private MockitoLoggerStub loggerStub;\n+    private RunNotifier notifier;\n+\n+    @Before\n+    public void setup() throws InitializationError {\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        runner = new ExperimentalMockitoJUnitRunner(this.getClass(), loggerStub);\n+    }\n+    \n+    @Test(expected=RunWasCalled.class)\n+    public void shouldRunTests() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                throw new RunWasCalled();\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                //this is what happens when the test runs:\n+                //first, unused stubbing:\n+                unusedStubbingThatQualifiesForWarning();\n+                //then, let's make the test fail so that warnings are printed\n+                notifier.fireTestFailure(null);\n+                //assert\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n+                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                callUnstubbedMethodThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this method was not stubbed\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(456);\"));\n+                assertThat(loggedInfo, contains(\".callUnstubbedMethodThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                someStubbing();\n+                callStubbedMethodWithDifferentArgs();\n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - stubbed method called with different arguments\"));\n+                assertThat(loggedInfo, contains(\"Stubbed this way:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(789);\"));\n+                assertThat(loggedInfo, contains(\".someStubbing(\"));\n+                \n+                assertThat(loggedInfo, contains(\"But called with different arguments:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(10);\"));\n+                assertThat(loggedInfo, contains(\".callStubbedMethodWithDifferentArgs(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldNotLogAnythingWhenStubCalledCorrectly() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod(1)).thenReturn(\"foo\");\n+                mock.simpleMethod(1);\n+\n+                notifier.fireTestFailure(null);\n+                \n+                assertEquals(\"\", loggerStub.getLoggedInfo());\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldNotLogWhenTestPasses() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod()).thenReturn(\"foo\");\n+                \n+                notifier.fireTestFinished(null);\n+                \n+                assertEquals(\"\", loggerStub.getLoggedInfo());\n+            }\n+        });\n+    }\n+    \n+    \n+    public void shouldClearDebuggingDataAfterwards() throws Exception {\n+        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n+        \n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                unusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                assertTrue(debuggingInfo.hasData());\n+            }\n+        });\n+        \n+        assertFalse(debuggingInfo.hasData());\n+    }    \n+\n+    private void unusedStubbingThatQualifiesForWarning() {\n+        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n+    }\n+\n+    private void callUnstubbedMethodThatQualifiesForWarning() {\n+        mock.simpleMethod(456);\n+    }\n+    \n+    private void someStubbing() {\n+        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n+    }\n+    \n+    private void callStubbedMethodWithDifferentArgs() {\n+        mock.simpleMethod(10);\n+    }\n+    \n+    public class MockitoLoggerStub extends MockitoLoggerImpl {\n+        \n+        StringBuilder loggedInfo = new StringBuilder();\n+        \n+        public void log(Object what) {\n+            super.log(what);\n+            loggedInfo.append(what);\n+        }\n+\n+        public String getLoggedInfo() {\n+            return loggedInfo.toString();\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    private static class RunWasCalled extends RuntimeException {}; \n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/returnvalues/EmptyReturnValuesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.returnvalues;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class EmptyReturnValuesTest extends TestBase {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n+        EmptyReturnValues values = new EmptyReturnValues();\n+        \n+        assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty());\n+\n+        assertTrue(((Set) values.returnValueFor(Set.class)).isEmpty());\n+        assertTrue(((SortedSet) values.returnValueFor(SortedSet.class)).isEmpty());\n+        assertTrue(((HashSet) values.returnValueFor(HashSet.class)).isEmpty());\n+        assertTrue(((TreeSet) values.returnValueFor(TreeSet.class)).isEmpty());\n+        assertTrue(((LinkedHashSet) values.returnValueFor(LinkedHashSet.class)).isEmpty());\n+\n+        assertTrue(((List) values.returnValueFor(List.class)).isEmpty());\n+        assertTrue(((ArrayList) values.returnValueFor(ArrayList.class)).isEmpty());\n+        assertTrue(((LinkedList) values.returnValueFor(LinkedList.class)).isEmpty());\n+\n+        assertTrue(((Map) values.returnValueFor(Map.class)).isEmpty());\n+        assertTrue(((SortedMap) values.returnValueFor(SortedMap.class)).isEmpty());\n+        assertTrue(((HashMap) values.returnValueFor(HashMap.class)).isEmpty());\n+        assertTrue(((TreeMap) values.returnValueFor(TreeMap.class)).isEmpty());\n+        assertTrue(((LinkedHashMap) values.returnValueFor(LinkedHashMap.class)).isEmpty());\n+        \n+        assertNull(values.returnValueFor(String.class));\n+    }\n+    \n+    @Test public void shouldReturnPrimitive() {\n+        EmptyReturnValues values = new EmptyReturnValues();\n+        \n+        assertEquals(false, values.returnValueFor(Boolean.TYPE));\n+        assertEquals((char) 0, values.returnValueFor(Character.TYPE));\n+        assertEquals(0, values.returnValueFor(Byte.TYPE));\n+        assertEquals(0, values.returnValueFor(Short.TYPE));\n+        assertEquals(0, values.returnValueFor(Integer.TYPE));\n+        assertEquals(0, values.returnValueFor(Long.TYPE));\n+        assertEquals(0, values.returnValueFor(Float.TYPE));\n+        assertEquals(0, values.returnValueFor(Double.TYPE));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/returnvalues/MoreEmptyReturnValuesTest.java\n+package org.mockito.internal.returnvalues;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+public class MoreEmptyReturnValuesTest extends TestBase {\n+\n+    private MoreEmptyReturnValues rv = new MoreEmptyReturnValues();\n+\n+    @Ignore\n+    @Test\n+    public void shouldReturnEmptyArray() {\n+        String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());\n+        ret.getClass().isArray();\n+        assertTrue(ret.length == 0);\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyString() {\n+        assertEquals(\"\", rv.returnValueFor(String.class));\n+    }\n+\n+    @Test\n+    public void shouldReturnObjectInstance() {\n+        assertNotNull(rv.returnValueFor(Object.class));\n+    }\n+}\n--- a/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerPMTest.java\n+++ b/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerPMTest.java\n import org.mockito.Mock;\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.util.MockitoLoggerImpl;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n+import org.mockito.util.MockitoLoggerStub;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     @Ignore\n     @Test\n     public void shouldRunTestsWithHypotheticalPartialMock() throws Exception {\n-        runner = spy(runner);\n+//        runner = spy(runner);\n         \n         //This even might not be needed because runOnParent() might be safe\n         doNothing().when(runner).runTestBody(notifier);\n     }\n     \n     @Test\n-    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n-        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n-            protected void runTestBody(RunNotifier notifier) {\n-                //this is what happens when the test runs:\n-                //first, unused stubbing:\n-                unusedStubbingThatQualifiesForWarning();\n-                //then, let's make the test fail so that warnings are printed\n-                notifier.fireTestFailure(null);\n-                //assert\n-                String loggedInfo = loggerStub.getLoggedInfo();\n-                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n-                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n-                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n-            }\n-        };\n-        runner.run(notifier);\n+    public void usingAnnonymousInnerClass() throws Exception {\n+        //boring setup that goes to @Before\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        \n+        //arrange\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                someUnusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+            }\n+        };\n+        \n+        //act\n+        runner.run(notifier);\n+        \n+        //assert\n+        String loggedInfo = loggerStub.getLoggedInfo();\n+        assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n     }\n     \n     @Ignore\n     @Test\n-    public void shouldLogUnusedStubbingWarningWhenTestFailsWithPartialMock() throws Exception {\n-        runner = spy(runner);\n-        \n+    public void usingPartialMocking() throws Exception {\n+        //boring setup that goes to @Before\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        runner = spy(ExperimentalMockitoJUnitRunnerPMStub.class, guessConstructor(loggerStub));\n+        \n+        //arrange\n         doAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) {\n                 RunNotifier notifier = (RunNotifier) invocation.getArguments()[0];\n-                //this is what happens when the test runs:\n-                //first, unused stubbing:\n-                unusedStubbingThatQualifiesForWarning();\n-                //then, let's make the test fail so that warnings are printed\n-                notifier.fireTestFailure(null);\n-                //assert\n-                String loggedInfo = loggerStub.getLoggedInfo();\n-                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n-                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n-                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+                someUnusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n                 return null;\n             }\n         }).when(runner).runTestBody(notifier);\n-\n-        runner.run(notifier);\n+        \n+        //act\n+        runner.run(notifier);\n+        \n+        //assert\n+        String loggedInfo = loggerStub.getLoggedInfo();\n+        assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+    }\n+\n+    private <T> T spy(Class<T> clazz, Constructor guessConstructor) {\n+        return null;\n+    }\n+\n+    class Constructor<T> {\n+        \n+    }\n+    \n+    private Constructor guessConstructor(Object ... constructorArguments) {\n+        return null;\n+    }\n+\n+    private ExperimentalMockitoJUnitRunnerPMStub partialMock(Class<ExperimentalMockitoJUnitRunnerPM> class1) {\n+        return null;\n     }\n \n     @Test\n         runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n             protected void runTestBody(RunNotifier notifier) {\n                 someStubbing();\n-                //TODO below should be different test method\n //                callStubbedMethodCorrectly();\n                 callStubbedMethodWithDifferentArgs();\n                 notifier.fireTestFailure(null);\n         \n         runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n             protected void runTestBody(RunNotifier notifier) {\n-                unusedStubbingThatQualifiesForWarning();\n+                someUnusedStubbingThatQualifiesForWarning();\n                 notifier.fireTestFailure(null);\n                 assertTrue(debuggingInfo.hasData());\n             }\n         assertFalse(debuggingInfo.hasData());\n     }    \n \n-    private void unusedStubbingThatQualifiesForWarning() {\n+    private void someUnusedStubbingThatQualifiesForWarning() {\n         when(mock.simpleMethod(123)).thenReturn(\"foo\");\n     }\n \n         when(mock.simpleMethod(789)).thenReturn(\"foo\");\n     }\n     \n-    private void callStubbedMethodCorrectly() {\n-        mock.simpleMethod(789);\n-    }\n-\n     private void callStubbedMethodWithDifferentArgs() {\n         mock.simpleMethod(10);\n     }\n-    \n-    public class MockitoLoggerStub extends MockitoLoggerImpl {\n-        \n-        StringBuilder loggedInfo = new StringBuilder();\n-        \n-        public void log(Object what) {\n-//            can be uncommented when debugging this test\n-//            super.log(what);\n-            loggedInfo.append(what);\n-        }\n-\n-        public String getLoggedInfo() {\n-            return loggedInfo.toString();\n-        }\n-    }\n }\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/stubbing/SmartNullsStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/SmartNullsStubbingTest.java\n \n     @Before\n     public void setup() {\n-        mock = mock(IMethods.class, Mockito.SMART_NULLS);\n+        mock = mock(IMethods.class, Mockito.RETURNS_SMART_NULLS);\n     }\n     \n     public IMethods unstubbedMethodInvokedHere(IMethods mock) {\n     \n     @Test\n     public void shouldThrowSmartNPEWhenMethodReturnsClass() throws Exception {\n-        Foo mock = mock(Foo.class, SMART_NULLS);\n+        Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n         Foo foo = mock.getSomeClass(); \n         try {\n             foo.boo();\n     \n     @Test\n     public void shouldThrowSmartNPEWhenMethodReturnsInterface() throws Exception {\n-        Foo mock = mock(Foo.class, SMART_NULLS);\n+        Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n         Bar bar = mock.getSomeInterface(); \n         try {\n             bar.boo();\n--- a/test/org/mockitousage/warnings/WarningAboutStubCalledWithDifferentArgsTest.java\n+++ b/test/org/mockitousage/warnings/WarningAboutStubCalledWithDifferentArgsTest.java\n \n import org.junit.Ignore;\n import org.junit.Test;\n+import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/warnings/WarningAboutStubsNotUsedTest.java\n+++ b/test/org/mockitousage/warnings/WarningAboutStubsNotUsedTest.java\n \n import org.junit.Ignore;\n import org.junit.Test;\n+import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/warnings/WarningAboutUnstubbedMethodsInvokedTest.java\n+++ b/test/org/mockitousage/warnings/WarningAboutUnstubbedMethodsInvokedTest.java\n \n import org.junit.Ignore;\n import org.junit.Test;\n+import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.Mock;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n ", "timestamp": 1231543742, "metainfo": ""}