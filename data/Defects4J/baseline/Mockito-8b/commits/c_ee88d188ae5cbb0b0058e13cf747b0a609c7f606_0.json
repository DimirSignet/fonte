{"sha": "ee88d188ae5cbb0b0058e13cf747b0a609c7f606", "log": "refactored verifiers  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40196", "commit": "\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import java.util.Arrays;\n import java.util.List;\n \n-import org.mockito.exceptions.Reporter;\n import org.mockito.internal.creation.MockAwareInvocationHandler;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n         InvocationsMarker marker = new InvocationsMarker();\n         List<Verifier> verifiers = Arrays.asList(\n                 new MissingInvocationVerifier(), \n-                new NumberOfInvocationsVerifier(new Reporter()),\n+                new NumberOfInvocationsVerifier(),\n                 new NoMoreInvocationsVerifier());\n         return new VerifyingRecorder(chunker, marker, verifiers);\n     }\n--- a/src/org/mockito/internal/invocation/InvocationsCalculator.java\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculator.java\n  */\n package org.mockito.internal.invocation;\n \n-import java.util.LinkedList;\n import java.util.List;\n \n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.internal.progress.VerificationMode;\n \n+//TODO refactor to an object that holds Invocations and exposes some calculations\n public class InvocationsCalculator {\n-\n-    private List<Invocation> invocations = new LinkedList<Invocation>();\n \n     public InvocationsCalculator() {}\n     \n-    public InvocationsCalculator(List<Invocation> invocations) {\n-        this.invocations.addAll(invocations);\n-    }\n-\n-    public int countActual(InvocationMatcher wanted) {\n+    public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n         int actual = 0;\n         for (Invocation registeredInvocation : invocations) {\n             if (wanted.matches(registeredInvocation)) {\n         return actual;\n     }\n \n-    public Invocation findActualInvocation(InvocationMatcher wanted) {\n+    public Invocation findActualInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n         Invocation actualbyName = null;\n         for (Invocation registered : invocations) {\n             String wantedMethodName = wanted.getMethod().getName();\n             }\n         }\n         \n-        return actualbyName != null ? actualbyName : getFirstUnverified();\n+        return actualbyName != null ? actualbyName : getFirstUnverified(invocations);\n     }\n     \n-    public Invocation getFirstUnverified() {\n+    public Invocation getFirstUnverified(List<Invocation> invocations) {\n         for (Invocation i : invocations) {\n             if (!i.isVerified()) {\n                 return i;\n         return null;\n     }\n     \n-    public HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted) {\n+    public HasStackTrace getLastInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n         Invocation lastMatching = null;\n         for (Invocation registered : invocations) {\n             if (wanted.matches(registered)) {\n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n \n-    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, VerificationMode mode) {\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n         int counter = 0;\n         for (Invocation registered : invocations) {\n             if (wanted.matches(registered)) {\n         }\n         throw new IllegalArgumentException(\"There are no undesired invocations!\");\n     }\n-\n-    public List<Invocation> getInvocations() {\n-        return invocations;\n-    }\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.verification;\n+\n+import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n public class MissingInvocationVerifier implements Verifier {\n     \n     private final Reporter reporter = new Reporter();\n-\n-    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n+    private final InvocationsCalculator calculator = new InvocationsCalculator();\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n         if (!mode.isExplicit()) {\n             return;\n         }\n         \n-        int actualCount = calculator.countActual(wanted);\n+        int actualCount = calculator.countActual(invocations, wanted);\n         Integer wantedCount = mode.wantedCount();\n         boolean atLeastOnce = mode.atLeastOnceMode();\n                \n         if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n-            reportMissingInvocationError(calculator, wanted);\n+            reportMissingInvocationError(invocations, wanted);\n         }\n     }\n     \n-    private void reportMissingInvocationError(InvocationsCalculator calculator, InvocationMatcher wanted) {\n-        Invocation actual = calculator.findActualInvocation(wanted);\n+    private void reportMissingInvocationError(List<Invocation> invocations, InvocationMatcher wanted) {\n+        Invocation actual = calculator.findActualInvocation(invocations, wanted);\n         \n         if (actual != null) {\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n--- a/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.verification;\n+\n+import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n public class NoMoreInvocationsVerifier implements Verifier {\n \n     private final Reporter reporter = new Reporter();\n-\n-    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n+    private final InvocationsCalculator calculator = new InvocationsCalculator();\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n         if (mode.isExplicit()) {\n             return;\n         }\n \n-        Invocation unverified = calculator.getFirstUnverified();\n+        Invocation unverified = calculator.getFirstUnverified(invocations);\n         if (unverified != null) {\n             reporter.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n     }\n-}\n+}\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n  */\n package org.mockito.internal.verification;\n \n+import java.util.List;\n+\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n public class NumberOfInvocationsVerifier implements Verifier {\n     \n     private final Reporter reporter;\n+    private final InvocationsCalculator calculator;\n \n-    public NumberOfInvocationsVerifier(Reporter reporter) {\n+    public NumberOfInvocationsVerifier() {\n+        this(new Reporter(), new InvocationsCalculator());\n+    }\n+    \n+    NumberOfInvocationsVerifier(Reporter reporter, InvocationsCalculator calculator) {\n         this.reporter = reporter;\n+        this.calculator = calculator;\n     }\n-\n-    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n         if (mode.atLeastOnceMode() || !mode.isExplicit()) {\n             return;\n         }\n         \n-        int actualCount = calculator.countActual(wanted);\n+        int actualCount = calculator.countActual(invocations, wanted);\n         Integer wantedCount = mode.wantedCount();\n         \n         if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocation = calculator.getLastInvocationStackTrace(wanted);\n+            HasStackTrace lastInvocation = calculator.getLastInvocationStackTrace(invocations, wanted);\n             reporter.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n-            HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(wanted, mode);\n+            HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(invocations, wanted, mode);\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n--- a/src/org/mockito/internal/verification/Verifier.java\n+++ b/src/org/mockito/internal/verification/Verifier.java\n  */\n package org.mockito.internal.verification;\n \n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n \n \n public interface Verifier {\n \n-    void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode);\n+    void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode);\n     \n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.progress.VerificationMode;\n     \n     public void verify(InvocationMatcher wanted, VerificationMode mode) {\n         List<Invocation> invocations = getInvocationsForEvaluation(mode);\n-        //TODO should not construct calculator\n-        InvocationsCalculator calculator = new InvocationsCalculator(invocations);\n         \n         for (Verifier verifier : verifiers) {\n-            verifier.verify(calculator, wanted, mode);\n+            verifier.verify(invocations, wanted, mode);\n         }\n         \n         if (mode.isExplicit()) {\n--- a/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n import static org.junit.Assert.assertSame;\n \n import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.parents.HasStackTrace;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.VerificationMode;\n \n \n public class InvocationsCalculatorTest extends RequiresValidState {\n     \n-    private InvocationsCalculator calculator;\n+    private List<Invocation> invocations = new LinkedList<Invocation>();\n     private Invocation simpleMethodInvocation;\n     private Invocation simpleMethodInvocationTwo;\n     private Invocation differentMethodInvocation;\n+    private InvocationsCalculator calculator;\n \n     @Before\n     public void setup() throws Exception {\n         simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n         simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n         differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n-        calculator = new InvocationsCalculator(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n+        invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n+        calculator = new InvocationsCalculator();\n     }\n     \n     @Test\n     public void shouldGetFirstUnverifiedInvocation() throws Exception {\n-        assertSame(simpleMethodInvocation, calculator.getFirstUnverified());\n+        assertSame(simpleMethodInvocation, calculator.getFirstUnverified(invocations));\n         \n         simpleMethodInvocationTwo.markVerified();\n         simpleMethodInvocation.markVerified();\n         \n-        assertSame(differentMethodInvocation, calculator.getFirstUnverified());\n+        assertSame(differentMethodInvocation, calculator.getFirstUnverified(invocations));\n         \n         differentMethodInvocation.markVerified();\n-        assertNull(calculator.getFirstUnverified());\n+        assertNull(calculator.getFirstUnverified(invocations));\n     }\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n-        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(0));\n         HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test\n     public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n-        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(1));\n         HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n         assertSame(firstUndesired, expected);\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n-        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n+        calculator.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(2));\n     }\n     \n     @Test(expected=IllegalArgumentException.class)\n     public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n-        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n+        calculator.getFirstUndesiredInvocationStackTrace(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationMode.times(100));\n     }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n \n public class MissingInvocationVerifierTest extends RequiresValidState {\n \n+    //TODO more tests\n     @Test\n     public void shouldVerifyOnlyWhenModeIsExplicit() {\n         MissingInvocationVerifier verifier = new MissingInvocationVerifier();\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n \n public class NoMoreInvocationsVerifierTest extends RequiresValidState {\n \n+    //TODO tests\n     @Test\n     public void shouldNeverVerifyWhenVerificationIsExplicit() throws Exception {\n         NoMoreInvocationsVerifier verifier = new NoMoreInvocationsVerifier();\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n  */\n package org.mockito.internal.verification;\n \n+import static java.util.Arrays.asList;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertSame;\n import static org.mockito.internal.progress.VerificationMode.atLeastOnce;\n import static org.mockito.internal.progress.VerificationMode.times;\n+\n+import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.exceptions.parents.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n     @Before\n     public void setup() {\n         reporterStub = new ReporterStub();\n-        verifier = new NumberOfInvocationsVerifier(reporterStub);\n         calculatorStub = new InvocationsCalculatorStub();\n+        verifier = new NumberOfInvocationsVerifier(reporterStub, calculatorStub);\n     }\n \n     @Test\n     @Test\n     public void shouldCountActualInvocations() throws Exception {\n         InvocationMatcher wanted = new InvocationBuilder().toInvocationMatcher();\n-        verifier.verify(calculatorStub, wanted, times(4));\n+        verifier.verify(asList(wanted.getInvocation()), wanted, times(4));\n         assertSame(wanted, calculatorStub.wantedForCountingActual);\n     }\n     \n     public void shouldReportTooLittleInvocations() throws Exception {\n         InvocationMatcher wanted = new InvocationBuilder().toInvocationMatcher();\n         VerificationMode mode = times(10);\n-        verifier.verify(calculatorStub, wanted, mode);\n+        verifier.verify(asList(wanted.getInvocation()), wanted, mode);\n         \n         assertSame(wanted, calculatorStub.wantedForGettingTrace);\n         \n     public void shouldReportTooManyInvocations() throws Exception {\n         InvocationMatcher wanted = new InvocationBuilder().toInvocationMatcher();\n         VerificationMode mode = times(0);\n-        verifier.verify(calculatorStub, wanted, mode);\n+        verifier.verify(asList(wanted.getInvocation()), wanted, mode);\n         \n         assertSame(wanted, calculatorStub.wantedForGettingTrace);\n         assertSame(mode, calculatorStub.mode);\n         private InvocationMatcher wantedForGettingTrace;\n         private VerificationMode mode;\n         @Override\n-        public int countActual(InvocationMatcher wanted) {\n+        public int countActual(List<Invocation> invocations, InvocationMatcher wanted) {\n             this.wantedForCountingActual = wanted;\n             return 5;\n         }\n         \n-        @Override public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, VerificationMode mode) {\n+        @Override public HasStackTrace getFirstUndesiredInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n             wantedForGettingTrace = wanted;\n             this.mode = mode;\n             return firstUndesired;\n         }\n         \n         @Override\n-        public HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted) {\n+        public HasStackTrace getLastInvocationStackTrace(List<Invocation> invocations, InvocationMatcher wanted) {\n             wantedForGettingTrace = wanted;\n             return lastInvocation;\n         }\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.progress.VerificationMode;\n         \n         assertEquals(verifierStub.mode, mode);\n         assertSame(verifierStub.wanted, differentMethod);\n-        assertThat(verifierStub.calculator.getInvocations(), collectionHasExactlyInOrder(simpleMethod));\n+        assertThat(verifierStub.invocations, collectionHasExactlyInOrder(simpleMethod));\n     }\n     \n     @Test\n         \n         assertEquals(verifierStub.mode, mode);\n         assertEquals(verifierStub.wanted, differentMethod);\n-        assertThat(verifierStub.calculator.getInvocations(), collectionHasExactlyInOrder(differentMethod.getInvocation()));\n+        assertThat(verifierStub.invocations, collectionHasExactlyInOrder(differentMethod.getInvocation()));\n     }\n     \n     @Test\n             this.wanted = wanted;\n             this.mode = mode;\n             \n-            assertNotNull(\"marking should happen after verification\", verifierStub.calculator);\n+            assertNotNull(\"marking should happen after verification\", verifierStub.invocations);\n         }\n     }\n     \n     class VerifierStub implements Verifier {\n-        private InvocationsCalculator calculator;\n+        private List<Invocation> invocations;\n         private InvocationMatcher wanted;\n         private VerificationMode mode;\n-        public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, VerificationMode mode) {\n-            this.calculator = calculator;\n+        public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+            this.invocations = invocations;\n             this.wanted = wanted;\n             this.mode = mode;\n         }", "timestamp": 1197664556, "metainfo": ""}