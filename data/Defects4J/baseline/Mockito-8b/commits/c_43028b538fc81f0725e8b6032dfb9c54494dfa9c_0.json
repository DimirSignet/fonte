{"sha": "43028b538fc81f0725e8b6032dfb9c54494dfa9c", "log": "when number of invocations don't match, provided cause with stack trace to actual invocation. Now also with TooManyInvocationsError  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40147", "commit": "\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n                     wanted        \n         ));\n     }\n-\n+    \n     public static void numberOfInvocationsDiffers(int wantedCount, int actualCount, String wanted) {\n         throw new NumberOfInvocationsError(join(\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ));\n+    }\n+\n+    public static void tooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n+        FirstUndesiredInvocation cause = new FirstUndesiredInvocation(join(\"First undesired invocation:\"));\n+        cause.setStackTrace(firstUndesired.getStackTrace());\n+        \n+        throw new TooManyActualInvocationsError(join(\n+                wanted,\n+                \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n+        ), cause);\n     }\n     \n     public static void tooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n     }\n \n     public static void noMoreInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n-        UndesiredInvocation cause = buildCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n+        UndesiredInvocation cause = buildUndesiredInvocationCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n         throw new VerificationError(join(\"No more interactions wanted\"), cause);\n     }\n     \n     public static void zeroInteractionsWanted(String undesired, HasStackTrace actualInvocationStackTrace) {\n-        UndesiredInvocation cause = buildCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n+        UndesiredInvocation cause = buildUndesiredInvocationCause(actualInvocationStackTrace, \"Undesired invocation:\", undesired);\n         throw new VerificationError(join(\"Zero interactions wanted\"), cause);\n     }\n \n-    private static UndesiredInvocation buildCause(HasStackTrace actualInvocationStackTrace, String ... messageLines) {\n+    private static UndesiredInvocation buildUndesiredInvocationCause(HasStackTrace actualInvocationStackTrace, String ... messageLines) {\n         UndesiredInvocation cause = new UndesiredInvocation(join(messageLines));\n         cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n         return cause;\n--- /dev/null\n+++ b/src/org/mockito/exceptions/TooManyActualInvocationsError.java\n+package org.mockito.exceptions;\n+\n+public class TooManyActualInvocationsError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public TooManyActualInvocationsError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/cause/FirstUndesiredInvocation.java\n+package org.mockito.exceptions.cause;\n+\n+import org.mockito.exceptions.MockitoException;\n+\n+public class FirstUndesiredInvocation extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public FirstUndesiredInvocation(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n         Integer wantedCount = mode.wantedCount();\n         \n         if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocationStackTrace = registeredInvocations.getLastInvocationStackTrace(wanted);\n-            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocationStackTrace);\n+            HasStackTrace lastInvocation = registeredInvocations.getLastInvocationStackTrace(wanted);\n+            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n-//            registeredInvocations.findFirstUndesiredInvocation(wanted, mode);\n-            Exceptions.numberOfInvocationsDiffers(wantedCount, actualCount, wanted.toString());\n+            HasStackTrace firstUndesired = registeredInvocations.getFirstUndesiredInvocationStackTrace(wanted, mode);\n+            Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n \n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n         }\n         return lastMatching != null ? lastMatching.getStackTrace() : null;\n     }\n+\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(ExpectedInvocation wanted, VerifyingMode mode) {\n+        int counter = 0;\n+        for (Invocation registered : registeredInvocations) {\n+            if (wanted.matches(registered)) {\n+                counter++;\n+                if (counter > mode.wantedCount()) {\n+                    return registered.getStackTrace();\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"There are no undesired invocations!\");\n+    }\n }\n--- a/test/org/mockito/internal/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/RegisteredInvocationsTest.java\n import java.util.*;\n \n import org.junit.*;\n+import org.mockito.exceptions.HasStackTrace;\n import org.mockito.util.RequiresValidState;\n \n @SuppressWarnings(\"unchecked\")\n         registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation), atLeastOnce());\n         assertNull(registered.getFirstUnverified());\n     }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new ExpectedInvocation(simpleMethodInvocation), VerifyingMode.times(0));\n+        HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new ExpectedInvocation(simpleMethodInvocation), VerifyingMode.times(1));\n+        HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsTwo() throws Exception {\n+        HasStackTrace firstUndesired = registered.getFirstUndesiredInvocationStackTrace(new ExpectedInvocation(simpleMethodInvocation), VerifyingMode.times(2));\n+        HasStackTrace expected = simpleMethodInvocationThree.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n }\n--- a/test/org/mockitousage/verification/BasicVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n         try {\n             verify(mock).clear();\n             fail();\n-        } catch (NumberOfInvocationsError e) {};\n+        } catch (TooManyActualInvocationsError e) {};\n     }\n \n     @Test\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n import org.junit.*;\n import org.mockito.Mockito;\n import org.mockito.exceptions.*;\n-import org.mockito.exceptions.cause.TooLittleInvocations;\n+import org.mockito.exceptions.cause.*;\n import org.mockito.util.RequiresValidState;\n \n @SuppressWarnings(\"unchecked\")\n         mock.clear();\n         mock.clear();\n         mock.clear();\n+        mock.clear();\n \n-        Mockito.verify(mock, 3).clear();\n+        Mockito.verify(mock, 4).clear();\n         try {\n             Mockito.verify(mock, 1).clear();\n             fail();\n-        } catch (NumberOfInvocationsError e) {\n+        } catch (TooManyActualInvocationsError e) {\n             String expected = \n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n                 \"\\n\" +\n-                \"Wanted 1 time but was 3\";\n+                \"Wanted 1 time but was 4\";\n             assertEquals(expected, e.getMessage());\n+            \n+            assertEquals(FirstUndesiredInvocation.class, e.getCause().getClass());\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"First undesired invocation:\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n     \n         try {\n             Mockito.verify(mock, 0).clear();\n             fail();\n-        } catch (NumberOfInvocationsError e) {\n+        } catch (TooManyActualInvocationsError e) {\n             assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n         }\n     }", "timestamp": 1197219449, "metainfo": ""}