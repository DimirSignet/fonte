{"sha": "f8681148a48edb7b742343f4d9e995d4523345bb", "log": "- in order to start seperating serializable funtionality (sorry 5 hg versions again) -- created a MockitoMethod Interface -- changed MockitoMethod to SerializableMockitoMethod which implements MockitoMethod -- return MockitoMethod everywhere we were calling the getMethod before -- added methods to MockitoMethod that match the methods we were using from a normal Method  - in order to begin separation of serializable from non-serializable mocks -- renamed MockitoMethodProxy to SerializableMockitoMethodProxy -- created MockitMethodProxy interface -- return MockitoMehtodProxy in all classes that were using a MethodProxy. (CGLIBHacker, FilteredCGLIBProxyRealMethod, HasCGLIBMethodProxy, MethodInterceptorFilter)  - in order to begin separation of serializable from non-serializable mocks -- renamed MockitoMethodProxy to SerializableMockitoMethodProxy -- created MockitMethodProxy interface -- return MockitoMehtodProxy in all classes that were using a MethodProxy. (CGLIBHacker, FilteredCGLIBProxyRealMethod, HasCGLIBMethodProxy, MethodInterceptorFilter)  - in order to begin separation of serializable from non-serializable mocks -- add serializable MockSetting -- when creating MockitoMockProxy look at the isSerializable setting and create SerializableMockitoMockProxy or DelegatingMockitoMockProxy -- not sure about the createMockitoMethodProxy in IMockHandler  - in order to begin separation of serializable from non-serializable mocks -- added createMockitoMethod to IMockHandler and MockHandler (still need to ask szczepan about this??? but is only place that has settings) --- createMockitoMethod determines which MockitoMethod to create based on MockSettings.isSerializable. -- changed Invocation to take MockitoMethod instead of Method  --HG-- rename : src/org/mockito/internal/creation/MockitoMethodProxy.java => src/org/mockito/internal/creation/SerializableMockitoMethodProxy.java rename : src/org/mockito/internal/invocation/MockitoMethod.java => src/org/mockito/internal/invocation/SerializableMockitoMethod.java rename : test/org/mockito/internal/creation/MockitoMethodProxyTest.java => test/org/mockito/internal/creation/SerializableMockitoMethodProxyTest.java rename : test/org/mockito/internal/invocation/MockitoMethodTest.java => test/org/mockito/internal/invocation/SerializableMockitoMethodTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401655", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n      */\n     @SuppressWarnings(\"unchecked\")\n     MockSettings defaultAnswer(Answer defaultAnswer);\n+\n+    MockSettings serializable();\n+    \n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     public static <T> T spy(T object) {\n         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                 .spiedInstance(object)\n-                .defaultAnswer(CALLS_REAL_METHODS));\n+                .defaultAnswer(CALLS_REAL_METHODS)); \n     }\n \n     /**\n--- a/src/org/mockito/internal/IMockHandler.java\n+++ b/src/org/mockito/internal/IMockHandler.java\n package org.mockito.internal;\n \n import java.io.Serializable;\n+import java.lang.reflect.Method;\n \n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.MockitoMethod;\n \n public interface IMockHandler extends Serializable {\n \n     Object handle(Invocation invocation) throws Throwable;\n+    \n+    MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy);\n+\n+    MockitoMethod createMockitoMethod(Method method);\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  */\n package org.mockito.internal;\n \n+import java.lang.reflect.Method;\n import java.util.List;\n \n-import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.*;\n import org.mockito.internal.invocation.*;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n \n /**\n  * Invocation handler set on mock objects.\n- *\n- * @param <T> type of mock object to handle\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n  */\n public class MockHandler<T> implements IMockHandler {\n \n     private static final long serialVersionUID = -2917871070982574165L;\n-    \n+\n     MockitoStubber mockitoStubber;\n     MatchersBinder matchersBinder;\n     MockingProgress mockingProgress;\n-    \n+\n     private final RegisteredInvocations registeredInvocations;\n     private final MockName mockName;\n     private final MockSettingsImpl mockSettings;\n \n-    public MockHandler(MockName mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder, MockSettingsImpl mockSettings) {\n+    public MockHandler(MockName mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder,\n+                    MockSettingsImpl mockSettings) {\n         this.mockName = mockName;\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n         this.mockitoStubber = new MockitoStubber(mockingProgress);\n         this.registeredInvocations = new RegisteredInvocations();\n     }\n-    \n+\n     public MockHandler(MockHandler<T> oldMockHandler) {\n-        this(oldMockHandler.mockName, oldMockHandler.mockingProgress, oldMockHandler.matchersBinder, oldMockHandler.mockSettings);\n+        this(oldMockHandler.mockName, oldMockHandler.mockingProgress, oldMockHandler.matchersBinder,\n+                        oldMockHandler.mockSettings);\n     }\n-    \n-    //for tests\n+\n+    // for tests\n     MockHandler() {\n-        this(new MockName(\"mockie for tests\", MockHandler.class), new ThreadSafeMockingProgress(), new MatchersBinder(), new MockSettingsImpl());\n+        this(new MockName(\"mockie for tests\", MockHandler.class), new ThreadSafeMockingProgress(),\n+                        new MatchersBinder(), new MockSettingsImpl());\n     }\n-    \n+\n     public Object handle(Invocation invocation) throws Throwable {\n         if (mockitoStubber.hasAnswersForStubbing()) {\n-            //stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n+                            .getArgumentMatcherStorage(), invocation);\n             mockitoStubber.setMethodForStubbing(invocationMatcher);\n             return null;\n         }\n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n \n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n-        \n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n+                        invocation);\n+\n         mockingProgress.validateState();\n \n         if (verificationMode != null) {\n \n         StubbedInvocationMatcher stubbedInvocation = mockitoStubber.findAnswerFor(invocation);\n         if (!invocation.isVoid() && stubbedInvocation == null) {\n-            //it is a return-value interaction but not stubbed. This *might* be a problem\n+            // it is a return-value interaction but not stubbed. This *might* be\n+            // a problem\n             mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n         }\n-        \n+\n         if (stubbedInvocation != null) {\n             mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n             stubbedInvocation.captureArgumentsFrom(invocation);\n             return stubbedInvocation.answer(invocation);\n         } else {\n             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n-            \n-            //redo setting invocation for potential stubbing in case of partial mocks / spies.\n-            //Without it, the real method inside 'when' might have delegated \n-            //to other self method and overwrite the intended stubbed method with a different one.\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one.\n             mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n             return ret;\n         }\n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n     }\n+\n+    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n+        if (mockSettings.isSerializable())\n+            return new SerializableMockitoMethodProxy(methodProxy);\n+        return new DelegatingMockitoMethodProxy(methodProxy);\n+    }\n+\n+    public MockitoMethod createMockitoMethod(Method method) {\n+        if (mockSettings.isSerializable())\n+            return new SerializableMockitoMethod(method);\n+        return new DelegatingMockitoMethod(method);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/AbstractMockitoMethodProxy.java\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.Field;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.cglib.MockitoNamingPolicy;\n+\n+public abstract class AbstractMockitoMethodProxy implements MockitoMethodProxy {\n+\n+    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {\n+        return getMethodProxy().invokeSuper(target, arguments);\n+    }\n+\n+    public void setNamingPolicyField(MockitoNamingPolicy namingPolicy) {\n+        try {\n+            MethodProxy methodProxy = getMethodProxy();\n+            Field createInfoField = reflectOnCreateInfo(methodProxy);\n+            createInfoField.setAccessible(true);\n+            Object createInfo = createInfoField.get(methodProxy);\n+            Field namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\n+            namingPolicyField.setAccessible(true);\n+            if (namingPolicyField.get(createInfo) == null) {\n+                namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\n+                            \"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses\", e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws SecurityException, NoSuchFieldException {\n+        \n+        Class cglibMethodProxyClass = methodProxy.getClass();\n+        // in case methodProxy was extended by user, let's traverse the object\n+        // graph to find the cglib methodProxy\n+        // with all the fields we would like to change\n+        while (cglibMethodProxyClass != MethodProxy.class) {\n+            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();\n+        }\n+        return cglibMethodProxyClass.getDeclaredField(\"createInfo\");\n+    }\n+\n+\n+    protected abstract MethodProxy getMethodProxy();\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/DelegatingMockitoMethodProxy.java\n+package org.mockito.internal.creation;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+public class DelegatingMockitoMethodProxy extends AbstractMockitoMethodProxy {\n+\n+    private final MethodProxy methodProxy;\n+\n+    public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    @Override\n+    protected MethodProxy getMethodProxy() {\n+        return methodProxy;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.creation.cglib.CGLIBHacker;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.MockitoMethod;\n import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n \n         } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n             return hashCodeForMock(proxy);\n         }\n-\n-        cglibHacker.setMockitoNamingPolicy(methodProxy);\n         \n-        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(new MockitoMethodProxy(methodProxy));\n-        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), realMethod);\n+        MockitoMethodProxy mockitoMethodProxy = mockHandler.createMockitoMethodProxy(methodProxy);\n+        \n+        cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n+        \n+        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n+        MockitoMethod mockitoMethod = mockHandler.createMockitoMethod(method);\n+        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n         return mockHandler.handle(invocation);\n     }\n     \n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n     private String name;\n     private Object spiedInstance;\n     private Answer<Object> defaultAnswer;\n+    private boolean isSerializable;\n+\n+    public MockSettings serializable() {\n+        this.isSerializable = true;\n+        return this;\n+    }\n \n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n         if (extraInterfaces == null || extraInterfaces.length == 0) {\n     public Answer<Object> getDefaultAnswer() {\n         return defaultAnswer;\n     }\n+\n+    public boolean isSerializable() {\n+        return isSerializable;\n+    }\n }\n--- a/src/org/mockito/internal/creation/MockitoMethodProxy.java\n+++ b/src/org/mockito/internal/creation/MockitoMethodProxy.java\n package org.mockito.internal.creation;\n \n-import java.io.Serializable;\n+import org.mockito.internal.creation.cglib.MockitoNamingPolicy;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.util.reflection.Whitebox;\n+public interface MockitoMethodProxy {\n \n-public class MockitoMethodProxy implements Serializable {\n+    Object invokeSuper(Object target, Object[] arguments) throws Throwable;\n \n-  private static final long serialVersionUID = -5337859962876770632L;\n-  private Class<?> c1;\n-  private Class<?> c2;\n-  private String desc;\n-  private String name;\n-  private String superName;\n+    void setNamingPolicyField(MockitoNamingPolicy namingPolicy);\n \n-  public MockitoMethodProxy(MethodProxy methodProxy) {\n-    Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n-    c1 = (Class<?>) Whitebox.getInternalState(info, \"c1\");\n-    c2 = (Class<?>) Whitebox.getInternalState(info, \"c2\");\n-    desc = methodProxy.getSignature().getDescriptor();\n-    name = methodProxy.getSignature().getName();\n-    superName = methodProxy.getSuperName();\n-  }\n-\n-  public MethodProxy getMethodProxy() {\n-    return MethodProxy.create(c1, c2, desc, name, superName);\n-  }\n-\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/SerializableMockitoMethodProxy.java\n+package org.mockito.internal.creation;\n+\n+import java.io.Serializable;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.util.reflection.Whitebox;\n+\n+public class SerializableMockitoMethodProxy extends AbstractMockitoMethodProxy implements Serializable {\n+\n+    private static final long serialVersionUID = -5337859962876770632L;\n+    private Class<?> c1;\n+    private Class<?> c2;\n+    private String desc;\n+    private String name;\n+    private String superName;\n+    private transient MethodProxy methodProxy;\n+\n+    public SerializableMockitoMethodProxy(MethodProxy methodProxy) {\n+        Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        c1 = (Class<?>) Whitebox.getInternalState(info, \"c1\");\n+        c2 = (Class<?>) Whitebox.getInternalState(info, \"c2\");\n+        desc = methodProxy.getSignature().getDescriptor();\n+        name = methodProxy.getSignature().getName();\n+        superName = methodProxy.getSuperName();\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    protected MethodProxy getMethodProxy() {\n+        if (methodProxy == null)\n+            methodProxy = MethodProxy.create(c1, c2, desc, name, superName);\n+        return methodProxy;\n+    }\n+}\n--- a/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n+++ b/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n  */\n package org.mockito.internal.creation.cglib;\n \n-import java.lang.reflect.Field;\n import java.io.Serializable;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n \n public class CGLIBHacker implements Serializable {\n \n     private static final long serialVersionUID = -4389233991416356668L;\n \n-    public void setMockitoNamingPolicy(MethodProxy methodProxy) {\n-        try {\n-            Field createInfoField = reflectOnCreateInfo(methodProxy);\n-            createInfoField.setAccessible(true);\n-            Object createInfo = createInfoField.get(methodProxy);\n-            Field namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\n-            namingPolicyField.setAccessible(true);\n-            if (namingPolicyField.get(createInfo) == null) {\n-                namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);\n-            }\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses\", e);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws NoSuchFieldException {\n-        Class cglibMethodProxyClass = methodProxy.getClass();\n-        //in case methodProxy was extended by user, let's traverse the object graph to find the cglib methodProxy \n-        //with all the fields we would like to change \n-        while (cglibMethodProxyClass != MethodProxy.class) {\n-            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();\n-        }\n-        return cglibMethodProxyClass.getDeclaredField(\"createInfo\");\n+    public void setMockitoNamingPolicy(MockitoMethodProxy methodProxy) {\n+        methodProxy.setNamingPolicyField(MockitoNamingPolicy.INSTANCE);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/DelegatingMockitoMethod.java\n+package org.mockito.internal.invocation;\n+\n+import java.lang.reflect.Method;\n+\n+public class DelegatingMockitoMethod implements MockitoMethod {\n+\n+    private final Method method;\n+\n+    public DelegatingMockitoMethod(Method method) {\n+        this.method = method;\n+    }\n+\n+    public Class<?>[] getExceptionTypes() {\n+        return method.getExceptionTypes();\n+    }\n+\n+    public String getName() {\n+        return method.getName();\n+    }\n+\n+    public Class<?>[] getParameterTypes() {\n+        return method.getParameterTypes();\n+    }\n+\n+    public Class<?> getReturnType() {\n+        return method.getReturnType();\n+    }\n+\n+    public boolean isVarArgs() {\n+        return method.isVarArgs();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        throw new RuntimeException(\"hashCode() not implemented\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        DelegatingMockitoMethod other = (DelegatingMockitoMethod) obj;\n+        if (method == null) {\n+            if (other.method != null)\n+                return false;\n+        } else if (!method.equals(other.method))\n+            return false;\n+        return true;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n  */\n package org.mockito.internal.invocation;\n \n-import java.lang.reflect.Method;\n import java.util.*;\n \n import org.hamcrest.Matcher;\n \n     final RealMethod realMethod;\n \n-    public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, RealMethod realMethod) {\n-        this.method = new MockitoMethod(method);\n+    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n+        this.method = mockitoMethod;\n         this.mock = mock;\n         this.realMethod = realMethod;\n-        this.arguments = expandVarArgs(method.isVarArgs(), args);\n+        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n         this.rawArguments = args;\n         this.sequenceNumber = sequenceNumber;\n         this.location = new Location();\n         return mock;\n     }\n \n-    public Method getMethod() {\n-        return method.getMethod();\n+    public MockitoMethod getMethod() {\n+        return method;\n     }\n \n     public Object[] getArguments() {\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n package org.mockito.internal.invocation;\n \n import java.io.Serializable;\n-import java.lang.reflect.Method;\n import java.util.Collections;\n import java.util.List;\n \n         this(invocation, Collections.<Matcher>emptyList());\n     }\n \n-    public Method getMethod() {\n+    public MockitoMethod getMethod() {\n         return invocation.getMethod();\n     }\n     \n--- a/src/org/mockito/internal/invocation/MockitoMethod.java\n+++ b/src/org/mockito/internal/invocation/MockitoMethod.java\n package org.mockito.internal.invocation;\n \n-import java.io.Serializable;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n+public interface MockitoMethod {\n \n-import org.mockito.exceptions.base.MockitoException;\n+  Class<?> getReturnType();\n \n-public class MockitoMethod implements Serializable {\n+  Class<?>[] getParameterTypes();\n \n-    private static final long serialVersionUID = 6005610965006048445L;\n-    private Class<?> declaringClass;\n-    private String methodName;\n-    private Class<?>[] parameterTypes;\n-    private Class<?> returnType;\n+  String getName();\n \n-    public MockitoMethod(Method method) {\n-        declaringClass = method.getDeclaringClass();\n-        methodName = method.getName();\n-        parameterTypes = method.getParameterTypes();\n-        returnType = method.getReturnType();\n-    }\n+  Class<?>[] getExceptionTypes();\n \n-    @Override\n-    public int hashCode() {\n-        throw new RuntimeException(\"hashCode() not implemented\");\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (this == obj)\n-            return true;\n-        if (obj == null)\n-            return false;\n-        if (getClass() != obj.getClass())\n-            return false;\n-        MockitoMethod other = (MockitoMethod) obj;\n-        if (declaringClass == null) {\n-            if (other.declaringClass != null)\n-                return false;\n-        } else if (!declaringClass.equals(other.declaringClass))\n-            return false;\n-        if (methodName == null) {\n-            if (other.methodName != null)\n-                return false;\n-        } else if (!methodName.equals(other.methodName))\n-            return false;\n-        if (!Arrays.equals(parameterTypes, other.parameterTypes))\n-            return false;\n-        if (returnType == null) {\n-            if (other.returnType != null)\n-                return false;\n-        } else if (!returnType.equals(other.returnType))\n-            return false;\n-        return true;\n-    }\n-\n-    public Method getMethod() {\n-        try {\n-            return declaringClass.getDeclaredMethod(methodName, parameterTypes);\n-        } catch (SecurityException e) {\n-            String message = String.format(\n-                    \"The method %1$s.%2$s is probably private or protected and cannot be mocked.\", declaringClass, methodName);\n-            throw new MockitoException(message, e);\n-        } catch (NoSuchMethodException e) {\n-            String message = String.format(\n-                    \"The method %1$s.%2$s does not exists and you should not get to this point.\\n\" +\n-                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n-            throw new MockitoException(message, e);\n-        }\n-    }\n-\n-    public String getName() {\n-        return methodName;\n-    }\n-\n-    public Class<?> getReturnType() {\n-        return returnType;\n-    }\n+  boolean isVarArgs();\n \n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/SerializableMockitoMethod.java\n+package org.mockito.internal.invocation;\n+\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+public class SerializableMockitoMethod implements MockitoMethod, Serializable {\n+\n+    private static final long serialVersionUID = 6005610965006048445L;\n+    private Class<?> declaringClass;\n+    private String methodName;\n+    private Class<?>[] parameterTypes;\n+    private Class<?> returnType;\n+    private Class<?>[] exceptionTypes;\n+    private boolean isVarArgs;\n+\n+    public SerializableMockitoMethod(Method method) {\n+        declaringClass = method.getDeclaringClass();\n+        methodName = method.getName();\n+        parameterTypes = method.getParameterTypes();\n+        returnType = method.getReturnType();\n+        exceptionTypes = method.getExceptionTypes();\n+        isVarArgs = method.isVarArgs();\n+    }\n+\n+    public String getName() {\n+      return methodName;\n+    }\n+    \n+    public Class<?> getReturnType() {\n+      return returnType;\n+    }\n+    \n+    public Class<?>[] getParameterTypes() {\n+      return parameterTypes;\n+    }\n+\n+    public Class<?>[] getExceptionTypes() {\n+      return exceptionTypes;\n+    }\n+\n+    public boolean isVarArgs() {\n+      return isVarArgs;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        throw new RuntimeException(\"hashCode() not implemented\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        SerializableMockitoMethod other = (SerializableMockitoMethod) obj;\n+        if (declaringClass == null) {\n+            if (other.declaringClass != null)\n+                return false;\n+        } else if (!declaringClass.equals(other.declaringClass))\n+            return false;\n+        if (methodName == null) {\n+            if (other.methodName != null)\n+                return false;\n+        } else if (!methodName.equals(other.methodName))\n+            return false;\n+        if (!Arrays.equals(parameterTypes, other.parameterTypes))\n+            return false;\n+        if (returnType == null) {\n+            if (other.returnType != null)\n+                return false;\n+        } else if (!returnType.equals(other.returnType))\n+            return false;\n+        return true;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n  */\n package org.mockito.internal.invocation.realmethod;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.creation.MockitoMethodProxy;\n \n \n     }\n \n     public Object invoke(Object target, Object[] arguments) throws Throwable {\n-        return methodProxy.getMethodProxy().invokeSuper(target, arguments);\n+        return methodProxy.invokeSuper(target, arguments);\n     }\n \n-    public MethodProxy getMethodProxy() {\n-        return methodProxy.getMethodProxy();\n+    public MockitoMethodProxy getMethodProxy() {\n+        return methodProxy;\n     }\n }\n--- a/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n  */\n package org.mockito.internal.invocation.realmethod;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n         }\n     }\n \n-    public MethodProxy getMethodProxy() {\n+    public MockitoMethodProxy getMethodProxy() {\n         return ((HasCGLIBMethodProxy) realMethod).getMethodProxy();\n     }\n }\n--- a/src/org/mockito/internal/invocation/realmethod/HasCGLIBMethodProxy.java\n+++ b/src/org/mockito/internal/invocation/realmethod/HasCGLIBMethodProxy.java\n \n import java.io.Serializable;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n \n public interface HasCGLIBMethodProxy extends Serializable {\n \n-    MethodProxy getMethodProxy();\n+    MockitoMethodProxy getMethodProxy();\n }\n--- a/src/org/mockito/internal/util/ObjectMethodsGuru.java\n+++ b/src/org/mockito/internal/util/ObjectMethodsGuru.java\n \n import java.lang.reflect.Method;\n import java.io.Serializable;\n+\n+import org.mockito.internal.invocation.DelegatingMockitoMethod;\n+import org.mockito.internal.invocation.MockitoMethod;\n \n public class ObjectMethodsGuru implements Serializable {\n \n     private static final long serialVersionUID = -1286718569065470494L;\n \n     public boolean isToString(Method method) {\n+        return isToString(new DelegatingMockitoMethod(method));\n+    }\n+\n+    public boolean isToString(MockitoMethod method) {\n         return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n                 && method.getName().equals(\"toString\");\n     }\n--- a/src/org/mockito/invocation/InvocationOnMock.java\n+++ b/src/org/mockito/invocation/InvocationOnMock.java\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n+\n+import org.mockito.internal.invocation.MockitoMethod;\n \n /**\n  * An invocation on a mock\n      * \n      * @return method\n      */\n-    Method getMethod();\n+    MockitoMethod getMethod();\n \n     /**\n      * returns arguments passed to the method\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n  */\n package org.mockito.internal;\n \n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.lang.reflect.Method;\n+\n import org.junit.Test;\n+import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.creation.*;\n+import org.mockito.internal.invocation.*;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockitoutil.TestBase;\n-\n @SuppressWarnings({\"unchecked\",\"serial\"})\n public class MockHandlerTest extends TestBase {\n     \n         \n         assertNull(handler.mockingProgress.pullVerificationMode());\n     }\n+    \n+    @Test\n+    public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {\n+        MockSettingsImpl mockSettings = (MockSettingsImpl) withSettings().serializable();\n+        MockHandler handler = new MockHandler(null, null, null, mockSettings);\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = handler.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {\n+        MockHandler handler = new MockHandler(null, null, null, (MockSettingsImpl) withSettings());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = handler.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {\n+        // given\n+        MockSettingsImpl mockSettings = (MockSettingsImpl) withSettings().serializable();\n+        MockHandler handler = new MockHandler(null, null, null, mockSettings);\n+        Method method = getClass().getMethod(\"toString\", new Class<?>[0]);\n+        \n+        // when\n+        MockitoMethod mockitoMethod = handler.createMockitoMethod(method);\n+        \n+        // then\n+        assertThat(mockitoMethod, instanceOf(SerializableMockitoMethod.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateNONSerializableMethodIfIsNotSerializableMock() throws Exception {\n+        // given\n+        MockSettingsImpl mockSettings = (MockSettingsImpl) withSettings();\n+        MockHandler handler = new MockHandler(null, null, null, mockSettings);\n+        Method method = getClass().getMethod(\"toString\", new Class<?>[0]);\n+        \n+        // when\n+        MockitoMethod mockitoMethod = handler.createMockitoMethod(method);\n+        \n+        // then\n+        assertThat(mockitoMethod, instanceOf(DelegatingMockitoMethod.class));\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/SerializableMockitoMethodProxyTest.java\n+package org.mockito.internal.creation;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockitoutil.TestBase;\n+import org.powermock.reflect.Whitebox;\n+\n+public class SerializableMockitoMethodProxyTest extends TestBase {\n+\n+    @Test\n+    public void shouldCreateCorrectCreationInfo() throws Exception {\n+        // given\n+        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"\", \"\", \"\");\n+        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);\n+\n+        // when\n+        Object methodProxy = Whitebox.invokeMethod(serializableMockitoMethodProxy, \"getMethodProxy\",  new Object[0]);\n+\n+        // then\n+        Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        assertEquals(String.class, Whitebox.getInternalState(info, \"c1\"));\n+        assertEquals(Integer.class, Whitebox.getInternalState(info, \"c2\"));\n+    }\n+\n+    @Test\n+    public void shouldCreateCorrectSignatures() throws Exception {\n+        // given\n+        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"a\", \"b\", \"c\");\n+        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);\n+\n+        // when\n+        MethodProxy methodProxy = (MethodProxy) Whitebox.invokeMethod(serializableMockitoMethodProxy, \"getMethodProxy\",  new Object[0]);\n+\n+        // then\n+        assertEquals(\"a\", methodProxy.getSignature().getDescriptor());\n+        assertEquals(\"b\", methodProxy.getSignature().getName());\n+        assertEquals(\"c\", methodProxy.getSuperName());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SerializableMockitoMethodProxyTest []\";\n+    }\n+\n+}\n--- a/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n+++ b/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n  */\n package org.mockito.internal.creation.cglib;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.spy;\n \n import org.junit.Test;\n import org.mockito.cglib.core.NamingPolicy;\n-import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockitoutil.TestBase;\n import org.powermock.reflect.Whitebox;\n \n     @Test\n     public void shouldSetMockitoNamingPolicy() throws Exception {\n         //given\n-        MethodProxy methodProxy = new MethodProxyBuilder().build();\n+        MockitoMethodProxy methodProxy = new MethodProxyBuilder().build();\n         \n         //when\n         new CGLIBHacker().setMockitoNamingPolicy(methodProxy);\n         \n         //then\n-        Object createInfo = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        Object realMethodProxy = Whitebox.invokeMethod(methodProxy, \"getMethodProxy\", new Object[0]);\n+        Object createInfo = Whitebox.getInternalState(realMethodProxy, \"createInfo\");\n         NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, \"namingPolicy\");\n-        assertEquals(namingPolicy, MockitoNamingPolicy.INSTANCE);\n+        assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);\n     }\n     \n     @Test\n     public void shouldSetMockitoNamingPolicyEvenIfMethodProxyIsProxied() throws Exception {\n         //given\n-        MethodProxy proxiedMethodProxy = spy(new MethodProxyBuilder().build());\n+        MockitoMethodProxy proxiedMethodProxy = spy(new MethodProxyBuilder().build());\n         \n         //when\n         new CGLIBHacker().setMockitoNamingPolicy(proxiedMethodProxy);\n         \n         //then\n-        Object createInfo = Whitebox.getInternalState(proxiedMethodProxy, \"createInfo\");\n+        Object realMethodProxy = Whitebox.invokeMethod(proxiedMethodProxy, \"getMethodProxy\", new Object[0]);\n+        Object createInfo = Whitebox.getInternalState(realMethodProxy, \"createInfo\");\n         NamingPolicy namingPolicy = (NamingPolicy) Whitebox.getInternalState(createInfo, \"namingPolicy\");\n-        assertEquals(namingPolicy, MockitoNamingPolicy.INSTANCE);\n+        assertEquals(MockitoNamingPolicy.INSTANCE, namingPolicy);\n     }\n }\n--- a/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n+++ b/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n  */\n package org.mockito.internal.creation.cglib;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.ExposedInvocation;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.invocation.InvocationOnMock;\n @SuppressWarnings(\"serial\")\n public class MethodProxyBuilder {\n \n-    public MethodProxy build() {\n+    public MockitoMethodProxy build() {\n         IMethods mock = mock(IMethods.class);\n         when(mock.objectReturningMethodNoArgs()).thenAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n--- a/test/org/mockito/internal/invocation/ExposedInvocation.java\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n  */\n package org.mockito.internal.invocation;\n \n-import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.realmethod.HasCGLIBMethodProxy;\n \n public class ExposedInvocation {\n \n-    private final MethodProxy methodProxy;\n+    private final MockitoMethodProxy methodProxy;\n \n     public ExposedInvocation(Invocation toBeExposed) {\n          methodProxy = ((HasCGLIBMethodProxy) toBeExposed.realMethod).getMethodProxy();\n     }\n \n-    public MethodProxy getMethodProxy() {\n+    public MockitoMethodProxy getMethodProxy() {\n         return methodProxy;\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n             }\n         }\n         \n-        Invocation i = new Invocation(mock, method, args, sequenceNumber, null);\n+        Invocation i = new Invocation(mock, new DelegatingMockitoMethod(method), args, sequenceNumber, null);\n         if (verified) {\n             i.markVerified();\n         }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/SerializableMockitoMethodTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class SerializableMockitoMethodTest extends TestBase {\n+\n+    private SerializableMockitoMethod mockMethod;\n+    private Method toStringMethod;\n+    private Class<?>[] args;\n+\n+    @Before\n+    public void createMethodToTestWith() throws SecurityException, NoSuchMethodException {\n+        args = new Class<?>[0];\n+        toStringMethod = this.getClass().getMethod(\"toString\", args);\n+        mockMethod = new SerializableMockitoMethod(toStringMethod);\n+    }\n+    \n+    @Test\n+    public void shouldBeSerializable() throws Exception {\n+        ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n+        new ObjectOutputStream(serialized).writeObject(mockMethod);\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToRetrieveMethodExceptionTypes() throws Exception {\n+        assertArrayEquals(toStringMethod.getExceptionTypes(), mockMethod.getExceptionTypes());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToRetrieveMethodName() throws Exception {\n+        assertEquals(toStringMethod.getName(), mockMethod.getName());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToCheckIsArgVargs() throws Exception {\n+        assertEquals(toStringMethod.isVarArgs(), mockMethod.isVarArgs());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToGetParameterTypes() throws Exception {\n+        assertArrayEquals(toStringMethod.getParameterTypes(), mockMethod.getParameterTypes());\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToGetReturnType() throws Exception {\n+        assertEquals(toStringMethod.getReturnType(), mockMethod.getReturnType());\n+    }\n+    \n+    @Test\n+    public void shouldBeEqualForTwoInstances() throws Exception {\n+        assertTrue(new SerializableMockitoMethod(toStringMethod).equals(mockMethod));\n+    }\n+    \n+    @Test\n+    public void shouldNotBeEqualForSameMethodFromTwoDifferentClasses() throws Exception {\n+        Method testBaseToStringMethod = String.class.getMethod(\"toString\", args);\n+        assertFalse(new SerializableMockitoMethod(testBaseToStringMethod).equals(mockMethod));\n+    }\n+    \n+}\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n  */\n package org.mockitousage.basicapi;\n \n-import static org.mockito.Matchers.anyObject;\n-import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.*;\n \n import java.io.*;\n     @Test\n     public void shouldAllowMockToBeSerializable() throws Exception {\n         // given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n \n         // when-serialize then-deserialize\n         serializeAndBack(mock);\n     @Test\n     public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {\n         // given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         when(mock.booleanReturningMethod()).thenReturn(true);\n \n         // when\n     @Test\n     public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {\n         // given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         String value = \"value\";\n         when(mock.stringReturningMethod()).thenReturn(value);\n \n     @Test\n     public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {\n         // given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectReturningMethodNoArgs()).thenReturn(value);\n \n \n     @Test\n     public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(value)).thenReturn(value);\n \n \n     @Test\n     public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n \n \n     @Test\n     public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n         mock.objectArgMethod(\"\");\n     @Test\n     public void shouldVerifyEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n         //given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n \n         // when\n         mock.simpleMethod(1);\n     @Test\n     public void shouldStubEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n         //given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n \n         // when\n         when(mock.simpleMethod(1)).thenReturn(\"foo\");\n \n     @Test\n     public void shouldVerifyCallOrderForSerializedMock() throws Exception {\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-        IMethods mock2 = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n+        IMethods mock2 = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         mock.arrayReturningMethod();\n         mock2.arrayReturningMethod();\n \n \n     @Test\n     public void shouldRememberInteractionsForSerializedMock() throws Exception {\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n         mock.objectArgMethod(\"happened\");\n     public void shouldSerializeWithStubbingCallback() throws Exception {\n \n         // given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class).serializable());\n         final String string = \"return value\";\n         when(mock.objectArgMethod(anyString())).thenAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) {\n         assertEquals(string, readObject.objectArgMethod(\"\"));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     @Test\n     public void shouldSerializeWithRealObjectSpy() throws Exception {\n         // given\n         List<Object> list = new ArrayList<Object>();\n-        List<Object> spy = spy(list);\n+        List<Object> spy = mock(ArrayList.class, withSettings()\n+                        .spiedInstance(list)\n+                        .defaultAnswer(CALLS_REAL_METHODS)\n+                        .serializable());\n         when(spy.size()).thenReturn(100);\n \n         // when\n     @Test\n     public void shouldSerializeRealPartialMock() throws Exception {\n         // given\n-        Any mock = mock(Any.class);\n+        Any mock = mock(Any.class, withSettings().serializable());\n         when(mock.matches(anyObject())).thenCallRealMethod();\n \n         // when\n--- a/test/org/mockitousage/basicapi/ObjectsSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/ObjectsSerializationTest.java\n  */\n package org.mockitousage.basicapi;\n \n-import static org.mockito.Matchers.anyObject;\n-import static org.mockito.Matchers.anyString;\n-import static org.mockito.Mockito.*;\n-\n-import java.io.*;\n-import java.util.*;\n+import java.io.Serializable;\n \n import org.junit.Test;\n-import org.mockito.InOrder;\n-import org.mockito.internal.matchers.Any;\n-import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.stubbing.Answer;\n-import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+@SuppressWarnings(\"serial\")\n public class ObjectsSerializationTest extends TestBase implements Serializable {\n \n     //Ok, this test has nothing to do with mocks but it shows fundamental feature of java serialization that\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.StateMaster;\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.configuration.ConfigurationAccess;\n-import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.*;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n \n import java.io.*;\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n-        return new Invocation(new Object(), type.getMethod(methodName,\n-                new Class[0]), args, 1, null);\n+        return new Invocation(new Object(), new DelegatingMockitoMethod(type.getMethod(methodName,\n+                new Class[0])), args, 1, null);\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n-        return new Invocation(new Object(), type.getMethod(methodName,\n-                new Class[0]), new Object[0], 1, realMethod);\n+        return new Invocation(new Object(), new DelegatingMockitoMethod(type.getMethod(methodName,\n+                new Class[0])), new Object[0], 1, realMethod);\n     }\n \n     protected static String describe(SelfDescribing m) {\n         return StringDescription.toString(m);\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     protected <T> T serializeAndBack(T obj) throws Exception {\n         ByteArrayOutputStream os = this.serializeMock(obj);\n         return (T) this.deserializeMock(os, Object.class);", "timestamp": 1257418131, "metainfo": ""}