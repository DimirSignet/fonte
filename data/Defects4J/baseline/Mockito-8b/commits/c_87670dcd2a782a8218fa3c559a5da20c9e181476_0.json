{"sha": "87670dcd2a782a8218fa3c559a5da20c9e181476", "log": "Renamed Location so that we can hoist up an interface to the public api.  --HG-- rename : src/org/mockito/internal/debugging/Location.java => src/org/mockito/internal/debugging/LocationImpl.java", "commit": "\n--- a/src/org/mockito/exceptions/PrintableInvocation.java\n+++ b/src/org/mockito/exceptions/PrintableInvocation.java\n \n package org.mockito.exceptions;\n \n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n \n public interface PrintableInvocation {\n     \n     String toString();\n     \n-    Location getLocation();\n+    LocationImpl getLocation();\n     \n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockito.exceptions.verification.junit.JUnitTool;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n \n     }\n \n-    public void unfinishedStubbing(Location location) {\n+    public void unfinishedStubbing(LocationImpl location) {\n         throw new UnfinishedStubbingException(join(\n                 \"Unfinished stubbing detected here:\",\n                 location,\n     public void incorrectUseOfApi() {\n         throw new MockitoException(join(\n                 \"Incorrect use of API detected here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"\",\n                 \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n                 \"Examples of correct usage:\",\n         ));\n     }\n \n-    public void unfinishedVerificationException(Location location) {\n+    public void unfinishedVerificationException(LocationImpl location) {\n         UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n                 \"Missing method call for verify(mock) here:\",\n                 location,\n     public void incorrectUseOfAdditionalMatchers(String additionalMatcherName, int expectedSubMatchersCount, Collection<LocalizedMatcher> matcherStack) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Invalid use of argument matchers inside additional matcher \" + additionalMatcherName + \" !\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"\",\n                 expectedSubMatchersCount + \" sub matchers expected, \" + matcherStack.size() + \" recorded:\",\n                 locationsOf(matcherStack),\n     public void reportNoSubMatchersFound(String additionalMatcherName) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"No matchers found for additional matcher \" + additionalMatcherName,\n-                new Location(),\n+                new LocationImpl(),\n                 \"\"\n         ));\n     }\n         return join(description.toArray());\n     }\n \n-    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n+    public void argumentsAreDifferent(String wanted, String actual, LocationImpl actualLocation) {\n         String message = join(\"Argument(s) are different! Wanted:\",\n                 wanted,\n-                new Location(),\n+                new LocationImpl(),\n                 \"Actual invocation has different arguments:\",\n                 actual,\n                 actualLocation,\n         return join(\n                 \"Wanted but not invoked:\",\n                 wanted.toString(),\n-                new Location(),\n+                new LocationImpl(),\n                 \"\"\n         );\n     }\n                     \"Verification in order failure\",\n                     \"Wanted but not invoked:\",\n                     wanted.toString(),\n-                    new Location(),\n+                    new LocationImpl(),\n                     \"Wanted anywhere AFTER following interaction:\",\n                     previous.toString(),\n                     previous.getLocation(),\n         ));\n     }\n \n-    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n+    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, LocationImpl firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new TooManyActualInvocations(message);\n     }\n \n     private String createTooManyInvocationsMessage(int wantedCount, int actualCount, PrintableInvocation wanted,\n-            Location firstUndesired) {\n+            LocationImpl firstUndesired) {\n         return join(\n                 wanted.toString(),\n                 \"Wanted \" + Pluralizer.pluralize(wantedCount) + \":\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n                 firstUndesired,\n                 \"\"\n         );\n     }\n \n-    public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n+    public void neverWantedButInvoked(PrintableInvocation wanted, LocationImpl firstUndesired) {\n         throw new NeverWantedButInvoked(join(\n                 wanted.toString(),\n                 \"Never wanted here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But invoked here:\",\n                 firstUndesired,\n                 \"\"\n         ));\n     }\n \n-    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n+    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, LocationImpl firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n     }\n \n     private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n-            Location lastActualInvocation) {\n+            LocationImpl lastActualInvocation) {\n         String ending =\n             (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n \n             String message = join(\n                     wanted.toString(),\n                     \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n-                    new Location(),\n+                    new LocationImpl(),\n                     \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                     ending\n             );\n             return message;\n     }\n \n-    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, LocationImpl lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n \n         throw new TooLittleActualInvocations(message);\n     }\n \n-    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, LocationImpl lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n \n         throw new VerificationInOrderFailure(join(\n \n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But found this interaction:\",\n                 undesired.getLocation(),\n                 scenario\n     public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"But found this interaction:\",\n                 undesired.getLocation(),\n                 \"\"\n                 ));\n     }\n \n-    public void smartNullPointerException(String invocation, Location location) {\n+    public void smartNullPointerException(String invocation, LocationImpl location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n-                new Location(),\n+                new LocationImpl(),\n                 \"because this method call was *not* stubbed correctly:\",\n                 location,\n                 invocation,\n--- a/src/org/mockito/internal/debugging/Localized.java\n+++ b/src/org/mockito/internal/debugging/Localized.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n \n public class Localized<T> {\n \n     private final T object;\n-    private final Location location;\n+    private final LocationImpl location;\n \n     public Localized(T object) {\n         this.object = object;\n-        location = new Location();\n+        location = new LocationImpl();\n     }\n \n     public T getObject() {\n         return object;\n     }\n \n-    public Location getLocation() {\n+    public LocationImpl getLocation() {\n         return location;\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/LocationImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.debugging;\n+\n+import java.io.Serializable;\n+\n+import org.mockito.internal.exceptions.base.StackTraceFilter;\n+\n+public class LocationImpl implements Serializable {\n+\n+    private static final long serialVersionUID = -9054861157390980624L;\n+    private final Throwable stackTraceHolder;\n+    private final StackTraceFilter stackTraceFilter;\n+\n+    public LocationImpl() {\n+        this(new StackTraceFilter());\n+    }\n+\n+    public LocationImpl(StackTraceFilter stackTraceFilter) {\n+        this.stackTraceFilter = stackTraceFilter;\n+        stackTraceHolder = new Throwable();\n+    }\n+\t\n+    @Override\n+    public String toString() {\n+        StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);\n+        if (filtered.length == 0) {\n+            return \"-> at <<unknown line>>\";\n+        }\n+        return \"-> at \" + filtered[0].toString();\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n \n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.reporting.PrintSettings;\n     private final Object[] arguments;\n     private final Object[] rawArguments;\n \n-    private final Location location;\n+    private final LocationImpl location;\n     private boolean verified;\n     private boolean isIgnoredForVerification;\n \n         this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);\n         this.rawArguments = args;\n         this.sequenceNumber = sequenceNumber;\n-        this.location = new Location();\n+        this.location = new LocationImpl();\n     }\n \n     public Object getMock() {\n         return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);\n     }\n \n-    public Location getLocation() {\n+    public LocationImpl getLocation() {\n         return location;\n     }\n \n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.internal.reporting.PrintSettings;\n \n         return false;\n     }\n     \n-    public Location getLocation() {\n+    public LocationImpl getLocation() {\n         return invocation.getLocation();\n     }\n \n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.internal.verification.api.InOrderContext;\n         return null;\n     }\n \n-    public Location getLastLocation(List<Invocation> invocations) {\n+    public LocationImpl getLastLocation(List<Invocation> invocations) {\n         if (invocations.isEmpty()) {\n             return null;\n         } else {\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.matchers;\n \n import java.io.Serializable;\n \n import org.hamcrest.*;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n \n @SuppressWarnings(\"unchecked\")\n public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator, Serializable {\n \n     private static final long serialVersionUID = 6748641229659825725L;\n     private final Matcher actualMatcher;\n-    private Location location;\n+    private LocationImpl location;\n \n     public LocalizedMatcher(Matcher actualMatcher) {\n         this.actualMatcher = actualMatcher;\n-        this.location = new Location();\n+        this.location = new LocationImpl();\n     }\n \n     public void _dont_implement_Matcher___instead_extend_BaseMatcher_() {\n         actualMatcher.describeTo(description);\n     }\n \n-    public Location getLocation() {\n+    public LocationImpl getLocation() {\n         return location;\n     }\n     \n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.Localized;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.internal.listeners.MockingStartedListener;\n     \n     IOngoingStubbing iOngoingStubbing;\n     private Localized<VerificationMode> verificationMode;\n-    private Location stubbingInProgress = null;\n+    private LocationImpl stubbingInProgress = null;\n     private MockingProgressListener listener;\n \n     public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n \n     public void stubbingStarted() {\n         validateState();\n-        stubbingInProgress = new Location();\n+        stubbingInProgress = new LocationImpl();\n     }\n \n     public void validateState() {\n         \n         //validate stubbing:\n         if (stubbingInProgress != null) {\n-            Location temp = stubbingInProgress;\n+            LocationImpl temp = stubbingInProgress;\n             stubbingInProgress = null;\n             reporter.unfinishedStubbing(temp);\n         }\n         GlobalConfiguration.validate();\n \n         if (verificationMode != null) {\n-            Location location = verificationMode.getLocation();\n+            LocationImpl location = verificationMode.getLocation();\n             verificationMode = null;\n             reporter.unfinishedVerificationException(location);\n         }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n \n import org.mockito.Mockito;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.plugins.MockMaker;\n import org.mockito.internal.configuration.ClassPathLoader;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.invocation.InvocationOnMock;\n \n     private final class ThrowingInterceptor implements MockitoInvocationHandler {\n         private final InvocationOnMock invocation;\n-        private final Location location = new Location();\n+        private final LocationImpl location = new LocationImpl();\n \n         private ThrowingInterceptor(InvocationOnMock invocation) {\n             this.invocation = invocation;\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            Location lastLocation = finder.getLastLocation(actualInvocations);\n+            LocationImpl lastLocation = finder.getLastLocation(actualInvocations);\n             reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        \n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            Location lastLocation = finder.getLastLocation(chunk);\n+            LocationImpl lastLocation = finder.getLastLocation(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n     \n     public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n         int actualCount = 0;\n-        Location lastLocation = null;\n+        LocationImpl lastLocation = null;\n         while( actualCount < wantedCount ){\n             Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n             if( next == null ){\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationMarker;\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            Location lastInvocation = finder.getLastLocation(actualInvocations);\n+            LocationImpl lastInvocation = finder.getLastLocation(actualInvocations);\n             reporter.tooLittleActualInvocations(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount == 0 && actualCount > 0) {\n-            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n+            LocationImpl firstUndesired = actualInvocations.get(wantedCount).getLocation();\n             reporter.neverWantedButInvoked(wanted, firstUndesired); \n         } else if (wantedCount < actualCount) {\n-            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n+            LocationImpl firstUndesired = actualInvocations.get(wantedCount).getLocation();\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMarker;\n import org.mockito.internal.invocation.InvocationMatcher;\n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            Location lastInvocation = finder.getLastLocation(chunk);\n+            LocationImpl lastInvocation = finder.getLastLocation(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount < actualCount) {\n-            Location firstUndesired = chunk.get(wantedCount).getLocation();\n+            LocationImpl firstUndesired = chunk.get(wantedCount).getLocation();\n             reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n--- a/src/org/mockito/invocation/PublicInvocation.java\n+++ b/src/org/mockito/invocation/PublicInvocation.java\n package org.mockito.invocation;\n \n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.StubInfo;\n \n /**\n \n     int getSequenceNumber();\n \n-    Location getLocation();\n+    LocationImpl getLocation();\n \n     Object[] getRawArguments();\n \n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.verification.InOrderContextImpl;\n import org.mockito.internal.verification.api.InOrderContext;\n import org.mockitousage.IMethods;\n     \n     @Test\n     public void shouldGetLastStackTrace() throws Exception {\n-        Location last = finder.getLastLocation(invocations);\n+        LocationImpl last = finder.getLastLocation(invocations);\n         assertSame(differentMethodInvocation.getLocation(), last);\n         \n         assertNull(finder.getLastLocation(Collections.<Invocation>emptyList()));\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n     class ReporterStub extends Reporter {\n         private Object wanted;\n         private String actual;\n-        private Location actualLocation;\n+        private LocationImpl actualLocation;\n         \n         @Override\n         public void wantedButNotInvoked(PrintableInvocation wanted, List<? extends PrintableInvocation> invocations) {\n             this.wanted = wanted;\n         }\n         \n-        @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n+        @Override public void argumentsAreDifferent(String wanted, String actual, LocationImpl actualLocation) {\n                     this.wanted = wanted;\n                     this.actual = actual;\n                     this.actualLocation = actualLocation;\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         private PrintableInvocation previous;\n         private String wantedString;\n         private String actual;\n-        private Location actualLocation;\n+        private LocationImpl actualLocation;\n         \n         @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n             this.wanted = wanted;\n             this.wanted = wanted;\n         }\n \n-        @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n+        @Override public void argumentsAreDifferent(String wanted, String actual, LocationImpl actualLocation) {\n             this.wantedString = wanted;\n             this.actual = actual;\n             this.actualLocation = actualLocation;\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         private int wantedCount;\n         private int actualCount;\n         private PrintableInvocation wanted;\n-        private Location location;\n-        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+        private LocationImpl location;\n+        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, LocationImpl lastActualLocation) {\n                     this.wantedCount = discrepancy.getWantedCount();\n                     this.actualCount = discrepancy.getActualCount();\n                     this.wanted = wanted;\n                     this.location = lastActualLocation;\n         }\n         \n-        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n+        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, LocationImpl firstUndesired) {\n                     this.wantedCount = wantedCount;\n                     this.actualCount = actualCount;\n                     this.wanted = wanted;\n         }\n         \n         @Override\n-        public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n+        public void neverWantedButInvoked(PrintableInvocation wanted, LocationImpl firstUndesired) {\n             this.wanted = wanted;\n             this.location = firstUndesired;\n         }\n--- a/test/org/mockitousage/internal/debugging/LocationTest.java\n+++ b/test/org/mockitousage/internal/debugging/LocationTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.internal.debugging;\n \n import org.junit.Test;\n-import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.base.StackTraceFilter;\n import org.mockitoutil.TestBase;\n \n \n     @Test\n     public void shouldLocationNotContainGetStackTraceMethod() {\n-        assertContains(\"shouldLocationNotContainGetStackTraceMethod\", new Location().toString());\n+        assertContains(\"shouldLocationNotContainGetStackTraceMethod\", new LocationImpl().toString());\n     }\n \n     @Test\n         };\n \n         //when\n-        String loc = new Location(filterReturningEmptyArray).toString();\n+        String loc = new LocationImpl(filterReturningEmptyArray).toString();\n \n         //then\n         assertEquals(\"-> at <<unknown line>>\", loc);", "timestamp": 1333231192, "metainfo": ""}