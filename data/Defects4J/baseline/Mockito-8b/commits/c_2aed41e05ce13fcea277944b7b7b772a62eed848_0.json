{"sha": "2aed41e05ce13fcea277944b7b7b772a62eed848", "log": "massive checkin (worked in the plane :DDDD) -added javdoc for examples how to configure mockito -annotation style of creating mocks has additional benefit now: it uses the name of the field to print verification errors. -refactored the rest of matchers to assertors  --HG-- rename : src/org/mockito/internal/creation/MockNamer.java => src/org/mockito/internal/creation/ClassNameFinder.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40531", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * \n  * <h3>Shorthand for mocks creation - &#064;Mock annotation</h3>\n  * \n+ * <ul>\n+ * <li>Minimizes repetitive mock creation code.</li> \n+ * <li>Makes the test class more readable.</li>\n+ * </ul>\n+ * \n  * <pre>\n  *   public class ArticleManagerTest { \n  *     \n  *       &#064;Mock private UserProvider userProvider;\n  *     \n  *       private ArticleManager manager;\n- *       \n- * </pre>\n- * \n- * <ul>\n- * <li>Minimizes repetitive mock creation code.</li> \n- * <li>Makes the test class more readable.</li>\n- * </ul>\n- *\n- * See examples in javadoc for {@link MockitoAnnotations}\n+ * </pre>\n+ * \n+ * <b>Important!</b> This needs to be somewhere in the test runner or a base class:\n+ *   \n+ * <pre>\n+ *   MockitoAnnotations.initMocks(testClass);\n+ * </pre>   \n+ * \n+ * Read more here: {@link MockitoAnnotations}\n  */\n+//TODO add javadoc how to do junit runner here and in mockito annotations\n public class Mockito extends Matchers {\n \n     private static final Reporter REPORTER = new Reporter();\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return MockUtil.createMock(classToMock, MOCKING_PROGRESS);\n+        return MockUtil.createMock(classToMock, null, MOCKING_PROGRESS);\n+    }\n+    \n+    static <T> T mock(Class<T> classToMock, String name) {\n+        return MockUtil.createMock(classToMock, name, MOCKING_PROGRESS);\n     }\n \n     /**\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n                 boolean wasAccessible = f.isAccessible();\n                 f.setAccessible(true);\n                 try {\n-                    f.set(testClass, Mockito.mock(f.getType()));\n+                    f.set(testClass, Mockito.mock(f.getType(), f.getName()));\n                 } catch (IllegalAccessException e) {\n                     throw new MockitoException(\"Problems initiating mocks annotated with @Mock\", e);\n                 } finally {\n--- a/src/org/mockito/configuration/BaseReturnValues.java\n+++ b/src/org/mockito/configuration/BaseReturnValues.java\n \n import org.mockito.invocation.InvocationOnMock;\n \n+/**\n+ * Handy implementation of {@link ReturnValues} that already deals with void types and default return values.\n+ * <p>\n+ * Intended for subclassing and providing implementation for {@link BaseReturnValues#returnValueFor(InvocationOnMock)}.\n+ * <p>\n+ * See examples from mockito/test/org/mockitousage/examples/configure subpackage. \n+ * You may want to check out the project from svn repository to easily browse Mockito's test code.\n+ */\n public abstract class BaseReturnValues implements ReturnValues {\n     \n     private DefaultReturnValues defaultReturnValues = new DefaultReturnValues();\n     \n+    /* (non-Javadoc)\n+     * @see org.mockito.configuration.ReturnValues#valueFor(org.mockito.invocation.InvocationOnMock)\n+     */\n     public Object valueFor(InvocationOnMock invocation) {\n         Object returnByDefault = defaultReturnValues.valueFor(invocation);\n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(invocation);\n     }\n \n+    /**\n+     * The default implementation already evaluated invocation and decided to return null.\n+     * Override this method to return different value than null. \n+     * \n+     * @param invocation\n+     * @return return value for an invocation\n+     */\n     protected abstract Object returnValueFor(InvocationOnMock invocation);\n }\n--- a/src/org/mockito/configuration/DefaultReturnValues.java\n+++ b/src/org/mockito/configuration/DefaultReturnValues.java\n import java.util.TreeMap;\n import java.util.TreeSet;\n \n-import org.mockito.internal.creation.MockNamer;\n+import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n- * Used by default by every Mockito mock\n+ * Used by default by every Mockito mock.\n+ * <ul>\n+ * <li>\n+ *  Returns appropriate primitive for primitive-returning methods\n+ * </li>\n+ * <li>\n+ *  Returns empty collection for collection-returning methods (works for most commonly used collection types)\n+ * </li>\n+ * <li>\n+ *  Returns description of mock for toString() method\n+ * </li>\n+ * <li>\n+ *  Returns null for everything else\n+ * </li>\n+ * </ul>\n  */\n public class DefaultReturnValues implements ReturnValues {\n     \n+    /* (non-Javadoc)\n+     * @see org.mockito.configuration.ReturnValues#valueFor(org.mockito.invocation.InvocationOnMock)\n+     */\n     public Object valueFor(InvocationOnMock invocation) {\n         if (Invocation.isToString(invocation)) {\n             Object mock = invocation.getMock();\n-            String mockDescription = \"Mock for \" + MockNamer.nameForMock(mock) + \", hashCode: \" + mock.hashCode();\n+            String mockDescription = \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n             return mockDescription;\n         }\n         \n     protected Object returnValueFor(Class<?> type) {\n         if (type.isPrimitive()) {\n             return primitiveOf(type);\n+        } else if (isPrimitiveWrapper(type)) {\n+            return primitiveWrapperOf(type);\n         //new instances are used instead of Collections.emptyList(), etc.\n         //to avoid UnsupportedOperationException if code under test modifies returned collection\n         } else if (type == Collection.class) {\n             return 0;\n         } \n     }\n+    \n+    private boolean isPrimitiveWrapper(Class<?> type) {\n+        return wrapperReturnValues.containsKey(type);\n+    }\n+    \n+    private Object primitiveWrapperOf(Class<?> type) {\n+        return wrapperReturnValues.get(type);\n+    }\n+    \n+    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n+    \n+    static {\n+        wrapperReturnValues.put(Boolean.class, Boolean.FALSE);\n+        wrapperReturnValues.put(Character.class, new Character((char) 0));\n+        wrapperReturnValues.put(Byte.class, new Byte((byte) 0));\n+        wrapperReturnValues.put(Short.class, new Short((short) 0));\n+        wrapperReturnValues.put(Integer.class, new Integer(0));\n+        wrapperReturnValues.put(Long.class, new Long(0));\n+        wrapperReturnValues.put(Float.class, new Float(0));\n+        wrapperReturnValues.put(Double.class, new Double(0));\n+    }\n }\n--- a/src/org/mockito/configuration/MockitoConfiguration.java\n+++ b/src/org/mockito/configuration/MockitoConfiguration.java\n \n import org.mockito.exceptions.base.MockitoException;\n \n+/**\n+ * Allows configuring Mockito to enable custom 'mocking style'. \n+ * It can be useful when working with legacy code, etc. \n+ * <p>\n+ * See examples from mockito/test/org/mockitousage/examples/configure subpackage. \n+ * You may want to check out the project from svn repository to easily browse Mockito's test code.\n+ * <p>\n+ * This class is thread-safe but every thread has own instance of configuration (ThreadLocal pattern).\n+ * <p>\n+ * Configuring mockito is a new concept that we evaluate. Please let us know if you find it useful. \n+ */\n public class MockitoConfiguration {\n     \n     private static final ThreadLocal<MockitoConfiguration> CONFIG = new ThreadLocal<MockitoConfiguration>();\n         resetReturnValues();\n     }\n     \n+    /**\n+     * @return instance of a configuration \n+     */\n     public static MockitoConfiguration instance() {\n         if (CONFIG.get() == null) {\n             CONFIG.set(new MockitoConfiguration());\n         return CONFIG.get();\n     }\n     \n+    /**\n+     * @return current {@link ReturnValues} implementation\n+     */\n     public ReturnValues getReturnValues() {\n         return returnValues;\n     }\n \n+    /**\n+     * Sets {@link ReturnValues} implementation. \n+     * Allows to change the default (unstubbed) values returned by mocks. \n+     * \n+     * @param returnValues\n+     */\n     public void setReturnValues(ReturnValues returnValues) {\n         if (returnValues == null) {\n             throw new MockitoException(\"Cannot set null ReturnValues!\");\n         this.returnValues = returnValues;\n     }\n \n+    /**\n+     * Resets {@link ReturnValues} implementation to the default one: {@link MockitoProperties#DEFAULT_RETURN_VALUES}\n+     */\n     public void resetReturnValues() {\n         returnValues = MockitoProperties.DEFAULT_RETURN_VALUES;\n     }\n--- a/src/org/mockito/configuration/MockitoProperties.java\n+++ b/src/org/mockito/configuration/MockitoProperties.java\n  */\n package org.mockito.configuration;\n \n+/**\n+ * Configuration properties \n+ */\n public class MockitoProperties {\n \n     public static final ReturnValues DEFAULT_RETURN_VALUES =  new DefaultReturnValues();\n--- a/src/org/mockito/configuration/ReturnValues.java\n+++ b/src/org/mockito/configuration/ReturnValues.java\n \n import org.mockito.invocation.InvocationOnMock;\n \n+/**\n+ * Configures return values for an unstubbed invocation\n+ */\n public interface ReturnValues {\n \n+    /**\n+     * @param invocation\n+     * @return default return value if no stubbed value found\n+     */\n     Object valueFor(InvocationOnMock invocation);\n-\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import net.sf.cglib.proxy.MethodProxy;\n \n import org.mockito.configuration.MockitoConfiguration;\n+import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.creation.MockAwareInterceptor;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n     private final Stubber stubber;\n     private final MatchersBinder matchersBinder;\n     private final MockingProgress mockingProgress;\n+    private final String mockName;\n     \n     private T mock;\n     \n-    public MockHandler(MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n+    public MockHandler(String mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder) {\n+        this.mockName = mockName;\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n         stubber = new Stubber(mockingProgress);\n         return verifyingRecorder.getRegisteredInvocations();\n     }\n     \n+    public String getMockName() {\n+        if (mockName != null) {\n+            return mockName;\n+        } else {\n+            return toInstanceName(ClassNameFinder.classNameForMock(mock));\n+        }\n+    }\n+    \n+    //lower case first letter\n+    private String toInstanceName(String className) {\n+        return className;\n+        //TODO enable and fix tests\n+//        return className.substring(0, 1).toLowerCase() + className.substring(1);\n+    }\n+\n     private VerifyingRecorder createRecorder() {\n         List<Verifier> verifiers = Arrays.asList(\n                 new MissingInvocationInOrderVerifier(),\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n \n public class MockUtil {\n     \n-    public static <T> T createMock(Class<T> classToMock, MockingProgress progress) {\n+    public static <T> T createMock(Class<T> classToMock, String mockName, MockingProgress progress) {\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n-        MockHandler<T> mockHandler = new MockHandler<T>(progress, new MatchersBinder());\n+        MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder());\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n         return proxyFactory.createMock(classToMock, filter);\n     }\n             return false;\n         }\n     }\n+\n+    public static String getMockName(Object mock) {\n+        return getMockHandler(mock).getMockName();\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/ClassNameFinder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+public class ClassNameFinder {\n+\n+    public static String classNameForMock(Object mock) {\n+        if (mock.getClass().getInterfaces().length == 2) {\n+            return mock.getClass().getInterfaces()[0].getSimpleName();\n+        } else {\n+            return mock.getClass().getSuperclass().getSimpleName();\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.creation.MockNamer;\n+import org.mockito.internal.MockUtil;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.invocation.InvocationOnMock;\n     }\n \n     private String qualifiedMethodName() {\n-        return MockNamer.nameForMock(mock) + \".\" + method.getName();\n+        //TODO this surely breaks sane dependencies between packages:\n+        String name = MockUtil.getMockName(mock);\n+        return name + \".\" + method.getName();\n     }\n \n     private String getArgumentsLine(List<Matcher> matchers) {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n         return ListUtil.filter(unverified, new RemoveNotMatching(wanted));\n     }\n \n+    /**\n+     * some examples how it works:\n+     * \n+     * Given invocations sequence:\n+     * 1,1,2,1\n+     * \n+     * if wanted is 1 and mode is times(2) then returns\n+     * 1,1  \n+     * \n+     * if wanted is 1 and mode is atLeastOnce() then returns\n+     * 1,1,1\n+     * \n+     * if wanted is 1 and mode is times(x), where x != 2 then returns\n+     * 1,1,1\n+     */\n     public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n         List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n-\n-import static org.mockito.internal.MockUtil.*;\n \n import java.util.ArrayList;\n import java.util.List;\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.MockUtil;\n \n public class MockUtilTest extends TestBase {\n \n     @Test \n     public void shouldGetHandler() {\n         List mock = Mockito.mock(List.class);\n-        assertNotNull(getMockHandler(mock));\n+        assertNotNull(MockUtil.getMockHandler(mock));\n     }\n \n     @Test \n     public void shouldScreamWhenEnhancedButNotAMockPassed() {\n         Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);\n         try {\n-            getMockHandler(o);\n+            MockUtil.getMockHandler(o);\n             fail();\n         } catch (NotAMockException e) {}\n     }\n \n     @Test (expected=NotAMockException.class)\n     public void shouldScreamWhenNotAMockPassed() {\n-        getMockHandler(\"\");\n+        MockUtil.getMockHandler(\"\");\n     }\n     \n     @Test (expected=MockitoException.class)\n     public void shouldScreamWhenNullPassed() {\n-        getMockHandler(null);\n+        MockUtil.getMockHandler(null);\n     }\n     \n     @Test\n     public void shouldValidateMock() {\n-        assertFalse(isMock(\"i mock a mock\"));\n-        assertTrue(isMock(Mockito.mock(List.class)));\n+        assertFalse(MockUtil.isMock(\"i mock a mock\"));\n+        assertTrue(MockUtil.isMock(Mockito.mock(List.class)));\n     }\n }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoTest extends TestBase {\n \n-    //TODO I want to have ruby script that will collect all java code from examples in javadoc/documentation\n-    // and create a test case that I can manually fix and run and make sure examples are valid.\n-    // Or better. Write examples as unit tests, annotate them in the way so that javadoc can be generated out of it.\n-    \n-    //TODO check if performace can be tweaked (e.g: LL -> AL)\n-    \n-    //TODO names for @Mock - take field names\n-    //TODO return 0 for Integer, etc\n-    \n     @Test\n     public void shouldRemoveStubbableFromProgressAfterStubbing() {\n         List mock = Mockito.mock(List.class);\n--- a/test/org/mockito/TestBase.java\n+++ b/test/org/mockito/TestBase.java\n         org.junit.Assert.assertThat(message, actual, m);\n     }\n     \n-    protected void assertContains(String expectedSubstring, String target) {\n-        assertTrue(\"This substring:\\n\" + expectedSubstring\n-                + \"\\nshould exist somewhere here:\\n\" + target, \n-                target.contains(expectedSubstring));\n+    public static <T> Assertor<String> contains(final String substring) {\n+        return new Assertor<String>() {\n+            public void assertValue(String value) {\n+                assertTrue(\"This substring: \\n\" + substring + \n+                        \"\\nshould be inside of:\\n\" + value\n+                        , value.contains(substring));\n+            }\n+        };\n+    }\n+    \n+    public static <T> Assertor<String> endsWith(final String substring) {\n+        return new Assertor<String>() {\n+            public void assertValue(String value) {\n+                assertTrue(\"This substring: \\n\" + substring + \n+                        \"\\nshould be at the end of:\\n\" + value\n+                        , value.endsWith(substring));\n+            }\n+        };\n     }\n \n     public static <T> Assertor<Throwable> messageContains(final String text) {\n--- a/test/org/mockito/configuration/DefaultReturnValuesTest.java\n+++ b/test/org/mockito/configuration/DefaultReturnValuesTest.java\n         \n         assertEquals(false, values.returnValueFor(Boolean.TYPE));\n         assertEquals((char) 0, values.returnValueFor(Character.TYPE));\n+        assertEquals(0, values.returnValueFor(Byte.TYPE));\n         assertEquals(0, values.returnValueFor(Short.TYPE));\n         assertEquals(0, values.returnValueFor(Integer.TYPE));\n         assertEquals(0, values.returnValueFor(Long.TYPE));\n--- a/test/org/mockito/configuration/MockitoConfigurationTest.java\n+++ b/test/org/mockito/configuration/MockitoConfigurationTest.java\n             MockitoConfiguration.instance().setReturnValues(null);\n             fail();\n         } catch (MockitoException e) {\n-            assertContains(\"Cannot set null ReturnValues!\", e.getMessage());\n+            assertThat(e, messageContains(\"Cannot set null ReturnValues!\"));\n         }\n     }\n }\n--- a/test/org/mockito/exceptions/base/StackTraceRemoverTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceRemoverTest.java\n         setStackTrace(\"methodOne\", \"methodTwo\", \"methodThree\", \"commonMethodOne\", \"commonMethodTwo\");\n         setCauseStackTrace(\"actualOne\", \"actualTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, hasExactlyInOrder(\n                 \"methodOne\",\n                 \"methodTwo\",\n                 \"methodThree\"\n         setStackTrace(\"methodOne\", \"commonMethodOne\", \"commonMethodTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n         setCauseStackTrace(\"actualOne\", \"commonMethodOne\", \"commonMethodTwo\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, hasExactlyInOrder(\n                 \"methodOne\",\n                 \"commonMethodOne\",\n                 \"commonMethodTwo\"\n         setStackTrace(\"methodOne\", \"commonMethodOne\");\n         setCauseStackTrace(\"actualOne\", \"commonMethodOne\", \"actualOne\", \"commonMethodOne\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, hasExactlyInOrder(\n                 \"methodOne\"\n         ));\n     }\n         setStackTrace(\"one\", \"commonOne\");\n         setCauseStackTrace(\"two\", \"commonOne\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, hasExactlyInOrder(\n                 \"one\"\n         ));\n     }\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         MockingProgressImpl state = new MockingProgressImpl();\n         state.verificationStarted(VerificationModeImpl.atLeastOnce());\n-        MockHandler handler = new MockHandler(state, new ExceptionThrowingBinder());\n+        MockHandler handler = new MockHandler(null, state, new ExceptionThrowingBinder());\n         \n         try {\n             handler.intercept(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{}, null);\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n import java.util.LinkedList;\n import java.util.List;\n \n+import org.mockito.Mockito;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n     private String methodName = \"simpleMethod\";\n     private int sequenceNumber = 0;\n     private Object[] args = new Object[] {};\n-    private Object mock = \"mock\";\n+    private Object mock = Mockito.mock(IMethods.class);\n     private Method method;\n     private boolean verified;\n \n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.NotNull;\n import org.mockitousage.IMethods;\n public class InvocationMatcherTest extends TestBase {\n \n     private InvocationMatcher simpleMethod;\n+    @Mock private IMethods mock; \n     \n     @Before\n     public void setup() {\n-        simpleMethod = new InvocationBuilder().simpleMethod().toInvocationMatcher();\n+        simpleMethod = new InvocationBuilder().mock(mock).simpleMethod().toInvocationMatcher();\n     }\n \n     public void shouldBuildEqualsMatchersWhenNullPassed() throws Exception {\n         InvocationMatcher m = new InvocationMatcher(new InvocationBuilder().args(\"foo\").toInvocation(), null);\n-        assertThat(m.getMatchers(), collectionHasExactlyInOrder(new Equals(\"foo\")));\n+        assertThat(m.getMatchers(), hasExactlyInOrder(new Equals(\"foo\")));\n     }\n     \n     @Test\n         Matcher mTwo = new Equals('x');\n         InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));\n \n-        assertContains(\"Object.simpleMethod(notNull())\", notNull.toString());\n-        assertContains(\"Object.simpleMethod('x')\", equals.toString());\n+        assertThat(notNull.toString(), contains(\"simpleMethod(notNull())\"));\n+        assertThat(equals.toString(), contains(\"simpleMethod('x')\"));\n     }\n     \n     @Test\n     public void shouldKnowIfIsSimilarTo() throws Exception {\n-        Invocation same = new InvocationBuilder().simpleMethod().toInvocation();\n+        Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n         assertTrue(simpleMethod.hasSimilarMethod(same));\n         \n-        Invocation different = new InvocationBuilder().differentMethod().toInvocation();\n+        Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(different));\n     }\n     \n         Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n         \n-        InvocationMatcher invocation = new InvocationBuilder().method(method).arg(\"foo\").toInvocationMatcher();\n-        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(\"bar\").toInvocation();\n+        InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg(\"foo\").toInvocationMatcher();\n+        Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n         \n         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     @Test\n     public void shouldPrintMethodName() {\n         invocation = new InvocationBuilder().toInvocation();\n-        assertEquals(\"Object.simpleMethod();\", invocation.toString());\n+        assertEquals(\"IMethods.simpleMethod();\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintMethodArgs() {\n         invocation = new InvocationBuilder().args(\"foo\").toInvocation();\n-        assertEquals(\"Object.simpleMethod(\\\"foo\\\");\", invocation.toString());\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(\\\"foo\\\");\"));\n     }\n     \n     @Test\n     public void shouldPrintMethodIntegerArgAndString() {\n         invocation = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n-        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1);\", invocation.toString());\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(\\\"foo\\\", 1);\"));\n     }\n     \n     @Test\n     public void shouldPrintNull() {\n         invocation = new InvocationBuilder().args((String) null).toInvocation();\n-        assertEquals(\"Object.simpleMethod(null);\", invocation.toString());\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(null);\"));\n     }\n     \n     @Test\n     public void shouldPrintArray() {\n         invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] { 1, 2, 3 }).toInvocation();\n-        assertEquals(\"Object.oneArray([1, 2, 3]);\", invocation.toString());\n+        assertThat(invocation.toString(), endsWith(\"oneArray([1, 2, 3]);\"));\n     }\n     \n     @Test\n     public void shouldPrintNullIfArrayIsNull() throws Exception {\n         Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n         invocation = new InvocationBuilder().method(m).args((Object) null).toInvocation();\n-        assertEquals(\"Object.oneArray(null);\", invocation.toString());\n+        assertThat(invocation.toString(), endsWith(\"oneArray(null);\"));\n     }\n     \n     @Test\n     public void shouldPrintArgumentsInMultilinesWhenGetsTooBig() {\n         invocation = new InvocationBuilder().args(\"veeeeery long string that makes it ugly in one line\", 1).toInvocation();\n-        assertEquals(\"Object.simpleMethod(\" +\n+        assertThat(invocation.toString(), endsWith( \n+                \"simpleMethod(\" +\n                 \"\\n\" +\n                 \"    \\\"veeeeery long string that makes it ugly in one line\\\",\" +\n                 \"\\n\" +\n                 \"    1\" +\n                 \"\\n\" +\n-                \");\", invocation.toString());\n+                \");\"));\n     }\n     \n     @Test\n         Invocation i = new InvocationBuilder().args(\"foo\", new String[] {\"bar\"}).toInvocation();\n         List matchers = i.argumentsToMatchers();\n \n-        //TODO when I use IsCollectionContaining.hasItems ant fails to compile tests. \n         assertEquals(2, matchers.size());\n         assertEquals(Equals.class, matchers.get(0).getClass());\n         assertEquals(ArrayEquals.class, matchers.get(1).getClass());\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.progress.VerificationModeBuilder;\n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockitousage.IMethods;\n \n \n public class InvocationsFinderTest extends TestBase {\n     private Invocation simpleMethodInvocationTwo;\n     private Invocation differentMethodInvocation;\n     private InvocationsFinder finder;\n+    \n+    @Mock private IMethods mock;\n \n     @Before\n     public void setup() throws Exception {\n-        simpleMethodInvocation = new InvocationBuilder().simpleMethod().seq(1).toInvocation();\n-        simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n-        differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n+        simpleMethodInvocation = new InvocationBuilder().mock(mock).simpleMethod().seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().mock(mock).simpleMethod().seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().mock(mock).differentMethod().seq(3).toInvocation();\n         invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n         finder = new InvocationsFinder();\n     }\n     @Test\n     public void shouldFindActualInvocations() throws Exception {\n         List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertThat(actual, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+        assertThat(actual, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n         actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation), atLeastOnce());\n-        assertThat(actual, collectionHasExactlyInOrder(differentMethodInvocation));\n+        assertThat(actual, hasExactlyInOrder(differentMethodInvocation));\n     }\n     \n     @Test\n     \n     @Test\n     public void shouldFindFirstSimilarInvocationByName() throws Exception {\n-        Invocation overloadedSimpleMethod = new InvocationBuilder().simpleMethod().arg(\"test\").toInvocation();\n+        Invocation overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg(\"test\").toInvocation();\n         \n         Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod), atLeastOnce());\n         assertSame(found, simpleMethodInvocation);\n     @Test\n     public void shouldFindAllMatchingUnverifiedChunks() throws Exception {\n         List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        assertThat(allMatching, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+        assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n         simpleMethodInvocation.markVerifiedInOrder();\n         allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        assertThat(allMatching, collectionHasExactlyInOrder(simpleMethodInvocationTwo));\n+        assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocationTwo));\n         \n         simpleMethodInvocationTwo.markVerifiedInOrder();\n         allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation));\n     \n     @Test\n     public void shouldFindMatchingChunk() throws Exception {\n-        Invocation simpleMethodInvocationThree = new InvocationBuilder().toInvocation();\n-        invocations.add(simpleMethodInvocationThree);\n-        \n         VerificationModeImpl inOrderMode = new VerificationModeBuilder().times(2).inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), inOrderMode);\n-        assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+        assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n     \n     @Test\n     public void shouldReturnAllChunksWhenModeIsAtLeastOnce() throws Exception {\n-        Invocation simpleMethodInvocationThree = new InvocationBuilder().toInvocation();\n+        Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n         VerificationModeImpl atLeastOnceInOrder = new VerificationModeBuilder().inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnceInOrder);\n-        assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n+        assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n     public void shouldReturnAllChunksWhenWantedCountDoesntMatch() throws Exception {\n-        Invocation simpleMethodInvocationThree = new InvocationBuilder().toInvocation();\n+        Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n         VerificationModeImpl atLeastOnceInOrder = new VerificationModeBuilder().times(100).inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnceInOrder);\n-        assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n+        assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/stubbing/ResultTest.java\n+++ b/test/org/mockito/internal/stubbing/ResultTest.java\n             fail();\n         } catch (RuntimeException e) {\n             assertTrue(Arrays.equals(filterStub.hasStackTrace.getStackTrace(), e.getStackTrace()));\n-            assertThat(\"should fill in stack trace\", e, hasFirstMethodInStackTrace(\"answer\"));\n+            assertThat(e, hasFirstMethodInStackTrace(\"answer\"));\n         }\n     }\n     \n--- a/test/org/mockito/internal/util/ListUtilTest.java\n+++ b/test/org/mockito/internal/util/ListUtilTest.java\n             }\n         });\n         \n-        assertThat(filtered, collectionHasExactlyInOrder(\"one\", \"two\", \"three\"));\n+        assertThat(filtered, hasExactlyInOrder(\"one\", \"two\", \"three\"));\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n         \n         assertSame(verifierStub.mode, mode);\n         assertSame(verifierStub.wanted, differentMethod);\n-        assertThat(verifierStub.invocations, collectionHasExactlyInOrder(simpleMethod));\n+        assertThat(verifierStub.invocations, hasExactlyInOrder(simpleMethod));\n     }\n     \n     @Test\n         VerificationModeImpl inOrderMode = new VerificationModeBuilder().inOrder();\n         recorder.verify(differentMethod, inOrderMode);\n         \n-        assertThat(verifierStub.invocations, collectionHasExactlyInOrder(simpleMethod, differentMethod.getInvocation()));\n+        assertThat(verifierStub.invocations, hasExactlyInOrder(simpleMethod, differentMethod.getInvocation()));\n     }\n     \n     @Test\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.util;\n+\n+import static org.junit.Assert.*;\n \n import java.lang.reflect.Method;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n \n-import org.hamcrest.BaseMatcher;\n-import org.hamcrest.CoreMatchers;\n-import org.hamcrest.Description;\n-import org.hamcrest.Matcher;\n import org.mockito.exceptions.base.HasStackTrace;\n \n @SuppressWarnings(\"unchecked\")\n-public class ExtraMatchers extends CoreMatchers {\n+public class ExtraMatchers {\n \n-    public static <T> Matcher<Throwable> hasFirstMethodInStackTrace(final String method) {\n+    public static <T> Assertor<Throwable> hasFirstMethodInStackTrace(final String method) {\n         return hasMethodInStackTraceAt(0, method);\n     }\n     \n-    public static <T> Matcher hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n-        return new BaseMatcher() {\n-            public boolean matches(Object traceElements) {\n+    public static <T> Assertor hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n+        return new Assertor() {\n+            public void assertValue(Object traceElements) {\n                 final List<StackTraceElement> trace;\n                 if (traceElements instanceof List) {\n                     trace = (List<StackTraceElement>) traceElements;\n                     throw new RuntimeException(\"this matcher cannot deal with object provided: \" + traceElements);\n                 }\n                 \n-                if (trace.size() != methods.length) {\n-                    return false;\n-                }\n+                assertEquals(methods.length, trace.size());\n                     \n                 for (int i = 0; i < trace.size(); i++) {\n-                    if (!trace.get(i).getMethodName().equals(methods[i])) {\n-                        return false;\n-                    }\n+                    assertEquals(methods[i], trace.get(i).getMethodName());\n                 }\n-\n-                return true;\n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"has only those methods in stack trace: \");\n-                desc.appendValue(methods);\n             }\n         };\n     }\n     \n-    public static <T> Matcher<HasStackTrace> hasOnlyThoseClassesInStackTrace(final String ... classes) {\n-        return new BaseMatcher() {\n-            public boolean matches(Object traceElements) {\n-                StackTraceElement[] trace = ((HasStackTrace) traceElements).getStackTrace();\n+    public static <T> Assertor<HasStackTrace> hasOnlyThoseClassesInStackTrace(final String ... classes) {\n+        return new Assertor<HasStackTrace>() {\n+            public void assertValue(HasStackTrace traceElements) {\n+                StackTraceElement[] trace = traceElements.getStackTrace();\n                 \n-                if (trace.length != classes.length) {\n-                    return false;\n-                }\n+                assertEquals(\"Number of classes does not match\",\n+                        classes.length, trace.length);\n                     \n                 for (int i = 0; i < trace.length; i++) {\n-                    if (!trace[i].getClassName().equals(classes[i])) {\n-                        return false;\n-                    }\n+                    assertEquals(classes[i], trace[i].getClassName());\n                 }\n-\n-                return true;\n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"has only those classes in stack trace: \");\n-                desc.appendValue(classes);\n             }\n         };\n     }\n     \n-    public static <T> Matcher<Throwable> hasMethodInStackTraceAt(final int stackTraceIndex, final String method) {\n-        return new BaseMatcher<Throwable>() {\n+    public static <T> Assertor<Throwable> hasMethodInStackTraceAt(final int stackTraceIndex, final String method) {\n+        return new Assertor<Throwable>() {\n \n             private String actualMethodAtIndex;\n \n-            public boolean matches(Object throwable) {\n-                actualMethodAtIndex = ((Throwable) throwable).getStackTrace()[stackTraceIndex].getMethodName();\n-                return  actualMethodAtIndex.equals(method);\n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"Method of index: \" + stackTraceIndex + \" expected to be: \" + method + \" but is: \" + actualMethodAtIndex);\n+            public void assertValue(Throwable throwable) {\n+                actualMethodAtIndex = throwable.getStackTrace()[stackTraceIndex].getMethodName();\n+                assertTrue(\n+                    \"Method at index: \" + stackTraceIndex + \n+                    \"\\n\" +\n+                    \"expected to be: \" + method + \n+                    \"\\n\" +\n+                    \"but is: \" + actualMethodAtIndex,\n+                    actualMethodAtIndex.equals(method));\n             }\n         };\n     }\n     \n-    public static <T> Matcher<Object> hasBridgeMethod(final String methodName) {\n-        return new BaseMatcher<Object>() {\n+    public static <T> Assertor<Object> hasBridgeMethod(final String methodName) {\n+        return new Assertor<Object>() {\n \n-            public boolean matches(Object o) {\n+            public void assertValue(Object o) {\n                 Class clazz = null;\n                 if (o instanceof Class) {\n                     clazz = (Class) o;\n                 }\n                 \n                 for (Method m : clazz.getMethods()) {\n-                    if (m.isBridge()) {\n-                        if (m.getName().equals(methodName)) {\n-                            return true;\n-                        }\n+                    if (m.isBridge() && m.getName().equals(methodName)) {\n+                        return;\n                     }\n                 }\n                 \n-                return false; \n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"Bridge method: \" + methodName + \" not found!\");\n+                fail(\"Bridge method [\" + methodName + \"]\\nnot found in:\\n\" + o);\n             }\n         };\n     }\n     \n-    public static <T> Matcher<Collection> collectionHas(final T ... elements) {\n-        return new BaseMatcher<Collection>() {\n+    public static <T> Assertor<Collection> has(final T ... elements) {\n+        return new Assertor<Collection>() {\n \n-            public boolean matches(Object collection) {\n+            public void assertValue(Collection value) {\n                 for (T element : elements) {\n-                    if (((Collection) collection).contains(element) == false) {\n-                        return false;\n-                    }\n+                    assertTrue(\n+                            \"Element:\" +\n+                            \"\\n\" +\n+                            element +\n+                            \"does not exists in:\" +\n+                            \"\\n\" +\n+                            value, \n+                            value.contains(element));\n                 }\n-                return true;\n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"collection doesn't containg one of: \" + Arrays.toString(elements));\n             }\n         };\n     }\n     \n-    //TODO can't you use matchers from hamcrest library (may apply to other methods here)?\n-    public static <T> Matcher<Collection> collectionHasExactlyInOrder(final T ... elements) {\n-        return new BaseMatcher<Collection>() {\n+    public static <T> Assertor<Collection> hasExactlyInOrder(final T ... elements) {\n+        return new Assertor<Collection>() {\n \n-            public boolean matches(Object collection) {\n-                Collection actual = (Collection) collection;\n-                if (actual.size() != elements.length) {\n-                    return false;\n-                }\n-                if (Collections.indexOfSubList((List<?>) actual, Arrays.asList(elements)) == -1) {\n-                    return false;\n-                }\n+            public void assertValue(Collection value) {\n+                assertEquals(elements.length, value.size());\n                 \n-                return true;\n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"collection doesn't contain following elements in order: \" + Arrays.toString(elements));\n+                boolean containsSublist = Collections.indexOfSubList((List<?>) value, Arrays.asList(elements)) != -1;\n+                assertTrue(\n+                        \"Elements:\" +\n+                        \"\\n\" + \n+                        Arrays.toString(elements) + \n+                        \"\\n\" +\n+                        \"were not found in collection:\" +\n+                        \"\\n\" +\n+                        value, containsSublist);\n             }\n         };\n     }\n-    //TODO get rid of matchers and use assertors to investigate the idea and make testing simpler\n }\n--- a/test/org/mockitousage/AnnotationsTest.java\n+++ b/test/org/mockitousage/AnnotationsTest.java\n     @Mock List list;\n     @Mock final Map map = new HashMap();\n     //TODO add initMocks that allows to send own annotation/own implementation of creation logic\n+    \n+    //TODO shall I bother deprecating @MockitoAnnotations.Mock and refactor annotation to own file?\n     \n     @Before\n     public void setup() {\n--- a/test/org/mockitousage/DescriptiveMessagesOnMisuseTest.java\n+++ b/test/org/mockitousage/DescriptiveMessagesOnMisuseTest.java\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldScreamWhenWholeMethodPassedToVerify() {\n-        verify(mock.booleanReturningMethod(2));\n+        verify(mock.booleanReturningMethod());\n     }   \n     \n     @Test(expected=NotAMockException.class)\n     public void shouldScreamWhenWholeMethodPassedToVerifyNoMoreInteractions() {\n-        verifyNoMoreInteractions(mock.byteReturningMethod(1));\n+        verifyNoMoreInteractions(mock.byteReturningMethod());\n     }  \n     \n     @Test(expected=MockitoException.class)\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n \n public interface IMethods {\n \n-    boolean booleanReturningMethod(int index);\n+    boolean booleanReturningMethod();\n+    \n+    Boolean booleanObjectReturningMethod();\n \n-    byte byteReturningMethod(int index);\n+    byte byteReturningMethod();\n+    \n+    Byte byteObjectReturningMethod();\n \n-    short shortReturningMethod(int index);\n+    short shortReturningMethod();\n+    \n+    Short shortObjectReturningMethod();\n \n-    char charReturningMethod(int index);\n+    char charReturningMethod();\n+    \n+    Character charObjectReturningMethod();\n \n-    int intReturningMethod(int index);\n+    int intReturningMethod();\n+    \n+    Integer integerReturningMethod();\n \n-    long longReturningMethod(int index);\n+    long longReturningMethod();\n+    \n+    Long longObjectReturningMethod();\n \n-    float floatReturningMethod(int index);\n+    float floatReturningMethod();\n+    \n+    Float floatObjectReturningMethod();\n \n-    double doubleReturningMethod(int index);\n+    double doubleReturningMethod();\n+    \n+    Double doubleObjectReturningMethod();\n \n     Object objectReturningMethod(Object ... objects);\n \n--- a/test/org/mockitousage/MatchersMixedWithRawArgumentsTest.java\n+++ b/test/org/mockitousage/MatchersMixedWithRawArgumentsTest.java\n     //1. how objenesis deal with primitive arrays (like byte[])?\n     //2. Analisys of all matchers used by R2 project finished before anyObject() and so far proves it's a good idea.\n \n-    @Ignore(\"prototyping\")\n+    @Ignore(\"prototyping new feature that allows to avoid eq() matchers when raw args passed\")\n     @Test\n     public void shouldAllowMixingRawArgumentsWithMatchers() {\n         mock.varargs(\"1\", \"2\", \"3\");\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkInOrderTest.java\n import org.mockito.TestBase;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n \n-//TODO pmd rule so that all that starts with should have @Test annotation (or all XTest have some annotations on public methods)\n public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {\n     \n     private IMethods mock;\n--- a/test/org/mockitousage/ReplacingObjectMethodsTest.java\n+++ b/test/org/mockitousage/ReplacingObjectMethodsTest.java\n         \n         assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n         \n-        assertContains(\"Mock for ObjectMethodsOverridden\", mock.toString());\n+        assertThat(mock.toString(), contains(\"Mock for ObjectMethodsOverridden\"));\n     }\n     \n     @Test \n         \n         assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n         \n-        assertContains(\"Mock for ObjectMethodsOverriddenSubclass\", mock.toString());\n+        assertThat(mock.toString(), contains(\"Mock for ObjectMethodsOverriddenSubclass\"));\n     }\n     \n     public static class ObjectMethodsOverridden {\n--- a/test/org/mockitousage/examples/configure/withbaseclass/ConfiguringDefaultReturnValuesUsingBaseClassTest.java\n+++ b/test/org/mockitousage/examples/configure/withbaseclass/ConfiguringDefaultReturnValuesUsingBaseClassTest.java\n     public void shouldReturnMocksByDefaultInsteadOfNulls() throws Exception {\n         MyObject m = mock(MyObject.class);\n         //mocks don't return nulls any more...\n+        //the configuration code is hidden in the base class\n         MyObject returned = m.foo();\n         assertNotNull(returned);\n         assertNotNull(returned.foo());\n--- a/test/org/mockitousage/examples/use/ExampleTest.java\n+++ b/test/org/mockitousage/examples/use/ExampleTest.java\n         stub(mockCalculator.countArticles(\"Guardian\")).toReturn(12);\n         stub(mockCalculator.countArticlesInPolish(anyString())).toReturn(5);\n \n-//        stub(mockCalculator.countAllArticles(anyString(), \"asdf\")).toReturn(5);\n-        \n         articleManager.updateArticleCounters(\"Guardian\");\n         \n         verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 12);\n         verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 5);\n         verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 7);\n-        \n-        verifyNoMoreInteractions(mockDatabase);\n     }\n     \n     @Test\n \n         verify(mockCalculator).countArticles(\"Guardian\");\n         verify(mockCalculator).countArticlesInPolish(\"Guardian\");\n-        \n-        verifyNoMoreInteractions(mockCalculator);\n     }\n     \n     @Test\n         verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 0);\n         verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 0);\n         verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 0);\n-        \n-        verifyNoMoreInteractions(mockDatabase);\n     }\n     \n     @Test\n--- a/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n+++ b/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n \n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n-import static org.mockito.util.ExtraMatchers.*;\n-\n-import java.util.Arrays;\n \n import org.hamcrest.BaseMatcher;\n import org.hamcrest.Description;\n     }\n     \n     @Test\n-    public void shouldAcceptCollectionContainingMatcher() {\n-        stub(mock.simpleMethod(argThat(collectionHas(\"1\", \"2\")))).toReturn(\"1 and 2\");\n-        assertNull(mock.simpleMethod(Arrays.asList(\"3\", \"1\")));\n-        assertEquals(\"1 and 2\", mock.simpleMethod(Arrays.asList(\"1\", \"2\")));\n-    }\n-    \n-    @Test\n     public void shouldVerifyUsingHamcrestMatcher() {\n         mock.simpleMethod(\"blah\");\n         \n--- a/test/org/mockitousage/matchers/MatchersTest.java\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Matchers;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n         stub(mock.oneArg(and(eq((int) 1), eq((int) 1)))).toReturn(\"5\");\n         stub(mock.oneArg(and(eq((long) 1), eq((long) 1)))).toReturn(\"6\");\n         stub(mock.oneArg(and(eq((short) 1), eq((short) 1)))).toReturn(\"7\");\n-        stub(mock.oneArg(and(contains(\"a\"), contains(\"d\")))).toReturn(\"8\");\n+        stub(mock.oneArg(and(Matchers.contains(\"a\"), Matchers.contains(\"d\")))).toReturn(\"8\");\n         stub(mock.oneArg(and(isA(Class.class), eq(Object.class)))).toReturn(\"9\");\n \n         assertEquals(\"0\", mock.oneArg(false));\n         stub(mock.oneArg(not(eq((int) 1)))).toReturn(\"5\");\n         stub(mock.oneArg(not(eq((long) 1)))).toReturn(\"6\");\n         stub(mock.oneArg(not(eq((short) 1)))).toReturn(\"7\");\n-        stub(mock.oneArg(not(contains(\"a\")))).toReturn(\"8\");\n+        stub(mock.oneArg(not(Matchers.contains(\"a\")))).toReturn(\"8\");\n         stub(mock.oneArg(not(isA(Class.class)))).toReturn(\"9\");\n \n         assertEquals(\"0\", mock.oneArg(true));\n \n     @Test\n     public void containsMatcher() {\n-        stub(mock.oneArg(contains(\"ell\"))).toReturn(\"1\");\n-        stub(mock.oneArg(contains(\"ld\"))).toReturn(\"2\");\n+        stub(mock.oneArg(Matchers.contains(\"ell\"))).toReturn(\"1\");\n+        stub(mock.oneArg(Matchers.contains(\"ld\"))).toReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(\"hello\"));\n         assertEquals(\"2\", mock.oneArg(\"world\"));\n \n     @Test\n     public void endsWithMatcher() {\n-        stub(mock.oneArg(endsWith(\"ab\"))).toReturn(\"1\");\n-        stub(mock.oneArg(endsWith(\"bc\"))).toReturn(\"2\");\n+        stub(mock.oneArg(Matchers.endsWith(\"ab\"))).toReturn(\"1\");\n+        stub(mock.oneArg(Matchers.endsWith(\"bc\"))).toReturn(\"2\");\n \n         assertEquals(\"1\", mock.oneArg(\"xab\"));\n         assertEquals(\"2\", mock.oneArg(\"xbc\"));\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n     \n     @Test\n     public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n-        stub(mock.booleanReturningMethod(1)).toReturn(true);\n+        stub(mock.booleanReturningMethod()).toReturn(true);\n         \n-        mock.booleanReturningMethod(1);\n+        mock.booleanReturningMethod();\n         \n         try {\n             verifyNoMoreInteractions(mock);\n         Generic mockTwo = mock(Generic.class);\n         \n         List<Sub> subs = null;\n-        //TODO can I somehow avoid a cast here:\n+        //can I somehow avoid a cast here:\n         stub(mockTwo.getList()).toReturn((List) subs);\n     }\n     \n         IMethods mockTwo = mock(IMethods.class);\n         stub(mockTwo.toString()).toReturn(\"test\");\n         \n-        assertContains(\"Mock for IMethods\", mock.toString());\n+        assertThat(mock.toString(), contains(\"Mock for IMethods\"));\n         assertEquals(\"test\", mockTwo.toString());\n     }\n     \n--- a/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n+++ b/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class ReturningDefaultValuesTest extends TestBase {\n \n+    @Mock private IMethods mock;\n+\n     @Test\n     public void shouldReturnAllKindsOfPrimitives() throws Exception {\n-        IMethods mock = Mockito.mock(IMethods.class);\n-\n-        //this is mainly to prove that cglib-enchanted-thing works properly \n-        //and returns primitive value rather than throw NullPointerException\n-        //If we used java.lang.reflect.Proxy NullPointerException will bang\n-        assertEquals((byte) 0, mock.byteReturningMethod(12));\n-        assertEquals((short) 0, mock.shortReturningMethod(12));\n-        assertEquals(0, mock.intReturningMethod(12));\n-        assertEquals(0L, mock.intReturningMethod(12));\n-        assertEquals(0.0F, mock.floatReturningMethod(12), 0.0F);\n-        assertEquals(0.0D, mock.doubleReturningMethod(12), 0.0D);\n-        assertEquals((char) 0, mock.charReturningMethod(12));\n-        assertEquals(false, mock.booleanReturningMethod(12));\n-        assertEquals(null, mock.objectReturningMethod(12));\n+        assertEquals((byte) 0, mock.byteReturningMethod());\n+        assertEquals((short) 0, mock.shortReturningMethod());\n+        assertEquals(0, mock.intReturningMethod());\n+        assertEquals(0L, mock.longReturningMethod());\n+        assertEquals(0.0F, mock.floatReturningMethod(), 0.0F);\n+        assertEquals(0.0D, mock.doubleReturningMethod(), 0.0D);\n+        assertEquals((char) 0, mock.charReturningMethod());\n+        assertEquals(false, mock.booleanReturningMethod());\n+        assertEquals(null, mock.objectReturningMethod());\n+    }\n+    \n+    @Test\n+    public void shouldReturnTheSameValuesForWrapperClasses() throws Exception {\n+        assertEquals(new Byte((byte) 0), mock.byteObjectReturningMethod());\n+        assertEquals(new Short((short) 0), mock.shortObjectReturningMethod());\n+        assertEquals(new Integer(0), mock.integerReturningMethod());\n+        assertEquals(new Long(0L), mock.longObjectReturningMethod());\n+        assertEquals(new Float(0.0F), mock.floatObjectReturningMethod(), 0.0F);\n+        assertEquals(new Double(0.0D), mock.doubleObjectReturningMethod(), 0.0D);\n+        assertEquals(new Character((char) 0), mock.charObjectReturningMethod());\n+        assertEquals(new Boolean(false), mock.booleanObjectReturningMethod());\n     }\n     \n     @Test \n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n import org.mockito.exceptions.cause.ActualArgumentsAreDifferent;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n             assertThat(e, causeMessageContains(\"foo\"));\n         }\n     }\n+\n+    @Mock private IMethods iHavefunkyName; \n+    \n+    @Test\n+    public void shouldPrintFieldNameWhenAnnotationsUsed() throws Exception {\n+        //TODO if I am adding this feature, then shall I also make the first letter of generated mock name lower-case (for consistency)???\n+        //it's hard to say what is more consistent... ask Igor or Felix\n+        iHavefunkyName.simpleMethod(10);\n+    \n+        try {\n+            verify(iHavefunkyName).simpleMethod(20);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e, messageContains(\"iHavefunkyName.simpleMethod(20)\"));\n+            assertThat(e, causeMessageContains(\"iHavefunkyName.simpleMethod(10)\"));\n+        }\n+    }\n }\n--- a/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Matchers;\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n         mock.threeArgumentMethod(11, \"\", \"01234\");\n \n         try {\n-            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains(\"123\"));\n             fail();\n         } catch (ArgumentsAreDifferent e) {}\n \n         mock.threeArgumentMethod(8, new Object(), \"01234\");\n         \n         try {\n-            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains(\"123\"));\n             fail();\n         } catch (ArgumentsAreDifferent e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"no match\");\n \n         try {\n-            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains(\"123\"));\n             fail();\n         } catch (ArgumentsAreDifferent e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"123\");\n         \n-        verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+        verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains(\"123\"));\n     }\n }", "timestamp": 1207573529, "metainfo": ""}