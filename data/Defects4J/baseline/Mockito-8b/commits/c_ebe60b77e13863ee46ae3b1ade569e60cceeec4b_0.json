{"sha": "ebe60b77e13863ee46ae3b1ade569e60cceeec4b", "log": "buildSrc tidy-up. Now it is all java code.  Tests are still spock of course!!!", "commit": "\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/comparison/PomComparator.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+\n+import static org.mockito.release.util.ArgumentValidation.notNull;\n+\n+class PomComparator {\n+\n+    private Closure<String> left;\n+    private Closure<String> right;\n+\n+    PomComparator setPair(Closure<String> left, Closure<String> right) {\n+        notNull(left, \"pom content to compare\", right, \"pom content to compare\");\n+        this.left = left;\n+        this.right = right;\n+        return this;\n+    }\n+\n+    boolean areEqual() {\n+        String left = this.left.call();\n+        String right = this.right.call();\n+\n+        notNull(left, \"pom content to compare\", right, \"pom content to compare\");\n+\n+        return replaceVersion(left).equals(replaceVersion(right));\n+    }\n+\n+    private String replaceVersion(String pom) {\n+        return pom.replaceFirst(\"<version>(.*)</version>\", \"<version>foobar</version>\");\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/comparison/PublicationsComparator.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+\n+import java.io.File;\n+\n+/**\n+ * Compares publications\n+ */\n+public interface PublicationsComparator {\n+\n+    /**\n+     * Sets files for comparison\n+     */\n+    void compareBinaries(Closure<File> left, Closure<File> right);\n+\n+    /**\n+     * Sets poms for comparison\n+     */\n+    void comparePoms(Closure<String> left, Closure<String> right);\n+\n+    /**\n+     * Gives information if publications are equal\n+     */\n+    boolean isPublicationsEqual();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/comparison/PublicationsComparatorTask.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.tasks.TaskAction;\n+\n+import java.io.File;\n+\n+public class PublicationsComparatorTask extends DefaultTask implements PublicationsComparator {\n+\n+    private ZipComparator zipComparator = new ZipComparator(new ZipCompare());\n+    private PomComparator pomComparator = new PomComparator();\n+    private Boolean publicationsEqual;\n+\n+    public void compareBinaries(Closure<File> left, Closure<File> right) {\n+        zipComparator.setPair(left, right);\n+    }\n+\n+    public void comparePoms(Closure<String> left, Closure<String> right) {\n+        pomComparator.setPair(left, right);\n+    }\n+\n+    public boolean isPublicationsEqual() {\n+        assert publicationsEqual != null : \"Comparison task was not executed yet, the 'publicationsEqual' information not available.\";\n+        return publicationsEqual;\n+    }\n+\n+    @TaskAction public void comparePublications() {\n+        getLogger().lifecycle(\"{} - about to compare publications\", getPath());\n+\n+        boolean poms = pomComparator.areEqual();\n+        getLogger().lifecycle(\"{} - pom files equal: {}\", getPath(), poms);\n+\n+        ZipComparator.Result result = zipComparator.compareFiles();\n+        getLogger().info(\"{} - compared binaries: '{}' and '{}'\", getPath(), result.getFile1(), result.getFile2());\n+        boolean jars = result.areEqual();\n+        getLogger().lifecycle(\"{} - source jars equal: {}\", getPath(), jars);\n+\n+\n+        this.publicationsEqual = jars && poms;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/comparison/ZipComparator.java\n+package org.mockito.release.comparison;\n+\n+import groovy.lang.Closure;\n+\n+import java.io.File;\n+\n+import static org.mockito.release.util.ArgumentValidation.notNull;\n+\n+class ZipComparator {\n+\n+    private Closure<File> file1;\n+    private Closure<File> file2;\n+\n+    private final ZipCompare zipCompare;\n+\n+    ZipComparator(ZipCompare zipCompare) {\n+        this.zipCompare = zipCompare;\n+    }\n+\n+    ZipComparator setPair(Closure<File> file1, Closure<File> file2) {\n+        notNull(file1, \"zip/jar file to compare\", file2, \"zip/jar file to compare\");\n+        this.file1 = file1;\n+        this.file2 = file2;\n+        return this;\n+    }\n+\n+    Result compareFiles() {\n+        final File file1 = this.file1.call();\n+        final File file2 = this.file2.call();\n+        notNull(file1, \"zip/jar file to compare\", file2, \"zip/jar file to compare\");\n+\n+        final boolean equals = zipCompare.compareZips(file1.getAbsolutePath(), file2.getAbsolutePath());\n+\n+        return new Result() {\n+            public boolean areEqual() { return equals; }\n+            public File getFile1() { return file1; }\n+            public File getFile2() { return file2; }\n+        };\n+    }\n+\n+    static interface Result {\n+        boolean areEqual();\n+        File getFile1();\n+        File getFile2();\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/comparison/ZipCompare.java\n+package org.mockito.release.comparison;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+//TODO SF - borrowed code, not very nice, should not write to system out and should throw decent exceptions\n+class ZipCompare {\n+\n+    boolean compareZips(String filePath1, String filePath2) {\n+        ZipFile file1;\n+        try {\n+            file1 = new ZipFile(filePath1);\n+        } catch (IOException e) {\n+            System.out.println(\"Could not open zip file \" + filePath1 + \": \" + e);\n+            return false;\n+        }\n+\n+        ZipFile file2;\n+        try {\n+            file2 = new ZipFile(filePath2);\n+        } catch (IOException e) {\n+            System.out.println(\"Could not open zip file \" + filePath1 + \": \" + e);\n+            return false;\n+        }\n+\n+        System.out.println(\"Comparing \" + filePath1 + \" with \" + filePath2 + \":\");\n+\n+        Set set1 = new LinkedHashSet();\n+        for (Enumeration e = file1.entries(); e.hasMoreElements(); )\n+            set1.add(((ZipEntry) e.nextElement()).getName());\n+\n+        Set set2 = new LinkedHashSet();\n+        for (Enumeration e = file2.entries(); e.hasMoreElements(); )\n+            set2.add(((ZipEntry) e.nextElement()).getName());\n+\n+        int errcount = 0;\n+        int filecount = 0;\n+        for (Iterator i = set1.iterator(); i.hasNext(); ) {\n+            String name = (String) i.next();\n+            if (!set2.contains(name)) {\n+                System.out.println(name + \" not found in \" + filePath2);\n+                errcount += 1;\n+                continue;\n+            }\n+            try {\n+                set2.remove(name);\n+                if (!streamsEqual(file1.getInputStream(file1.getEntry(name)), file2.getInputStream(file2\n+                        .getEntry(name)))) {\n+                    System.out.println(name + \" does not match\");\n+                    errcount += 1;\n+                    continue;\n+                }\n+            } catch (Exception e) {\n+                System.out.println(name + \": IO Error \" + e);\n+                e.printStackTrace();\n+                errcount += 1;\n+                continue;\n+            }\n+            filecount += 1;\n+        }\n+        for (Iterator i = set2.iterator(); i.hasNext(); ) {\n+            String name = (String) i.next();\n+            System.out.println(name + \" not found in \" + filePath1);\n+            errcount += 1;\n+        }\n+        System.out.println(filecount + \" entries matched\");\n+        if (errcount > 0) {\n+            System.out.println(errcount + \" entries did not match\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    static boolean streamsEqual(InputStream stream1, InputStream stream2) throws IOException {\n+        byte[] buf1 = new byte[4096];\n+        byte[] buf2 = new byte[4096];\n+        boolean done1 = false;\n+        boolean done2 = false;\n+\n+        try {\n+            while (!done1) {\n+                int off1 = 0;\n+                int off2 = 0;\n+\n+                while (off1 < buf1.length) {\n+                    int count = stream1.read(buf1, off1, buf1.length - off1);\n+                    if (count < 0) {\n+                        done1 = true;\n+                        break;\n+                    }\n+                    off1 += count;\n+                }\n+                while (off2 < buf2.length) {\n+                    int count = stream2.read(buf2, off2, buf2.length - off2);\n+                    if (count < 0) {\n+                        done2 = true;\n+                        break;\n+                    }\n+                    off2 += count;\n+                }\n+                if (off1 != off2 || done1 != done2)\n+                    return false;\n+                for (int i = 0; i < off1; i++) {\n+                    if (buf1[i] != buf2[i])\n+                        return false;\n+                }\n+            }\n+            return true;\n+        } finally {\n+            stream1.close();\n+            stream2.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/GitNotesBuilder.java\n+package org.mockito.release.notes;\n+\n+import org.gradle.api.Project;\n+import org.mockito.release.notes.exec.Exec;\n+import org.mockito.release.notes.improvements.ImprovementSet;\n+import org.mockito.release.notes.improvements.ImprovementsProvider;\n+import org.mockito.release.notes.improvements.Improvements;\n+import org.mockito.release.notes.vcs.ContributionSet;\n+import org.mockito.release.notes.vcs.ContributionsProvider;\n+import org.mockito.release.notes.vcs.Vcs;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.util.Date;\n+\n+class GitNotesBuilder implements NotesBuilder {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(GitNotesBuilder.class);\n+\n+    private final File workDir;\n+    private final String authTokenEnvVar;\n+\n+    /**\n+     * @param workDir the working directory for external processes execution (for example: git log)\n+     * @param authTokenEnvVar the env var that holds the GitHub auth token\n+     */\n+    GitNotesBuilder(File workDir, String authTokenEnvVar) {\n+        this.workDir = workDir;\n+        this.authTokenEnvVar = authTokenEnvVar;\n+    }\n+\n+    public String buildNotes(String version, String fromRevision, String toRevision) {\n+        LOG.info(\"Getting release notes between {} and {}\", fromRevision, toRevision);\n+\n+        ContributionsProvider contributionsProvider = Vcs.getGitProvider(Exec.getProcessRunner(workDir));\n+        ContributionSet contributions = contributionsProvider.getContributionsBetween(fromRevision, toRevision);\n+\n+        ImprovementsProvider improvementsProvider = Improvements.getGitHubProvider(authTokenEnvVar);\n+        ImprovementSet improvements = improvementsProvider.getImprovements(contributions);\n+\n+        return new NotesPrinter().printNotes(version, new Date(), contributions, improvements);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/Notes.java\n+package org.mockito.release.notes;\n+\n+import org.gradle.api.Project;\n+import org.mockito.release.notes.versions.PreviousVersion;\n+import org.mockito.release.notes.versions.Versions;\n+\n+import java.io.File;\n+\n+/**\n+ * Release notes services\n+ */\n+public class Notes {\n+\n+    /**\n+     * Release notes build based on git and GitHub.\n+     *\n+     * @param workDir working directory for executing external processes like 'git log'\n+     * @param authTokenEnvVar env variable name that holds the GitHub auth token\n+     */\n+    public static NotesBuilder gitHubNotesBuilder(File workDir, String authTokenEnvVar) {\n+        return new GitNotesBuilder(workDir, authTokenEnvVar);\n+    }\n+\n+    /**\n+     * Provides previous version information based on the release notes content file\n+     */\n+    public static PreviousVersion previousVersion(String releaseNotesContent) {\n+        return Versions.previousFromNotesContent(releaseNotesContent);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/NotesBuilder.java\n+package org.mockito.release.notes;\n+\n+/**\n+ * Builds the release notes text\n+ */\n+public interface NotesBuilder {\n+\n+    /**\n+     * Release notes text for contributions between given versions.\n+     *\n+     * @param version the version of the release we're building the notes\n+     * @param fromRevision valid git revision (can be tag name or HEAD)\n+     * @param toRevision valid git revision (can be tag name or HEAD)\n+     */\n+    String buildNotes(String version, String fromRevision, String toRevision);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/NotesPrinter.java\n+package org.mockito.release.notes;\n+\n+import org.mockito.release.notes.util.HumanReadable;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+class NotesPrinter {\n+\n+    public String printNotes(String version, Date date, HumanReadable contributions, HumanReadable improvements) {\n+        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm z\");\n+        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        String now = format.format(date);\n+\n+        return \"### \" + version + \" (\" + now + \")\" + \"\\n\\n\"\n+                + contributions.toText() + \"\\n\"\n+                + improvements.toText() + \"\\n\\n\";\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/exec/DefaultProcessRunner.java\n+package org.mockito.release.notes.exec;\n+\n+import org.mockito.release.notes.util.ReleaseNotesException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+class DefaultProcessRunner implements ProcessRunner {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(DefaultProcessRunner.class);\n+    private final File workDir;\n+\n+    DefaultProcessRunner(File workDir) {\n+        this.workDir = workDir;\n+    }\n+\n+    public String run(String... commandLine) {\n+        LOG.info(\"Executing command: {}\", (Object) commandLine);\n+\n+        try {\n+            Process process = new ProcessBuilder(commandLine).directory(workDir).redirectErrorStream(true).start();\n+            return readFully(new BufferedReader(new InputStreamReader(process.getInputStream())));\n+        } catch (Exception e) {\n+            throw new ReleaseNotesException(\"Problems executing command: \" + Arrays.toString(commandLine), e);\n+        }\n+    }\n+\n+    private static String readFully(BufferedReader reader) throws IOException {\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            String line;\n+            while((line = reader.readLine()) != null) {\n+                sb.append(line).append(\"\\n\");\n+            }\n+            return sb.toString();\n+        } finally {\n+            reader.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/exec/Exec.java\n+package org.mockito.release.notes.exec;\n+\n+import java.io.File;\n+\n+public class Exec {\n+\n+    public static ProcessRunner getProcessRunner(File workDir) {\n+        return new DefaultProcessRunner(workDir);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/exec/ProcessRunner.java\n+package org.mockito.release.notes.exec;\n+\n+/**\n+ * Provides ways to execute external processes\n+ */\n+public interface ProcessRunner {\n+\n+    /**\n+     * Executes given command line and returns the output.\n+     *\n+     * @param commandLine to execute\n+     * @return combined error and standard output.\n+     */\n+    String run(String ... commandLine);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/DefaultImprovements.java\n+package org.mockito.release.notes.improvements;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+class DefaultImprovements implements ImprovementSet {\n+\n+    private final List<Improvement> improvements = new LinkedList<Improvement>();\n+\n+    public String toText() {\n+        if (improvements.isEmpty()) {\n+            //TODO SF we should break the build if there are no notable improvements yet the binaries have changed\n+            return \"* No notable improvements. See the commits for detailed changes.\";\n+        }\n+        StringBuilder sb = new StringBuilder(\"* Improvements: \").append(improvements.size());\n+        for (Improvement i : improvements) {\n+            sb.append(\"\\n  * \").append(i.toText());\n+        }\n+        return sb.toString();\n+    }\n+\n+    public void add(Improvement improvement) {\n+        improvements.add(improvement);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/GitHubAuthToken.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.util.ReleaseNotesException;\n+\n+class GitHubAuthToken {\n+\n+    private final String envVariableName;\n+\n+    public GitHubAuthToken(String envVariableName) {\n+        this.envVariableName = envVariableName;\n+    }\n+\n+    public String getToken() {\n+        String out = System.getenv(envVariableName);\n+        if (out == null) {\n+            throw new ReleaseNotesException(\"Environmental variable '\" + envVariableName + \"' is missing.\", null);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/GitHubImprovementsProvider.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.vcs.ContributionSet;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class GitHubImprovementsProvider implements ImprovementsProvider {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GitHubImprovementsProvider.class);\n+    private final GitHubAuthToken authToken;\n+\n+    public GitHubImprovementsProvider(GitHubAuthToken authToken) {\n+        this.authToken = authToken;\n+    }\n+\n+    public ImprovementSet getImprovements(ContributionSet contributions) {\n+        LOGGER.info(\"Parsing {} commits with {} tickets\", contributions.getAllCommits().size(), contributions.getAllTickets().size());\n+        DefaultImprovements out = new DefaultImprovements();\n+        new GitHubTicketFetcher().fetchTickets(authToken.getToken(), contributions.getAllTickets(), out);\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/GitHubTicketFetcher.java\n+package org.mockito.release.notes.improvements;\n+\n+import com.jcabi.github.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class GitHubTicketFetcher {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(GitHubTicketFetcher.class);\n+\n+    void fetchTickets(String gitHubAuthToken, Collection<String> ticketIds, DefaultImprovements improvements) {\n+        if (ticketIds.isEmpty()) {\n+            return;\n+        }\n+        try {\n+            //TODO if possible we should query for all tickets via one REST call and perhaps stop using jcapi\n+            LOG.info(\"Querying GitHub API for {} tickets\", ticketIds.size());\n+            RtGithub github = new RtGithub(gitHubAuthToken);\n+            Repo repo = github.repos().get(new Coordinates.Simple(\"mockito/mockito\"));\n+            Issues issues = repo.issues();\n+            for (String ticketId : ticketIds) {\n+                LOG.info(\" #{}\", ticketId);\n+                //TODO make ticked id an int\n+                Issue i = issues.get(Integer.parseInt(ticketId));\n+                Issue.Smart issue = new Issue.Smart(i);\n+                if (issue.exists() && !issue.isOpen()) {\n+                    improvements.add(new Improvement(issue.number(), issue.title(), issue.htmlUrl().toString(),\n+                            labels(issue.labels())));\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems fetching \" + ticketIds.size() + \" from GitHub\", e);\n+        }\n+    }\n+\n+    private static Set<String> labels(IssueLabels labels) {\n+        Set<String> out = new HashSet<String>();\n+        for (Label label : labels.iterate()) {\n+            out.add(label.name());\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/Improvement.java\n+package org.mockito.release.notes.improvements;\n+\n+import java.net.URL;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+class Improvement {\n+\n+    private final int id;\n+    private final String title;\n+    private final String url;\n+    private final Collection<String> labels;\n+\n+    public Improvement(int id, String title, String url, Collection<String> labels) {\n+        this.id = id;\n+        this.title = title;\n+        this.url = url;\n+        this.labels = labels;\n+    }\n+\n+    public String toText() {\n+        return title + \" [(#\" + id + \")](\" + url + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/ImprovementSet.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.util.HumanReadable;\n+\n+/**\n+ * the improvements\n+ */\n+public interface ImprovementSet extends HumanReadable {\n+\n+    /**\n+     * human readable representation of the improvements\n+     */\n+    String toText();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/Improvements.java\n+package org.mockito.release.notes.improvements;\n+\n+/**\n+ * Improvements based on some issue tracking system outside of the vcs.\n+ */\n+public class Improvements {\n+\n+    /**\n+     * Fetches tickets from GitHub. Needs GitHub auth token.\n+     *\n+     * @param authTokenEnvVarName name of the env var that holds the token\n+     */\n+    public static ImprovementsProvider getGitHubProvider(final String authTokenEnvVarName) {\n+        return new GitHubImprovementsProvider(new GitHubAuthToken(authTokenEnvVarName));\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/improvements/ImprovementsProvider.java\n+package org.mockito.release.notes.improvements;\n+\n+import org.mockito.release.notes.vcs.ContributionSet;\n+\n+public interface ImprovementsProvider {\n+\n+    ImprovementSet getImprovements(ContributionSet contributions);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/util/HumanReadable.java\n+package org.mockito.release.notes.util;\n+\n+/**\n+ * Human readable text representation\n+ */\n+public interface HumanReadable {\n+\n+    /**\n+     * the text representation\n+     */\n+    String toText();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/util/Predicate.java\n+package org.mockito.release.notes.util;\n+\n+/**\n+ * Generic predicate\n+ */\n+public interface Predicate<T> {\n+\n+    /**\n+     * returns true if the predicate is satisfied for given object\n+     */\n+    boolean isTrue(T object);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/util/ReleaseNotesException.java\n+package org.mockito.release.notes.util;\n+\n+public class ReleaseNotesException extends RuntimeException {\n+\n+    public ReleaseNotesException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/Commit.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.Collection;\n+\n+public interface Commit {\n+\n+    /**\n+     * Author identifier. For git it would be 'email'\n+     */\n+    String getAuthorId();\n+\n+    /**\n+     * Author display name. For git it would be 'author'\n+     */\n+    String getAuthor();\n+\n+    /**\n+     * Commit message\n+     */\n+    String getMessage();\n+\n+    /**\n+     * Tickets referenced by the commit. For example, jira issue ids or GitHub issue ids.\n+     */\n+    Collection<String> getTickets();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/Contribution.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+class Contribution implements Comparable<Contribution> {\n+\n+    //email identifies the contributor, author alias not necessarily\n+    final String authorId;\n+    final String author;\n+    final List<Commit> commits = new LinkedList<Commit>();\n+\n+    Contribution(Commit commit) {\n+        authorId = commit.getAuthorId();\n+        author = commit.getAuthor();\n+        commits.add(commit);\n+    }\n+\n+    Contribution add(Commit commit) {\n+        assert authorId.equals(commit.getAuthorId());\n+        commits.add(commit);\n+        return this;\n+    }\n+\n+    public String toText() {\n+        return commits.size() + \": \" + author;\n+    }\n+\n+    public int compareTo(Contribution other) {\n+        return Integer.valueOf(other.getCommits().size()).compareTo(commits.size());\n+    }\n+\n+    public Collection<Commit> getCommits() {\n+        return commits;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/ContributionSet.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.HumanReadable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A set of contributions\n+ */\n+public interface ContributionSet extends HumanReadable {\n+\n+    /**\n+     * all commits in given contribution set, spanning all authors\n+     */\n+    Collection<Commit> getAllCommits();\n+\n+    /**\n+     * all tickets referenced in commit messages\n+     */\n+    Collection<String> getAllTickets();\n+\n+    /**\n+     * human readable text representation\n+     */\n+    String toText();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/ContributionsProvider.java\n+package org.mockito.release.notes.vcs;\n+\n+/**\n+ * Knows the contributions\n+ */\n+public interface ContributionsProvider {\n+\n+    /**\n+     * Provides contributions between specified versions\n+     */\n+    ContributionSet getContributionsBetween(String fromRev, String toRev);\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/DefaultContributionSet.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.Predicate;\n+\n+import java.util.*;\n+\n+class DefaultContributionSet implements ContributionSet {\n+    private final Map<String, Contribution> contributions = new HashMap<String, Contribution>();\n+    private final Collection<Commit> commits = new LinkedList<Commit>();\n+    private final Predicate<Commit> ignoreCommit;\n+    private final Set<String> tickets = new LinkedHashSet<String>();\n+\n+    public DefaultContributionSet(Predicate<Commit> ignoredCommit) {\n+        this.ignoreCommit = ignoredCommit;\n+    }\n+\n+    void add(Commit commit) {\n+        if (ignoreCommit.isTrue(commit)) {\n+            return;\n+        }\n+        commits.add(commit);\n+        tickets.addAll(commit.getTickets());\n+        Contribution c = contributions.get(commit.getAuthorId());\n+        if (c == null) {\n+            contributions.put(commit.getAuthorId(), new Contribution(commit));\n+        } else {\n+            c.add(commit);\n+        }\n+    }\n+\n+    public Collection<Commit> getAllCommits() {\n+        return commits;\n+    }\n+\n+    public Collection<String> getAllTickets() {\n+        return tickets;\n+    }\n+\n+    public String toText() {\n+        StringBuilder sb = new StringBuilder(\"* Authors: \").append(contributions.size())\n+                .append(\"\\n* Commits: \").append(commits.size());\n+\n+        for (Map.Entry<String, Contribution> entry : sortByValue(contributions)) {\n+            Contribution c = entry.getValue();\n+            sb.append(\"\\n  * \").append(c.toText());\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static <K, V extends Comparable<V>> List<Map.Entry<K, V>> sortByValue(Map<K, V> map) {\n+        List<Map.Entry<K, V>> entries = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n+        Collections.sort(entries, new ByValue<K, V>());\n+        return entries;\n+    }\n+\n+    private static class ByValue<K, V extends Comparable<V>> implements Comparator<Map.Entry<K, V>> {\n+        public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n+            return o1.getValue().compareTo(o2.getValue());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/GitCommit.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+\n+class GitCommit implements Commit {\n+\n+    private final String email;\n+    private final String author;\n+    private final String message;\n+    private Set<String> tickets;\n+\n+    public GitCommit(String email, String author, String message) {\n+        this.email = email;\n+        this.author = author;\n+        this.message = message;\n+        this.tickets = TicketParser.parseTickets(message);\n+    }\n+\n+    public String getAuthorId() {\n+        return email;\n+    }\n+\n+    public String getAuthor() {\n+        return author;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    public Collection<String> getTickets() {\n+        return tickets;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/GitContributionsProvider.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.Predicate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class GitContributionsProvider implements ContributionsProvider {\n+\n+    private static Logger LOG = LoggerFactory.getLogger(GitContributionsProvider.class);\n+    private final GitLogProvider logProvider;\n+    private final Predicate<Commit> ignoredCommit;\n+\n+    GitContributionsProvider(GitLogProvider logProvider, Predicate<Commit> ignoredCommit) {\n+        this.logProvider = logProvider;\n+        this.ignoredCommit = ignoredCommit;\n+    }\n+\n+    public ContributionSet getContributionsBetween(String fromRev, String toRev) {\n+        LOG.info(\"Fetching {} from the repo\", fromRev);\n+\n+        LOG.info(\"Loading all commits between {} and {}\", fromRev, toRev);\n+\n+        String commitToken = \"@@commit@@\";\n+        String infoToken = \"@@info@@\";\n+        String log = logProvider.getLog(fromRev, toRev, \"--pretty=format:%ae\" + infoToken + \"%an\" + infoToken + \"%B%N\" + commitToken);\n+\n+        DefaultContributionSet contributions = new DefaultContributionSet(ignoredCommit);\n+\n+        for (String entry : log.split(commitToken)) {\n+            String[] entryParts = entry.split(infoToken);\n+            if (entryParts.length == 3) {\n+                String email = entryParts[0].trim();\n+                String author = entryParts[1].trim();\n+                String message = entryParts[2].trim();\n+                contributions.add(new GitCommit(email, author, message));\n+            }\n+        }\n+\n+        return contributions;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/GitLogProvider.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.exec.ProcessRunner;\n+\n+class GitLogProvider {\n+\n+    private final ProcessRunner runner;\n+\n+    GitLogProvider(ProcessRunner runner) {\n+        this.runner = runner;\n+    }\n+\n+    public String getLog(String fromRev, String toRev, String format) {\n+        runner.run(\"git\", \"fetch\", \"origin\", \"+refs/tags/\" + fromRev + \":refs/tags/\" + fromRev);\n+        return runner.run(\"git\", \"log\", format, fromRev + \"..\" + toRev);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/IgnoreCiSkip.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.util.Predicate;\n+\n+/**\n+ * Ignores commits with [ci skip]\n+ */\n+class IgnoreCiSkip implements Predicate<Commit> {\n+\n+    public boolean isTrue(Commit commit) {\n+        //we used #id for Travis CI build number in commits performed by Travis. Let's avoid pulling those ids here.\n+        //also, if ci was skipped we probably are not interested in such change, no?\n+        //Currently, all our [ci skip] are infrastructure commits plus documentation changes made by humans via github web interface\n+        return commit.getMessage().contains(\"[ci skip]\");\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/TicketParser.java\n+package org.mockito.release.notes.vcs;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class TicketParser {\n+\n+    /**\n+     * Collects all ticked ids found in message, ticket format is #123\n+     */\n+    static Set<String> parseTickets(String message) {\n+        Set<String> tickets = new LinkedHashSet<String>();\n+        Pattern ticket = Pattern.compile(\"#\\\\d+\");\n+        Matcher m = ticket.matcher(message);\n+        while(m.find()) {\n+            String ticketId = m.group().substring(1); //remove leading '#'\n+            tickets.add(ticketId);\n+        }\n+        return tickets;\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/vcs/Vcs.java\n+package org.mockito.release.notes.vcs;\n+\n+import org.mockito.release.notes.exec.ProcessRunner;\n+\n+/**\n+ * Vcs services\n+ */\n+public class Vcs {\n+\n+    /**\n+     * Provides means to get contributions.\n+     */\n+    public static ContributionsProvider getGitProvider(ProcessRunner runner) {\n+        return new GitContributionsProvider(new GitLogProvider(runner), new IgnoreCiSkip());\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/versions/FromNotesContent.java\n+package org.mockito.release.notes.versions;\n+\n+import org.mockito.release.notes.util.ReleaseNotesException;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Retrieves previously released version based on the top entry in the current release notes content.\n+ */\n+class FromNotesContent implements PreviousVersion {\n+\n+    private final String releaseNotesContent;\n+\n+    FromNotesContent(String releaseNotesContent) {\n+        this.releaseNotesContent = releaseNotesContent;\n+    }\n+\n+    public String getPreviousVersion() {\n+        //Example: \"### 1.9.5 (06-10-2012)\", we want to extract \"1.9.5\"\n+        Pattern p = Pattern.compile(\"(?s)^### (.+?) .*\");\n+        Matcher m = p.matcher(releaseNotesContent);\n+        if(!m.matches()) {\n+            throw new ReleaseNotesException(\"Unable to parse previous version from release notes content: \" + releaseNotesContent, null);\n+        }\n+        return m.group(1);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/versions/PreviousVersion.java\n+package org.mockito.release.notes.versions;\n+\n+/**\n+ * Provides the previous version.\n+ */\n+public interface PreviousVersion {\n+\n+    /**\n+     * The previous version\n+     */\n+    String getPreviousVersion();\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/notes/versions/Versions.java\n+package org.mockito.release.notes.versions;\n+\n+/**\n+ * Version services\n+ */\n+public class Versions {\n+\n+    /**\n+     * Provides a way to retrieve previous version based on the content of the release notes file.\n+     */\n+    public static PreviousVersion previousFromNotesContent(String notesContent) {\n+        return new FromNotesContent(notesContent);\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/util/ArgumentValidation.java\n+package org.mockito.release.util;\n+\n+/**\n+ * Utility for validation of arguments\n+ */\n+public abstract class ArgumentValidation {\n+\n+    /**\n+     * None of the input targets can not be null otherwise IllegalArgumentException is thrown.\n+     * Every second argument must a String describing the previous element.\n+     */\n+    public static void notNull(Object ... targets) {\n+        if (targets.length % 2 != 0) {\n+            throw new IllegalArgumentException(\"notNull method requires pairs of argument + message\");\n+        }\n+\n+        boolean nullFound = false;\n+        for (Object t : targets) {\n+            if (t == null) {\n+                nullFound = true;\n+                continue;\n+            }\n+            if (nullFound) {\n+                if (!(t instanceof String)) {\n+                    throw new IllegalArgumentException(\"notNull method requires pairs of argument + message\");\n+                }\n+                throw new IllegalArgumentException(((String) t).concat(\" cannot be null.\"));\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/buildSrc/src/main/java/org/mockito/release/util/InputOutput.java\n+package org.mockito.release.util;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+/**\n+ * Utility for input/output\n+ */\n+public class InputOutput {\n+\n+    /**\n+     * Closes input, does nothing when input is null\n+     */\n+    public static void closeStream(Closeable closable) {\n+        if (closable != null) {\n+            try {\n+                closable.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Problems closing stream.\", e);\n+            }\n+        }\n+    }\n+}", "timestamp": 1416674238, "metainfo": ""}