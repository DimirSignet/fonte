{"sha": "0947b49f60739d7a09f8158e8a6ea653e385448e", "log": "Identify mocks class in MockUtil", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n package org.mockito.internal.creation;\n \n import org.mockito.Incubating;\n-import org.mockito.cglib.proxy.Factory;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n  * TODO Use a constant for the class annotation marker\n  * TODO Use proper MockitoException\n  * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n- * TODO place Mockito mock identification logic in MockUtil\n  * TODO check the class is mockable in the deserialization side\n  *\n  * @author Brice Dutheil\n      *\n      */\n     private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n+\n+        private MockUtil mockUtil = new MockUtil();\n+\n         public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n             super(out);\n         }\n          * @return The marker if this is a Mockito proxy class, otherwise returns a void marker.\n          */\n         private String mockitoProxyClassMarker(Class<?> cl) {\n-            // TODO place logic in MockUtil\n-            if (Factory.class.isAssignableFrom(cl)) {\n+            if (mockUtil.isMock(cl)) {\n                 return \"MockitoProxyMarker\";\n             } else {\n                 return \"\";\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n     }\n \n     public boolean isSpy(Object mock) {\n-        return mock instanceof MockitoSpy; // && isMock(mock);\n+        return mock instanceof MockitoSpy;\n+    }\n+\n+    public boolean isMock(Class mockClass) {\n+        return mockClass != null && MockitoMock.class.isAssignableFrom(mockClass);\n+    }\n+\n+    public boolean isSpy(Class mockClass) {\n+        return mockClass != null && MockitoSpy.class.isAssignableFrom(mockClass);\n     }\n \n     private <T> boolean isMockitoMock(T mock) {\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n     public void should_validate_mock() {\n         assertFalse(mockUtil.isMock(\"i mock a mock\"));\n         assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n+        assertFalse(mockUtil.isMock((Class) null));\n+        assertFalse(mockUtil.isMock(String.class));\n+        assertTrue(mockUtil.isMock(Mockito.mock(List.class).getClass()));\n     }\n \n     @Test\n         assertFalse(mockUtil.isSpy(\"i mock a mock\"));\n         assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));\n         assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));\n+        assertFalse(mockUtil.isSpy((Class) null));\n+        assertFalse(mockUtil.isSpy(String.class));\n+        assertFalse(mockUtil.isSpy(Mockito.mock(List.class).getClass()));\n+        assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList()).getClass()));\n     }\n \n     @Test", "timestamp": 1355623659, "metainfo": ""}