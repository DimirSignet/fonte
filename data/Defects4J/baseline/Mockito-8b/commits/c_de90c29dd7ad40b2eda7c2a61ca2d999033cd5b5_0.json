{"sha": "de90c29dd7ad40b2eda7c2a61ca2d999033cd5b5", "log": "issue 256: IndexOutOfBoundsException was thrown when OngoingStubbingImpl.thenReturn is called two times -> now report incorrect use of API", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         ));\n     }\n \n+    public void incorrectUseOfApi() {\n+        throw new MockitoException(join(\n+                \"Incorrect use of API detected here:\",\n+                new Location(),\n+                \"\",\n+                \"You probably stored a reference to OngoingStubbing returned by when() and called stubbing methods like thenReturn() on this reference more than once.\",\n+                \"Examples of correct usage:\",\n+                \"    when(mock.isOk()).thenReturn(true).thenReturn(false).thenThrow(exception);\",\n+                \"    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);\",\n+                \"\"\n+        ));\n+    }\n+\n     public void missingMethodInvocation() {\n         throw new MissingMethodInvocationException(join(\n                 \"when() requires an argument which has to be 'a method call on a mock'.\",\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n         return !answersForStubbing.isEmpty();\n     }\n \n+    public boolean hasInvocationForPotentialStubbing() {\n+        return !registeredInvocations.isEmpty();\n+    }\n+\n     public void setMethodForStubbing(InvocationMatcher invocation) {\n         invocationForStubbing = invocation;\n         assert hasAnswersForStubbing();\n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n  */\n package org.mockito.internal.stubbing;\n \n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.DeprecatedOngoingStubbing;\n     }\n \n     public OngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+        if(!invocationContainerImpl.hasInvocationForPotentialStubbing()) {\n+            new Reporter().incorrectUseOfApi();\n+        }\n+\n         invocationContainerImpl.addAnswer(answer);\n         return new ConsecutiveStubbing<T>(invocationContainerImpl);\n     }\n     public <M> M getMock() {\n         return (M) invocationContainerImpl.invokedMock();\n     }\n-}\n+}\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n  */\n package org.mockito.internal.verification;\n \n-import java.io.Serializable;\n-import java.util.*;\n-\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n \n public class RegisteredInvocations implements Serializable {\n         return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());\n     }\n \n+    public boolean isEmpty() {\n+        return invocations.isEmpty();\n+    }\n+\n     private static class RemoveToString implements Filter<Invocation> {\n         public boolean isOut(Invocation invocation) {\n             return invocation.isToString();\n         }\n     }\n-}\n+}\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n \n import java.util.LinkedList;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  * Author: Szczepan Faber\n         }\n \n         //when\n-        for (int i = 0; i < t.length; i++ ) {\n-            t[i].join();\n+        for (Thread aT : t) {\n+            aT.join();\n         }\n \n         //then\n \n         assertEquals(invocation.getMock(), container.invokedMock());\n     }\n+\n+    @Test\n+    public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        assertTrue(container.hasInvocationForPotentialStubbing());\n+\n+        container.addAnswer(new ReturnsEmptyValues());\n+        assertFalse(container.hasInvocationForPotentialStubbing());\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.stubbing.OngoingStubbing;\n+\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest {\n+\n+    @Test\n+    public void second_stubbing_throws_IndexOutOfBoundsException() throws Exception {\n+        Map<String, String> map = mock(Map.class);\n+\n+        OngoingStubbing<String> mapOngoingStubbing = when(map.get(anyString()));\n+\n+        mapOngoingStubbing.thenReturn(\"first stubbing\");\n+\n+        try {\n+            mapOngoingStubbing.thenReturn(\"second stubbing\");\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage())\n+                    .contains(\"Incorrect use of API detected here\")\n+                    .contains(this.getClass().getSimpleName());\n+        }\n+    }\n+}", "timestamp": 1308160565, "metainfo": ""}