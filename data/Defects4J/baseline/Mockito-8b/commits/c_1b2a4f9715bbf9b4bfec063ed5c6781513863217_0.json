{"sha": "1b2a4f9715bbf9b4bfec063ed5c6781513863217", "log": "Insulated most cglib in a separate package  Majority of classes in this package are not public. I'd like to insulate all cglib so that it can be replaced easily.", "commit": "\n--- a/src/org/mockito/internal/creation/cglib/AbstractMockitoMethodProxy.java\n+++ b/src/org/mockito/internal/creation/cglib/AbstractMockitoMethodProxy.java\n  */\n package org.mockito.internal.creation.cglib;\n \n-public abstract class AbstractMockitoMethodProxy implements MockitoMethodProxy {\n+abstract class AbstractMockitoMethodProxy implements MockitoMethodProxy {\n \n     public Object invokeSuper(Object target, Object[] arguments) throws Throwable {\n         return getMethodProxy().invokeSuper(target, arguments);\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoSerializationIssue;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+import org.mockito.mock.SerializableMode;\n+\n+import java.io.*;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n+\n+/**\n+ * This is responsible for serializing a mock, it is enabled if the mock is implementing\n+ * {@link Serializable}.\n+ *\n+ * <p>\n+ *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},\n+ *     if the mock settings is set to be serializable it will add the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable}\n+ *     interface.\n+ *     This interface defines a the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n+ *     whose signature match the one that is looked by the standard Java serialization.\n+ * </p>\n+ *\n+ * <p>\n+ *     Then in the {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter} of mockito, if the <code>writeReplace</code> method is called,\n+ *     it will use the custom implementation of this class {@link #writeReplace(Object)}. This method has a specific\n+ *     knowledge on how to serialize a mockito mock that is based on CGLIB.\n+ * </p>\n+ *\n+ * <p><strong>Only one instance per mock! See {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter}</strong></p>\n+ *\n+ * TODO use a proper way to add the interface\n+ * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n+ * TODO check the class is mockable in the deserialization side\n+ *\n+ * @see org.mockito.internal.creation.cglib.CglibMockMaker\n+ * @see org.mockito.internal.creation.cglib.MethodInterceptorFilter\n+ * @author Brice Dutheil\n+ * @since 1.10.0\n+ */\n+@Incubating\n+class AcrossJVMSerializationFeature implements Serializable {\n+    private static final long serialVersionUID = 7411152578314420778L;\n+    private static final String MOCKITO_PROXY_MARKER = \"MockitoProxyMarker\";\n+    private boolean instanceLocalCurrentlySerializingFlag = false;\n+    private final Lock mutex = new ReentrantLock();\n+\n+    public boolean isWriteReplace(Method method) {\n+        return  method.getReturnType() == Object.class\n+                && method.getParameterTypes().length == 0\n+                && method.getName().equals(\"writeReplace\");\n+    }\n+\n+\n+    /**\n+     * Custom implementation of the <code>writeReplace</code> method for serialization.\n+     *\n+     * Here's how it's working and why :\n+     * <ol>\n+     *     <li>\n+     *         <p>When first entering in this method, it's because some is serializing the mock, with some code like :\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     objectOutputStream.writeObject(mock);\n+     * </code></pre>\n+     *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and\n+     *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.\n+     *         At this point, the code will return an\n+     *         {@link AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy}.</p>\n+     *     </li>\n+     *     <li>\n+     *         <p>Now, in the constructor\n+     *         {@link AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n+     *         the mock is being serialized in a custom way (using\n+     *         {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream}) to a\n+     *         byte array. So basically it means the code is performing double nested serialization of the passed\n+     *         <code>mockitoMock</code>.</p>\n+     *\n+     *         <p>However the <code>ObjectOutputStream</code> will still detect the custom\n+     *         <code>writeReplace</code> and execute it.\n+     *         <em>(For that matter disabling replacement via {@link ObjectOutputStream#enableReplaceObject(boolean)}\n+     *         doesn't disable the <code>writeReplace</code> call, but just just toggle replacement in the\n+     *         written stream, <strong><code>writeReplace</code> is always called by\n+     *         <code>ObjectOutputStream</code></strong>.)</em></p>\n+     *\n+     *         <p>In order to avoid this recursion, obviously leading to a {@link StackOverflowError}, this method is using\n+     *         a flag that marks the mock as already being replaced, and then shouldn't replace itself again.\n+     *         <strong>This flag is local to this class</strong>, which means the flag of this class unfortunately needs\n+     *         to be protected against concurrent access, hence the reentrant lock.</p>\n+     *     </li>\n+     * </ol>\n+     *\n+     *\n+     * @param mockitoMock The Mockito mock to be serialized.\n+     * @return A wrapper ({@link AcrossJVMMockSerializationProxy}) to be serialized by the calling ObjectOutputStream.\n+     * @throws ObjectStreamException\n+     */\n+    public Object writeReplace(Object mockitoMock) throws ObjectStreamException {\n+        try {\n+            // reentrant lock for critical section. could it be improved ?\n+            mutex.lock();\n+            // mark started flag // per thread, not per instance\n+            // temporary loosy hack to avoid stackoverflow\n+            if(mockIsCurrentlyBeingReplaced()) {\n+                return mockitoMock;\n+            }\n+            mockReplacementStarted();\n+\n+            return new AcrossJVMMockSerializationProxy(mockitoMock);\n+        } catch (IOException ioe) {\n+            MockUtil mockUtil = new MockUtil();\n+            MockName mockName = mockUtil.getMockName(mockitoMock);\n+            String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();\n+            throw new MockitoSerializationIssue(join(\n+                    \"The mock '\" + mockName + \"' of type '\" + mockedType + \"'\",\n+                    \"The Java Standard Serialization reported an '\" + ioe.getClass().getSimpleName() + \"' saying :\",\n+                    \"  \" + ioe.getMessage()\n+            ), ioe);\n+        } finally {\n+            // unmark\n+            mockReplacementCompleted();\n+            mutex.unlock();\n+        }\n+    }\n+\n+\n+    private void mockReplacementCompleted() {\n+        instanceLocalCurrentlySerializingFlag = false;\n+    }\n+\n+\n+    private void mockReplacementStarted() {\n+        instanceLocalCurrentlySerializingFlag = true;\n+    }\n+\n+\n+    private boolean mockIsCurrentlyBeingReplaced() {\n+        return instanceLocalCurrentlySerializingFlag;\n+    }\n+\n+\n+    /**\n+     * Enable serialization serialization that will work across classloaders / and JVM.\n+     *\n+     * <p>Only enable if settings says the mock should be serializable. In this case add the\n+     * {@link AcrossJVMMockitoMockSerializable} to the extra interface list.</p>\n+     *\n+     * @param settings Mock creation settings.\n+     * @param <T> Type param to not be bothered by the generics\n+     */\n+    public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {\n+        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n+            // havin faith that this set is modifiable\n+            // TODO use a proper way to add the interface\n+            settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerializable.class);\n+        }\n+    }\n+\n+\n+    /**\n+     * This is the serialization proxy that will encapsulate the real mock data as a byte array.\n+     *\n+     * <p>When called in the constructor it will serialize the mock in a byte array using a\n+     * custom {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream} that\n+     * will annotate the mock class in the stream.\n+     * Other information are used in this class in order to facilitate deserialization.\n+     * </p>\n+     *\n+     * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via\n+     * the custom {@link MockitoMockObjectInputStream} that will be in charge of creating the mock class.</p>\n+     */\n+    public static class AcrossJVMMockSerializationProxy implements Serializable {\n+\n+\n+        private static final long serialVersionUID = -7600267929109286514L;\n+        private final byte[] serializedMock;\n+        private final Class typeToMock;\n+        private final Set<Class> extraInterfaces;\n+        /**\n+         * Creates the wrapper that be used in the serialization stream.\n+         *\n+         * <p>Immediately serializes the Mockito mock using specifically crafted\n+         * {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream},\n+         * in a byte array.</p>\n+         *\n+         * @param mockitoMock The Mockito mock to serialize.\n+         * @throws IOException\n+         */\n+        public AcrossJVMMockSerializationProxy(Object mockitoMock) throws IOException {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);\n+\n+            objectOutputStream.writeObject(mockitoMock);\n+\n+            objectOutputStream.close();\n+            out.close();\n+\n+            MockCreationSettings mockSettings = new MockUtil().getMockSettings(mockitoMock);\n+            this.serializedMock = out.toByteArray();\n+            this.typeToMock = mockSettings.getTypeToMock();\n+            this.extraInterfaces = mockSettings.getExtraInterfaces();\n+        }\n+\n+        /**\n+         * Resolves the proxy to a new deserialized instance of the Mockito mock.\n+         *\n+         * <p>Uses the custom crafted {@link MockitoMockObjectInputStream} to deserialize the mock.</p>\n+         *\n+         * @return A deserialized instance of the Mockito mock.\n+         * @throws ObjectStreamException\n+         */\n+        private Object readResolve() throws ObjectStreamException {\n+            try {\n+                ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);\n+                ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);\n+\n+                Object deserializedMock = objectInputStream.readObject();\n+\n+                bis.close();\n+                objectInputStream.close();\n+\n+                return deserializedMock;\n+            } catch (IOException ioe) {\n+                throw new MockitoSerializationIssue(join(\n+                        \"Mockito mock cannot be deserialized to a mock of '\" + typeToMock.getCanonicalName() + \"'. The error was :\",\n+                        \"  \" + ioe.getMessage(),\n+                        \"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), ioe);\n+            } catch (ClassNotFoundException cce) {\n+                throw new MockitoSerializationIssue(join(\n+                        \"A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :\",\n+                        \"  \" + cce.getMessage(),\n+                        \"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), cce);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectInputStream</code> that will resolve the Mockito proxy class.\n+     *\n+     * <p>\n+     *     This specificaly crafted ObjectInoutStream has the most important role to resolve the Mockito generated\n+     *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream\n+     *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it\n+     *     delegates class resolution to the default super behavior.\n+     *     The mirror method used for serializing the mock is\n+     *     {@link AcrossJVMSerializationFeature.MockitoMockObjectOutputStream#annotateClass(Class)}.\n+     * </p>\n+     *\n+     * <p>\n+     *     When this marker is found, {@link ClassImposterizer} methods are being used to create the mock class.\n+     *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the\n+     *     {@link SearchingClassLoader} that will look if this enhanced class has\n+     *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer\n+     *     code.</em>\n+     * </p>\n+     */\n+    public static class MockitoMockObjectInputStream extends ObjectInputStream {\n+        private final Class typeToMock;\n+        private final Set<Class> extraInterfaces;\n+\n+        public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {\n+            super(in) ;\n+            this.typeToMock = typeToMock;\n+            this.extraInterfaces = extraInterfaces;\n+            enableResolveObject(true); // ensure resolving is enabled\n+        }\n+\n+        /**\n+         * Resolve the Mockito proxy class if it is marked as such.\n+         *\n+         * <p>Uses the fields {@link #typeToMock} and {@link #extraInterfaces} to\n+         * create the Mockito proxy class as the <code>ObjectStreamClass</code>\n+         * doesn't carry useful information for this purpose.</p>\n+         *\n+         * @param desc Description of the class in the stream, not used.\n+         * @return The class that will be used to deserialize the instance mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+            if (notMarkedAsAMockitoMock(readObject())) {\n+                return super.resolveClass(desc);\n+            }\n+\n+            // TODO check the class is mockable in the deserialization side\n+            // ClassImposterizer.INSTANCE.canImposterise(typeToMock);\n+\n+            // create the Mockito mock class before it can even be deserialized\n+            //TODO SF unify creation of imposterizer, constructor code duplicated\n+            ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator());\n+            imposterizer.setConstructorsAccessible(typeToMock, true);\n+            Class<?> proxyClass = imposterizer.createProxyClass(\n+                    typeToMock,\n+                    extraInterfaces.toArray(new Class[extraInterfaces.size()])\n+            );\n+\n+            hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);\n+\n+            return proxyClass;\n+\n+        }\n+\n+        /**\n+         * Hack the <code>name</code> field of the given <code>ObjectStreamClass</code> with\n+         * the <code>newProxyClass</code>.\n+         *\n+         * The parent ObjectInputStream will check the name of the class in the stream matches the name of the one\n+         * that is created in this method.\n+         *\n+         * The CGLIB classes uses a hash of the classloader and/or maybe some other data that allow them to be\n+         * relatively unique in a JVM.\n+         *\n+         * When names differ, which happens when the mock is deserialized in another ClassLoader, a\n+         * <code>java.io.InvalidObjectException</code> is thrown, so this part of the code is hacking through\n+         * the given <code>ObjectStreamClass</code> to change the name with the newly created class.\n+         *\n+         * @param descInstance The <code>ObjectStreamClass</code> that will be hacked.\n+         * @param proxyClass The proxy class whose name will be applied.\n+         * @throws InvalidObjectException\n+         */\n+        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {\n+            try {\n+              Field classNameField = descInstance.getClass().getDeclaredField(\"name\");\n+              new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());\n+            } catch (NoSuchFieldException nsfe) {\n+                // TODO use our own mockito mock serialization exception\n+                throw new MockitoSerializationIssue(join(\n+                        \"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',\",\n+                        \"this is definitely a bug in our code as it means the JDK team changed a few internal things.\",\n+                        \"\",\n+                        \"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome.\"\n+                ), nsfe);\n+            }\n+        }\n+\n+        /**\n+         * Read the stream class annotation and identify it as a Mockito mock or not.\n+         *\n+         * @param marker The marker to identify.\n+         * @return <code>true</code> if not marked as a Mockito, <code>false</code> if the class annotation marks a Mockito mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {\n+            return !MOCKITO_PROXY_MARKER.equals(marker);\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectOutputStream</code>.\n+     *\n+     * <p>\n+     *     This output stream has the role of marking in the stream the Mockito class. This\n+     *     marking process is necessary to identify the proxy class that will need to be recreated.\n+     *\n+     *     The mirror method used for deserializing the mock is\n+     *     {@link MockitoMockObjectInputStream#resolveClass(ObjectStreamClass)}.\n+     * </p>\n+     *\n+     */\n+    private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n+        private static final String NOTHING = \"\";\n+\n+        public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n+            super(out);\n+        }\n+\n+        /**\n+         * Annotates (marks) the class if this class is a Mockito mock.\n+         *\n+         * @param cl The class to annotate.\n+         * @throws IOException\n+         */\n+        @Override\n+        protected void annotateClass(Class<?> cl) throws IOException {\n+            writeObject(mockitoProxyClassMarker(cl));\n+            // might be also useful later, for embedding classloader info ...maybe ...maybe not\n+        }\n+\n+        /**\n+         * Returns the Mockito marker if this class is a Mockito mock.\n+         *\n+         * @param cl The class to mark.\n+         * @return The marker if this is a Mockito proxy class, otherwise returns a void marker.\n+         */\n+        private String mockitoProxyClassMarker(Class<?> cl) {\n+            if (AcrossJVMMockitoMockSerializable.class.isAssignableFrom(cl)) {\n+                return MOCKITO_PROXY_MARKER;\n+            } else {\n+                return NOTHING;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an\n+     * <code>ObjectOutputStream</code>.\n+     *\n+     * It will be applied before the creation of the mock when the mock setting says it should serializable.\n+     *\n+     * @see #enableSerializationAcrossJVM(org.mockito.mock.MockCreationSettings)\n+     */\n+    public interface AcrossJVMMockitoMockSerializable {\n+        public Object writeReplace() throws java.io.ObjectStreamException;\n+    }\n+}\n--- a/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n+++ b/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n import java.io.Serializable;\n import java.lang.reflect.Field;\n \n-public class CGLIBHacker implements Serializable {\n+class CGLIBHacker implements Serializable {\n \n     private static final long serialVersionUID = -4389233991416356668L;\n \n--- a/src/org/mockito/internal/creation/cglib/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/cglib/CglibMockMaker.java\n import org.mockito.cglib.proxy.Factory;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.creation.AcrossJVMSerializationFeature;\n import org.mockito.internal.creation.instance.InstantiatorProvider;\n-import org.mockito.internal.creation.jmock.CglibClassImposterizer;\n import org.mockito.invocation.MockHandler;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.plugins.MockMaker;\n     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n         InternalMockHandler mockitoHandler = cast(handler);\n         new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);\n-        return new CglibClassImposterizer(new InstantiatorProvider().getInstantiator()).imposterise(\n+        return new ClassImposterizer(new InstantiatorProvider().getInstantiator()).imposterise(\n                 new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/ClassImposterizer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.core.CodeGenerationException;\n+import org.mockito.cglib.core.NamingPolicy;\n+import org.mockito.cglib.core.Predicate;\n+import org.mockito.cglib.proxy.*;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.instance.Instantiator;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n+\n+/**\n+ * Inspired on jMock (thanks jMock guys!!!)\n+ */\n+public class ClassImposterizer {\n+\n+    private final Instantiator instantiator;\n+\n+    public ClassImposterizer(Instantiator instantiator) {\n+        this.instantiator = instantiator;\n+    }\n+    \n+    private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {\n+        @Override\n+        public String getClassName(String prefix, String source, Object key, Predicate names) {\n+            return \"codegen.\" + super.getClassName(prefix, source, key, names);\n+        }\n+    };\n+    \n+    private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {\n+        public int accept(Method method) {\n+            return method.isBridge() ? 1 : 0;\n+        }\n+    };\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n+        return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n+    }\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n+        Class<Factory> proxyClass = null;\n+        Object proxyInstance = null;\n+        try {\n+            setConstructorsAccessible(mockedType, true);\n+            proxyClass = createProxyClass(mockedType, ancillaryTypes);\n+            proxyInstance = createProxy(proxyClass, interceptor);\n+            return mockedType.cast(proxyInstance);\n+        } catch (ClassCastException cce) {\n+            throw new MockitoException(join(\n+                \"ClassCastException occurred while creating the mockito proxy :\",\n+                \"  class to mock : \" + describeClass(mockedType),\n+                \"  created class : \" + describeClass(proxyClass),\n+                \"  proxy instance class : \" + describeClass(proxyInstance),\n+                \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n+                \"\",\n+                \"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)\"\n+            ), cce);\n+        } finally {\n+            setConstructorsAccessible(mockedType, false);\n+        }\n+    }\n+\n+    private static String describeClass(Class type) {\n+        return type == null? \"null\" : \"'\" + type.getCanonicalName() + \"', loaded by classloader : '\" + type.getClassLoader() + \"'\";\n+    }\n+\n+    private static String describeClass(Object instance) {\n+        return instance == null? \"null\" : describeClass(instance.getClass());\n+    }\n+\n+    //TODO this method does not belong here\n+    public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n+        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n+            constructor.setAccessible(accessible);\n+        }\n+    }\n+    \n+    public Class<Factory> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {\n+        if (mockedType == Object.class) {\n+            mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n+        }\n+        \n+        Enhancer enhancer = new Enhancer() {\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            protected void filterConstructors(Class sc, List constructors) {\n+                // Don't filter\n+            }\n+        };\n+        Class<?>[] allMockedTypes = prepend(mockedType, interfaces);\n+\t\tenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));\n+        enhancer.setUseFactory(true);\n+        if (mockedType.isInterface()) {\n+            enhancer.setSuperclass(Object.class);\n+            enhancer.setInterfaces(allMockedTypes);\n+        } else {\n+            enhancer.setSuperclass(mockedType);\n+            enhancer.setInterfaces(interfaces);\n+        }\n+        enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\n+        enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\n+        if (mockedType.getSigners() != null) {\n+            enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);\n+        } else {\n+            enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\n+        }\n+\n+        enhancer.setSerialVersionUID(42L);\n+        \n+        try {\n+            return enhancer.createClass(); \n+        } catch (CodeGenerationException e) {\n+            if (Modifier.isPrivate(mockedType.getModifiers())) {\n+                throw new MockitoException(\"\\n\"\n+                        + \"Mockito cannot mock this class: \" + mockedType \n+                        + \".\\n\"\n+                        + \"Most likely it is a private class that is not visible by Mockito\");\n+            }\n+            throw new MockitoException(\"\\n\"\n+                    + \"Mockito cannot mock this class: \" + mockedType \n+                    + \"\\n\" \n+                    + \"Mockito can only mock visible & non-final classes.\"\n+                    + \"\\n\" \n+                    + \"If you're not sure why you're getting this error, please report to the mailing list.\", e);\n+        }\n+    }\n+    \n+    private Object createProxy(Class<Factory> proxyClass, final MethodInterceptor interceptor) {\n+        Factory proxy = instantiator.newInstance(proxyClass);\n+        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n+        return proxy;\n+    }\n+    \n+    private Class<?>[] prepend(Class<?> first, Class<?>... rest) {\n+        Class<?>[] all = new Class<?>[rest.length+1];\n+        all[0] = first;\n+        System.arraycopy(rest, 0, all, 1, rest.length);\n+        return all;\n+    }\n+    \n+    public static class ClassWithSuperclassToWorkAroundCglibBug {}\n+    \n+}\n--- a/src/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java\n+++ b/src/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java\n \n import org.mockito.cglib.proxy.MethodProxy;\n \n-public class DelegatingMockitoMethodProxy extends AbstractMockitoMethodProxy {\n+class DelegatingMockitoMethodProxy extends AbstractMockitoMethodProxy {\n \n     private final MethodProxy methodProxy;\n \n--- a/src/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java\n import org.mockito.cglib.proxy.MethodInterceptor;\n import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.creation.AcrossJVMSerializationFeature;\n import org.mockito.internal.creation.DelegatingMethod;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.MockitoMethod;\n /**\n  * Should be one instance per mock instance, see CglibMockMaker.\n  */\n-public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n+class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private static final long serialVersionUID = 6182795666612683784L;\n     private final InternalMockHandler handler;\n--- a/src/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java\n+++ b/src/org/mockito/internal/creation/cglib/MockitoNamingPolicy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n \n import org.mockito.cglib.core.DefaultNamingPolicy;\n \n-public class MockitoNamingPolicy extends DefaultNamingPolicy {\n+class MockitoNamingPolicy extends DefaultNamingPolicy {\n     \n     public static final MockitoNamingPolicy INSTANCE = new MockitoNamingPolicy(); \n     \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/SearchingClassLoader.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import static java.lang.Thread.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Inspired on jMock (thanks jMock guys!!!)\n+ */\n+class SearchingClassLoader extends ClassLoader {\n+    private final ClassLoader nextToSearch;\n+    \n+    public SearchingClassLoader(ClassLoader parent, ClassLoader nextToSearch) {\n+        super(parent);\n+        this.nextToSearch = nextToSearch;\n+    }\n+    \n+    public static ClassLoader combineLoadersOf(Class<?>... classes) {\n+        return combineLoadersOf(classes[0], classes);\n+    }\n+    \n+    private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {\n+        List<ClassLoader> loaders = new ArrayList<ClassLoader>();\n+        \n+        addIfNewElement(loaders, first.getClassLoader());\n+        for (Class<?> c : others) {\n+            addIfNewElement(loaders, c.getClassLoader());\n+        }\n+        \n+        // To support Eclipse Plug-in tests.\n+        // In an Eclipse plug-in, we will not be on the system class loader\n+        // but in the class loader of the plug-in.\n+        //\n+        // Note: I've been unable to reproduce the error in the test suite.\n+        addIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());\n+        \n+        // To support the Maven Surefire plugin.\n+        // Note: I've been unable to reproduce the error in the test suite.\n+        addIfNewElement(loaders, currentThread().getContextClassLoader());\n+\n+        //Had to comment that out because it didn't work with in-container Spring tests\n+        //addIfNewElement(loaders, ClassLoader.getSystemClassLoader());\n+        \n+        return combine(loaders);\n+    }\n+    \n+    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n+        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n+        \n+        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n+            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n+        }\n+        \n+        return loader;\n+    }\n+    \n+    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n+        if (c != null && !loaders.contains(c)) {\n+            loaders.add(c);\n+        }\n+    }\n+    \n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        if (nextToSearch != null) {\n+            return nextToSearch.loadClass(name);\n+        } else {\n+            return super.findClass(name); // will throw ClassNotFoundException\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java\n+++ b/src/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java\n \n import java.io.Serializable;\n \n-public class SerializableMockitoMethodProxy extends AbstractMockitoMethodProxy implements Serializable {\n+class SerializableMockitoMethodProxy extends AbstractMockitoMethodProxy implements Serializable {\n \n     private static final long serialVersionUID = -5337859962876770632L;\n     private final Class<?> c1;\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/SerializableNoOp.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.NoOp;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Offer a Serializable implementation of the NoOp CGLIB callback.\n+ */\n+class SerializableNoOp implements NoOp, Serializable {\n+\n+  private static final long serialVersionUID = 7434976328690189159L;\n+  public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();\n+\n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.creation.jmock.CglibClassImposterizerTest;\n+import org.mockito.internal.creation.cglib.ClassImposterizerTest;\n import org.mockito.internal.handler.MockHandlerImplTest;\n import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n                     MissingInvocationCheckerTest.class,\n                     NumberOfInvocationsInOrderCheckerTest.class,\n                     MissingInvocationInOrderCheckerTest.class,\n-                    CglibClassImposterizerTest.class,\n+                    ClassImposterizerTest.class,\n                     InvocationMatcherTest.class,\n                     InvocationsFinderTest.class,\n                     InvocationImplTest.class,\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/ClassImposterizerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.instance.ConstructorInstantiator;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ClassImposterizerTest extends TestBase {\n+\n+    ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator());\n+\n+    @Test\n+    public void shouldCreateMockFromInterface() throws Exception {\n+        SomeInterface proxy = imposterizer.imposterise(new MethodInterceptorStub(), SomeInterface.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(Object.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClass() throws Exception {\n+        ClassWithoutConstructor proxy = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(ClassWithoutConstructor.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {\n+        try {\n+            new ClassWithDodgyConstructor();\n+            fail();\n+        } catch (Exception e) {}\n+        \n+        ClassWithDodgyConstructor mock = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);\n+        assertNotNull(mock);\n+    }\n+    \n+    @Test \n+    public void shouldMocksHaveDifferentInterceptors() throws Exception {\n+        SomeClass mockOne = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        SomeClass mockTwo = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        \n+        Factory cglibFactoryOne = (Factory) mockOne;\n+        Factory cglibFactoryTwo = (Factory) mockTwo;\n+        \n+        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n+    }\n+    \n+    @Test\n+    public void shouldUseAnicilliaryTypes() {\n+        SomeClass mock = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);\n+        \n+        assertThat(mock, is(instanceOf(SomeInterface.class)));\n+    }\n+\n+    @Test\n+    public void shouldCreateClassByConstructor() {\n+        imposterizer = new ClassImposterizer(new ConstructorInstantiator());\n+        OtherClass mock = imposterizer.imposterise(new MethodInterceptorStub(), OtherClass.class);\n+        assertNotNull(mock);\n+    }\n+\n+    class SomeClass {}\n+    interface SomeInterface {}\n+    static class OtherClass {}\n+    \n+    private class ClassWithoutConstructor {}\n+\n+    private class ClassWithDodgyConstructor {\n+        public ClassWithDodgyConstructor() {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private final class MethodInterceptorStub implements MethodInterceptor {\n+\n+        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+            return null;\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/ExposedInvocation.java\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n import org.mockito.internal.creation.cglib.MockitoMethodProxy;\n import org.mockito.internal.invocation.realmethod.HasCGLIBMethodProxy;\n \n+//TODO SF try to get rid of so that we can further insulate cglib into separate package\n public class ExposedInvocation {\n \n     private final MockitoMethodProxy methodProxy;\n--- a/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n+++ b/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n                     .containsIgnoringCase(\"MockitoConfiguration\");\n             assertThat(e.getCause())\n                     .satisfies(thatCceIsThrownFrom(\"java.lang.Class.cast\"))\n-                    .satisfies(thatCceIsThrownFrom(\"org.mockito.internal.creation.jmock.ClassImposterizer.imposterise\"));\n+                    .satisfies(thatCceIsThrownFrom(\"org.mockito.internal.creation.cglib.ClassImposterizer.imposterise\"));\n         }\n     }\n ", "timestamp": 1413586207, "metainfo": ""}