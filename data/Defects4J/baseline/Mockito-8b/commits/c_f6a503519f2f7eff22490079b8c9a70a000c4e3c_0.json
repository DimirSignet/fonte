{"sha": "f6a503519f2f7eff22490079b8c9a70a000c4e3c", "log": "added initial state validating  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40109", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     }\n \n     public static <T> MockitoExpectation<T> stub(T methodCallToStub) {\n-//        MockitoState.instance().stubbingStarted();\n+        MockitoState.instance().stubbingStarted();\n         \n-        //TODO increment number of stubs\n         MockitoExpectation controlToStub = MockitoState.instance().pullControlToBeStubbed();\n         if (controlToStub == null) {\n-            throw new MissingMethodInvocationException();\n+            Exceptions.missingMethodInvocation();\n         }\n         return controlToStub;\n     }\n \t */\n \tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n \t    assertMocksNotEmpty(mocks);\n-\t    MockitoState.instance().checkForUnfinishedVerification();\n+\t    MockitoState.instance().validateState();\n \t    for (Object mock : mocks) {\n             MockUtil.getControl(mock).verifyNoMoreInteractions();\n         }\n \n     public static void verifyZeroInteractions(Object ... mocks) {\n         assertMocksNotEmpty(mocks);\n-        MockitoState.instance().checkForUnfinishedVerification();\n+        MockitoState.instance().validateState();\n         for (Object mock : mocks) {\n             MockUtil.getControl(mock).verifyZeroInteractions();\n         }\n     }\n     \n     public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n-//        MockitoState.instance().reportControlForStubbing(mockControl)\n         return MockUtil.getControl(mock);\n     }\n \n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n         return Mockito.verify(mock, VerifyingMode.inOrder(verifyingMode.wantedCount(), mocksToBeVerifiedInOrder));\n     }\n \n-    public void verifyNoMoreInteractions() {\n-        Mockito.verifyNoMoreInteractions(mocksToBeVerifiedInOrder.toArray());\n-    }\n-\n     public void addMockToBeVerifiedInOrder(Object mock) {\n         mocksToBeVerifiedInOrder.add(mock);\n     }\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions;\n-\n-import org.mockito.internal.Invocation;\n \n /**\n  * All messages in one place makes it easier to tune and amend the text. \n         ));\n     }\n \n-    public static void noMoreInteractionsWanted(Invocation unexpected, String message) {\n+    public static void noMoreInteractionsWanted(String unexpected, String message) {\n         throw new VerificationError(join(\n                 message,\n-                \"Unexpected: \" + unexpected.toString()\n+                \"Unexpected: \" + unexpected\n         ));\n     }\n-}\n+\n+    public static void unfinishedStubbing() {\n+        throw new UnfinishedStubbingException(join(\n+                \"Unifinished stubbing detected, e.g. toReturn() is missing\",\n+                \"Examples of proper stubbing:\",\n+                \"stub(mock.isOk()).toReturn(true);\",\n+                \"stub(mock.isOk()).toThrow(exception);\",\n+                \"stubVoid(mock).toThrow(exception).on().someMethod();\"\n+        ));\n+    }\n+\n+    public static void missingMethodInvocation() {\n+        throw new MissingMethodInvocationException(join(\n+                \"stub() requires an argument which has to be a proper method call on a mock object\"\n+        ));\n+    }\n+}\n--- a/src/org/mockito/exceptions/MissingMethodInvocationException.java\n+++ b/src/org/mockito/exceptions/MissingMethodInvocationException.java\n \n     private static final long serialVersionUID = 1L;\n \n-    public MissingMethodInvocationException() {\n-        super(\"stub() requires an argument which has to be a proper method call on a mock object\");\n+    public MissingMethodInvocationException(String message) {\n+        super(message);\n     }\n }\n--- a/src/org/mockito/exceptions/UnfinishedStubbingException.java\n+++ b/src/org/mockito/exceptions/UnfinishedStubbingException.java\n     private static final long serialVersionUID = 1L;\n \n     public UnfinishedStubbingException(String message) {\n-        super(\"bollox\");\n+        super(message);\n     }\n }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n+        mockitoState.validateState();\n         \n         Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n-        List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n-        validateMatchers(invocation, lastMatchers);\n-\n-        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n-        \n-        ExpectedInvocation invocationWithMatchers = new ExpectedInvocation(invocation, processedMatchers);\n+        ExpectedInvocation invocationWithMatchers = expectedInvocation(invocation);\n         \n         if (verifyingMode != null) {\n             behavior.verify(invocationWithMatchers, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n-        }\n+        } \n         \n-//        else if (mockitoState.mockStubbingScenario()) {\n-//            mockitoState.stubbingCompleted();\n-//        }\n-        \n-        mockitoState.reportLastControl(this);\n-        \n+        mockitoState.reportControlForStubbing(this);\n+\n         behavior.addInvocation(invocationWithMatchers);\n         \n         if (throwableToBeSetOnVoidMethod != null) {\n             throwableToBeSetOnVoidMethod = null;\n             return null;\n         }\n+        \n+        return behavior.resultFor(invocation);\n+    }\n \n-        return behavior.resultFor(invocation);\n+    private ExpectedInvocation expectedInvocation(Invocation invocation) {\n+        List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n+        validateMatchers(invocation, lastMatchers);\n+\n+        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n+        \n+        ExpectedInvocation invocationWithMatchers = new ExpectedInvocation(invocation, processedMatchers);\n+        return invocationWithMatchers;\n     }\n \n     public void verifyNoMoreInteractions() {\n     }\n \n     public void andReturn(T value) {\n-//      TODO count number of andReturn vs number of stubbing\n+        mockitoState.stubbingCompleted();\n         behavior.addResult(Result.createReturnResult(value));\n     }\n \n     public void andThrows(Throwable throwable) {\n+        mockitoState.stubbingCompleted();\n         validateThrowable(throwable);\n-        //TODO count number of andReturn vs number of stubbing\n         behavior.addResult(Result.createThrowResult(throwable));\n     }\n     \n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     private void verifyNoMoreInteractions(String message) {\n         Invocation unverified = registeredInvocations.getFirstUnverified();\n         if (unverified != null) {\n-            Exceptions.noMoreInteractionsWanted(unverified, message);\n+            Exceptions.noMoreInteractionsWanted(unverified.toString(), message);\n         }\n     }\n \n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n  */\n package org.mockito.internal;\n \n-import org.mockito.exceptions.UnfinishedVerificationException;\n+import org.mockito.exceptions.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoState {\n     \n-    //TODO this has to be threaddy singleton\n+    //TODO this has to be thready singleton\n     static MockitoState INSTANCE = new MockitoState();\n     \n     private final ThreadLocal<MockControl> lastControl = new ThreadLocal<MockControl>();\n     private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n     private final ThreadLocal<Integer> invocationSequenceNumber = new ThreadLocal<Integer>();\n-//    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLoca<Object>();\n+    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n+//    private final ThreadLocal<Object> stubbingVoidModeLocal = new ThreadLocal<Object>();\n+\n \n     MockitoState() {}\n     \n         return INSTANCE;\n     }\n     \n-    public synchronized void reportLastControl(MockControl mockControl) {\n+    public synchronized void reportControlForStubbing(MockControl mockControl) {\n         lastControl.set(mockControl);\n     }\n \n     }\n     \n     public synchronized void verifyingStarted(VerifyingMode verify) {\n-        checkForUnfinishedVerification();\n+        validateState();\n         verifyingModeLocal.set(verify);\n     }\n \n         }\n     }\n \n-//    public void stubbingStarted() {\n-//        stubbingModeLocal.set(new Object());\n-//    }\n+    public synchronized void stubbingStarted() {\n+        validateState();\n+        stubbingModeLocal.set(new Object());\n+    }\n \n-//    public boolean mockStubbingScenario() {\n-//        return stubbingModeLocal.get() != null;\n-//    }\n+    public synchronized void validateState() {\n+        checkForUnfinishedVerification();\n+        if (stubbingModeLocal.get() != null) {\n+            Exceptions.unfinishedStubbing();\n+        }\n+    }\n \n-//    public void stubbingCompleted() {\n-//        stubbingModeLocal.set(null);\n+    public synchronized void stubbingCompleted() {\n+        stubbingModeLocal.set(null);\n+    }\n+    \n+    public String toString() {\n+        return  \"lastControl: \" + lastControl.get() + \n+                \", verifyingMode: \" + verifyingModeLocal.get() +\n+                \", invocationSequenceNumber: \" + invocationSequenceNumber.get() +\n+                \", stubbingModeLocal: \" + stubbingModeLocal.get();\n+    }\n+//\n+//    public void stubbingVoidStarted() {\n+//        validateState();\n+//        stubbingVoidModeLocal.set(new Object());\n //    }\n }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n  */\n package org.mockito;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertNull;\n \n import java.util.List;\n \n import org.junit.*;\n-import org.mockito.exceptions.*;\n+import org.mockito.exceptions.NotAMockException;\n import org.mockito.internal.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoTest {\n \n     private String notMock;\n-    private List mock;\n \n     @Before\n     public void setup() {\n-        mock = mock(List.class);\n+        StateResetter.reset();\n         notMock = \"i'm not a notMock\";\n-        StateResetter.reset();\n     }\n     \n     @After\n     public void shouldValidateMockWhenGettingStrictVerifier() {\n         Mockito.createStrictOrderVerifier(notMock);\n     }\n-    \n-    @Test\n-    public void shouldDetectUnfinishedVerification() {\n-        verify(mock);\n-        try {\n-            verify(mock).get(0);\n-            fail();\n-        } catch (MockitoException e) {}\n-    }\n-    \n-    @Test\n-    public void shouldDetectUnfinishedVerificationWhenVeryfingNoMoreInteractions() {\n-        verify(mock);\n-        try {\n-            verifyNoMoreInteractions(mock);\n-            fail();\n-        } catch (MockitoException e) {}\n-    }\n-    \n-    @Test\n-    public void shouldDetectUnfinishedVerificationWhenVeryfingZeroInteractions() {\n-        verify(mock);\n-        try {\n-            verifyZeroInteractions(mock);\n-            fail();\n-        } catch (MockitoException e) {}\n-    }\n }\n--- a/test/org/mockito/usage/IMethods.java\n+++ b/test/org/mockito/usage/IMethods.java\n package org.mockito.usage;\n \n import java.io.IOException;\n+import java.util.List;\n \n public interface IMethods {\n \n \n     public String throwsError(int count) throws Error;\n \n-    void simpleMethod();\n+    boolean simpleMethod();\n     \n     void differentMethod();\n \n     void varargsString(int i, String... string);\n \n     void varargsObject(int i, Object... object);\n+\n+    List<String> listReturningMethod(Object ... objects);\n }\n--- a/test/org/mockito/usage/InvalidUsageTest.java\n+++ b/test/org/mockito/usage/InvalidUsageTest.java\n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n \n-import java.util.*;\n-\n import org.junit.*;\n import org.mockito.Strictly;\n import org.mockito.exceptions.*;\n /**\n  * invalid state happens if:\n  *    -unfinished stubbing\n- *    -unfinished stubVoid\n+ *    -unfinished stubVoid ?\n  *    -stubbing without actual method call\n  *    -verify without actual method call\n- *\n- * we should aim to detect invalid state in following scenarios:\n- *    -on method call on mock\n- *    -on verify\n- *    -on verifyZeroInteractions\n- *    -on verifyNoMoreInteractions\n- *    -on stub\n- *    -on stubVoid\n  *\n  * obviously we should consider if it is really important to cover all those naughty usage\n  */\n @SuppressWarnings(\"unchecked\")\n public class InvalidUsageTest {\n \n-    private LinkedList mock;\n-    private LinkedList mockTwo;\n+    private IMethods mock;\n+    private IMethods mockTwo;\n \n     @Before\n     @After\n     public void resetState() {\n         StateResetter.reset();\n-        mock = mock(LinkedList.class);\n-        mockTwo = mock(LinkedList.class);\n+        mock = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n     }\n     \n     @Test(expected=MockitoException.class)\n     @Test(expected=MockitoException.class)\n     public void shouldNotVerifyStrictlyUnfamilarMocks() {\n         Strictly strictly = createStrictOrderVerifier(mock);\n-        strictly.verify(mockTwo).clear();\n+        strictly.verify(mockTwo).simpleMethod();\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n-        stub(mock.add(\"monkey island\")).andThrows(new Exception());\n+        stub(mock.simpleMethod()).andThrows(new Exception());\n     }\n     \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullThrowable() throws Exception {\n-        stub(mock.add(\"monkey island\")).andThrows(null);\n+        stub(mock.simpleMethod()).andThrows(null);\n     }    \n \n     @Test(expected=MissingMethodInvocationException.class)\n         stub(\"blah\".contains(\"blah\"));\n     }\n \n+    @Test\n+    public void shouldDetectUnfinishedStubbing() {\n+        stub(mock.simpleMethod());\n+        assertInvalidStateDetected(mock, UnfinishedStubbingException.class);\n+    }\n+    \n     @Ignore\n     @Test\n-    public void unfinishedStubbingDetectedOnVerify() {\n-        stub(mock.add(\"test\"));\n-\n-        try {\n-            verifyZeroInteractions(mock);\n-            fail();\n-        } catch (UnfinishedStubbingException e) {}\n+    public void shouldDetectUnfinishedStubbingVoid() {\n+        stubVoid(mock);\n+        assertInvalidStateDetected(mock, UnfinishedStubbingException.class);\n     }\n-\n-    @Ignore\n-    @Test\n-    public void unfinishedStubbingDetectedWhenAnotherStubbingIsStarted() {\n-        stub(mock.add(\"test\"));\n-\n-        try {\n-            stub(mock.add(\"test\")).andThrows(new Exception(\"ssdf\"));\n-            fail();\n-        } catch (UnfinishedStubbingException e) {}\n-    }\n-\n-    @Ignore\n-    @Test\n-    public void unfinishedStubbingDetectedWhenMockCalled() {\n-        stub(mock.add(\"test\"));\n-\n-        try {\n-            mock.clear();\n-            fail();\n-        } catch (UnfinishedStubbingException e) {}\n-    }\n-\n+    \n     @Ignore\n     @Test\n     public void unfinishedStubbingVoid() {\n         stubVoid(mock);\n \n         try {\n-            mock.clear();\n+            mock.simpleMethod();\n             fail();\n         } catch (UnfinishedStubbingException e) {}\n     }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerification() {\n+        verify(mock);\n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerificationWhenVeryfingNoMoreInteractions() {\n+        verify(mock);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerificationWhenVeryfingZeroInteractions() {\n+        verify(mock);\n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    private static interface DetectsInvalidState {\n+        void detect(IMethods mock);\n+    }\n+    \n+    private static class OnVerify implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verify(mock);\n+        }\n+    }\n+    \n+    private static class OnStrictVerify implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            createStrictOrderVerifier(mock).verify(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyZeroInteractions implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verifyZeroInteractions(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyNoMoreInteractions implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verifyNoMoreInteractions(mock);\n+        }\n+    }    \n+    \n+    private static class OnStub implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            stub(mock.simpleMethod());\n+        }\n+    }\n+    \n+//    private static class OnStubVoid implements DetectsInvalidState {\n+//        public void detect(IMethods mock) {\n+//            stubVoid(mock);\n+//        }\n+//    }\n+    \n+    private static class OnMethodCallOnMock implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            mock.simpleMethod();\n+        }\n+    }\n+    \n+    private void assertInvalidStateDetected(IMethods mock, Class expected) {\n+        detects(new OnMethodCallOnMock(), mock, expected);\n+        detects(new OnStub(), mock, expected);\n+//        detects(new OnStubVoid(), mock, expected);\n+        detects(new OnVerify(), mock, expected);\n+        detects(new OnStrictVerify(), mock, expected);\n+        detects(new OnVerifyZeroInteractions(), mock, expected);\n+        detects(new OnVerifyNoMoreInteractions(), mock, expected);\n+    }\n+    \n+    private void detects(DetectsInvalidState detector, IMethods mock, Class expected) {\n+        try {\n+            detector.detect(mock);\n+            fail(\"Should throw an exception\");\n+        } catch (Exception e) {\n+            assertEquals(expected, e.getClass());\n+        }\n+    }\n }\n--- a/test/org/mockito/usage/matchers/BasicStubbingTest.java\n+++ b/test/org/mockito/usage/matchers/BasicStubbingTest.java\n  */\n package org.mockito.usage.matchers;\n \n-import static org.hamcrest.CoreMatchers.equalTo;\n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n import static org.mockito.util.ExtraMatchers.collectionContaining;\n \n-import java.util.*;\n+import java.util.Arrays;\n \n import org.junit.*;\n import org.mockito.Mockito;\n import org.mockito.exceptions.VerificationError;\n+import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicStubbingTest {\n \n-    private DummyInterface mock;\n+    private IMethods mock;\n \n     @Before\n     public void setup() {\n-        mock = Mockito.mock(DummyInterface.class);\n-    }\n-    \n-    private interface DummyInterface {\n-        int getInt(String value);\n-        String getString(int argumentOne, String argumentTwo);\n-        List<String> getList();\n+        mock = Mockito.mock(IMethods.class);\n     }\n     \n     @Test\n     public void shouldStubAllMethodsByDefault() throws Exception {\n-        assertEquals(0, mock.getInt(\"test\"));\n-        assertEquals(0, mock.getInt(\"testTwo\"));\n+        assertEquals(0, mock.intReturningMethod(1));\n+        assertEquals(0, mock.intReturningMethod(2));\n         \n-        assertNull(mock.getString(0, null));\n-        assertNull(mock.getString(100, null));\n+        assertNull(mock.objectReturningMethod(1));\n+        assertNull(mock.objectReturningMethod(2));\n         \n-        assertEquals(0, mock.getList().size());\n-        assertEquals(0, mock.getList().size());\n+        assertEquals(0, mock.listReturningMethod().size());\n+        assertEquals(0, mock.listReturningMethod().size());\n     }\n     \n     @Test\n     public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n-        stub(mock.getInt(\"14\")).andReturn(14);\n+        stub(mock.intReturningMethod(14)).andReturn(14);\n         \n-        assertThat(mock.getInt(\"14\"), equalTo(14));\n-        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        assertEquals(14, mock.intReturningMethod(14));\n+        assertEquals(14, mock.intReturningMethod(14));\n         \n-        stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n+        stub(mock.listReturningMethod(\"x\")).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n         \n-        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n-        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.listReturningMethod(\"x\"), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.listReturningMethod(\"x\"), collectionContaining(\"elementOne\", \"elementTwo\"));\n         \n-        stub(mock.getString(10, \"test\")).andReturn(\"test\");\n+        stub(mock.objectReturningMethod(100)).andReturn(\"hundred\");\n         \n-        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n-        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+        assertEquals(\"hundred\", mock.objectReturningMethod(100));\n+        assertEquals(\"hundred\", mock.objectReturningMethod(100));\n     }\n     \n     @Test\n     public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n-        mock = Mockito.mock(DummyInterface.class);\n+        stub(mock.booleanReturningMethod(1)).andReturn(true);\n         \n-        stub(mock.getInt(\"blah\"));\n+        mock.booleanReturningMethod(1);\n         \n         try {\n             verifyNoMoreInteractions(mock);\n--- a/test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java\n \n     private LinkedList mock;\n \n-    @Before public void setup() {\n+    @Before \n+    public void setup() {\n         mock = mock(LinkedList.class);\n     }\n     \n         IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n         \n         stubVoid(mock).toThrow(expected).on().clear();\n-        \n         try {\n             mock.clear();\n             fail();", "timestamp": 1196469205, "metainfo": ""}