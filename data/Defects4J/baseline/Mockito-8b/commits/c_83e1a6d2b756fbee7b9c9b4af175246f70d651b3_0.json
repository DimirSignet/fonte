{"sha": "83e1a6d2b756fbee7b9c9b4af175246f70d651b3", "log": "big checkin (worked in a train again) added specific exception when never() or times(0) is used fixed some documentation around never() some refactorings left  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40395", "commit": "\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n  * ArgumentMatcher is an hamcrest {@link Matcher} with predefined describeTo() method for convenience.\n  * <p>\n  * See {@link Matchers}\n- * \n+ * <p>\n  * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}, e.g:\n  * \n  * <pre>\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n  * </pre>\n  * \n- * <h2>Custom Matchers</h2>\n+ * <h1>Custom Matchers</h1>\n  * \n  * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n  * <p>\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n  * </pre>\n  * \n- * <h3>Verifying exact number of invocations / at least once</h3>\n+ * <h3>Verifying exact number of invocations / at least once / never</h3>\n  *\n  *<pre>\n  *  //using mock \n  *  verify(mockedList, times(2)).add(\"twice\");\n  *  verify(mockedList, times(3)).add(\"three times\");\n  *  \n+ *  //verification using never(). never() is an alias to times(0)\n+ *  verify(mockedList, never()).add(\"three times\");\n+ *  \n  *  //verification using atLeastOnce()\n  *  verify(mockedList, atLeastOnce()).add(\"three times\");\n+ *  \n  * </pre>\n  * \n  * <p>\n  * <p>\n  * Also, you can create InOrder object passing only mocks that relevant for in-order verification.  \n  *\n- * <h3>Making sure no interactions happened on mock</h3>\n+ * <h3>Making sure interaction(s) never happened on mock</h3>\n  * \n  * <pre>\n  *   //using mocks - only mockOne is interacted\n  *   //ordinary verification\n  *   verify(mockOne).add(\"one\");\n  *   \n- *   //other mocks should not be interacted\n+ *   //verify that method was never called on a mock\n+ *   verify(mockOne, never()).add(\"two\"); \n+ *   \n+ *   //verify that other mocks were not interacted\n  *   verifyZeroInteractions(mockTwo, mockThree);\n  *   \n  *   //following works exactly the same as above\n     }\n     \n     /**\n-     * TODO better error reporting - important case\n-     *  \n      * Alias to times(0)\n      * <p>\n      * See {@link Mockito#times(int)}\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n         ), cause);\n     }\n     \n+    public void neverWantedButInvoked(Printable wanted, HasStackTrace firstUndesired) {\n+        UndesiredInvocation cause = createUndesiredInvocationCause(firstUndesired);\n+\n+        throw new NeverWantedButInvoked(join(\n+                wanted.toString(),\n+                \"Never wanted but invoked!\"\n+        ), cause);\n+    }    \n+    \n     public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, Printable wanted, HasStackTrace firstUndesired) {\n         UndesiredInvocation cause = createUndesiredInvocationCause(firstUndesired);\n \n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/NeverWantedButInvoked.java\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class NeverWantedButInvoked extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public NeverWantedButInvoked(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n         return !atLeastOnceMode() && wantedInvocationCount < actualCount;\n     }\n     \n-    public boolean wantedCountIsZero() {\n+    public boolean neverWanted() {\n         return !atLeastOnceMode() && wantedInvocationCount == 0;\n+    }\n+    \n+    public boolean neverWantedButInvoked(int actualCount) {\n+        return neverWanted() && actualCount > 0;\n     }\n     \n     @Override\n     public String toString() {\n         return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedInOrder;\n     }\n+\n }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode);\n         \n         boolean noMatchFound = chunk.size() == 0;\n-        if (mode.wantedCountIsZero() && noMatchFound) {\n+        if (mode.neverWanted() && noMatchFound) {\n             return;\n         }\n         \n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         if (mode.tooLittleActualInvocations(actualCount)) {\n             HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n             reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted, lastInvocation);\n+        } else if (mode.neverWantedButInvoked(actualCount)) {\n+            HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n+            reporter.neverWantedButInvoked(wanted, firstUndesired); \n         } else if (mode.tooManyActualInvocations(actualCount)) {\n             HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n             reporter.tooManyActualInvocations(mode.wantedCount(), actualCount, wanted, firstUndesired);\n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n     \n     @Test\n     public void shouldKnowIfWantedCountIsZero() throws Exception {\n-        assertTrue(times(0).wantedCountIsZero());\n+        assertTrue(times(0).neverWanted());\n         \n-        assertFalse(times(1).wantedCountIsZero());\n-        assertFalse(times(20).wantedCountIsZero());\n-        assertFalse(atLeastOnce().wantedCountIsZero());\n+        assertFalse(times(1).neverWanted());\n+        assertFalse(times(20).neverWanted());\n+        assertFalse(atLeastOnce().neverWanted());\n     }\n     \n     @Test\n         assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n         assertFalse(inOrder(1, asList(new Object())).exactNumberOfInvocationsMode());\n     }\n+    \n+    @Test\n+    public void shouldKnowIfNeverWantedButInvoked() throws Exception {\n+        assertFalse(times(1).neverWantedButInvoked(0));\n+        assertFalse(times(10).neverWantedButInvoked(20));\n+        assertFalse(times(0).neverWantedButInvoked(0));\n+        \n+        assertFalse(atLeastOnce().neverWantedButInvoked(0));\n+        assertFalse(atLeastOnce().neverWantedButInvoked(1));\n+        \n+        assertTrue(times(0).neverWantedButInvoked(1));\n+        assertTrue(times(0).neverWantedButInvoked(10));\n+    }\n }\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n     \n     @Test\n     public void shouldReportTooManyActual() throws Exception {\n-        VerificationModeImpl mode = times(0);\n+        VerificationModeImpl mode = times(1);\n+        finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         \n         verifier.verify(invocations, wanted, mode);\n         \n-        assertEquals(1, reporterStub.actualCount);\n-        assertEquals(0, reporterStub.wantedCount);\n+        assertEquals(2, reporterStub.actualCount);\n+        assertEquals(1, reporterStub.wantedCount);\n         assertEquals(wanted, reporterStub.wanted);\n     }\n     \n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n import org.mockito.Mockito;\n import org.mockito.TestBase;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n \n public class PointingStackTraceToActualInvocationTest extends TestBase {\n     \n         try {\n             verify(mock, times(0)).simpleMethod(1);\n             fail();\n-        } catch (TooManyActualInvocations e) {\n+        } catch (NeverWantedButInvoked e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"first\"));\n         }\n     }   \n--- a/test/org/mockitousage/matchers/CustomMatchersTest.java\n+++ b/test/org/mockitousage/matchers/CustomMatchersTest.java\n         assertEquals(null, mock.oneArg(\"x\"));\n     }\n     \n-  @Test\n-  public void shouldUseCustomCharMatcher() {\n-      stub(mock.oneArg(charThat(new IsSorZ()))).toReturn(\"foo\");\n+    @Test\n+    public void shouldUseCustomCharMatcher() {\n+        stub(mock.oneArg(charThat(new IsSorZ()))).toReturn(\"foo\");\n       \n-      assertEquals(\"foo\", mock.oneArg('s'));\n-      assertEquals(\"foo\", mock.oneArg('z'));\n-      assertEquals(null, mock.oneArg('x'));\n-  }\n+        assertEquals(\"foo\", mock.oneArg('s'));\n+        assertEquals(\"foo\", mock.oneArg('z'));\n+        assertEquals(null, mock.oneArg('x'));\n+    }\n+    \n+    class Article {\n+        \n+        private int pageNumber;\n+        private String headline;\n+        \n+        public Article(int pageNumber, String headline) {\n+            super();\n+            this.pageNumber = pageNumber;\n+            this.headline = headline;\n+        }\n+\n+        public int getPageNumber() {\n+            return pageNumber;\n+        }\n+\n+        public String getHeadline() {\n+            return headline;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldUseCustomCharMatcher1() {\n+        mock.simpleMethod(new Article(12, \"Fabulous article\"));\n+        \n+        Article articleOnPage12 = argThat(new ArgumentMatcher<Article>() {\n+            public boolean matches(Object argument) {\n+                Article o = (Article) argument;\n+                assertEquals(12, o.getPageNumber());\n+                return true;\n+            }} );\n+        \n+        verify(mock).simpleMethod(articleOnPage12);\n+        \n+        //Assertors?\n+        \n+//        verify(mock).simpleMethod(argThat(new ArgumentAssertor<Article>() {\n+//            public void assertArgument(Object argument) {\n+//                Article o = (Article) argument;\n+//                assertEquals(\"two\", o.getHeadline());\n+//            }} ));\n+    }\n     \n     @Test\n     public void shouldUseCustomPrimitiveNumberMatchers() {\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n import org.mockito.TestBase;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n             assertThat(e, causeMessageContains(\"IMethods.varargs(class [Ljava.lang.Object;)\"));\n         }\n     }\n+    \n+    @Test\n+    public void shouldSayNeverWantedButInvoked() throws Exception {\n+        mock.simpleMethod(1);\n+    \n+        verify(mock, never()).simpleMethod(2);\n+        try {\n+            verify(mock, never()).simpleMethod(1);\n+            fail();\n+        } catch (NeverWantedButInvoked e) {\n+            assertThat(e, messageContains(\"Never wanted but invoked!\"));\n+            assertThat(e, causeMessageContains(\"Undesired invocation\"));\n+        }\n+    }\n }\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n         try {\n             verify(mock, times(0)).clear();\n             fail();\n-        } catch (TooManyActualInvocations e) {\n-            assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n+        } catch (NeverWantedButInvoked e) {\n+            assertThat(e, messageContains(\"Never wanted but invoked!\"));\n         }\n     }\n \n         try {\n             verify(mock, never()).add(\"one\");\n             fail();\n-        } catch (TooManyActualInvocations e) {\n-            e.printStackTrace();\n-            assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n-        }\n+        } catch (NeverWantedButInvoked e) {}\n     }\n }\n--- a/test/org/mockitousage/verification/RelaxedVerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/RelaxedVerificationInOrderTest.java\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n         try {\n             verify(mockOne, times(0)).simpleMethod(1);\n             fail();\n-        } catch (TooManyActualInvocations e) {}\n+        } catch (NeverWantedButInvoked e) {}\n     }\n     \n     @Test", "timestamp": 1203945836, "metainfo": ""}