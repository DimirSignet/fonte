{"sha": "c10602b71e7bc4231419c36110f861d5d115184f", "log": "Final touches to the javadoc  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401488", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n  *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\n  *  <p>\n- *  <b>Before release 1.8</b> spy() was working slightly differently, e.g. it didn't produce real partial mocks and it was confusing for some users.\n+ *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.\n  *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n  *  <p>\n  *  <pre>\n  *    \n  *    //you can enable partial mock capabilities selectively on mocks:\n  *    Foo mock = mock(Foo.class);\n+ *    //Be sure the real implementation is 'safe'.\n+ *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n  *    when(mock.someMethod()).thenCallRealMethod();\n- *    //However, be sure the real implementation is 'safe'.\n- *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n  *  </pre>\n  *  \n  * As usual you are going to read <b>the partial mock warning</b>:\n  *  \n  * <h3 id=\"17\">17. (**New**) Resetting mocks</h3>\n  *  \n- * Smart Mockito users hardly use this method because they know it could be a sign of poor tests.\n+ * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n  * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n  * <p>\n  * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n     }\n     \n     /**\n-     * Smart Mockito users hardly use this method because they know it could be a sign of poor tests.\n+     * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n      * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n      * <p>\n      * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n-     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks\n+     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n+     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n+     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n      * <p>\n      * Example:\n      * <pre>\n--- a/src/org/mockito/internal/progress/NewOngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/NewOngoingStubbing.java\n      * However, there are rare cases when partial mocks come handy: \n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+     * <pre>\n+     *   // someMethod() must be safe (e.g. doesn't throw, doesn't have dependencies to the object state, etc.)\n+     *   // if it isn't safe then you will have trouble stubbing it using this api. Use Mockito.doCallRealMethod() instead. \n+     *   when(mock.someMethod()).thenCallRealMethod();\n+     *   \n+     *   // calls real method:\n+     *   mock.someMethod();\n+     *   \n+     * </pre>\n+     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n+     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n+     * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n      * <p>\n-     * <pre>\n-     * when(mock.someMethod()).thenCallRealMethod();\n-     * </pre>\n-     *\n      * See examples in javadoc for {@link Mockito#when}\n      *\n      * @return ongoingStubbing object that allows stubbing consecutive calls", "timestamp": 1244558699, "metainfo": ""}