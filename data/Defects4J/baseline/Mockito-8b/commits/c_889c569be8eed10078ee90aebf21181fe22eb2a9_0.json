{"sha": "889c569be8eed10078ee90aebf21181fe22eb2a9", "log": "Added non-greedy verification mode  --HG-- branch : issue296", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     }\n \n     /**\n+     * Allows non-greedy verification in order.  For example\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   inOrder.verify( mock, timesNow( 2 )).someMethod( \"some arg\" );\n+     * </code></pre>\n+     * <ul>\n+     * <li>will not fail if the method is called 3 times, unlike times( 2 )</li>\n+     * <li>will not mark the third invocation as verified, unlike atLeast( 2 )</li>\n+     * </ul>\n+     * This verification mode can only be used with in order verification.\n+     * @param wantedNumberOfInvocations number of invocations to verify\n+     * @return  verification mode\n+     */\n+    public static VerificationMode timesNow( int wantedNumberOfInvocations ){\n+        return VerificationModeFactory.timesNow( wantedNumberOfInvocations );\n+    }\n+    \n+    /**\n      * Allows checking if given method was the only one invoked. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, only()).someMethod();\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n             }\n         }\n         return firstChunk;\n+    }\n+    \n+    public Invocation findFirstMatchingUnverifiedInvocation( List<Invocation> invocations, InvocationMatcher wanted, InOrderContext context ){\n+        for( Invocation invocation : removeVerifiedInOrder( invocations, context )){\n+            if( wanted.matches( invocation )){\n+                return invocation;\n+            }\n+        }\n+        return null;\n     }\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/TimesNow.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationDataInOrder;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.checkers.*;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+public class TimesNow implements VerificationMode, VerificationInOrderMode {\n+\n+    final int wantedCount;\n+\n+    public TimesNow( int wantedNumberOfInvocations ) {\n+        if( wantedNumberOfInvocations <= 0 ) {\n+            throw new MockitoException( \"Negative and zero values are not allowed here\" );\n+        }\n+        this.wantedCount = wantedNumberOfInvocations;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        throw new MockitoException( \"timesNow is only intended to work with InOrder\" );\n+    }\n+\n+    public void verifyInOrder(VerificationDataInOrder data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        missingInvocation.check( allInvocations, wanted, this, data.getOrderingContext());\n+        NonGreedyNumberOfInvocationsInOrderChecker numberOfCalls = new NonGreedyNumberOfInvocationsInOrderChecker();\n+        numberOfCalls.check( allInvocations, wanted, wantedCount, data.getOrderingContext());\n+    }    \n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count (non-greedy): \" + wantedCount;\n+    }\n+\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n         return new Times(wantedNumberOfInvocations);\n     }\n \n+    public static TimesNow timesNow( int wantedNumberOfInvocations ) {\n+        return new TimesNow( wantedNumberOfInvocations );\n+    }\n+\n     public static NoMoreInteractions noMoreInteractions() {\n         return new NoMoreInteractions();\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/checkers/NonGreedyNumberOfInvocationsInOrderChecker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification.checkers;\n+\n+import org.mockito.exceptions.Discrepancy;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.Location;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMarker;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.verification.api.InOrderContext;\n+\n+import java.util.List;\n+\n+public class NonGreedyNumberOfInvocationsInOrderChecker {\n+\n+    private final InvocationsFinder finder;\n+    private final Reporter reporter;\n+    private final InvocationMarker marker;\n+\n+    public NonGreedyNumberOfInvocationsInOrderChecker() {\n+        this(new InvocationsFinder(), new Reporter(), new InvocationMarker());\n+    }\n+\n+    NonGreedyNumberOfInvocationsInOrderChecker(InvocationsFinder finder, Reporter reporter, InvocationMarker marker ) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+        this.marker = marker;\n+    }\n+    \n+    public void check(List<Invocation> invocations, InvocationMatcher wanted, int wantedCount, InOrderContext context) {\n+        int actualCount = 0;\n+        Location lastLocation = null;\n+        while( actualCount < wantedCount ){\n+            Invocation next = finder.findFirstMatchingUnverifiedInvocation( invocations, wanted, context );\n+            if( next == null ){\n+                reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastLocation );\n+            }\n+            marker.markVerified( next, wanted );\n+            context.markVerified( next );\n+            lastLocation = next.getLocation();\n+            actualCount++;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderWithTimesNowTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.*;\n+\n+public class VerificationInOrderWithTimesNowTest extends TestBase {\n+\n+    @Mock private IMethods mockOne;\n+    @Mock private IMethods mockTwo;\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    @Test\n+    public void shouldFailWhenMethodNotCalled(){\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCalledTooFewTimes(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(2)\" );\n+        exceptionRule.expectMessage( \"Wanted 2 times\" );\n+        exceptionRule.expectMessage( \"But was 1 time\" );\n+        verifier.verify( mockOne, timesNow( 2 )).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.oneArg(1)\" );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockTwo, timesNow( 1 )).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"Verification in order failure\" );\n+        exceptionRule.expectMessage( \"Wanted but not invoked\" );\n+        exceptionRule.expectMessage( \"mockOne.voidMethod()\" );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+    }\n+    \n+\n+    @Test\n+    public void shouldAllowSequentialCallsToTimesNowForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 2 )).oneArg( 2 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToTimesNowForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 2 )).voidMethod();\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg(1);\n+        verifyNoMoreInteractions(mockOne);\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowSequentialCallsToTimesNowForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockTwo, timesNow( 2 )).voidMethod();\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifyNoMoreInteractions(mockOne);\n+        verifyNoMoreInteractions(mockTwo);\n+        verifier.verifyNoMoreInteractions();\n+    }\n+    \n+    \n+    @Test\n+    public void shouldAllowFewerCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 2 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 2 );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 2 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        \n+        exceptionRule.expect( NoInteractionsWanted.class );\n+        verifyNoMoreInteractions( mockOne );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){\n+        mockOne.oneArg( 1 );\n+        mockOne.oneArg( 2 );\n+        mockOne.oneArg( 2 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 2 );\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+        mockOne.oneArg( 1 );\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+\n+        exceptionRule.expect( NoInteractionsWanted.class );\n+        verifyNoMoreInteractions( mockOne );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){\n+        mockOne.oneArg( 1 );\n+        mockOne.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne );\n+        verifier.verify( mockOne, timesNow( 1 )).oneArg( 1 );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+\n+    @Test\n+    public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockTwo, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockTwo, timesNow( 1 )).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+        mockOne.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockTwo, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+\n+        exceptionRule.expect(NoInteractionsWanted.class);\n+        verifyNoMoreInteractions( mockTwo );\n+    }\n+\n+    @Test\n+    public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){\n+        mockOne.voidMethod();\n+        mockTwo.voidMethod();\n+        mockTwo.voidMethod();\n+\n+        InOrder verifier = inOrder( mockOne, mockTwo );\n+        verifier.verify( mockOne, timesNow( 1 )).voidMethod();\n+        verifier.verify( mockTwo, timesNow( 1 )).voidMethod();\n+\n+        exceptionRule.expect( VerificationInOrderFailure.class );\n+        exceptionRule.expectMessage( \"No interactions wanted here\" );\n+        verifier.verifyNoMoreInteractions();\n+    }\n+    \n+    @Test\n+    public void shouldFailToCreateTimesNowWithZeroArgument(){\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+        verifier.verify( mockOne, timesNow( 0 )).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateTimesNowWithNegativeArgument(){\n+        InOrder verifier = inOrder( mockOne );\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"Negative and zero values are not allowed here\" );\n+        verifier.verify( mockOne, timesNow( -1 )).voidMethod();\n+    }\n+\n+    @Test\n+    public void shouldFailToCreateTimesNowForNonInOrderVerification(){\n+        mockOne.voidMethod();\n+        exceptionRule.expect( MockitoException.class );\n+        exceptionRule.expectMessage( \"timesNow is only intended to work with InOrder\" );\n+        verify( mockOne, timesNow( 1 )).voidMethod();\n+    }\n+}", "timestamp": 1324930914, "metainfo": ""}