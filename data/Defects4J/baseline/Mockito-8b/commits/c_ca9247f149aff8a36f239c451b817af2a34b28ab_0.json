{"sha": "ca9247f149aff8a36f239c451b817af2a34b28ab", "log": "refactorings probably ;)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40244", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n     }\n \n-    //TODO refactor to wanted but not invoked with wanted and actual\n-    public void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+    public void wantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n         WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n                 \"Actual invocation:\",\n                 actual\n             ), cause);\n     }\n     \n-    public void strictVerificationFailed(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+    public void strictlyWantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n         WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n                 \"Actual invocation:\",\n                 actual\n                 \"Wanted invocation:\",\n                 wanted\n             ), cause);\n+    }\n+    \n+    private void wantedDiffersFromActual(String message, String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+        \n     }\n \n     public void wantedButNotInvoked(String wanted) {\n         ), cause);\n     }\n     \n-    public void strictlyTooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualInvocationStackTrace) {\n+    public void strictlyTooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualStackTrace) {\n         TooLittleInvocations cause = null;\n-        if (lastActualInvocationStackTrace != null) {\n+        if (lastActualStackTrace != null) {\n             cause = new TooLittleInvocations(join(\"Too little invocations:\"));\n-            cause.setStackTrace(lastActualInvocationStackTrace.getStackTrace());\n+            cause.setStackTrace(lastActualStackTrace.getStackTrace());\n         }\n \n         throw new StrictVerificationFailure(join(\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.LinkedList;\n import java.util.List;\n \n+import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n         }\n         return null;\n     }\n+\n+    public HasStackTrace getLastStackTrace(List<Invocation> invocations) {\n+        if (invocations.isEmpty()) {\n+            return null;\n+        } else {\n+            Invocation last = invocations.get(invocations.size() - 1);\n+            return last.getStackTrace();\n+        }\n+    }\n     \n     private class RemoveNotMatching implements Filter<Invocation> {\n         private final InvocationMatcher wanted;\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n     private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n         if (similar != null) {\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, similar);\n-            reporter.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), similar.getStackTrace());\n+            reporter.wantedDiffersFromActual(printer.printWanted(), printer.printActual(), similar.getStackTrace());\n         } else {\n             reporter.wantedButNotInvoked(wanted.toString());\n         }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         \n         int actualCount = actualInvocations.size();\n         if (mode.tooLittleActualInvocations(actualCount)) {\n-            HasStackTrace lastInvocation = getLastSafely(actualInvocations);\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n             reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n         } else if (mode.tooManyActualInvocations(actualCount)) {\n             HasStackTrace firstUndesired = actualInvocations.get(mode.wantedCount()).getStackTrace();\n             i.markVerified();\n         }\n     }\n-\n-    private HasStackTrace getLastSafely(List<Invocation> actualInvocations) {\n-        if (actualInvocations.isEmpty()) {\n-            return null;\n-        } else {\n-            return actualInvocations.get(actualInvocations.size() - 1).getStackTrace();\n-        }\n-    }\n }\n--- a/src/org/mockito/internal/verification/StrictlyMissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/StrictlyMissingInvocationVerifier.java\n         \n         if (chunk.size() == 0) {\n             reporter.strictlyWantedButNotInvoked(wanted.toString());\n-        }\n-        \n-        if (!wanted.matches(chunk.get(0))) {\n+        } else if (!wanted.matches(chunk.get(0))) {\n             Invocation actual = chunk.get(0);\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n-            reporter.strictVerificationFailed(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n+            reporter.strictlyWantedDiffersFromActual(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java\n         int actualCount = chunk.size();\n         \n         if (mode.tooLittleActualInvocations(actualCount)) {\n-            HasStackTrace lastInvocation = getLastSafely(chunk);\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n             reporter.strictlyTooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n         }\n         \n             i.markVerifiedStrictly();\n         }\n     }\n-    \n-    private HasStackTrace getLastSafely(List<Invocation> actualInvocations) {\n-        if (actualInvocations.isEmpty()) {\n-            return null;\n-        } else {\n-            Invocation last = actualInvocations.get(actualInvocations.size() - 1);\n-            return last.getStackTrace();\n-        }\n-    }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import static org.mockito.util.ExtraMatchers.*;\n \n import java.util.Arrays;\n+import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.base.HasStackTrace;\n \n \n public class InvocationsFinderTest extends RequiresValidState {\n         Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n         assertNotSame(onDifferentMock, found);\n     }  \n+    \n+    @Test\n+    public void shouldGetLastStackTrace() throws Exception {\n+        HasStackTrace last = finder.getLastStackTrace(invocations);\n+        assertSame(differentMethodInvocation.getStackTrace(), last);\n+        \n+        assertNull(finder.getLastStackTrace(Collections.<Invocation>emptyList()));\n+    } \n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n         @Override public void wantedButNotInvoked(String wanted) {\n             this.wanted = wanted;\n         }\n-        @Override public void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+        @Override public void wantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n                     this.wanted = wanted;\n                     this.actual = actual;\n                     this.actualInvocationStackTrace = actualInvocationStackTrace;\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/StrictlyMissingInvocationVerifierTest.java\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+\n+public class StrictlyMissingInvocationVerifierTest extends RequiresValidState {\n+\n+    private StrictlyMissingInvocationVerifier verifier;\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new StrictlyMissingInvocationVerifier(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }                                                                    \n+\n+    @Test\n+    public void shouldNeverVerifyIfModeIsNotMissingModeStrictly() throws Exception {\n+        verifier.verify(null, null, atLeastOnce());\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() throws Exception {\n+        assertTrue(finderStub.firstUnverifiedChunkToReturn.isEmpty());\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().strict());\n+        \n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedDiffersFromActual() throws Exception {\n+        Invocation different = new InvocationBuilder().differentMethod().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.add(different);\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().strict());\n+        \n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+        assertEquals(different.toString(), reporterStub.actual);\n+        assertSame(different.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private String wanted;\n+        private String actual;\n+        private HasStackTrace actualInvocationStackTrace;\n+\n+        @Override public void strictlyWantedButNotInvoked(String wanted) {\n+            this.wanted = wanted;\n+        }\n+        \n+        @Override public void strictlyWantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+            this.wanted = wanted;\n+            this.actual = actual;\n+            this.actualInvocationStackTrace = actualInvocationStackTrace;\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifierTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).strict());\n     }\n     \n+    @Test\n+    public void shouldReportTooLittleInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.addAll(asList(first, second)); \n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).strict());\n+        \n+        assertEquals(4, reporterStub.wantedCount);\n+        assertEquals(2, reporterStub.actualCount);\n+        assertSame(second.getStackTrace(), reporterStub.lastActualStackTrace);\n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.addAll(asList(first, second)); \n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).strict());\n+        \n+        assertEquals(1, reporterStub.wantedCount);\n+        assertEquals(2, reporterStub.actualCount);\n+        assertSame(second.getStackTrace(), reporterStub.firstUndesired);\n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldMarkInvocationsAsVerified() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.add(invocation);\n+        assertFalse(invocation.isVerifiedStrictly());\n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).strict());\n+        \n+        assertTrue(invocation.isVerifiedStrictly());\n+    }\n+\n     class ReporterStub extends Reporter {\n+        private HasStackTrace lastActualStackTrace;\n+        private int actualCount;\n+        private int wantedCount;\n+        private HasStackTrace firstUndesired;\n+        private String wanted;\n+\n+        @Override public void strictlyTooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualStackTrace) {\n+            this.wantedCount = wantedCount;\n+            this.actualCount = actualCount;\n+            this.wanted = wanted;\n+            this.lastActualStackTrace = lastActualStackTrace;\n+        }\n+        \n+        @Override public void strictlyTooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n+            this.wantedCount = wantedCount;\n+            this.actualCount = actualCount;\n+            this.wanted = wanted;\n+            this.firstUndesired = firstUndesired;\n+        }\n     }\n }\n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n         verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 0);\n         verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 0);\n         verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 0);\n+//        verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 2);\n         \n         verifyNoMoreInteractions(mockDatabase);\n     }\n         \n         strictly.verify(mockDatabase, atLeastOnce()).getArticlesFor(anyString());\n         strictly.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());\n-//      strictly.verify(mockDatabase, atLeastOnce()).save(null);\n+//        strictly.verify(mockDatabase, atLeastOnce()).save(null);\n     }\n }", "timestamp": 1198950744, "metainfo": ""}