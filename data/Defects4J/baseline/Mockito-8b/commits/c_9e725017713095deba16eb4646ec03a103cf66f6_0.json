{"sha": "9e725017713095deba16eb4646ec03a103cf66f6", "log": "Added documentation and new convenience API in top level Mockito class.  Issue #92", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n \n     /**\n      * Mockito attempts to use constructor when creating instance of the mock.\n+     * This is particularly useful for spying on abstract classes. See also {@link Mockito#spy(Class)}.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * //Robust API, via settings builder:\n+     * OtherAbstract spy = mock(OtherAbstract.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+     *\n+     * //Mocking a non-static inner abstract class:\n+     * InnerAbstract spy = mock(InnerAbstract.class, withSettings().useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+     * </code></pre>\n      *\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings useConstructor();\n \n     /**\n-     * Useful for mocking non-static inner classes in conjunction with {@link #useConstructor()}\n+     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor()}.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+     * </code></pre>\n      *\n      * @return settings instance so that you can fluently specify other settings\n      */\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *      <a href=\"#27\">27. Delegate calls to real instance (Since 1.9.5)</a><br/>\n  *      <a href=\"#28\">28. <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n  *      <a href=\"#29\">29. (new) BDD style verification (Since 1.10.0)</a><br/>\n+ *      <a href=\"#30\">30. (new) Spying or mocking abstract classes (Since 1.10.12)</a><br/>\n  * </b>\n  *\n  * <p>\n  * Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD <b>then</b> keyword.\n  *\n  * For more information and an example see {@link BDDMockito}.\n+ *\n+ *\n+ *\n+ * <h3 id=\"30\">30. <a class=\"meaningful_link\" href=\"#spying_abstract_classes\">(new) Spying or mocking abstract classes (Since 1.10.12)</h3>\n+ *\n+ * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}.\n+ * <p>\n+ * Previously, spying was only possible on instances of objects.\n+ * New API makes it possible to use constructor when creating an instance of the mock.\n+ * This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class.\n+ * At the moment, only parameter-less constructor is supported, let us know if it is not enough.\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   //convenience API, new overloaded spy() method:\n+ *   SomeAbstract spy = spy(SomeAbstract.class);\n+ *\n+ *   //Robust API, via settings builder:\n+ *   OtherAbstract spy = mock(OtherAbstract.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+ *\n+ *   //Mocking a non-static inner abstract class:\n+ *   InnerAbstract spy = mock(InnerAbstract.class, withSettings().useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+ * </code></pre>\n+ *\n+ * For more information please see {@link MockSettings#useConstructor()}.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     }\n \n     /**\n+     * Please refer to the documentation of {@link #spy(Object)}.\n+     * Overusing spies hints at code design smells.\n+     * <p>\n+     * This method, in contrast to the original {@link #spy(Object)}, creates a spy based on class instead of an object.\n+     * Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.\n+     * This is particularly useful for spying on abstract classes because they cannot be instantiated.\n+     * See also {@link MockSettings#useConstructor()}.\n+     * <p>\n+     * Examples:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   SomeAbstract spy = spy(SomeAbstract.class);\n+     *\n+     *   //Robust API, via settings builder:\n+     *   OtherAbstract spy = mock(OtherAbstract.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n+     *\n+     *   //Mocking a non-static inner abstract class:\n+     *   InnerAbstract spy = mock(InnerAbstract.class, withSettings().useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n+     * </code></pre>\n+     *\n+     * @param classToSpy the class to spy\n+     * @param <T> type of the spy\n+     * @return a spy of the provided class\n+     */\n+    public static <T> T spy(Class<T> classToSpy) {\n+        return MOCKITO_CORE.mock(classToSpy, withSettings()\n+                .useConstructor()\n+                .defaultAnswer(CALLS_REAL_METHODS));\n+    }\n+\n+    /**\n      * Stubs a method call with return value or an exception. E.g:\n      *\n      * <pre class=\"code\"><code class=\"java\">\n--- a/test/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java\n+++ b/test/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n-import static org.mockito.Mockito.CALLS_REAL_METHODS;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.withSettings;\n+import static org.mockito.Mockito.*;\n \n public class CreatingMocksWithConstructorTest extends TestBase {\n \n     @Test\n     public void can_mock_abstract_classes() {\n         AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n-        //the message is a part of state of the mocked type that gets initialized in constructor\n+        assertEquals(\"hey!\", mock.getMessage());\n+    }\n+\n+    @Test\n+    public void can_spy_abstract_classes() {\n+        AbstractMessage mock = spy(AbstractMessage.class);\n         assertEquals(\"hey!\", mock.getMessage());\n     }\n \n     @Test\n     public void can_mock_inner_classes() {\n         InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));\n-\n-        //the message is a part of state of the mocked type that gets initialized in constructor\n         assertEquals(\"hey!\", mock.getMessage());\n     }\n ", "timestamp": 1416167485, "metainfo": ""}