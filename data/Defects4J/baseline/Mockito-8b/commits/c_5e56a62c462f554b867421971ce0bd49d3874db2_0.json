{"sha": "5e56a62c462f554b867421971ce0bd49d3874db2", "log": "Working on issue 177 (verification with timeout) Added more stuff. Some TODOs left.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401970", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.stubbing.OngoingStubbing;\n import org.mockito.stubbing.Stubber;\n import org.mockito.stubbing.VoidMethodStubbable;\n-import org.mockito.verification.FluentVerificationMode;\n import org.mockito.verification.Timeout;\n+import org.mockito.verification.VerificationWithTimeout;\n import org.mockito.verification.VerificationMode;\n \n /**\n     }\n     \n     /**\n-     * Allows verifying with timeout. May be useful for testing concurrency.\n-     * <pre>\n-     *   //passes when someMethod() is called within given time span \n-     *   verify(mock, timeout(100)).someMethod();\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param millis - time span in millis\n-     * \n-     * @return verification mode\n-     */\n-    public static FluentVerificationMode timeout(int millis) {\n-        return new Timeout(millis, VerificationModeFactory.atLeastOnce());\n-    }    \n-    \n-    /**\n      * Alias to times(0), see {@link Mockito#times(int)}\n      * <p>\n      * Verifies that interaction did not happen. E.g:\n      * \n      * @return verification mode\n      */\n+    //TODO make exception message nicer\n     public static VerificationMode only() {\n     \treturn VerificationModeFactory.only();\n-    }\n+    }    \n+    \n+    /**\n+     * Allows verifying with timeout. May be useful for testing concurrency.\n+     * <pre>\n+     *   //passes when someMethod() is called within given time span \n+     *   verify(mock, timeout(100)).someMethod();\n+     *   //TODO decide what is the default for timeout() - atLeastOnce() or times(1)\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param millis - time span in millis\n+     * \n+     * @return verification mode\n+     */\n+    public static Timeout timeout(int millis) {\n+        return new VerificationWithTimeout(millis, VerificationModeFactory.atLeastOnce());\n+    }       \n     \n     /**\n      * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/VerificationWithTimeoutImpl.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.verification.VerificationMode;\n+\n+public class VerificationWithTimeoutImpl {\n+    \n+    VerificationMode delegate;\n+    int timeout;\n+    int treshhold;\n+\n+    public VerificationWithTimeoutImpl(int treshhold, int millis, VerificationMode delegate) {\n+        this.treshhold = treshhold;\n+        this.timeout = millis;\n+        this.delegate = delegate;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        int soFar = 0;\n+        MockitoAssertionError error = null;\n+        while (soFar <= timeout) {\n+            try {\n+                delegate.verify(data);\n+                return;\n+            } catch (MockitoAssertionError e) {\n+                error = e;\n+                soFar += treshhold;\n+                sleep(treshhold);\n+            }\n+        }\n+        if (error != null) {\n+            throw error;\n+        }\n+    }\n+\n+    void sleep(int sleep) {\n+        try {\n+            Thread.sleep(sleep);\n+        } catch (InterruptedException ie) {\n+            // TODO\n+            throw new MockitoException(\"TODO\");\n+        }\n+    }\n+    \n+    public VerificationMode getDelegate() {\n+        return delegate;\n+    }\n+\n+    public int getTimeout() {\n+        return timeout;\n+    }\n+\n+    public int getTreshhold() {\n+        return treshhold;\n+    }    \n+}\n--- a/src/org/mockito/verification/Timeout.java\n+++ b/src/org/mockito/verification/Timeout.java\n-package org.mockito.verification;\n-\n-import org.mockito.exceptions.base.MockitoAssertionError;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.verification.api.VerificationData;\n-\n-public class Timeout implements FluentVerificationMode {\n-\n-    private final VerificationMode delegate;\n-    private final int max;\n-    private final int treshhold;\n-\n-    public Timeout(int millis, VerificationMode delegate) {\n-        this(10, millis, delegate);\n-    }\n-\n-    Timeout(int treshhold, int millis, VerificationMode delegate) {\n-        this.treshhold = treshhold;\n-        this.max = millis;\n-        this.delegate = delegate;\n-    }\n-\n-    @Override\n-    public void verify(VerificationData data) {\n-        int soFar = 0;\n-        MockitoAssertionError error = null;\n-        while (soFar <= max) {\n-            try {\n-                delegate.verify(data);\n-                return;\n-            } catch (MockitoAssertionError e) {\n-                error = e;\n-                soFar += treshhold;\n-                sleep(treshhold);\n-            }\n-        }\n-        if (error != null) {\n-            throw error;\n-        }\n-    }\n-\n-    private void sleep(int sleep) {\n-        try {\n-            Thread.sleep(sleep);\n-        } catch (InterruptedException ie) {\n-            // TODO\n-            throw new MockitoException(\"TODO\");\n-        }\n-    }\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.verification;\n+\n+import org.mockito.Mockito;\n+\n+/**\n+ * Similar to {@link VerificationMode} but allows combining with other modes. E.g:\n+ * \n+ * <pre>\n+ * verify(mock, timeout(100).times(5)).foo();\n+ * \n+ * verify(mock, timeout(100).never()).bar();\n+ * \n+ * verify(mock, timeout(200).atLeastOnce()).baz();\n+ * </pre>\n+ * \n+ * <p>\n+ * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n+ */\n+public interface Timeout extends VerificationMode {\n+    \n+    //TODO: verifyNoMoreInteractions() ?\n+    \n+    /**\n+     * Allows verifying exact number of invocations within given timeout\n+     * <pre>\n+     *   verify(mock, timeout(100).times(2)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param wantedNumberOfInvocations wanted number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public VerificationMode times(int wantedNumberOfInvocations);\n+    \n+    /**\n+     * Alias to times(0), see {@link times(int)}\n+     * <p>\n+     * Verifies that interaction did not happen within given timeout. E.g:\n+     * <pre>\n+     *   verify(mock, timeout(100).never()).someMethod();\n+     * </pre>\n+     * \n+     * <p>\n+     * If you want to verify there were NO interactions with the mock \n+     * check out {@link verifyNoMoreInteractions(Object...)}\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @return verification mode\n+     */\n+    public VerificationMode never();\n+    \n+    /**\n+     * Allows at-least-once verification withing given timeout. E.g:\n+     * <pre>\n+     *   verify(mock, timeout(100).atLeastOnce()).someMethod(\"some arg\");\n+     * </pre>\n+     * Alias to atLeast(1)\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @return verification mode\n+     */\n+    public VerificationMode atLeastOnce();\n+\n+    /**\n+     * Allows at-least-x verification withing given timeout. E.g:\n+     * <pre>\n+     *   verify(mock, timeout(100).atLeast(3)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param minNumberOfInvocations minimum number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public VerificationMode atLeast(int minNumberOfInvocations);\n+\n+    /**\n+     * Allows at-most-x verification within given timeout. E.g:\n+     * <pre>\n+     *   verify(mock, timeout(100).atMost(3)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param maxNumberOfInvocations max number of invocations \n+     * \n+     * @return verification mode\n+     */\n+    public VerificationMode atMost(int maxNumberOfInvocations);\n+\n+    /**\n+     * Allows checking if given method was the only one invoked. E.g:\n+     * <pre>\n+     *   verify(mock, only()).someMethod();\n+     *   //above is a shorthand for following 2 lines of code:\n+     *   verify(mock).someMethod();\n+     *   verifyNoMoreInvocations(mock);\n+     * </pre>\n+     * \n+     * <p>\n+     * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @return verification mode\n+     */\n+    public VerificationMode only();       \n }\n--- /dev/null\n+++ b/src/org/mockito/verification/VerificationWithTimeout.java\n+package org.mockito.verification;\n+\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.internal.verification.VerificationWithTimeoutImpl;\n+import org.mockito.internal.verification.api.VerificationData;\n+\n+public class VerificationWithTimeout implements Timeout {\n+\n+    VerificationWithTimeoutImpl impl;\n+\n+    public VerificationWithTimeout(int millis, VerificationMode delegate) {\n+        this(10, millis, delegate);\n+    }\n+\n+    VerificationWithTimeout(int treshhold, int millis, VerificationMode delegate) {\n+        this.impl = new VerificationWithTimeoutImpl(treshhold, millis, delegate);\n+    }\n+\n+    @Override\n+    public void verify(VerificationData data) {\n+        impl.verify(data);\n+    }\n+\n+    @Override\n+    public VerificationMode atLeast(int minNumberOfInvocations) {\n+        return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeast(minNumberOfInvocations));\n+    }\n+\n+    @Override\n+    public VerificationMode atLeastOnce() {\n+        return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atLeastOnce());\n+    }\n+\n+    @Override\n+    public VerificationMode atMost(int maxNumberOfInvocations) {\n+        return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.atMost(maxNumberOfInvocations));\n+    }\n+\n+    @Override\n+    public VerificationMode never() {\n+        return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(0));\n+    }\n+\n+    @Override\n+    public VerificationMode only() {\n+        return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.only());\n+    }\n+\n+    @Override\n+    public VerificationMode times(int wantedNumberOfInvocations) {\n+        return new VerificationWithTimeout(impl.getTreshhold(), impl.getTimeout(), VerificationModeFactory.times(wantedNumberOfInvocations));\n+    }\n+}\n--- a/test/org/mockito/verification/TimeoutTest.java\n+++ b/test/org/mockito/verification/TimeoutTest.java\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.internal.verification.AtLeast;\n+import org.mockito.internal.verification.AtMost;\n+import org.mockito.internal.verification.Only;\n+import org.mockito.internal.verification.Times;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockitoutil.TestBase;\n \n+@SuppressWarnings(\"unchecked\")\n public class TimeoutTest extends TestBase {\n     \n     @Mock VerificationMode mode;\n \n     @Test\n     public void shouldPassWhenVerificationPasses() {\n-        Timeout t = new Timeout(1, 3, mode);\n+        VerificationWithTimeout t = new VerificationWithTimeout(1, 3, mode);\n         \n         doNothing().when(mode).verify(data);\n         \n     \n     @Test\n     public void shouldFailBecauseVerificationFails() {\n-        Timeout t = new Timeout(1, 2, mode);\n+        VerificationWithTimeout t = new VerificationWithTimeout(1, 2, mode);\n         \n         doThrow(error).\n         doThrow(error).\n     \n     @Test\n     public void shouldPassEvenIfFirstVerificationFails() {\n-        Timeout t = new Timeout(1, 2, mode);\n+        VerificationWithTimeout t = new VerificationWithTimeout(1, 2, mode);\n         \n         doThrow(error).\n         doThrow(error).\n \n     @Test\n     public void shouldTryToVerifyCorrectNumberOfTimes() {\n-        Timeout t = new Timeout(1, 4, mode);\n+        VerificationWithTimeout t = new VerificationWithTimeout(1, 4, mode);\n         \n         doThrow(error).when(mode).verify(data);\n         \n         \n         verify(mode, times(5)).verify(data);\n     }\n+    \n+    @Test\n+    public void shouldCreateCorrectType() {\n+        VerificationWithTimeout t = new VerificationWithTimeout(25, 50, mode);\n+        \n+        assertCorrectMode(t.atLeastOnce(), VerificationWithTimeout.class, 50, 25, AtLeast.class);\n+        assertCorrectMode(t.atLeast(5), VerificationWithTimeout.class, 50, 25, AtLeast.class);\n+        assertCorrectMode(t.times(5), VerificationWithTimeout.class, 50, 25, Times.class);\n+        assertCorrectMode(t.never(), VerificationWithTimeout.class, 50, 25, Times.class);\n+        assertCorrectMode(t.only(), VerificationWithTimeout.class, 50, 25, Only.class);\n+        assertCorrectMode(t.atMost(10), VerificationWithTimeout.class, 50, 25, AtMost.class);\n+    }\n+    \n+    private void assertCorrectMode(VerificationMode t, Class expectedType, int expectedTimeout, int expectedTreshold, Class expectedDelegateType) {\n+        assertEquals(expectedType, t.getClass());\n+        assertEquals(expectedTimeout, ((VerificationWithTimeout) t).impl.getTimeout());\n+        assertEquals(expectedTreshold, ((VerificationWithTimeout) t).impl.getTreshhold());\n+        assertEquals(expectedDelegateType, ((VerificationWithTimeout) t).impl.getDelegate().getClass());\n+    }\n }\n--- a/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n+++ b/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n         \n         //then\n         verify(mock, never()).clear();\n-        verify(mock, timeout(40)).clear();\n+        verify(mock, timeout(40).atLeast(1)).clear();\n     }\n \n     @Test\n         //then\n         verify(mock, never()).clear();\n         try {\n-            verify(mock, timeout(20)).clear();\n+            verify(mock, timeout(20).atLeastOnce()).clear();\n             fail();\n         } catch (MockitoAssertionError e) {}\n     }\n     \n-//    @Test\n-//    public void shouldAllowMixingOtherModesWithTimeout() throws Exception {\n-//        //given\n-//        Thread t = waitAndExerciseMock(40);\n-//        \n-//        //when\n-//        t.start();\n-//        \n-//        //then\n-//        verify(mock, never()).clear();\n-//        try {\n-//            verify(mock, timeout(20)).clear();\n-//            fail();\n-//        } catch (MockitoAssertionError e) {}\n-//    }\n+    @Test\n+    public void shouldAllowMixingOtherModesWithTimeout() throws Exception {\n+        //given\n+        Thread t1 = waitAndExerciseMock(20);\n+        Thread t2 = waitAndExerciseMock(20);\n+        \n+        //when\n+        t1.start();\n+        t2.start();\n+        \n+        //then\n+        verify(mock, timeout(1).never()).clear();\n+        verify(mock, timeout(100).times(2)).clear();\n+        verifyNoMoreInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldAllowMixingOtherModesWithTimeoutAndFail() throws Exception {\n+        //given\n+        Thread t1 = waitAndExerciseMock(20);\n+        Thread t2 = waitAndExerciseMock(20);\n+        \n+        //when\n+        t1.start();\n+        t2.start();\n+        \n+        //then\n+        verify(mock, timeout(1).never()).clear();\n+        try {\n+            verify(mock, timeout(100).times(3)).clear();\n+            fail();\n+        } catch (TooLittleActualInvocations e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowMixingOnlyWithTimeout() throws Exception {\n+        //given\n+        Thread t1 = waitAndExerciseMock(20);\n+        \n+        //when\n+        t1.start();\n+        \n+        //then\n+        verify(mock, never()).clear();\n+        verify(mock, timeout(40).only()).clear();\n+    }\n+    \n+    @Test\n+    public void shouldAllowMixingOnlyWithTimeoutAndFail() throws Exception {\n+        //given\n+        Thread t1 = waitAndExerciseMock(20);        \n+        \n+        //when\n+        t1.start();\n+        mock.add(\"foo\");\n+        \n+        //then\n+        verify(mock, never()).clear();\n+        try {\n+            verify(mock, timeout(40).only()).clear();\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n \n     private Thread waitAndExerciseMock(final int sleep) {\n         Thread t = new Thread() { ", "timestamp": 1273604478, "metainfo": ""}