{"sha": "4a5eb957b161413d61552022286f4c1b51743539", "log": "Made some exception messages more descriptive", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);   \n     }\n \n-    public void injectMockAnnotationFieldIsNull(String field) {\n-        throw new MockitoException(\"Field '\" + field + \"' annotated with @InjectMocks is null.\\n\" +\n-                \"Please make sure the instance is created *before* MockitoAnnotations.initMocks();\\n\" +\n-                \"Example of correct usage:\\n\" +\n-                \"   class SomeTest {\\n\" +\n-                \"      @InjectMocks private Foo foo = new Foo();\\n\" +\n-                \"      \\n\" +\n-                \"      @Before public void setUp() {\\n\" +\n-                \"         MockitoAnnotations.initMock(this);\\n\"\n-                );\n+    public void cannotInitializeForSpyAnnotation(String fieldName, String details) {\n+        throw new MockitoException(join(\"Cannot instianate a @Spy for '\" + fieldName + \"' field.\",\n+            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n+            \"However, I failed because: \" + details,\n+            \"Examples of correct usage of @Spy:\",\n+            \"   @Spy List mock = new LinkedList();\",\n+            \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n+            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n+                \"\"));\n     }\n }\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.Captor;\n-import org.mockito.Mock;\n-import org.mockito.Mockito;\n-import org.mockito.Spy;\n+import org.mockito.*;\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n         for (Field field : fields) {\n             if (field.isAnnotationPresent(Spy.class)) {\n                 assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n-                boolean wasAccessible = field.isAccessible();\n-                field.setAccessible(true);\n+                Object instance = null;\n                 try {\n-                    Object instance = new FieldInitializer(testClass, field).initialize();\n-                    //TODO: delete below:\n-                    if (instance == null) {\n-                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n-                        \t\t  \"The instance must be created *before* initMocks();\\n\" +\n-                                  \"Example of correct usage of @Spy:\\n\" +\n-                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n-                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n-\n-                    }\n-                    if (new MockUtil().isMock(instance)) { \n+                    instance = new FieldInitializer(testClass, field).initialize();\n+                } catch (MockitoException e) {\n+                    new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e.getMessage());\n+                }\n+                try {\n+                    if (new MockUtil().isMock(instance)) {\n                         // instance has been spied earlier\n                         Mockito.reset(instance);\n                     } else {\n+                        field.setAccessible(true);\n                         field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n                                 .spiedInstance(instance)\n                                 .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                     }\n                 } catch (IllegalAccessException e) {\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n-                } finally {\n-                    field.setAccessible(wasAccessible);\n                 }\n             }\n         }\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n \n     private void checkNotLocal(Field field) {\n         if(field.getType().isLocalClass()) {\n-            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is a local class\");\n+            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' is a local class.\");\n         }\n     }\n \n     private void checkNotInner(Field field) {\n         if(field.getType().isMemberClass() && !Modifier.isStatic(field.getType().getModifiers())) {\n-            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is an inner class\");\n+            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' is an inner class.\");\n         }\n     }\n \n     private void checkNotInterface(Field field) {\n         if(field.getType().isInterface()) {\n-            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is an interface\");\n+            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' is an interface.\");\n         }\n     }\n \n     private void checkNotAbstract(Field field) {\n         if(Modifier.isAbstract(field.getType().getModifiers())) {\n-            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is an inner class\");\n+            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \" is an abstract class.\");\n         }\n     }\n \n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n  */\n package org.mockitousage.annotation;\n \n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockito.MockitoAnnotations;\n import org.mockito.Spy;\n \n import java.util.AbstractList;\n import java.util.ArrayList;\n+import java.util.LinkedList;\n import java.util.List;\n \n+import static org.fest.assertions.Assertions.assertThat;\n import static org.mockito.Mockito.doReturn;\n \n @SuppressWarnings({\"unchecked\", \"unused\"})\n \t\tassertNotNull(staticTypeWithoutDefinedConstructor);\n     }\n \n-    @Test(expected = MockitoException.class)\n+    @Test\n     public void shouldFailIfTypeIsAnInterface() throws Exception {\n \t\tclass FailingSpy {\n \t\t\t@Spy private List spyTypeIsInterface;\n \t\t}\n \n-\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+        try {\n+            MockitoAnnotations.initMocks(new FailingSpy());\n+            fail();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"an interface\");\n+        }\n     }\n \n-    @Test(expected = MockitoException.class)\n+    @Test\n     public void shouldFailIfTypeIsAbstract() throws Exception {\n \t\tclass FailingSpy {\n \t\t\t@Spy private AbstractList spyTypeIsAbstract;\n \t\t}\n \n-\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+        try {\n+            MockitoAnnotations.initMocks(new FailingSpy());\n+            fail();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"abstract class\");\n+        }\n     }\n \n-    @Test(expected = MockitoException.class)\n+    @Test\n     public void shouldFailIfTypeIsInnerClass() throws Exception {\n \t\tclass FailingSpy {\n-\t\t\t@Spy private List spyTypeIsInner;\n+\t\t\t@Spy private TheInnerClass spyTypeIsInner;\n             class TheInnerClass { }\n \t\t}\n \n-\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+        try {\n+            MockitoAnnotations.initMocks(new FailingSpy());\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"inner class\");\n+        }\n     }\n \n \t@Test(expected = IndexOutOfBoundsException.class)", "timestamp": 1288378762, "metainfo": ""}