{"sha": "739fe2ccdfada0e9a2207c6df2629a6e2f030c81", "log": "added detecting invalid return type when stubbing with doReturn() style  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40909", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.cause.ActualArgumentsAreDifferent;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedAnywhereAfterFollowingInteraction;\n-import org.mockito.exceptions.cause.ActualArgumentsAreDifferent;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.exceptions.misusing.NullInsteadOfMockException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n                 \"Wanted at least \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n     }\n-    \n+\n+    public void wrongTypeOfReturnValue(String expectedType, String actualType, String method) {\n+        throw new WrongTypeOfReturnValue(join(\n+                actualType + \" cannot be returned by \" + method,\n+                method + \" should return \" + expectedType\n+                ));\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/misusing/WrongTypeOfReturnValue.java\n+package org.mockito.exceptions.misusing;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class WrongTypeOfReturnValue extends MockitoException {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public WrongTypeOfReturnValue(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n     \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         if (mockitoStubber.hasAnswersForStubbing()) {\n-            //stubbing voids in the old-school way: stubVoid()\n+            //stubbing voids with stubVoid() or doAnswer() style\n             Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n             mockitoStubber.setMethodForStubbing(invocationMatcher);\n--- a/src/org/mockito/internal/configuration/DefaultReturnValues.java\n+++ b/src/org/mockito/internal/configuration/DefaultReturnValues.java\n import org.mockito.configuration.ReturnValues;\n import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n     Object returnValueFor(Class<?> type) {\n         if (type.isPrimitive()) {\n             return primitiveOf(type);\n-        } else if (isPrimitiveWrapper(type)) {\n-            return primitiveWrapperOf(type);\n+        } else if (Primitives.isPrimitiveWrapper(type)) {\n+            return Primitives.primitiveWrapperOf(type);\n         //new instances are used instead of Collections.emptyList(), etc.\n         //to avoid UnsupportedOperationException if code under test modifies returned collection\n         } else if (type == Collection.class) {\n             return 0;\n         } \n     }\n-    \n-    private boolean isPrimitiveWrapper(Class<?> type) {\n-        return wrapperReturnValues.containsKey(type);\n-    }\n-    \n-    private Object primitiveWrapperOf(Class<?> type) {\n-        return wrapperReturnValues.get(type);\n-    }\n-    \n-    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n-    \n-    static {\n-        wrapperReturnValues.put(Boolean.class, Boolean.FALSE);\n-        wrapperReturnValues.put(Character.class, new Character((char) 0));\n-        wrapperReturnValues.put(Byte.class, new Byte((byte) 0));\n-        wrapperReturnValues.put(Short.class, new Short((short) 0));\n-        wrapperReturnValues.put(Integer.class, new Integer(0));\n-        wrapperReturnValues.put(Long.class, new Long(0));\n-        wrapperReturnValues.put(Float.class, new Float(0));\n-        wrapperReturnValues.put(Double.class, new Double(0));\n-    }\n }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n \n /**\n         \n         return false;\n     }\n+    \n+    public boolean isValidReturnType(Class clazz) {\n+        if (method.getReturnType().isPrimitive()) {\n+            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n+        } else {\n+            return method.getReturnType().isAssignableFrom(clazz);\n+        }\n+    }\n \n     public boolean isVoid() {\n         return this.method.getReturnType() == Void.TYPE;\n     }\n+\n+    public String printMethodReturnType() {\n+        return method.getReturnType().getSimpleName();\n+    }\n+\n+    public String getMethodName() {\n+        return method.getName();\n+    }\n+\n+    public boolean returnsPrimitive() {\n+        return method.getReturnType().isPrimitive();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/AnswersValidator.java\n         if (invocation.isVoid()) {\n             reporter.cannotStubVoidMethodWithAReturnValue();\n         }\n+        \n+        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n+            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n+        } \n+\n+        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n+            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n+        }\n     }\n \n     private void validateException(ThrowsException answer, Invocation invocation) {\n--- a/src/org/mockito/internal/stubbing/Returns.java\n+++ b/src/org/mockito/internal/stubbing/Returns.java\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return value;\n     }\n+\n+    public String printReturnType() {\n+        return value.getClass().getSimpleName();\n+    }\n+\n+    public Class<?> getReturnType() {\n+        return value.getClass();\n+    }\n+\n+    public boolean returnsNull() {\n+        return value == null;\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/Primitives.java\n+package org.mockito.internal.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class Primitives {\n+    \n+    public static boolean isPrimitiveWrapper(Class<?> type) {\n+        return wrapperReturnValues.containsKey(type);\n+    }\n+    \n+    public static Object primitiveWrapperOf(Class<?> type) {\n+        return wrapperReturnValues.get(type);\n+    }\n+    \n+    public static Class<?> primitiveTypeOf(Class<?> clazz) {\n+        return primitiveTypes.get(clazz);\n+    }\n+    \n+    private static Map<Class<?>, Object> wrapperReturnValues = new HashMap<Class<?>, Object>();\n+    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n+    \n+    static {\n+        wrapperReturnValues.put(Boolean.class, Boolean.FALSE);\n+        wrapperReturnValues.put(Character.class, new Character((char) 0));\n+        wrapperReturnValues.put(Byte.class, new Byte((byte) 0));\n+        wrapperReturnValues.put(Short.class, new Short((short) 0));\n+        wrapperReturnValues.put(Integer.class, new Integer(0));\n+        wrapperReturnValues.put(Long.class, new Long(0));\n+        wrapperReturnValues.put(Float.class, new Float(0));\n+        wrapperReturnValues.put(Double.class, new Double(0));\n+    }\n+    \n+    static {\n+        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n+        primitiveTypes.put(Character.class, Character.TYPE);\n+        primitiveTypes.put(Byte.class, Byte.TYPE);\n+        primitiveTypes.put(Short.class, Short.TYPE);\n+        primitiveTypes.put(Integer.class, Integer.TYPE);\n+        primitiveTypes.put(Long.class, Long.TYPE);\n+        primitiveTypes.put(Float.class, Float.TYPE);\n+        primitiveTypes.put(Double.class, Double.TYPE);\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/AnswersValidatorTest.java\n+++ b/test/org/mockito/internal/stubbing/AnswersValidatorTest.java\n         validator.validate(new ThrowsException(new RuntimeException()), invocation);\n     }\n     \n-    @Test\n-    public void shouldValidateReturnValue() throws Throwable {\n-        validator.validate(new Returns(\"one\"), new InvocationBuilder().simpleMethod().toInvocation());\n-    }\n-    \n     @Test(expected = MockitoException.class)\n     public void shouldFailWhenReturnValueSetForVoidMethod() throws Throwable {\n         validator.validate(new Returns(\"one\"), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     public void shouldAllowVoidReturnForVoidMethod() throws Throwable {\n         validator.validate(new DoesNothing(), new InvocationBuilder().method(\"voidMethod\").toInvocation());\n     }\n+    \n+    @Test\n+    public void shouldAllowCorrectTypeOfReturnValue() throws Throwable {\n+        validator.validate(new Returns(\"one\"), new InvocationBuilder().simpleMethod().toInvocation());\n+        validator.validate(new Returns(false), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n+        validator.validate(new Returns(new Boolean(true)), new InvocationBuilder().method(\"booleanObjectReturningMethod\").toInvocation());\n+        validator.validate(new Returns(1), new InvocationBuilder().method(\"integerReturningMethod\").toInvocation());\n+        validator.validate(new Returns(1L), new InvocationBuilder().method(\"longReturningMethod\").toInvocation());\n+        validator.validate(new Returns(1L), new InvocationBuilder().method(\"longObjectReturningMethod\").toInvocation());\n+        validator.validate(new Returns(null), new InvocationBuilder().method(\"objectReturningMethodNoArgs\").toInvocation());\n+        validator.validate(new Returns(1), new InvocationBuilder().method(\"objectReturningMethodNoArgs\").toInvocation());\n+    }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailOnReturnTypeMismatch() throws Throwable {\n+        validator.validate(new Returns(\"String\"), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n+    }\n+    \n+    @Test(expected = MockitoException.class)\n+    public void shouldFailOnWrongPrimitive() throws Throwable {\n+        validator.validate(new Returns(1), new InvocationBuilder().method(\"doubleReturningMethod\").toInvocation());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailOnNullWithPrimitive() throws Throwable {\n+        validator.validate(new Returns(null), new InvocationBuilder().method(\"booleanReturningMethod\").toInvocation());\n+    }\n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n     Double doubleObjectReturningMethod();\n \n     Object objectReturningMethod(Object ... objects);\n+    \n+    Object objectReturningMethodNoArgs();\n \n     String oneArg(boolean value);\n     \n--- a/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n import java.io.IOException;\n \n import org.junit.After;\n-import org.junit.Ignore;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.StateMaster;\n-import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.invocation.InvocationOnMock;\n     }\n  \n     @Test\n-    @Ignore(\"TODO\")\n-    public void shouldCheckTypesFast() throws Exception {\n-        try {\n-            doReturn(\"foo\").when(mock).booleanReturningMethod();\n-            fail();\n-        } catch (Exception e) {\n-            \n-        }\n+    public void shouldDetectInvalidReturnType() throws Exception {\n+        try {\n+            doReturn(\"foo\").when(mock).booleanObjectReturningMethod();\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e, messageContains(\n+                    \"String cannot be returned by booleanObjectReturningMethod\" +\n+                    \"\\n\" +\n+                    \"booleanObjectReturningMethod should return Boolean\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldDetectWhenNullAssignedToBoolean() throws Exception {\n+        try {\n+            doReturn(null).when(mock).intReturningMethod();\n+            fail();\n+        } catch (Exception e) {\n+            assertThat(e, messageContains(\"null cannot be returned by intReturningMethod\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldAllowStubbingWhenTypesMatchSignature() throws Exception {\n+        doReturn(\"foo\").when(mock).objectReturningMethodNoArgs();\n+        doReturn(\"foo\").when(mock).simpleMethod();\n+        doReturn(1).when(mock).intReturningMethod();\n+        doReturn(new Integer(2)).when(mock).intReturningMethod();\n     }\n }", "timestamp": 1221866744, "metainfo": ""}