{"sha": "cbc530c6a55b947a6008dcd4e511794c93cad513", "log": "- wes - implemented ability to serialize mock objects -- covered mock interface, mock object, partial mock, spy -- created MockitoMethod to handle creation of java Method which is not Serializable -- created MockitoMethodProxy to handle creation of cglib's MethodProxy which is not Serializable -- created SerializableNoOp to replace cglib's NoOp which is not Serializable -- made all matchers Serializable -- made all answers Serializable -- made stubbing objects Serializable  - known issues -- any object mocked object that depends on normal initialization for Serialization could/probably will fail serialization -- equals after deserialization of a mock will fail  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401639", "commit": "\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n+\n+import java.io.Serializable;\n \n import org.hamcrest.BaseMatcher;\n \n  * \n  * @param <T> type of argument\n  */\n-public abstract class ArgumentMatcher<T> extends BaseMatcher<T> {\n+public abstract class ArgumentMatcher<T> extends BaseMatcher<T> implements Serializable {\n+\n+    private static final long serialVersionUID = -2145234737829370369L;\n \n     /**\n      * Returns whether this matcher accepts the given argument.\n--- /dev/null\n+++ b/src/org/mockito/cglib/proxy/SerializableNoOp.java\n+package org.mockito.cglib.proxy;\n+\n+import java.io.Serializable;\n+\n+public class SerializableNoOp implements NoOp, Serializable {\n+\n+  private static final long serialVersionUID = 7434976328690189159L;\n+  public static final Callback SERIALIZABLE_INSTANCE = new SerializableNoOp();\n+\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n+import java.io.Serializable;\n import java.util.List;\n \n /**\n  *\n  * @param <T> type of mock object to handle\n  */\n-public class MockHandler<T> implements IMockHandler {\n+public class MockHandler<T> implements IMockHandler, Serializable {\n \n+    private static final long serialVersionUID = -2917871070982574165L;\n+    \n     MockitoStubber mockitoStubber;\n     MatchersBinder matchersBinder;\n     MockingProgress mockingProgress;\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n import java.io.Serializable;\n import java.lang.reflect.Method;\n \n-@SuppressWarnings(\"unchecked\")\n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n+    private static final long serialVersionUID = 6182795666612683784L;\n     private final IMockHandler mockHandler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n \n         cglibHacker.setMockitoNamingPolicy(methodProxy);\n         \n-        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n+        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(new MockitoMethodProxy(methodProxy));\n+        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), realMethod);\n         return mockHandler.handle(invocation);\n     }\n     \n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n  */\n package org.mockito.internal.creation;\n \n+import java.io.Serializable;\n+\n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.stubbing.Answer;\n \n-public class MockSettingsImpl implements MockSettings {\n+public class MockSettingsImpl implements MockSettings, Serializable {\n \n+    private static final long serialVersionUID = 4475297236197939568L;\n     private Class<?>[] extraInterfaces;\n     private String name;\n     private Object spiedInstance;\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MockitoMethodProxy.java\n+package org.mockito.internal.creation;\n+\n+import java.io.Serializable;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.util.reflection.Whitebox;\n+\n+public class MockitoMethodProxy implements Serializable {\n+\n+  private static final long serialVersionUID = -5337859962876770632L;\n+  private Class<?> c1;\n+  private Class<?> c2;\n+  private String desc;\n+  private String name;\n+  private String superName;\n+\n+  public MockitoMethodProxy(MethodProxy methodProxy) {\n+    Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+    c1 = (Class<?>) Whitebox.getInternalState(info, \"c1\");\n+    c2 = (Class<?>) Whitebox.getInternalState(info, \"c2\");\n+    desc = methodProxy.getSignature().getDescriptor();\n+    name = methodProxy.getSignature().getName();\n+    superName = methodProxy.getSuperName();\n+  }\n+\n+  public MethodProxy getMethodProxy() {\n+    return MethodProxy.create(c1, c2, desc, name, superName);\n+  }\n+\n+}\n--- a/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n+++ b/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n import org.mockito.cglib.proxy.MethodProxy;\n \n public class CGLIBHacker implements Serializable {\n+\n+    private static final long serialVersionUID = -4389233991416356668L;\n \n     public void setMockitoNamingPolicy(MethodProxy methodProxy) {\n         try {\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n  */\n package org.mockito.internal.creation.jmock;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n+import java.lang.reflect.*;\n import java.util.List;\n \n-import org.mockito.cglib.core.CodeGenerationException;\n-import org.mockito.cglib.core.NamingPolicy;\n-import org.mockito.cglib.core.Predicate;\n-import org.mockito.cglib.proxy.Callback;\n-import org.mockito.cglib.proxy.CallbackFilter;\n-import org.mockito.cglib.proxy.Enhancer;\n-import org.mockito.cglib.proxy.Factory;\n-import org.mockito.cglib.proxy.MethodInterceptor;\n-import org.mockito.cglib.proxy.NoOp;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.proxy.*;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.cglib.MockitoNamingPolicy;\n import org.objenesis.ObjenesisStd;\n     \n     private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\n         Factory proxy = (Factory) objenesis.newInstance(proxyClass);\n-        proxy.setCallbacks(new Callback[] {interceptor, NoOp.INSTANCE});\n+        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n         return proxy;\n     }\n     \n     }\n     \n     public static class ClassWithSuperclassToWorkAroundCglibBug {}\n+    \n }\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n  */\n package org.mockito.internal.debugging;\n \n+import java.io.Serializable;\n+\n import org.mockito.internal.exceptions.base.StackTraceFilter;\n \n-public class Location  {\n+public class Location implements Serializable {\n \n+    private static final long serialVersionUID = -9054861157390980624L;\n     private final String where;\n \n     public Location() {\n         StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n         StackTraceElement[] filtered = filter.filter(stackTrace, false);\n         if (filtered.length == 0) {\n-            where = \"-> at <<unknown line>>\";   \n+            where = \"-> at <<unknown line>>\";\n         } else {\n             where = \"-> at \" + filtered[0].toString();\n         }\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.InvocationOnMock;\n \n+import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.ArrayList;\n import java.util.Arrays;\n  * Contains stack trace of invocation\n  */\n @SuppressWarnings(\"unchecked\")\n-public class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation {\n-\n+public class Invocation implements PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation, Serializable {\n+\n+    private static final long serialVersionUID = 8240069639250980199L;\n     private static final int MAX_LINE_LENGTH = 45;\n     private final int sequenceNumber;\n     private final Object mock;\n-    private final Method method;\n+    private final MockitoMethod method;\n     private final Object[] arguments;\n     private final Object[] rawArguments;\n \n     final RealMethod realMethod;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, RealMethod realMethod) {\n+        this.method = new MockitoMethod(method);\n         this.mock = mock;\n-        this.method = method;\n         this.realMethod = realMethod;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n         this.rawArguments = args;\n     }\n \n     public Method getMethod() {\n-        return method;\n+        return method.getMethod();\n     }\n \n     public Object[] getArguments() {\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n  */\n package org.mockito.internal.invocation;\n \n+import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.Collections;\n import java.util.List;\n import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n \n @SuppressWarnings(\"unchecked\")\n-public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation {\n+public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n \n+    private static final long serialVersionUID = -3047126096857467610L;\n     private final Invocation invocation;\n     private final List<Matcher> matchers;\n \n--- a/src/org/mockito/internal/invocation/MatchersBinder.java\n+++ b/src/org/mockito/internal/invocation/MatchersBinder.java\n  */\n package org.mockito.internal.invocation;\n \n+import java.io.Serializable;\n import java.util.List;\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n \n @SuppressWarnings(\"unchecked\")\n-public class MatchersBinder {\n+public class MatchersBinder implements Serializable {\n+\n+    private static final long serialVersionUID = -311433939339443463L;\n \n     public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n         List<Matcher> lastMatchers = argumentMatcherStorage.pullMatchers();\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/MockitoMethod.java\n+package org.mockito.internal.invocation;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class MockitoMethod implements Serializable {\n+\n+  private static final long serialVersionUID = 6005610965006048445L;\n+  private Class<?> declaringClass;\n+  private String methodName;\n+  private Class<?>[] parameterTypes;\n+  private Class<?> returnType;\n+\n+  public MockitoMethod(Method method) {\n+    declaringClass = method.getDeclaringClass();\n+    methodName = method.getName();\n+    parameterTypes = method.getParameterTypes();\n+    returnType = method.getReturnType();\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    final int prime = 31;\n+    int result = 1;\n+    result = prime * result + ((declaringClass == null) ? 0 : declaringClass.hashCode());\n+    result = prime * result + ((methodName == null) ? 0 : methodName.hashCode());\n+    result = prime * result + Arrays.hashCode(parameterTypes);\n+    result = prime * result + ((returnType == null) ? 0 : returnType.hashCode());\n+    return result;\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj)\n+      return true;\n+    if (obj == null)\n+      return false;\n+    if (getClass() != obj.getClass())\n+      return false;\n+    MockitoMethod other = (MockitoMethod) obj;\n+    if (declaringClass == null) {\n+      if (other.declaringClass != null)\n+        return false;\n+    } else if (!declaringClass.equals(other.declaringClass))\n+      return false;\n+    if (methodName == null) {\n+      if (other.methodName != null)\n+        return false;\n+    } else if (!methodName.equals(other.methodName))\n+      return false;\n+    if (!Arrays.equals(parameterTypes, other.parameterTypes))\n+      return false;\n+    if (returnType == null) {\n+      if (other.returnType != null)\n+        return false;\n+    } else if (!returnType.equals(other.returnType))\n+      return false;\n+    return true;\n+  }\n+\n+  public Method getMethod() {\n+    try {\n+      return declaringClass.getDeclaredMethod(methodName, parameterTypes);\n+    } catch (SecurityException e) {\n+      // TODO real exception\n+      throw new MockitoException(\"could not create method\", e);\n+    } catch (NoSuchMethodException e) {\n+      // TODO real exception\n+      throw new MockitoException(\"could not create method\", e);\n+    }\n+  }\n+\n+  public String getName() {\n+    return methodName;\n+  }\n+\n+  public Class<?> getReturnType() {\n+    return returnType;\n+  }\n+\n+}\n--- a/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n  */\n package org.mockito.internal.invocation.realmethod;\n \n+import java.io.Serializable;\n+\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n \n \n-public class CGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy {\n+public class CGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy, Serializable {\n \n-    private final MethodProxy methodProxy;\n+    private static final long serialVersionUID = -4596470901191501582L;\n+    private final MockitoMethodProxy methodProxy;\n \n-    public CGLIBProxyRealMethod(MethodProxy methodProxy) {\n+    public CGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {\n         this.methodProxy = methodProxy;\n     }\n \n     public Object invoke(Object target, Object[] arguments) throws Throwable {\n-        return methodProxy.invokeSuper(target, arguments);\n+        return methodProxy.getMethodProxy().invokeSuper(target, arguments);\n     }\n \n     public MethodProxy getMethodProxy() {\n-        return methodProxy;\n+        return methodProxy.getMethodProxy();\n     }\n }\n--- a/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n /*\n  * Copyright (c) 2007 Mockito contributors\n+\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.invocation.realmethod;\n \n+import java.io.Serializable;\n+\n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n-public class FilteredCGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy {\n+public class FilteredCGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy, Serializable {\n \n+    private static final long serialVersionUID = 3596550785818938496L;\n     private final RealMethod realMethod;\n \n-    public FilteredCGLIBProxyRealMethod(MethodProxy methodProxy) {\n+    public FilteredCGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {\n         this(new CGLIBProxyRealMethod(methodProxy));\n     }\n \n--- a/src/org/mockito/internal/matchers/And.java\n+++ b/src/org/mockito/internal/matchers/And.java\n @SuppressWarnings(\"unchecked\")\n public class And extends ArgumentMatcher {\n \n+    private static final long serialVersionUID = -4624719625691177501L;\n     private final List<Matcher> matchers;\n \n     public And(List<Matcher> matchers) {\n--- a/src/org/mockito/internal/matchers/Any.java\n+++ b/src/org/mockito/internal/matchers/Any.java\n @SuppressWarnings(\"unchecked\")\n public class Any extends ArgumentMatcher {\n \n+    private static final long serialVersionUID = -4062420125651019029L;\n     public static final Any ANY = new Any();    \n     \n     private Any() {}\n--- a/src/org/mockito/internal/matchers/AnyVararg.java\n+++ b/src/org/mockito/internal/matchers/AnyVararg.java\n @SuppressWarnings(\"unchecked\")\n public class AnyVararg extends ArgumentMatcher implements VarargMatcher {\n \n+    private static final long serialVersionUID = 1700721373094731555L;\n     public static final Matcher ANY_VARARG = new AnyVararg();\n \n     public boolean matches(Object arg) {\n--- a/src/org/mockito/internal/matchers/ArrayEquals.java\n+++ b/src/org/mockito/internal/matchers/ArrayEquals.java\n import org.hamcrest.Description;\n \n public class ArrayEquals extends Equals {\n+\n+    private static final long serialVersionUID = -7167812844261087583L;\n \n     public ArrayEquals(Object wanted) {\n         super(wanted);\n--- a/src/org/mockito/internal/matchers/CapturingMatcher.java\n+++ b/src/org/mockito/internal/matchers/CapturingMatcher.java\n @SuppressWarnings(\"unchecked\")\n public class CapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments {\n     \n+    private static final long serialVersionUID = 4274067078639307295L;\n     private LinkedList<Object> arguments = new LinkedList<Object>();\n \n     /* (non-Javadoc)\n--- a/src/org/mockito/internal/matchers/CompareEqual.java\n+++ b/src/org/mockito/internal/matchers/CompareEqual.java\n package org.mockito.internal.matchers;\n \n public class CompareEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    private static final long serialVersionUID = 2998586260452920429L;\n \n     public CompareEqual(Comparable<T> value) {\n         super(value);\n--- a/src/org/mockito/internal/matchers/CompareTo.java\n+++ b/src/org/mockito/internal/matchers/CompareTo.java\n \n \n public abstract class CompareTo<T extends Comparable<T>> extends ArgumentMatcher<T> {\n+    private static final long serialVersionUID = 1857450785375711120L;\n     private final Comparable<T> wanted;\n \n     public CompareTo(Comparable<T> value) {\n--- a/src/org/mockito/internal/matchers/Contains.java\n+++ b/src/org/mockito/internal/matchers/Contains.java\n \n public class Contains extends ArgumentMatcher<String> {\n \n+    private static final long serialVersionUID = -1909837398271763801L;\n     private final String substring;\n \n     public Contains(String substring) {\n--- a/src/org/mockito/internal/matchers/EndsWith.java\n+++ b/src/org/mockito/internal/matchers/EndsWith.java\n \n public class EndsWith extends ArgumentMatcher<String> {\n \n+    private static final long serialVersionUID = 8556443228350129421L;\n     private final String suffix;\n \n     public EndsWith(String suffix) {\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n  */\n package org.mockito.internal.matchers;\n \n+import java.io.Serializable;\n+\n import org.hamcrest.Description;\n import org.hamcrest.SelfDescribing;\n import org.mockito.ArgumentMatcher;\n \n-public class Equals extends ArgumentMatcher<Object> implements ContainsExtraTypeInformation {\n+public class Equals extends ArgumentMatcher<Object> implements ContainsExtraTypeInformation, Serializable {\n \n+    private static final long serialVersionUID = -3395637450058086891L;\n     private final Object wanted;\n \n     public Equals(Object wanted) {\n--- a/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n \n \n public class EqualsWithDelta extends ArgumentMatcher<Number>{\n+    private static final long serialVersionUID = 5066980489920383664L;\n+\n     private final Number wanted;\n \n     private final Number delta;\n--- a/src/org/mockito/internal/matchers/Find.java\n+++ b/src/org/mockito/internal/matchers/Find.java\n \n public class Find extends ArgumentMatcher<String> {\n \n+    private static final long serialVersionUID = 8895781429480404872L;\n     private final String regex;\n \n     public Find(String regex) {\n--- a/src/org/mockito/internal/matchers/GreaterOrEqual.java\n+++ b/src/org/mockito/internal/matchers/GreaterOrEqual.java\n package org.mockito.internal.matchers;\n \n public class GreaterOrEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    private static final long serialVersionUID = 87695769061286092L;\n \n     public GreaterOrEqual(Comparable<T> value) {\n         super(value);\n--- a/src/org/mockito/internal/matchers/GreaterThan.java\n+++ b/src/org/mockito/internal/matchers/GreaterThan.java\n package org.mockito.internal.matchers;\n \n public class GreaterThan<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    private static final long serialVersionUID = 7446529803235604408L;\n \n     public GreaterThan(Comparable<T> value) {\n         super(value);\n--- a/src/org/mockito/internal/matchers/InstanceOf.java\n+++ b/src/org/mockito/internal/matchers/InstanceOf.java\n \n public class InstanceOf extends ArgumentMatcher<Object> {\n \n+    private static final long serialVersionUID = 517358915876138366L;\n     private final Class<?> clazz;\n \n     public InstanceOf(Class<?> clazz) {\n--- a/src/org/mockito/internal/matchers/LessOrEqual.java\n+++ b/src/org/mockito/internal/matchers/LessOrEqual.java\n package org.mockito.internal.matchers;\n \n public class LessOrEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    private static final long serialVersionUID = -6648773374429103565L;\n \n     public LessOrEqual(Comparable<T> value) {\n         super(value);\n--- a/src/org/mockito/internal/matchers/LessThan.java\n+++ b/src/org/mockito/internal/matchers/LessThan.java\n package org.mockito.internal.matchers;\n \n public class LessThan<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    private static final long serialVersionUID = -133860804462310942L;\n \n     public LessThan(Comparable<T> value) {\n         super(value);\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.matchers;\n+\n+import java.io.Serializable;\n \n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n-public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator {\n+public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator, Serializable {\n \n+    private static final long serialVersionUID = 6748641229659825725L;\n     private final Matcher actualMatcher;\n     private Location location;\n \n--- a/src/org/mockito/internal/matchers/Matches.java\n+++ b/src/org/mockito/internal/matchers/Matches.java\n \n public class Matches extends ArgumentMatcher<Object> {\n \n+    private static final long serialVersionUID = 8787704593379472029L;\n     private final String regex;\n \n     public Matches(String regex) {\n--- a/src/org/mockito/internal/matchers/Not.java\n+++ b/src/org/mockito/internal/matchers/Not.java\n @SuppressWarnings(\"unchecked\")\n public class Not extends ArgumentMatcher {\n \n+    private static final long serialVersionUID = 4627373642333593264L;\n     private final Matcher first;\n \n     public Not(Matcher first) {\n--- a/src/org/mockito/internal/matchers/NotNull.java\n+++ b/src/org/mockito/internal/matchers/NotNull.java\n \n public class NotNull extends ArgumentMatcher<Object> {\n \n+    private static final long serialVersionUID = 7278261081285153228L;\n     public static final NotNull NOT_NULL = new NotNull();\n     \n     private NotNull() {\n--- a/src/org/mockito/internal/matchers/Null.java\n+++ b/src/org/mockito/internal/matchers/Null.java\n \n public class Null extends ArgumentMatcher<Object> {\n \n+    private static final long serialVersionUID = 2823082637424390314L;\n     public static final Null NULL = new Null();\n \n     private Null() {\n--- a/src/org/mockito/internal/matchers/Or.java\n+++ b/src/org/mockito/internal/matchers/Or.java\n @SuppressWarnings(\"unchecked\")\n public class Or extends ArgumentMatcher {\n \n+    private static final long serialVersionUID = 5888739035212283087L;\n     private final List<Matcher> matchers;\n \n     public Or(List<Matcher> matchers) {\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n \n public class Same extends ArgumentMatcher<Object> {\n \n+    private static final long serialVersionUID = -1226959355938572597L;\n     private final Object wanted;\n \n     public Same(Object wanted) {\n--- a/src/org/mockito/internal/matchers/StartsWith.java\n+++ b/src/org/mockito/internal/matchers/StartsWith.java\n \n public class StartsWith extends ArgumentMatcher<String> {\n \n+    private static final long serialVersionUID = -5978092285707998431L;\n     private final String prefix;\n \n     public StartsWith(String prefix) {\n--- a/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java\n+++ b/src/org/mockito/internal/matchers/apachecommons/ReflectionEquals.java\n import org.mockito.ArgumentMatcher;\n \n public class ReflectionEquals extends ArgumentMatcher<Object> {\n+    private static final long serialVersionUID = 2022780425116330014L;\n     private final Object wanted;\n     private final String[] excludeFields;\n \n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n+import java.io.Serializable;\n+\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n-public class ThreadSafeMockingProgress implements MockingProgress {\n+public class ThreadSafeMockingProgress implements MockingProgress, Serializable {\n     \n+    private static final long serialVersionUID = 6839454041642082618L;\n     private static ThreadLocal<MockingProgress> mockingProgress = new ThreadLocal<MockingProgress>();\n \n     static MockingProgress threadSafely() {\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n  */\n package org.mockito.internal.stubbing;\n \n+import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.LinkedList;\n import java.util.List;\n import org.mockito.stubbing.Answer;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockitoStubber {\n+public class MockitoStubber implements Serializable {\n \n+    private static final long serialVersionUID = -5334301962749537176L;\n     private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private final MockingProgress mockingProgress;\n     private final List<Answer> answersForStubbing = new ArrayList<Answer>();\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n @SuppressWarnings(\"unchecked\")\n public class StubbedInvocationMatcher extends InvocationMatcher implements Answer {\n \n+    private static final long serialVersionUID = 4919105134123672727L;\n     private final Queue<Answer> answers = new ConcurrentLinkedQueue<Answer>();\n \n     public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n--- a/src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswerReturnValuesAdapter.java\n @SuppressWarnings(\"deprecation\")\n public class AnswerReturnValuesAdapter implements Answer<Object> {\n \n+    private static final long serialVersionUID = 1418158596876713469L;\n     private final ReturnValues returnValues;\n \n     public AnswerReturnValuesAdapter(ReturnValues returnValues) {\n--- a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n  * <p>\n  */\n public class CallsRealMethods implements Answer<Object> {\n+    private static final long serialVersionUID = 9057165148930624087L;\n+\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return invocation.callRealMethod();\n     }\n--- a/src/org/mockito/internal/stubbing/answers/DoesNothing.java\n+++ b/src/org/mockito/internal/stubbing/answers/DoesNothing.java\n \n public class DoesNothing implements Answer<Object> {\n     \n+    private static final long serialVersionUID = 4840880517740698416L;\n+\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return null;\n     }\n--- a/src/org/mockito/internal/stubbing/answers/Returns.java\n+++ b/src/org/mockito/internal/stubbing/answers/Returns.java\n \n public class Returns implements Answer<Object> {\n \n+    private static final long serialVersionUID = -6245608253574215396L;\n     private final Object value;\n \n     public Returns(Object value) {\n--- a/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n \n public class ThrowsException implements Answer<Object> {\n \n+    private static final long serialVersionUID = 1128820328555183980L;\n     private final Throwable throwable;\n     private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n \n--- a/src/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/GloballyConfiguredAnswer.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n+\n+import java.io.Serializable;\n \n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.internal.configuration.GlobalConfiguration;\n  * <p>\n  * See javadoc for {@link IMockitoConfiguration}\n  */\n-public class GloballyConfiguredAnswer implements Answer<Object> {\n+public class GloballyConfiguredAnswer implements Answer<Object>, Serializable {\n     \n+    private static final long serialVersionUID = 3585893470101750917L;\n+\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         return new GlobalConfiguration().getDefaultAnswer().answer(invocation);\n     }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n  */\n public class ReturnsEmptyValues implements Answer<Object> {\n     \n+    private static final long serialVersionUID = 1998191268711234347L;\n+\n     /* (non-Javadoc)\n      * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n      */\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java\n \n public class ReturnsMocks implements Answer<Object> {\n     \n+    private static final long serialVersionUID = -6755257986994634579L;\n     private MockitoCore mockitoCore = new MockitoCore();\n     private Answer<Object> delegate = new ReturnsMoreEmptyValues();\n     \n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java\n  */\n public class ReturnsMoreEmptyValues implements Answer<Object> {\n     \n+    private static final long serialVersionUID = -2816745041482698471L;\n     private Answer<Object> delegate = new ReturnsEmptyValues();\n     \n     /* (non-Javadoc)\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n  */\n public class ReturnsSmartNulls implements Answer<Object> {\n \n+    private static final long serialVersionUID = 7618312406617949441L;\n+\n     private final class ThrowingInterceptor implements MethodInterceptor {\n         private final InvocationOnMock invocation;\n         private final Location location = new Location();\n--- a/src/org/mockito/internal/util/MockName.java\n+++ b/src/org/mockito/internal/util/MockName.java\n  */\n package org.mockito.internal.util;\n \n-public class MockName {\n+import java.io.Serializable;\n+\n+public class MockName implements Serializable {\n     \n+    private static final long serialVersionUID = 8014974700844306925L;\n     private final String mockName;\n     private boolean surrogate;\n \n--- a/src/org/mockito/internal/util/ObjectMethodsGuru.java\n+++ b/src/org/mockito/internal/util/ObjectMethodsGuru.java\n import java.io.Serializable;\n \n public class ObjectMethodsGuru implements Serializable {\n+\n+    private static final long serialVersionUID = -1286718569065470494L;\n \n     public boolean isToString(Method method) {\n         return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n  */\n package org.mockito.internal.verification;\n \n+import java.io.Serializable;\n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n import org.mockito.internal.util.ListUtil.Filter;\n \n \n-public class RegisteredInvocations {\n+public class RegisteredInvocations implements Serializable {\n \n+    private static final long serialVersionUID = -2674402327380736290L;\n     private final List<Invocation> invocations = Collections.synchronizedList(new LinkedList<Invocation>());\n     \n     public void add(Invocation invocation) {\n--- a/src/org/mockito/stubbing/Answer.java\n+++ b/src/org/mockito/stubbing/Answer.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.stubbing;\n+\n+import java.io.Serializable;\n \n import org.mockito.invocation.InvocationOnMock;\n \n  * \n  * @param <T> the type to return.\n  */\n-public interface Answer<T> {\n+public interface Answer<T> extends Serializable {\n     /**\n      * @param invocation the invocation on the mock.\n      *\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/MockitoMethodProxyTest.java\n+package org.mockito.internal.creation;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockitoutil.TestBase;\n+import org.powermock.reflect.Whitebox;\n+\n+\n+public class MockitoMethodProxyTest extends TestBase {\n+\n+  @Test\n+  public void shouldCreateWithMethodProxy() throws Exception {\n+    MethodProxy proxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+    MockitoMethodProxy mockitoMethodProxy = new MockitoMethodProxy(proxy);\n+    assertNotNull( mockitoMethodProxy.getMethodProxy());\n+  }\n+  \n+  @Test\n+  public void shouldCreateCorrectCreationInfo() throws Exception {\n+    //given\n+    MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"\", \"\", \"\");\n+    MockitoMethodProxy mockitoMethodProxy = new MockitoMethodProxy(proxy);\n+    \n+    //when\n+    Object methodProxy = mockitoMethodProxy.getMethodProxy();\n+   \n+    //then\n+    Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+    assertEquals(String.class, Whitebox.getInternalState(info, \"c1\"));\n+    assertEquals(Integer.class, Whitebox.getInternalState(info, \"c2\"));\n+  }\n+  \n+  @Test\n+  public void shouldCreateCorrectSignatures() throws Exception {\n+    //given\n+    MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"a\", \"b\", \"c\");\n+    MockitoMethodProxy mockitoMethodProxy = new MockitoMethodProxy(proxy);\n+    \n+    //when\n+    MethodProxy methodProxy = (MethodProxy) mockitoMethodProxy.getMethodProxy();\n+    \n+    //then\n+    assertEquals(\"a\", methodProxy.getSignature().getDescriptor());\n+    assertEquals(\"b\", methodProxy.getSignature().getName());\n+    assertEquals(\"c\", methodProxy.getSuperName());\n+  }\n+  \n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/MockitoMethodTest.java\n+package org.mockito.internal.invocation;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class MockitoMethodTest extends TestBase {\n+\n+  @Test\n+  public void shouldBeSerializable() throws Exception {\n+    Class<?>[] args = new Class<?>[0];\n+    MockitoMethod method = new MockitoMethod(this.getClass().getMethod(\"toString\", args));\n+    ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n+    new ObjectOutputStream(serialized).writeObject(method);\n+  }\n+  \n+  @Test\n+  public void shouldBeAbleToRetrieveTheMethodInitializedWith() throws Exception {\n+    Class<?>[] args = new Class<?>[0];\n+    Method method = this.getClass().getMethod(\"toString\", args);\n+    MockitoMethod mockMethod = new MockitoMethod(method);\n+    assertEquals(method, mockMethod.getMethod());\n+  }\n+}\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n  */\n package org.mockitousage.basicapi;\n \n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.*;\n+\n+import java.io.*;\n+import java.util.*;\n+\n import org.junit.Test;\n-import org.junit.Ignore;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.withSettings;\n+import org.mockito.InOrder;\n+import org.mockito.internal.matchers.Any;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-\n-public class MocksSerializationTest extends TestBase {\n-\n-    @Test\n-    @Ignore\n-    public void shouldAllowMockToBeSerializable() throws Exception {\n-        //given\n-        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-        ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n-\n-        //when\n-        new ObjectOutputStream(serialized).writeObject(mock);\n-\n-        //then\n-    }\n+public class MocksSerializationTest extends TestBase implements Serializable {\n+\n+  private static final long serialVersionUID = 6160482220413048624L;\n+\n+  @Test\n+  public void shouldAllowMockToBeSerializable() throws Exception {\n+    // given\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    deserializeMock(serialized, IMethods.class);\n+  }\n+\n+  @Test\n+  public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {\n+    // given\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    when(mock.booleanReturningMethod()).thenReturn(true);\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    assertTrue(readObject.booleanReturningMethod());\n+  }\n+\n+  @Test\n+  public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {\n+    // given\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    String value = \"value\";\n+    when(mock.stringReturningMethod()).thenReturn(value);\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    assertEquals(value, readObject.stringReturningMethod());\n+  }\n+\n+  @Test\n+  public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {\n+    // given\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    List<?> value = Collections.emptyList();\n+    when(mock.objectReturningMethodNoArgs()).thenReturn(value);\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    assertEquals(value, readObject.objectReturningMethodNoArgs());\n+  }\n+\n+  @Test\n+  public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    List<?> value = Collections.emptyList();\n+    when(mock.objectArgMethod(value)).thenReturn(value);\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    assertEquals(value, readObject.objectArgMethod(value));\n+  }\n+\n+  @Test\n+  public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    List<?> value = Collections.emptyList();\n+    when(mock.objectArgMethod(anyString())).thenReturn(value);\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    assertEquals(value, readObject.objectArgMethod(\"\"));\n+  }\n+\n+  @Test\n+  public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    List<?> value = Collections.emptyList();\n+    when(mock.objectArgMethod(anyString())).thenReturn(value);\n+    mock.objectArgMethod(\"\");\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    verify(readObject, times(1)).objectArgMethod(\"\");\n+  }\n+\n+  @Test\n+  public void shouldVerifyCallOrderForSerializedMock() throws Exception {\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    IMethods mock2 = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    mock.arrayReturningMethod();\n+    mock2.arrayReturningMethod();\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+    ByteArrayOutputStream serialized2 = serializeMock(mock2);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    IMethods readObject2 = deserializeMock(serialized2, IMethods.class);\n+    InOrder inOrder = inOrder(readObject, readObject2);\n+    inOrder.verify(readObject).arrayReturningMethod();\n+    inOrder.verify(readObject2).arrayReturningMethod();\n+  }\n+\n+  @Test\n+  public void shouldRememberInteractionsForSerializedMock() throws Exception {\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    List<?> value = Collections.emptyList();\n+    when(mock.objectArgMethod(anyString())).thenReturn(value);\n+    mock.objectArgMethod(\"happened\");\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    verify(readObject, never()).objectArgMethod(\"never happened\");\n+  }\n+\n+  @SuppressWarnings(\"serial\")\n+  @Test\n+  public void shouldSerializeWithStubbingCallback() throws Exception {\n+    \n+    // given\n+    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+    final String string = \"return value\";\n+    when(mock.objectArgMethod(anyString())).thenAnswer(new Answer<Object>() {\n+      public Object answer(InvocationOnMock invocation) {\n+        invocation.getArguments();\n+        invocation.getMock();\n+        return string;\n+      }\n+    });\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+    // then\n+    IMethods readObject = deserializeMock(serialized, IMethods.class);\n+    assertEquals(string, readObject.objectArgMethod(\"\"));\n+  }\n+\n+  @Test\n+  public void shouldSerializeWithRealObjectSpy() throws Exception {\n+\n+    // given\n+    List<Object> list = new ArrayList<Object>();\n+    List<Object> spy = spy(list);\n+    when(spy.size()).thenReturn(100);\n+\n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(spy);\n+\n+    // then\n+    List<?> readObject = deserializeMock(serialized, List.class);\n+    assertEquals(100, readObject.size());\n+  }\n+  \n+  @Test\n+  public void shouldSerializeObjectMock() throws Exception {\n+    // given\n+    Any mock = mock(Any.class);\n+    \n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+    \n+    // then\n+    deserializeMock(serialized, Any.class);\n+  }\n+  \n+  @Test\n+  public void shouldSerializeRealPartialMock() throws Exception {\n+    // given\n+    Any mock = mock(Any.class);\n+    when(mock.matches(anyObject())).thenCallRealMethod();\n+    \n+    // when\n+    ByteArrayOutputStream serialized = serializeMock(mock);\n+    \n+    // then\n+    Any readObject = deserializeMock(serialized, Any.class);\n+    readObject.matches(\"\");\n+  }\n+\n+  private <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,\n+      ClassNotFoundException {\n+    InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());\n+    Object readObject = new ObjectInputStream(unserialize).readObject();\n+    assertNotNull(readObject);\n+    return type.cast(readObject);\n+  }\n+\n+  private ByteArrayOutputStream serializeMock(Object mock) throws IOException {\n+    ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n+    new ObjectOutputStream(serialized).writeObject(mock);\n+    return serialized;\n+  }\n+\n }", "timestamp": 1256883017, "metainfo": ""}