{"sha": "0efaf1b9945017f9ee70de1da857c37cc62299c8", "log": "Refactored to make it easy for incoming feature (smarter printing verbose types for arguments)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401469", "commit": "\n--- a/src/org/mockito/internal/invocation/PrintSettings.java\n+++ b/src/org/mockito/internal/invocation/PrintSettings.java\n public class PrintSettings {\n \n     private boolean multiline;\n-    private boolean verboseArguments;\n     private List<Matcher> verboseMatchers = new LinkedList<Matcher>();\n \n     public void setMultiline(boolean multiline) {\n     }\n \n     public void setVerboseArguments(boolean verboseArguments) {\n-        this.verboseArguments = verboseArguments;\n     }\n \n     public boolean isMultiline() {\n         return multiline;\n-    }\n-\n-    public boolean isVerboseArguments() {\n-        return verboseArguments;\n     }\n \n     public static PrintSettings verboseMatchers(Matcher ... verboselyPrinted) {\n     }\n \n     public boolean printsVerbosely(Matcher matcher) {\n-        if (isVerboseArguments()) {\n-            return true;\n-        }\n         for (Matcher m : verboseMatchers) {\n             if (m == matcher) {\n                 return true;\n--- a/src/org/mockito/internal/verification/SmartPrinter.java\n+++ b/src/org/mockito/internal/verification/SmartPrinter.java\n     public SmartPrinter(PrintingFriendlyInocation wanted, PrintingFriendlyInocation actual) {\n         PrintSettings printSettings = new PrintSettings();\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n-        printSettings.setVerboseArguments(wanted.toString().equals(actual.toString()));\n         \n         this.wanted = wanted.toString(printSettings);\n         this.actual = actual.toString(printSettings);\n--- a/test/org/mockito/internal/verification/SmartPrinterTest.java\n+++ b/test/org/mockito/internal/verification/SmartPrinterTest.java\n         assertNotContains(\"\\n\", printer.getWanted().toString());\n         assertNotContains(\"\\n\", printer.getActual().toString());\n     }\n-    \n-    @Test\n-    public void shouldPrintVerboseArgumentsWhenStringOutputIsTheSame() {\n-        //given\n-        mock.longArg(1);\n-        Invocation withLongArg = getLastInvocation();\n-        \n-        mock.longArg(1);\n-        Invocation withIntArg = getLastInvocation();\n-        \n-        //when\n-        SmartPrinter printer = new SmartPrinter(withLongArg, withIntArg);\n-        \n-        //then\n-        assertContains(\"longArg((Long) 1)\", printer.getWanted().toString());\n-        assertContains(\"longArg((Long) 1)\", printer.getActual().toString());\n-    }\n }\n--- a/test/org/mockitousage/bugs/EqWithIntsDoesntCopeWithLongsTest.java\n+++ b/test/org/mockitousage/bugs/EqWithIntsDoesntCopeWithLongsTest.java\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n import org.mockitoutil.TestBase;\n \n-//see issue \n+@Ignore\n public class EqWithIntsDoesntCopeWithLongsTest extends TestBase {\n \n     class Boo {\n-        public void withLong(long y) {\n+        public void withLong(long x) {\n+        }\n+        \n+        public void withLongAndInt(long x, int y) {\n         }\n     }\n     \n             assertContains(\"withLong((Long) 100);\", e.getMessage());\n         }\n     }\n+    \n+    @Test\n+    public void shouldShowTheTypeOfOnlyTheArgumentThatDoesntMatch() throws Exception {\n+        //given\n+        Boo boo = mock(Boo.class);\n+        boo.withLongAndInt(100, 200);\n+        \n+        try {\n+            //when\n+            verify(boo).withLongAndInt(eq(100), eq(200));\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            //then\n+            assertContains(\"withLongAndInt((Integer) 100,  200)\", e.getMessage());\n+            assertContains(\"withLongAndInt((Long) 100,  200)\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldShowTheTypeOfTheMismatchingArgumentWhenOutputDescriptionsForInvocationsAreDifferent() throws Exception {\n+        //given\n+        Boo boo = mock(Boo.class);\n+        boo.withLongAndInt(100, 200);\n+        \n+        try {\n+            //when\n+            verify(boo).withLongAndInt(eq(100), anyInt());\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            //then\n+            assertContains(\"withLongAndInt((Integer) 100,  200)\", e.getMessage());\n+            assertContains(\"withLongAndInt((Long) 100,  <any>)\", e.getMessage());\n+        }\n+    }\n }", "timestamp": 1244234228, "metainfo": ""}