{"sha": "881414b4f58b43eb4b0d4174cd934da2d13385c0", "log": "working on TODOs after fixing the stack trace remover bug  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40435", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n                 && invocation.getMethod().equals(actual.getMethod())\n                 && argumentsMatch(actual);\n     }\n-    \n-    private boolean isOverloaded(Invocation actual) {\n-        //TODO unit\n-        return invocation.getMock().equals(actual.getMock())\n-            && invocation.getMethod().getName().equals(actual.getMethod().getName())\n-            && !invocation.getMethod().equals(actual.getMethod());\n-    }\n \n     private boolean argumentsMatch(Invocation actual) {\n         Object[] arguments = actual.getArguments();\n \n     /**\n      * similar means the same method name, same mock, unverified \n-     * and if arguments are the same cannot be overloaded\n+     * and: if arguments are the same cannot be overloaded\n      */\n     public boolean isSimilarTo(Invocation candidate) {\n         String wantedMethodName = getMethod().getName();\n         String currentMethodName = candidate.getMethod().getName();\n         \n-        boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n-        boolean isUnverified = !candidate.isVerified();\n-        boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n-        boolean overloadedButSameArgs = isOverloaded(candidate) && argumentsMatch(candidate);        \n+        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n+        final boolean isUnverified = !candidate.isVerified();\n+        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n+        final boolean methodEquals = invocation.getMethod().equals(candidate.getMethod());\n+        final boolean overloadedButSameArgs = !methodEquals && argumentsMatch(candidate);        \n         \n         if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\n             return true;\n--- a/test/org/mockito/exceptions/base/CommonStackTraceRemoverTest.java\n+++ b/test/org/mockito/exceptions/base/CommonStackTraceRemoverTest.java\n package org.mockito.exceptions.base;\n \n import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n-import java.util.Arrays;\n import java.util.List;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n \n+@SuppressWarnings(\"unchecked\")\n public class CommonStackTraceRemoverTest extends TestBase {\n \n     private CommonStackTraceRemover remover;\n \n     @Test\n     public void testShouldNotRemoveWhenStackTracesDontHaveCommonPart() {\n-        StackTraceElement elementOne = new StackTraceElement(\"MethodInterceptorFilter\", \"intercept\", \"MethodInterceptorFilter.java\", 49);\n-        HasStackTrace trace = new HasStackTraceStub(elementOne);\n+        HasStackTrace exception = new TraceBuilder().methods(\"intercept\").toTrace();\n+        List<StackTraceElement> cause = new TraceBuilder().methods(\"foo\").toTraceList();\n         \n-        StackTraceElement elementTwo = new StackTraceElement(\"Mockito\", \"other\", \"Mockito.java\", 90);\n-        List<StackTraceElement> cause = Arrays.asList(elementTwo);\n+        remover.remove(exception, cause);\n         \n-        remover.remove(trace, cause);\n-        \n-        assertEquals(1, trace.getStackTrace().length);\n-        assertEquals(elementOne, trace.getStackTrace()[0]);\n-        //TODO decent arrays equal please, the same in STFT\n+        assertThat(exception, hasOnlyThoseMethodsInStackTrace(\"intercept\"));\n     }\n     \n-    //TODO even though this stuff is tested on functional level, I want some more tests here - the unit test should be complete\n+    @Test\n+    public void testShouldRemoveCommonStackTracePart() {\n+        HasStackTrace exception = new TraceBuilder().methods(\"intercept\", \"handle\", \"foo\", \"bar\").toTrace();\n+        List<StackTraceElement> cause = new TraceBuilder().methods(\"intercept\", \"handle\", \"hello\", \"world\").toTraceList();\n+        \n+        remover.remove(exception, cause);\n+        \n+        assertThat(exception, hasOnlyThoseMethodsInStackTrace(\"bar\", \"foo\"));\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/exceptions/base/TraceBuilder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.base;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class TraceBuilder {\n+\n+    private String[] methods;\n+\n+    public TraceBuilder methods(String ... methods) {\n+        this.methods = methods;\n+        return this;\n+    }\n+\n+    public HasStackTrace toTrace() {\n+        List<StackTraceElement> trace = toTraceList();\n+        return new HasStackTraceStub(trace.toArray(new StackTraceElement[methods.length]));\n+    }\n+\n+    public List<StackTraceElement> toTraceList() {\n+        List<StackTraceElement> trace = new LinkedList<StackTraceElement>();\n+        for (String method : methods) {\n+            trace.add(new StackTraceElement(\"SomeClass\", method, \"SomeClass.java\", 50));\n+        }\n+        Collections.reverse(trace);\n+        return trace;\n+    }\n+}\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n import org.hamcrest.CoreMatchers;\n import org.hamcrest.Description;\n import org.hamcrest.Matcher;\n+import org.mockito.exceptions.base.HasStackTrace;\n \n @SuppressWarnings(\"unchecked\")\n public class ExtraMatchers extends CoreMatchers {\n \n     public static <T> Matcher<Throwable> hasFirstMethodInStackTrace(final String method) {\n         return hasMethodInStackTraceAt(0, method);\n+    }\n+    \n+//    public static <T> Matcher<HasStackTrace> hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n+//        return new BaseMatcher<List<StackTraceElement>>() {\n+//    }\n+    \n+    public static <T> Matcher hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n+        return new BaseMatcher() {\n+            public boolean matches(Object traceElements) {\n+                final List<StackTraceElement> trace;\n+                if (traceElements instanceof List) {\n+                    trace = (List<StackTraceElement>) traceElements;\n+                } else if (traceElements instanceof HasStackTrace) {\n+                    trace = Arrays.asList(((HasStackTrace) traceElements).getStackTrace());\n+                } else {\n+                    throw new RuntimeException(\"this matcher cannot deal with object provided: \" + traceElements);\n+                }\n+                \n+                if (trace.size() != methods.length) {\n+                    return false;\n+                }\n+                    \n+                for (int i = 0; i < trace.size(); i++) {\n+                    if (!trace.get(i).getMethodName().equals(methods[i])) {\n+                        return false;\n+                    }\n+                }\n+\n+                return true;\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"has only those methods in stack trace: \");\n+                desc.appendValue(methods);\n+            }\n+        };\n     }\n     \n     public static <T> Matcher<Throwable> hasMethodInStackTraceAt(final int stackTraceIndex, final String method) {\n             }\n         };\n     }\n-}\n+}\n--- a/test/org/mockitousage/StackTrackeChangingTest.java\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n             verifySimpleMethodOnAMock();\n             fail();\n         } catch (ArgumentsAreDifferentException e) {\n+            //TODO hasOnlyThoseMethods stuff\n             assertThat(e, hasMethodInStackTraceAt(0, \"verifySimpleMethodOnAMock\"));\n             assertThat(e, hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n             assertThat(e.getCause(), hasMethodInStackTraceAt(0, \"simpleMethodOnAMock\"));", "timestamp": 1204581161, "metainfo": ""}