{"sha": "5b494bf419235a18d7b903a2d4809c556e15920b", "log": "fixes to javadoc mostly  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40398", "commit": "\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n  * Allows creating customized argument matchers. \n  * <p>\n  * ArgumentMatcher is an hamcrest {@link Matcher} with predefined describeTo() method for convenience.\n- * <p>\n- * See {@link Matchers}\n  * <p>\n  * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}, e.g:\n  * \n  * verify(mock).addAll(argThat(new IsListOfTwoElements()));\n  * </pre>\n  * \n- * Custom matchers are generally used rarely.\n- * <p>\n  * To keep it readable you may want to extract method, e.g:\n  * \n  * <pre>\n  *   //becomes\n  *   verify(mock).addAll(listOfTwoElements());\n  * </pre>\n+ *\n+ * Custom argument matchers can make the test less readable. \n+ * Sometimes it's better to implement equals() for arguments that are passed to mocks \n+ * (Mockito naturally uses equals() for argument matching). \n+ * This can make the test cleaner.\n+ * <p>\n+ * Read more about {@link Matchers}\n  * \n  * @param <T> type of argument\n  */\n--- a/src/org/mockito/InOrder.java\n+++ b/src/org/mockito/InOrder.java\n  * <pre>\n  * InOrder inOrder = inOrder(firstMock, secondMock);\n  * \n- * inOrder.verify(firstMock).add(\"should be called first\");\n- * inOrder.verify(secondMock).add(\"should be called second\");\n+ * inOrder.verify(firstMock).add(\"was called first\");\n+ * inOrder.verify(secondMock).add(\"was called second\");\n  * </pre>\n  * \n  * See examples in javadoc for {@link Mockito} class\n  */\n public interface InOrder {\n     /**\n-     * Verifies mock object in order. E.g:\n-     * \n+     * Verifies interaction <b>happened once</b> in order.\n+     * <p>\n+     * Alias to <code>inOrder.verify(mock, times(1))</code>\n+     * <p>\n+     * Example:\n      * <pre>\n      * InOrder inOrder = inOrder(firstMock, secondMock);\n      * \n-     * inOrder.verify(firstMock).someMethod(\"should be called first\");\n-     * inOrder.verify(secondMock).someMethod(\"should be called second\");\n+     * inOrder.verify(firstMock).someMethod(\"was called first\");\n+     * inOrder.verify(secondMock).someMethod(\"was called second\");\n      * </pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n     <T> T verify(T mock);\n \n     /**\n-     * Verifies mock object in order. E.g:\n+     * Verifies interaction in order. E.g:\n      * \n      * <pre>\n      * InOrder inOrder = inOrder(firstMock, secondMock);\n      * \n-     * inOrder.verify(firstMock, times(2)).someMethod(\"should be called first two times\");\n-     * inOrder.verify(secondMock, atLeastOnce()).someMethod(\"should be called second\");\n+     * inOrder.verify(firstMock, times(2)).someMethod(\"was called first two times\");\n+     * inOrder.verify(secondMock, atLeastOnce()).someMethod(\"was called second at least once\");\n      * </pre>\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n      * @param mock to be verified\n-     * @param mode times(x) or atLeastOnce()\n+     * @param mode, for example times(x) or atLeastOnce()\n      * \n      * @return mock object itself\n      */\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  *  //you can also verify using argument matcher\n  *  verify(mockedList).get(anyInt());\n  * </pre>\n+ * Scroll down to see all methods - full list of matchers.\n+ * <p>\n  * <b>Warning:</b>\n  * <p>\n  * If you are using argument matchers, <b>all arguments</b> have to be provided by matchers.\n  *   //above is incorrect - exception will be thrown because third argument is given without argument matcher.\n  * </pre>\n  * \n- * <h1>Custom Matchers</h1>\n+ * <h1>Custom Argument Matchers</h1>\n  * \n  * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n  * <p>\n  *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n  * </pre>\n  * \n- * Custom matchers are generally used rarely. \n- * <p>\n  * To keep it readable you may want to extract method, e.g:\n  * <pre>\n  *   verify(mock).addAll(argThat(new IsListOfTwoElements()));\n  *   //becomes\n  *   verify(mock).addAll(listOfTwoElements());\n  * </pre>\n- * \n+ *\n+ * Custom argument matchers can make the test less readable. \n+ * Sometimes it's better to implement equals() for arguments that are passed to mocks \n+ * (Mockito naturally uses equals() for argument matching). \n+ * This can make the test cleaner.\n  */\n public class Matchers {\n \n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * Following examples mock List, because everyone knows its interface (methods like add(), get(), clear() will be used). \n  * <br>You probably wouldn't mock List class 'in real'.  \n  * \n- * <h3>Let's verify!</h3>\n+ * <h3>Let's verify some behaviour!</h3>\n  * \n  * <pre>\n  * //Let's import Mockito statically so that code looks clearer\n  * \n  * <p>\n  * Argument matchers allow flexible verification or stubbing. \n- * See all {@link Matchers} including examples of <b>custom matchers / hamcrest matchers</b>. \n+ * See all {@link Matchers} including examples of <b>custom argument matchers / hamcrest matchers</b>. \n  * <p>\n  * <b>Warning:</b>\n  * <p>\n  *  verify(mockedList, times(3)).add(\"three times\");\n  *  \n  *  //verification using never(). never() is an alias to times(0)\n- *  verify(mockedList, never()).add(\"three times\");\n+ *  verify(mockedList, never()).add(\"never happened\");\n  *  \n  *  //verification using atLeastOnce()\n  *  verify(mockedList, atLeastOnce()).add(\"three times\");\n  *   List secondMock = mock(List.class);\n  *   \n  *   //using mocks\n- *   firstMock.add(\"should be called first\");\n- *   secondMock.add(\"should be called second\");\n+ *   firstMock.add(\"was called first\");\n+ *   secondMock.add(\"was called second\");\n  *   \n  *   //create inOrder object passing any mocks that need to be verified in order\n  *   InOrder inOrder = inOrder(firstMock, secondMock);\n  *   \n  *   //following will make sure that firstMock was called before secondMock\n- *   inOrder.verify(firstMock).add(\"should be called first\");\n- *   inOrder.verify(secondMock).add(\"should be called second\");\n+ *   inOrder.verify(firstMock).add(\"was called first\");\n+ *   inOrder.verify(secondMock).add(\"was called second\");\n  * </pre>\n  * \n  * Verification in order is flexible - you don't have to verify all interactions one-by-one\n     }\n \n     /**\n-     * Verifies certain behavior <b>happened once</b>. E.g:\n+     * Verifies certain behavior <b>happened once</b> \n+     * <p>\n+     * Alias to <code>verify(mock, times(1))</code> E.g:\n      * <pre>\n      *   verify(mock).someMethod(\"some arg\");\n      * </pre>\n     /**\n      * Verifies certain behavior happened at least once or exact number of times. E.g:\n      * <pre>\n-     *   verify(mock, times(5)).someMethod(\"should be called five times\");\n+     *   verify(mock, times(5)).someMethod(\"was called five times\");\n      *   \n-     *   verify(mock, atLeastOnce()).someMethod(\"should be called at least once\");\n+     *   verify(mock, atLeastOnce()).someMethod(\"was called at least once\");\n      *   \n      *   //you can use flexible argument matchers, e.g:\n      *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n      * See examples in javadoc for {@link Mockito} class\n      * \n      * @param mock to be verified\n-     * @param mode times(x) or atLeastOnce()\n+     * @param mode times(x), atLeastOnce() or never()\n      * \n      * @return mock object itself\n      */\n      * <pre>\n      *   InOrder inOrder = inOrder(firstMock, secondMock);\n      *   \n-     *   inOrder.verify(firstMock).add(\"should be called first\");\n-     *   inOrder.verify(secondMock).add(\"should be called second\");\n+     *   inOrder.verify(firstMock).add(\"was called first\");\n+     *   inOrder.verify(secondMock).add(\"was called second\");\n      * </pre>\n      * \n      * Verification in order is flexible - you don't have to verify all interactions one-by-one\n     }\n     \n     /**\n-     * Alias to times(0)\n-     * <p>\n-     * See {@link Mockito#times(int)}\n+     * Alias to times(0), see {@link Mockito#times(int)}\n+     * <p>\n+     * Verifies that interaction did not happen\n+     * <pre>\n+     *   verify(mock, never()).someMethod();\n+     * </pre>\n+     * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * \n--- a/src/org/mockito/internal/progress/VerificationMode.java\n+++ b/src/org/mockito/internal/progress/VerificationMode.java\n /**\n  * Allows verifying that certain behavior happened at least once or exact number of times. E.g:\n  * <pre>\n- *   verify(mock, times(5)).someMethod(\"should be called five times\");\n+ *   verify(mock, times(5)).someMethod(\"was called five times\");\n  *   \n- *   verify(mock, atLeastOnce()).someMethod(\"should be called at least once\");\n+ *   verify(mock, atLeastOnce()).someMethod(\"was called at least once\");\n+ *   \n+ *   verify(mock, never()).someMethod(\"was never called\");\n  * </pre>\n  * \n  * <b>times(1) is the default</b> and can be omitted\n--- a/test/org/mockitousage/DescriptiveMessagesOnMisuseTest.java\n+++ b/test/org/mockitousage/DescriptiveMessagesOnMisuseTest.java\n     @Mock private IMethods mock;\n \n     @SuppressWarnings(\"all\")\n-    @Ignore\n+    @Ignore(\"just for tuning up the error messages\")\n     @Test\n     public void tryDescriptiveMessagesOnMisuse() {\n         verifyNoMoreInteractions();", "timestamp": 1204015627, "metainfo": ""}