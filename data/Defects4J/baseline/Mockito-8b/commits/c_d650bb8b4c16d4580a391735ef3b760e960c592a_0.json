{"sha": "d650bb8b4c16d4580a391735ef3b760e960c592a", "log": "issue 260 : factored out the mock scanning for injection", "commit": "\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n \n import org.mockito.*;\n import org.mockito.configuration.AnnotationEngine;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.reflection.FieldReader;\n+import org.mockito.internal.configuration.injection.scanner.InjectMocksScanner;\n+import org.mockito.internal.configuration.injection.scanner.MockScanner;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n  */\n @SuppressWarnings({\"deprecation\", \"unchecked\"})\n public class InjectingAnnotationEngine implements AnnotationEngine {\n-    MockUtil mockUtil = new MockUtil();\n-    AnnotationEngine delegate = new DefaultAnnotationEngine();\n-    AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n+    private AnnotationEngine delegate = new DefaultAnnotationEngine();\n+    private AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n \n     /***\n      * Create a mock using {@link DefaultAnnotationEngine}\n         }\n     }\n \n-    void assertNoAnnotations(final Field field, final Class ... annotations) {\n-        for (Class annotation : annotations) {\n-            if (field.isAnnotationPresent(annotation)) {\n-                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n-            }\n-        }        \n-    }\n \n     /**\n      * Initializes mock/spies dependencies for objects annotated with\n         Set<Object> mocks = new HashSet<Object>();\n         \n         while (clazz != Object.class) {\n-            mockDependentFields.addAll(scanForInjection(testClassInstance, clazz));\n-            mocks.addAll(scanAndPrepareMocks(testClassInstance, clazz));\n+            new InjectMocksScanner(testClassInstance, clazz).addTo(mockDependentFields);\n+            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);\n             clazz = clazz.getSuperclass();\n         }\n         \n         new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n     }\n \n-    /**\n-     * Scan fields annotated by &#064;InjectMocks\n-     *\n-     * @param testClassInstance Instance of the test\n-     * @param clazz Current class in the hierarchy of the test\n-     * @return Fields that depends on Mock\n-     *\n-     * @see #scanAndPrepareMocks(Object, Class)\n-     */\n-    private Set<Field> scanForInjection(final Object testClassInstance, final Class<?> clazz) {\n-        Set<Field> mockDependentFields = new HashSet<Field>();\n-        Field[] fields = clazz.getDeclaredFields();\n-        for (Field field : fields) {\n-            if (null != field.getAnnotation(InjectMocks.class)) {\n-                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n-                mockDependentFields.add(field);\n-            }\n-        }\n-\n-        return mockDependentFields;\n-    }\n-\n-    /**\n-     * Scan mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.\n-     *\n-     * <p>\n-     *     Actually the preparation of mocks consists only in defining a MockName if not already set.\n-     * </p>\n-     *\n-     * @param testClassInstance The test instance\n-     * @param clazz The class in the type hierarchy of this instance.\n-     * @return A prepared set of mock\n-     */\n-    private Set<Object> scanAndPrepareMocks(final Object testClassInstance, final Class<?> clazz) {\n-        Set<Object> mocks = new HashSet<Object>();\n-        for (Field field : clazz.getDeclaredFields()) {\n-            // mock or spies only\n-            FieldReader fieldReader = new FieldReader(testClassInstance, field);\n-            if (containsMockOrSpy(field, fieldReader)) {\n-                Object mockInstance = fieldReader.read();\n-\n-                if (mockInstance != null) {\n-                    mockUtil.redefineMockNameIfSurrogate(mockInstance, field.getName());\n-                    mocks.add(mockInstance);\n-                }\n-            }\n-        }\n-        return mocks;\n-    }\n-\n-    private boolean containsMockOrSpy(Field field, FieldReader fieldReader) {\n-        return null != field.getAnnotation(Spy.class)\n-                || null != field.getAnnotation(Mock.class)\n-                || null != field.getAnnotation(MockitoAnnotations.Mock.class)\n-                || mockUtil.isMock(fieldReader.read())\n-                || mockUtil.isSpy(fieldReader.read());\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/scanner/InjectMocksScanner.java\n+package org.mockito.internal.configuration.injection.scanner;\n+\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.Reporter;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Scan field for injection.\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public class InjectMocksScanner {\n+    private final Class<?> clazz;\n+\n+    /**\n+     * Create a new InjectMocksScanner for the given clazz on the given instance\n+     *\n+     * @param clazz    Current class in the hierarchy of the test\n+     */\n+    public InjectMocksScanner(Class<?> clazz) {\n+        this.clazz = clazz;\n+    }\n+\n+\n+    /**\n+     * Add the fields annotated by @{@link InjectMocks}\n+     *\n+     * @param mockDependentFields Set of fields annotated by  @{@link InjectMocks}\n+     */\n+    public void addTo(Set<Field> mockDependentFields) {\n+        mockDependentFields.addAll(scan());\n+    }\n+\n+    /**\n+     * Scan fields annotated by &#064;InjectMocks\n+     *\n+     * @return Fields that depends on Mock\n+     */\n+    private Set<Field> scan() {\n+        Set<Field> mockDependentFields = new HashSet<Field>();\n+        Field[] fields = clazz.getDeclaredFields();\n+        for (Field field : fields) {\n+            if (null != field.getAnnotation(InjectMocks.class)) {\n+                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n+                mockDependentFields.add(field);\n+            }\n+        }\n+\n+        return mockDependentFields;\n+    }\n+\n+    void assertNoAnnotations(final Field field, final Class... annotations) {\n+        for (Class annotation : annotations) {\n+            if (field.isAnnotationPresent(annotation)) {\n+                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+package org.mockito.internal.configuration.injection.scanner;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldReader;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Scan mocks, and prepare them if needed.\n+ */\n+public class MockScanner {\n+    private MockUtil mockUtil = new MockUtil();\n+    private final Object instance;\n+    private final Class<?> clazz;\n+\n+    /**\n+     * Creates a MockScanner.\n+     *\n+     * @param instance The test instance\n+     * @param clazz    The class in the type hierarchy of this instance.\n+     */\n+    public MockScanner(Object instance, Class<?> clazz) {\n+        this.instance = instance;\n+        this.clazz = clazz;\n+    }\n+\n+    /**\n+     * Add the scanned and prepared mock instance to the given collection.\n+     *\n+     * <p>\n+     * The preparation of mocks consists only in defining a MockName if not already set.\n+     * </p>\n+     *\n+     * @param mocks Set of mocks\n+     */\n+    public void addPreparedMocks(Set<Object> mocks) {\n+        mocks.addAll(scan());\n+    }\n+\n+    /**\n+     * Scan and prepare mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.\n+     *\n+     * @return A prepared set of mock\n+     */\n+    private Set<Object> scan() {\n+        Set<Object> mocks = new HashSet<Object>();\n+        for (Field field : clazz.getDeclaredFields()) {\n+            // mock or spies only\n+            FieldReader fieldReader = new FieldReader(instance, field);\n+\n+            Object mockInstance = preparedMock(fieldReader.read(), field);\n+            if (mockInstance != null) {\n+                mocks.add(mockInstance);\n+            }\n+        }\n+        return mocks;\n+    }\n+\n+    private Object preparedMock(Object instance, Field field) {\n+        if (isAnnotatedByMockOrSpy(field)) {\n+            return instance;\n+        } else if (isMockOrSpy(instance)) {\n+            mockUtil.redefineMockNameIfSurrogate(instance, field.getName());\n+            return instance;\n+        }\n+        return null;\n+    }\n+\n+    private boolean isAnnotatedByMockOrSpy(Field field) {\n+        return null != field.getAnnotation(Spy.class)\n+                || null != field.getAnnotation(Mock.class)\n+                || null != field.getAnnotation(MockitoAnnotations.Mock.class);\n+    }\n+\n+    private boolean isMockOrSpy(Object instance) {\n+        return mockUtil.isMock(instance)\n+                || mockUtil.isSpy(instance);\n+    }\n+}", "timestamp": 1319822332, "metainfo": ""}