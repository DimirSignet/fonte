{"sha": "b2484302d4e715da6664092d670ca8805e609d9c", "log": "Better documentation on the generic meta-data  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n+++ b/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.util.Checks;\n-import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.stubbing.Answer;\n \n import java.lang.reflect.*;\n \n \n /**\n+ * This class can retrieve generic meta-data that the compiler stores on classes\n+ * and accessible members.\n  *\n+ * <p>\n+ *     The main idea of this code is to create a Map that will help to resolve return types.\n+ *     In order to actually work with nested generics, this map will have to be passed along new instances\n+ *     as a type context.\n+ * </p>\n  *\n+ * <p>\n+ *     Hence :\n+ *     <ul>\n+ *         <li>the metadata is created using the {@link #from(Type)} method from a real\n+ *         Class or from a ParameterizedType, other types are not yet supported.</li>\n  *\n+ *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n+ *         {@link #resolveGenericReturnType(Method)}.</li>\n  *\n+ *         <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n+ *         we need to create the mock ourselves as we know how to create it, depending on the kind of Type (Class,\n+ *         ParameterizedType, TypeVariable), the method {@link #toMock(Answer)} assumes this responsibility.</li>\n+ *     </ul>\n+ * </p>\n  *\n+ * <p>\n+ * For now this code support the following kind of generic declarations :\n+ * <pre class=\"code\"><code class=\"java\">\n+ * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n+ *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n+ *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n+ *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n+ *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n+ *     K returningK();\n+ *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n+ *     &lt;S, T extends S&gt; T two_type_params();\n+ *     &lt;O extends K&gt; O typeVar_with_type_params();\n+ *     Number returningNonGeneric();\n+ * }\n+ * </code></pre>\n+ *\n+ * @see #from(Type)\n+ * @see #resolveGenericReturnType(Method)\n+ * @see #toMock(Answer)\n+ * @see org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubs\n  */\n @Incubating\n public abstract class MockitoGenericMetadata {\n     }\n \n     private Object createMock(Class<?> rawType, MockSettings mockSettings) {\n-        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n-            return null;\n-        }\n         return Mockito.mock(rawType, mockSettings);\n     }\n \n--- a/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n+++ b/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n package org.mockito.internal.util.reflection;\n \n import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n \n \n \n-    @Test\n-    public void toMock_returns_null_if_type_unmockable() throws Exception {\n+    @Test(expected = MockitoException.class)\n+    public void toMock_propagate_MockitoException_if_type_unmockable() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n \n         MockitoGenericMetadata.BoundedType boundedType = (MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n \n-        assertThat(from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS)).isNull();\n+        from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);\n     }\n \n     @Test", "timestamp": 1343833586, "metainfo": ""}