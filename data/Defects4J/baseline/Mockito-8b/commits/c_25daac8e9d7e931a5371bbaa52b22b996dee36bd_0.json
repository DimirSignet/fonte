{"sha": "25daac8e9d7e931a5371bbaa52b22b996dee36bd", "log": "got rid of some TODOs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40431", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n                 && invocation.getMethod().equals(actual.getMethod())\n-                && argumentsMatch(actual.getArguments());\n+                && argumentsMatch(actual);\n     }\n     \n-    public boolean isOverloadedVersionOf(Invocation actual) {\n+    private boolean isOverloaded(Invocation actual) {\n+        //TODO unit\n         return invocation.getMock().equals(actual.getMock())\n-            && argumentsMatch(actual.getArguments())\n             && invocation.getMethod().getName().equals(actual.getMethod().getName())\n             && !invocation.getMethod().equals(actual.getMethod());\n     }\n \n-    private boolean argumentsMatch(Object[] arguments) {\n+    private boolean argumentsMatch(Invocation actual) {\n+        Object[] arguments = actual.getArguments();\n         if (arguments.length != matchers.size()) {\n             return false;\n         }\n         }\n         return true;\n     }\n+\n+    /**\n+     * similar means the same method name, same mock, unverified \n+     * and if arguments are the same cannot be overloaded\n+     */\n+    public boolean isSimilarTo(Invocation candidate) {\n+        String wantedMethodName = getMethod().getName();\n+        String currentMethodName = candidate.getMethod().getName();\n+        \n+        boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n+        boolean isUnverified = !candidate.isVerified();\n+        boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n+        boolean overloadedButSameArgs = isOverloaded(candidate) && argumentsMatch(candidate);        \n+        \n+        if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         for (Invocation invocation : invocations) {\n-            //TODO shit code - refactor to InvocationMatcher wanted.isSimilar(invocation) and add test for overloading check, make it also efficient\n-            String wantedMethodName = wanted.getMethod().getName();\n-            String currentMethodName = invocation.getMethod().getName();\n-            \n-            boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n-            boolean isUnverified = !invocation.isVerified();\n-            boolean mockIsTheSame = wanted.getInvocation().getMock() == invocation.getMock();\n-            boolean isOverloaded = wanted.isOverloadedVersionOf(invocation);\n-            \n-            if (methodNameEquals && isUnverified && mockIsTheSame && !isOverloaded) {\n+            if (wanted.isSimilarTo(invocation)) {\n                 return invocation;\n             }\n         }\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n     private Object[] args = new Object[] {};\n     private Object mock = \"mock\";\n     private Method method;\n+    private boolean verified;\n \n     public Invocation toInvocation() {\n-        if (method != null) {\n-            return new Invocation(mock, method, args, sequenceNumber);\n-        }\n-        \n-        Method m;\n-        List<Class> argTypes = new LinkedList<Class>();\n-        for (Object arg : args) {\n-            if (arg == null) {\n-                argTypes.add(Object.class);\n-            } else {\n-                argTypes.add(arg.getClass());\n+        if (method == null) {\n+            List<Class> argTypes = new LinkedList<Class>();\n+            for (Object arg : args) {\n+                if (arg == null) {\n+                    argTypes.add(Object.class);\n+                } else {\n+                    argTypes.add(arg.getClass());\n+                }\n+            }\n+            \n+            try {\n+                method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\n             }\n         }\n         \n-        try {\n-            m = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\n+        Invocation i = new Invocation(mock, method, args, sequenceNumber);\n+        if (verified) {\n+            i.markVerified();\n         }\n-        return new Invocation(mock, m, args, sequenceNumber);\n+        return i;\n     }\n \n     public InvocationBuilder method(String methodName) {\n         return this;\n     }\n \n+    public InvocationBuilder verified() {\n+        this.verified = true;\n+        return this;\n+    }\n+\n     public InvocationMatcher toInvocationMatcher() {\n         return new InvocationMatcher(toInvocation());\n     }\n     public InvocationBuilder differentMethod() {\n         return this.method(\"differentMethod\");\n     }\n-}\n+}\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import static org.junit.Assert.*;\n import static org.mockito.util.ExtraMatchers.*;\n \n+import java.lang.reflect.Method;\n import java.util.HashMap;\n import java.util.Map;\n \n import org.hamcrest.Matcher;\n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.TestBase;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.NotNull;\n+import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcherTest extends TestBase {\n+\n+    private InvocationMatcher simpleMethod;\n+    \n+    @Before\n+    public void setup() {\n+        simpleMethod = new InvocationBuilder().simpleMethod().toInvocationMatcher();\n+    }\n \n     public void shouldBuildEqualsMatchersWhenNullPassed() throws Exception {\n         InvocationMatcher m = new InvocationMatcher(new InvocationBuilder().args(\"foo\").toInvocation(), null);\n         assertEquals(\"Object.simpleMethod(notNull())\", notNull.toString());\n         assertEquals(\"Object.simpleMethod('x')\", equals.toString());\n     }\n-}\n+    \n+    @Test\n+    public void shouldKnowIfIsSimilarTo() throws Exception {\n+        Invocation same = new InvocationBuilder().simpleMethod().toInvocation();\n+        assertTrue(simpleMethod.isSimilarTo(same));\n+        \n+        Invocation different = new InvocationBuilder().differentMethod().toInvocation();\n+        assertFalse(simpleMethod.isSimilarTo(different));\n+    }\n+    \n+    @Test\n+    public void shouldNotBeSimilarToVerifiedInvocation() throws Exception {\n+        Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n+        assertFalse(simpleMethod.isSimilarTo(verified));\n+    }\n+       \n+    @Test\n+    public void shouldNotBeSimilarIfMocksAreDifferent() throws Exception {\n+        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        assertFalse(simpleMethod.isSimilarTo(onDifferentMock));\n+    }    \n+    \n+    @Test\n+    public void shouldNotBeSimilarIfIsOverloadedButUsedWithTheSameArg() throws Exception {\n+        Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n+        Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n+        \n+        String sameArg = \"test\";\n+        \n+        InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();\n+        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n+        \n+        assertFalse(invocation.isSimilarTo(overloadedInvocation));\n+    } \n+    \n+    @Test\n+    public void shouldBeSimilarIfIsOverloadedButUsedWithDifferentArg() throws Exception {\n+        Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n+        Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n+        \n+        InvocationMatcher invocation = new InvocationBuilder().method(method).arg(\"foo\").toInvocationMatcher();\n+        Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(\"bar\").toInvocation();\n+        \n+        assertTrue(invocation.isSimilarTo(overloadedInvocation));\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n import java.util.List;\n import java.util.Map;\n \n-import org.hamcrest.CoreMatchers;\n import org.junit.Before;\n import org.junit.Test;\n-import org.junit.matchers.IsCollectionContaining;\n import org.mockito.TestBase;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n     }\n     \n     @Test\n-    public void shouldFindSimilarUnverifiedInvocationByName() throws Exception {\n-        simpleMethodInvocation.markVerified();\n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertSame(found, simpleMethodInvocationTwo);\n-    }\n-    \n-    @Test\n-    public void shouldNotFindSimilarInvocationBecauseAllAreVerified() throws Exception {\n-        simpleMethodInvocation.markVerified();\n-        simpleMethodInvocationTwo.markVerified();\n-        differentMethodInvocation.markVerified();\n-        \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertNull(found);\n-    }\n-    \n-    @Test\n-    public void shouldLookForSimilarInvocationsOnlyOnTheSameMock() throws Exception {\n-        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n-        invocations.addFirst(onDifferentMock);\n-        \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertNotSame(onDifferentMock, found);\n-    }    \n-    \n-    @Test\n-    public void shouldReturnLastUnverifiedFromTheSameMockOnly() throws Exception {\n-        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n-        invocations.addFirst(onDifferentMock);\n-\n-        simpleMethodInvocation.markVerified();\n-        simpleMethodInvocationTwo.markVerified();\n-        \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertNotSame(onDifferentMock, found);\n-    }  \n-    \n-    @Test\n     public void shouldGetLastStackTrace() throws Exception {\n         HasStackTrace last = finder.getLastStackTrace(invocations);\n         assertSame(differentMethodInvocation.getStackTrace(), last);", "timestamp": 1204488384, "metainfo": ""}