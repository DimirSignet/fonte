{"sha": "8d77362bb3f9a78140ab8e17992bb0b535e6fde6", "log": "More work around DEEP mocks  --HG-- rename : src/org/mockito/internal/util/CreationValidator.java => src/org/mockito/internal/util/MockCreationValidator.java rename : test/org/mockito/internal/util/CreationValidatorTest.java => test/org/mockito/internal/util/MockCreationValidatorTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401849", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     /*\n      * Helps debugging failing tests. Not yet ready.\n      */\n-    static MockitoDebugger debug() {\n+    public static MockitoDebugger debug() {\n         return new MockitoDebuggerImpl();\n     }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepMocks.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepMocks.java\n import org.mockito.Mockito;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n public class ReturnsDeepMocks implements Answer<Object>, Serializable {\n     private static final long serialVersionUID = -6926328908792880098L;\n+    \n+    private Answer<Object> delegate = new ReturnsEmptyValues();\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-        //TODO: cover also unmockable & final classes\n         Class<?> clz = invocation.getMethod().getReturnType();\n-        if (clz.isPrimitive())\n-            return null;\n+        if (!new MockCreationValidator().isTypeMockable(clz))\n+            return delegate.answer(invocation);\n         return getMock(invocation);\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockCreationValidator {\n+\n+    public boolean isTypeMockable(Class<?> clz) {\n+        return ClassImposterizer.INSTANCE.canImposterise(clz);\n+    }\n+    \n+    public void validateType(Class classToMock) {\n+        if (!isTypeMockable(classToMock)) {\n+            new Reporter().cannotMockFinalClass(classToMock);\n+        }\n+    }\n+    \n+    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n+        if (extraInterfaces == null) {\n+            return;\n+        }\n+        \n+        for (Class i : extraInterfaces) {\n+            if (classToMock == i) {\n+                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n+            }\n+        }\n+    }\n+    \n+    public void validateMockedType(Class classToMock, Object spiedInstance) {\n+        if (classToMock == null || spiedInstance == null) {\n+            return;\n+        }\n+        if (!classToMock.equals(spiedInstance.getClass())) {\n+            new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n     \n-    private final CreationValidator creationValidator;\n+    private final MockCreationValidator creationValidator;\n \n-    public MockUtil(CreationValidator creationValidator) {\n+    public MockUtil(MockCreationValidator creationValidator) {\n         this.creationValidator = creationValidator;\n     }\n     \n     public MockUtil() {\n-        this(new CreationValidator());\n+        this(new MockCreationValidator());\n     }\n \n     public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n--- /dev/null\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockCreationValidatorTest extends TestBase {\n+\n+    final class FinalClass {}\n+    MockCreationValidator validator = new MockCreationValidator();\n+    \n+    @Test\n+    public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n+        try {\n+            //when\n+            validator.validateExtraInterfaces(IMethods.class, new Class<?>[] {IMethods.class});\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"You mocked following type: IMethods\", e.getMessage());\n+        }\n+    }\n+        \n+    @Test\n+    public void shouldNotAllowsInconsistentTypes() throws Exception {\n+        try {\n+            //when\n+            validator.validateMockedType(List.class, new ArrayList());\n+            fail();\n+            //then\n+        } catch(MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowOnlyConsistentTypes() throws Exception {\n+        //when\n+        validator.validateMockedType(ArrayList.class, new ArrayList());\n+        //then no exception is thrown\n+    }\n+    \n+    @Test\n+    public void shouldValidationBeSafeWhenNullsPassed() throws Exception {\n+        //when\n+        validator.validateMockedType(null, new ArrayList());\n+        //or\n+        validator.validateMockedType(ArrayList.class, null);\n+        //then no exception is thrown\n+    }\n+}\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n     \n-    public class CreationValidatorStub extends CreationValidator {\n+    public class CreationValidatorStub extends MockCreationValidator {\n         private boolean extraInterfacesValidated;\n         private boolean typeValidated;\n         public void validateType(Class classToMock) {\n--- a/test/org/mockitousage/stubbing/DeepMockingTest.java\n+++ b/test/org/mockitousage/stubbing/DeepMockingTest.java\n  */\n package org.mockitousage.stubbing;\n \n+import static org.mockito.BDDMockito.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n import java.io.ByteArrayOutputStream;\n import java.io.OutputStream;\n import java.net.Socket;\n import org.junit.Test;\n import org.mockitoutil.TestBase;\n \n-import static org.mockito.Mockito.*;\n-\n \n public class DeepMockingTest extends TestBase {\n \n+    static class Person {\n+        Address address;\n+\n+        public Address getAddress() {\n+            return address;\n+        }\n+        \n+        public FinalClass getFinalClass() {\n+            return null;\n+        }\n+    }\n+    \n+    static class Address {\n+        Street street;\n+\n+        public Street getStreet() {\n+            return street;\n+        }\n+    }\n+    \n+    static class Street {\n+        String name;\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }    \n+    \n+    static final class FinalClass {};    \n+    \n     @Test\n     public void myTest() throws Exception {\n         SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_MOCKS);\n     public void withAnyPatternArguments() throws Exception {\n         OutputStream out = new ByteArrayOutputStream();\n \n+        //TODO: should not use javax in case it changes\n         SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_MOCKS);\n         when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);\n \n         assertEquals(c, sf.createSocket(\"stackoverflow.com\", 8080).getPort());\n         assertEquals(a, sf.createSocket(\"stackoverflow.com\", 80).getPort());\n     }\n+    \n+    Person person = mock(Person.class, RETURNS_DEEP_MOCKS);\n+       \n+    @Test\n+    public void shouldStubbingBasicallyWorkFine() throws Exception {\n+        //given\n+        given(person.getAddress().getStreet().getName()).willReturn(\"Norymberska\");\n+        \n+        //when\n+        String street = person.getAddress().getStreet().getName();\n+        \n+        //then\n+        assertEquals(\"Norymberska\", street);\n+    }    \n+    \n+    @Test\n+    public void shouldVerificationBasicallyWorkFine() throws Exception {\n+        //given\n+        person.getAddress().getStreet().getName();\n+        \n+        //then\n+        verify(person.getAddress().getStreet()).getName();\n+    }   \n+    \n+    @Test\n+    public void shouldFailGracefullyWhenClassIsFinal() throws Exception {\n+        //when        \n+        FinalClass value = new FinalClass();\n+        given(person.getFinalClass()).willReturn(value);\n+        \n+        //then\n+        assertEquals(value, person.getFinalClass());\n+    }\n }", "timestamp": 1266182809, "metainfo": ""}