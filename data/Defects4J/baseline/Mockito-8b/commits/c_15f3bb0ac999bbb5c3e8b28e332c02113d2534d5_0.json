{"sha": "15f3bb0ac999bbb5c3e8b28e332c02113d2534d5", "log": "moved stubbing to separate class  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40153", "commit": "\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.exceptions.*;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.matchers.*;\n \n public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n     private final MockitoBehavior<T> behavior = new MockitoBehavior<T>();\n-\n+    private final Stubber stubber = new Stubber();\n     private Throwable throwableToBeSetOnVoidMethod;\n     \n     /**\n             ExpectedInvocation invocationWithMatchers = expectedInvocation(proxy, method, args);\n             //TODO this is a bit dodgy, we should set result directly on behavior and behavior should validate exception\n             behavior.addInvocation(invocationWithMatchers);\n+            stubber.setInvocationForPotentialStubbing(invocationWithMatchers);\n             andThrows(throwableToBeSetOnVoidMethod);\n             throwableToBeSetOnVoidMethod = null;\n             return null;\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n         } \n         \n+        stubber.setInvocationForPotentialStubbing(invocationWithMatchers);\n         behavior.addInvocation(invocationWithMatchers);\n \n         MockitoState.instance().reportControlForStubbing(this);\n         \n-        return behavior.resultFor(invocationWithMatchers.getInvocation());\n+        return stubber.resultFor(invocationWithMatchers.getInvocation());\n     }\n \n     private ExpectedInvocation expectedInvocation(Object proxy, Method method, Object[] args) {\n \n     public void andReturn(T value) {\n         MockitoState.instance().stubbingCompleted();\n-        behavior.addResult(Result.createReturnResult(value));\n+        behavior.lastInvocationWasStubbed();\n+        stubber.addReturnValue(value);\n     }\n \n     public void andThrows(Throwable throwable) {\n         MockitoState.instance().stubbingCompleted();\n-        validateThrowable(throwable);\n-        behavior.addResult(Result.createThrowResult(throwable));\n+        behavior.lastInvocationWasStubbed();\n+        stubber.addThrowable(throwable);\n     }\n     \n-    private void validateThrowable(Throwable throwable) {\n-        if (throwable == null) {\n-            Exceptions.cannotStubWithNullThrowable();\n-        }\n-\n-        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n-            return;\n-        }\n-    \n-        if (!isValidCheckedException(throwable)) {\n-            Exceptions.checkedExceptionInvalid(throwable);\n-        }\n-    }\n-\n-    private boolean isValidCheckedException(Throwable throwable) {\n-        //TODO move validation logic to behavior, so that we don't need to expose getInvocationForStubbing()\n-        Invocation lastInvocation = behavior.getInvocationForStubbing().getInvocation();\n-\n-        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n-        Class<?> throwableClass = throwable.getClass();\n-        for (Class<?> exception : exceptions) {\n-            if (exception.isAssignableFrom(throwableClass)) {\n-                return true;\n-            }\n-        }\n-        \n-        return false;\n-    }\n-\n     public MethodSelector<T> toThrow(Throwable throwable) {\n         throwableToBeSetOnVoidMethod = throwable;\n         return this;\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n public class MockitoBehavior<T> {\n \n     private RegisteredInvocations registeredInvocations = new RegisteredInvocations(new AllInvocationsFinder());\n-    private LinkedList<StubbedInvocation> stubbed = new LinkedList<StubbedInvocation>();\n \n     private T mock;\n-    private ExpectedInvocation invocationForStubbing;\n     \n     public void addInvocation(ExpectedInvocation invocation) {\n         this.registeredInvocations.add(invocation.getInvocation());\n-        this.invocationForStubbing = invocation;\n     }\n \n-    public void addResult(Result result) {\n-        assert invocationForStubbing != null;\n-        registeredInvocations.removeLast();\n-        stubbed.addFirst(new StubbedInvocation(invocationForStubbing, result));\n-    }\n-    \n     public void verify(ExpectedInvocation wanted, VerifyingMode mode) {\n         checkOrderOfInvocations(wanted, mode);\n         checkForMissingInvocation(wanted, mode);\n         }\n     }\n     \n-    public Object resultFor(Invocation wanted) throws Throwable {\n-        for (StubbedInvocation s : stubbed) {\n-            if (s.matches(wanted)) {\n-                return s.getResult().answer();\n-            }\n-        }\n-\n-        return ToTypeMappings.emptyReturnValueFor(wanted.getMethod().getReturnType());\n-    }\n-\n     public T getMock() {\n         return mock;\n     }\n         return registeredInvocations.all();\n     }\n \n-    public ExpectedInvocation getInvocationForStubbing() {\n-        return invocationForStubbing;\n+    public void lastInvocationWasStubbed() {\n+        registeredInvocations.removeLast();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/Stubber.java\n+package org.mockito.internal;\n+\n+import java.util.LinkedList;\n+\n+import org.mockito.exceptions.Exceptions;\n+\n+public class Stubber {\n+\n+    private ExpectedInvocation invocationForStubbing;\n+    private LinkedList<StubbedInvocation> stubbed = new LinkedList<StubbedInvocation>();\n+    \n+    public void addReturnValue(Object value) {\n+        addResult(Result.createReturnResult(value));\n+    }\n+    \n+    public void addThrowable(Throwable throwable) {\n+        validateThrowable(throwable);\n+        addResult(Result.createThrowResult(throwable));\n+    }\n+    \n+    private void addResult(Result result) {\n+        assert invocationForStubbing != null;\n+        stubbed.addFirst(new StubbedInvocation(invocationForStubbing, result));\n+    }\n+    \n+    public Object resultFor(Invocation wanted) throws Throwable {\n+        for (StubbedInvocation s : stubbed) {\n+            if (s.matches(wanted)) {\n+                return s.getResult().answer();\n+            }\n+        }\n+\n+        return ToTypeMappings.emptyReturnValueFor(wanted.getMethod().getReturnType());\n+    }\n+    \n+    private void validateThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            Exceptions.cannotStubWithNullThrowable();\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+    \n+        if (!isValidCheckedException(throwable)) {\n+            Exceptions.checkedExceptionInvalid(throwable);\n+        }\n+    }\n+\n+    private boolean isValidCheckedException(Throwable throwable) {\n+        Invocation lastInvocation = invocationForStubbing.getInvocation();\n+\n+        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+\n+    public void setInvocationForPotentialStubbing(ExpectedInvocation invocation) {\n+        this.invocationForStubbing = invocation;\n+    }\n+}", "timestamp": 1197244391, "metainfo": ""}