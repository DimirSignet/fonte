{"sha": "1d9c00310418b8329c5de11835a596d4d83d0a7f", "log": "removed bunch of TODOs, added more sophisticated testing around exception messages  --HG-- rename : src/org/mockito/internal/verification/AtMostXVerificationMode.java => src/org/mockito/internal/verification/AtMost.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40965", "commit": "\n--- a/src/org/mockito/InOrderVerifier.java\n+++ b/src/org/mockito/InOrderVerifier.java\n         if (!mocksToBeVerifiedInOrder.contains(mock)) {\n             reporter.inOrderRequiresFamiliarMock();\n         } else if (!(mode instanceof VerificationInOrderMode)) {\n-            throw new MockitoException(\"VerificationMode is not implmented to work with InOrder\");\n+            throw new MockitoException(mode.getClass().getSimpleName() + \" is not implemented to work with InOrder\");\n         }\n         return Mockito.verify(mock, new InOrderVerificationModeWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));\n     }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import static org.mockito.exceptions.StringJoiner.*;\n \n import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.cause.ActualArgumentsAreDifferent;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n                 method + \" should return \" + expectedType\n                 ));\n     }\n+\n+    public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n+        throw new MockitoAssertionError(join(\"Wanted at most \" + pluralize(maxNumberOfInvocations) + \" but was \" + foundSize));\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/AtMost.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationMode;\n+\n+public class AtMost implements VerificationMode {\n+\n+    private final int maxNumberOfInvocations;\n+\n+    public AtMost(int maxNumberOfInvocations) {\n+        if (maxNumberOfInvocations < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        this.maxNumberOfInvocations = maxNumberOfInvocations;\n+    }\n+\n+    public void verify(VerificationData data) {\n+        List<Invocation> invocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        InvocationsFinder finder = new InvocationsFinder();\n+        List<Invocation> found = finder.findInvocations(invocations, wanted);\n+        int foundSize = found.size();\n+        if (foundSize > maxNumberOfInvocations) {\n+            new Reporter().wantedAtMostX(maxNumberOfInvocations, foundSize);\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n     }\n \n     public static VerificationMode atMost(int maxNumberOfInvocations) {\n-        return new AtMostXVerificationMode(maxNumberOfInvocations);\n+        return new AtMost(maxNumberOfInvocations);\n     }\n }\n--- a/test/org/mockitousage/verification/AtMostXVerificationTest.java\n+++ b/test/org/mockitousage/verification/AtMostXVerificationTest.java\n             verify(mock, atMost(-1)).clear();\n             fail();\n         } catch (MockitoException e) {\n-            //TODO assert message\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n         }\n     }\n     \n             verify(mock, atMost(1)).clear();\n             fail();\n         } catch (MockitoAssertionError e) {\n-            //TODO assert message\n+            assertEquals(\"\\nWanted at most 1 time but was 2\", e.getMessage());\n         }\n     }\n     \n             inOrder.verify(mock, atMost(1)).clear();\n             fail();\n         } catch (MockitoException e) {\n-            //TODO assert message\n+            assertEquals(\"AtMost is not implemented to work with InOrder\", e.getMessage());\n         }\n     }\n }", "timestamp": 1223979422, "metainfo": ""}