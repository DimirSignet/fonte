{"sha": "7cd8b316815de9a88c34495040272ecfe6f60eea", "log": "refactorings, added some new shiny defensive exceptions  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4031", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n package org.mockito;\n \n import org.mockito.exceptions.MissingMethodInvocationException;\n-import org.mockito.hamcrest.*;\n import org.mockito.internal.*;\n \n+@SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n \n     public static <T> T mock(Class<T> classToMock) {\n //        MockitoState.instance().stubbingStarted();\n         \n         //TODO increment number of stubs\n-        //TODO stub has to be removed from MockitoState.instance().controlToBeStubbed!!!!!!!\n-        MockitoExpectation controlToStub = MockitoState.instance().controlToBeStubbed();\n+        MockitoExpectation controlToStub = MockitoState.instance().removeControlToBeStubbed();\n         if (controlToStub == null) {\n             throw new MissingMethodInvocationException();\n         }\n     }\n     \n     public static <T> T verify(T mock, int exactNumberOfInvocations) {\n-        //TODO validate mock everywhere\n-        //TODO validate if there is unfinished stubbing\n+        MockUtil.validateMock(mock);\n         MockitoState.instance().verifyingStarted(VerifyingMode.times(exactNumberOfInvocations));\n         return mock;\n     }\n \n \tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n+\t    MockitoState.instance().checkForUnfinishedVerification();\n \t    for (Object mock : mocks) {\n             MockUtil.getControl(mock).verifyNoMoreInteractions();\n         }\n     }\n     \n     public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n-        //TODO validate mock\n //        MockitoState.instance().reportControlForStubbing(mockitoControl)\n         return MockUtil.getControl(mock);\n     }\n-\n-    public static <T> T assertInvoked(T mock) {\n-        return verify(mock);\n-    }\n-\n-    public static <T> T assertInvoked(T mock, int exactNumberOfInvocations) {\n-        return verify(mock, exactNumberOfInvocations);\n-    }\n-    \n-    public static void assertNoMoreInteractions(Object ... mocks) {\n-        verifyNoMoreInteractions(mocks);   \n-    }\n-\n-    public static void assertZeroInteractions(Object ... mocks) {\n-        verifyZeroInteractions(mocks);   \n-    }\n-\n-    public static <T> T assertThat(MockitoMatcher<T> matcher) {\n-        return verify(matcher.getMock());\n-    }\n-    \n-    public static <T> MockitoMatcher<T> wasInvoked(T mock) {\n-        return new WasInvokedMatcher<T>(mock);\n-    }\n-    \n-    public static <T> MockitoMatcher<T> wasInvoked(T mock, int exactNumberOfInvocations) {\n-        return new WasInvokedMatcher<T>(mock, exactNumberOfInvocations);\n-    }\n-    \n-    public static <T> MockitoMatcher<T> noMoreInteractions(T mock) {\n-        return new HasNoMoreIvocationsMatcher<T>(mock);\n-    }\n-    \n-    public static <T> MockitoMatcher<T> zeroInteractions(T mock) {\n-        return new HasNoIvocationsMatcher<T>(mock);\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/MockitoExperimental.java\n+package org.mockito;\n+\n+import org.mockito.hamcrest.*;\n+\n+/**\n+ * experimental assert-like syntax\n+ * \n+ * @author Szczepan Faber\n+ */\n+public class MockitoExperimental extends Mockito {\n+\n+    public static <T> T assertInvoked(T mock) {\n+        return verify(mock);\n+    }\n+\n+    public static <T> T assertInvoked(T mock, int exactNumberOfInvocations) {\n+        return verify(mock, exactNumberOfInvocations);\n+    }\n+    \n+    public static void assertNoMoreInteractions(Object ... mocks) {\n+        verifyNoMoreInteractions(mocks);   \n+    }\n+\n+    public static void assertZeroInteractions(Object ... mocks) {\n+        verifyZeroInteractions(mocks);   \n+    }\n+\n+    public static <T> T assertThat(MockitoMatcher<T> matcher) {\n+        return verify(matcher.getMock());\n+    }\n+    \n+    public static <T> MockitoMatcher<T> wasInvoked(T mock) {\n+        return new WasInvokedMatcher<T>(mock);\n+    }\n+    \n+    public static <T> MockitoMatcher<T> wasInvoked(T mock, int exactNumberOfInvocations) {\n+        return new WasInvokedMatcher<T>(mock, exactNumberOfInvocations);\n+    }\n+    \n+    public static <T> MockitoMatcher<T> noMoreInteractions(T mock) {\n+        return new HasNoMoreIvocationsMatcher<T>(mock);\n+    }\n+    \n+    public static <T> MockitoMatcher<T> zeroInteractions(T mock) {\n+        return new HasNoIvocationsMatcher<T>(mock);\n+    }\n+}\n--- a/src/org/mockito/exceptions/InvalidUseOfMatchersException.java\n+++ b/src/org/mockito/exceptions/InvalidUseOfMatchersException.java\n \n public class InvalidUseOfMatchersException extends IllegalStateException {\n \n+    private static final long serialVersionUID = 1L;\n+\n     public InvalidUseOfMatchersException(String message) {\n         super(  \"\\n\" +\n-                \"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n-        \t\t\"\\n\" +\n-                message);\n+                message +\n+                \"\\n\" +\n+                \"Read about matchers: http://code.google.com/p/mockito/matchers\");\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/UnfinishedVerificationException.java\n+package org.mockito.exceptions;\n+\n+public class UnfinishedVerificationException extends RuntimeException {\n+    \n+    public UnfinishedVerificationException() {\n+        super(  \"\\n\" +\n+        \t\t\"Previous verify(mock) doesn't have a method call.\" +\n+        \t\t\"\\n\" +\n+        \t\t\"Should be something like that: verify(mock).doSomething()\");\n+    }\n+}\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n     \n     @SuppressWarnings(\"unchecked\")\n     public static <T> MockitoControl<T> getControl(T mock) {\n+        if (mock == null) {\n+            throw new IllegalArgumentException(\"Mock cannot be null\");\n+        }\n+        \n         MockitoObjectMethodsFilter<MockitoControl<T>> handler;\n \n         try {\n--- a/src/org/mockito/internal/MockitoControl.java\n+++ b/src/org/mockito/internal/MockitoControl.java\n         List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n         InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, processedMatchers);\n         \n-        if (mockitoState.mockVerificationScenario()) {\n+        if (mockitoState.verificationScenario()) {\n             VerifyingMode verifyingMode = mockitoState.verifyingCompleted();\n \n             //have to validate matcher after verifyingMode flag is cleared - a bit smelly\n //            mockitoState.stubbingCompleted();\n //        }\n         \n-        mockitoState.reportLastControlForStubbing(this);\n+        mockitoState.reportLastControl(this);\n         \n         behavior.addInvocation(invocationWithMatchers);\n         \n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n package org.mockito.internal;\n+\n+import org.mockito.exceptions.UnfinishedVerificationException;\n \n /**\n  * state. therefore dangerous and may have nasty bugs.\n  * \n  * @author sfaber\n  */\n+@SuppressWarnings(\"unchecked\")\n public class MockitoState {\n     \n     static MockitoState INSTANCE = new MockitoState();\n     private final ThreadLocal<MockitoControl> controlForStubbing = new ThreadLocal<MockitoControl>();\n     private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n     private final ThreadLocal<Throwable> throwableToBeSetOnVoidMethod = new ThreadLocal<Throwable>();\n-    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n+//    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n \n     MockitoState() {}\n     \n         return INSTANCE;\n     }\n     \n-    public synchronized void reportLastControlForStubbing(MockitoControl mockitoControl) {\n+    public synchronized void reportLastControl(MockitoControl mockitoControl) {\n         controlForStubbing.set(mockitoControl);\n     }\n \n-    public synchronized MockitoExpectation controlToBeStubbed() {\n-        return controlForStubbing.get();\n+    public synchronized MockitoExpectation removeControlToBeStubbed() {\n+        MockitoControl control = controlForStubbing.get();\n+        controlForStubbing.set(null);\n+        return control;\n     }\n     \n     public synchronized void verifyingStarted(VerifyingMode verify) {\n+        checkForUnfinishedVerification();\n         verifyingModeLocal.set(verify);\n     }\n \n-    public synchronized boolean mockVerificationScenario() {\n+    public void checkForUnfinishedVerification() {\n+        if (verifyingModeLocal.get() != null) {\n+            throw new UnfinishedVerificationException();\n+        }\n+    }\n+\n+    public synchronized boolean verificationScenario() {\n         return verifyingModeLocal.get() != null; \n     }\n \n         return verifyingMode;\n     }\n \n-    public void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n+    public synchronized void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n         throwableToBeSetOnVoidMethod.set(throwable);\n     }\n \n-    public Throwable removeThrowableToBeSetOnVoidMethod() {\n+    public synchronized Throwable removeThrowableToBeSetOnVoidMethod() {\n         Throwable throwable = throwableToBeSetOnVoidMethod.get();\n         throwableToBeSetOnVoidMethod.set(null);\n         return throwable;\n     }\n \n-    public boolean settingThrowableOnVoidMethodScenario() {\n+    public synchronized boolean settingThrowableOnVoidMethodScenario() {\n         return throwableToBeSetOnVoidMethod.get() != null; \n+    }\n+\n+    public void validate() {\n+        // TODO Auto-generated method stub\n     }\n \n //    public void stubbingStarted() {\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n         getControl(\"\");\n     }\n     \n+    @Test (expected=IllegalArgumentException.class)\n+    public void shouldScreamWhenNullPassed() {\n+        getControl(null);\n+    }\n+    \n     @Test (expected=NotAMockException.class)\n     public void shouldValidateMock() {\n         validateMock(\"\");\n     }\n+    \n+    @Test (expected=IllegalArgumentException.class)\n+    public void shouldScreamWhenNullPassedToValidation() {\n+        validateMock(null);\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/MockitoTest.java\n+package org.mockito;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoTest {\n+\n+    private String notMock;\n+    private List mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = mock(List.class);\n+        notMock = \"i'm not a notMock\";\n+        StateResetter.reset();\n+    }\n+    \n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Test\n+    public void shouldRemoveStubbedControlFromStateWhenStubbing() {\n+        List mock = Mockito.mock(List.class);\n+        Mockito.stub(mock.add(\"test\")).andReturn(true);\n+        \n+        assertNull(MockitoState.instance().removeControlToBeStubbed());\n+    }\n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldValidateMockWhenVerifying() {\n+        Mockito.verify(notMock);\n+    }\n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldValidateMockWhenVerifyingWithExactNumberOfInvocations() {\n+        Mockito.verify(notMock, 19);\n+    }\n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldValidateMockWhenVerifyingNoMoreInteractions() {\n+        Mockito.verifyNoMoreInteractions(notMock);\n+    }\n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldValidateMockWhenVerifyingZeroInteractions() {\n+        Mockito.verifyZeroInteractions(notMock);\n+    }\n+    \n+    @Test(expected=NotAMockException.class)\n+    public void shouldValidateMockWhenStubbingVoid() {\n+        Mockito.stubVoid(notMock);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerification() {\n+        verify(mock);\n+        try {\n+            verify(mock).get(0);\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerificationWhenVeryfingNoMoreInteractions() {\n+        verify(mock);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerificationWhenVeryfingZeroInteractions() {\n+        verify(mock);\n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n+    }\n+}\n--- a/test/org/mockito/internal/MockitoControlTest.java\n+++ b/test/org/mockito/internal/MockitoControlTest.java\n         } catch (InvalidUseOfMatchersException e) {\n         }\n         \n-        assertFalse(state.mockVerificationScenario());\n+        assertFalse(state.verificationScenario());\n     }\n }\n--- a/test/org/mockito/internal/MockitoStateTest.java\n+++ b/test/org/mockito/internal/MockitoStateTest.java\n import static org.junit.Assert.*;\n \n import org.junit.*;\n-import org.mockito.internal.*;\n+import org.mockito.exceptions.UnfinishedVerificationException;\n \n public class MockitoStateTest {\n \n     \n     @Test\n     public void shouldSwitchVerifyingMode() throws Exception {\n+        assertFalse(mockitoState.verificationScenario());\n+        \n+        VerifyingMode mode = VerifyingMode.times(19);\n+        \n+        mockitoState.verifyingStarted(mode);\n+        \n+        assertTrue(mockitoState.verificationScenario());\n+        \n+        assertSame(mode, mockitoState.verifyingCompleted());\n+    }\n+    \n+    @Test\n+    public void shouldCheckIfVerificationWasFinished() throws Exception {\n         mockitoState.verifyingStarted(VerifyingMode.anyTimes());\n-        \n-        assertTrue(mockitoState.mockVerificationScenario());\n-        \n-        mockitoState.verifyingStarted(null);\n-        \n-        assertFalse(mockitoState.mockVerificationScenario());\n-        \n-        mockitoState.verifyingStarted(VerifyingMode.times(100));\n-        \n-        assertTrue(mockitoState.mockVerificationScenario());\n-        \n-        assertEquals(100, mockitoState.verifyingCompleted().getExactNumberOfInvocations());\n-        \n-        assertFalse(mockitoState.mockVerificationScenario());\n+        try {\n+            mockitoState.verifyingStarted(VerifyingMode.anyTimes());\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n     }\n }\n--- a/test/org/mockito/usage/MockitoExploitsTest.java\n+++ b/test/org/mockito/usage/MockitoExploitsTest.java\n package org.mockito.usage;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.fail;\n import static org.mockito.Mockito.*;\n \n import java.util.List;\n \n import org.junit.*;\n-import org.mockito.Mockito;\n import org.mockito.exceptions.*;\n-import org.mockito.internal.*;\n+import org.mockito.internal.StateResetter;\n \n-/**\n- * TODO find out what is important to protect ourselves and what's just too defensive \n- */\n @SuppressWarnings(\"unchecked\")\n public class MockitoExploitsTest {\n     \n     }\n     \n     @Test\n-    public void rubbishPassedToStubMethod() {\n+    public void shouldDetectStubbingWithoutMethodCallOnMock() {\n         try {\n             stub(\"blah\".contains(\"blah\"));\n             fail();\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (UnfinishedStubbingException e) {\n-            //cool\n-        }\n+        } catch (UnfinishedStubbingException e) {}\n     }\n     \n     @Ignore\n         try {\n             stub(mock.add(\"test\")).andThrows(new Exception(\"ssdf\"));\n             fail();\n-        } catch (UnfinishedStubbingException e) {\n-            //cool\n-        }\n+        } catch (UnfinishedStubbingException e) {}\n     }\n     \n     @Ignore\n     @Test\n-    public void rubbishPassedToStubMethodButThereIsAlreadyMethodCalledOnTheMock() {\n+    public void unfinishedStubbingDetectedMockCalled() {\n         List mock = mock(List.class);\n         \n-        mock.add(\"test\");\n+        stub(mock.add(\"test\"));\n         \n-        stub(\"blah\".contains(\"blah\")).andReturn(Boolean.TRUE);\n-        \n-        assertFalse(mock.add(\"test\"));\n-    }\n-    \n-    @Ignore\n-    @Test\n-    public void rubbishPassedToStubMethodAndThrowableSet() {\n-        List mock = mock(List.class);\n         try {\n-            stub(\"asdf\".charAt(1)).andThrows(new RuntimeException());\n+            mock.clear();\n             fail();\n-        } catch (Exception e) {\n-            //cool\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldLetVerifyOnlyMocks() throws Exception {\n-        try {\n-            Mockito.verify(\"not a mock\");\n-            fail();\n-        } catch (NotAMockException e) {\n-            //cool\n-        }\n+        } catch (UnfinishedStubbingException e) {}\n     }\n }\n--- a/test/org/mockito/usage/MockitoSyntaxExperiments.java\n+++ b/test/org/mockito/usage/MockitoSyntaxExperiments.java\n package org.mockito.usage;\n \n-import static org.mockito.Mockito.*;\n-\n import java.util.List;\n-\n-import org.mockito.Mockito;\n+import static org.mockito.MockitoExperimental.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoSyntaxExperiments {\n         //use it\n         mock.add(2, \"test2\");\n \n-        Mockito.verify(mock).add(2, \"test2\");\n-        Mockito.verify(mock, 5).add(2, \"test2\");\n+        verify(mock).add(2, \"test2\");\n+        verify(mock, 5).add(2, \"test2\");\n             //or\n-//            Mockito.verify(mock).times(5).add(2, \"test2\");\n-        Mockito.verifyNoMoreInteractions(mock);\n-        Mockito.verifyZeroInteractions(mock);\n+//            verify(mock).times(5).add(2, \"test2\");\n+        verifyNoMoreInteractions(mock);\n+        verifyZeroInteractions(mock);\n     }\n     \n     public void oldSchoolAssertSyntax() {\n         mock.add(2, \"test2\");\n \n         //Second for old style assertions\n-        Mockito.assertInvoked(mock).add(2, \"test2\");\n-        Mockito.assertInvoked(mock, 5).add(2, \"test2\");\n+        assertInvoked(mock).add(2, \"test2\");\n+        assertInvoked(mock, 5).add(2, \"test2\");\n             //or\n-//            Mockito.assertInvoked(mock).times(5).add(2, \"test2\");\n-        Mockito.assertNoMoreInteractions(mock);\n-        Mockito.assertZeroInteractions(mock);\n+//            assertInvoked(mock).times(5).add(2, \"test2\");\n+        assertNoMoreInteractions(mock);\n+        assertZeroInteractions(mock);\n     }\n     \n     public void shinyNewAssertThatSyntax() {\n         //use it\n         mock.add(2, \"test2\");\n         \n-        Mockito.assertThat(wasInvoked(mock)).add(2, \"test2\");\n-        Mockito.assertThat(wasInvoked(mock, 5)).add(2, \"test2\");\n-        Mockito.assertThat(noMoreInteractions(mock));\n-        Mockito.assertThat(zeroInteractions(mock));\n+        assertThat(wasInvoked(mock)).add(2, \"test2\");\n+        assertThat(wasInvoked(mock, 5)).add(2, \"test2\");\n+        assertThat(noMoreInteractions(mock));\n+        assertThat(zeroInteractions(mock));\n     }\n     \n     public void verifiesMocksInOrder() {\n-//        Mockito.verifyInOrder(new Ordering() { void sequence() {\n-//            Mockito.verify(mock).clear();\n-//            Mockito.verify(mock2).clear();\n+//        verifyInOrder(new Ordering() { void sequence() {\n+//            verify(mock).clear();\n+//            verify(mock2).clear();\n //        }};);\n     }\n }\n--- a/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n import org.junit.*;\n import org.mockito.*;\n import org.mockito.exceptions.InvalidUseOfMatchersException;\n-import org.mockito.internal.MockitoState;\n+import org.mockito.internal.*;\n import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n     \n     @Before\n     public void setUp() {\n+        StateResetter.reset();\n         mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n     }\n \n     @Test\n             mock.simpleMethodWithArgument(CrazyMatchers.not(\"jkl\"));\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n-            assertEquals(\"\\n\" +\n-                    \"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n+            assertEquals(\n                     \"\\n\" +\n-            \t\t\"No matchers found.\", e.getMessage());\n+            \t\t\"No matchers found.\" +\n+            \t\t\"\\n\" +\n+                    \"Read about matchers: http://code.google.com/p/mockito/matchers\"\n+            \t\t, e.getMessage());\n         }\n         \n         try {\n             mock.simpleMethodWithArgument(CrazyMatchers.or(eq(\"jkl\"), \"asd\"));\n             fail();\n         } catch (IllegalStateException e) {\n-            assertEquals(\"\\n\" +\n-            \t\t\"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n-            \t\t\"\\n\" +\n-            \t\t\"2 matchers expected, 1 recorded.\", e.getMessage());\n+            assertEquals(\n+                    \"\\n\" +\n+            \t\t\"2 matchers expected, 1 recorded.\" +\n+                    \"\\n\" +\n+                    \"Read about matchers: http://code.google.com/p/mockito/matchers\"\n+                    , e.getMessage());\n         }\n         \n         try {\n             mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n             fail();\n         } catch (IllegalStateException e) {\n-            assertEquals(\"\\n\" +\n-                    \"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n+            assertEquals(\n                     \"\\n\" +\n-                    \"3 matchers expected, 1 recorded.\", e.getMessage());\n+                    \"3 matchers expected, 1 recorded.\" +\n+                    \"\\n\" +\n+                    \"Read about matchers: http://code.google.com/p/mockito/matchers\"\n+                    , e.getMessage());\n         }\n     }\n }", "timestamp": 1195346482, "metainfo": ""}