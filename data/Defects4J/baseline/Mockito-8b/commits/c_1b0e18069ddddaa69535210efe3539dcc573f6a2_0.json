{"sha": "1b0e18069ddddaa69535210efe3539dcc573f6a2", "log": "More work on spies to make them true partial mocks  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401406", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"For example:\",\n                 \"    when(mock.getArticles()).thenReturn(articles);\",\n                 \"\",\n-                \"Also, this error might show up because you verify final method, equals() or hashCode() method.\",\n+                \"Also, this error might show up because you stub final/private/equals() or hashCode() method.\",\n                 \"Those methods *cannot* be stubbed/verified.\",\n                 \"\"\n         ));\n                 \"Example of correct verification:\",\n                 \"    verify(mock).doSomething()\",\n                 \"\",\n-                \"Also, this error might show up because you stub a final method, equals() or hashCode() method.\",\n+                \"Also, this error might show up because you verify final/private/equals() or hashCode() method.\",\n                 \"Those methods *cannot* be stubbed/verified.\",\n                 \"\"\n         ));\n                 \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                 \"\",\n                 \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n-                \"Following methods *cannot* be stubbed/verified: final methods, equals() and hashCode().\",                \n+                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode() methods.\",                \n                 \"\"\n                 ));\n     }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         } else if (MockUtil.isMock(instance)) {\n             return returnValues.valueFor(invocation);\n         } else {\n-            return methodProxy.invoke(instance, args);\n+            return methodProxy.invokeSuper(proxy, args);\n         }\n     }\n \n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n         \n         if (optionalInstance != null) {\n             try {\n-                new ShallowCopyTool().copy(optionalInstance, mock);\n+                new ShallowCopyTool().copyToMock(optionalInstance, mock);\n             } catch (UnableToCopyFieldValue e) {\n                 //Ignore - spying should be used only occasionally and if some field cannot be copied then let's be it\n             }\n--- a/src/org/mockito/internal/util/ShallowCopyTool.java\n+++ b/src/org/mockito/internal/util/ShallowCopyTool.java\n package org.mockito.internal.util;\n \n import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n \n public class ShallowCopyTool {\n \n-    public <T> void copy(T from, T to) throws UnableToCopyFieldValue {\n-        Field[] fieldsFrom = from.getClass().getDeclaredFields();\n-        Field[] fieldsTo = to.getClass().getDeclaredFields();\n+    public <T> void copyToMock(T from, T mock) throws UnableToCopyFieldValue {\n+        Class<? extends Object> classFrom = from.getClass();\n+        Class<?> classTo = mock.getClass().getSuperclass();\n+        assert classTo == classFrom : \"Classes must have the same type: class from: \" + classFrom + \", class to: \" + classTo;\n+\n+        Field[] fieldsFrom = classFrom.getDeclaredFields();\n+        Field[] fieldsTo = classTo.getDeclaredFields();\n         assert fieldsFrom.length == fieldsTo.length : \"Objects should be of the same type\";\n \n         for (int i = 0; i < fieldsFrom.length; i++) {\n+            if (Modifier.isStatic(fieldsFrom[i].getModifiers())) {\n+                continue;\n+            }\n             try {\n                 fieldsFrom[i].setAccessible(true);\n                 fieldsTo[i].setAccessible(true);\n                 Object value = fieldsFrom[i].get(from);\n-                fieldsTo[i].set(to, value);\n+                fieldsTo[i].set(mock, value);\n             } catch (Throwable t) {\n+                //TODO: add missing unit test\n                 throw new UnableToCopyFieldValue(\n                         \"Unable to copy value from field: \" + fieldsFrom[i] + \n                         \" to field: \" + fieldsTo[i], t); \n--- a/test/org/mockito/internal/util/ShallowCopyToolTest.java\n+++ b/test/org/mockito/internal/util/ShallowCopyToolTest.java\n package org.mockito.internal.util;\n \n-import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.LinkedList;\n \n import org.junit.Test;\n import org.mockitoutil.TestBase;\n \n-\n+@SuppressWarnings(\"unchecked\")\n public class ShallowCopyToolTest extends TestBase {\n \n     private ShallowCopyTool tool = new ShallowCopyTool();\n     \n     //TODO: inherited fields\n-    class SomeObject {\n-        private int fieldOne = 1;\n-        String fieldTwo = \"2\";\n-        protected Object fieldThree = new Object();\n-        public SomeOtherObject fieldFour = new SomeOtherObject();\n-        final int fieldFive;\n-        public SomeObject(int fieldFiveValue) {\n-            this.fieldFive = fieldFiveValue;\n+    //TODO: if one field fails - should carry on\n+    static class SomeObject {\n+        private static int staticField = 900; \n+        private int privateField = 1;\n+        private transient int privateTransientField = 100;\n+        String defaultField = \"2\";\n+        protected Object protectedField = new Object();\n+        public SomeOtherObject instancePublicField = new SomeOtherObject();\n+        final int finalField;\n+        public SomeObject(int finalField) {\n+            this.finalField = finalField;\n         }\n     }\n     \n-    class SomeOtherObject {}\n+    static class SomeOtherObject {}\n+\n+    private SomeObject first = new SomeObject(100);\n+    private SomeObject second = mock(SomeObject.class);\n+    \n+    @Test\n+    public void shouldShallowCopyBasicFields() throws Exception {\n+        //given\n+        assertEquals(100, first.finalField);\n+        assertNotEquals(100, second.finalField);\n+        \n+        //when\n+        tool.copyToMock(first, second);\n+        \n+        //then\n+        assertEquals(100, second.finalField);\n+    }\n \n     @Test\n-    public void shouldShallowCopy() throws Exception {\n+    public void shouldShallowCopyTransientPrivateFields() throws Exception {\n         //given\n-        SomeObject first = new SomeObject(100);\n-        SomeObject second = new SomeObject(200);\n-        assertEquals(200, second.fieldFive);\n+        first.privateTransientField = 1000;\n+        assertNotEquals(1000, second.privateTransientField);\n         \n         //when\n-        tool.copy(first, second);\n+        tool.copyToMock(first, second);\n         \n         //then\n-        assertEquals(100, second.fieldFive);\n+        assertEquals(1000, second.privateTransientField);\n+    }\n+    \n+    @Test\n+    public void shouldShallowCopyLinkedListIntoMock() throws Exception {\n+        //given\n+        LinkedList from = new LinkedList();\n+        LinkedList to = mock(LinkedList.class);\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then no exception is thrown\n     }\n }\n--- a/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n+++ b/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n \n import static org.mockito.Mockito.*;\n \n+import org.junit.After;\n import org.junit.Ignore;\n import org.junit.Test;\n-import org.mockito.Mock;\n+import org.mockito.Mockito;\n import org.mockitoutil.TestBase;\n \n @Ignore\n @SuppressWarnings(\"unchecked\")\n public class PartialMockingWithSpiesTest extends TestBase {\n \n+    @After\n+    public void validateMockitoUsage() {\n+        Mockito.validateMockitoUsage();\n+    }\n+    \n     class Person {\n-        private final String defaultName = \"Default name\";\n+        private final Name defaultName = new Name(\"Default name\");\n \n         public String getName() {\n-            return guessName();\n+            return guessName().name;\n         }\n \n-        protected String guessName() {\n+        Name guessName() {\n             return defaultName;\n         }\n     }\n+    \n+    class Name {\n+        private final String name;\n \n-    @Mock\n-    Person mock;\n+        public Name(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    Person spy = spy(new Person());\n \n     @Test\n     public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod() {\n         // when\n-        String name = mock.getName();\n+        String name = spy.getName();\n \n         // then\n         assertEquals(\"Default name\", name);\n+    }\n+    \n+    @Test\n+    public void shouldAllowStubbingOfMethodsThatDelegateToOtherMethods() {\n+        // when\n+        when(spy.getName()).thenReturn(\"foo\");\n+        \n+        // then\n+        assertEquals(\"foo\", spy.getName());\n     }\n \n     @Test\n     public void shouldVerify() {\n         // when\n-        mock.getName();\n+        spy.getName();\n \n         // then\n-        verify(mock).guessName();\n+        verify(spy).guessName();\n     }\n \n     @Test\n     public void shouldStub() {\n         // given\n-        when(mock.guessName()).thenReturn(\"John\");\n+        when(spy.guessName()).thenReturn(new Name(\"John\"));\n         // when\n-        String name = mock.getName();\n+        String name = spy.getName();\n         // then\n         assertEquals(\"John\", name);\n     }\n--- a/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n+++ b/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n import java.util.LinkedList;\n import java.util.List;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n import org.mockitoutil.TestBase;\n \n+@Ignore\n @SuppressWarnings(\"unchecked\")\n public class SpyingOnRealObjectsTest extends TestBase {\n \n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n             }\n         };\n     }\n+    \n+    public static void assertNotEquals(Object expected, Object got) {\n+        assertFalse(expected.equals(got));\n+    }\n \n     public static void assertContains(String sub, String string) {\n         assertTrue(\"\\n\" +", "timestamp": 1241384244, "metainfo": ""}