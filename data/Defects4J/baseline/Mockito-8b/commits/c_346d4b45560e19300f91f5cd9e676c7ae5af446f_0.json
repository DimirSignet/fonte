{"sha": "346d4b45560e19300f91f5cd9e676c7ae5af446f", "log": "issue 304 : last implementation found on the issue thread + tests / Captor reinitialization not yet managed. Use TestNG suite configuration : mockito-testng.xml  --HG-- branch : issue 304 : TestNG integration", "commit": "\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n+package org.mockito.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.testng.IInvokedMethod;\n+import org.testng.ITestResult;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class MockitoAfterTestNGMethod {\n+\n+    public void applyFor(IInvokedMethod method, ITestResult testResult) {\n+        Mockito.validateMockitoUsage();\n+\n+        if (method.isTestMethod()) {\n+            resetMocks(testResult.getInstance());\n+        }\n+    }\n+\n+\n+    private void resetMocks(Object instance) {\n+        Mockito.reset(instanceMocksOf(instance).toArray());\n+    }\n+\n+    private Set<Object> instanceMocksOf(Object instance) {\n+        Class<?> testClass = instance.getClass();\n+        Set<Object> instanceMocks = new HashSet<Object>();\n+\n+        for (Class<?> clazz = testClass; clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            instanceMocks.addAll(instanceMocksIn(instance, clazz));\n+        }\n+        return instanceMocks;\n+    }\n+\n+    private Set<Object> instanceMocksIn(Object instance, Class<?> clazz) {\n+        Set<Object> instanceMocks = new HashSet<Object>();\n+        Field[] declaredFields = clazz.getDeclaredFields();\n+        for (Field declaredField : declaredFields) {\n+            if (declaredField.isAnnotationPresent(Mock.class) || declaredField.isAnnotationPresent(Spy.class)) {\n+                declaredField.setAccessible(true);\n+                try {\n+                    Object fieldValue = declaredField.get(instance);\n+                    if (fieldValue != null) {\n+                        instanceMocks.add(fieldValue);\n+                    }\n+                } catch (IllegalAccessException e) {\n+                    throw new MockitoException(\"Could not access field \" + declaredField.getName());\n+                }\n+            }\n+        }\n+        return instanceMocks;\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoBeforeTestNGMethod.java\n+package org.mockito.testng;\n+\n+import org.mockito.MockitoAnnotations;\n+import org.testng.IInvokedMethod;\n+import org.testng.ITestResult;\n+\n+import java.util.WeakHashMap;\n+\n+public class MockitoBeforeTestNGMethod {\n+\n+    private WeakHashMap<Object, Boolean> initializedInstances = new WeakHashMap<Object, Boolean>();\n+\n+    /**\n+     * Initialize mocks.\n+     *\n+     * @param method Invoked method.\n+     * @param testResult TestNG Test Result\n+     */\n+    public void applyFor(IInvokedMethod method, ITestResult testResult) {\n+        initMocks(testResult);\n+        reinitCaptors(method, testResult);\n+    }\n+\n+    private void reinitCaptors(IInvokedMethod method, ITestResult testResult) {\n+        if (method.isConfigurationMethod()) {\n+            return;\n+        }\n+        initializeCaptors(testResult.getInstance());\n+    }\n+\n+    private void initMocks(ITestResult testResult) {\n+        if (alreadyInitialized(testResult.getInstance())) {\n+            return;\n+        }\n+        MockitoAnnotations.initMocks(testResult.getInstance());\n+        markAsInitialized(testResult.getInstance());\n+    }\n+\n+    private void initializeCaptors(Object instance) {\n+        /*\n+         * TODO Refactor #processAnnotationOn methods out of DefaultAnnotationEngine\n+         */\n+    }\n+\n+    private void markAsInitialized(Object instance) {\n+        initializedInstances.put(instance, true);\n+    }\n+\n+    private boolean alreadyInitialized(Object instance) {\n+        return initializedInstances.containsKey(instance);\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoTestNGListener.java\n+package org.mockito.testng;\n+\n+import org.testng.IInvokedMethod;\n+import org.testng.IInvokedMethodListener;\n+import org.testng.ITestNGListener;\n+import org.testng.ITestResult;\n+import org.testng.annotations.Listeners;\n+\n+/**\n+ * Mockito TestNG Listener, this listener adds the following behavior to your test :\n+ * <ul>\n+ *     <li>\n+ *         Initializes mocks annotated with {@link org.mockito.Mock}, so that <strong>explicit usage of\n+ *         {@link org.mockito.MockitoAnnotations#initMocks(Object)} is not necessary</strong>.\n+ *         <strong>Note :</strong> With TestNG, mocks are initialized before any TestNG method, either a <em>configuration\n+ *         method</em> (&#064;BeforeMethod, &#064;BeforeClass, etc) or a <em>test</em> method, i.e. mocks are initialized\n+ *         once only once for each test instance.\n+ *     </li>\n+ *     <li>\n+ *         As mocks are initialized only once, they will be reset after each <em>test method</em>.\n+ *         See javadoc {@link org.mockito.Mockito#reset(Object[])}\n+ *     </li>\n+ *     <li>\n+ *         Validates framework usage after each test method. See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ *     </li>\n+ * </ul>\n+ *\n+ * <p>\n+ * The listener is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.\n+ * Explicitly validating framework usage is also optional because it is triggered automatically by Mockito every time you use the framework.\n+ * See javadoc for {@link org.mockito.Mockito#validateMockitoUsage()}.\n+ *\n+ * <p>\n+ * Read more about &#064;Mock annotation in javadoc for {@link org.mockito.MockitoAnnotations}\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ * <b>&#064;Listeners(MockitoTestNGListener.class)</b>\n+ * public class ExampleTest {\n+ *\n+ *     &#064;Mock\n+ *     private List list;\n+ *\n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * </code></pre>\n+ */\n+public class MockitoTestNGListener implements IInvokedMethodListener {\n+\n+    private MockitoBeforeTestNGMethod beforeTest = new MockitoBeforeTestNGMethod();\n+    private MockitoAfterTestNGMethod afterTest = new MockitoAfterTestNGMethod();\n+\n+\n+    public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {\n+        if (hasMockitoTestNGListenerInTestHierarchy(testResult.getTestClass().getRealClass())) {\n+            beforeTest.applyFor(method, testResult);\n+        }\n+    }\n+\n+    public void afterInvocation(IInvokedMethod method, ITestResult testResult) {\n+        if (hasMockitoTestNGListenerInTestHierarchy(testResult.getTestClass().getRealClass())) {\n+            afterTest.applyFor(method, testResult);\n+        }\n+    }\n+\n+    protected boolean hasMockitoTestNGListenerInTestHierarchy(Class<?> testClass) {\n+        for (Class<?> clazz = testClass; clazz != Object.class; clazz = clazz.getSuperclass()) {\n+            if (hasMockitoTestNGListener(clazz)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected boolean hasMockitoTestNGListener(Class<?> clazz) {\n+        Listeners listeners = clazz.getAnnotation(Listeners.class);\n+        if (listeners == null) {\n+            return false;\n+        }\n+\n+        for (Class<? extends ITestNGListener> listenerClass : listeners.value()) {\n+            if (listenerClass() == listenerClass) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected Class<MockitoTestNGListener> listenerClass() {\n+        return MockitoTestNGListener.class;\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/AnnotatedFieldsShouldBeInitializedByMockitoTestNGListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class AnnotatedFieldsShouldBeInitializedByMockitoTestNGListenerTest {\n+\n+    @Mock List list;\n+    @Spy HashMap map;\n+    @InjectMocks SomeType someType;\n+    @Captor ArgumentCaptor<List> captor;\n+\n+    @Test\n+    public void ensure_annotated_fields_are_instantiated() throws Exception {\n+        assertThat(list).isNotNull();\n+        assertThat(map).isNotNull();\n+        assertThat(captor).isNotNull();\n+        assertThat(someType).isNotNull();\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/CaptorAnnotatedFieldShouldBeClearedTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+@Listeners(MockitoTestNGListener.class)\n+@Test(enabled = false, description = \"not yet ready\")\n+public class CaptorAnnotatedFieldShouldBeClearedTest {\n+\n+    @Captor ArgumentCaptor<String> captor;\n+    @Mock List<String> list;\n+\n+    @Test(enabled = false)\n+    public void first_test_method_that_uses_captor() throws Exception {\n+        list.add(\"a\");\n+        list.add(\"b\");\n+\n+        verify(list, times(2)).add(captor.capture());\n+        assertThat(captor.getAllValues()).containsOnly(\"a\", \"b\");\n+    }\n+\n+    @Test(enabled = false)\n+    public void second_test_method_that_uses_captor() throws Exception {\n+        list.add(\"t\");\n+        list.add(\"u\");\n+\n+        verify(list, times(2)).add(captor.capture());\n+        assertThat(captor.getAllValues()).containsOnly(\"t\", \"u\");\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ConfigurationMethodTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class ConfigurationMethodTest {\n+    @Mock private Map map;\n+\n+    @BeforeMethod\n+    public void some_behavior() {\n+        when(map.get(\"the answer to ...\")).thenReturn(42);\n+    }\n+\n+\n+    @Test\n+    public void mocks_should_stay_configured_with_behavior() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/DontResetMocksIfNoListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+public class DontResetMocksIfNoListenerTest {\n+\n+    @Mock private Map map;\n+\n+    @BeforeMethod\n+    public void init_mocks() {\n+        MockitoAnnotations.initMocks(this);\n+        when(map.get(\"the answer to ...\")).thenReturn(42);\n+    }\n+\n+    @Test\n+    public void mock_behavior_not_resetted_1() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+\n+    @Test\n+    public void mock_behavior_not_resetted_2() throws IOException {\n+        assertThat(map.get(\"the answer to ...\")).isEqualTo(42);\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/EnsureMocksAreInitializedBeforeBeforeClassMethodTest.java\n+package org.mockitousage.testng;\n+\n+import org.junit.BeforeClass;\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Observer;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class EnsureMocksAreInitializedBeforeBeforeClassMethodTest {\n+    \n+    @Mock Observer observer;\n+\n+    @BeforeClass\n+    private void make_sure_mock_is_initialized() {\n+        assertThat(observer).isNotNull();\n+    }\n+\n+    @Test\n+    public void dummy_test_see_BeforeClass_code() throws Exception {\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/InitializeChildTestWhenParentHasListenerTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class InitializeChildTestWhenParentHasListenerTest extends ParentTest {\n+\n+    @Mock Map childMockField;\n+\n+    @Test\n+    public void verify_mocks_are_initialized() throws Exception {\n+        assertThat(childMockField).isNotNull();\n+        assertThat(parentMockField).isNotNull();\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/MockFieldsShouldBeResetBetweenTestMethodsTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public class MockFieldsShouldBeResetBetweenTestMethodsTest {\n+    \n+    @Mock List<String> list;\n+    @Spy HashMap hashMap;\n+    @InjectMocks SomeType someType;\n+\n+    @Test\n+    public void behaviour_A_without_infection_from_behaviour_B() throws Exception {\n+        // verify mock is clean\n+        assertThat(list.get(0)).isNull();\n+        verify(list, never()).add(anyString());\n+\n+        // local behaviour A\n+        given(list.get(0)).willReturn(\"A\");\n+        assertThat(list.get(0)).isEqualTo(\"A\");\n+\n+        list.add(\"something else after A\");\n+    }\n+\n+    @Test\n+    public void behaviour_B_without_infection_from_behaviour_A() throws Exception {\n+        // verify mock is clean\n+        assertThat(list.get(0)).isNull();\n+        verify(list, never()).add(anyString());\n+\n+        // local behaviour A\n+        given(list.get(0)).willReturn(\"B\");\n+        assertThat(list.get(0)).isEqualTo(\"B\");\n+\n+        list.add(\"something else after B\");\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ParentTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+\n+import java.util.Map;\n+\n+@Listeners(MockitoTestNGListener.class)\n+public abstract class ParentTest {\n+\n+    @Mock Map parentMockField;\n+\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/ResetMocksInParentTestClassTooTest.java\n+package org.mockitousage.testng;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+public class ResetMocksInParentTestClassTooTest extends ParentTest {\n+\n+    @Test\n+    public void interact_with_parent_mock() throws Exception {\n+        parentMockField.get(\"a\");\n+    }\n+\n+    @Test\n+    public void verify__zero_interaction_with_parent_mock() throws Exception {\n+        verifyZeroInteractions(parentMockField);\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/SomeType.java\n+package org.mockitousage.testng;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class SomeType {\n+    List list;\n+    Map map;\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/TestWithoutListenerShouldNotInitializeAnnotatedFieldsTest.java\n+package org.mockitousage.testng;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class TestWithoutListenerShouldNotInitializeAnnotatedFieldsTest {\n+\n+    @Mock List list;\n+    @Spy Map map;\n+    @InjectMocks SomeType someType;\n+    @Captor ArgumentCaptor<List> captor;\n+\n+    @Test\n+    public void test_not_annotated_by_MockitoTestNGListener_should_not_touch_annotated_fields() throws Exception {\n+        assertThat(list).isNull();\n+        assertThat(map).isNull();\n+        assertThat(captor).isNull();\n+        assertThat(someType).isNull();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseIncorrectAnnotationUsage.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseIncorrectAnnotationUsage {\n+    @Spy Map spy_cant_initialize_interface_fields;\n+    @Test public void dummy_test_method() throws Exception { }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseIncorrectStubbingSyntax.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.PrintStream;\n+\n+import static org.mockito.Matchers.anySet;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseIncorrectStubbingSyntax {\n+\n+    @Test(expectedExceptions = InvalidUseOfMatchersException.class)\n+    public void incorrect_stubbing_syntax_in_test() throws Exception {\n+        mock(PrintStream.class);\n+        anyString();\n+        anySet();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingBecauseWrongStubbingSyntaxInConfigurationMethod.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Matchers.anyString;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingBecauseWrongStubbingSyntaxInConfigurationMethod {\n+\n+    @Mock List list;\n+\n+    // should fail\n+    @BeforeMethod public void some_wrong_stubs() {\n+        anyString();\n+    }\n+\n+\n+    @Test\n+    public void here_to_execute_the_config_method() throws Exception {\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/TestNGShouldFailWhenMockitoListenerFailsTest.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockitousage.testng.utils.FailureRecordingListener;\n+import org.testng.TestNG;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.testng.Assert.assertTrue;\n+\n+@Test(\n+        singleThreaded = true,\n+        description = \"Test that failing tests report a Mockito exception\"\n+)\n+public class TestNGShouldFailWhenMockitoListenerFailsTest {\n+\n+    private final FailureRecordingListener failureRecorder = new FailureRecordingListener();\n+\n+    public void report_failure_on_incorrect_annotation_usage() throws Throwable {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectAnnotationUsage.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(MockitoException.class);\n+    }\n+\n+    @Test\n+    public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_test_methods() throws Exception {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectStubbingSyntax.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(InvalidUseOfMatchersException.class);\n+    }\n+\n+\n+    @Test\n+    public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_configuration_methods() throws Exception {\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseWrongStubbingSyntaxInConfigurationMethod.class);\n+\n+        testNG.run();\n+\n+        assertTrue(testNG.hasFailure());\n+        assertThat(failureRecorder.lastThrowable()).isInstanceOf(InvalidUseOfMatchersException.class);\n+    }\n+\n+    @AfterMethod\n+    public void clear_failure_recorder() throws Exception {\n+        failureRecorder.clear();\n+    }\n+\n+\n+    private TestNG new_TestNG_with_failure_recorder_for(Class<?>... testNGClasses) {\n+        TestNG testNG = new TestNG();\n+        testNG.setVerbose(0);\n+        testNG.setUseDefaultListeners(false);\n+        testNG.addListener(failureRecorder);\n+\n+        testNG.setTestClasses(testNGClasses);\n+        return testNG;\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/utils/FailureRecordingListener.java\n+package org.mockitousage.testng.utils;\n+\n+import org.testng.IConfigurationListener;\n+import org.testng.ITestContext;\n+import org.testng.ITestListener;\n+import org.testng.ITestResult;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * <strong>Not thread-safe</strong> listener that record only failures, either on the test or on a configuration method.\n+ */\n+public class FailureRecordingListener implements ITestListener, IConfigurationListener {\n+\n+    public List<ITestResult> failedTestResults = new ArrayList<ITestResult>();\n+\n+    public void onTestFailure(ITestResult result) {\n+        failedTestResults.add(result);\n+    }\n+\n+    public void onConfigurationFailure(ITestResult result) {\n+        failedTestResults.add(result);\n+    }\n+\n+    public Throwable lastThrowable() {\n+        ListIterator<ITestResult> iterator = failedTestResults.listIterator(failedTestResults.size());\n+        return iterator.hasPrevious() ? iterator.previous().getThrowable() : null;\n+    }\n+\n+    public void clear() {\n+        failedTestResults.clear();\n+    }\n+\n+    // don't care bellow\n+\n+\n+    public void onConfigurationSuccess(ITestResult itr) { }\n+    public void onConfigurationSkip(ITestResult itr) { }\n+    public void onTestStart(ITestResult result) { }\n+    public void onTestSuccess(ITestResult result) { }\n+    public void onTestSkipped(ITestResult result) { }\n+    public void onTestFailedButWithinSuccessPercentage(ITestResult result) { }\n+    public void onStart(ITestContext context) { }\n+    public void onFinish(ITestContext context) { }\n+}", "timestamp": 1331138513, "metainfo": ""}