{"sha": "cae6a7b1fcf8adf0950d187543cf12758382b51f", "log": "issue 213 : Add method to return mock instance on OngoingStubbing", "commit": "\n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n          * See original {@link OngoingStubbing#thenCallRealMethod()}\n          */\n         BDDMyOngoingStubbing<T> willCallRealMethod();\n+\n+        <M> M getMock();\n     }\n     \n     public static class BDDOngoingStubbingImpl<T> implements BDDMyOngoingStubbing<T> {\n \n         public BDDMyOngoingStubbing<T> willCallRealMethod() {\n             return new BDDOngoingStubbingImpl<T>(mockitoOngoingStubbing.thenCallRealMethod());\n+        }\n+\n+        public <M> M getMock() {\n+            return (M) mockitoOngoingStubbing.getMock();\n         }\n     }\n     \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal;\n-\n-import java.util.List;\n \n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.InvocationContainer;\n-import org.mockito.internal.stubbing.InvocationContainerImpl;\n-import org.mockito.internal.stubbing.OngoingStubbingImpl;\n-import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n+import org.mockito.internal.stubbing.*;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n \n /**\n  * Invocation handler set on mock objects.\n                 mockingProgress.verificationStarted(verificationMode);\n             }\n         }\n-        \n+\n+        // prepare invocation for stubbing\n         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n         OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n         mockingProgress.reportOngoingStubbing(ongoingStubbing);\n \n+        // look for existing answer for this invocation\n         StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n \n         if (stubbedInvocation != null) {\n--- a/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java\n+++ b/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java\n         invocationContainerImpl.addConsecutiveAnswer(answer);\n         return this;\n     }\n+\n+    public <M> M getMock() {\n+        return (M) invocationContainerImpl.invokedMock();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.LinkedList;\n-import java.util.List;\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.stubbing.answers.AnswersValidator;\n import org.mockito.internal.verification.RegisteredInvocations;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationContainerImpl implements InvocationContainer, Serializable {\n     public List<StubbedInvocationMatcher> getStubbedInvocations() {\n         return stubbed;\n     }\n+\n+    public Object invokedMock() {\n+        return invocationForStubbing.getInvocation().getMock();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n         //TODO interface for tests\n         return invocationContainerImpl.getInvocations();\n     }\n+\n+    public <M> M getMock() {\n+        return (M) invocationContainerImpl.invokedMock();\n+    }\n }\n--- a/src/org/mockito/stubbing/OngoingStubbing.java\n+++ b/src/org/mockito/stubbing/OngoingStubbing.java\n      */\n     OngoingStubbing<T> thenAnswer(Answer<?> answer);\n \n+    /**\n+     * Returns the mock that was used for this stub.\n+     *\n+     * @param <M> The mock type given by the variable type.\n+     * @return Mock used in this ongoing stubbing.\n+     */\n+    <M> M getMock();\n }\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n import org.mockito.internal.stubbing.answers.Returns;\n \n import java.util.LinkedList;\n-import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n \n /**\n  * Author: Szczepan Faber\n             throw exceptions.getFirst();\n         }\n     }\n+\n+    @Test\n+    public void shouldReturnInvokedMock() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+\n+        assertEquals(invocation.getMock(), container.invokedMock());\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MockAccessTest.java\n+package org.mockitousage.basicapi;\n+\n+\n+import org.junit.Test;\n+\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class MockAccessTest {\n+\n+    @Test\n+    public void shouldAllowStubbedMockReferenceAccess() throws Exception {\n+        Set expectedMock = mock(Set.class);\n+\n+        Set returnedMock = when(expectedMock.isEmpty()).thenReturn(false).getMock();\n+\n+        assertEquals(expectedMock, returnedMock);\n+    }\n+\n+    @Test\n+    public void stubbedMockShouldWorkAsUsual() throws Exception {\n+        Set returnedMock = when(mock(Set.class).isEmpty()).thenReturn(false, true).getMock();\n+\n+        assertEquals(false, returnedMock.isEmpty());\n+        assertEquals(true, returnedMock.isEmpty());\n+    }\n+}\n--- a/test/org/mockitousage/basicapi/MocksCreationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksCreationTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.basicapi;\n-\n-import static org.hamcrest.CoreMatchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.SmartNullPointerException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.mockito.Mockito.*;\n \n @SuppressWarnings(\"unchecked\")\n public class MocksCreationTest extends TestBase {\n         List list = new LinkedList();\n         mock(LinkedList.class, withSettings().spiedInstance(list));\n     }\n+\n+    @Test\n+    public void shouldAllowInlineMockCreation() throws Exception {\n+        when(mock(Set.class).isEmpty()).thenReturn(false);\n+    }\n+\n }\n--- a/test/org/mockitousage/customization/BDDMockitoTest.java\n+++ b/test/org/mockitousage/customization/BDDMockitoTest.java\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.Set;\n \n import static org.mockito.BDDMockito.*;\n \n         //then\n         assertEquals(\"woof\", dog.bark());\n     }\n+\n+    @Test\n+    public void shouldAllStubbedMockReferenceAccess() throws Exception {\n+        Set expectedMock = mock(Set.class);\n+\n+        Set returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();\n+\n+        assertEquals(expectedMock, returnedMock);\n+    }\n }", "timestamp": 1297454526, "metainfo": ""}