{"sha": "330b915ba0233c35857db622bc4d4bf073fef1a9", "log": "added simple classes that could be run outside the test suite to demonstrate the ability to serialize a mock and deserialize it in another VM", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n  */\n package org.mockito.internal.creation;\n \n+import org.mockito.Incubating;\n import org.mockito.cglib.proxy.Factory;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.util.MockUtil;\n  * @author Brice Dutheil\n  * @since 1.9.6\n  */\n+@Incubating\n public class AcrossJVMSerializationFeature implements Serializable {\n     private static final long serialVersionUID = 7411152578314420778L;\n     private boolean instanceLocalCurrentlySerializingFlag = false;\n \n                 return deserializedMock;\n             } catch (IOException ioe) {\n-                throw new InvalidObjectException(\"For some reason mock cannot ve dematerialized : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n+                throw new InvalidObjectException(\"For some reason mock cannot be deserialized : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n             } catch (ClassNotFoundException cce) {\n                 throw new InvalidObjectException(\"For some reason Mockito Mock class cannot be found : \" + cce.toString());\n             }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n     private static Set<Class> prepareExtraInterfaces(CreationSettings settings) {\n         Set<Class> interfaces = new HashSet<Class>(settings.getExtraInterfaces());\n+//        interfaces.add(MockitoMock.class);\n         if(settings.isSerializable()) {\n             interfaces.add(Serializable.class);\n         }\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/DeserializeMockFromFile.java\n+package org.mockitousage.serialization;\n+\n+import org.mockito.Mockito;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.Observable;\n+\n+/**\n+ * These classes are here purely to show that mocks can be serialized in a different VM\n+ *\n+ * Just run as standalone app {@link SerializeMockToFile}, then {@link DeserializeMockFromFile}\n+ */\n+\n+public class DeserializeMockFromFile {\n+\n+    public static void main(String[] args) {\n+        Observable o = (Observable) deSerializeObject(\"mockito_mock.ser\");\n+\n+        // then verify\n+        Mockito.verify(o).addObserver(null);\n+        Mockito.verify(o).countObservers();\n+    }\n+\n+    private static Object deSerializeObject(String filename) {\n+        InputStream is = null;\n+        ObjectInputStream ois = null;\n+        Object returnObject = null;\n+        try {\n+\n+            is = new BufferedInputStream(new FileInputStream(filename));\n+            ois = new ObjectInputStream(is);\n+            returnObject = ois.readObject();\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (is != null)\n+                    is.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try {\n+                if (ois != null)\n+                    ois.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return returnObject;\n+    }\n+   \n+}\n+\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/SerializeMockToFile.java\n+package org.mockitousage.serialization;\n+\n+import org.mockito.Mockito;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Observable;\n+\n+/**\n+ * These classes are here purely to show that mocks can be serialized in a different VM\n+ *\n+ * Just run as standalone app {@link SerializeMockToFile}, then {@link DeserializeMockFromFile}\n+ */\n+public class SerializeMockToFile {\n+\n+    public static void main(String[] args) {\n+       \n+        Observable observable = Mockito.mock(\n+                Observable.class,\n+                Mockito.withSettings().serializable()\n+        );\n+\n+        // play with mock\n+        observable.addObserver(null);\n+        observable.countObservers();\n+\n+        // serialize to file\n+        serializeMock(observable, \"mockito_mock.ser\");\n+    }\n+\n+    private static void serializeMock(Object obj, String filename) {\n+        OutputStream os = null;\n+        ObjectOutputStream oos = null;\n+\n+        try {\n+            os = new BufferedOutputStream(new FileOutputStream(filename, false));\n+            oos = new ObjectOutputStream(os);\n+\n+            oos.writeObject(obj);\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (os != null) os.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try {\n+                if (oos != null) oos.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+    }\n+\n+    private static class DefaultMethodInterceptor implements MethodInterceptor, Serializable {\n+        private static final long serialVersionUID = 6606245777399406255L;\n+\n+        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n+            return methodProxy.invokeSuper(o, objects);\n+        }\n+    }\n+}", "timestamp": 1355620654, "metainfo": ""}