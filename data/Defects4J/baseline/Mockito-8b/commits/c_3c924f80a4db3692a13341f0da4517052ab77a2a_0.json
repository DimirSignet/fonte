{"sha": "3c924f80a4db3692a13341f0da4517052ab77a2a", "log": "printing args on smart nulls NullPointerException message (Issue #225)", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n  */\n package org.mockito.exceptions;\n \n-import static org.mockito.exceptions.Pluralizer.*;\n-import static org.mockito.internal.util.StringJoiner.*;\n+import static org.mockito.exceptions.Pluralizer.pluralize;\n+import static org.mockito.internal.util.StringJoiner.join;\n \n import java.util.List;\n \n                 ));\n \n     }\n-    \n+\n     public void unfinishedStubbing(Location location) {\n         throw new UnfinishedStubbingException(join(\n                 \"Unfinished stubbing detected here:\",\n                 \"Those methods *cannot* be stubbed/verified.\",\n                 \"\"\n         ));\n-        \n+\n         throw exception;\n     }\n-    \n+\n     public void notAMockPassedToVerify(Class type) {\n         throw new NotAMockException(join(\n                 \"Argument passed to verify() is of type \" + type.getSimpleName() + \" and is not a mock!\",\n                 \"    verify(mock, atLeastOnce()).someMethod();\"\n         ));\n     }\n-    \n+\n     public void nullPassedToVerify() {\n         throw new NullInsteadOfMockException(join(\n                 \"Argument passed to verify() should be a mock but is null!\",\n                 \"    verify(mock, atLeastOnce()).someMethod();\",\n                 \"Also, if you use @Mock annotation don't miss initMocks()\"\n         ));\n-    }    \n-    \n+    }\n+\n     public void notAMockPassedToWhenMethod() {\n         throw new NotAMockException(join(\n                 \"Argument passed to when() is not a mock!\",\n                 \"    doThrow(new RuntimeException()).when(mock).someMethod();\"\n         ));\n     }\n-    \n+\n     public void nullPassedToWhenMethod() {\n         throw new NullInsteadOfMockException(join(\n                 \"Argument passed to when() is null!\",\n                 \"Example of correct stubbing:\",\n-                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",                \n+                \"    doThrow(new RuntimeException()).when(mock).someMethod();\",\n                 \"Also, if you use @Mock annotation don't miss initMocks()\"\n         ));\n     }\n-    \n+\n     public void mocksHaveToBePassedToVerifyNoMoreInteractions() {\n         throw new MockitoException(join(\n                 \"Method requires argument(s)!\",\n             \"    verifyZeroInteractions(mockOne, mockTwo);\"\n         ));\n     }\n-    \n+\n     public void nullPassedToVerifyNoMoreInteractions() {\n         throw new NullInsteadOfMockException(join(\n                 \"Argument(s) passed is null!\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                 ));\n-    } \n-    \n+    }\n+\n     public void nullPassedWhenCreatingInOrder() {\n         throw new NullInsteadOfMockException(join(\n                 \"Argument(s) passed is null!\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                 ));\n     }\n-    \n+\n     public void mocksHaveToBePassedWhenCreatingInOrder() {\n         throw new MockitoException(join(\n                 \"Method requires argument(s)!\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                 ));\n     }\n-    \n+\n     public void inOrderRequiresFamiliarMock() {\n         throw new MockitoException(join(\n                 \"InOrder can only verify mocks that were passed in during creation of InOrder.\",\n                 \"    inOrder.verify(mockOne).doStuff();\"\n                 ));\n     }\n-    \n+\n     public void invalidUseOfMatchers(int expectedMatchersCount, int recordedMatchersCount) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Invalid use of argument matchers!\",\n                 expectedMatchersCount + \" matchers expected, \" + recordedMatchersCount + \" recorded.\",\n-                \"This exception may occur if matchers are combined with raw values:\",        \n+                \"This exception may occur if matchers are combined with raw values:\",\n                 \"    //incorrect:\",\n                 \"    someMethod(anyObject(), \\\"raw String\\\");\",\n                 \"When using matchers, all arguments have to be provided by matchers.\",\n                 \"\",\n                 \"For more info see javadoc for Matchers class.\"\n         ));\n-    }    \n+    }\n \n     public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n-        String message = join(\"Argument(s) are different! Wanted:\", \n+        String message = join(\"Argument(s) are different! Wanted:\",\n                 wanted,\n                 new Location(),\n                 \"Actual invocation has different arguments:\",\n                 actualLocation,\n                 \"\"\n                 );\n-        \n+\n         if (JUnitTool.hasJUnit()) {\n             throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n         } else {\n             throw new ArgumentsAreDifferent(message);\n         }\n     }\n-    \n+\n     public void wantedButNotInvoked(PrintableInvocation wanted) {\n         throw new WantedButNotInvoked(createWantedButNotInvokedMessage(wanted));\n     }\n             }\n             allInvocations = sb.toString();\n         }\n-        \n+\n         String message = createWantedButNotInvokedMessage(wanted);\n         throw new WantedButNotInvoked(message + allInvocations);\n     }\n                 \"\"\n         );\n     }\n-    \n+\n     public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n         throw new VerificationInOrderFailure(join(\n                     \"Verification in order failure\",\n                 \"\"\n         );\n     }\n-    \n+\n     public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n         throw new NeverWantedButInvoked(join(\n                 wanted.toString(),\n                 firstUndesired,\n                 \"\"\n         ));\n-    }    \n-    \n+    }\n+\n     public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n \n     private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n             Location lastActualInvocation) {\n-        String ending = \n+        String ending =\n             (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n-            \n+\n             String message = join(\n                     wanted.toString(),\n                     \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n                     new Location(),\n-                    \"But was \" + discrepancy.getPluralizedActualCount() + \":\", \n+                    \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n                     ending\n             );\n             return message;\n     }\n-   \n+\n     public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n-        \n+\n         throw new TooLittleActualInvocations(message);\n     }\n-    \n+\n     public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n         String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n-        \n+\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n                 ));\n     public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n         ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n         String scenario = scenarioPrinter.print(invocations);\n-        \n+\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new Location(),\n                 \"\"\n         ));\n     }\n-    \n+\n     public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 \"\"\n                 ));\n     }\n-    \n+\n     public void cannotMockFinalClass(Class<?> clazz) {\n         throw new MockitoException(join(\n                 \"Cannot mock/spy \" + clazz.toString(),\n                 ));\n     }\n \n-    public void smartNullPointerException(Location location) {\n+    public void smartNullPointerException(Object obj, Location location) {\n         throw new SmartNullPointerException(join(\n                 \"You have a NullPointerException here:\",\n                 new Location(),\n+                obj,\n                 \"Because this method was *not* stubbed correctly:\",\n                 location,\n                 \"\"\n     public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n         throw new MockitoException(join(\n                 \"extraInterfaces() does not accept the same type as the mocked type.\",\n-                \"You mocked following type: \" + wrongType.getSimpleName(), \n+                \"You mocked following type: \" + wrongType.getSimpleName(),\n                 \"and you passed the same very interface to the extraInterfaces()\"\n         ));\n     }\n \n     public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n         throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n-                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);   \n+                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);\n     }\n \n     public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java\n                 return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n             }\n \n-            new Reporter().smartNullPointerException(location);\n+            new Reporter().smartNullPointerException(obj, location);\n             return null;\n         }\n \n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java\n \n     \tassertEquals(\"SmartNull returned by unstubbed withArgs(oompa, lumpa) method on mock\", smartNull + \"\");\n     }\n+\n+    @Test\n+\tpublic void shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable {\n+    \tAnswer<Object> answer = new ReturnsSmartNulls();\n+\n+        Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\n+\n+        try {\n+            smartNull.get();\n+            fail();\n+        } catch (SmartNullPointerException ex) {\n+        \tString message = ex.getMessage();\n+        \tassertTrue(\"Exception message should include oompa and lumpa, but was: \" + message,\n+        \t\t\tmessage.contains(\"oompa, lumpa\"));\n+        }\n+\t}\n }", "timestamp": 1288990532, "metainfo": ""}