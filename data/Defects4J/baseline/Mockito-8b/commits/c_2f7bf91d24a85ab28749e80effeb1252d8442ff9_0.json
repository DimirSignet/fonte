{"sha": "2f7bf91d24a85ab28749e80effeb1252d8442ff9", "log": "split verification logic  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40162", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/MissingInvocationVerifier.java\n+package org.mockito.internal;\n+\n+import org.mockito.exceptions.Exceptions;\n+\n+public class MissingInvocationVerifier implements Verifier {\n+\n+    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, VerifyingMode mode) {\n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        boolean atLeastOnce = mode.atLeastOnceMode();\n+               \n+        if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n+            reportMissingInvocationError(registeredInvocations, wanted);\n+        }\n+    }\n+    \n+    private void reportMissingInvocationError(RegisteredInvocations registeredInvocations, InvocationMatcher wanted) {\n+        Invocation actual = registeredInvocations.findActualInvocation(wanted);\n+        \n+        if (actual != null) {\n+            reportDiscrepancy(wanted, actual);\n+        } else {\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+    }\n+\n+    private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        if (wanted.equals(actual)) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n+    }\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n         this.mockitoState = mockitoState;\n         this.matchersBinder = matchersBinder;\n         stubber = new Stubber(mockitoState);\n-        verifyingRecorder = new VerifyingRecorder<T>();\n+        verifyingRecorder = new VerifyingRecorder<T>(new OrderOfInvocationsVerifier(), new MissingInvocationVerifier(), new NumberOfInvocationsVerifier());\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n--- /dev/null\n+++ b/src/org/mockito/internal/NumberOfInvocationsVerifier.java\n+package org.mockito.internal;\n+\n+import org.mockito.exceptions.Exceptions;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+\n+public class NumberOfInvocationsVerifier implements Verifier {\n+\n+    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, VerifyingMode mode) {\n+        if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n+            return;\n+        }\n+        \n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        \n+        if (actualCount < wantedCount) {\n+            HasStackTrace lastInvocation = registeredInvocations.getLastInvocationStackTrace(wanted);\n+            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n+        } else if (actualCount > wantedCount) {\n+            HasStackTrace firstUndesired = registeredInvocations.getFirstUndesiredInvocationStackTrace(wanted, mode);\n+            Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/OrderOfInvocationsVerifier.java\n+package org.mockito.internal;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Exceptions;\n+\n+public class OrderOfInvocationsVerifier implements Verifier {\n+\n+    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, VerifyingMode mode) {\n+        if (!mode.orderOfInvocationsMatters()) {\n+            return;\n+        }\n+        \n+        List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n+        \n+        if (mode.wantedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n+            Exceptions.numberOfInvocationsDiffers(0, chunks.get(0).getCount(), wanted.toString());\n+        } else if (mode.wantedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (chunks.isEmpty()) {\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+        \n+        if (!wanted.matches(chunks.get(0).getInvocation())) {\n+            reportStrictOrderDiscrepancy(wanted, chunks.get(0).getInvocation());\n+        }\n+        \n+        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.wantedCount()) {\n+            Exceptions.numberOfInvocationsDiffers(mode.wantedCount(), chunks.get(0).getCount(), wanted.toString());\n+        }\n+    }\n+    \n+    private void reportStrictOrderDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        boolean sameMocks = wantedInvocation.getInvocation().getMock().equals(actualInvocation.getMock());\n+        boolean sameMethods = wanted.equals(actual);\n+        if (sameMethods && !sameMocks) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber();\n+        } else if (sameMethods) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.strictlyWantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/Verifier.java\n+package org.mockito.internal;\n+\n+public interface Verifier {\n+\n+    void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, VerifyingMode mode);\n+    \n+}\n--- a/src/org/mockito/internal/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/VerifyingRecorder.java\n  */\n package org.mockito.internal;\n \n-import java.util.*;\n+import java.util.List;\n \n-import org.mockito.exceptions.*;\n-import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.exceptions.Exceptions;\n \n public class VerifyingRecorder<T> {\n \n     private RegisteredInvocations registeredInvocations = new RegisteredInvocations(new AllInvocationsFinder());\n+    private final Verifier[] verifiers;\n \n+    public VerifyingRecorder(Verifier ... verifiers) {\n+        this.verifiers = verifiers;\n+    }\n+    \n     public void recordInvocation(InvocationMatcher invocation) {\n         this.registeredInvocations.add(invocation.getInvocation());\n     }\n     \n+    public void eraseLastInvocation() {\n+        registeredInvocations.removeLast();\n+    }\n+\n     public List<Invocation> getRegisteredInvocations() {\n         return registeredInvocations.all();\n     }\n \n-    public void eraseLastInvocation() {\n-        registeredInvocations.removeLast();\n-    }\n-\n     public void verify(InvocationMatcher wanted, VerifyingMode mode) {\n-        checkOrderOfInvocations(wanted, mode);\n-        checkForMissingInvocation(wanted, mode);\n-        checkForWrongNumberOfInvocations(wanted, mode);        \n+        for (Verifier v : verifiers) {\n+            v.verify(registeredInvocations, wanted, mode);\n+        }\n         registeredInvocations.markInvocationsAsVerified(wanted, mode);\n     }\n     \n-    private void checkForMissingInvocation(InvocationMatcher wanted, VerifyingMode mode) {\n-        int actualCount = registeredInvocations.countActual(wanted);\n-        Integer wantedCount = mode.wantedCount();\n-        boolean atLeastOnce = mode.atLeastOnceMode();\n-               \n-        if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n-            reportMissingInvocationError(wanted);\n-        }\n-    }\n-\n-    void checkForWrongNumberOfInvocations(InvocationMatcher wanted, VerifyingMode mode) {\n-        if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n-            return;\n-        }\n-        \n-        int actualCount = registeredInvocations.countActual(wanted);\n-        Integer wantedCount = mode.wantedCount();\n-        \n-        if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocation = registeredInvocations.getLastInvocationStackTrace(wanted);\n-            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n-        } else if (actualCount > wantedCount) {\n-            HasStackTrace firstUndesired = registeredInvocations.getFirstUndesiredInvocationStackTrace(wanted, mode);\n-            Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n-        }\n-    }\n-\n-    private void reportMissingInvocationError(InvocationMatcher wanted) {\n-        Invocation actual = registeredInvocations.findActualInvocation(wanted);\n-        \n-        if (actual != null) {\n-            reportDiscrepancy(wanted, actual);\n-        } else {\n-            Exceptions.wantedButNotInvoked(wanted.toString());\n-        }\n-    }\n-\n-    private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n-        String wanted = wantedInvocation.toString();\n-        String actual = actualInvocation.toString();\n-        if (wanted.equals(actual)) {\n-            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n-            actual = actualInvocation.toStringWithArgumentTypes();\n-        }\n-        \n-        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n-    }\n-    \n-    private void reportStrictOrderDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n-        String wanted = wantedInvocation.toString();\n-        String actual = actualInvocation.toString();\n-        boolean sameMocks = wantedInvocation.getInvocation().getMock().equals(actualInvocation.getMock());\n-        boolean sameMethods = wanted.equals(actual);\n-        if (sameMethods && !sameMocks) {\n-            wanted = wantedInvocation.toStringWithSequenceNumber();\n-            actual = actualInvocation.toStringWithSequenceNumber();\n-        } else if (sameMethods) {\n-            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n-            actual = actualInvocation.toStringWithArgumentTypes();\n-        }\n-        \n-        Exceptions.strictlyWantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n-    }\n-\n-    //TODO Cyclomatic Complexity = 10 :|\n-    private void checkOrderOfInvocations(InvocationMatcher wanted, VerifyingMode mode) {\n-        if (!mode.orderOfInvocationsMatters()) {\n-            return;\n-        }\n-        \n-        List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n-        \n-        if (mode.wantedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n-            Exceptions.numberOfInvocationsDiffers(0, chunks.get(0).getCount(), wanted.toString());\n-        } else if (mode.wantedCountIsZero()) {\n-            return;\n-        }\n-        \n-        if (chunks.isEmpty()) {\n-            Exceptions.wantedButNotInvoked(wanted.toString());\n-        }\n-        \n-        if (!wanted.matches(chunks.get(0).getInvocation())) {\n-            reportStrictOrderDiscrepancy(wanted, chunks.get(0).getInvocation());\n-        }\n-        \n-        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.wantedCount()) {\n-            Exceptions.numberOfInvocationsDiffers(mode.wantedCount(), chunks.get(0).getCount(), wanted.toString());\n-        }\n-    }\n-\n     public void verifyNoMoreInteractions() {\n         Invocation unverified = registeredInvocations.getFirstUnverified();\n         if (unverified != null) {\n--- /dev/null\n+++ b/test/org/mockito/internal/NumberOfInvocationsVerifierTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+\n+import org.junit.*;\n+import org.mockito.RequiresValidState;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n+\n+    private NumberOfInvocationsVerifier verifier;\n+    \n+    @Before\n+    public void setup() {\n+        verifier = new NumberOfInvocationsVerifier();\n+    }\n+\n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n+        VerifyingMode inOrder = VerifyingMode.inOrder(1, Arrays.asList(new Object()));\n+        assertTrue(inOrder.orderOfInvocationsMatters());\n+        \n+        verifier.verify(null, null, inOrder);\n+    }\n+    \n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n+        VerifyingMode inOrder = VerifyingMode.atLeastOnce();\n+        \n+        verifier.verify(null, null, inOrder);\n+    }\n+}\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n                     InvocationMatcherTest.class, \n                     InvocationChunkTest.class, \n                     MockFactoryTest.class, \n-                    VerifyingRecorderTest.class, \n+                    NumberOfInvocationsVerifierTest.class, \n                     MockitoStateImplTest.class, \n                     RegisteredInvocationsTest.class, \n                     EmptyReturnValuesTest.class, ", "timestamp": 1197335592, "metainfo": ""}