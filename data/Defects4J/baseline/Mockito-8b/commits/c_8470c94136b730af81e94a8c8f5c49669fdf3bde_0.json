{"sha": "8470c94136b730af81e94a8c8f5c49669fdf3bde", "log": "Rename job  --HG-- rename : src/org/mockito/internal/verification/MockitoVerificationMode.java => src/org/mockito/internal/verification/Times.java rename : test/org/mockito/internal/progress/MockitoVerificationModeTest.java => test/org/mockito/internal/progress/TimesTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40973", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n-import org.mockito.internal.verification.MockitoVerificationMode;\n+import org.mockito.internal.verification.Times;\n import org.mockito.internal.verification.VerificationModeDecoder;\n \n public class InvocationsFinder {\n      * if wanted is 1 and mode is times(x), where x != 2 then returns\n      * 1,1,1\n      */\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, Times mode) {\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n         List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n         \n--- a/src/org/mockito/internal/verification/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsChecker.java\n         this.finder = finder;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, Times mode) {\n         VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n         \n--- a/src/org/mockito/internal/verification/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderChecker.java\n         this.reporter = reporter;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, Times mode) {\n         VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode);\n         \n--- /dev/null\n+++ b/src/org/mockito/internal/verification/Times.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.api.VerificationMode;\n+\n+public class Times implements VerificationInOrderMode, VerificationMode {\n+    \n+    final int wantedInvocationCount;\n+    \n+    public Times(int wantedNumberOfInvocations) {\n+        if (wantedNumberOfInvocations < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+    }\n+    \n+    public void verify(VerificationData data) {\n+        MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n+        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();\n+        \n+        if (wantedInvocationCount > 0) {\n+            missingInvocation.verify(data.getAllInvocations(), data.getWanted());\n+        }\n+        numberOfInvocations.verify(data.getAllInvocations(), data.getWanted(), this);\n+    }\n+    \n+    public void verifyInOrder(VerificationData data) {\n+        List<Invocation> allInvocations = data.getAllInvocations();\n+        InvocationMatcher wanted = data.getWanted();\n+        \n+        MissingInvocationInOrderChecker missingInvocation = new MissingInvocationInOrderChecker();\n+        NumberOfInvocationsInOrderChecker numberOfCalls = new NumberOfInvocationsInOrderChecker();\n+        \n+        if (wantedCount() > 0) {\n+            missingInvocation.verify(allInvocations, wanted, this);\n+        }\n+        \n+        numberOfCalls.verify(allInvocations, wanted, this);\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: \" + wantedCount();\n+    }    \n+\n+    public int wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeDecoder.java\n+++ b/src/org/mockito/internal/verification/VerificationModeDecoder.java\n //TODO verify all methods are used\n public class VerificationModeDecoder {\n \n-    private final MockitoVerificationMode mode;\n+    private final Times mode;\n \n-    public VerificationModeDecoder(MockitoVerificationMode mode) {\n+    public VerificationModeDecoder(Times mode) {\n         this.mode = mode;\n     }\n \n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n         return new AtLeast(minNumberOfInvocations);\n     }\n \n-    public static MockitoVerificationMode times(int wantedNumberOfInvocations) {\n-        return new MockitoVerificationMode(wantedNumberOfInvocations);\n+    public static Times times(int wantedNumberOfInvocations) {\n+        return new Times(wantedNumberOfInvocations);\n     }\n \n     public static NoMoreInteractionsMode noMoreInteractions() {\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.invocation.InvocationsFinderTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.MockitoVerificationModeTest;\n+import org.mockito.internal.progress.TimesTest;\n import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n import org.mockito.internal.verification.MissingInvocationCheckerTest;\n                     EqualsTest.class,\n                     ListUtilTest.class,\n                     MockingProgressImplTest.class,\n-                    MockitoVerificationModeTest.class,\n+                    TimesTest.class,\n                     MockHandlerTest.class,\n                     AllInvocationsFinderTest.class,\n                     DefaultReturnValuesTest.class,\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.mockito.Mock;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.progress.VerificationModeBuilder;\n-import org.mockito.internal.verification.MockitoVerificationMode;\n+import org.mockito.internal.verification.Times;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldFindMatchingChunk() throws Exception {\n-        MockitoVerificationMode inOrderMode = new VerificationModeBuilder().times(2).inOrder();\n+        Times inOrderMode = new VerificationModeBuilder().times(2).inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), inOrderMode);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder().inOrder();\n+        Times atLeastOnceInOrder = new VerificationModeBuilder().inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnceInOrder);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder().times(100).inOrder();\n+        Times atLeastOnceInOrder = new VerificationModeBuilder().times(100).inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnceInOrder);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/TimesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockitoutil.TestBase;\n+\n+public class TimesTest extends TestBase {\n+\n+    @Test\n+    public void shouldNotAllowNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            VerificationModeFactory.times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotAllowNegativeNumberOfMinimumInvocations() throws Exception {\n+        try {\n+            VerificationModeFactory.atLeast(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value or zero are not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/progress/VerificationModeBuilder.java\n+++ b/test/org/mockito/internal/progress/VerificationModeBuilder.java\n package org.mockito.internal.progress;\n \n \n-import org.mockito.internal.verification.MockitoVerificationMode;\n+import org.mockito.internal.verification.Times;\n import org.mockito.internal.verification.VerificationModeFactory;\n \n public class VerificationModeBuilder {\n \n     private Integer times = 1;\n \n-    public MockitoVerificationMode inOrder() {\n+    public Times inOrder() {\n         return VerificationModeFactory.times(times);\n     }\n \n--- a/test/org/mockito/internal/verification/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/InvocationsFinderStub.java\n     }\n     \n     @Override\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, Times mode) {\n         return validMatchingChunkToReturn;\n     }\n \n--- a/test/org/mockito/internal/verification/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsCheckerTest.java\n \n     @Test\n     public void shouldReportTooLittleActual() throws Exception {\n-        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n+        Times mode = VerificationModeFactory.times(100);\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         \n         verifier.verify(invocations, wanted, mode);\n \n     @Test\n     public void shouldReportWithLastInvocationStackTrace() throws Exception {\n-        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n+        Times mode = VerificationModeFactory.times(100);\n         Invocation first = new InvocationBuilder().toInvocation();\n         Invocation second = new InvocationBuilder().toInvocation();\n         \n     \n     @Test\n     public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {\n-        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n+        Times mode = VerificationModeFactory.times(100);\n         \n         assertTrue(finderStub.actualToReturn.isEmpty());\n         \n     \n     @Test\n     public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n-        MockitoVerificationMode mode = VerificationModeFactory.times(2);\n+        Times mode = VerificationModeFactory.times(2);\n \n         Invocation first = new InvocationBuilder().toInvocation();\n         Invocation second = new InvocationBuilder().toInvocation();\n     \n     @Test\n     public void shouldReportTooManyActual() throws Exception {\n-        MockitoVerificationMode mode = VerificationModeFactory.times(1);\n+        Times mode = VerificationModeFactory.times(1);\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         \n     \n     @Test\n     public void shouldReportNeverWantedButInvoked() throws Exception {\n-        MockitoVerificationMode mode = VerificationModeFactory.times(0);\n+        Times mode = VerificationModeFactory.times(0);\n         Invocation invocation = new InvocationBuilder().toInvocation();\n         finderStub.actualToReturn.add(invocation);\n         \n--- a/test/org/mockito/internal/verification/VerificationModeDecoderTest.java\n+++ b/test/org/mockito/internal/verification/VerificationModeDecoderTest.java\n \n public class VerificationModeDecoderTest extends TestBase {\n     \n-    private VerificationModeDecoder decode(MockitoVerificationMode mode) {\n+    private VerificationModeDecoder decode(Times mode) {\n         return new VerificationModeDecoder(mode);\n     }\n     ", "timestamp": 1223981694, "metainfo": ""}