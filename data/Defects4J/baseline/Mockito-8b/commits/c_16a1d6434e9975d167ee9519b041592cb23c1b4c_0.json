{"sha": "16a1d6434e9975d167ee9519b041592cb23c1b4c", "log": "added yet ugly feature that merges exception trace  --HG-- rename : src/org/mockito/exceptions/HasFilterableStackTrace.java => src/org/mockito/exceptions/HasStackTrace.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40137", "commit": "\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions;\n+\n+import java.util.*;\n \n /**\n  * All messages in one place makes it easier to tune and amend the text. \n         \n     }\n     \n-    public static void wantedInvocationDiffersFromActual(String wanted, String actual) {\n-        throw new VerificationError(join(\n+    public static VerificationError wantedInvocationDiffersFromActual(String wanted, String actual, List<StackTraceElement> invocationStackTrace) {\n+        return new VerificationError(join(\n                 \"Invocation differs from actual\",\n-                \"Wanted: \" + wanted,\n+                \"Wanted: \" + wanted,    \n                 \"Actual: \" + actual\n-            ));\n+            ), invocationStackTrace);\n     }\n     \n \n--- /dev/null\n+++ b/src/org/mockito/exceptions/HasStackTrace.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+public interface HasStackTrace {\n+    \n+    void setStackTrace(StackTraceElement[] stackTrace);\n+    \n+    StackTraceElement[] getStackTrace();\n+\n+}\n--- a/src/org/mockito/exceptions/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/MockitoAssertionError.java\n  */\n package org.mockito.exceptions;\n \n+import java.util.List;\n \n-public class MockitoAssertionError extends AssertionError implements HasFilterableStackTrace {\n+\n+public class MockitoAssertionError extends AssertionError implements HasStackTrace {\n \n     private static final long serialVersionUID = 1L;\n     protected StackTraceElement[] unfilteredStackTrace;\n         filter.filterStackTrace(this);\n     }\n     \n+    public MockitoAssertionError(String message, List<StackTraceElement> invocationStackTrace) {\n+        this(message);\n+        \n+        MockitoStackTraceMerger merger = new MockitoStackTraceMerger();\n+        merger.merge(this, invocationStackTrace);\n+    }\n+\n     public StackTraceElement[] getUnfilteredStackTrace() {\n         return unfilteredStackTrace;\n     }\n--- a/src/org/mockito/exceptions/MockitoException.java\n+++ b/src/org/mockito/exceptions/MockitoException.java\n  */\n package org.mockito.exceptions;\n \n-public class MockitoException extends RuntimeException implements HasFilterableStackTrace {\n+public class MockitoException extends RuntimeException implements HasStackTrace {\n \n     private static final long serialVersionUID = 1L;\n \n--- a/src/org/mockito/exceptions/MockitoStackTraceFilter.java\n+++ b/src/org/mockito/exceptions/MockitoStackTraceFilter.java\n         return fromMockObject || fromOrgMockito;\n     }\n \n-    public void filterStackTrace(HasFilterableStackTrace hasFilterableStackTrace) {\n-        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasFilterableStackTrace.getStackTrace());\n+    public void filterStackTrace(HasStackTrace hasStackTrace) {\n+        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasStackTrace.getStackTrace());\n         \n         int lastToRemove = -1;\n         int i = 0;\n         }\n         \n         List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove+1, unfilteredStackTrace.size() - 1);\n-        hasFilterableStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+        hasStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/MockitoStackTraceMerger.java\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+public class MockitoStackTraceMerger {\n+\n+    public void merge(HasStackTrace hasStackTrace, List<StackTraceElement> invocationStackTrace) {\n+        List<StackTraceElement> exceptionsPart = null;\n+        List<StackTraceElement> exceptionsTrace = Arrays.asList(hasStackTrace.getStackTrace());\n+        int length = exceptionsTrace.size();\n+        for(int i=0 ; i<length; i++) {\n+            List<StackTraceElement> subList = exceptionsTrace.subList(i, length);\n+            int lastStartingIndexOfSubList = Collections.lastIndexOfSubList(invocationStackTrace, subList);\n+            if (lastStartingIndexOfSubList == -1) {\n+                continue;\n+            }\n+            \n+            int lastEndingIndexOfSubList = lastStartingIndexOfSubList + subList.size() - 1;\n+            if (lastEndingIndexOfSubList == invocationStackTrace.size() - 1) {\n+                exceptionsPart = exceptionsTrace.subList(0, Math.max(i, 1));\n+                break;\n+            }\n+        }\n+        \n+        assert exceptionsPart != null;\n+        \n+        List<StackTraceElement> newStackTrace = new LinkedList<StackTraceElement>();\n+        newStackTrace.addAll(exceptionsPart);\n+        newStackTrace.add(new StackTraceElement(\"\", \"_below_is_actual_invocation_stack_trace_\", \"\", 0));\n+        newStackTrace.addAll(invocationStackTrace);\n+        \n+//        int pointOfCommon = -1;\n+//        int index = 0;\n+//        for (StackTraceElement e : hasStackTrace.getStackTrace()) {\n+////            System.out.println(e);\n+////            System.err.println(invocationStackTrace.get(index));\n+//            if (pointOfCommon == -1 && invocationStackTrace.indexOf(e)) {\n+//                pointOfCommon = index;\n+//            }\n+//            \n+//            index++;\n+//        }\n+//        \n+//        assert pointOfCommon != -1;\n+        \n+//        List<StackTraceElement> newStackTrace = new LinkedList<StackTraceElement>();\n+//        List<StackTraceElement> exceptionTraceSublist = exceptionsTrace.subList(0, pointOfCommon);\n+//        newStackTrace.addAll(exceptionTraceSublist);\n+//        newStackTrace.add(new StackTraceElement(\"\", \"_below_is_actual_invocation_stack_trace_\", \"\", 0));\n+//        newStackTrace.addAll(invocationStackTrace);\n+        \n+        hasStackTrace.setStackTrace(newStackTrace.toArray(new StackTraceElement[newStackTrace.size()]));\n+    }\n+}\n--- a/src/org/mockito/exceptions/VerificationError.java\n+++ b/src/org/mockito/exceptions/VerificationError.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.exceptions;\n+\n+import java.util.*;\n \n public class VerificationError extends MockitoAssertionError {\n \n     public VerificationError(String message) {\n         super(message);\n     }\n+\n+    public VerificationError(String message, List<StackTraceElement> invocationStackTrace) {\n+        super(message, invocationStackTrace);\n+    }\n }\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n import java.lang.reflect.*;\n import java.util.*;\n \n+import org.mockito.exceptions.MockitoException;\n import org.mockito.internal.matchers.*;\n \n public class Invocation {\n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n+    private final StackTraceElement[] stackTrace;\n \n     private boolean verifiedInOrder;\n \n         this.method = method;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n         this.sequenceNumber = sequenceNumber;\n+        this.stackTrace = new MockitoException(\"just to get stack trace\").getStackTrace();\n     }\n \n     private static Object[] expandVarArgs(final boolean isVarArgs,\n     public String toStringWithSequenceNumber(List<IArgumentMatcher> matchers) {\n         return getMockAndMethodNameWithSeqenceNumber() + getArgumentsString(matchers);\n     }\n+\n+    public StackTraceElement[] getStackTrace() {\n+        return this.stackTrace;\n+    }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n             actual = actualInvocation.toStringWithArgumentTypes();\n         }\n         \n-        Exceptions.wantedInvocationDiffersFromActual(wanted, actual);\n+        List<StackTraceElement> elements = new LinkedList<StackTraceElement>(Arrays.asList(actualInvocation.getStackTrace()));\n+        \n+        throw Exceptions.wantedInvocationDiffersFromActual(wanted, actual, elements);\n     }\n     \n     private void reportStrictOrderDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation) {\n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n package org.mockito.internal;\n \n import java.util.*;\n+\n+import org.mockito.exceptions.MockitoException;\n \n public class RegisteredInvocations {\n     \n     }\n \n     public void add(Invocation invocation) {\n-        registeredInvocations.add(invocation);        \n+        registeredInvocations.add(invocation);    \n     }\n \n     public void removeLast() {\n--- a/src/org/mockito/internal/Result.java\n+++ b/src/org/mockito/internal/Result.java\n                 MockitoStackTraceFilter filter = new MockitoStackTraceFilter();\n                 final Throwable filtered = throwable.fillInStackTrace();\n                 \n-                filter.filterStackTrace(new HasFilterableStackTrace() {\n+                filter.filterStackTrace(new HasStackTrace() {\n                     public StackTraceElement[] getStackTrace() {\n                         return filtered.getStackTrace();\n                     }\n--- /dev/null\n+++ b/test/org/mockito/exceptions/MockitoStackTraceMergerTest.java\n+package org.mockito.exceptions;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+import java.util.*;\n+\n+import org.junit.Test;\n+\n+\n+public class MockitoStackTraceMergerTest {\n+\n+    private StackTraceElement[] exceptionStackTrace;\n+    private List<StackTraceElement> actualInvocationStackTrace;\n+    private List<String> methodsOnTraceAfterMerging;\n+    \n+    private class SomeException implements HasStackTrace {\n+        public StackTraceElement[] getStackTrace() {\n+            return exceptionStackTrace;\n+        }\n+        public void setStackTrace(StackTraceElement[] stackTrace) {\n+            methodsOnTraceAfterMerging = new LinkedList<String>();\n+            for(StackTraceElement e : stackTrace) {\n+                methodsOnTraceAfterMerging.add(e.getMethodName());\n+            }\n+        }\n+    }\n+    \n+    private void merge() {\n+        MockitoStackTraceMerger merger = new MockitoStackTraceMerger();\n+        SomeException exception = new SomeException();\n+        merger.merge(exception, actualInvocationStackTrace);\n+    }\n+    \n+    private void exceptionStackTrace(String ... methods) {\n+        exceptionStackTrace = new StackTraceBuilder().methods(methods).toStackTrace();\n+    }\n+    \n+    private void actualInvocationStackTrace(String ... methods) {\n+        actualInvocationStackTrace = new StackTraceBuilder().methods(methods).toStackTraceList();\n+    }\n+    \n+    @Test\n+    public void shouldMergeStackTrace() throws Exception {\n+        exceptionStackTrace(\"methodOne\", \"methodTwo\", \"methodThree\", \"commonMethodOne\", \"commonMethodTwo\");\n+        actualInvocationStackTrace(\"actualOne\", \"actualTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n+        merge();\n+        assertThat(methodsOnTraceAfterMerging, collectionContainingInOrder(\n+                \"methodOne\",\n+                \"methodTwo\",\n+                \"methodThree\",\n+                \"_below_is_actual_invocation_stack_trace_\",\n+                \"actualOne\",       \n+                \"actualTwo\",       \n+                \"commonMethodOne\", \n+                \"commonMethodTwo\"\n+        ));\n+    }\n+    \n+\n+    @Test\n+    public void shouldMergeWhenExceptionTraceHasRecursion() throws Exception {\n+        exceptionStackTrace(\"methodOne\", \"commonMethodOne\", \"commonMethodTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n+        actualInvocationStackTrace(\"actualOne\", \"commonMethodOne\", \"commonMethodTwo\");\n+        merge();\n+        assertThat(methodsOnTraceAfterMerging, collectionContainingInOrder(\n+                \"methodOne\",\n+                \"commonMethodOne\",\n+                \"commonMethodTwo\",\n+                \"_below_is_actual_invocation_stack_trace_\",\n+                \"actualOne\",       \n+                \"commonMethodOne\", \n+                \"commonMethodTwo\"\n+        ));\n+    }\n+\n+    @Test\n+    public void shouldMergeWhenActualTraceHasRecursion() throws Exception {\n+        exceptionStackTrace(\"methodOne\", \"commonMethodOne\");\n+        actualInvocationStackTrace(\"actualOne\", \"commonMethodOne\", \"actualOne\", \"commonMethodOne\");\n+        merge();\n+        assertThat(methodsOnTraceAfterMerging, collectionContainingInOrder(\n+                \"methodOne\",\n+                \"_below_is_actual_invocation_stack_trace_\",\n+                \"actualOne\",       \n+                \"commonMethodOne\", \n+                \"actualOne\",\n+                \"commonMethodOne\"\n+        ));\n+    }\n+    \n+    @Test\n+    public void shouldMergeWhenOnlyOneMethodOnStackTrace() throws Exception {\n+        exceptionStackTrace(\"commonOne\");\n+        actualInvocationStackTrace(\"commonOne\");\n+        merge();\n+        assertThat(methodsOnTraceAfterMerging, collectionContainingInOrder(\n+                \"commonOne\",\n+                \"_below_is_actual_invocation_stack_trace_\",\n+                \"commonOne\"       \n+        ));\n+    }\n+    \n+    @Test\n+    public void shouldMergeWhenOneMethodEach() throws Exception {\n+        exceptionStackTrace(\"one\", \"commonOne\");\n+        actualInvocationStackTrace(\"two\", \"commonOne\");\n+        merge();\n+        assertThat(methodsOnTraceAfterMerging, collectionContainingInOrder(\n+                \"one\",\n+                \"_below_is_actual_invocation_stack_trace_\",\n+                \"two\",\n+                \"commonOne\"\n+        ));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/exceptions/StackTraceBuilder.java\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+public class StackTraceBuilder {\n+    \n+    private String[] methods;\n+\n+    public StackTraceBuilder methods(String ... methods) {\n+        this.methods = methods;\n+        return this;\n+    }\n+\n+    public StackTraceElement[] toStackTrace() {\n+        StackTraceElement[] trace = new StackTraceElement[methods.length];\n+        \n+        for (int i = 0 ; i < methods.length ; i++) {\n+            trace[i] = new StackTraceElement(\"DummyClass\", methods[i], \"DummyClass.java\", 100);\n+        }\n+        \n+        return trace;\n+    }\n+\n+    public List<StackTraceElement> toStackTraceList() {\n+        return Arrays.asList(toStackTrace());\n+    }\n+}\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n @SuppressWarnings(\"unchecked\")\n public class ExtraMatchers extends CoreMatchers {\n \n-    public static <T> Matcher<Throwable> firstMethodOnStackEqualsTo(final String method) {\n+    public static <T> Matcher<Throwable> hasFirstMethodInStackTrace(final String method) {\n+        return hasMethodInStackTraceAt(0, method);\n+    }\n+    \n+    public static <T> Matcher<Throwable> hasMethodInStackTraceAt(final int stackTraceIndex, final String method) {\n         return new BaseMatcher<Throwable>() {\n \n-            private String firstMethodOnStack;\n+            private String actualMethodAtIndex;\n \n             public boolean matches(Object throwable) {\n-                firstMethodOnStack = ((Throwable) throwable).getStackTrace()[0].getMethodName();\n-                return  firstMethodOnStack.equals(method);\n+                actualMethodAtIndex = ((Throwable) throwable).getStackTrace()[stackTraceIndex].getMethodName();\n+                return  actualMethodAtIndex.equals(method);\n             }\n \n             public void describeTo(Description desc) {\n-                desc.appendText(\"first method expected to be: \" + method + \" but is: \" + firstMethodOnStack);\n+                desc.appendText(\"Method of index: \" + stackTraceIndex + \" expected to be: \" + method + \" but is: \" + actualMethodAtIndex);\n             }\n         };\n     }\n             }\n         };\n     }\n+    \n+    public static <T> Matcher<Collection> collectionContainingInOrder(final T ... elements) {\n+        return new BaseMatcher<Collection>() {\n+\n+            public boolean matches(Object collection) {\n+                Collection actual = (Collection)collection;\n+                if (actual.size() != elements.length) {\n+                    return false;\n+                }\n+                if (Collections.indexOfSubList((List<?>) actual, Arrays.asList(elements)) == -1) {\n+                    return false;\n+                }\n+                \n+                return true;\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"collection doesn't contain following elements in order: \" + Arrays.toString(elements));\n+            }\n+        };\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.util.ExtraMatchers.hasMethodInStackTraceAt;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationError;\n+import org.mockito.util.RequiresValidState;\n+\n+public class StackTrackeChangingTest extends RequiresValidState {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    private void simpleMethodOnAMock() {\n+        mock.simpleMethod(\"blah\");\n+    }\n+    \n+    @Test\n+    public void shouldMergeInvocationStackTraceAndExceptionStackTrace() {\n+        simpleMethodOnAMock();\n+        try {\n+            verifySimpleMethodOnAMock();\n+            fail();\n+        } catch (VerificationError e) {\n+            assertThat(e, hasMethodInStackTraceAt(0, \"verifySimpleMethodOnAMock\"));\n+            assertThat(e, hasMethodInStackTraceAt(1, \"shouldMergeInvocationStackTraceAndExceptionStackTrace\"));\n+            assertThat(e, hasMethodInStackTraceAt(2, \"_below_is_actual_invocation_stack_trace_\"));\n+            assertThat(e, hasMethodInStackTraceAt(3, \"simpleMethodOnAMock\"));\n+            assertThat(e, hasMethodInStackTraceAt(4, \"shouldMergeInvocationStackTraceAndExceptionStackTrace\"));\n+        }\n+    }\n+\n+    private void verifySimpleMethodOnAMock() {\n+        verify(mock).simpleMethod();        \n+    }\n+}\n--- a/test/org/mockitousage/StackTrackeFilteringTest.java\n+++ b/test/org/mockitousage/StackTrackeFilteringTest.java\n \n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n-import static org.mockito.util.ExtraMatchers.firstMethodOnStackEqualsTo;\n+import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;\n \n import org.junit.*;\n import org.mockito.*;\n             verify(mock).simpleMethod();\n             fail();\n         } catch (VerificationError expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerify\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerify\"));\n         }\n     }\n     \n             verifyNoMoreInteractions(mock);\n             fail();\n         } catch (VerificationError expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n         }\n     }\n     \n             verifyZeroInteractions(mock);\n             fail();\n         } catch (VerificationError expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n         }\n     }\n     \n             verify(mock).oneArg(true); \n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceOnMockitoException\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceOnMockitoException\"));\n         }\n     }\n     \n             strictly.verify(mock).oneArg(false); \n             fail();\n         } catch (VerificationError expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n         }\n     }\n     \n             createStrictOrderVerifier();\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyThrowsMockitoException\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyThrowsMockitoException\"));\n         }\n     }\n     \n             strictly.verify(null);\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyVerifies\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifies\"));\n         }\n     }\n     \n             stub(mock.oneArg(true)).andThrows(new Exception());\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceWhenThrowingExceptionFromControl\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceWhenThrowingExceptionFromControl\"));\n         }\n     }\n     \n             mock.simpleMethod();\n             fail();\n         } catch (RuntimeException e) {\n-            assertThat(e, firstMethodOnStackEqualsTo(\"shouldShowProperExceptionStackTrace\"));\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldShowProperExceptionStackTrace\"));\n         }\n     }\n }", "timestamp": 1196985118, "metainfo": ""}