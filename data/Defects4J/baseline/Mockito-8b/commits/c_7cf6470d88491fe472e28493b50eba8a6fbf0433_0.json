{"sha": "7cf6470d88491fe472e28493b50eba8a6fbf0433", "log": "Initial checkin to allow my friends work on it. Contains loads of stuff from EasyMock, several TODOs, bugs, no build script. In short: very very alpha stuff.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%402", "commit": "\n--- /dev/null\n+++ b/src/org/easymock/AbstractMatcher.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+/**\n+ * A convenience implementation of {@link ArgumentsMatcher}. A subclass that\n+ * does not redefine any method will behave like\n+ * {@link MockControl#EQUALS_MATCHER}.\n+ * \n+ * @deprecated Since EasyMock 2.0, <code>ArgumentsMatcher</code>s are only supported\n+ * for the legacy <code>MockControl</code>. For mock objects generated by the methods\n+ * on <code>EasyMock</code>, there are per-argument matchers available. For more\n+ * information, see the EasyMock documentation.\n+ */\n+public abstract class AbstractMatcher implements ArgumentsMatcher {\n+\n+    /**\n+     * Checks whether an expected argument matches an actual argument; the method\n+     * is used by\n+     * {@link AbstractMatcher#matches(Object[], Object[])}. The arguments\n+     * provided to this method are always not <code>null</code>.\n+     * \n+     * @param expected\n+     *            the expected argument.\n+     * @param actual\n+     *            the actual argument.\n+     * @return true if the arguments match, false otherwise.\n+     */\n+    protected boolean argumentMatches(Object expected, Object actual) {\n+        return expected.equals(actual);\n+    }\n+\n+    /**\n+     * Converts an argument to a String, used by\n+     * {@link AbstractMatcher#toString(Object[])}.\n+     * \n+     * @param argument\n+     *            the argument to convert to a String.\n+     * @return a <code>String</code> representation of the argument.\n+     */\n+    protected String argumentToString(Object argument) {\n+        if (argument instanceof String) {\n+            return \"\\\"\" + argument + \"\\\"\";\n+        }\n+        return \"\" + argument;\n+    }\n+\n+    /**\n+     * Checks whether an expected argument array matches an actual argument array.\n+     * This convenience implementation uses\n+     * <code>argumentMatches(Object, Object)</code> to check whether arguments\n+     * pairs match. If all the arguments match, true is returned, otherwise\n+     * false. In two cases, <code>argumentMatches(Object, Object)</code> is\n+     * not called: If both argument arrays are null, they match; if one and only\n+     * one is null, they do not match.\n+     * \n+     * @param expected\n+     *            the expected arguments.\n+     * @param actual\n+     *            the actual arguments.\n+     * @return true if the arguments match, false otherwise.\n+     */\n+    public boolean matches(Object[] expected, Object[] actual) {\n+        if (expected == actual) {\n+            return true;\n+        }\n+        if (expected == null || actual == null) {\n+            return false;\n+        }\n+        if (expected.length != actual.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < expected.length; i++) {\n+            Object expectedObject = expected[i];\n+            Object actualObject = actual[i];\n+\n+            if (expectedObject == null && actualObject == null) {\n+                continue;\n+            }\n+\n+            if (expectedObject == null && actualObject != null) {\n+                return false;\n+            }\n+\n+            if (expectedObject != null && actualObject == null) {\n+                return false;\n+            }\n+\n+            if (!argumentMatches(expectedObject, actualObject)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a string representation of the matcher. This convenience\n+     * implementation calls {@link AbstractMatcher#argumentToString(Object)}\n+     * for every argument in the given array and returns the string representations\n+     * of the arguments separated by commas.\n+     * \n+     * @param arguments\n+     *            the arguments to be used in the string representation.\n+     * @return a string representation of the matcher.\n+     */\n+    public String toString(Object[] arguments) {\n+        if (arguments == null)\n+            arguments = new Object[0];\n+\n+        StringBuffer result = new StringBuffer();\n+\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (i > 0)\n+                result.append(\", \");\n+            result.append(argumentToString(arguments[i]));\n+        }\n+        return result.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/ArgumentsMatcher.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+/**\n+ * A comparison function that is used to match arguments.\n+ * \n+ * @see MockControl#setDefaultMatcher\n+ * @see MockControl#setMatcher\n+ * @see MockControl#EQUALS_MATCHER\n+ * @see MockControl#ARRAY_MATCHER\n+ * @see MockControl#ALWAYS_MATCHER\n+ * \n+ * @deprecated Since EasyMock 2.0, <code>ArgumentsMatcher</code>s are only supported\n+ * for the legacy <code>MockControl</code>. For mock objects generated by the methods\n+ * on <code>EasyMock</code>, there are per-argument matchers available. For more\n+ * information, see the EasyMock documentation.\n+ */\n+public interface ArgumentsMatcher {\n+\n+    /**\n+     * Matches two arrays of arguments.\n+     * \n+     * @param expected\n+     *            the expected arguments.\n+     * @param actual\n+     *            the actual arguments.\n+     * @return true if the arguments match, false otherwise.\n+     */\n+    boolean matches(Object[] expected, Object[] actual);\n+\n+    /**\n+     * Returns a string representation of the arguments.\n+     * \n+     * @param arguments\n+     *            the arguments to be used in the string representation.\n+     * @return a string representation of the arguments.\n+     */\n+    String toString(Object[] arguments);\n+}\n--- /dev/null\n+++ b/src/org/easymock/EasyMock.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+import java.lang.reflect.Proxy;\n+import java.util.Comparator;\n+\n+import org.easymock.internal.ClassExtensionHelper;\n+import org.easymock.internal.LastArguments;\n+import org.easymock.internal.LastControl;\n+import org.easymock.internal.MockInvocationHandler;\n+import org.easymock.internal.MocksControl;\n+import org.easymock.internal.ObjectMethodsFilter;\n+import org.easymock.internal.matchers.Any;\n+import org.easymock.internal.matchers.ArrayEquals;\n+import org.easymock.internal.matchers.Compare;\n+import org.easymock.internal.matchers.CompareEqual;\n+import org.easymock.internal.matchers.Contains;\n+import org.easymock.internal.matchers.EndsWith;\n+import org.easymock.internal.matchers.Equals;\n+import org.easymock.internal.matchers.EqualsWithDelta;\n+import org.easymock.internal.matchers.Find;\n+import org.easymock.internal.matchers.GreaterOrEqual;\n+import org.easymock.internal.matchers.GreaterThan;\n+import org.easymock.internal.matchers.InstanceOf;\n+import org.easymock.internal.matchers.LessOrEqual;\n+import org.easymock.internal.matchers.LessThan;\n+import org.easymock.internal.matchers.Matches;\n+import org.easymock.internal.matchers.NotNull;\n+import org.easymock.internal.matchers.Null;\n+import org.easymock.internal.matchers.Same;\n+import org.easymock.internal.matchers.StartsWith;\n+\n+public class EasyMock {\n+\n+    /**\n+     * Creates a mock object that implements the given interface, order checking\n+     * is enabled by default.\n+     * \n+     * @param <T>\n+     *            the interface that the mock object should implement.\n+     * @param toMock\n+     *            the class of the interface that the mock object should\n+     *            implement.\n+     * @return the mock object.\n+     */\n+    public static <T> T createStrictMock(Class<T> toMock) {\n+        return createStrictControl().createMock(toMock);\n+    }\n+\n+    /**\n+     * Creates a mock object that implements the given interface, order checking\n+     * is enabled by default.\n+     * @param name the name of the mock object.     \n+     * @param toMock\n+     *            the class of the interface that the mock object should\n+     *            implement.\n+     * @param <T>\n+     *            the interface that the mock object should implement.\n+     * @return the mock object.\n+     * @throws IllegalArgumentException if the name is not a valid Java identifier.\n+     */\n+    public static <T> T createStrictMock(String name, Class<T> toMock) {\n+        return createStrictControl().createMock(name, toMock);\n+    }\n+\n+    /**\n+     * Creates a mock object that implements the given interface, order checking\n+     * is disabled by default.\n+     * \n+     * @param <T>\n+     *            the interface that the mock object should implement.\n+     * @param toMock\n+     *            the class of the interface that the mock object should\n+     *            implement.\n+     * @return the mock object.\n+     */\n+    public static <T> T createMock(Class<T> toMock) {\n+        return createControl().createMock(toMock);\n+    }\n+    \n+    /**\n+     * Creates a mock object that implements the given interface, order checking\n+     * is disabled by default.\n+     * @param name the name of the mock object.\n+     * @param toMock\n+     *            the class of the interface that the mock object should\n+     *            implement.\n+     * \n+     * @param <T>\n+     *            the interface that the mock object should implement.\n+     * @return the mock object.\n+     * @throws IllegalArgumentException if the name is not a valid Java identifier.\n+     */\n+    public static <T> T createMock(String name, Class<T> toMock) {\n+        return createControl().createMock(name, toMock);\n+    }\n+    \n+    /**\n+     * Creates a mock object that implements the given interface, order checking\n+     * is disabled by default, and the mock object will return <code>0</code>,\n+     * <code>null</code> or <code>false</code> for unexpected invocations.\n+     * \n+     * @param <T>\n+     *            the interface that the mock object should implement.\n+     * @param toMock\n+     *            the class of the interface that the mock object should\n+     *            implement.\n+     * @return the mock object.\n+     */\n+    public static <T> T createNiceMock(Class<T> toMock) {\n+        return createNiceControl().createMock(toMock);\n+    }\n+\n+    /**\n+     * Creates a mock object that implements the given interface, order checking\n+     * is disabled by default, and the mock object will return <code>0</code>,\n+     * <code>null</code> or <code>false</code> for unexpected invocations.\n+     * @param name the name of the mock object.\n+     * @param toMock\n+     *            the class of the interface that the mock object should\n+     *            implement.\n+     * \n+     * @param <T>\n+     *            the interface that the mock object should implement.\n+     * @return the mock object.\n+     * @throws IllegalArgumentException if the name is not a valid Java identifier.\n+     */\n+    public static <T> T createNiceMock(String name, Class<T> toMock) {\n+        return createNiceControl().createMock(name, toMock);\n+    }\n+    \n+    /**\n+     * Creates a control, order checking is enabled by default.\n+     * \n+     * @return the control.\n+     */\n+    public static IMocksControl createStrictControl() {\n+        return new MocksControl(MocksControl.MockType.STRICT);\n+    }\n+\n+    /**\n+     * Creates a control, order checking is disabled by default.\n+     * \n+     * @return the control.\n+     */\n+    public static IMocksControl createControl() {\n+        return new MocksControl(MocksControl.MockType.DEFAULT);\n+    }\n+    \n+    /**\n+     * Creates a control, order checking is disabled by default, and the mock\n+     * objects created by this control will return <code>0</code>,\n+     * <code>null</code> or <code>false</code> for unexpected invocations.\n+     * \n+     * @return the control.\n+     */\n+    public static IMocksControl createNiceControl() {\n+        return new MocksControl(MocksControl.MockType.NICE);\n+    }\n+\n+    /**\n+     * Returns the expectation setter for the last expected invocation in the\n+     * current thread.\n+     * \n+     * @param value\n+     *            the parameter is used to transport the type to the\n+     *            ExpectationSetter. It allows writing the expected call as\n+     *            argument, i.e.\n+     *            <code>expect(mock.getName()).andReturn(\"John Doe\")<code>.\n+     * \n+     * @return the expectation setter.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> IExpectationSetters<T> expect(T value) {\n+        return getControlForLastCall();\n+    }\n+\n+    /**\n+     * Returns the expectation setter for the last expected invocation in the\n+     * current thread. This method is used for expected invocations on void\n+     * methods.\n+     * \n+     * @return the expectation setter.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static IExpectationSetters<Object> expectLastCall() {\n+        return getControlForLastCall();\n+    }\n+\n+    private static IExpectationSetters getControlForLastCall() {\n+        MocksControl lastControl = LastControl.lastControl();\n+        if (lastControl == null) {\n+            throw new IllegalStateException(\"no last call on a mock available\");\n+        }\n+        return lastControl;\n+    }\n+\n+    /**\n+     * Expects any boolean argument. For details, see the EasyMock\n+     * documentation.\n+     * \n+     * @return <code>false</code>.\n+     */\n+    public static boolean anyBoolean() {\n+        reportMatcher(Any.ANY);\n+        return false;\n+    }\n+\n+    /**\n+     * Expects any byte argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static byte anyByte() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any char argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static char anyChar() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any int argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static int anyInt() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any long argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static long anyLong() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any float argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static float anyFloat() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any double argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static double anyDouble() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any short argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>0</code>.\n+     */\n+    public static short anyShort() {\n+        reportMatcher(Any.ANY);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects any Object argument. For details, see the EasyMock documentation.\n+     * \n+     * @return <code>null</code>.\n+     */\n+    public static Object anyObject() {\n+        reportMatcher(Any.ANY);\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a comparable argument greater than or equal the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T extends Comparable<T>> T geq(Comparable<T> value) {\n+        reportMatcher(new GreaterOrEqual<T>(value));\n+        return null;\n+    }\n+    \n+    /**\n+     * Expects a byte argument greater than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static byte geq(byte value) {\n+        reportMatcher(new GreaterOrEqual<Byte>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double argument greater than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static double geq(double value) {\n+        reportMatcher(new GreaterOrEqual<Double>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float argument greater than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static float geq(float value) {\n+        reportMatcher(new GreaterOrEqual<Float>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int argument greater than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static int geq(int value) {\n+        reportMatcher(new GreaterOrEqual<Integer>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long argument greater than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static long geq(long value) {\n+        reportMatcher(new GreaterOrEqual<Long>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short argument greater than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static short geq(short value) {\n+        reportMatcher(new GreaterOrEqual<Short>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a comparable argument less than or equal the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T extends Comparable<T>> T leq(Comparable<T> value) {\n+        reportMatcher(new LessOrEqual<T>(value));\n+        return null;\n+    }\n+     \n+    /**\n+     * Expects a byte argument less than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static byte leq(byte value) {\n+        reportMatcher(new LessOrEqual<Byte>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double argument less than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static double leq(double value) {\n+        reportMatcher(new LessOrEqual<Double>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float argument less than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static float leq(float value) {\n+        reportMatcher(new LessOrEqual<Float>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int argument less than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static int leq(int value) {\n+        reportMatcher(new LessOrEqual<Integer>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long argument less than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static long leq(long value) {\n+        reportMatcher(new LessOrEqual<Long>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short argument less than or equal to the given value. For\n+     * details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static short leq(short value) {\n+        reportMatcher(new LessOrEqual<Short>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a comparable argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T extends Comparable<T>> T gt(Comparable<T> value) {\n+        reportMatcher(new GreaterThan<T>(value));\n+        return null;\n+    }\n+    \n+    /**\n+     * Expects a byte argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static byte gt(byte value) {\n+        reportMatcher(new GreaterThan<Byte>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static double gt(double value) {\n+        reportMatcher(new GreaterThan<Double>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static float gt(float value) {\n+        reportMatcher(new GreaterThan<Float>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static int gt(int value) {\n+        reportMatcher(new GreaterThan<Integer>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static long gt(long value) {\n+        reportMatcher(new GreaterThan<Long>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short argument greater than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static short gt(short value) {\n+        reportMatcher(new GreaterThan<Short>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a comparable argument less than the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T extends Comparable<T>> T lt(Comparable<T> value) {\n+        reportMatcher(new LessThan<T>(value));\n+        return null;\n+    }\n+    \n+    /**\n+     * Expects a byte argument less than the given value. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static byte lt(byte value) {\n+        reportMatcher(new LessThan<Byte>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double argument less than the given value. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static double lt(double value) {\n+        reportMatcher(new LessThan<Double>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float argument less than the given value. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static float lt(float value) {\n+        reportMatcher(new LessThan<Float>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int argument less than the given value. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static int lt(int value) {\n+        reportMatcher(new LessThan<Integer>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long argument less than the given value. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static long lt(long value) {\n+        reportMatcher(new LessThan<Long>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short argument less than the given value. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static short lt(short value) {\n+        reportMatcher(new LessThan<Short>(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an object implementing the given class. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param <T>\n+     *            the accepted type.\n+     * @param clazz\n+     *            the class of the accepted type.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T isA(Class<T> clazz) {\n+        reportMatcher(new InstanceOf(clazz));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a string that contains the given substring. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param substring\n+     *            the substring.\n+     * @return <code>null</code>.\n+     */\n+    public static String contains(String substring) {\n+        reportMatcher(new Contains(substring));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a boolean that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>false</code>.\n+     */\n+    public static boolean and(boolean first, boolean second) {\n+        LastArguments.reportAnd(2);\n+        return false;\n+    }\n+\n+    /**\n+     * Expects a byte that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static byte and(byte first, byte second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a char that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static char and(char first, char second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static double and(double first, double second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static float and(float first, float second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static int and(int first, int second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static long and(long first, long second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short that matches both given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static short and(short first, short second) {\n+        LastArguments.reportAnd(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an Object that matches both given expectations.\n+     * \n+     * @param <T>\n+     *            the type of the object, it is passed through to prevent casts.\n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T and(T first, T second) {\n+        LastArguments.reportAnd(2);\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a boolean that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>false</code>.\n+     */\n+    public static boolean or(boolean first, boolean second) {\n+        LastArguments.reportOr(2);\n+        return false;\n+    }\n+\n+    /**\n+     * Expects a byte that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static byte or(byte first, byte second) {\n+        LastArguments.reportOr(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a char that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static char or(char first, char second) {\n+        LastArguments.reportOr(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static double or(double first, double second) {\n+        LastArguments.reportOr(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static float or(float first, float second) {\n+        LastArguments.reportOr(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static int or(int first, int second) {\n+        LastArguments.reportOr(2);\n+        return first;\n+    }\n+\n+    /**\n+     * Expects a long that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static long or(long first, long second) {\n+        LastArguments.reportOr(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short that matches one of the given expectations.\n+     * \n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static short or(short first, short second) {\n+        LastArguments.reportOr(2);\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an Object that matches one of the given expectations.\n+     * \n+     * @param <T>\n+     *            the type of the object, it is passed through to prevent casts.\n+     * @param first\n+     *            placeholder for the first expectation.\n+     * @param second\n+     *            placeholder for the second expectation.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T or(T first, T second) {\n+        LastArguments.reportOr(2);\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a boolean that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>false</code>.\n+     */\n+    public static boolean not(boolean first) {\n+        LastArguments.reportNot();\n+        return false;\n+    }\n+\n+    /**\n+     * Expects a byte that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static byte not(byte first) {\n+        LastArguments.reportNot();\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a char that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static char not(char first) {\n+        LastArguments.reportNot();\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static double not(double first) {\n+        LastArguments.reportNot();\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static float not(float first) {\n+        LastArguments.reportNot();\n+        return first;\n+    }\n+\n+    /**\n+     * Expects an int that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static int not(int first) {\n+        LastArguments.reportNot();\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static long not(long first) {\n+        LastArguments.reportNot();\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short that does not match the given expectation.\n+     * \n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>0</code>.\n+     */\n+    public static short not(short first) {\n+        LastArguments.reportNot();\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an Object that does not match the given expectation.\n+     * \n+     * @param <T>\n+     *            the type of the object, it is passed through to prevent casts.\n+     * @param first\n+     *            placeholder for the expectation.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T not(T first) {\n+        LastArguments.reportNot();\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a boolean that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static boolean eq(boolean value) {\n+        reportMatcher(new Equals(value));\n+        return false;\n+    }\n+\n+    /**\n+     * Expects a byte that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static byte eq(byte value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a char that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static char eq(char value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a double that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static double eq(double value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static float eq(float value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an int that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static int eq(int value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a long that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static long eq(long value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a short that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>0</code>.\n+     */\n+    public static short eq(short value) {\n+        reportMatcher(new Equals(value));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an Object that is equal to the given value.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T eq(T value) {\n+        reportMatcher(new Equals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a boolean array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static boolean[] aryEq(boolean[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a byte array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static byte[] aryEq(byte[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a char array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static char[] aryEq(char[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a double array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static double[] aryEq(double[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a float array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static float[] aryEq(float[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects an int array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static int[] aryEq(int[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a long array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static long[] aryEq(long[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a short array that is equal to the given array, i.e. it has to\n+     * have the same length, and each element has to be equal.\n+     * \n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static short[] aryEq(short[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects an Object array that is equal to the given array, i.e. it has to\n+     * have the same type, length, and each element has to be equal.\n+     * \n+     * @param <T>\n+     *            the type of the array, it is passed through to prevent casts.\n+     * @param value\n+     *            the given arry.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T[] aryEq(T[] value) {\n+        reportMatcher(new ArrayEquals(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects null.\n+     * \n+     * @return <code>null</code>.\n+     */\n+    public static Object isNull() {\n+        reportMatcher(Null.NULL);\n+        return null;\n+    }\n+\n+    /**\n+     * Expects not null.\n+     * \n+     * @return <code>null</code>.\n+     */\n+    public static Object notNull() {\n+        reportMatcher(NotNull.NOT_NULL);\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a string that contains a substring that matches the given regular\n+     * expression. For details, see the EasyMock documentation.\n+     * \n+     * @param regex\n+     *            the regular expression.\n+     * @return <code>null</code>.\n+     */\n+    public static String find(String regex) {\n+        reportMatcher(new Find(regex));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a string that matches the given regular expression. For details,\n+     * see the EasyMock documentation.\n+     * \n+     * @param regex\n+     *            the regular expression.\n+     * @return <code>null</code>.\n+     */\n+    public static String matches(String regex) {\n+        reportMatcher(new Matches(regex));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a string that starts with the given prefix. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param prefix\n+     *            the prefix.\n+     * @return <code>null</code>.\n+     */\n+    public static String startsWith(String prefix) {\n+        reportMatcher(new StartsWith(prefix));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a string that ends with the given suffix. For details, see the\n+     * EasyMock documentation.\n+     * \n+     * @param suffix\n+     *            the suffix.\n+     * @return <code>null</code>.\n+     */\n+    public static String endsWith(String suffix) {\n+        reportMatcher(new EndsWith(suffix));\n+        return null;\n+    }\n+\n+    /**\n+     * Expects a double that has an absolute difference to the given value that\n+     * is less than the given delta. For details, see the EasyMock\n+     * documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @param delta\n+     *            the given delta.\n+     * @return <code>0</code>.\n+     */\n+    public static double eq(double value, double delta) {\n+        reportMatcher(new EqualsWithDelta(value, delta));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects a float that has an absolute difference to the given value that\n+     * is less than the given delta. For details, see the EasyMock\n+     * documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @param delta\n+     *            the given delta.\n+     * @return <code>0</code>.\n+     */\n+    public static float eq(float value, float delta) {\n+        reportMatcher(new EqualsWithDelta(value, delta));\n+        return 0;\n+    }\n+\n+    /**\n+     * Expects an Object that is the same as the given value. For details, see\n+     * the EasyMock documentation.\n+     * \n+     * @param <T>\n+     *            the type of the object, it is passed through to prevent casts.\n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T> T same(T value) {\n+        reportMatcher(new Same(value));\n+        return null;\n+    }\n+\n+    /**\n+     * Switches the given mock objects (more exactly: the controls of the mock\n+     * objects) to replay mode. For details, see the EasyMock documentation.\n+     * \n+     * @param mocks\n+     *            the mock objects.\n+     */\n+    public static void replay(Object... mocks) {\n+        for (Object mock : mocks) {\n+        \tClassExtensionHelper.getControl(mock).replay();\n+        }\n+    }\n+\n+    /**\n+     * Resets the given mock objects (more exactly: the controls of the mock\n+     * objects). For details, see the EasyMock documentation.\n+     * \n+     * @param mocks\n+     *            the mock objects.\n+     */\n+    public static void reset(Object... mocks) {\n+        for (Object mock : mocks) {\n+        \tClassExtensionHelper.getControl(mock).reset();\n+        }\n+    }\n+\n+    /**\n+     * Verifies the given mock objects (more exactly: the controls of the mock\n+     * objects).\n+     * \n+     * @param mocks\n+     *            the mock objects.\n+     */\n+    public static void verify(Object... mocks) {\n+        for (Object mock : mocks) {\n+        \tClassExtensionHelper.getControl(mock).verify();\n+        }\n+    }\n+\n+    /**\n+     * Switches order checking of the given mock object (more exactly: the\n+     * control of the mock object) the on and off. For details, see the EasyMock\n+     * documentation.\n+     * \n+     * @param mock\n+     *            the mock object.\n+     * @param state\n+     *            <code>true</code> switches order checking on,\n+     *            <code>false</code> switches it off.\n+     */\n+    public static void checkOrder(Object mock, boolean state) {\n+    \tClassExtensionHelper.getControl(mock).checkOrder(state);\n+    }\n+\n+    /**\n+     * Reports an argument matcher. This method is needed to define own argument\n+     * matchers. For details, see the EasyMock documentation.\n+     * \n+     * @param matcher\n+     */\n+    public static void reportMatcher(IArgumentMatcher matcher) {\n+        LastArguments.reportMatcher(matcher);\n+    }\n+\n+    private static MocksControl getControl(Object mock) {\n+        return ((ObjectMethodsFilter<MockInvocationHandler>) Proxy\n+        .getInvocationHandler(mock)).getDelegate().getControl();\n+    }\n+\n+    /**\n+     * Returns the arguments of the current mock method call, if inside an\n+     * <code>IAnswer</code> callback - be careful here, reordering parameters of  \n+     * method changes the semantics of your tests.\n+     * \n+     * @return the arguments of the current mock method call.\n+     * @throws IllegalStateException\n+     *             if called outside of <code>IAnswer</code> callbacks.\n+     */\n+    public static Object[] getCurrentArguments() {\n+        Object[] result = LastArguments.getCurrentArguments();\n+        if (result == null) {\n+            throw new IllegalStateException(\n+                    \"current arguments are only available when executing callback methods\");\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Expects a comparable argument equals to the given value according to their\n+     * compareTo method. For details, see the EasyMock documentation.\n+     * \n+     * @param value\n+     *            the given value.\n+     * @return <code>null</code>.\n+     */\n+    public static <T extends Comparable<T>> T cmpEq(Comparable<T> value) {\n+        reportMatcher(new CompareEqual<T>(value));\n+        return null;\n+    }\n+    \n+    /**\n+     * Expects an argument that will be compared using the provided comparator.\n+     * The following comparison will take place:\n+     * <p>\n+     * <code>comparator.compare(actual, expected) operator 0</code>\n+     * </p>\n+     * For details, see the EasyMock documentation.\n+     * \n+     * @param value the given value.\n+     * @param comparator Comparator used to compare the actual with expected value.\n+     * @param operator The comparison operator.\n+     * @return <code>null</code>\n+     */\n+    public static <T> T cmp(T value, Comparator<T> comparator, LogicalOperator operator) {\n+        reportMatcher(new Compare<T>(value, comparator, operator));\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/IAnswer.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+import org.easymock.classextension.*;\n+\n+/**\n+ * Used to answer expected calls.\n+ * @param <T> the type to return.\n+ */\n+public interface IAnswer<T> {\n+    /**\n+     * is called by EasyMock to answer an expected call. \n+     * The answer may be to return a value, or to throw an exception.\n+     * The arguments of the call for which the answer is generated \n+     * are available via {@link EasyMock#getCurrentArguments()} - be careful\n+     * here, using the arguments is not refactoring-safe.\n+     * \n+     * @return the value to be returned\n+     * @throws Throwable the throwable to be thrown\n+     */\n+    T answer() throws Throwable;\n+}\n--- /dev/null\n+++ b/src/org/easymock/IArgumentMatcher.java\n+/*\n+ * Copyright (c) 2001-2006 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+/**\n+ * Decides whether an actual argument is accepted.\n+ */\n+public interface IArgumentMatcher {\n+    \n+    /**\n+     * Returns whether this matcher accepts the given argument. \n+     * <p>\n+     * Like Object.equals(), it should be aware that the argument passed might \n+     * be null and of any type. So you will usually start the method with an \n+     * instanceof and/or null check.\n+     * <p>\n+     * The method should <b>never</b> assert if the argument doesn't match. It\n+     * should only return false. EasyMock will take care of asserting if the\n+     * call is really unexpected.\n+     * \n+     * @param argument the argument\n+     * @return whether this matcher accepts the given argument.\n+     */\n+    boolean matches(Object argument);\n+\n+    /**\n+     * Appends a string representation of this matcher to the given buffer. In case\n+     * of failure, the printed message will show this string to allow to know which\n+     * matcher was used for the failing call.\n+     * \n+     * @param buffer the buffer to which the string representation is appended.\n+     */\n+    void appendTo(StringBuffer buffer);\n+}\n--- /dev/null\n+++ b/src/org/easymock/IExpectationSetters.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+import org.mockito.MockitoExpectation;\n+\n+/**\n+ * Allows setting expectations for an associated expected invocation.\n+ * Implementations of this interface are returned by\n+ * {@link EasyMock#expect(Object)}, and by {@link EasyMock#expectLastCall()}.\n+ */\n+public interface IExpectationSetters<T> {\n+\n+    /**\n+     * Sets a return value that will be returned for the expected invocation.\n+     * \n+     * @param value\n+     *            the value to return.\n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> andReturn(T value);\n+\n+    /**\n+     * Sets a throwable that will be thrown for the expected invocation.\n+     * \n+     * @param throwable\n+     *            the throwable to throw.\n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> andThrow(Throwable throwable);\n+\n+    /**\n+     * Sets an object that will be used to calculate the answer for the expected\n+     * invocation (either return a value, or throw an exception).\n+     * \n+     * @param answer\n+     *            the object used to answer the invocation.\n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> andAnswer(IAnswer<T> answer);\n+\n+    /**\n+     * Sets a stub return value that will be returned for the expected\n+     * invocation.\n+     * \n+     * @param value\n+     *            the value to return.\n+     */\n+    void andStubReturn(T value);\n+\n+    /**\n+     * Sets a stub throwable that will be thrown for the expected invocation.\n+     * \n+     * @param throwable\n+     *            the throwable to throw.\n+     */\n+    void andStubThrow(Throwable throwable);\n+\n+    /**\n+     * Sets a stub object that will be used to calculate the answer for the\n+     * expected invocation (either return a value, or throw an exception).\n+     * \n+     * @param answer\n+     *            the object used to answer the invocation.\n+     */\n+    void andStubAnswer(IAnswer<T> answer);\n+\n+    /**\n+     * Sets stub behavior for the expected invocation (this is needed for void\n+     * methods).\n+     */\n+    void asStub();\n+\n+    /**\n+     * Expect the last invocation <code>count</code> times.\n+     * \n+     * @param count\n+     *            the number of invocations expected.\n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> times(int count);\n+\n+    /**\n+     * Expect the last invocation between <code>min</code> and\n+     * <code>max</code> times.\n+     * \n+     * @param min\n+     *            the minimum number of invocations expected.\n+     * @param max\n+     *            the maximum number of invocations expected.\n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> times(int min, int max);\n+\n+    /**\n+     * Expect the last invocation once. This is default in EasyMock.\n+     * \n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> once();\n+\n+    /**\n+     * Expect the last invocation at least once.\n+     * \n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> atLeastOnce();\n+\n+    /**\n+     * Expect the last invocation any times.\n+     * \n+     * @return this object to allow method call chaining.\n+     */\n+    IExpectationSetters<T> anyTimes();\n+}\n--- /dev/null\n+++ b/src/org/easymock/IMocksControl.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+/**\n+ * Controls all the mock objects created by it.\n+ * For details, see the EasyMock documentation.\n+ */\n+public interface IMocksControl extends IExpectationSetters {\n+    /**\n+     * Creates a mock object that implements the given interface.\n+     * @param <T> the interface that the mock object should implement.\n+     * @param toMock the class of the interface that the mock object should implement.\n+     * @return the mock object.\n+     */\n+    <T> T createMock(Class<T> toMock);\n+\n+    /**\n+     * Creates a mock object that implements the given interface.\n+     * @param name the name of the mock object .\n+     * @param toMock the class of the interface that the mock object should implement.\n+     * @param <T> the interface that the mock object should implement.\n+     * @return the mock object.\n+     * @throws IllegalArgumentException if the name is not a valid Java identifier.\n+     */\n+    <T> T createMock(String name, Class<T> toMock);\n+\n+    /**\n+     * Removes all expectations for the mock objects of this control.\n+     */\n+    void reset();\n+\n+    /**\n+     * Switches the control from record mode to replay mode.\n+     */\n+    void replay();\n+\n+    /**\n+     * Verifies that all expectations were met. \n+     */\n+    void verify();\n+\n+    /**\n+     * Switches order checking on and off.\n+     * @param state <code>true</code> switches order checking on, <code>false</code> switches it off.\n+     */\n+    void checkOrder(boolean state);\n+}\n--- /dev/null\n+++ b/src/org/easymock/LogicalOperator.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Henri Tremblay.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+/**\n+ * See {@link EasyMock#cmp}\n+ */\n+public enum LogicalOperator {\n+    LESS_THAN(\"<\") {\n+        public boolean matchResult(int result) {\n+            return result < 0;\n+        }\n+    },\n+    LESS_OR_EQUAL(\"<=\") {\n+        public boolean matchResult(int result) {\n+            return result <= 0;\n+        }\n+    },\n+    EQUAL(\"==\") {\n+        public boolean matchResult(int result) {\n+            return result == 0;\n+        }\n+    },\n+    GREATER_OR_EQUAL(\">=\") {\n+        public boolean matchResult(int result) {\n+            return result >= 0;\n+        }\n+    },\n+    GREATER(\">\") {\n+        public boolean matchResult(int result) {\n+            return result > 0;\n+        }\n+    };\n+    \n+    private String symbol;\n+    \n+    private LogicalOperator(String symbol) {\n+        this.symbol = symbol;\n+    }\n+    \n+    public String getSymbol() {\n+        return symbol;\n+    }\n+    \n+    public abstract boolean matchResult(int result);\n+}\n--- /dev/null\n+++ b/src/org/easymock/MockClassControl.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+import static org.easymock.internal.ClassExtensionHelper.getInterceptor;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.MocksControl;\n+\n+/**\n+ * Instances of <code>MockClassControl</code> control the behavior of their\n+ * associated mock objects. For more information, see the EasyMock\n+ * documentation.\n+ * \n+ * @see <a href=\"http://www.easymock.org/\">EasyMock</a>\n+ * @deprecated Use org.easymock.classextension.EasyMock instead\n+ */\n+public class MockClassControl<T> extends MockControl<T> {\n+\n+    /**\n+     * Creates a mock control object for the specified class or interface. The\n+     * {@link MockClassControl}and its associated mock object will not check\n+     * the order of expected method calls. An unexpected method call on the mock\n+     * object will lead to an <code>AssertionFailedError</code>.\n+     * \n+     * @param classToMock\n+     *            the class to mock.\n+     * @return the mock control (which is a {@link MockClassControl}instance)\n+     */\n+    public static <T> MockControl<T> createControl(Class<T> classToMock) {\n+        return new MockClassControl<T>(\n+                (MocksControl) EasyMock.createControl(),\n+                classToMock);\n+    }\n+\n+    /**\n+     * Same as {@link #createControl(Class)}but allows to pass a list of\n+     * methods to mock. All the other methods won't be. It means that if these\n+     * methods are called, their real code will be executed.\n+     * \n+     * @param classToMock\n+     *            the class to mock\n+     * @param mockedMethods\n+     *            Methods to be mocked. If null, all methods will be mocked.\n+     * @return the mock control\n+     */\n+    public static <T> MockClassControl<T> createControl(Class<T> classToMock,\n+            Method[] mockedMethods) {\n+        return new MockClassControl<T>(\n+                (MocksControl) EasyMock.createControl(),\n+                classToMock, mockedMethods);\n+    }\n+\n+    /**\n+     * Creates a mock control object for the specified class or interface. The\n+     * {@link MockClassControl}and its associated mock object will check the\n+     * order of expected method calls. An unexpected method call on the mock\n+     * object will lead to an <code>AssertionFailedError</code>.\n+     * \n+     * @param classToMock\n+     *            the class to mock.\n+     * @return the mock control (which is a {@link MockClassControl}instance)\n+     */\n+    public static <T> MockControl<T> createStrictControl(Class<T> classToMock) {\n+        return new MockClassControl<T>(\n+                (MocksControl) EasyMock\n+                        .createStrictControl(), classToMock);\n+    }\n+\n+    /**\n+     * Same as {@link #createStrictControl(Class)}but allows to pass a list of\n+     * methods to mock. All the other methods won't be. It means that if these\n+     * methods are called, their real code will be executed.\n+     * \n+     * @param classToMock\n+     *            the class to mock\n+     * @param mockedMethods\n+     *            Methods to be mocked. If null, all methods will be mocked.\n+     * @return the mock control\n+     */\n+    public static <T> MockClassControl<T> createStrictControl(\n+            Class<T> classToMock, Method[] mockedMethods) {\n+        return new MockClassControl<T>(\n+                (MocksControl) EasyMock\n+                        .createStrictControl(), classToMock, mockedMethods);\n+    }\n+\n+    /**\n+     * Creates a mock control object for the specified class or interface. The\n+     * {@link MockClassControl}and its associated mock object will check not\n+     * the order of expected method calls. An unexpected method call on the mock\n+     * object will return an empty value (0, null, false).\n+     * \n+     * @param classToMock\n+     *            the class to mock.\n+     * @return the mock control (which is a {@link MockClassControl}instance)\n+     */\n+    public static <T> MockControl<T> createNiceControl(Class<T> classToMock) {\n+        return new MockClassControl<T>(\n+                (MocksControl) EasyMock.createNiceControl(),\n+                classToMock);\n+    }\n+\n+    /**\n+     * Same as {@link #createNiceControl(Class, Method[])}but allows to pass a\n+     * list of methods to mock. All the other methods won't be. It means that if\n+     * these methods are called, their real code will be executed.\n+     * \n+     * @param classToMock\n+     *            the class to mock\n+     * @param mockedMethods\n+     *            Methods to be mocked. If null, all methods will be mocked.\n+     * @return the mock control\n+     */\n+    public static <T> MockClassControl<T> createNiceControl(\n+            Class<T> classToMock, Method[] mockedMethods) {\n+        return new MockClassControl<T>(\n+                (MocksControl) EasyMock.createNiceControl(),\n+                classToMock, mockedMethods);\n+    }\n+\n+    /**\n+     * @deprecated No need to pick a constructor anymore. Constructor arguments\n+     *             are now ignored. Just use {@link #createControl(Class)}\n+     */\n+    public static <T> MockClassControl<T> createControl(Class<T> classToMock,\n+            Class[] constructorTypes, Object[] constructorArgs) {\n+        return (MockClassControl<T>) createControl(classToMock);\n+    }\n+\n+    /**\n+     * @deprecated No need to pick a constructor anymore. Constructor arguments\n+     *             are now ignored. Just use\n+     *             {@link #createControl(Class, Method[])}\n+     */\n+    public static <T> MockClassControl<T> createControl(Class<T> classToMock,\n+            Class[] constructorTypes, Object[] constructorArgs,\n+            Method[] mockedMethods) {\n+        return (MockClassControl<T>) createControl(classToMock, mockedMethods);\n+    }\n+\n+    /**\n+     * @deprecated No need to pick a constructor anymore. Constructor arguments\n+     *             are now ignored. Just use {@link #createStrictControl(Class)}\n+     */\n+    public static <T> MockClassControl<T> createStrictControl(\n+            Class<T> classToMock, Class[] constructorTypes,\n+            Object[] constructorArgs) {\n+        return (MockClassControl<T>) createStrictControl(classToMock);\n+    }\n+\n+    /**\n+     * @deprecated No need to pick a constructor anymore. Constructor arguments\n+     *             are now ignored. Just use\n+     *             {@link #createStrictControl(Class, Method[])}\n+     */\n+    public static <T> MockClassControl<T> createStrictControl(\n+            Class<T> classToMock, Class[] constructorTypes,\n+            Object[] constructorArgs, Method[] mockedMethods) {\n+        return (MockClassControl<T>) createStrictControl(classToMock,\n+                mockedMethods);\n+    }\n+\n+    /**\n+     * @deprecated No need to pick a constructor anymore. Constructor arguments\n+     *             are now ignored. Just use {@link #createNiceControl(Class)}\n+     */\n+    public static <T> MockClassControl<T> createNiceControl(\n+            Class<T> classToMock, Class[] constructorTypes,\n+            Object[] constructorArgs) {\n+        return (MockClassControl<T>) createNiceControl(classToMock);\n+    }\n+\n+    /**\n+     * @deprecated No need to pick a constructor anymore. Constructor arguments\n+     *             are now ignored. Just use\n+     *             {@link #createNiceControl(Class, Method[])}\n+     */\n+    public static <T> MockClassControl<T> createNiceControl(\n+            Class<T> classToMock, Class[] constructorTypes,\n+            Object[] constructorArgs, Method[] mockedMethods) {\n+        return (MockClassControl<T>) createNiceControl(classToMock,\n+                mockedMethods);\n+    }\n+\n+    private MockClassControl(MocksControl ctrl, Class<T> classToMock,\n+            Method[] mockedMethods) {\n+        super(ctrl, classToMock);\n+        // Set the mocked methods on the interceptor\n+        getInterceptor(getMock()).setMockedMethods(mockedMethods);\n+    }\n+\n+    private MockClassControl(MocksControl ctrl, Class<T> classToMock) {\n+        super(ctrl, classToMock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/MockControl.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock;\n+\n+import static org.easymock.EasyMock.expect;\n+\n+import org.easymock.classextension.*;\n+import org.easymock.internal.*;\n+\n+/**\n+ * A <code>MockControl</code> object controls the behavior of its associated\n+ * mock object. For more information, see the EasyMock documentation.\n+ * \n+ * @deprecated Since EasyMock 2.0, static methods on <code>EasyMock</code> are\n+ * used to create and control mock objects.\n+ */\n+public class MockControl<T> {\n+    private final T mock;\n+\n+    private final MocksControl ctrl;\n+\n+    protected MockControl(MocksControl ctrl, Class<T> toMock) {\n+        this.ctrl = ctrl;\n+        this.mock = ctrl.createMock(toMock);\n+    }\n+\n+    /**\n+     * Creates a mock control object for the specified interface. The\n+     * <code>MockControl</code> and its associated mock object will not check\n+     * the order of expected method calls. An unexpected method call on the mock\n+     * object will lead to an <code>AssertionError</code>.\n+     * \n+     * @param toMock\n+     *            the class of the interface to mock.\n+     * @return the mock control.\n+     */\n+    public static <T> MockControl<T> createControl(Class<T> toMock) {\n+        return new MockControl<T>((MocksControl) EasyMock.createControl(),\n+                toMock);\n+    }\n+\n+    /**\n+     * Creates a mock control object for the specified interface. The\n+     * <code>MockControl</code> and its associated mock object will check the\n+     * order of expected method calls. An unexpected method call on the mock\n+     * object will lead to an <code>AssertionError</code>.\n+     * \n+     * @param toMock\n+     *            the class of the interface to mock.\n+     * @return the mock control.\n+     */\n+    public static <T> MockControl<T> createStrictControl(Class<T> toMock) {\n+        return new MockControl<T>(\n+                (MocksControl) EasyMock.createStrictControl(), toMock);\n+    }\n+\n+    /**\n+     * Creates a mock control object for the specified interface. The\n+     * <code>MockControl</code> and its associated mock object will not check\n+     * the order of expected method calls. An unexpected method call on the mock\n+     * object will return an empty value (0, null, false).\n+     * \n+     * @param toMock\n+     *            the class of the interface to mock.\n+     * @return the mock control.\n+     */\n+    public static <T> MockControl<T> createNiceControl(Class<T> toMock) {\n+        return new MockControl<T>((MocksControl) EasyMock.createNiceControl(),\n+                toMock);\n+    }\n+\n+    /**\n+     * Returns the mock object.\n+     * \n+     * @return the mock object of this control\n+     */\n+    public T getMock() {\n+        return mock;\n+    }\n+\n+    /**\n+     * Resets the mock control and the mock object to the state directly after\n+     * creation.\n+     */\n+    public final void reset() {\n+        ctrl.reset();\n+    }\n+\n+    /**\n+     * Switches the mock object from record state to replay state. For more\n+     * information, see the EasyMock documentation.\n+     * \n+     * @throws IllegalStateException\n+     *             if the mock object already is in replay state.\n+     */\n+    public void replay() {\n+        ctrl.replay();\n+    }\n+\n+    /**\n+     * Verifies that all expectations have been met. For more information, see\n+     * the EasyMock documentation.\n+     * \n+     * @throws IllegalStateException\n+     *             if the mock object is in record state.\n+     * @throws AssertionError\n+     *             if any expectation has not been met.\n+     */\n+    public void verify() {\n+        ctrl.verify();\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call once, and\n+     * will react by returning silently.\n+     * \n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state, if no method was\n+     *                called on the mock object before, or if the last method\n+     *                called on the mock was no void method.\n+     */\n+    public void setVoidCallable() {\n+        expectLastCall(\n+                \"method call on the mock needed before setting void callable\")\n+                .once();\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call once, and\n+     * will react by throwing the provided Throwable.\n+     * \n+     * @param throwable\n+     *            the Throwable to throw.\n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state or if no method was\n+     *                called on the mock object before.\n+     * @exception IllegalArgumentException\n+     *                if the last method called on the mock cannot throw the\n+     *                provided Throwable.\n+     * @exception NullPointerException\n+     *                if throwable is null.\n+     */\n+    public void setThrowable(Throwable throwable) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting Throwable\")\n+                .andThrow(throwable).once();\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call once, and\n+     * will react by returning the provided return value.\n+     * \n+     * @param value\n+     *            the return value.\n+     * @throws IllegalStateException\n+     *             if the mock object is in replay state, if no method was\n+     *             called on the mock object before. or if the last method\n+     *             called on the mock does not return <code>boolean</code>.\n+     */\n+    public void setReturnValue(Object value) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting return value\")\n+                .andReturn(value).once();\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call a fixed\n+     * number of times, and will react by returning silently.\n+     * \n+     * @param times\n+     *            the number of times that the call is expected.\n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state, if no method was\n+     *                called on the mock object before, or if the last method\n+     *                called on the mock was no void method.\n+     */\n+    public void setVoidCallable(int times) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting void callable\")\n+                .times(times);\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call a fixed\n+     * number of times, and will react by throwing the provided Throwable.\n+     * \n+     * @param throwable\n+     *            the Throwable to throw.\n+     * @param times\n+     *            the number of times that the call is expected.\n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state or if no method was\n+     *                called on the mock object before.\n+     * @exception IllegalArgumentException\n+     *                if the last method called on the mock cannot throw the\n+     *                provided Throwable.\n+     * @exception NullPointerException\n+     *                if throwable is null.\n+     */\n+    public void setThrowable(Throwable throwable, int times) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting Throwable\")\n+                .andThrow(throwable).times(times);\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call a fixed\n+     * number of times, and will react by returning the provided return value.\n+     * \n+     * @param value\n+     *            the return value.\n+     * @param times\n+     *            the number of times that the call is expected.\n+     * @throws IllegalStateException\n+     *             if the mock object is in replay state, if no method was\n+     *             called on the mock object before. or if the last method\n+     *             called on the mock does not return <code>boolean</code>.\n+     */\n+    public void setReturnValue(Object value, int times) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting return value\")\n+                .andReturn(value).times(times);\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call a fixed\n+     * number of times, and will react by returning the provided return value.\n+     * \n+     * @param value\n+     *            the return value.\n+     * @param range\n+     *            the number of times that the call is expected.\n+     * @throws IllegalStateException\n+     *             if the mock object is in replay state, if no method was\n+     *             called on the mock object before. or if the last method\n+     *             called on the mock does not return <code>boolean</code>.\n+     */\n+    public void setReturnValue(Object value, Range range) {\n+        IExpectationSetters setter = expectLastCall(\n+                \"method call on the mock needed before setting return value\")\n+                .andReturn(value);\n+        callWithConvertedRange(setter, range);\n+    }\n+\n+    /**\n+     * Records that the mock object will by default allow the last method\n+     * specified by a method call.\n+     * \n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state, if no method was\n+     *                called on the mock object before, or if the last method\n+     *                called on the mock was no void method.\n+     */\n+    public void setDefaultVoidCallable() {\n+        ((MocksControl) expectLastCall(\"method call on the mock needed before setting default void callable\"))\n+                .setLegacyDefaultVoidCallable();\n+    }\n+\n+    /**\n+     * Records that the mock object will by default allow the last method\n+     * specified by a method call, and will react by throwing the provided\n+     * Throwable.\n+     * \n+     * @param throwable\n+     *            throwable the throwable to be thrown\n+     * @exception IllegalArgumentException\n+     *                if the last method called on the mock cannot throw the\n+     *                provided Throwable.\n+     * @exception NullPointerException\n+     *                if throwable is null.\n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state, or if no method was\n+     *                called on the mock object before.\n+     */\n+    public void setDefaultThrowable(Throwable throwable) {\n+        ctrl.setLegacyDefaultThrowable(throwable);\n+    }\n+\n+    /**\n+     * Records that the mock object will by default allow the last method\n+     * specified by a method call, and will react by returning the provided\n+     * return value.\n+     * \n+     * @param value\n+     *            the return value.\n+     * @throws IllegalStateException\n+     *             if the mock object is in replay state, if no method was\n+     *             called on the mock object before. or if the last method\n+     *             called on the mock does not return <code>boolean</code>.\n+     */\n+    public void setDefaultReturnValue(Object value) {\n+        ctrl.setLegacyDefaultReturnValue(value);\n+    }\n+\n+    /**\n+     * Sets the ArgumentsMatcher for the last method called on the mock object.\n+     * The matcher must be set before any behavior for the method is defined.\n+     * \n+     * @throws IllegalStateException\n+     *             if called in replay state, or if no method was called on the\n+     *             mock object before.\n+     */\n+    public void setMatcher(ArgumentsMatcher matcher) {\n+        ctrl.setLegacyMatcher(matcher);\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call between\n+     * <code>minCount</code> and <code>maxCount</code> times, and will react\n+     * by returning silently.\n+     * \n+     * @param minCount\n+     *            the minimum number of times that the call is expected.\n+     * @param maxCount\n+     *            the maximum number of times that the call is expected.\n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state, if no method was\n+     *                called on the mock object before, or if the last method\n+     *                called on the mock was no void method.\n+     */\n+    public void setVoidCallable(int minCount, int maxCount) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting void callable\")\n+                .times(minCount, maxCount);\n+    }\n+\n+    public void setVoidCallable(Range range) {\n+        IExpectationSetters setter = expectLastCall(\"method call on the mock needed before setting void callable\");\n+        callWithConvertedRange(setter, range);\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call between\n+     * <code>minCount</code> and <code>maxCount</code> times, and will react\n+     * by throwing the provided Throwable.\n+     * \n+     * @param throwable\n+     *            the Throwable to throw.\n+     * @param minCount\n+     *            the minimum number of times that the call is expected.\n+     * @param maxCount\n+     *            the maximum number of times that the call is expected.\n+     * @exception IllegalStateException\n+     *                if the mock object is in replay state or if no method was\n+     *                called on the mock object before.\n+     * @exception IllegalArgumentException\n+     *                if the last method called on the mock cannot throw the\n+     *                provided Throwable.\n+     * @exception NullPointerException\n+     *                if throwable is null.\n+     */\n+    public void setThrowable(Throwable throwable, int minCount, int maxCount) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting Throwable\")\n+                .andThrow(throwable).times(minCount, maxCount);\n+    }\n+\n+    public void setThrowable(Throwable throwable, Range range) {\n+        IExpectationSetters setter = expectLastCall(\n+                \"method call on the mock needed before setting Throwable\")\n+                .andThrow(throwable);\n+        callWithConvertedRange(setter, range);\n+    }\n+\n+    /**\n+     * Records that the mock object will expect the last method call between\n+     * <code>minCount</code> and <code>maxCount</code> times, and will react\n+     * by returning the provided return value.\n+     * \n+     * @param value\n+     *            the return value.\n+     * @param minCount\n+     *            the minimum number of times that the call is expected.\n+     * @param maxCount\n+     *            the maximum number of times that the call is expected.\n+     * @throws IllegalStateException\n+     *             if the mock object is in replay state, if no method was\n+     *             called on the mock object before. or if the last method\n+     *             called on the mock does not return <code>boolean</code>.\n+     */\n+    public void setReturnValue(Object value, int minCount, int maxCount) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting return value\")\n+                .andReturn(value).times(minCount, maxCount);\n+    }\n+\n+    /**\n+     * Exactly one call.\n+     */\n+    public static final Range ONE = MocksControl.ONCE;\n+\n+    /**\n+     * One or more calls.\n+     */\n+    public static final Range ONE_OR_MORE = MocksControl.AT_LEAST_ONCE;\n+\n+    /**\n+     * Zero or more calls.\n+     */\n+    public static final Range ZERO_OR_MORE = MocksControl.ZERO_OR_MORE;\n+\n+    /**\n+     * Matches if each expected argument is equal to the corresponding actual\n+     * argument.\n+     */\n+    public static final ArgumentsMatcher EQUALS_MATCHER = new EqualsMatcher();\n+\n+    /**\n+     * Matches always.\n+     */\n+    public static final ArgumentsMatcher ALWAYS_MATCHER = new AlwaysMatcher();\n+\n+    /**\n+     * Matches if each expected argument is equal to the corresponding actual\n+     * argument for non-array arguments; array arguments are compared with the\n+     * appropriate <code>java.util.Arrays.equals()</code> -method.\n+     */\n+    public static final ArgumentsMatcher ARRAY_MATCHER = new ArrayMatcher();\n+\n+    /**\n+     * Sets the default ArgumentsMatcher for all methods of the mock object. The\n+     * matcher must be set before any behavior is defined on the mock object.\n+     * \n+     * @throws IllegalStateException\n+     *             if called in replay state, or if any behavior is already\n+     *             defined on the mock object.\n+     */\n+    public void setDefaultMatcher(ArgumentsMatcher matcher) {\n+        ctrl.setLegacyDefaultMatcher(matcher);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setReturnValue(Object)}. For explanation, see\n+     * \"Convenience Methods for Return Values\" in the EasyMock documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public <V1, V2 extends V1> void expectAndReturn(V1 ignored, V2 value) {\n+        EasyMock.expectLastCall().andReturn(value).once();\n+    }\n+\n+    public void expectAndReturn(int ignored, int value) {\n+        this.expectAndReturn((Object) ignored, (Object) value);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setReturnValue(Object, Range)}. For\n+     * explanation, see \"Convenience Methods for Return Values\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public <V1, V2 extends V1> void expectAndReturn(V1 ignored, V2 value,\n+            Range range) {\n+        IExpectationSetters expectAndReturn = EasyMock.expectLastCall()\n+                .andReturn(value);\n+        callWithConvertedRange(expectAndReturn, range);\n+    }\n+\n+    public void expectAndReturn(int ignored, int value, Range range) {\n+        this.expectAndReturn((Object) ignored, (Object) value, range);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setReturnValue(Object, int)}. For\n+     * explanation, see \"Convenience Methods for Return Values\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public <V1, V2 extends V1> void expectAndReturn(V1 ignored, V2 value,\n+            int count) {\n+        EasyMock.expectLastCall().andReturn(value).times(count);\n+    }\n+\n+    public void expectAndReturn(int ignored, int value, int count) {\n+        this.expectAndReturn((Object) ignored, (Object) value, count);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setReturnValue(Object, int, int)}. For\n+     * explanation, see \"Convenience Methods for Return Values\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public <V1, V2 extends V1> void expectAndReturn(V1 ignored, V2 value,\n+            int min, int max) {\n+        EasyMock.expectLastCall().andReturn(value).times(min, max);\n+    }\n+\n+    public void expectAndReturn(int ignored, int value, int min, int max) {\n+        this.expectAndReturn((Object) ignored, (Object) value, min, max);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setThrowable(Throwable)}. For explanation,\n+     * see \"Convenience Methods for Throwables\" in the EasyMock documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public void expectAndThrow(Object ignored, Throwable throwable) {\n+        EasyMock.expect(ignored).andThrow(throwable).once();\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setThrowable(Throwable, Range)}. For\n+     * explanation, see \"Convenience Methods for Throwables\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public void expectAndThrow(Object ignored, Throwable throwable, Range range) {\n+        IExpectationSetters setter = EasyMock.expect(ignored).andThrow(\n+                throwable);\n+        callWithConvertedRange(setter, range);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setThrowable(Throwable, int)}. For\n+     * explanation, see \"Convenience Methods for Throwables\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public void expectAndThrow(Object ignored, Throwable throwable, int count) {\n+        expect(ignored).andThrow(throwable).times(count);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setThrowable(Throwable, int, int)}. For\n+     * explanation, see \"Convenience Methods for Throwables\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public void expectAndThrow(Object ignored, Throwable throwable, int min,\n+            int max) {\n+        expect(ignored).andThrow(throwable).times(min, max);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setDefaultReturnValue(Object)}. For\n+     * explanation, see \"Convenience Methods for Return Values\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public <V1, V2 extends V1> void expectAndDefaultReturn(V1 ignored, V2 value) {\n+        EasyMock.expectLastCall().andStubReturn(value);\n+    }\n+\n+    /**\n+     * Same as {@link MockControl#setDefaultThrowable(Throwable)}. For\n+     * explanation, see \"Convenience Methods for Throwables\" in the EasyMock\n+     * documentation.\n+     * \n+     * @param ignored\n+     *            an ignored value.\n+     */\n+    public void expectAndDefaultThrow(Object ignored, Throwable throwable) {\n+        expectLastCall(\n+                \"method call on the mock needed before setting default Throwable\")\n+                .andStubThrow(throwable);\n+    }\n+\n+    private IExpectationSetters<Object> expectLastCall(String failureMessage) {\n+        try {\n+            return EasyMock.expectLastCall();\n+        } catch (IllegalStateException e) {\n+            throw new IllegalStateException(failureMessage);\n+        }\n+    }\n+\n+    private void callWithConvertedRange(IExpectationSetters setter, Range range) {\n+        if (range == ONE) {\n+            setter.once();\n+        } else if (range == ONE_OR_MORE) {\n+            setter.atLeastOnce();\n+        } else if (range == ZERO_OR_MORE) {\n+            setter.anyTimes();\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected Range\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/easymock/ObjenesisClassInstantiator.java\n+package org.easymock;\n+\n+import org.objenesis.ObjenesisHelper;\n+\n+public class ObjenesisClassInstantiator {\n+\n+    public static Object newInstance(Class clazz) throws InstantiationException {\n+        return ObjenesisHelper.newInstance(clazz);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/AlwaysMatcher.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import org.easymock.AbstractMatcher;\n+\n+public class AlwaysMatcher extends AbstractMatcher {\n+    public boolean matches(Object[] expected, Object[] actual) {\n+        return true;\n+    }\n+\n+    protected String argumentToString(Object argument) {\n+        return \"<any>\";\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ArrayMatcher.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import org.easymock.AbstractMatcher;\n+import org.easymock.internal.matchers.ArrayEquals;\n+\n+public class ArrayMatcher extends AbstractMatcher {\n+    public String argumentToString(Object argument) {\n+        StringBuffer result = new StringBuffer();\n+        new ArrayEquals(argument).appendTo(result);\n+        return result.toString();\n+    }\n+\n+    public boolean argumentMatches(Object expected, Object actual) {\n+        return new ArrayEquals(expected).matches(actual);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/AssertionErrorWrapper.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public class AssertionErrorWrapper extends RuntimeException {\n+    private final AssertionError error;\n+\n+    public AssertionErrorWrapper(AssertionError error) {\n+        this.error = error;\n+    }\n+\n+    public AssertionError getAssertionError() {\n+        return error;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ClassExtensionHelper.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Proxy;\n+\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+\n+import org.easymock.internal.ClassProxyFactory.MockMethodInterceptor;\n+\n+public final class ClassExtensionHelper {\n+\n+    private ClassExtensionHelper() {\n+    }\n+    \n+    public static MockMethodInterceptor getInterceptor(Object mock) {\n+        Factory factory = (Factory) mock;\n+        return (MockMethodInterceptor) factory.getCallback(0);\n+    }\n+\n+    public static MocksControl getControl(Object mock) {\n+        ObjectMethodsFilter<MockInvocationHandler> handler;\n+\n+        try {\n+            if (Enhancer.isEnhanced(mock.getClass())) {\n+                handler = (ObjectMethodsFilter) getInterceptor(mock)\n+                        .getHandler();\n+            } else if (Proxy.isProxyClass(mock.getClass())) {\n+                handler = (ObjectMethodsFilter) Proxy\n+                        .getInvocationHandler(mock);\n+            } else {\n+                throw new RuntimeExceptionWrapper(new IllegalArgumentException(\n+                        \"Not a mock: \" + mock.getClass().getName()));\n+            }\n+            \n+            return handler.getDelegate().getControl();\n+        } catch (ClassCastException e) {\n+            throw new RuntimeExceptionWrapper(new IllegalArgumentException(\n+                    \"Not a mock: \" + mock.getClass().getName()));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ClassProxyFactory.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.*;\n+import java.lang.reflect.InvocationHandler;\n+import java.util.*;\n+\n+import net.sf.cglib.core.*;\n+import net.sf.cglib.proxy.*;\n+\n+import org.easymock.ObjenesisClassInstantiator;\n+import org.mockito.MockAwareInvocationHandler;\n+\n+/**\n+ * Factory generating a mock for a class.\n+ * <p>\n+ * Note that this class is stateful\n+ */\n+public class ClassProxyFactory<T> {\n+\n+    public static interface MockMethodInterceptor extends MethodInterceptor {\n+        InvocationHandler getHandler();\n+\n+        void setMockedMethods(Method[] mockedMethods);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T createProxy(Class<T> toMock, final MockAwareInvocationHandler handler) {\n+\n+        // Dirty trick to fix ObjectMethodsFilter\n+        // It will replace the equals, hashCode, toString methods it kept that\n+        // are the ones\n+        // from Object.class by the correct ones since they might have been\n+        // overloaded\n+        // in the mocked class.\n+    \tif (!toMock.isInterface()) {\n+\t        try {\n+\t        \t\n+\t            updateMethod(handler, toMock.getMethod(\"equals\",\n+\t                    new Class[] { Object.class }));\n+\t            updateMethod(handler, toMock.getMethod(\"hashCode\", new Class[0]));\n+\t            updateMethod(handler, toMock.getMethod(\"toString\", new Class[0]));\n+\t        } catch (NoSuchMethodException e) {\n+\t            throw new RuntimeException(\n+\t                    \"We strangly failed to retrieve methods that always exist on an object...\");\n+\t        }\n+    \t}\n+\n+        MethodInterceptor interceptor = new MockMethodInterceptor() {\n+\n+            private Set<Method> mockedMethods;\n+\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                if (method.isBridge()) {\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+                if (mockedMethods != null && !mockedMethods.contains(method)) {\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+                return handler.invoke(obj, method, args);\n+            }\n+\n+            public InvocationHandler getHandler() {\n+                return handler;\n+            }\n+\n+            public void setMockedMethods(Method[] mockedMethods) {\n+                this.mockedMethods = new HashSet<Method>(Arrays\n+                        .asList(mockedMethods));\n+            }\n+        };\n+\n+        // Create the mock\n+        Enhancer enhancer = new Enhancer() {\n+            /**\n+             * Filter all private constructors but do not check that there are\n+             * some left\n+             */\n+            protected void filterConstructors(Class sc, List constructors) {\n+                CollectionUtils.filter(constructors, new VisibilityPredicate(\n+                        sc, true));\n+            }\n+        };\n+        \n+        //TODO not tested\n+        if (toMock.isInterface()) {\n+\t\t\tenhancer.setInterfaces(new Class[] { toMock });\n+\t\t} else {\n+\t\t\tenhancer.setSuperclass(toMock);\n+\t\t}\n+        \n+        enhancer.setCallbackType(interceptor.getClass());\n+\n+        Class mockClass = enhancer.createClass();\n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+\n+        Factory mock;\n+        try {\n+            mock = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(\"Fail to instantiate mock for \" + toMock\n+                    + \" on \" + System.getProperty(\"java.vm.vendor\") + \" JVM\");\n+        }\n+\n+        // This call is required. Cglib has some \"magic code\" making sure a\n+        // callback is used by only one instance of a given class. So only the\n+        // instance created right after registering the callback will get it.\n+        // However, this is done in the construtor which I'm bypassing to\n+        // allow class instantiation without calling a constructor.\n+        // Fortunatly, the \"magic code\" is also called in getCallback which is\n+        // why I'm calling it here mock.getCallback(0);\n+        mock.getCallback(0);\n+\n+        handler.setMock(mock);\n+        return (T) mock;\n+    }\n+\n+    private void updateMethod(InvocationHandler objectMethodsFilter,\n+            Method correctMethod) {\n+        Field methodField = retrieveField(ObjectMethodsFilter.class,\n+                correctMethod.getName() + \"Method\");\n+        updateField(objectMethodsFilter, correctMethod, methodField);\n+    }\n+\n+    private Field retrieveField(Class clazz, String field) {\n+        try {\n+            return clazz.getDeclaredField(field);\n+        } catch (NoSuchFieldException e) {\n+            throw new InternalError(\n+                    \"There must be some refactoring because the \" + field\n+                            + \" field was there...\");\n+        }\n+    }\n+\n+    private void updateField(Object instance, Object value, Field field) {\n+        boolean accessible = field.isAccessible();\n+        field.setAccessible(true);\n+        try {\n+            field.set(instance, value);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\n+                    \"Should be accessible since we set it ourselves\");\n+        }\n+        field.setAccessible(accessible);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/EqualsMatcher.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import org.easymock.AbstractMatcher;\n+\n+@SuppressWarnings(\"deprecation\")\n+public class EqualsMatcher extends AbstractMatcher {\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ExpectedInvocation.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.matchers.Equals;\n+\n+public class ExpectedInvocation {\n+\n+    protected final Invocation invocation;\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private final org.easymock.ArgumentsMatcher matcher;\n+\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public ExpectedInvocation(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        this(invocation, matchers, null);\n+    }\n+\n+    private ExpectedInvocation(Invocation invocation,\n+            List<IArgumentMatcher> matchers, @SuppressWarnings(\"deprecation\")\n+            org.easymock.ArgumentsMatcher matcher) {\n+        this.invocation = invocation;\n+        this.matcher = matcher;\n+        this.matchers = (matcher == null) ? createMissingMatchers(invocation,\n+                matchers) : null;\n+    }\n+\n+    private List<IArgumentMatcher> createMissingMatchers(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        if (matchers != null) {\n+            if (matchers.size() != invocation.getArguments().length) {\n+                throw new IllegalStateException(\"\"\n+                        + invocation.getArguments().length\n+                        + \" matchers expected, \" + matchers.size()\n+                        + \" recorded.\");\n+            }\n+            ;\n+            return matchers;\n+        }\n+        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !this.getClass().equals(o.getClass()))\n+            return false;\n+\n+        ExpectedInvocation other = (ExpectedInvocation) o;\n+        return this.invocation.equals(other.invocation)\n+                && ((this.matcher == null && other.matcher == null) || (this.matcher != null && this.matcher\n+                        .equals(other.matcher)))\n+                && ((this.matchers == null && other.matchers == null) || (this.matchers != null && this.matchers\n+                        .equals(other.matchers)));\n+    }\n+\n+    public int hashCode() {\n+        return 1; //invocation.hashCode();\n+    }\n+\n+    public boolean matches(Invocation actual) {\n+        return matchers != null ? this.invocation.getMock().equals(\n+                actual.getMock())\n+                && this.invocation.getMethod().equals(actual.getMethod())\n+                && matches(actual.getArguments()) : this.invocation.matches(\n+                actual, matcher);\n+    }\n+\n+    private boolean matches(Object[] arguments) {\n+        if (arguments.length != matchers.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!matchers.get(i).matches(arguments[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String toString() {\n+        return matchers != null ? myToString() : invocation.toString(matcher);\n+    }\n+\n+    private String myToString() {\n+        StringBuffer result = new StringBuffer();\n+        result.append(invocation.getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(result);\n+            if (it.hasNext()) {\n+                result.append(\", \");\n+            }\n+        }\n+        result.append(\")\");\n+        return result.toString();\n+    }\n+\n+    public Method getMethod() {\n+        return invocation.getMethod();\n+    }\n+\n+    public ExpectedInvocation withMatcher(@SuppressWarnings(\"deprecation\")\n+    org.easymock.ArgumentsMatcher matcher) {\n+        return new ExpectedInvocation(invocation, null, matcher);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ExpectedInvocationAndResult.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public class ExpectedInvocationAndResult {\n+    ExpectedInvocation expectedInvocation;\n+\n+    Result result;\n+\n+    public ExpectedInvocationAndResult(ExpectedInvocation expectedInvocation,\n+            Result result) {\n+        this.expectedInvocation = expectedInvocation;\n+        this.result = result;\n+    }\n+\n+    public ExpectedInvocation getExpectedInvocation() {\n+        return expectedInvocation;\n+    }\n+\n+    public Result getResult() {\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ExpectedInvocationAndResults.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public class ExpectedInvocationAndResults {\n+    ExpectedInvocation expectedInvocation;\n+\n+    Results results;\n+\n+    public ExpectedInvocationAndResults(ExpectedInvocation expectedInvocation,\n+            Results results) {\n+        this.expectedInvocation = expectedInvocation;\n+        this.results = results;\n+    }\n+\n+    public ExpectedInvocation getExpectedInvocation() {\n+        return expectedInvocation;\n+    }\n+\n+    public Results getResults() {\n+        return results;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return expectedInvocation.toString() + \": \" + results.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ILegacyMatcherMethods.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.ArgumentsMatcher;\n+\n+public interface ILegacyMatcherMethods {\n+\n+    void setDefaultMatcher(ArgumentsMatcher matcher);\n+\n+    void setMatcher(Method method, ArgumentsMatcher matcher);\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ILegacyMethods.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public interface ILegacyMethods extends ILegacyMatcherMethods {\n+    void setDefaultReturnValue(Object value);\n+\n+    void setDefaultThrowable(Throwable throwable);\n+\n+    void setDefaultVoidCallable();\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/IMocksBehavior.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public interface IMocksBehavior extends ILegacyMatcherMethods {\n+\n+    // record\n+    void addExpected(ExpectedInvocation expected, Result result, Range count);\n+\n+    void addStub(ExpectedInvocation expected, Result result);\n+\n+    void checkOrder(boolean value);\n+\n+    // replay\n+    Result addActual(Invocation invocation);\n+\n+    // verify\n+    void verify();\n+\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/IMocksControlState.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import org.easymock.IAnswer;\n+\n+public interface IMocksControlState extends ILegacyMethods {\n+\n+    Object invoke(Invocation invocation) throws Throwable;\n+\n+    void assertRecordState();\n+\n+    void andReturn(Object value);\n+\n+    void andThrow(Throwable throwable);\n+\n+    void andAnswer(IAnswer answer);\n+\n+    void andStubReturn(Object value);\n+\n+    void andStubThrow(Throwable throwable);\n+\n+    void andStubAnswer(IAnswer answer);\n+\n+    void asStub();\n+\n+    void times(Range range);\n+\n+    void checkOrder(boolean value);\n+\n+    void replay();\n+\n+    void verify();\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/Invocation.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import static java.lang.Character.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.internal.matchers.ArrayEquals;\n+\n+public class Invocation {\n+\n+    private final Object mock;\n+\n+    private final Method method;\n+\n+    private final Object[] arguments;\n+\n+    public Invocation(Object mock, Method method, Object[] args) {\n+        this.mock = mock;\n+        this.method = method;\n+        this.arguments = expandVarArgs(method.isVarArgs(), args);\n+    }\n+\n+    private static Object[] expandVarArgs(final boolean isVarArgs,\n+            final Object[] args) {\n+        if (!isVarArgs || isVarArgs && args[args.length - 1] != null\n+                && !args[args.length - 1].getClass().isArray()) {\n+            return args == null ? new Object[0] : args;\n+        }\n+        Object[] varArgs = ArrayEquals.createObjectArray(args[args.length - 1]);\n+        final int nonVarArgsCount = args.length - 1;\n+        final int varArgsCount = varArgs.length;\n+        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n+        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n+        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n+        return newArgs;\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !o.getClass().equals(this.getClass()))\n+            return false;\n+\n+        Invocation other = (Invocation) o;\n+\n+        return this.mock.equals(other.mock) && this.method.equals(other.method)\n+                && this.equalArguments(other.arguments);\n+    }\n+\n+//    public int hashCode() {\n+//        throw new UnsupportedOperationException(\"hashCode() is not implemented\");\n+//    }\n+\n+    private boolean equalArguments(Object[] arguments) {\n+        if (this.arguments.length != arguments.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < this.arguments.length; i++) {\n+            Object myArgument = this.arguments[i];\n+            Object otherArgument = arguments[i];\n+\n+            if (isPrimitiveParameter(i)) {\n+                if (!myArgument.equals(otherArgument)) {\n+                    return false;\n+                }\n+            } else {\n+                if (myArgument != otherArgument) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isPrimitiveParameter(int parameterPosition) {\n+        Class<?>[] parameterTypes = method.getParameterTypes();\n+        if (method.isVarArgs()) {\n+            parameterPosition = Math.min(parameterPosition,\n+                    parameterTypes.length - 1);\n+        }\n+        return parameterTypes[parameterPosition].isPrimitive();\n+    }\n+\n+    public boolean matches(Invocation actual, ArgumentsMatcher matcher) {\n+        return this.mock.equals(actual.mock)\n+                && this.method.equals(actual.method)\n+                && matcher.matches(this.arguments, actual.arguments);\n+    }\n+\n+    public String toString(ArgumentsMatcher matcher) {\n+        return getMockAndMethodName() + \"(\" + matcher.toString(arguments) + \")\";\n+    }\n+\n+    public String getMockAndMethodName() {\n+        String mockName = mock.toString();\n+        String methodName = method.getName();\n+        if (toStringIsDefined(mock) && isJavaIdentifier(mockName)) {\n+            return mockName + \".\" + methodName;\n+        } else {\n+            return methodName;\n+        }\n+    }\n+\n+    private boolean toStringIsDefined(Object o) {\n+        try {\n+            o.getClass().getDeclaredMethod(\"toString\", (Class[]) null)\n+                    .getModifiers();\n+            return true;\n+        } catch (SecurityException ignored) {\n+            \n+            return false;\n+            \n+        } catch (NoSuchMethodException shouldNeverHappen) {\n+            \n+            throw new RuntimeException(\"The toString() method could not be found!\");\n+            \n+        }\n+    }\n+\n+    public static boolean isJavaIdentifier(String mockName) {\n+        if (mockName.length() == 0 || mockName.indexOf(' ') > -1\n+                || !Character.isJavaIdentifierStart(mockName.charAt(0))) {\n+            return false;\n+        }\n+        for (char c : mockName.substring(1).toCharArray()) {\n+            if (!isJavaIdentifierPart(c)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/LastArguments.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.util.*;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.matchers.And;\n+import org.easymock.internal.matchers.Not;\n+import org.easymock.internal.matchers.Or;\n+\n+public class LastArguments {\n+    private static final ThreadLocal<Stack<Object[]>> threadToCurrentArguments = new ThreadLocal<Stack<Object[]>>();\n+\n+    private static final ThreadLocal<Stack<IArgumentMatcher>> threadToArgumentMatcherStack = new ThreadLocal<Stack<IArgumentMatcher>>();\n+\n+    public static synchronized void reportMatcher(IArgumentMatcher matcher) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        if (stack == null) {\n+            stack = new Stack<IArgumentMatcher>();\n+            threadToArgumentMatcherStack.set(stack);\n+        }\n+        stack.push(matcher);\n+    }\n+\n+    public static synchronized List<IArgumentMatcher> pullMatchers() {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        if (stack == null) {\n+            return null;\n+        }\n+        threadToArgumentMatcherStack.remove();\n+        return new ArrayList<IArgumentMatcher>(stack);\n+    }\n+\n+    public static synchronized void reportAnd(int count) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        stack.push(new And(popLastArgumentMatchers(count)));\n+    }\n+\n+    public static synchronized void reportNot() {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        stack.push(new Not(popLastArgumentMatchers(1).get(0)));\n+    }\n+\n+    private static List<IArgumentMatcher> popLastArgumentMatchers(int count) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        assertState(stack.size() >= count, \"\" + count + \" matchers expected, \"\n+                + stack.size() + \" recorded.\");\n+        List<IArgumentMatcher> result = new LinkedList<IArgumentMatcher>();\n+        result.addAll(stack.subList(stack.size() - count, stack.size()));\n+        for (int i = 0; i < count; i++) {\n+            stack.pop();\n+        }\n+        return result;\n+    }\n+\n+    private static void assertState(boolean toAssert, String message) {\n+        if (!toAssert) {\n+            threadToArgumentMatcherStack.remove();\n+            throw new IllegalStateException(message);\n+        }\n+    }\n+\n+    public static void reportOr(int count) {\n+        Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n+        assertState(stack != null, \"no matchers found.\");\n+        stack.push(new Or(popLastArgumentMatchers(count)));\n+    }\n+\n+    public static Object[] getCurrentArguments() {\n+        Stack<Object[]> stack = threadToCurrentArguments.get();\n+        if (stack == null || stack.empty()) {\n+            return null;\n+        }\n+        return stack.lastElement();\n+    }\n+\n+    public static void pushCurrentArguments(Object[] args) {\n+        Stack<Object[]> stack = threadToCurrentArguments.get();\n+        if (stack == null) {\n+            stack = new Stack<Object[]>();\n+            threadToCurrentArguments.set(stack);\n+        }\n+        stack.push(args);\n+    }\n+\n+    public static void popCurrentArguments() {\n+        Stack<Object[]> stack = threadToCurrentArguments.get();\n+        stack.pop();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/LastControl.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.util.*;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.matchers.And;\n+import org.easymock.internal.matchers.Not;\n+import org.easymock.internal.matchers.Or;\n+\n+public class LastControl {\n+    private static final ThreadLocal<MocksControl> threadToControl = new ThreadLocal<MocksControl>();\n+\n+    public static synchronized void reportLastControl(MocksControl control) {\n+        if (control != null) {\n+            threadToControl.set(control);\n+        } else {\n+            threadToControl.remove();\n+        }\n+    }\n+\n+    public static synchronized MocksControl lastControl() {\n+        return threadToControl.get();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/LegacyMatcherProvider.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.MockControl;\n+\n+public class LegacyMatcherProvider {\n+\n+    private ArgumentsMatcher defaultMatcher;\n+\n+    private boolean defaultMatcherSet;\n+\n+    private Map<Method, ArgumentsMatcher> matchers = new HashMap<Method, ArgumentsMatcher>();\n+\n+    public ArgumentsMatcher getMatcher(Method method) {\n+        if (!matchers.containsKey(method)) {\n+            if (!defaultMatcherSet) {\n+                setDefaultMatcher(MockControl.EQUALS_MATCHER);\n+            }\n+            matchers.put(method, defaultMatcher);\n+        }\n+        return matchers.get(method);\n+    }\n+\n+    public void setDefaultMatcher(ArgumentsMatcher matcher) {\n+        if (defaultMatcherSet) {\n+            throw new RuntimeExceptionWrapper(\n+                    new IllegalStateException(\n+                            \"default matcher can only be set once directly after creation of the MockControl\"));\n+        }\n+        defaultMatcher = matcher;\n+        defaultMatcherSet = true;\n+    }\n+\n+    public void setMatcher(Method method, ArgumentsMatcher matcher) {\n+        if (matchers.containsKey(method) && matchers.get(method) != matcher) {\n+            throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                    \"for method \"\n+                            + method.getName()\n+                            + \"(\"\n+                            + (method.getParameterTypes().length == 0 ? \"\"\n+                                    : \"...\")\n+                            + \"), a matcher has already been set\"));\n+        }\n+        matchers.put(method, matcher);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/MockInvocationHandler.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+\n+import org.mockito.MockAwareInvocationHandler;\n+\n+public class MockInvocationHandler implements InvocationHandler, MockAwareInvocationHandler {\n+\n+    protected final MocksControl control;\n+\n+    public MockInvocationHandler(MocksControl control) {\n+        this.control = control;\n+    }\n+\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+            throws Throwable {\n+        try {\n+            if (control.getState() instanceof RecordState) {\n+                LastControl.reportLastControl(control);\n+            }\n+            return control.getState().invoke(\n+                    new Invocation(proxy, method, args));\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw e.getRuntimeException().fillInStackTrace();\n+        } catch (AssertionErrorWrapper e) {\n+            throw e.getAssertionError().fillInStackTrace();\n+        } catch (ThrowableWrapper t) {\n+            throw t.getThrowable().fillInStackTrace();\n+        }\n+    }\n+\n+    public MocksControl getControl() {\n+        return control;\n+    }\n+\n+    public void setMock(Object mock) {\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/MocksBehavior.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.MockControl;\n+\n+public class MocksBehavior implements IMocksBehavior {\n+\n+    private final List<UnorderedBehavior> behaviorLists = new ArrayList<UnorderedBehavior>();\n+\n+    private List<ExpectedInvocationAndResult> stubResults = new ArrayList<ExpectedInvocationAndResult>();\n+\n+    private final boolean nice;\n+\n+    private boolean checkOrder;\n+\n+    private int position = 0;\n+\n+    public MocksBehavior(boolean nice) {\n+        this.nice = nice;\n+    }\n+\n+    public final void addStub(ExpectedInvocation expected, Result result) {\n+        stubResults.add(new ExpectedInvocationAndResult(expected, result));\n+    }\n+\n+    public void addExpected(ExpectedInvocation expected, Result result,\n+            Range count) {\n+        if (legacyMatcherProvider != null) {\n+            expected = expected.withMatcher(legacyMatcherProvider\n+                    .getMatcher(expected.getMethod()));\n+        }\n+        addBehaviorListIfNecessary(expected);\n+        lastBehaviorList().addExpected(expected, result, count);\n+    }\n+\n+    private final Result getStubResult(Invocation actual) {\n+        for (ExpectedInvocationAndResult each : stubResults) {\n+            if (each.getExpectedInvocation().matches(actual)) {\n+                return each.getResult();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private void addBehaviorListIfNecessary(ExpectedInvocation expected) {\n+        if (behaviorLists.isEmpty()\n+                || !lastBehaviorList().allowsExpectedInvocation(expected,\n+                        checkOrder)) {\n+            behaviorLists.add(new UnorderedBehavior(checkOrder));\n+        }\n+    }\n+\n+    private UnorderedBehavior lastBehaviorList() {\n+        return behaviorLists.get(behaviorLists.size() - 1);\n+    }\n+\n+    public final Result addActual(Invocation actual) {\n+        int tempPosition = position;\n+        String errorMessage = \"\";\n+        while (position < behaviorLists.size()) {\n+            Result result = behaviorLists.get(position).addActual(actual);\n+            if (result != null) {\n+                return result;\n+            }\n+            errorMessage += behaviorLists.get(position).toString(actual);\n+            if (!behaviorLists.get(position).verify()) {\n+                break;\n+            }\n+            position++;\n+        }\n+        Result stubOrNice = getStubResult(actual);\n+        if (stubOrNice == null && nice) {\n+            stubOrNice = Result.createReturnResult(ToTypeMappings.emptyReturnValueFor(actual.getMethod().getReturnType()));\n+        }\n+        if (stubOrNice != null) {\n+            position = tempPosition;\n+            return stubOrNice;\n+        }\n+        throw new AssertionErrorWrapper(new AssertionError(\n+                \"\\n  Unexpected method call \"\n+                        + actual.toString(MockControl.EQUALS_MATCHER) + \":\"\n+                        + errorMessage.toString()));\n+    }\n+\n+    public void verify() {\n+        boolean verified = true;\n+        StringBuffer errorMessage = new StringBuffer();\n+\n+        for (UnorderedBehavior behaviorList : behaviorLists.subList(position,\n+                behaviorLists.size())) {\n+            errorMessage.append(behaviorList.toString());\n+            if (!behaviorList.verify()) {\n+                verified = false;\n+            }\n+        }\n+        if (verified) {\n+            return;\n+        }\n+\n+        throw new AssertionErrorWrapper(new AssertionError(\n+                \"\\n  Expectation failure on verify:\" + errorMessage.toString()));\n+    }\n+\n+    public void checkOrder(boolean value) {\n+        this.checkOrder = value;\n+    }\n+\n+    private LegacyMatcherProvider legacyMatcherProvider;\n+\n+    public LegacyMatcherProvider getLegacyMatcherProvider() {\n+        if (legacyMatcherProvider == null) {\n+            legacyMatcherProvider = new LegacyMatcherProvider();\n+        }\n+        return legacyMatcherProvider;\n+    }\n+\n+    public void setDefaultMatcher(ArgumentsMatcher matcher) {\n+        getLegacyMatcherProvider().setDefaultMatcher(matcher);\n+    }\n+\n+    public void setMatcher(Method method, ArgumentsMatcher matcher) {\n+        getLegacyMatcherProvider().setMatcher(method, matcher);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/MocksControl.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.IAnswer;\n+import org.easymock.IExpectationSetters;\n+import org.easymock.IMocksControl;\n+\n+public class MocksControl implements IMocksControl {\n+\n+    private IMocksControlState state;\n+\n+    private IMocksBehavior behavior;\n+    \n+    public enum MockType {\n+        NICE, DEFAULT, STRICT\n+    }\n+\n+    private MockType type;\n+\n+    public MocksControl(MockType type) {\n+        this.type = type;\n+        reset();\n+    }\n+\n+    public IMocksControlState getState() {\n+        return state;\n+    }\n+\n+    public <T> T createMock(Class<T> toMock) {\n+        try {\n+            state.assertRecordState();\n+            ClassProxyFactory<T> proxyFactory = new ClassProxyFactory<T>();\n+            return proxyFactory.createProxy(toMock, new ObjectMethodsFilter(\n+                    toMock, new MockInvocationHandler(this), null));\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public <T> T createMock(String name, Class<T> toMock) {\n+        try {\n+            state.assertRecordState();\n+            ClassProxyFactory<T> proxyFactory = new ClassProxyFactory<T>();\n+            return proxyFactory.createProxy(toMock, new ObjectMethodsFilter(\n+                    toMock, new MockInvocationHandler(this), name));\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public final void reset() {\n+        behavior = new MocksBehavior(type == MockType.NICE);\n+        behavior.checkOrder(type == MockType.STRICT);\n+        state = new RecordState(behavior);\n+        LastControl.reportLastControl(null);\n+    }\n+\n+    public void replay() {\n+        try {\n+            state.replay();\n+            state = new ReplayState(behavior);\n+            LastControl.reportLastControl(null);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void verify() {\n+        try {\n+            state.verify();\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        } catch (AssertionErrorWrapper e) {\n+            throw (AssertionError) e.getAssertionError().fillInStackTrace();\n+        }\n+    }\n+\n+    public void checkOrder(boolean value) {\n+        try {\n+            state.checkOrder(value);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    // methods from IBehaviorSetters\n+\n+    public IExpectationSetters andReturn(Object value) {\n+        try {\n+            state.andReturn(value);\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters andThrow(Throwable throwable) {\n+        try {\n+            state.andThrow(throwable);\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters andAnswer(IAnswer answer) {\n+        try {\n+            state.andAnswer(answer);\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void andStubReturn(Object value) {\n+        try {\n+            state.andStubReturn(value);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void andStubThrow(Throwable throwable) {\n+        try {\n+            state.andStubThrow(throwable);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void andStubAnswer(IAnswer answer) {\n+        try {\n+            state.andStubAnswer(answer);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void asStub() {\n+        try {\n+            state.asStub();\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters times(int times) {\n+        try {\n+            state.times(new Range(times));\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters times(int min, int max) {\n+        try {\n+            state.times(new Range(min, max));\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters once() {\n+        try {\n+            state.times(ONCE);\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters atLeastOnce() {\n+        try {\n+            state.times(AT_LEAST_ONCE);\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public IExpectationSetters anyTimes() {\n+        try {\n+            state.times(ZERO_OR_MORE);\n+            return this;\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Exactly one call.\n+     */\n+    public static final Range ONCE = new Range(1);\n+\n+    /**\n+     * One or more calls.\n+     */\n+    public static final Range AT_LEAST_ONCE = new Range(1, Integer.MAX_VALUE);\n+\n+    /**\n+     * Zero or more calls.\n+     */\n+    public static final Range ZERO_OR_MORE = new Range(0, Integer.MAX_VALUE);\n+\n+    public void setLegacyDefaultMatcher(ArgumentsMatcher matcher) {\n+        try {\n+            state.setDefaultMatcher(matcher);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void setLegacyMatcher(ArgumentsMatcher matcher) {\n+        try {\n+            state.setMatcher(null, matcher);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void setLegacyDefaultReturnValue(Object value) {\n+        try {\n+            state.setDefaultReturnValue(value);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public void setLegacyDefaultVoidCallable() {\n+        state.setDefaultVoidCallable();\n+    }\n+\n+    public void setLegacyDefaultThrowable(Throwable throwable) {\n+        try {\n+            state.setDefaultThrowable(throwable);\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ObjectMethodsFilter.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.MockAwareInvocationHandler;\n+\n+public class ObjectMethodsFilter<T extends MockAwareInvocationHandler> implements MockAwareInvocationHandler {\n+    private final Method equalsMethod;\n+\n+    private final Method hashCodeMethod;\n+\n+    private final Method toStringMethod;\n+\n+    private final T delegate;\n+\n+    private final String name;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectMethodsFilter(Class toMock, T delegate,\n+            String name) {\n+        if (name != null && !Invocation.isJavaIdentifier(name)) {\n+            throw new IllegalArgumentException(String.format(\"'%s' is not a valid Java identifier.\", name));\n+            \n+        }\n+        try {\n+            if (toMock.isInterface()) {\n+                toMock = Object.class;\n+            }\n+            equalsMethod = toMock.getMethod(\"equals\",\n+                    new Class[] { Object.class });\n+            hashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n+            toStringMethod = toMock.getMethod(\"toString\", (Class[]) null);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"An Object method could not be found!\");\n+        }\n+        this.delegate = delegate;\n+        this.name = name;\n+    }\n+\n+    public final Object invoke(Object proxy, Method method, Object[] args)\n+            throws Throwable {\n+        if (equalsMethod.equals(method)) {\n+            return Boolean.valueOf(proxy == args[0]);\n+        }\n+        if (hashCodeMethod.equals(method)) {\n+            return new Integer(System.identityHashCode(proxy));\n+        }\n+        if (toStringMethod.equals(method)) {\n+            return mockToString(proxy);\n+        }\n+        return delegate.invoke(proxy, method, args);\n+    }\n+\n+    private String mockToString(Object proxy) {\n+        return (name != null) ? name : \"EasyMock for \" + mockType(proxy);\n+    }\n+\n+    //TODO unit test it or check if tested properly\n+    private String mockType(Object proxy) {\n+\t\tif (proxy.getClass().getInterfaces().length == 2) {\n+\t\t\treturn proxy.getClass().getInterfaces()[0].toString();\n+\t\t} else {\n+\t\t\treturn proxy.getClass().getSuperclass().toString();\n+\t\t}\n+\t}\n+\n+    public T getDelegate() {\n+        return delegate;\n+    }\n+\n+    public void setMock(Object mock) {\n+        delegate.setMock(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/Range.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public class Range {\n+    private int minimum;\n+\n+    private int maximum;\n+\n+    public Range(int count) {\n+        this(count, count);\n+    }\n+\n+    public Range(int minimum, int maximum) {\n+        if (!(minimum <= maximum)) {\n+            throw new RuntimeExceptionWrapper(new IllegalArgumentException(\n+                    \"minimum must be <= maximum\"));\n+        }\n+\n+        if (!(minimum >= 0)) {\n+            throw new RuntimeExceptionWrapper(new IllegalArgumentException(\n+                    \"minimum must be >= 0\"));\n+        }\n+\n+        if (!(maximum >= 1)) {\n+            throw new RuntimeExceptionWrapper(new IllegalArgumentException(\n+                    \"maximum must be >= 1\"));\n+        }\n+        this.minimum = minimum;\n+        this.maximum = maximum;\n+    }\n+\n+    public boolean hasFixedCount() {\n+        return minimum == maximum;\n+    }\n+\n+    public int getMaximum() {\n+        return maximum;\n+    }\n+\n+    public int getMinimum() {\n+        return minimum;\n+    }\n+\n+    public String toString() {\n+        if (hasFixedCount()) {\n+            return \"\" + minimum;\n+        } else if (hasOpenCount()) {\n+            return \"at least \" + minimum;\n+        } else {\n+            return \"between \" + minimum + \" and \" + maximum;\n+        }\n+    }\n+\n+    public String expectedAndActual(int count) {\n+        return \"expected: \" + this.toString() + \", actual: \" + count;\n+    }\n+\n+    public boolean contains(int count) {\n+        return minimum <= count && count <= maximum;\n+    }\n+\n+    public boolean hasOpenCount() {\n+        return maximum == Integer.MAX_VALUE;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/RecordState.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.IAnswer;\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.MockControl;\n+\n+public class RecordState implements IMocksControlState {\n+\n+    protected ExpectedInvocation lastInvocation;\n+\n+    protected boolean lastInvocationUsed = true;\n+\n+    protected Result lastResult;\n+\n+    protected IMocksBehavior behavior;\n+\n+    public RecordState(IMocksBehavior behavior) {\n+        this.behavior = behavior;\n+    }\n+\n+    public void assertRecordState() {\n+    }\n+\n+    public java.lang.Object invoke(Invocation invocation) {\n+        closeMethod();\n+        List<IArgumentMatcher> lastMatchers = LastArguments.pullMatchers();\n+        lastInvocation = new ExpectedInvocation(invocation, lastMatchers);\n+        lastInvocationUsed = false;\n+        return ToTypeMappings.emptyReturnValueFor(invocation.getMethod().getReturnType());\n+    }\n+\n+    public void replay() {\n+        closeMethod();\n+        if (LastArguments.pullMatchers() != null) {\n+            throw new IllegalStateException(\"matcher calls were used outside expectations\");\n+        }\n+    }\n+\n+    public void verify() {\n+        throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                \"calling verify is not allowed in record state\"));\n+    }\n+\n+    public void andReturn(Object value) {\n+        requireMethodCall(\"return value\");\n+        value = convertNumberClassIfNeccessary(value);\n+        requireAssignable(value);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        lastResult = Result.createReturnResult(value);\n+    }\n+\n+    public void andThrow(Throwable throwable) {\n+        requireMethodCall(\"Throwable\");\n+        requireValidThrowable(throwable);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        lastResult = Result.createThrowResult(throwable);\n+    }\n+    \n+    public void andAnswer(IAnswer answer) {\n+        requireMethodCall(\"answer\");\n+        requireValidAnswer(answer);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        lastResult = Result.createAnswerResult(answer);\n+    }\n+\n+    public void andStubReturn(Object value) {\n+        requireMethodCall(\"stub return value\");\n+        value = convertNumberClassIfNeccessary(value);\n+        requireAssignable(value);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        behavior.addStub(lastInvocation, Result.createReturnResult(value));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void setDefaultReturnValue(Object value) {\n+        requireMethodCall(\"default return value\");\n+        value = convertNumberClassIfNeccessary(value);\n+        requireAssignable(value);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        behavior.addStub(\n+                lastInvocation.withMatcher(MockControl.ALWAYS_MATCHER), Result\n+                        .createReturnResult(value));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void asStub() {\n+        requireMethodCall(\"stub behavior\");\n+        requireVoidMethod();\n+        behavior.addStub(lastInvocation, Result.createReturnResult(null));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void setDefaultVoidCallable() {\n+        requireMethodCall(\"default void callable\");\n+        requireVoidMethod();\n+        behavior.addStub(\n+                lastInvocation.withMatcher(MockControl.ALWAYS_MATCHER), Result\n+                        .createReturnResult(null));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void andStubThrow(Throwable throwable) {\n+        requireMethodCall(\"stub Throwable\");\n+        requireValidThrowable(throwable);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        behavior.addStub(lastInvocation, Result.createThrowResult(throwable));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void setDefaultThrowable(Throwable throwable) {\n+        requireMethodCall(\"default Throwable\");\n+        requireValidThrowable(throwable);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        behavior.addStub(\n+                lastInvocation.withMatcher(MockControl.ALWAYS_MATCHER), Result\n+                        .createThrowResult(throwable));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void andStubAnswer(IAnswer answer) {\n+        requireMethodCall(\"stub answer\");\n+        requireValidAnswer(answer);\n+        if (lastResult != null) {\n+            times(MocksControl.ONCE);\n+        }\n+        behavior.addStub(lastInvocation, Result.createAnswerResult(answer));\n+        lastInvocationUsed = true;\n+    }\n+\n+    public void times(Range range) {\n+        requireMethodCall(\"times\");\n+        requireLastResultOrVoidMethod();\n+\n+        behavior.addExpected(lastInvocation, lastResult != null ? lastResult\n+                : Result.createReturnResult(null), range);\n+        lastInvocationUsed = true;\n+        lastResult = null;\n+    }\n+\n+    protected Object createNumberObject(Object value, Class returnType) {\n+        if (!(value instanceof Number)) {\n+            return value;\n+        }\n+        Number number = (Number) value;\n+        if (returnType.equals(Byte.TYPE)) {\n+            return number.byteValue();\n+        } else if (returnType.equals(Short.TYPE)) {\n+            return number.shortValue();\n+        } else if (returnType.equals(Character.TYPE)) {\n+            return (char) number.intValue();\n+        } else if (returnType.equals(Integer.TYPE)) {\n+            return number.intValue();\n+        } else if (returnType.equals(Long.TYPE)) {\n+            return number.longValue();\n+        } else if (returnType.equals(Float.TYPE)) {\n+            return number.floatValue();\n+        } else if (returnType.equals(Double.TYPE)) {\n+            return number.doubleValue();\n+        } else {\n+            return number;\n+        }\n+    }\n+\n+    protected Object convertNumberClassIfNeccessary(Object o) {\n+        Class returnType = lastInvocation.getMethod().getReturnType();\n+        return createNumberObject(o, returnType);\n+    }\n+\n+    protected void closeMethod() {\n+        if (lastInvocationUsed && lastResult == null) {\n+            return;\n+        }\n+        if (!isLastResultOrVoidMethod()) {\n+            throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                    \"missing behavior definition for the preceeding method call \"\n+                            + lastInvocation.toString()));\n+        }\n+        this.times(MockControl.ONE);\n+    }\n+\n+    protected void requireMethodCall(String failMessage) {\n+        if (lastInvocation == null) {\n+            throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                    \"method call on the mock needed before setting \"\n+                            + failMessage));\n+        }\n+    }\n+\n+    protected void requireAssignable(Object returnValue) {\n+        if (lastMethodIsVoidMethod()) {\n+            throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                    \"void method cannot return a value\"));\n+        }\n+        if (returnValue == null) {\n+            return;\n+        }\n+        Class<?> returnedType = lastInvocation.getMethod().getReturnType();\n+        if (returnedType.isPrimitive()) {\n+            returnedType = ToTypeMappings.primitiveToWrapperType.get(returnedType);\n+        }\n+        if (!returnedType.isAssignableFrom(returnValue.getClass())) {\n+            throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                    \"incompatible return value type\"));\n+        }\n+    }\n+\n+    protected void requireValidThrowable(Throwable throwable) {\n+        if (throwable == null)\n+            throw new RuntimeExceptionWrapper(new NullPointerException(\n+                    \"null cannot be thrown\"));\n+        if (isValidThrowable(throwable))\n+            return;\n+\n+        throw new RuntimeExceptionWrapper(new IllegalArgumentException(\n+                \"last method called on mock cannot throw \"\n+                        + throwable.getClass().getName()));\n+    }\n+\n+    protected void requireValidAnswer(IAnswer answer) {\n+        if (answer == null)\n+            throw new RuntimeExceptionWrapper(new NullPointerException(\n+                    \"answer object must not be null\"));\n+    }\n+\n+    protected void requireLastResultOrVoidMethod() {\n+        if (isLastResultOrVoidMethod()) {\n+            return;\n+        }\n+        throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                \"last method called on mock is not a void method\"));\n+    }\n+\n+    protected void requireVoidMethod() {\n+        if (lastMethodIsVoidMethod()) {\n+            return;\n+        }\n+        throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                \"last method called on mock is not a void method\"));\n+    }\n+\n+    protected boolean isLastResultOrVoidMethod() {\n+        return lastResult != null || lastMethodIsVoidMethod();\n+    }\n+\n+    protected boolean lastMethodIsVoidMethod() {\n+        Class returnType = lastInvocation.getMethod().getReturnType();\n+        return returnType.equals(Void.TYPE);\n+    }\n+\n+    protected boolean isValidThrowable(Throwable throwable) {\n+        if (throwable instanceof RuntimeException) {\n+            return true;\n+        }\n+        if (throwable instanceof Error) {\n+            return true;\n+        }\n+        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public void checkOrder(boolean value) {\n+        closeMethod();\n+        behavior.checkOrder(value);\n+    }\n+\n+    public void setDefaultMatcher(ArgumentsMatcher matcher) {\n+        behavior.setDefaultMatcher(matcher);\n+    }\n+\n+    public void setMatcher(Method method, ArgumentsMatcher matcher) {\n+        requireMethodCall(\"matcher\");\n+        behavior.setMatcher(lastInvocation.getMethod(), matcher);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ReplayState.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.IAnswer;\n+\n+public class ReplayState implements IMocksControlState {\n+\n+    private IMocksBehavior behavior;\n+\n+    public ReplayState(IMocksBehavior behavior) {\n+        this.behavior = behavior;\n+    }\n+\n+    public Object invoke(Invocation invocation) throws Throwable {\n+        Result result = behavior.addActual(invocation);\n+        LastArguments.pushCurrentArguments(invocation.getArguments());\n+        try {\n+            try {\n+                return result.answer();\n+            } catch (Throwable t) {\n+                throw new ThrowableWrapper(t);\n+            }\n+        } finally {\n+            LastArguments.popCurrentArguments();\n+        }\n+    }\n+\n+    public void verify() {\n+        behavior.verify();\n+    }\n+\n+    public void replay() {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void callback(Runnable runnable) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void checkOrder(boolean value) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void andReturn(Object value) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void andThrow(Throwable throwable) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void andAnswer(IAnswer answer) {\n+        throwWrappedIllegalStateException();\n+    }\n+    \n+    public void andStubReturn(Object value) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void andStubThrow(Throwable throwable) {\n+        throwWrappedIllegalStateException();\n+    }\n+    \n+    public void andStubAnswer(IAnswer answer) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void asStub() {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void times(Range range) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void setMatcher(Method method, ArgumentsMatcher matcher) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void setDefaultMatcher(ArgumentsMatcher matcher) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void setDefaultReturnValue(Object value) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void setDefaultThrowable(Throwable throwable) {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    public void setDefaultVoidCallable() {\n+        throwWrappedIllegalStateException();\n+    }\n+\n+    private void throwWrappedIllegalStateException() {\n+        throw new RuntimeExceptionWrapper(new IllegalStateException(\n+                \"This method must not be called in replay state.\"));\n+    }\n+\n+    public void assertRecordState() {\n+        throwWrappedIllegalStateException();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/Result.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import org.easymock.IAnswer;\n+\n+public class Result implements IAnswer {\n+\n+    private IAnswer value;\n+\n+    private Result(IAnswer value) {\n+        this.value = value;\n+    }\n+\n+    public static Result createThrowResult(final Throwable throwable) {\n+        return new Result(new IAnswer<Object>() {\n+            public Object answer() throws Throwable {\n+                throw throwable;\n+            }\n+        });\n+    }\n+    public static Result createReturnResult(final Object value) {\n+\n+        return new Result(new IAnswer<Object>() {\n+            public Object answer() throws Throwable {\n+                return value;\n+            }\n+        });\n+    }\n+\n+    public static Result createAnswerResult(IAnswer answer) {\n+        return new Result(answer);\n+    }\n+\n+    public Object answer() throws Throwable {\n+        return value.answer();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/Results.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class Results {\n+\n+    private int callCount;\n+\n+    private LinkedList<Range> ranges = new LinkedList<Range>();\n+\n+    private List<Result> results = new ArrayList<Result>();\n+\n+    public void add(Result result, Range range) {\n+        if (!ranges.isEmpty()) {\n+            Range lastRange = ranges.getLast();\n+            if (!lastRange.hasFixedCount())\n+                throw new RuntimeExceptionWrapper(\n+                        new IllegalStateException(\n+                                \"last method called on mock already has a non-fixed count set.\"));\n+        }\n+        ranges.add(range);\n+        results.add(result);\n+    }\n+\n+    public Result next() {\n+        int currentPosition = 0;\n+        for (int i = 0; i < ranges.size(); i++) {\n+            Range interval = ranges.get(i);\n+            if (interval.hasOpenCount()) {\n+                callCount += 1;\n+                return results.get(i);\n+            }\n+            currentPosition += interval.getMaximum();\n+            if (currentPosition > callCount) {\n+                callCount += 1;\n+                return results.get(i);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public boolean hasValidCallCount() {\n+        return getMainInterval().contains(getCallCount());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getMainInterval().expectedAndActual(getCallCount());\n+    }\n+\n+    private Range getMainInterval() {\n+        int min = 0, max = 0;\n+\n+        for (Range interval : ranges) {\n+            min += interval.getMinimum();\n+            if (interval.hasOpenCount() || max == Integer.MAX_VALUE) {\n+                max = Integer.MAX_VALUE;\n+            } else {\n+                max += interval.getMaximum();\n+            }\n+        }\n+\n+        return new Range(min, max);\n+    }\n+\n+    public int getCallCount() {\n+        return callCount;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/RuntimeExceptionWrapper.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public class RuntimeExceptionWrapper extends RuntimeException {\n+    private final RuntimeException runtimeException;\n+\n+    public RuntimeExceptionWrapper(final RuntimeException runtimeException) {\n+        this.runtimeException = runtimeException;\n+    }\n+\n+    public RuntimeException getRuntimeException() {\n+        return runtimeException;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ThrowableWrapper.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+public class ThrowableWrapper extends Throwable {\n+    private final Throwable throwable;\n+\n+    public ThrowableWrapper(final Throwable throwable) {\n+        this.throwable = throwable;\n+    }\n+\n+    public Throwable getThrowable() {\n+        return throwable;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/ToTypeMappings.java\n+package org.easymock.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+public class ToTypeMappings {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Object> emptyReturnValueToPrimitiveType = new HashMap<Class, Object>();\n+\n+    static {\n+        emptyReturnValueToPrimitiveType.put(Void.TYPE, null);\n+        emptyReturnValueToPrimitiveType.put(Boolean.TYPE, Boolean.FALSE);\n+        emptyReturnValueToPrimitiveType.put(Byte.TYPE, new Byte((byte) 0));\n+        emptyReturnValueToPrimitiveType.put(Short.TYPE, new Short((short) 0));\n+        emptyReturnValueToPrimitiveType.put(Character.TYPE, new Character((char) 0));\n+        emptyReturnValueToPrimitiveType.put(Integer.TYPE, new Integer(0));\n+        emptyReturnValueToPrimitiveType.put(Long.TYPE, new Long(0));\n+        emptyReturnValueToPrimitiveType.put(Float.TYPE, new Float(0));\n+        emptyReturnValueToPrimitiveType.put(Double.TYPE, new Double(0));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Class> primitiveToWrapperType = new HashMap<Class, Class>();\n+\n+    static {\n+        primitiveToWrapperType.put(Boolean.TYPE, Boolean.class);\n+        primitiveToWrapperType.put(Byte.TYPE, Byte.class);\n+        primitiveToWrapperType.put(Short.TYPE, Short.class);\n+        primitiveToWrapperType.put(Character.TYPE, Character.class);\n+        primitiveToWrapperType.put(Integer.TYPE, Integer.class);\n+        primitiveToWrapperType.put(Long.TYPE, Long.class);\n+        primitiveToWrapperType.put(Float.TYPE, Float.class);\n+        primitiveToWrapperType.put(Double.TYPE, Double.class);\n+    }\n+    \n+    public static Object emptyReturnValueFor(Class type) {\n+        if (type.isPrimitive()) {\n+            return emptyReturnValueToPrimitiveType.get(type);\n+        }\n+        \n+        return emptyReturnValueToType.get(type);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected static Map<Class, Object> emptyReturnValueToType = new HashMap<Class, Object>();\n+    \n+    static {\n+        emptyReturnValueToType.put(Collection.class, new LinkedList<Object>());\n+        \n+        emptyReturnValueToType.put(Set.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(HashSet.class, new HashSet<Object>());\n+        emptyReturnValueToType.put(SortedSet.class, new TreeSet<Object>());        \n+        emptyReturnValueToType.put(TreeSet.class, new TreeSet<Object>());\n+        emptyReturnValueToType.put(LinkedHashSet.class, new LinkedHashSet<Object>());        \n+\n+        emptyReturnValueToType.put(List.class, new LinkedList<Object>());       \n+        emptyReturnValueToType.put(LinkedList.class, new LinkedList<Object>());\n+        emptyReturnValueToType.put(ArrayList.class, new ArrayList<Object>());\n+        \n+        emptyReturnValueToType.put(Map.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(HashMap.class, new HashMap<Object, Object>());\n+        emptyReturnValueToType.put(SortedMap.class, new TreeMap<Object, Object>());        \n+        emptyReturnValueToType.put(TreeMap.class, new TreeMap<Object, Object>());\n+        emptyReturnValueToType.put(LinkedHashMap.class, new LinkedHashMap<Object, Object>());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/UnorderedBehavior.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class UnorderedBehavior {\n+\n+    private final List<ExpectedInvocationAndResults> results = new ArrayList<ExpectedInvocationAndResults>();\n+\n+    private final boolean checkOrder;\n+\n+    public UnorderedBehavior(boolean checkOrder) {\n+        this.checkOrder = checkOrder;\n+    }\n+\n+    public void addExpected(ExpectedInvocation expected, Result result,\n+            Range count) {\n+        for (ExpectedInvocationAndResults entry : results) {\n+            if (entry.getExpectedInvocation().equals(expected)) {\n+                entry.getResults().add(result, count);\n+                return;\n+            }\n+        }\n+        Results list = new Results();\n+        list.add(result, count);\n+        results.add(new ExpectedInvocationAndResults(expected, list));\n+    }\n+\n+    public Result addActual(Invocation actual) {\n+        for (ExpectedInvocationAndResults entry : results) {\n+            if (!entry.getExpectedInvocation().matches(actual)) {\n+                continue;\n+            }\n+            Result result = entry.getResults().next();\n+            if (result != null) {\n+                return result;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public boolean verify() {\n+        for (ExpectedInvocationAndResults entry : results) {\n+            if (!entry.getResults().hasValidCallCount()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(null);\n+    }\n+\n+    public String toString(Invocation invocation) {\n+        StringBuffer result = new StringBuffer();\n+        for (ExpectedInvocationAndResults entry : results) {\n+            boolean unordered = !checkOrder;\n+            boolean validCallCount = entry.getResults().hasValidCallCount();\n+            boolean match = invocation != null\n+                    && entry.getExpectedInvocation().matches(invocation);\n+\n+            if (unordered && validCallCount && !match) {\n+                continue;\n+            }\n+            result.append(\"\\n    \" + entry.toString());\n+            if (match) {\n+                result.append(\" (+1)\");\n+            }\n+        }\n+        return result.toString();\n+    }\n+\n+    public boolean allowsExpectedInvocation(ExpectedInvocation expected,\n+            boolean checkOrder) {\n+        if (this.checkOrder != checkOrder) {\n+            return false;\n+        } else if (results.isEmpty() || !this.checkOrder) {\n+            return true;\n+        } else {\n+            ExpectedInvocation lastMethodCall = results.get(results.size() - 1)\n+                    .getExpectedInvocation();\n+            return lastMethodCall.equals(expected);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/And.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class And implements IArgumentMatcher {\n+\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public And(List<IArgumentMatcher> matchers) {\n+        this.matchers = matchers;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        for (IArgumentMatcher matcher : matchers) {\n+            if (!matcher.matches(actual)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"and(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(buffer);\n+            if (it.hasNext()) {\n+                buffer.append(\", \");\n+            }\n+        }\n+        buffer.append(\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Any.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Any implements IArgumentMatcher {\n+\n+    public static final Any ANY = new Any();    \n+    \n+    private Any() {\n+        \n+    }\n+    \n+    public boolean matches(Object actual) {\n+        return true;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"<any>\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/ArrayEquals.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+public class ArrayEquals extends Equals {\n+\n+    public ArrayEquals(Object expected) {\n+        super(expected);\n+    }\n+\n+    public boolean matches(Object actual) {\n+        Object expected = getExpected();\n+        if (expected instanceof boolean[]\n+                && (actual == null || actual instanceof boolean[])) {\n+            return Arrays.equals((boolean[]) expected, (boolean[]) actual);\n+        } else if (expected instanceof byte[]\n+                && (actual == null || actual instanceof byte[])) {\n+            return Arrays.equals((byte[]) expected, (byte[]) actual);\n+        } else if (expected instanceof char[]\n+                && (actual == null || actual instanceof char[])) {\n+            return Arrays.equals((char[]) expected, (char[]) actual);\n+        } else if (expected instanceof double[]\n+                && (actual == null || actual instanceof double[])) {\n+            return Arrays.equals((double[]) expected, (double[]) actual);\n+        } else if (expected instanceof float[]\n+                && (actual == null || actual instanceof float[])) {\n+            return Arrays.equals((float[]) expected, (float[]) actual);\n+        } else if (expected instanceof int[]\n+                && (actual == null || actual instanceof int[])) {\n+            return Arrays.equals((int[]) expected, (int[]) actual);\n+        } else if (expected instanceof long[]\n+                && (actual == null || actual instanceof long[])) {\n+            return Arrays.equals((long[]) expected, (long[]) actual);\n+        } else if (expected instanceof short[]\n+                && (actual == null || actual instanceof short[])) {\n+            return Arrays.equals((short[]) expected, (short[]) actual);\n+        } else if (expected instanceof Object[]\n+                && (actual == null || actual instanceof Object[])) {\n+            return Arrays.equals((Object[]) expected, (Object[]) actual);\n+        } else {\n+            return super.matches(actual);\n+        }\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        if (getExpected() != null && getExpected().getClass().isArray()) {\n+            appendArray(createObjectArray(getExpected()), buffer);\n+        } else {\n+            super.appendTo(buffer);\n+        }\n+    }\n+\n+    private void appendArray(Object[] array, StringBuffer buffer) {\n+        buffer.append(\"[\");\n+        for (int i = 0; i < array.length; i++) {\n+            new Equals(array[i]).appendTo(buffer);\n+            if (i != array.length - 1) {\n+                buffer.append(\", \");\n+            }\n+        }\n+        buffer.append(\"]\");\n+    }\n+\n+    public static Object[] createObjectArray(Object array) {\n+        if (array instanceof Object[]) {\n+            return (Object[]) array;\n+        }\n+        Object[] result = new Object[Array.getLength(array)];\n+        for (int i = 0; i < Array.getLength(array); i++) {\n+            result[i] = Array.get(array, i);\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Compare.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Henri Tremblay.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import java.util.Comparator;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.LogicalOperator;\n+\n+public class Compare<T> implements IArgumentMatcher {\n+\n+    private T expected;\n+\n+    private Comparator<T> comparator;\n+\n+    private LogicalOperator operator;\n+\n+    public Compare(T expected, Comparator<T> comparator, LogicalOperator result) {\n+        this.expected = expected;\n+        this.comparator = comparator;\n+        this.operator = result;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(comparator + \"(\" + expected + \") \" + operator.getSymbol()\n+                + \" 0\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean matches(Object actual) {\n+        if(actual == null) {\n+            return false;\n+        }\n+        return operator.matchResult(comparator.compare((T) actual, expected));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/CompareEqual.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+public class CompareEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public CompareEqual(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"cmpEq\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result == 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/CompareTo.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public abstract class CompareTo<T extends Comparable<T>> implements IArgumentMatcher {\n+    private final Comparable<T> expected;\n+\n+    public CompareTo(Comparable<T> value) {\n+        this.expected = value;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean matches(Object actual) {\n+        \n+        if(!(actual instanceof Comparable)) {\n+            return false;\n+        }\n+        \n+        return matchResult(((Comparable) actual).compareTo(expected));\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(getName() + \"(\" + expected + \")\");\n+    }\n+    \n+    protected abstract String getName();\n+    \n+    protected abstract boolean matchResult(int result);\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Contains.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Contains implements IArgumentMatcher {\n+\n+    private final String substring;\n+\n+    public Contains(String substring) {\n+        this.substring = substring;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String)\n+                && ((String) actual).indexOf(substring) >= 0;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"contains(\\\"\" + substring + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/EndsWith.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class EndsWith implements IArgumentMatcher {\n+\n+    private final String suffix;\n+\n+    public EndsWith(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String) && ((String) actual).endsWith(suffix);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"endsWith(\\\"\" + suffix + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Equals.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Equals implements IArgumentMatcher {\n+\n+    private final Object expected;\n+\n+    public Equals(Object expected) {\n+        this.expected = expected;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        if (this.expected == null) {\n+            return actual == null;\n+        }\n+        return expected.equals(actual);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        appendQuoting(buffer);\n+        buffer.append(expected);\n+        appendQuoting(buffer);\n+    }\n+\n+    private void appendQuoting(StringBuffer buffer) {\n+        if (expected instanceof String) {\n+            buffer.append(\"\\\"\");\n+        } else if (expected instanceof Character) {\n+            buffer.append(\"'\");\n+        }\n+    }\n+\n+    protected final Object getExpected() {\n+        return expected;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == null || !this.getClass().equals(o.getClass()))\n+            return false;\n+        Equals other = (Equals) o;\n+        return this.expected == null && other.expected == null\n+                || this.expected != null\n+                && this.expected.equals(other.expected);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        throw new UnsupportedOperationException(\"hashCode() is not supported\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/EqualsWithDelta.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class EqualsWithDelta implements IArgumentMatcher {\n+    private final Number expected;\n+\n+    private final Number delta;\n+\n+    public EqualsWithDelta(Number value, Number delta) {\n+        this.expected = value;\n+        this.delta = delta;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        Number actualNumber = (Number) actual;\n+        return expected.doubleValue() - delta.doubleValue() <= actualNumber\n+                .doubleValue()\n+                && actualNumber.doubleValue() <= expected.doubleValue()\n+                        + delta.doubleValue();\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"eq(\" + expected + \", \" + delta + \")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Find.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import java.util.regex.Pattern;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Find implements IArgumentMatcher {\n+\n+    private final String regex;\n+\n+    public Find(String regex) {\n+        this.regex = regex;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String)\n+                && Pattern.compile(regex).matcher((String) actual).find();\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"find(\\\"\" + regex.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/GreaterOrEqual.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+public class GreaterOrEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public GreaterOrEqual(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"geq\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result >= 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/GreaterThan.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+public class GreaterThan<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public GreaterThan(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"gt\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result > 0;\n+    }    \n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/InstanceOf.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class InstanceOf implements IArgumentMatcher {\n+\n+    private final Class<?> clazz;\n+\n+    public InstanceOf(Class clazz) {\n+        this.clazz = clazz;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual != null) && clazz.isAssignableFrom(actual.getClass());\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"isA(\" + clazz.getName() + \")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/LessOrEqual.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+public class LessOrEqual<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public LessOrEqual(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"leq\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result <= 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/LessThan.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+public class LessThan<T extends Comparable<T>> extends CompareTo<T> {\n+\n+    public LessThan(Comparable<T> value) {\n+        super(value);\n+    }\n+\n+    @Override\n+    protected String getName() {\n+        return \"lt\";\n+    }\n+\n+    @Override\n+    protected boolean matchResult(int result) {\n+        return result < 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Matches.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Matches implements IArgumentMatcher {\n+\n+    private final String regex;\n+\n+    public Matches(String regex) {\n+        this.regex = regex;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String) && ((String) actual).matches(regex);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"matches(\\\"\" + regex.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")\n+                + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Not.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Not implements IArgumentMatcher {\n+\n+    private final IArgumentMatcher first;\n+\n+    public Not(IArgumentMatcher first) {\n+        this.first = first;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return !first.matches(actual);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"not(\");\n+        first.appendTo(buffer);\n+        buffer.append(\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/NotNull.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class NotNull implements IArgumentMatcher {\n+\n+    public static final NotNull NOT_NULL = new NotNull();\n+    \n+    private NotNull() {\n+        \n+    }\n+    \n+    public boolean matches(Object actual) {\n+        return actual != null;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"notNull()\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Null.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Null implements IArgumentMatcher {\n+\n+    public static final Null NULL = new Null();\n+\n+    private Null() {\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return actual == null;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"isNull()\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Or.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Or implements IArgumentMatcher {\n+\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public Or(List<IArgumentMatcher> matchers) {\n+        this.matchers = matchers;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        for (IArgumentMatcher matcher : matchers) {\n+            if (matcher.matches(actual)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"or(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(buffer);\n+            if (it.hasNext()) {\n+                buffer.append(\", \");\n+            }\n+        }\n+        buffer.append(\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/Same.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class Same implements IArgumentMatcher {\n+\n+    private final Object expected;\n+\n+    public Same(Object expected) {\n+        this.expected = expected;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return expected == actual;\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"same(\");\n+        appendQuoting(buffer);\n+        buffer.append(expected);\n+        appendQuoting(buffer);\n+        buffer.append(\")\");\n+    }\n+\n+    private void appendQuoting(StringBuffer buffer) {\n+        if (expected instanceof String) {\n+            buffer.append(\"\\\"\");\n+        } else if (expected instanceof Character) {\n+            buffer.append(\"'\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/easymock/internal/matchers/StartsWith.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.internal.matchers;\n+\n+import org.easymock.IArgumentMatcher;\n+\n+public class StartsWith implements IArgumentMatcher {\n+\n+    private final String prefix;\n+\n+    public StartsWith(String prefix) {\n+        this.prefix = prefix;\n+    }\n+\n+    public boolean matches(Object actual) {\n+        return (actual instanceof String)\n+                && ((String) actual).startsWith(prefix);\n+    }\n+\n+    public void appendTo(StringBuffer buffer) {\n+        buffer.append(\"startsWith(\\\"\" + prefix + \"\\\")\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/InvocationWithMatchers.java\n+package org.mockito;\n+\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.*;\n+\n+public class InvocationWithMatchers extends ExpectedInvocation {\n+\n+    public InvocationWithMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        super(invocation, matchers);\n+    }\n+    \n+    MockitoInvocation getInvocation() {\n+        return (MockitoInvocation) this.invocation;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/MethodSelector.java\n+package org.mockito;\n+\n+public interface MethodSelector<T> {\n+    \n+    T on();\n+    \n+}\n--- /dev/null\n+++ b/src/org/mockito/MockAwareInvocationHandler.java\n+package org.mockito;\n+\n+import java.lang.reflect.InvocationHandler;\n+\n+public interface MockAwareInvocationHandler extends InvocationHandler {\n+    void setMock(Object mock);\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockUtil.java\n+/*\n+ * Copyright (c) 2007 Szczepan Faber \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import net.sf.cglib.proxy.*;\n+\n+import org.easymock.internal.ObjectMethodsFilter;\n+import org.easymock.internal.ClassProxyFactory.MockMethodInterceptor;\n+import org.mockito.exceptions.NotAMockException;\n+\n+public class MockUtil {\n+    \n+    private static MockMethodInterceptor getInterceptor(Object mock) {\n+        Factory factory = (Factory) mock;\n+        return (MockMethodInterceptor) factory.getCallback(0);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> MockitoControl<T> getControl(T mock) {\n+        ObjectMethodsFilter<MockitoControl<T>> handler;\n+\n+        try {\n+            if (Enhancer.isEnhanced(mock.getClass())) {\n+                handler = (ObjectMethodsFilter) getInterceptor(mock)\n+                        .getHandler();\n+            } else {\n+                throw new NotAMockException(mock);\n+            }\n+            \n+            return handler.getDelegate();\n+        } catch (ClassCastException e) {\n+            throw new NotAMockException(mock);\n+        }\n+    }\n+    \n+    public static void validateMock(Object mock) {\n+        getControl(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/Mockito.java\n+package org.mockito;\n+\n+import org.easymock.internal.*;\n+import org.mockito.exceptions.NotAMockMethodException;\n+import org.mockito.matchers.*;\n+\n+public class Mockito {\n+\n+    public static <T> T mock(Class<T> classToMock) {\n+        try {\n+            ClassProxyFactory<T> proxyFactory = new ClassProxyFactory<T>();\n+            return proxyFactory.createProxy(classToMock, new ObjectMethodsFilter<MockitoControl>(\n+                    classToMock, new MockitoControl<T>(), null));\n+        } catch (RuntimeExceptionWrapper e) {\n+            throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n+        }\n+    }\n+\n+    public static <T> MockitoExpectation<T> stub(T methodCallToStub) {\n+        //TODO increment number of stubs\n+        //TODO stub has to be removed from MockitoOperations.controlToBeStubbed!!!!!!!\n+        MockitoExpectation controlToStub = MockitoOperations.controlToBeStubbed();\n+        if (controlToStub == null) {\n+            throw new NotAMockMethodException();\n+        }\n+        return controlToStub;\n+    }\n+    \n+    public static <T> T verify(T mock) {\n+        MockUtil.validateMock(mock);\n+        MockitoOperations.reportVerifyingMode(VerifyingMode.anyTimes());\n+        return mock;\n+    }\n+    \n+    public static <T> T verify(T mock, int exactNumberOfInvocations) {\n+        //TODO validate mock everywhere\n+        //TODO validate if there is unfinished stubbing\n+        MockitoOperations.reportVerifyingMode(VerifyingMode.times(exactNumberOfInvocations));\n+        return mock;\n+    }\n+\n+\tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n+\t    for (Object mock : mocks) {\n+            MockUtil.getControl(mock).verifyNoMoreInteractions();\n+        }\n+\t}\n+\n+    public static void verifyZeroInteractions(Object ... mocks) {\n+         verifyNoMoreInteractions(mocks);   \n+    }\n+\n+    public static <T> T assertInvoked(T mock) {\n+        return verify(mock);\n+    }\n+\n+    public static <T> T assertInvoked(T mock, int exactNumberOfInvocations) {\n+        return verify(mock, exactNumberOfInvocations);\n+    }\n+    \n+    public static void assertNoMoreInteractions(Object ... mocks) {\n+        verifyNoMoreInteractions(mocks);   \n+    }\n+\n+    public static void assertZeroInteractions(Object ... mocks) {\n+        verifyZeroInteractions(mocks);   \n+    }\n+\n+    public static <T> T assertThat(MockitoMatcher<T> matcher) {\n+        return verify(matcher.getMock());\n+    }\n+    \n+    public static <T> MockitoMatcher<T> wasInvoked(T mock) {\n+        return new WasInvokedMatcher<T>(mock);\n+    }\n+    \n+    public static <T> MockitoMatcher<T> wasInvoked(T mock, int exactNumberOfInvocations) {\n+        return new WasInvokedMatcher<T>(mock, exactNumberOfInvocations);\n+    }\n+    \n+    public static <T> MockitoMatcher<T> noMoreInteractions(T mock) {\n+        return new HasNoMoreIvocationsMatcher<T>(mock);\n+    }\n+    \n+    public static <T> MockitoMatcher<T> zeroInteractions(T mock) {\n+        return new HasNoIvocationsMatcher<T>(mock);\n+    }\n+\n+    public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n+        //TODO validate mock\n+//        MockitoOperations.reportControlForStubbing(mockitoControl)\n+        return MockUtil.getControl(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockitoBehavior.java\n+package org.mockito;\n+\n+import java.util.*;\n+\n+import org.easymock.internal.*;\n+import org.mockito.exceptions.*;\n+\n+public class MockitoBehavior {\n+\n+    private List<MockitoInvocation> registeredInvocations = new LinkedList<MockitoInvocation>();\n+    private Map<MockitoInvocation, Result> results = new HashMap<MockitoInvocation, Result>();\n+    \n+    public void addInvocation(MockitoInvocation invocation) {\n+        this.registeredInvocations.add(invocation);\n+    }\n+\n+    public void addResult(Result result) {\n+        this.results.put(registeredInvocations.remove(registeredInvocations.size()-1), result);\n+    }\n+\n+    public void verify(InvocationWithMatchers invocation, VerifyingMode verifyingMode) {\n+        int actuallyInvoked = numberOfActualInvocations(invocation);\n+        \n+        if (verifyingMode.numberOfInvocationsMatters()) {\n+            int expectedInvoked = verifyingMode.getExactNumberOfInvocations();\n+            \n+            if (actuallyInvoked != expectedInvoked) {\n+                throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked);\n+            } \n+        } else {\n+            if (actuallyInvoked == 0) {\n+                throw new MockVerificationAssertionError();\n+            }\n+        }\n+    }\n+\n+    private int numberOfActualInvocations(InvocationWithMatchers expectedInvocation) {\n+        int verifiedInvocations = 0;\n+        for (MockitoInvocation registeredInvocation : registeredInvocations) {\n+            if (expectedInvocation.matches(registeredInvocation)) {\n+                verifiedInvocations += 1;\n+                registeredInvocation.markVerified();\n+            } else {\n+                verifiedInvocations += 0;\n+            }\n+        }\n+\n+        return verifiedInvocations;\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        for (MockitoInvocation registeredInvocation : registeredInvocations) {\n+            if (!registeredInvocation.isVerified()) {\n+                throw new MockVerificationAssertionError();\n+            }\n+        }\n+    }\n+\n+    public Object resultFor(MockitoInvocation invocation) throws Throwable {\n+        if (results.get(invocation) == null) {\n+            return ToTypeMappings.emptyReturnValueFor(invocation.getMethod().getReturnType());\n+        } else {\n+            return results.get(invocation).answer();\n+        }\n+    }\n+\n+    public MockitoInvocation lastInvocation() {\n+        return registeredInvocations.get(registeredInvocations.size() - 1);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockitoControl.java\n+package org.mockito;\n+\n+import java.lang.reflect.*;\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.*;\n+\n+public class MockitoControl<T> implements MockAwareInvocationHandler, InvocationHandler, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n+\n+    private MockitoBehavior behavior = new MockitoBehavior();\n+    private Object mock;\n+    \n+    public MockitoControl() {}\n+\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+        List<IArgumentMatcher> lastMatchers = LastArguments.pullMatchers();\n+\n+        MockitoInvocation invocation = new MockitoInvocation(proxy, method, args);\n+        InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, lastMatchers);\n+        \n+        if (MockitoOperations.mockVerificationScenario()) {\n+            VerifyingMode verifyingMode = MockitoOperations.removeVerifyingMode();\n+            \n+            behavior.verify(invocationWithMatchers, verifyingMode);\n+            return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n+        }\n+        \n+        MockitoOperations.reportControlForStubbing(this);\n+        \n+        behavior.addInvocation(invocation);\n+        \n+        if (MockitoOperations.settingThrowableOnVoidMethodScenario()) {\n+            Throwable throwable = MockitoOperations.removeThrowableToBeSetOnVoidMethod();\n+        \n+            andThrows(throwable);\n+            return null;\n+        }\n+\n+        return behavior.resultFor(invocation);\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        behavior.verifyNoMoreInteractions();\n+    }\n+\n+    public void andReturn(T value) {\n+//      TODO count number of andReturn vs number of stubbing\n+//      TODO why do we need that in easyMock?        \n+//      value = convertNumberClassIfNeccessary(value);\n+        behavior.addResult(Result.createReturnResult(value));\n+    }\n+\n+    public void andThrows(Throwable throwable) {\n+        validateThrowable(throwable);\n+        //TODO count number of andReturn vs number of stubbing\n+        behavior.addResult(Result.createThrowResult(throwable));\n+    }\n+    \n+    private void validateThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            throw new IllegalArgumentException(\"Cannot set null throwable\");\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+    \n+        if (! isValidCheckedException(throwable)) {\n+            throw new IllegalArgumentException(\"Given checked exception is invalid for this method\"); \n+        }\n+    }\n+\n+    private boolean isValidCheckedException(Throwable throwable) {\n+        MockitoInvocation lastInvocation = behavior.lastInvocation();\n+\n+        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+\n+    public MethodSelector<T> toThrow(Throwable throwable) {\n+        //TODO refactor so we don't use static state to keep the throwable\n+        MockitoOperations.reportThrowableToBeSetOnVoidMethod(throwable);\n+        return this;\n+    }\n+\n+    public T on() {\n+        // TODO check if mock can be of the type T\n+        return (T) mock;\n+    }\n+\n+    public void setMock(Object mock) {\n+        this.mock = mock;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockitoExpectation.java\n+package org.mockito;\n+\n+\n+public interface MockitoExpectation<T> {\n+\n+    void andReturn(T value);\n+\n+    void andThrows(Throwable throwable);\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockitoInvocation.java\n+package org.mockito;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.*;\n+\n+public class MockitoInvocation extends Invocation {\n+\n+    private boolean verified;\n+\n+    public MockitoInvocation(Object mock, Method method, Object[] args) {\n+        super(mock, method, args);\n+    }\n+\n+    public void markVerified() {\n+        verified = true;\n+    }\n+\n+    public boolean isVerified() {\n+        return verified;\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        return 1;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockitoOperations.java\n+package org.mockito;\n+\n+/**\n+ * static state. therefore dangerous and may have nasty bugs.\n+ * TODO look at every method that changes state and make sure the state is cleared afterwards\n+ * \n+ * @author sfaber\n+ */\n+public class MockitoOperations {\n+    \n+    private final static ThreadLocal<MockitoControl> controlForStubbing = new ThreadLocal<MockitoControl>();\n+    private final static ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n+    private final static ThreadLocal<Throwable> throwableToBeSetOnVoidMethod = new ThreadLocal<Throwable>();\n+\n+    public static synchronized void reportControlForStubbing(MockitoControl mockitoControl) {\n+        controlForStubbing.set(mockitoControl);\n+    }\n+\n+    public static synchronized MockitoExpectation controlToBeStubbed() {\n+        return controlForStubbing.get();\n+    }\n+    \n+    public static synchronized void reportVerifyingMode(VerifyingMode verify) {\n+        verifyingModeLocal.set(verify);\n+    }\n+\n+    public static synchronized boolean mockVerificationScenario() {\n+        return verifyingModeLocal.get() != null; \n+    }\n+\n+    public static synchronized VerifyingMode removeVerifyingMode() {\n+        VerifyingMode verifyingMode = verifyingModeLocal.get();\n+        verifyingModeLocal.set(null);\n+        return verifyingMode;\n+    }\n+\n+    public static void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n+        throwableToBeSetOnVoidMethod.set(throwable);\n+    }\n+\n+    public static Throwable removeThrowableToBeSetOnVoidMethod() {\n+        Throwable throwable = throwableToBeSetOnVoidMethod.get();\n+        throwableToBeSetOnVoidMethod.set(null);\n+        return throwable;\n+    }\n+\n+    public static boolean settingThrowableOnVoidMethodScenario() {\n+        return throwableToBeSetOnVoidMethod.get() != null; \n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/VerifyingMode.java\n+package org.mockito;\n+\n+import org.mockito.exceptions.MockVerificationAssertionError;\n+\n+public class VerifyingMode {\n+\n+    private static final int ANY_NUMBER_OF_TIMES = -1;\n+    private final int exactNumberOfInvocations;\n+\n+    public VerifyingMode(int exactNumberOfTimes) {\n+        this.exactNumberOfInvocations = exactNumberOfTimes;\n+    }\n+    \n+    public static VerifyingMode anyTimes() {\n+        return new VerifyingMode(ANY_NUMBER_OF_TIMES);\n+    }\n+\n+    public static VerifyingMode times(int exactNumberOfInvocations) {\n+        if (exactNumberOfInvocations < 0) {\n+            throw new IllegalArgumentException(\"Negative value is not allowed here\");\n+        }\n+        return new VerifyingMode(exactNumberOfInvocations);\n+    }\n+\n+    public boolean numberOfInvocationsMatters() {\n+        return exactNumberOfInvocations != ANY_NUMBER_OF_TIMES;\n+    }\n+\n+    public int getExactNumberOfInvocations() {\n+        return exactNumberOfInvocations;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/VoidMethodExpectation.java\n+package org.mockito;\n+\n+public interface VoidMethodExpectation<T> {\n+\n+    MethodSelector<T> toThrow(Throwable throwable);\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/MockVerificationAssertionError.java\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+public class MockVerificationAssertionError extends AssertionError {\n+\n+    public MockVerificationAssertionError() {\n+        super(\"Mock verification failed\");\n+        \n+        List<StackTraceElement> filteredStackTrace = new LinkedList<StackTraceElement>();\n+        for(StackTraceElement trace : getStackTrace()) {\n+            \n+//            filteredStackTrace\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/NotAMockException.java\n+package org.mockito.exceptions;\n+\n+public class NotAMockException extends RuntimeException {\n+\n+    public NotAMockException(Object object) {\n+        super(\"Not a mock: \" + object.getClass().getName());\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/NotAMockMethodException.java\n+package org.mockito.exceptions;\n+\n+public class NotAMockMethodException extends RuntimeException {\n+\n+    public NotAMockMethodException() {\n+        super(\"stub() requires an argument which has to be a proper method call on a mock object\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+package org.mockito.exceptions;\n+\n+public class NumberOfInvocationsAssertionError extends AssertionError {\n+\n+    public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked) {\n+        super(\"Expected to be invoked \" + expectedInvoked + \" times but was \" + actuallyInvoked);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/UnfinishedStubbingException.java\n+package org.mockito.exceptions;\n+\n+public class UnfinishedStubbingException extends RuntimeException {\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/matchers/HasNoIvocationsMatcher.java\n+/**\n+ * \n+ */\n+package org.mockito.matchers;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+\n+public class HasNoIvocationsMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n+    \n+    private final T mock;\n+\n+    public HasNoIvocationsMatcher(T mock) {\n+        this.mock = mock;\n+    }\n+    \n+    public boolean matches(Object arg0) {\n+        return false;\n+    }\n+\n+    public void describeTo(Description arg0) {\n+    };\n+    \n+    public T getMock() {\n+        return mock;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/matchers/HasNoMoreIvocationsMatcher.java\n+/**\n+ * \n+ */\n+package org.mockito.matchers;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+\n+public class HasNoMoreIvocationsMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n+    \n+    private final T mock;\n+\n+    public HasNoMoreIvocationsMatcher(T mock) {\n+        this.mock = mock;\n+    }\n+    \n+    public boolean matches(Object arg0) {\n+        return false;\n+    }\n+\n+    public void describeTo(Description arg0) {\n+    };\n+    \n+    public T getMock() {\n+        return mock;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/matchers/MockitoMatcher.java\n+package org.mockito.matchers;\n+\n+import org.hamcrest.Matcher;\n+\n+public interface MockitoMatcher<T> extends Matcher<T> {\n+    T getMock();\n+}\n--- /dev/null\n+++ b/src/org/mockito/matchers/WasInvokedMatcher.java\n+/**\n+ * \n+ */\n+package org.mockito.matchers;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+\n+public class WasInvokedMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n+    private final T mock;\n+    private final int exactNumberOfInvocations;\n+\n+    public WasInvokedMatcher(T mock) {\n+        this(mock, -1);\n+    }\n+    \n+    public WasInvokedMatcher(T mock, int exactNumberOfInvocations) {\n+        this.mock = mock;\n+        this.exactNumberOfInvocations = exactNumberOfInvocations;\n+    }\n+\n+    public boolean matches(Object arg0) {\n+        return true;\n+    }\n+\n+    public void describeTo(Description arg0) {\n+    }\n+\n+    public T getMock() {\n+        return mock;\n+    }\n+\n+    public int getExactNumberOfInvocations() {\n+        return exactNumberOfInvocations;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/classextension/CglibTest.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.classextension;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+\n+import junit.framework.TestCase;\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+import org.easymock.ObjenesisClassInstantiator;\n+import org.junit.Test;\n+\n+/**\n+ * This test case is used to make sure that the way cglib is used is providing the expected behavior\n+ */\n+public class CglibTest extends TestCase {\n+\n+    /**\n+     * Check that an interceptor is used by only one instance of a class\n+     * @throws Exception\n+     */\n+    @Test public void test() throws Exception {\n+\n+        Factory f1 = createMock();\n+        Factory f2 = createMock();\n+        \n+        assertNotSame(f1.getCallback(0), f2.getCallback(0));\n+    }\n+\n+    private Factory createMock() throws Exception {\n+        MethodInterceptor interceptor = new MethodInterceptor() {\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                return proxy.invokeSuper(obj, args);\n+            }\n+        };\n+\n+        Enhancer enhancer = new Enhancer();\n+        enhancer.setSuperclass(ArrayList.class);\n+        enhancer.setCallbackType(MethodInterceptor.class);\n+        \n+        Class mockClass = enhancer.createClass();\n+        \n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+                \n+        Factory f = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        \n+        f.getCallback(0);\n+        \n+        return f;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/classextension/internal/ClassProxyFactoryTest.java\n+package org.easymock.classextension.internal;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.CoreMatchers.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.ClassProxyFactory;\n+import org.junit.*;\n+import org.mockito.MockAwareInvocationHandler;\n+\n+public class ClassProxyFactoryTest {\n+\n+\t@Test public void shouldNotRewriteObjectMethodsForInterface() throws Exception {\n+\t\tClassProxyFactory<SomeInterface> factory = new ClassProxyFactory<SomeInterface>();\n+\t\tSomeInterface proxy = null;\n+\t\ttry {\n+\t\t\tproxy = factory.createProxy(SomeInterface.class, new MockAwareInvocationHandler() {\n+                public void setMock(Object mock) {}\n+                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                    return null;\n+                }});\n+\t\t} catch (RuntimeException e) {\n+\t\t\tfail(\"should not lookup Object methods since they are not available on interfaces\");\n+\t\t}\n+\t\t\n+\t\tassertThat(proxy, notNullValue());\n+\t}\n+\t\n+\tprivate interface SomeInterface {};\n+}\n--- /dev/null\n+++ b/test/org/easymock/internal/ToTypeMappingsTest.java\n+package org.easymock.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+\n+public class ToTypeMappingsTest {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n+        assertTrue(((Collection)ToTypeMappings.emptyReturnValueFor(Collection.class)).isEmpty());\n+        \n+        assertTrue(((Set)ToTypeMappings.emptyReturnValueFor(Set.class)).isEmpty());\n+        assertTrue(((SortedSet)ToTypeMappings.emptyReturnValueFor(SortedSet.class)).isEmpty());\n+        assertTrue(((HashSet)ToTypeMappings.emptyReturnValueFor(HashSet.class)).isEmpty());\n+        assertTrue(((TreeSet)ToTypeMappings.emptyReturnValueFor(TreeSet.class)).isEmpty());\n+        assertTrue(((LinkedHashSet)ToTypeMappings.emptyReturnValueFor(LinkedHashSet.class)).isEmpty());        \n+\n+        assertTrue(((List)ToTypeMappings.emptyReturnValueFor(List.class)).isEmpty());\n+        assertTrue(((ArrayList)ToTypeMappings.emptyReturnValueFor(ArrayList.class)).isEmpty());\n+        assertTrue(((LinkedList)ToTypeMappings.emptyReturnValueFor(LinkedList.class)).isEmpty());\n+        \n+        assertTrue(((Map)ToTypeMappings.emptyReturnValueFor(Map.class)).isEmpty());\n+        assertTrue(((SortedMap)ToTypeMappings.emptyReturnValueFor(SortedMap.class)).isEmpty());\n+        assertTrue(((HashMap)ToTypeMappings.emptyReturnValueFor(HashMap.class)).isEmpty());\n+        assertTrue(((TreeMap)ToTypeMappings.emptyReturnValueFor(TreeMap.class)).isEmpty());\n+        assertTrue(((LinkedHashMap)ToTypeMappings.emptyReturnValueFor(LinkedHashMap.class)).isEmpty());\n+        \n+        assertNull(ToTypeMappings.emptyReturnValueFor(String.class));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/ArgumentsMatcherTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.AbstractMatcher;\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ArgumentsMatcherTest {\n+\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        control = MockControl.createStrictControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void expectedArgumentsDelegatedToMatcher() {\n+        mock.twoArgumentMethod(0, 5);\n+        control.setMatcher(new AbstractMatcher() {\n+            @Override\n+            public boolean matches(Object[] expected, Object[] actual) {\n+                assertEquals(0, ((Integer) expected[0]).intValue());\n+                assertEquals(5, ((Integer) expected[1]).intValue());\n+                assertEquals(1, ((Integer) actual[0]).intValue());\n+                assertEquals(6, ((Integer) actual[1]).intValue());\n+                return true;\n+            }\n+        });\n+        mock.simpleMethod();\n+        control.replay();\n+        mock.twoArgumentMethod(1, 6);\n+        mock.simpleMethod();\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void expectedArgumentsDelegatedToMatcher2() {\n+        mock.threeArgumentMethod(7, \"\", \"A test\");\n+        control.setMatcher(new AbstractMatcher() {\n+            @Override\n+            public boolean matches(Object[] expected, Object[] actual) {\n+                int expectedInt = ((Integer) expected[0]).intValue();\n+                int actualInt = ((Integer) actual[0]).intValue();\n+                return expectedInt < actualInt;\n+            }\n+        });\n+        control.setReturnValue(\"1\");\n+        mock.threeArgumentMethod(6, \"\", \"A test\");\n+        control.setReturnValue(\"2\");\n+        mock.threeArgumentMethod(12, \"\", \"A test\");\n+        control.setReturnValue(\"3\");\n+\n+        control.replay();\n+        mock.threeArgumentMethod(9, \"test\", \"test\");\n+        mock.threeArgumentMethod(8, \"test\", \"test\");\n+        mock.threeArgumentMethod(13, \"test\", \"test\");\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void errorString() {\n+        mock.twoArgumentMethod(0, 5);\n+        control.setMatcher(new ArgumentsMatcher() {\n+            public boolean matches(Object[] expected, Object[] actual) {\n+                return false;\n+            }\n+\n+            public String toString(Object[] arguments) {\n+                return \"<<\" + arguments[0] + \">>\";\n+            }\n+        });\n+        control.replay();\n+        boolean failed = false;\n+        try {\n+            mock.twoArgumentMethod(1, 5);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\"\\n  Unexpected method call twoArgumentMethod(1, 5):\"\n+                    + \"\\n    twoArgumentMethod(<<0>>): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"exception expected\");\n+        }\n+    }\n+\n+    @Test\n+    public void settingTheSameMatcherIsOk() {\n+        try {\n+            mock.twoArgumentMethod(1, 2);\n+            control.setMatcher(MockControl.ARRAY_MATCHER);\n+            control.setMatcher(MockControl.ARRAY_MATCHER);\n+            mock.twoArgumentMethod(1, 2);\n+            control.setMatcher(MockControl.ARRAY_MATCHER);\n+\n+        } catch (IllegalStateException unexpected) {\n+            fail(\"no exception should be thrown if the same matcher is set twice\");\n+        }\n+    }\n+\n+    @Test\n+    public void abstractMatcher() {\n+        AbstractMatcher trueMatcher = new AbstractMatcher() {\n+            protected boolean parameterMatches(Object expected, Object actual) {\n+                return true;\n+            }\n+        };\n+        Object[] arrayWithNull = new Object[] { null };\n+        Object[] arrayWithObject = new Object[] { new Object() };\n+        assertFalse(trueMatcher.matches(arrayWithNull, arrayWithObject));\n+        assertFalse(trueMatcher.matches(arrayWithObject, arrayWithNull));\n+    }\n+\n+    @Test\n+    public void abstractMatcherToStringHandlesNullArray() {\n+        AbstractMatcher matcher = new AbstractMatcher() {\n+        };\n+        assertEquals(\"\", matcher.toString(null));\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/ArrayMatcherTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.MockControl;\n+import org.junit.Test;\n+\n+public class ArrayMatcherTest {\n+\n+    private static ArgumentsMatcher MATCHER = MockControl.ARRAY_MATCHER;\n+\n+    @Test\n+    public void booleanArray() {\n+        assertTrue(equals(new boolean[] { true }, new boolean[] { true }));\n+        assertFalse(equals(new boolean[] { true }, new boolean[] { false }));\n+    }\n+\n+    @Test\n+    public void byteArray() {\n+        assertTrue(equals(new byte[] { 6 }, new byte[] { 6 }));\n+        assertFalse(equals(new byte[] { 6 }, new byte[] { 7 }));\n+    }\n+\n+    @Test\n+    public void charArray() {\n+        assertTrue(equals(new char[] { 'x' }, new char[] { 'x' }));\n+        assertFalse(equals(new char[] { 'x' }, new char[] { 'y' }));\n+    }\n+\n+    @Test\n+    public void doubleArray() {\n+        assertTrue(equals(new double[] { 6.0 }, new double[] { 6.0 }));\n+        assertFalse(equals(new double[] { 6.0 }, new double[] { 7.0 }));\n+    }\n+\n+    @Test\n+    public void floatArray() {\n+        assertTrue(equals(new float[] { 6.0F }, new float[] { 6.0F }));\n+        assertFalse(equals(new float[] { 6.0F }, new float[] { 7.0F }));\n+    }\n+\n+    @Test\n+    public void intArray() {\n+        assertTrue(equals(new int[] { 6 }, new int[] { 6 }));\n+        assertFalse(equals(new int[] { 6 }, new int[] { 7 }));\n+    }\n+\n+    @Test\n+    public void longArray() {\n+        assertTrue(equals(new long[] { 6 }, new long[] { 6 }));\n+        assertFalse(equals(new long[] { 6 }, new long[] { 7 }));\n+    }\n+\n+    @Test\n+    public void shortArray() {\n+        assertTrue(equals(new short[] { 6 }, new short[] { 6 }));\n+        assertFalse(equals(new short[] { 6 }, new short[] { 7 }));\n+    }\n+\n+    @Test\n+    public void objectArray() {\n+        assertTrue(equals(new String[] { \"1\", \"2\" }, new String[] { \"1\", \"2\" }));\n+        assertFalse(equals(new String[] { \"1\", \"2\" }, new String[] { \"2\", \"2\" }));\n+    }\n+\n+    @Test\n+    public void nonArray() {\n+        assertTrue(equals(\"1\", \"1\"));\n+        assertFalse(equals(\"1\", \"2\"));\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        assertEquals(\"[true, false]\", stringFor(new boolean[] { true, false }));\n+        assertEquals(\"[6, 7]\", stringFor(new byte[] { 6, 7 }));\n+        assertEquals(\"['x', 'y']\", stringFor(new char[] { 'x', 'y' }));\n+        assertEquals(\"[6.0, 7.0]\", stringFor(new double[] { 6, 7 }));\n+        assertEquals(\"[6.0, 7.0]\", stringFor(new float[] { 6, 7 }));\n+        assertEquals(\"[6, 7]\", stringFor(new int[] { 6, 7 }));\n+        assertEquals(\"[6, 7]\", stringFor(new long[] { 6, 7 }));\n+        assertEquals(\"[6, 7]\", stringFor(new short[] { 6, 7 }));\n+        assertEquals(\"[\\\"1\\\", \\\"2\\\"]\", stringFor(new String[] { \"1\", \"2\" }));\n+        assertEquals(\"[\\\"1\\\", \\\"2\\\"]\", stringFor(new Object[] { \"1\", \"2\" }));\n+    }\n+\n+    @Test\n+    public void toStringMixed() {\n+        assertEquals(\"3, [\\\"1\\\", 2.0], \\\"Test\\\"\", MATCHER\n+                .toString(new Object[] { new Integer(3),\n+                        new Object[] { \"1\", new Float(2.0) }, \"Test\" }));\n+    }\n+\n+    private String stringFor(Object argument) {\n+        return MATCHER.toString(new Object[] { argument });\n+    }\n+\n+    private boolean equals(Object o1, Object o2) {\n+        Object[] expected = new Object[] { o1 };\n+        Object[] actual = new Object[] { o2 };\n+        return MATCHER.matches(expected, actual);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/DefaultMatcherTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class DefaultMatcherTest {\n+\n+    public static interface ArrayInterface {\n+        void methodA(int[] argument);\n+\n+        void methodB(int[] argument);\n+    }\n+\n+    private MockControl<ArrayInterface> control;\n+\n+    private ArrayInterface mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(ArrayInterface.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void defaultMatcher() {\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+\n+        mock.methodA(new int[] { 1, 1 });\n+        mock.methodB(new int[] { 2, 2 });\n+\n+        control.replay();\n+\n+        mock.methodA(new int[] { 1, 1 });\n+        mock.methodB(new int[] { 2, 2 });\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void failInReplayState() {\n+        control.replay();\n+        try {\n+            control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+        }\n+    }\n+\n+    @Test\n+    public void failIfDefaultMatcherSetTwice() {\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+        try {\n+            control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"default matcher can only be set once directly after creation of the MockControl\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void defaultMatcherSetTooLate() {\n+        int[] integers = new int[] { 1, 1 };\n+        int[] integers2 = new int[] { 2, 2 };\n+        mock.methodA(integers);\n+        control.setVoidCallable();\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+        mock.methodA(integers2);\n+        control.setVoidCallable();\n+        control.replay();\n+\n+        boolean failed = true;\n+        try {\n+            mock.methodA(new int[] { 1, 1 });\n+            failed = false;\n+        } catch (AssertionError expected) {\n+        }\n+        if (!failed) {\n+            fail();\n+        }\n+        mock.methodA(integers);\n+        mock.methodA(new int[] { 2, 2 });\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/EqualsMatcherTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.ArgumentsMatcher;\n+import org.easymock.MockControl;\n+import org.junit.Test;\n+\n+public class EqualsMatcherTest {\n+    final ArgumentsMatcher MATCHER = MockControl.EQUALS_MATCHER;\n+\n+    @Test\n+    public void equalsMatcher() {\n+        assertTrue(MATCHER.matches(null, null));\n+        assertFalse(MATCHER.matches(null, new Object[0]));\n+        assertFalse(MATCHER.matches(new Object[0], null));\n+        assertFalse(MATCHER.matches(new Object[] { \"\" }, new Object[] { null }));\n+        assertFalse(MATCHER.matches(new Object[] { null }, new Object[] { \"\" }));\n+        assertTrue(MATCHER\n+                .matches(new Object[] { null }, new Object[] { null }));\n+        assertTrue(MATCHER.matches(new Object[] { \"x\" }, new Object[] { \"x\" }));\n+    }\n+\n+    @Test\n+    public void differentNumberOfArguments() {\n+        assertFalse(MATCHER.matches(new Object[2], new Object[3]));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/ExpectedMethodCallTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.ExpectedInvocation;\n+import org.easymock.internal.Invocation;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ExpectedMethodCallTest {\n+\n+    private ExpectedInvocation call;\n+\n+    @Before\n+    public void setup() throws SecurityException, NoSuchMethodException {\n+        Object[] arguments1 = new Object[] { \"\" };\n+        Method m = Object.class.getMethod(\"equals\",\n+                new Class[] { Object.class });\n+        call = new ExpectedInvocation(new Invocation(null, m, arguments1), null);\n+    }\n+\n+//    @Test\n+//    public void testHashCode() {\n+//        try {\n+//            call.hashCode();\n+//            fail();\n+//        } catch (UnsupportedOperationException expected) {\n+//            assertEquals(\"hashCode() is not implemented\", expected.getMessage());\n+//        }\n+//    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/IMethods.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import java.io.IOException;\n+\n+public interface IMethods {\n+\n+    boolean booleanReturningMethod(int index);\n+\n+    byte byteReturningMethod(int index);\n+\n+    short shortReturningMethod(int index);\n+\n+    char charReturningMethod(int index);\n+\n+    int intReturningMethod(int index);\n+\n+    long longReturningMethod(int index);\n+\n+    float floatReturningMethod(int index);\n+\n+    double doubleReturningMethod(int index);\n+\n+    Object objectReturningMethod(int index);\n+\n+    String oneArg(boolean value);\n+\n+    String oneArg(byte value);\n+\n+    String oneArg(short value);\n+\n+    String oneArg(char value);\n+\n+    String oneArg(int value);\n+\n+    String oneArg(long value);\n+\n+    String oneArg(float value);\n+\n+    String oneArg(double value);\n+\n+    String oneArg(Object value);\n+\n+    String oneArg(String value);\n+\n+    public String throwsNothing(boolean value);\n+\n+    public String throwsIOException(int count) throws IOException;\n+\n+    public String throwsError(int count) throws Error;\n+\n+    void simpleMethod();\n+\n+    void simpleMethodWithArgument(String argument);\n+\n+    Object threeArgumentMethod(int valueOne, Object valueTwo, String valueThree);\n+\n+    void twoArgumentMethod(int one, int two);\n+\n+    void arrayMethod(String[] strings);\n+\n+    String oneArray(boolean[] array);\n+\n+    String oneArray(byte[] array);\n+\n+    String oneArray(char[] array);\n+\n+    String oneArray(double[] array);\n+\n+    String oneArray(float[] array);\n+\n+    String oneArray(int[] array);\n+\n+    String oneArray(long[] array);\n+\n+    String oneArray(short[] array);\n+\n+    String oneArray(Object[] array);\n+\n+    String oneArray(String[] array);\n+\n+    void varargsString(int i, String... string);\n+\n+    void varargsObject(int i, Object... object);\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/IVarArgs.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+public interface IVarArgs {\n+    public void withVarargsString(int value, String... s);\n+\n+    public void withVarargsObject(int value, Object... o);\n+\n+    public void withVarargsBoolean(int value, boolean... b);\n+\n+    public void withVarargsByte(int value, byte... b);\n+\n+    public void withVarargsChar(int value, char... c);\n+\n+    public void withVarargsDouble(int value, double... d);\n+\n+    public void withVarargsFloat(int value, float... f);\n+\n+    public void withVarargsInt(int value, int... i);\n+\n+    public void withVarargsLong(int value, long... l);\n+\n+    public void withVarargsShort(int value, short... s);\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/InvocationTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.EqualsMatcher;\n+import org.easymock.internal.Invocation;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InvocationTest {\n+\n+    private Invocation call;\n+\n+    private Invocation equalCall;\n+\n+    private Invocation nonEqualCall;\n+\n+    @Before\n+    public void setup() throws SecurityException, NoSuchMethodException {\n+        Object[] arguments1 = new Object[] { \"\" };\n+        Object[] arguments2 = new Object[] { \"\" };\n+        Object[] arguments3 = new Object[] { \"X\" };\n+        Method m = Object.class.getMethod(\"equals\",\n+                new Class[] { Object.class });\n+        Object mock = new Object();\n+        call = new Invocation(mock, m, arguments1);\n+        equalCall = new Invocation(mock, m, arguments2);\n+        nonEqualCall = new Invocation(mock, m, arguments3);\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        assertFalse(call.equals(null));\n+        assertFalse(call.equals(\"\"));\n+        assertTrue(call.equals(equalCall));\n+        assertFalse(call.equals(nonEqualCall));\n+    }\n+\n+//    @Test\n+//    public void testHashCode() {\n+//        try {\n+//            call.hashCode();\n+//            fail();\n+//        } catch (UnsupportedOperationException expected) {\n+//            assertEquals(\"hashCode() is not implemented\", expected.getMessage());\n+//        }\n+//    }\n+\n+    @Test\n+    public void testShouldDisplayMocksToStringIfValidJavaIdentifier()\n+            throws SecurityException, NoSuchMethodException {\n+        class ToString {\n+            private final String name;\n+\n+            public ToString(String name) {\n+                this.name = name;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n+\n+            public void aMethod() {\n+            }\n+        }\n+\n+        Method method = ToString.class.getMethod(\"aMethod\", new Class[0]);\n+        Invocation invocation = new Invocation(new ToString(\"validJavaIdentifier\"),\n+                method, null);\n+\n+        assertEquals(invocation.toString(new EqualsMatcher()),\n+                \"validJavaIdentifier.aMethod()\");\n+\n+        invocation = new Invocation(new ToString(\"no-valid-java-identifier\"),\n+                method, null);\n+\n+        assertEquals(invocation.toString(new EqualsMatcher()), \"aMethod()\");\n+\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/LegacyBehaviorTests.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+\n+import org.easymock.MockControl;\n+import org.junit.Test;\n+\n+public class LegacyBehaviorTests {\n+\n+    @Test\n+    public void throwAfterThrowable() throws IOException {\n+\n+        MockControl<IMethods> control = MockControl\n+                .createControl(IMethods.class);\n+        IMethods mock = control.getMock();\n+\n+        mock.throwsIOException(0);\n+        control.setThrowable(new IOException());\n+        control.setThrowable(new IOException(), MockControl.ONE_OR_MORE);\n+\n+        control.replay();\n+\n+        try {\n+            mock.throwsIOException(0);\n+            fail(\"IOException expected\");\n+        } catch (IOException expected) {\n+        }\n+\n+        boolean exceptionOccured = true;\n+        try {\n+            control.verify();\n+            exceptionOccured = false;\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    throwsIOException(0): expected: at least 2, actual: 1\",\n+                    expected.getMessage());\n+        }\n+\n+        if (!exceptionOccured)\n+            fail(\"exception expected\");\n+\n+        try {\n+            mock.throwsIOException(0);\n+            fail(\"IOException expected\");\n+        } catch (IOException expected) {\n+        }\n+\n+        control.verify();\n+\n+        try {\n+            mock.throwsIOException(0);\n+            fail(\"IOException expected\");\n+        } catch (IOException expected) {\n+        }\n+\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/MatchableArgumentsTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.ExpectedInvocation;\n+import org.easymock.internal.Invocation;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class MatchableArgumentsTest {\n+\n+    private Object[] arguments;\n+\n+    private Object[] arguments2;\n+\n+    @Before\n+    public void setup() {\n+        arguments = new Object[] { \"\" };\n+        arguments2 = new Object[] { \"\", \"\" };\n+    }\n+\n+    @Test\n+    public void testEquals() throws SecurityException, NoSuchMethodException {\n+        Method toPreventNullPointerExceptionm = Object.class.getMethod(\n+                \"toString\", new Class[] {});\n+\n+        Object mock = new Object();\n+\n+        ExpectedInvocation matchableArguments = new ExpectedInvocation(\n+                new Invocation(mock, toPreventNullPointerExceptionm, arguments),\n+                null);\n+        ExpectedInvocation nonEqualMatchableArguments = new ExpectedInvocation(\n+                new Invocation(mock, toPreventNullPointerExceptionm, arguments2),\n+                null);\n+\n+        assertFalse(matchableArguments.equals(null));\n+        assertFalse(matchableArguments.equals(nonEqualMatchableArguments));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/MockNameTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.*;\n+import org.junit.*;\n+\n+public class MockNameTest {\n+\n+    private MockControl<IMethods> control;\n+\n+    @Test\n+    public void defaultName() {\n+        control = MockControl.createControl(IMethods.class);\n+        String expected = \"EasyMock for \" + IMethods.class.toString();\n+        String actual = control.getMock().toString();\n+        assertEquals(expected, actual);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/NiceMockControlLongCompatibleReturnValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class NiceMockControlLongCompatibleReturnValueTest {\n+\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createNiceControl(IMethods.class);\n+        mock = control.getMock();\n+        control.replay();\n+    }\n+\n+    @Test\n+    public void byteReturningValue() {\n+        assertEquals((byte) 0, mock.byteReturningMethod(12));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void shortReturningValue() {\n+        assertEquals((short) 0, mock.shortReturningMethod(12));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void charReturningValue() {\n+        assertEquals((char) 0, mock.charReturningMethod(12));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void intReturningValue() {\n+        assertEquals(0, mock.intReturningMethod(12));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longReturningValue() {\n+        assertEquals((long) 0, mock.longReturningMethod(12));\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/NiceMockControlTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class NiceMockControlTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createNiceControl(IMethods.class);\n+        mock = control.getMock();\n+        control.replay();\n+    }\n+\n+    @Test\n+    public void defaultReturnValueBoolean() {\n+        assertEquals(false, mock.booleanReturningMethod(12));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void defaultReturnValueFloat() {\n+        assertEquals(0.0f, mock.floatReturningMethod(12), 0.0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void defaultReturnValueDouble() {\n+        assertEquals(0.0d, mock.doubleReturningMethod(12), 0.0d);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void defaultReturnValueObject() {\n+        assertEquals(null, mock.objectReturningMethod(12));\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/ObjectMethodsTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.MockControl;\n+import org.easymock.internal.MockInvocationHandler;\n+import org.easymock.internal.ObjectMethodsFilter;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ObjectMethodsTest {\n+    private MockControl<EmptyInterface> control;\n+\n+    private EmptyInterface mock;\n+\n+    private interface EmptyInterface {\n+    }\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(EmptyInterface.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void equalsBeforeActivation() {\n+        assertEquals(mock, mock);\n+        assertTrue(!mock.equals(null));\n+    }\n+\n+    @Test\n+    public void equalsAfterActivation() {\n+        control.replay();\n+        assertEquals(mock, mock);\n+        assertTrue(!mock.equals(null));\n+    }\n+\n+    @Test\n+    public void testHashCode() {\n+        int hashCodeBeforeActivation = mock.hashCode();\n+        control.replay();\n+        int hashCodeAfterActivation = mock.hashCode();\n+        assertEquals(hashCodeBeforeActivation, hashCodeAfterActivation);\n+    }\n+\n+    @Test\n+    public void toStringBeforeActivation() {\n+        assertEquals(\"EasyMock for \" + EmptyInterface.class.toString(), mock\n+                .toString());\n+    }\n+\n+    @Test\n+    public void toStringAfterActivation() {\n+        control.replay();\n+        assertEquals(\"EasyMock for \" + EmptyInterface.class.toString(), mock\n+                .toString());\n+    }\n+\n+    private static class MockedClass {\n+    }\n+\n+    private static class DummyProxy extends MockedClass {\n+    }\n+\n+    // if the class is no Proxy, ObjectMethodFilter should use the\n+    // superclasses' name. This is needed for the class extension.\n+    @Test\n+    public void toStringForClasses() throws Throwable {\n+        ObjectMethodsFilter filter = new ObjectMethodsFilter(Object.class, null, null);\n+        Method toString = Object.class.getMethod(\"toString\", new Class[0]);\n+        assertEquals(\"EasyMock for \" + MockedClass.class.toString(), filter\n+                .invoke(new DummyProxy(), toString, new Object[0]));\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidDefaultReturnValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidDefaultReturnValueTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void setInvalidDefaultBooleanReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setDefaultReturnValue(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidDefaultLongReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setDefaultReturnValue((long) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidDefaultFloatReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setDefaultReturnValue((float) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidDefaultDoubleReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setDefaultReturnValue((double) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidObjectDefaultReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setDefaultReturnValue(new Object());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDefaultReturnValueWithoutMethodCall() {\n+        try {\n+            control.setDefaultReturnValue(new Object());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default return value\",\n+                    e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidDefaultThrowableTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidDefaultThrowableTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    private class CheckedException extends Exception {\n+    }\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void throwNull() {\n+        mock.throwsNothing(false);\n+        try {\n+            control.setDefaultThrowable(null);\n+            fail(\"NullPointerException expected\");\n+        } catch (NullPointerException expected) {\n+            assertEquals(\"null cannot be thrown\", expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void throwCheckedExceptionWhereNoCheckedExceptionIsThrown() {\n+        mock.throwsNothing(false);\n+        try {\n+            control.setDefaultThrowable(new CheckedException());\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"last method called on mock cannot throw \"\n+                    + this.getClass().getName() + \"$CheckedException\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void throwWrongCheckedException() throws IOException {\n+        mock.throwsIOException(0);\n+        try {\n+            control.setDefaultThrowable(new CheckedException());\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"last method called on mock cannot throw \"\n+                    + this.getClass().getName() + \"$CheckedException\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDefaultThrowableWithoutMethodCall() throws IOException {\n+        try {\n+            control.setDefaultThrowable(new RuntimeException());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default Throwable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidMatcherTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidMatcherTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void setMatcherBeforeCallingMethods() {\n+        try {\n+            control.setMatcher(MockControl.ARRAY_MATCHER);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting matcher\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setMatcherTwice() {\n+        mock.simpleMethod();\n+        control.setMatcher(MockControl.ARRAY_MATCHER);\n+        try {\n+            control.setMatcher(MockControl.EQUALS_MATCHER);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"for method simpleMethod(), a matcher has already been set\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setMatcherTwice2() {\n+        mock.simpleMethodWithArgument(\"\");\n+        control.setMatcher(MockControl.ARRAY_MATCHER);\n+        try {\n+            control.setMatcher(MockControl.EQUALS_MATCHER);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"for method simpleMethodWithArgument(...), a matcher has already been set\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setSameMatcherTwice() {\n+        mock.simpleMethod();\n+        control.setMatcher(MockControl.ARRAY_MATCHER);\n+        try {\n+            control.setMatcher(MockControl.ARRAY_MATCHER);\n+        } catch (IllegalStateException unexpected) {\n+            fail(\"setting the same matcher should work\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidRangeTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidRangeTest {\n+\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void setOpenCallCountTwice() {\n+        mock.simpleMethod();\n+        control.setVoidCallable(MockControl.ONE_OR_MORE);\n+        try {\n+            control.setVoidCallable(MockControl.ONE_OR_MORE);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"last method called on mock already has a non-fixed count set.\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setIllegalMinimumCount() {\n+        mock.simpleMethod();\n+        int NEGATIVE = -1;\n+        try {\n+            control.setVoidCallable(NEGATIVE, 2);\n+            fail();\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"minimum must be >= 0\", expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setIllegalMaximumCount() {\n+        mock.simpleMethod();\n+        int NON_POSITIVE = 0;\n+        try {\n+            control.setVoidCallable(0, NON_POSITIVE);\n+            fail();\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"maximum must be >= 1\", expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setMinimumBiggerThanMaximum() {\n+        mock.simpleMethod();\n+        try {\n+            control.setVoidCallable(4, 3);\n+            fail();\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"minimum must be <= maximum\", expected.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidReturnValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidReturnValueTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void setInvalidBooleanReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void setInvalidLongReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((long) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidFloatReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((float) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidDoubleReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((double) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidObjectReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(new Object());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidBooleanReturnValueCount() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(false, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void setInvalidLongReturnValueCount() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((long) 0, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidFloatReturnValueCount() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((float) 0, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidDoubleReturnValueCount() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((double) 0, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setInvalidObjectReturnValueCount() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(new Object(), 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"incompatible return value type\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setReturnValueForVoidMethod() {\n+        mock.simpleMethod();\n+        try {\n+            control.setReturnValue(null);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"void method cannot return a value\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidStateChangeTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.easymock.internal.RecordState;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidStateChangeTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void activateWithoutReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            control.replay();\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\n+                    \"missing behavior definition for the preceeding method call oneArg(false)\",\n+                    e.getMessage());\n+            assertTrue(\"stack trace must be cut\", Util.getStackTrace(e)\n+                    .indexOf(RecordState.class.getName()) == -1);\n+        }\n+    }\n+\n+    @Test\n+    public void secondCallWithoutReturnValue() {\n+        mock.oneArg(false);\n+        try {\n+            mock.oneArg(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\n+                    \"missing behavior definition for the preceeding method call oneArg(false)\",\n+                    e.getMessage());\n+            assertTrue(\"stack trace must be cut\", Util.getStackTrace(e)\n+                    .indexOf(RecordState.class.getName()) == -1);\n+        }\n+    }\n+\n+    @Test\n+    public void verifyWithoutActivation() {\n+        try {\n+            control.verify();\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"calling verify is not allowed in record state\", e\n+                    .getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidThrowableTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidThrowableTest {\n+\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    private class CheckedException extends Exception {\n+    }\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void throwNull() {\n+        mock.throwsNothing(false);\n+        try {\n+            control.setThrowable(null);\n+            fail(\"NullPointerException expected\");\n+        } catch (NullPointerException expected) {\n+            assertEquals(\"null cannot be thrown\", expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void throwCheckedExceptionWhereNoCheckedExceptionIsThrown() {\n+        mock.throwsNothing(false);\n+        try {\n+            control.setThrowable(new CheckedException());\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"last method called on mock cannot throw \"\n+                    + CheckedException.class.getName(), expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void throwWrongCheckedException() throws IOException {\n+        mock.throwsIOException(0);\n+        try {\n+            control.setThrowable(new CheckedException());\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"last method called on mock cannot throw \"\n+                    + CheckedException.class.getName(), expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void throwAfterThrowable() throws IOException {\n+        mock.throwsIOException(0);\n+        control.setThrowable(new IOException(), MockControl.ONE_OR_MORE);\n+        try {\n+            control.setThrowable(new IOException());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"last method called on mock already has a non-fixed count set.\",\n+                    expected.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateInvalidUsageTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateInvalidUsageTest {\n+\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void setReturnValueWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setExpectedVoidCallCountWithoutMethodCall() {\n+        try {\n+            control.setVoidCallable(3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting void callable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void openVoidCallCountWithoutMethodCall() {\n+        try {\n+            control.setVoidCallable();\n+            fail(\"IllegalStateException expected\");\n+        } catch (Exception expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting void callable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueBoolean() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueShort() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((short) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueChar() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((char) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueInt() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueLong() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((long) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueFloat() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((float) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueDouble() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue((double) 0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setWrongReturnValueObject() {\n+        mock.oneArg(false);\n+        try {\n+            control.setReturnValue(new Object());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"incompatible return value type\", expected\n+                    .getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/RecordStateMethodCallMissingTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RecordStateMethodCallMissingTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void setBooleanReturnValueWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setLongReturnValueWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setFloatReturnValueWithoutMethodCall() {\n+        try {\n+            control.setReturnValue((float) 0.0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDoubleReturnValueWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(0.0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setObjectReturnValueWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(null);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setVoidCallableWithoutMethodCall() {\n+        try {\n+            control.setVoidCallable();\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting void callable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setThrowableWithoutMethodCall() {\n+        try {\n+            control.setThrowable(new RuntimeException());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting Throwable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setBooleanReturnValueCountWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(false, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setLongReturnValueCountWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(0, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setFloatReturnValueCountWithoutMethodCall() {\n+        try {\n+            control.setReturnValue((float) 0.0, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDoubleReturnValueCountWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(0.0, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setObjectReturnValueCountWithoutMethodCall() {\n+        try {\n+            control.setReturnValue(null, 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setVoidCallableCountWithoutMethodCall() {\n+        try {\n+            control.setVoidCallable(3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting void callable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setThrowableCountWithoutMethodCall() {\n+        try {\n+            control.setThrowable(new RuntimeException(), 3);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting Throwable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setBooleanDefaultReturnValueWithoutMethodCall() {\n+        try {\n+            control.setDefaultReturnValue(false);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setLongDefaultReturnValueWithoutMethodCall() {\n+        try {\n+            control.setDefaultReturnValue(0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setFloatDefaultReturnValueWithoutMethodCall() {\n+        try {\n+            control.setDefaultReturnValue((float) 0.0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDoubleDefaultReturnValueWithoutMethodCall() {\n+        try {\n+            control.setDefaultReturnValue(0.0);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setObjectDefaultReturnValueWithoutMethodCall() {\n+        try {\n+            control.setDefaultReturnValue(null);\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default return value\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDefaultVoidCallableWithoutMethodCall() {\n+        try {\n+            control.setDefaultVoidCallable();\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default void callable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void setDefaultThrowableWithoutMethodCall() {\n+        try {\n+            control.setDefaultThrowable(new RuntimeException());\n+            fail(\"IllegalStateException expected\");\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\n+                    \"method call on the mock needed before setting default Throwable\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void timesWithoutReturnValue() {\n+        mock.booleanReturningMethod(1);\n+        try {\n+            expectLastCall().times(3);\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"last method called on mock is not a void method\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void asStubWithNonVoidMethod() {\n+        mock.booleanReturningMethod(1);\n+        try {\n+            expectLastCall().asStub();\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"last method called on mock is not a void method\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/ReplayStateInvalidCallsTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import org.easymock.MockControl;\n+import org.easymock.internal.MocksBehavior;\n+import org.easymock.internal.ReplayState;\n+import org.easymock.internal.RuntimeExceptionWrapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ReplayStateInvalidCallsTest {\n+\n+    private ReplayState control;\n+\n+    private Exception exception;\n+\n+    @Before\n+    public void setUp() {\n+        exception = new Exception();\n+        control = new ReplayState(new MocksBehavior(false));\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void expectAndThrowLongWithMinMax() {\n+        control.andThrow(exception);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void expectAndReturnObjectWithMinMax() {\n+        control.andReturn(\"\");\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void setDefaultMatcher() {\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void asStub() {\n+        control.asStub();\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void setMatcher() {\n+        control.setMatcher(null, MockControl.ARRAY_MATCHER);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void setDefaultReturnValue() {\n+        control.setDefaultReturnValue(\"\");\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void setDefaultThrowable() {\n+        control.setDefaultThrowable(exception);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void setDefaultVoidCallable() {\n+        control.setDefaultVoidCallable();\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void replay() {\n+        control.replay();\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void checkOrder() {\n+        control.checkOrder(true);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void andStubReturn() {\n+        control.andStubReturn(\"7\");\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void andStubThrow() {\n+        control.andStubThrow(new RuntimeException());\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void andStubAnswer() {\n+        control.andStubAnswer(null);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void times() {\n+        control.times(MockControl.ONE);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void callback() {\n+        control.callback(new Runnable() {\n+            public void run() {\n+            };\n+        });\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void andReturn() {\n+        control.andReturn(null);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void andThrow() {\n+        control.andThrow(new RuntimeException());\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void andAnswer() {\n+        control.andAnswer(null);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void defaultThrowable() {\n+        control.setDefaultThrowable(new RuntimeException());\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void defaultReturnValue() {\n+        control.setDefaultReturnValue(null);\n+    }\n+\n+    @Test(expected = RuntimeExceptionWrapper.class)\n+    public void defaultVoidCallable() {\n+        control.setDefaultVoidCallable();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/ReplayStateInvalidUsageTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import org.easymock.EasyMock;\n+import org.easymock.IMocksControl;\n+import org.easymock.MockControl;\n+import org.easymock.internal.ReplayState;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ReplayStateInvalidUsageTest {\n+\n+    private MockControl<IMethods> control;\n+\n+    private Exception exception;\n+\n+    private ReplayState replayState;\n+\n+    private IMocksControl mocksControl;\n+\n+    @Before\n+    public void setUp() {\n+        exception = new Exception();\n+        control = MockControl.createControl(IMethods.class);\n+        control.replay();\n+        mocksControl = EasyMock.createControl();\n+        mocksControl.replay();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowObjectWithMinMax() {\n+        control.expectAndThrow(\"\", exception, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowDoubleWithMinMax() {\n+        control.expectAndThrow(0.0d, exception, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowFloatWithMinMax() {\n+        control.expectAndThrow(0.0f, exception, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowLongWithMinMax() {\n+        control.expectAndThrow(0, exception, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowBooleanWithMinMax() {\n+        control.expectAndThrow(false, exception, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowObjectWithCount() {\n+        control.expectAndThrow(\"\", exception, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowDoubleWithCount() {\n+        control.expectAndThrow(0.0d, exception, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowFloatWithCount() {\n+        control.expectAndThrow(0.0f, exception, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowLongWithCount() {\n+        control.expectAndThrow(0, exception, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowBooleanWithCount() {\n+        control.expectAndThrow(false, exception, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowObjectWithRange() {\n+        control.expectAndThrow(\"\", exception, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowDoubleWithRange() {\n+        control.expectAndThrow(0.0d, exception, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowFloatWithRange() {\n+        control.expectAndThrow(0.0f, exception, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowLongWithRange() {\n+        control.expectAndThrow(0, exception, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowBooleanWithRange() {\n+        control.expectAndThrow(false, exception, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowObject() {\n+        control.expectAndThrow(\"\", exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowDouble() {\n+        control.expectAndThrow(0.0d, exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowFloat() {\n+        control.expectAndThrow(0.0f, exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowLong() {\n+        control.expectAndThrow(0, exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndThrowBoolean() {\n+        control.expectAndThrow(false, exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnObjectWithMinMax() {\n+        control.expectAndReturn(\"\", \"\", 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnDoubleWithMinMax() {\n+        control.expectAndReturn(0.0d, 0.0d, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnFloatWithMinMax() {\n+        control.expectAndReturn(0.0f, 0.0f, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnLongWithMinMax() {\n+        control.expectAndReturn(0, 0, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnBooleanWithMinMax() {\n+        control.expectAndReturn(false, false, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnObjectWithCount() {\n+        control.expectAndReturn(\"\", \"\", 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnDoubleWithCount() {\n+        control.expectAndReturn(0.0d, 0.0d, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnFloatWithCount() {\n+        control.expectAndReturn(0.0f, 0.0f, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnLongWithCount() {\n+        control.expectAndReturn(0, 0, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnBooleanWithCount() {\n+        control.expectAndReturn(false, false, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnObjectWithRange() {\n+        control.expectAndReturn(\"\", \"\", MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnDoubleWithRange() {\n+        control.expectAndReturn(0.0d, 0.0d, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnFloatWithRange() {\n+        control.expectAndReturn(0.0f, 0.0f, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnLongWithRange() {\n+        control.expectAndReturn(0, 0, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnBooleanWithRange() {\n+        control.expectAndReturn(false, false, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnObject() {\n+        control.expectAndReturn(\"\", \"\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnDouble() {\n+        control.expectAndReturn(0.0d, 0.0d);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnFloat() {\n+        control.expectAndReturn(0.0f, 0.0f);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnLong() {\n+        control.expectAndReturn(0, 0);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void expectAndReturnBoolean() {\n+        control.expectAndReturn(false, false);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultMatcher() {\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueObjectWithMinMax() {\n+        control.setReturnValue(\"\", 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueDoubleWithMinMax() {\n+        control.setReturnValue(0.0d, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueFloatWithMinMax() {\n+        control.setReturnValue(0.0f, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueLongWithMinMax() {\n+        control.setReturnValue(0, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueBooleanWithMinMax() {\n+        control.setReturnValue(false, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setThrowableWithMinMax() {\n+        control.setThrowable(exception, 1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setVoidCallableWithMinMax() {\n+        control.setVoidCallable(1, 2);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setMatcher() {\n+        control.setMatcher(MockControl.ARRAY_MATCHER);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultReturnValueObject() {\n+        control.setDefaultReturnValue(\"\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultReturnValueDouble() {\n+        control.setDefaultReturnValue(0.0d);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultReturnValueFloat() {\n+        control.setDefaultReturnValue(0.0f);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultReturnValueLong() {\n+        control.setDefaultReturnValue(0);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultReturnValueBoolean() {\n+        control.setDefaultReturnValue(false);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultThrowable() {\n+        control.setDefaultThrowable(exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setDefaultVoidCallable() {\n+        control.setDefaultVoidCallable();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueObjectWithRange() {\n+        control.setReturnValue(\"\", MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueLongWithRange() {\n+        control.setReturnValue(0, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueFloatWithRange() {\n+        control.setReturnValue(0.0f, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueDoubleWithRange() {\n+        control.setReturnValue(0.0d, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueBooleanWithRange() {\n+        control.setReturnValue(false, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setThrowableWithRange() {\n+        control.setThrowable(exception, MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setVoidCallableWithRange() {\n+        control.setVoidCallable(MockControl.ONE);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueObjectWithCount() {\n+        control.setReturnValue(\"\", 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueLongWithCount() {\n+        control.setReturnValue(0, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueFloatWithCount() {\n+        control.setReturnValue(0.0f, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueDoubleWithCount() {\n+        control.setReturnValue(0.0d, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueBooleanWithCount() {\n+        control.setReturnValue(false, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setThrowableWithCount() {\n+        control.setThrowable(exception, 1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setVoidCallableWithCount() {\n+        control.setVoidCallable(1);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueObject() {\n+        control.setReturnValue(\"\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueDouble() {\n+        control.setReturnValue(0.0d);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueFloat() {\n+        control.setReturnValue(0.0f);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueLong() {\n+        control.setReturnValue(0);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setReturnValueBoolean() {\n+        control.setReturnValue(false);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setThrowable() {\n+        control.setThrowable(exception);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void setVoidCallable() {\n+        control.setVoidCallable();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void replay() {\n+        control.replay();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void createMock() {\n+        mocksControl.createMock(IMethods.class);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void createMockWithName() {\n+        mocksControl.createMock(\"\", IMethods.class);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void checkOrder() {\n+        mocksControl.checkOrder(true);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void andStubReturn() {\n+        mocksControl.andStubReturn(\"7\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void andStubThrow() {\n+        mocksControl.andStubThrow(new RuntimeException());\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void asStub() {\n+        mocksControl.asStub();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void times() {\n+        mocksControl.times(3);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void anyTimes() {\n+        mocksControl.anyTimes();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/StacktraceTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class StacktraceTest {\n+\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createStrictControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    private static class ToStringThrowsException {\n+        @Override\n+        public String toString() {\n+            throw new NullPointerException();\n+        }\n+    }\n+\n+    @Test\n+    public void assertRecordStateNoFillInStacktraceWhenExceptionNotFromEasyMock() {\n+        mock.oneArg(new ToStringThrowsException());\n+        try {\n+            mock.oneArg(new ToStringThrowsException());\n+        } catch (NullPointerException expected) {\n+            assertTrue(\"stack trace must not be cut\",\n+                    Util.getStackTrace(expected).indexOf(\n+                            ToStringThrowsException.class.getName()) > 0);\n+        }\n+    }\n+\n+    @Test\n+    public void assertReplayNoFillInStacktraceWhenExceptionNotFromEasyMock() {\n+        mock.oneArg(new ToStringThrowsException());\n+        try {\n+            control.replay();\n+        } catch (NullPointerException expected) {\n+            assertTrue(\"stack trace must not be cut\",\n+                    Util.getStackTrace(expected).indexOf(\n+                            ToStringThrowsException.class.getName()) > 0);\n+        }\n+    }\n+\n+    @Test\n+    public void assertReplayStateNoFillInStacktraceWhenExceptionNotFromEasyMock() {\n+        control.replay();\n+        try {\n+            mock.oneArg(new ToStringThrowsException());\n+        } catch (NullPointerException expected) {\n+            assertTrue(\"stack trace must not be cut\",\n+                    Util.getStackTrace(expected).indexOf(\n+                            ToStringThrowsException.class.getName()) > 0);\n+        }\n+    }\n+\n+    @Test\n+    public void assertVerifyNoFillInStacktraceWhenExceptionNotFromEasyMock() {\n+        mock.oneArg(new ToStringThrowsException());\n+        control.setReturnValue(\"\");\n+        control.replay();\n+        try {\n+            control.verify();\n+            fail();\n+        } catch (NullPointerException expected) {\n+            assertTrue(\"stack trace must not be cut\",\n+                    Util.getStackTrace(expected).indexOf(\n+                            ToStringThrowsException.class.getName()) > 0);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageCallCountTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageCallCountTest {\n+\n+    private MockControl<VoidMethodInterface> control;\n+\n+    private VoidMethodInterface mock;\n+\n+    private interface VoidMethodInterface {\n+        void method();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(VoidMethodInterface.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void mockWithNoExpectedCallsPassesWithNoCalls() {\n+        control.replay();\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void mockWithNoExpectedCallsFailsAtFirstCall() {\n+        control.replay();\n+        assertMethodCallFails();\n+    }\n+\n+    @Test\n+    public void mockWithOneExpectedCallFailsAtVerify() {\n+        callMethodOnce();\n+        control.replay();\n+        assertVerifyFails();\n+    }\n+\n+    @Test\n+    public void mockWithOneExpectedCallPassesWithOneCall() {\n+        callMethodOnce();\n+        control.replay();\n+        callMethodOnce();\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void mockWithOneExpectedCallFailsAtSecondCall() {\n+        callMethodOnce();\n+        control.replay();\n+        callMethodOnce();\n+        assertMethodCallFails();\n+    }\n+\n+    @Test\n+    public void tooFewCalls() {\n+        callMethodThreeTimes();\n+        control.replay();\n+        callMethodTwice();\n+        assertVerifyFails();\n+    }\n+\n+    @Test\n+    public void correctNumberOfCalls() {\n+        callMethodThreeTimes();\n+        control.replay();\n+        callMethodThreeTimes();\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void tooManyCalls() {\n+        callMethodThreeTimes();\n+        control.replay();\n+        callMethodThreeTimes();\n+        assertMethodCallFails();\n+    }\n+\n+    private void callMethodOnce() {\n+        mock.method();\n+    }\n+\n+    private void callMethodTwice() {\n+        mock.method();\n+        mock.method();\n+    }\n+\n+    private void callMethodThreeTimes() {\n+        mock.method();\n+        mock.method();\n+        mock.method();\n+    }\n+\n+    private void assertVerifyFails() {\n+        try {\n+            control.verify();\n+            fail(\"Expected AssertionError\");\n+        } catch (AssertionError expected) {\n+        }\n+    }\n+\n+    private void assertMethodCallFails() {\n+        try {\n+            mock.method();\n+            fail(\"Expected AssertionError\");\n+        } catch (AssertionError expected) {\n+        }\n+    }\n+\n+    @Test\n+    public void noUpperLimitWithoutCallCountSet() {\n+        mock.method();\n+        control.setVoidCallable(MockControl.ONE_OR_MORE);\n+        control.replay();\n+        assertVerifyFails();\n+        mock.method();\n+        control.verify();\n+        mock.method();\n+        control.verify();\n+        mock.method();\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageDefaultReturnValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageDefaultReturnValueTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void defaultReturnValue() {\n+        mock.threeArgumentMethod(7, \"\", \"test\");\n+        control.setReturnValue(\"test\", 1);\n+\n+        mock.threeArgumentMethod(8, null, \"test2\");\n+        control.setReturnValue(\"test2\", 1);\n+\n+        Object defaultValue = new Object();\n+        control.setDefaultReturnValue(defaultValue);\n+\n+        control.replay();\n+        assertEquals(\"test\", mock.threeArgumentMethod(7, \"\", \"test\"));\n+        assertEquals(\"test2\", mock.threeArgumentMethod(8, null, \"test2\"));\n+        assertSame(defaultValue, mock.threeArgumentMethod(7, new Object(),\n+                \"test\"));\n+        assertSame(defaultValue, mock.threeArgumentMethod(7, \"\", \"test\"));\n+        assertSame(defaultValue, mock.threeArgumentMethod(8, null, \"test\"));\n+        assertSame(defaultValue, mock.threeArgumentMethod(9, null, \"test\"));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void defaultVoidCallable() {\n+\n+        mock.twoArgumentMethod(1, 2);\n+        control.setDefaultVoidCallable();\n+\n+        mock.twoArgumentMethod(1, 1);\n+        RuntimeException expected = new RuntimeException();\n+        control.setThrowable(expected);\n+\n+        control.replay();\n+        mock.twoArgumentMethod(2, 1);\n+        mock.twoArgumentMethod(1, 2);\n+        mock.twoArgumentMethod(3, 7);\n+\n+        try {\n+            mock.twoArgumentMethod(1, 1);\n+            fail(\"RuntimeException expected\");\n+        } catch (RuntimeException actual) {\n+            assertSame(expected, actual);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void defaultThrowable() {\n+        mock.twoArgumentMethod(1, 2);\n+        control.setVoidCallable();\n+        mock.twoArgumentMethod(1, 1);\n+        control.setVoidCallable();\n+\n+        RuntimeException expected = new RuntimeException();\n+        control.setDefaultThrowable(expected);\n+\n+        control.replay();\n+\n+        mock.twoArgumentMethod(1, 2);\n+        mock.twoArgumentMethod(1, 1);\n+        try {\n+            mock.twoArgumentMethod(2, 1);\n+            fail(\"RuntimeException expected\");\n+        } catch (RuntimeException actual) {\n+            assertSame(expected, actual);\n+        }\n+    }\n+\n+    @Test\n+    public void defaultReturnValueBoolean() {\n+        mock.booleanReturningMethod(12);\n+        control.setReturnValue(true);\n+        control.setDefaultReturnValue(false);\n+\n+        control.replay();\n+\n+        assertFalse(mock.booleanReturningMethod(11));\n+        assertTrue(mock.booleanReturningMethod(12));\n+        assertFalse(mock.booleanReturningMethod(13));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void returnValueAndDefaultReturnValue() throws Exception {\n+\n+        mock.oneArg(\"\");\n+\n+        expectLastCall().andReturn(\"1\");\n+        control.setDefaultReturnValue(\"2\");\n+\n+        control.replay();\n+\n+        assertEquals(\"1\", mock.oneArg(\"\"));\n+        assertEquals(\"2\", mock.oneArg(\"\"));\n+        assertEquals(\"2\", mock.oneArg(\"X\"));\n+\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageExpectAndDefaultReturnTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Same as UsageExpectAndReturnTest except that each mocked method is called\n+ * twice to make sure the defaulting works fine.\n+ * \n+ * @author Henri Tremblay\n+ */\n+public class UsageExpectAndDefaultReturnTest {\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void booleanType() {\n+        control.expectAndDefaultReturn(mock.booleanReturningMethod(4), true);\n+        control.replay();\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longType() {\n+        control.expectAndDefaultReturn(mock.longReturningMethod(4), 12l);\n+        control.replay();\n+        assertEquals(12l, mock.longReturningMethod(4));\n+        assertEquals(12l, mock.longReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatType() {\n+        control.expectAndDefaultReturn(mock.floatReturningMethod(4), 12f);\n+        control.replay();\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleType() {\n+        control.expectAndDefaultReturn(mock.doubleReturningMethod(4), 12.0);\n+        control.replay();\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectType() {\n+        control.expectAndDefaultReturn(mock.objectReturningMethod(4), \"12\");\n+        control.replay();\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        control.verify();\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageExpectAndDefaultThrowTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Same as UsageExpectAndThrowTest except that each mocked method is called\n+ * twice to make sure the defaulting works fine.\n+ * \n+ * @author Henri Tremblay\n+ */\n+public class UsageExpectAndDefaultThrowTest {\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    private static RuntimeException EXCEPTION = new RuntimeException();\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void booleanType() {\n+        control\n+                .expectAndDefaultThrow(mock.booleanReturningMethod(4),\n+                        EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longType() {\n+        control.expectAndDefaultThrow(mock.longReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatType() {\n+        control.expectAndDefaultThrow(mock.floatReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleType() {\n+        control.expectAndDefaultThrow(mock.doubleReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void object() {\n+        control.expectAndDefaultThrow(mock.objectReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void throwableAndDefaultThrowable() throws Exception {\n+\n+        mock.oneArg(\"1\");\n+\n+        expectLastCall().andThrow(new IllegalArgumentException());\n+        control.setDefaultThrowable(new IllegalStateException());\n+\n+        control.replay();\n+\n+        try {\n+            mock.oneArg(\"1\");\n+        } catch (IllegalArgumentException ignored) {\n+        }\n+        try {\n+            mock.oneArg(\"1\");\n+        } catch (IllegalStateException ignored) {\n+        }\n+        try {\n+            mock.oneArg(\"2\");\n+        } catch (IllegalStateException ignored) {\n+        }\n+        control.verify();\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageExpectAndReturnTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageExpectAndReturnTest {\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void booleanType() {\n+        control.expectAndReturn(mock.booleanReturningMethod(4), true);\n+        control.replay();\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longType() {\n+        control.expectAndReturn(mock.longReturningMethod(4), 12l);\n+        control.replay();\n+        assertEquals((long) 12, mock.longReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatType() {\n+        control.expectAndReturn(mock.floatReturningMethod(4), 12f);\n+        control.replay();\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleType() {\n+        control.expectAndReturn(mock.doubleReturningMethod(4), 12.0);\n+        control.replay();\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void object() {\n+        control.expectAndReturn(mock.objectReturningMethod(4), \"12\");\n+        control.replay();\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void booleanAndRange() {\n+        control.expectAndReturn(mock.booleanReturningMethod(4), true,\n+                MockControl.ONE);\n+        control.replay();\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longAndRange() {\n+        control.expectAndReturn(mock.longReturningMethod(4), 12l,\n+                MockControl.ONE);\n+        control.replay();\n+        assertEquals((long) 12, mock.longReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatAndRange() {\n+        control.expectAndReturn(mock.floatReturningMethod(4), 12f,\n+                MockControl.ONE);\n+        control.replay();\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleAndRange() {\n+        control.expectAndReturn(mock.doubleReturningMethod(4), 12.0,\n+                MockControl.ONE);\n+        control.replay();\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectAndRange() {\n+        control.expectAndReturn(mock.objectReturningMethod(4), \"12\",\n+                MockControl.ONE);\n+        control.replay();\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void booleanAndCount() {\n+        control.expectAndReturn(mock.booleanReturningMethod(4), true, 2);\n+        control.replay();\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longAndCount() {\n+        control.expectAndReturn(mock.longReturningMethod(4), 12l, 2);\n+        control.replay();\n+        assertEquals((long) 12, mock.longReturningMethod(4));\n+        assertEquals((long) 12, mock.longReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatAndCount() {\n+        control.expectAndReturn(mock.floatReturningMethod(4), 12f, 2);\n+        control.replay();\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleAndCount() {\n+        control.expectAndReturn(mock.doubleReturningMethod(4), 12.0, 2);\n+        control.replay();\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectAndCount() {\n+        control.expectAndReturn(mock.objectReturningMethod(4), \"12\", 2);\n+        control.replay();\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void booleanAndMinMax() {\n+        control.expectAndReturn(mock.booleanReturningMethod(4), true, 2, 3);\n+        control.replay();\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        assertEquals(true, mock.booleanReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longAndMinMax() {\n+        control.expectAndReturn(mock.longReturningMethod(4), 12l, 2, 3);\n+        control.replay();\n+        assertEquals((long) 12, mock.longReturningMethod(4));\n+        assertEquals((long) 12, mock.longReturningMethod(4));\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatAndMinMax() {\n+        control.expectAndReturn(mock.floatReturningMethod(4), 12f, 2, 3);\n+        control.replay();\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        assertEquals(12f, mock.floatReturningMethod(4), 0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleAndMinMax() {\n+        control.expectAndReturn(mock.doubleReturningMethod(4), 12.0, 2, 3);\n+        control.replay();\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        assertEquals(12.0, mock.doubleReturningMethod(4), 0.0);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectAndMinMax() {\n+        control.expectAndReturn(mock.objectReturningMethod(4), \"12\", 2, 3);\n+        control.replay();\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        assertEquals(\"12\", mock.objectReturningMethod(4));\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageExpectAndThrowTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageExpectAndThrowTest {\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    private static RuntimeException EXCEPTION = new RuntimeException();\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void booleanType() {\n+        control.expectAndThrow(mock.booleanReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longType() {\n+        control.expectAndThrow(mock.longReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatType() {\n+        control.expectAndThrow(mock.floatReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleType() {\n+        control.expectAndThrow(mock.doubleReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void object() {\n+        control.expectAndThrow(mock.objectReturningMethod(4), EXCEPTION);\n+        control.replay();\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void booleanAndRange() {\n+        control.expectAndThrow(mock.booleanReturningMethod(4), EXCEPTION,\n+                MockControl.ONE);\n+        control.replay();\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longAndRange() {\n+        control.expectAndThrow(mock.longReturningMethod(4), EXCEPTION,\n+                MockControl.ONE);\n+        control.replay();\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatAndRange() {\n+        control.expectAndThrow(mock.floatReturningMethod(4), EXCEPTION,\n+                MockControl.ONE);\n+        control.replay();\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleAndRange() {\n+        control.expectAndThrow(mock.doubleReturningMethod(4), EXCEPTION,\n+                MockControl.ONE);\n+        control.replay();\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectAndRange() {\n+        control.expectAndThrow(mock.objectReturningMethod(4), EXCEPTION,\n+                MockControl.ONE);\n+        control.replay();\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void booleanAndCount() {\n+        control.expectAndThrow(mock.booleanReturningMethod(4), EXCEPTION, 2);\n+        control.replay();\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longAndCount() {\n+        control.expectAndThrow(mock.longReturningMethod(4), EXCEPTION, 2);\n+        control.replay();\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatAndCount() {\n+        control.expectAndThrow(mock.floatReturningMethod(4), EXCEPTION, 2);\n+        control.replay();\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleAndCount() {\n+        control.expectAndThrow(mock.doubleReturningMethod(4), EXCEPTION, 2);\n+        control.replay();\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectAndCount() {\n+        control.expectAndThrow(mock.objectReturningMethod(4), EXCEPTION, 2);\n+        control.replay();\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void booleanAndMinMax() {\n+        control.expectAndThrow(mock.booleanReturningMethod(4), EXCEPTION, 2, 3);\n+        control.replay();\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+        try {\n+            mock.booleanReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void longAndMinMax() {\n+        control.expectAndThrow(mock.longReturningMethod(4), EXCEPTION, 2, 3);\n+        control.replay();\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+        try {\n+            mock.longReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void floatAndMinMax() {\n+        control.expectAndThrow(mock.floatReturningMethod(4), EXCEPTION, 2, 3);\n+        control.replay();\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+        try {\n+            mock.floatReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void doubleAndMinMax() {\n+        control.expectAndThrow(mock.doubleReturningMethod(4), EXCEPTION, 2, 3);\n+        control.replay();\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+        try {\n+            mock.doubleReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void objectAndMinMax() {\n+        control.expectAndThrow(mock.objectReturningMethod(4), EXCEPTION, 2, 3);\n+        control.replay();\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+        try {\n+            mock.objectReturningMethod(4);\n+            fail();\n+        } catch (RuntimeException exception) {\n+            assertSame(EXCEPTION, exception);\n+        }\n+        control.verify();\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageFloatingPointReturnValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageFloatingPointReturnValueTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void returnFloat() {\n+        mock.floatReturningMethod(0);\n+        control.setReturnValue(25.0F);\n+        control.setDefaultReturnValue(34.0F);\n+\n+        control.replay();\n+\n+        assertEquals(25.0F, mock.floatReturningMethod(0), 0.0F);\n+        assertEquals(34.0F, mock.floatReturningMethod(-4), 0.0F);\n+        assertEquals(34.0F, mock.floatReturningMethod(12), 0.0F);\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void returnDouble() {\n+        mock.doubleReturningMethod(0);\n+        control.setReturnValue(25.0);\n+        control.setDefaultReturnValue(34.0);\n+\n+        control.replay();\n+\n+        assertEquals(25.0, mock.doubleReturningMethod(0), 0.0);\n+        assertEquals(34.0, mock.doubleReturningMethod(-4), 0.0);\n+        assertEquals(34.0, mock.doubleReturningMethod(12), 0.0);\n+\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageLongCompatibleReturnValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageLongCompatibleReturnValueTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void returnByte() {\n+        mock.byteReturningMethod(0);\n+        control.setReturnValue(25);\n+        control.setDefaultReturnValue(34);\n+\n+        control.replay();\n+\n+        assertEquals((byte) 25, mock.byteReturningMethod(0));\n+        assertEquals((byte) 34, mock.byteReturningMethod(-4));\n+        assertEquals((byte) 34, mock.byteReturningMethod(12));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void returnShort() {\n+        mock.shortReturningMethod(0);\n+        control.setReturnValue(25);\n+        control.setDefaultReturnValue(34);\n+\n+        control.replay();\n+\n+        assertEquals((short) 25, mock.shortReturningMethod(0));\n+        assertEquals((short) 34, mock.shortReturningMethod(-4));\n+        assertEquals((short) 34, mock.shortReturningMethod(12));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void returnChar() {\n+        mock.charReturningMethod(0);\n+        control.setReturnValue(25);\n+        control.setDefaultReturnValue(34);\n+\n+        control.replay();\n+\n+        assertEquals((char) 25, mock.charReturningMethod(0));\n+        assertEquals((char) 34, mock.charReturningMethod(-4));\n+        assertEquals((char) 34, mock.charReturningMethod(12));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void returnInt() {\n+        mock.intReturningMethod(0);\n+        control.setReturnValue(25);\n+        control.setDefaultReturnValue(34);\n+\n+        control.replay();\n+\n+        assertEquals(25, mock.intReturningMethod(0));\n+        assertEquals(34, mock.intReturningMethod(-4));\n+        assertEquals(34, mock.intReturningMethod(12));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void returnLong() {\n+        mock.longReturningMethod(0);\n+        control.setReturnValue(25);\n+        control.setDefaultReturnValue(34);\n+\n+        control.replay();\n+\n+        assertEquals((long) 25, mock.longReturningMethod(0));\n+        assertEquals((long) 34, mock.longReturningMethod(-4));\n+        assertEquals((long) 34, mock.longReturningMethod(12));\n+\n+        control.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageOverloadedDefaultValueTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageOverloadedDefaultValueTest {\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void overloading() {\n+\n+        mock.oneArg(true);\n+        control.setReturnValue(\"true\");\n+        control.setDefaultReturnValue(\"false\");\n+\n+        mock.oneArg((byte) 0);\n+        control.setReturnValue(\"byte 0\");\n+        control.setDefaultReturnValue(\"byte 1\");\n+\n+        mock.oneArg((short) 0);\n+        control.setReturnValue(\"short 0\");\n+        control.setDefaultReturnValue(\"short 1\");\n+\n+        mock.oneArg((char) 0);\n+        control.setReturnValue(\"char 0\");\n+        control.setDefaultReturnValue(\"char 1\");\n+\n+        mock.oneArg(0);\n+        control.setReturnValue(\"int 0\");\n+        control.setDefaultReturnValue(\"int 1\");\n+\n+        mock.oneArg((long) 0);\n+        control.setReturnValue(\"long 0\");\n+        control.setDefaultReturnValue(\"long 1\");\n+\n+        mock.oneArg((float) 0);\n+        control.setReturnValue(\"float 0\");\n+        control.setDefaultReturnValue(\"float 1\");\n+\n+        mock.oneArg(0.0);\n+        control.setReturnValue(\"double 0\");\n+        control.setDefaultReturnValue(\"double 1\");\n+\n+        mock.oneArg(\"Object 0\");\n+        control.setReturnValue(\"String 0\");\n+        control.setDefaultReturnValue(\"String 1\");\n+\n+        control.replay();\n+\n+        assertEquals(\"true\", mock.oneArg(true));\n+        assertEquals(\"false\", mock.oneArg(false));\n+\n+        assertEquals(\"byte 0\", mock.oneArg((byte) 0));\n+        assertEquals(\"byte 1\", mock.oneArg((byte) 1));\n+\n+        assertEquals(\"short 0\", mock.oneArg((short) 0));\n+        assertEquals(\"short 1\", mock.oneArg((short) 1));\n+\n+        assertEquals(\"char 0\", mock.oneArg((char) 0));\n+        assertEquals(\"char 1\", mock.oneArg((char) 1));\n+\n+        assertEquals(\"int 0\", mock.oneArg(0));\n+        assertEquals(\"int 1\", mock.oneArg(1));\n+\n+        assertEquals(\"long 0\", mock.oneArg((long) 0));\n+        assertEquals(\"long 1\", mock.oneArg((long) 1));\n+\n+        assertEquals(\"float 0\", mock.oneArg((float) 0.0));\n+        assertEquals(\"float 1\", mock.oneArg((float) 1.0));\n+\n+        assertEquals(\"double 0\", mock.oneArg(0.0));\n+        assertEquals(\"double 1\", mock.oneArg(1.0));\n+\n+        assertEquals(\"String 0\", mock.oneArg(\"Object 0\"));\n+        assertEquals(\"String 1\", mock.oneArg(\"Object 1\"));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void defaultThrowable() {\n+\n+        mock.oneArg(\"Object\");\n+        RuntimeException expected = new RuntimeException();\n+        control.setDefaultThrowable(expected);\n+\n+        control.replay();\n+\n+        try {\n+            mock.oneArg(\"Something else\");\n+            fail(\"runtime exception expected\");\n+        } catch (RuntimeException expectedException) {\n+            assertSame(expected, expectedException);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageOverloadedMethodTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageOverloadedMethodTest {\n+\n+    MockControl<IMethods> controller;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        controller = MockControl.createControl(IMethods.class);\n+        mock = controller.getMock();\n+    }\n+\n+    @Test\n+    public void overloading() {\n+\n+        mock.oneArg(true);\n+        controller.setReturnValue(\"true\");\n+        mock.oneArg(false);\n+        controller.setReturnValue(\"false\");\n+\n+        mock.oneArg((byte) 0);\n+        controller.setReturnValue(\"byte 0\");\n+        mock.oneArg((byte) 1);\n+        controller.setReturnValue(\"byte 1\");\n+\n+        mock.oneArg((short) 0);\n+        controller.setReturnValue(\"short 0\");\n+        mock.oneArg((short) 1);\n+        controller.setReturnValue(\"short 1\");\n+\n+        mock.oneArg((char) 0);\n+        controller.setReturnValue(\"char 0\");\n+        mock.oneArg((char) 1);\n+        controller.setReturnValue(\"char 1\");\n+\n+        mock.oneArg(0);\n+        controller.setReturnValue(\"int 0\");\n+        mock.oneArg(1);\n+        controller.setReturnValue(\"int 1\");\n+\n+        mock.oneArg((long) 0);\n+        controller.setReturnValue(\"long 0\");\n+        mock.oneArg((long) 1);\n+        controller.setReturnValue(\"long 1\");\n+\n+        mock.oneArg((float) 0);\n+        controller.setReturnValue(\"float 0\");\n+        mock.oneArg((float) 1);\n+        controller.setReturnValue(\"float 1\");\n+\n+        mock.oneArg(0.0);\n+        controller.setReturnValue(\"double 0\");\n+        mock.oneArg(1.0);\n+        controller.setReturnValue(\"double 1\");\n+\n+        mock.oneArg(\"Object 0\");\n+        controller.setReturnValue(\"1\");\n+        mock.oneArg(\"Object 1\");\n+        controller.setReturnValue(\"2\");\n+\n+        controller.replay();\n+\n+        assertEquals(\"true\", mock.oneArg(true));\n+        assertEquals(\"false\", mock.oneArg(false));\n+\n+        assertEquals(\"byte 0\", mock.oneArg((byte) 0));\n+        assertEquals(\"byte 1\", mock.oneArg((byte) 1));\n+\n+        assertEquals(\"short 0\", mock.oneArg((short) 0));\n+        assertEquals(\"short 1\", mock.oneArg((short) 1));\n+\n+        assertEquals(\"char 0\", mock.oneArg((char) 0));\n+        assertEquals(\"char 1\", mock.oneArg((char) 1));\n+\n+        assertEquals(\"int 0\", mock.oneArg(0));\n+        assertEquals(\"int 1\", mock.oneArg(1));\n+\n+        assertEquals(\"long 0\", mock.oneArg((long) 0));\n+        assertEquals(\"long 1\", mock.oneArg((long) 1));\n+\n+        assertEquals(\"float 0\", mock.oneArg((float) 0.0));\n+        assertEquals(\"float 1\", mock.oneArg((float) 1.0));\n+\n+        assertEquals(\"double 1\", mock.oneArg(1.0));\n+        assertEquals(\"double 0\", mock.oneArg(0.0));\n+\n+        assertEquals(\"1\", mock.oneArg(\"Object 0\"));\n+        assertEquals(\"2\", mock.oneArg(\"Object 1\"));\n+\n+        controller.verify();\n+    }\n+\n+    @Test\n+    public void nullReturnValue() {\n+\n+        mock.oneArg(\"Object\");\n+        controller.setReturnValue(null);\n+\n+        controller.replay();\n+\n+        assertNull(mock.oneArg(\"Object\"));\n+\n+    }\n+\n+    @Test\n+    public void moreThanOneResultAndOpenCallCount() {\n+        mock.oneArg(true);\n+        controller.setReturnValue(\"First Result\", 4);\n+        controller.setReturnValue(\"Second Result\", 2);\n+        controller.setThrowable(new RuntimeException(\"Third Result\"), 3);\n+        controller.setReturnValue(\"Following Result\", MockControl.ONE_OR_MORE);\n+\n+        controller.replay();\n+\n+        assertEquals(\"First Result\", mock.oneArg(true));\n+        assertEquals(\"First Result\", mock.oneArg(true));\n+        assertEquals(\"First Result\", mock.oneArg(true));\n+        assertEquals(\"First Result\", mock.oneArg(true));\n+\n+        assertEquals(\"Second Result\", mock.oneArg(true));\n+        assertEquals(\"Second Result\", mock.oneArg(true));\n+\n+        try {\n+            mock.oneArg(true);\n+            fail(\"expected exception\");\n+        } catch (RuntimeException expected) {\n+            assertEquals(\"Third Result\", expected.getMessage());\n+        }\n+\n+        try {\n+            mock.oneArg(true);\n+            fail(\"expected exception\");\n+        } catch (RuntimeException expected) {\n+            assertEquals(\"Third Result\", expected.getMessage());\n+        }\n+\n+        try {\n+            mock.oneArg(true);\n+            fail(\"expected exception\");\n+        } catch (RuntimeException expected) {\n+            assertEquals(\"Third Result\", expected.getMessage());\n+        }\n+\n+        assertEquals(\"Following Result\", mock.oneArg(true));\n+        assertEquals(\"Following Result\", mock.oneArg(true));\n+        assertEquals(\"Following Result\", mock.oneArg(true));\n+        assertEquals(\"Following Result\", mock.oneArg(true));\n+        assertEquals(\"Following Result\", mock.oneArg(true));\n+\n+        controller.verify();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageRangeTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.Iterator;\n+\n+import org.easymock.MockControl;\n+import org.easymock.internal.Range;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageRangeTest {\n+\n+    private Iterator mock;\n+\n+    private MockControl<Iterator> control;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createStrictControl(Iterator.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void zeroOrMoreNoCalls() {\n+        mock.hasNext();\n+        control.setReturnValue(false, MockControl.ZERO_OR_MORE);\n+        control.replay();\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void zeroOrMoreOneCall() {\n+        mock.hasNext();\n+        control.setReturnValue(false, MockControl.ZERO_OR_MORE);\n+        control.replay();\n+        assertFalse(mock.hasNext());\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void zeroOrMoreThreeCalls() {\n+        mock.hasNext();\n+        control.setReturnValue(false, MockControl.ZERO_OR_MORE);\n+        control.replay();\n+        assertFalse(mock.hasNext());\n+        assertFalse(mock.hasNext());\n+        assertFalse(mock.hasNext());\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void combination() {\n+        mock.hasNext();\n+        control.setReturnValue(true, MockControl.ONE_OR_MORE);\n+        mock.next();\n+        control.setReturnValue(\"1\");\n+\n+        mock.hasNext();\n+        control.setReturnValue(true, MockControl.ONE_OR_MORE);\n+        mock.next();\n+        control.setReturnValue(\"2\");\n+\n+        mock.hasNext();\n+        control.setReturnValue(false, MockControl.ONE_OR_MORE);\n+\n+        control.replay();\n+\n+        assertTrue(mock.hasNext());\n+        assertTrue(mock.hasNext());\n+        assertTrue(mock.hasNext());\n+\n+        assertEquals(\"1\", mock.next());\n+\n+        try {\n+            mock.next();\n+            fail();\n+        } catch (AssertionError expected) {\n+        }\n+\n+        assertTrue(mock.hasNext());\n+\n+        assertEquals(\"2\", mock.next());\n+\n+        assertFalse(mock.hasNext());\n+\n+        control.verify();\n+\n+    }\n+\n+    @Test\n+    public void withIllegalOwnRange() {\n+        mock.hasNext();\n+        try {\n+            control.setReturnValue(true, new Range(2, 7));\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Unexpected Range\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageStrictMockTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.easymock.internal.ReplayState;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageStrictMockTest {\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createStrictControl(IMethods.class);\n+        mock = control.getMock();\n+\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        control.replay();\n+    }\n+\n+    @Test\n+    public void verify() {\n+        control.reset();\n+        control.replay();\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void orderedCallsSucces() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void unorderedCallsFailure() {\n+        boolean failed = false;\n+        try {\n+            mock.simpleMethodWithArgument(\"2\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail(\"unordered calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void tooManyCallsFailure() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        boolean failed = false;\n+        try {\n+            mock.simpleMethodWithArgument(\"2\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail(\"too many calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void tooFewCallsFailure() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        boolean failed = false;\n+        try {\n+            control.verify();\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertTrue(\"stack trace must be filled in\", Util.getStackTrace(\n+                    expected).indexOf(ReplayState.class.getName()) == -1);\n+        }\n+        if (!failed) {\n+            fail(\"too few calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void differentMethods() {\n+\n+        control.reset();\n+\n+        mock.booleanReturningMethod(0);\n+        control.setReturnValue(true);\n+        mock.simpleMethod();\n+        mock.booleanReturningMethod(1);\n+        control.setReturnValue(false, 2, 3);\n+        mock.simpleMethod();\n+        control.setVoidCallable(MockControl.ONE_OR_MORE);\n+\n+        control.replay();\n+        assertEquals(true, mock.booleanReturningMethod(0));\n+        mock.simpleMethod();\n+\n+        boolean failed = false;\n+        try {\n+            control.verify();\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    simpleMethod(): expected: 1, actual: 1\"\n+                            + \"\\n    booleanReturningMethod(1): expected: between 2 and 3, actual: 0\"\n+                            + \"\\n    simpleMethod(): expected: at least 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"too few calls accepted\");\n+        }\n+\n+        assertEquals(false, mock.booleanReturningMethod(1));\n+\n+        failed = false;\n+        try {\n+            mock.simpleMethod();\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethod():\"\n+                            + \"\\n    booleanReturningMethod(1): expected: between 2 and 3, actual: 1\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"wrong call accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void range() {\n+\n+        control.reset();\n+\n+        mock.booleanReturningMethod(0);\n+        control.setReturnValue(true);\n+        mock.simpleMethod();\n+        mock.booleanReturningMethod(1);\n+        control.setReturnValue(false, 2, 3);\n+        mock.simpleMethod();\n+        control.setVoidCallable(MockControl.ONE_OR_MORE);\n+        mock.booleanReturningMethod(1);\n+        control.setReturnValue(false);\n+\n+        control.replay();\n+\n+        mock.booleanReturningMethod(0);\n+        mock.simpleMethod();\n+\n+        mock.booleanReturningMethod(1);\n+        mock.booleanReturningMethod(1);\n+        mock.booleanReturningMethod(1);\n+\n+        boolean failed = false;\n+\n+        try {\n+            mock.booleanReturningMethod(1);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Unexpected method call booleanReturningMethod(1):\"\n+                            + \"\\n    booleanReturningMethod(1): expected: between 2 and 3, actual: 3 (+1)\"\n+                            + \"\\n    simpleMethod(): expected: at least 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"too many calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void defaultBehavior() {\n+        control.reset();\n+\n+        mock.booleanReturningMethod(1);\n+        control.setReturnValue(true);\n+        control.setReturnValue(false);\n+        control.setReturnValue(true);\n+        control.setDefaultReturnValue(true);\n+\n+        control.replay();\n+\n+        assertEquals(true, mock.booleanReturningMethod(2));\n+        assertEquals(true, mock.booleanReturningMethod(3));\n+        assertEquals(true, mock.booleanReturningMethod(1));\n+        assertEquals(false, mock.booleanReturningMethod(1));\n+        assertEquals(true, mock.booleanReturningMethod(3));\n+\n+        boolean failed = false;\n+        try {\n+            control.verify();\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    booleanReturningMethod(1): expected: 3, actual: 2\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"too few calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void unexpectedCallWithArray() {\n+        control.reset();\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+        mock.arrayMethod(new String[] { \"Test\", \"Test 2\" });\n+        control.replay();\n+        boolean failed = false;\n+        String[] strings = new String[] { \"Test\" };\n+        try {\n+            mock.arrayMethod(strings);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Unexpected method call arrayMethod(\"\n+                            + strings.toString()\n+                            + \"):\"\n+                            + \"\\n    arrayMethod([\\\"Test\\\", \\\"Test 2\\\"]): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"exception expected\");\n+        }\n+\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageTest {\n+\n+    MockControl<IMethods> control;\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void exactCallCountByLastCall() {\n+        mock.oneArg(false);\n+        control.setReturnValue(\"Test\");\n+        control.setReturnValue(\"Test2\");\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+\n+        boolean failed = false;\n+        try {\n+            mock.oneArg(false);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed)\n+            fail(\"expected AssertionError\");\n+    }\n+\n+    @Test\n+    public void openCallCountByLastCall() {\n+        mock.oneArg(false);\n+        control.setReturnValue(\"Test\");\n+        control.setReturnValue(\"Test2\", MockControl.ONE_OR_MORE);\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+    }\n+\n+    @Test\n+    public void exactCallCountByLastThrowable() {\n+        mock.oneArg(false);\n+        control.setReturnValue(\"Test\");\n+        control.setReturnValue(\"Test2\");\n+        control.setThrowable(new IndexOutOfBoundsException(), 1);\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+\n+        try {\n+            mock.oneArg(false);\n+        } catch (IndexOutOfBoundsException expected) {\n+        }\n+\n+        boolean failed = true;\n+        try {\n+            try {\n+                mock.oneArg(false);\n+            } catch (IndexOutOfBoundsException expected) {\n+            }\n+            failed = false;\n+        } catch (AssertionError expected) {\n+        }\n+        if (!failed)\n+            fail(\"expected AssertionError\");\n+    }\n+\n+    @Test\n+    public void openCallCountByLastThrowable() {\n+        mock.oneArg(false);\n+        control.setReturnValue(\"Test\");\n+        control.setReturnValue(\"Test2\");\n+        control.setThrowable(new IndexOutOfBoundsException(),\n+                MockControl.ONE_OR_MORE);\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+\n+        try {\n+            mock.oneArg(false);\n+        } catch (IndexOutOfBoundsException expected) {\n+        }\n+        try {\n+            mock.oneArg(false);\n+        } catch (IndexOutOfBoundsException expected) {\n+        }\n+    }\n+\n+    @Test\n+    public void moreThanOneArgument() {\n+        mock.threeArgumentMethod(1, \"2\", \"3\");\n+        control.setReturnValue(\"Test\", 2);\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+\n+        boolean failed = true;\n+        try {\n+            control.verify();\n+            failed = false;\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    threeArgumentMethod(1, \\\"2\\\", \\\"3\\\"): expected: 2, actual: 1\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"exception expected\");\n+        }\n+    }\n+\n+    @Test\n+    public void unexpectedCallWithArray() {\n+        control.reset();\n+        control.setDefaultMatcher(MockControl.ARRAY_MATCHER);\n+        control.replay();\n+        boolean failed = false;\n+        String[] strings = new String[] { \"Test\" };\n+        try {\n+            mock.arrayMethod(strings);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\"\\n  Unexpected method call arrayMethod(\"\n+                    + strings.toString() + \"):\", expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"exception expected\");\n+        }\n+\n+    }\n+\n+    @Test\n+    public void wrongArguments() {\n+        mock.simpleMethodWithArgument(\"3\");\n+        control.replay();\n+\n+        try {\n+            mock.simpleMethodWithArgument(\"5\");\n+            fail();\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethodWithArgument(\\\"5\\\"):\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"3\\\"): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void summarizeSameObjectArguments() {\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"3\");\n+        control.replay();\n+\n+        try {\n+            mock.simpleMethodWithArgument(\"5\");\n+            fail();\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethodWithArgument(\\\"5\\\"):\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"3\\\"): expected: 2, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void argumentsOrdered() {\n+        mock.simpleMethodWithArgument(\"4\");\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"2\");\n+        mock.simpleMethodWithArgument(\"0\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        control.replay();\n+\n+        try {\n+            mock.simpleMethodWithArgument(\"5\");\n+            fail();\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethodWithArgument(\\\"5\\\"):\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"4\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"3\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"2\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"0\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"1\\\"): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageThrowableTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageThrowableTest {\n+\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void noUpperLimit() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        control.setVoidCallable(MockControl.ONE_OR_MORE);\n+        mock.simpleMethodWithArgument(\"2\");\n+        control.replay();\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void throwRuntimeException() {\n+        testThrowUncheckedException(new RuntimeException());\n+    }\n+\n+    @Test\n+    public void throwSubclassOfRuntimeException() {\n+        testThrowUncheckedException(new RuntimeException() {\n+        });\n+    }\n+\n+    @Test\n+    public void throwError() {\n+        testThrowUncheckedException(new Error());\n+    }\n+\n+    @Test\n+    public void throwSubclassOfError() {\n+        testThrowUncheckedException(new Error() {\n+        });\n+    }\n+\n+    private void testThrowUncheckedException(Throwable throwable) {\n+        mock.throwsNothing(true);\n+        control.setReturnValue(\"true\");\n+        mock.throwsNothing(false);\n+        control.setThrowable(throwable);\n+\n+        control.replay();\n+\n+        try {\n+            mock.throwsNothing(false);\n+            fail(\"Trowable expected\");\n+        } catch (Throwable expected) {\n+            assertSame(throwable, expected);\n+        }\n+\n+        assertEquals(\"true\", mock.throwsNothing(true));\n+    }\n+\n+    @Test\n+    public void throwCheckedException() throws IOException {\n+        testThrowCheckedException(new IOException());\n+    }\n+\n+    @Test\n+    public void throwSubclassOfCheckedException() throws IOException {\n+        testThrowCheckedException(new IOException() {\n+        });\n+    }\n+\n+    private void testThrowCheckedException(IOException expected)\n+            throws IOException {\n+        try {\n+            mock.throwsIOException(0);\n+            control.setReturnValue(\"Value 0\");\n+            mock.throwsIOException(1);\n+            control.setThrowable(expected);\n+            mock.throwsIOException(2);\n+            control.setReturnValue(\"Value 2\");\n+        } catch (IOException e) {\n+            fail(\"Unexpected Exception\");\n+        }\n+\n+        control.replay();\n+\n+        assertEquals(\"Value 0\", mock.throwsIOException(0));\n+        assertEquals(\"Value 2\", mock.throwsIOException(2));\n+\n+        try {\n+            mock.throwsIOException(1);\n+            fail(\"IOException expected\");\n+        } catch (IOException expectedException) {\n+            assertSame(expectedException, expected);\n+        }\n+    }\n+\n+    @Test\n+    public void throwAfterReturnValue() {\n+        mock.throwsNothing(false);\n+        control.setReturnValue(\"\");\n+        RuntimeException expectedException = new RuntimeException();\n+        control.setThrowable(expectedException);\n+\n+        control.replay();\n+\n+        assertEquals(\"\", mock.throwsNothing(false));\n+\n+        try {\n+            mock.throwsNothing(false);\n+            fail(\"RuntimeException expected\");\n+        } catch (RuntimeException actualException) {\n+            assertSame(expectedException, actualException);\n+        }\n+\n+        control.verify();\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageUnorderedTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.MockControl;\n+import org.junit.Test;\n+\n+public class UsageUnorderedTest {\n+\n+    public interface Interface {\n+        void method(int number);\n+    }\n+\n+    @Test\n+    public void message() {\n+        MockControl<Interface> control = MockControl\n+                .createControl(Interface.class);\n+        Interface mock = control.getMock();\n+\n+        mock.method(0);\n+        control.setMatcher(MockControl.ALWAYS_MATCHER);\n+        control.setVoidCallable(1);\n+        mock.method(0);\n+        control.setVoidCallable(2);\n+        mock.method(1);\n+\n+        control.replay();\n+\n+        mock.method(6);\n+        mock.method(7);\n+        mock.method(1);\n+        mock.method(25);\n+\n+        try {\n+            mock.method(42);\n+            fail();\n+        } catch (AssertionError expected) {\n+            assertEquals(\"\\n  Unexpected method call method(42):\"\n+                    + \"\\n    method(<any>): expected: 3, actual: 3 (+1)\"\n+                    + \"\\n    method(<any>): expected: 1, actual: 1 (+1)\",\n+                    expected.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageVarargTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import org.easymock.MockControl;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageVarargTest {\n+\n+    MockControl<IVarArgs> control;\n+\n+    IVarArgs mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createStrictControl(IVarArgs.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void varargObjectAccepted() {\n+        mock.withVarargsString(1, \"1\");\n+        mock.withVarargsString(2, \"1\", \"2\");\n+        mock.withVarargsString(2, \"1\", \"2\");\n+        mock.withVarargsObject(3, \"1\");\n+        mock.withVarargsObject(4, \"1\", \"2\");\n+\n+        control.replay();\n+        mock.withVarargsString(1, \"1\");\n+        mock.withVarargsString(2, \"1\", \"2\");\n+        mock.withVarargsString(2, \"1\", \"2\");\n+        mock.withVarargsObject(3, \"1\");\n+        mock.withVarargsObject(4, \"1\", \"2\");\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargBooleanAccepted() {\n+        mock.withVarargsBoolean(1, true);\n+        mock.withVarargsBoolean(2, true, false);\n+\n+        control.replay();\n+        mock.withVarargsBoolean(1, true);\n+        mock.withVarargsBoolean(2, true, false);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargByteAccepted() {\n+        mock.withVarargsByte(1, (byte) 1);\n+        mock.withVarargsByte(2, (byte) 1, (byte) 2);\n+\n+        control.replay();\n+        mock.withVarargsByte(1, (byte) 1);\n+        mock.withVarargsByte(2, (byte) 1, (byte) 2);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargCharAccepted() {\n+        mock.withVarargsChar(1, 'a');\n+        mock.withVarargsChar(1, 'a', 'b');\n+\n+        control.replay();\n+        mock.withVarargsChar(1, 'a');\n+        mock.withVarargsChar(1, 'a', 'b');\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargDoubleAccepted() {\n+        mock.withVarargsDouble(1, 1.0d);\n+        mock.withVarargsDouble(1, 1.0d, 2.0d);\n+\n+        control.replay();\n+        mock.withVarargsDouble(1, 1.0d);\n+        mock.withVarargsDouble(1, 1.0d, 2.0d);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargFloatAccepted() {\n+        mock.withVarargsFloat(1, 1.0f);\n+        mock.withVarargsFloat(1, 1.0f, 2.0f);\n+\n+        control.replay();\n+        mock.withVarargsFloat(1, 1.0f);\n+        mock.withVarargsFloat(1, 1.0f, 2.0f);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargIntAccepted() {\n+        mock.withVarargsInt(1, 1);\n+        mock.withVarargsInt(1, 1, 2);\n+\n+        control.replay();\n+        mock.withVarargsInt(1, 1);\n+        mock.withVarargsInt(1, 1, 2);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargLongAccepted() {\n+        mock.withVarargsLong(1, (long) 1);\n+        mock.withVarargsLong(1, 1, 2);\n+\n+        control.replay();\n+        mock.withVarargsLong(1, (long) 1);\n+        mock.withVarargsLong(1, 1, 2);\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void varargShortAccepted() {\n+        mock.withVarargsShort(1, (short) 1);\n+        mock.withVarargsShort(1, (short) 1, (short) 2);\n+\n+        control.replay();\n+        mock.withVarargsShort(1, (short) 1);\n+        mock.withVarargsShort(1, (short) 1, (short) 2);\n+        control.verify();\n+    }\n+    \n+    @Test\n+    public void varargAcceptedIfArrayIsGiven() {\n+        IVarArgs object = (IVarArgs) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[] { IVarArgs.class }, new InvocationHandler() {\n+        \n+            public Object invoke(Object proxy, Method method, Object[] args)\n+                    throws Throwable {\n+                return null;\n+            }\n+        });\n+        object.withVarargsObject(1);\n+        object.withVarargsObject(1, (Object) null);\n+        object.withVarargsObject(1, (Object[]) null);\n+        object.withVarargsObject(1, (Object[]) new Object[0] );\n+        object.withVarargsObject(1, false);\n+        object.withVarargsObject(1, new boolean[] {true, false});\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/UsageVerifyTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+\n+import org.easymock.MockControl;\n+import org.easymock.internal.ReplayState;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageVerifyTest {\n+    private MockControl<IMethods> control;\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        control = MockControl.createControl(IMethods.class);\n+        mock = control.getMock();\n+    }\n+\n+    @Test\n+    public void twoReturns() {\n+        mock.throwsNothing(true);\n+        control.setReturnValue(\"Test\");\n+        control.setReturnValue(\"Test2\");\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.throwsNothing(true));\n+\n+        boolean failed = true;\n+\n+        try {\n+            control.verify();\n+            failed = false;\n+        } catch (AssertionError expected) {\n+            assertEquals(\"\\n  Expectation failure on verify:\"\n+                    + \"\\n    throwsNothing(true): expected: 2, actual: 1\",\n+                    expected.getMessage());\n+            assertTrue(\"stack trace must be filled in\", Util.getStackTrace(\n+                    expected).indexOf(ReplayState.class.getName()) == -1);\n+        }\n+\n+        if (!failed)\n+            fail(\"AssertionError expected\");\n+\n+        assertEquals(\"Test2\", mock.throwsNothing(true));\n+\n+        control.verify();\n+\n+        try {\n+            mock.throwsNothing(true);\n+            fail(\"AssertionError expected\");\n+        } catch (AssertionError expected) {\n+            assertEquals(\"\\n  Unexpected method call throwsNothing(true):\"\n+                    + \"\\n    throwsNothing(true): expected: 2, actual: 2 (+1)\",\n+                    expected.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void atLeastTwoReturns() {\n+        mock.throwsNothing(true);\n+        control.setReturnValue(\"Test\");\n+        control.setReturnValue(\"Test2\", MockControl.ONE_OR_MORE);\n+\n+        control.replay();\n+\n+        assertEquals(\"Test\", mock.throwsNothing(true));\n+\n+        try {\n+            control.verify();\n+            fail(\"AssertionError expected\");\n+        } catch (AssertionError expected) {\n+\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    throwsNothing(true): expected: at least 2, actual: 1\",\n+                    expected.getMessage());\n+        }\n+\n+        assertEquals(\"Test2\", mock.throwsNothing(true));\n+        assertEquals(\"Test2\", mock.throwsNothing(true));\n+\n+        control.verify();\n+    }\n+\n+    @Test\n+    public void twoThrows() throws IOException {\n+        mock.throwsIOException(0);\n+        control.setThrowable(new IOException());\n+        control.setThrowable(new IOException());\n+        mock.throwsIOException(1);\n+        control.setThrowable(new IOException());\n+\n+        control.replay();\n+\n+        try {\n+            mock.throwsIOException(0);\n+            fail(\"IOException expected\");\n+        } catch (IOException expected) {\n+        }\n+\n+        try {\n+            control.verify();\n+            fail(\"AssertionError expected\");\n+        } catch (AssertionError expected) {\n+            assertEquals(\"\\n  Expectation failure on verify:\"\n+                    + \"\\n    throwsIOException(0): expected: 2, actual: 1\"\n+                    + \"\\n    throwsIOException(1): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+        try {\n+            mock.throwsIOException(0);\n+            fail(\"IOException expected\");\n+        } catch (IOException expected) {\n+        }\n+\n+        try {\n+            control.verify();\n+            fail(\"AssertionError expected\");\n+        } catch (AssertionError expected) {\n+            assertEquals(\"\\n  Expectation failure on verify:\"\n+                    + \"\\n    throwsIOException(1): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+        try {\n+            mock.throwsIOException(1);\n+            fail(\"IOException expected\");\n+        } catch (IOException expected) {\n+        }\n+\n+        control.verify();\n+\n+        try {\n+            mock.throwsIOException(0);\n+            fail(\"AssertionError expected\");\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call throwsIOException(0):\"\n+                            + \"\\n    throwsIOException(0): expected: 2, actual: 2 (+1)\",\n+                    expected.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests/Util.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+public class Util {\n+    public static String getStackTrace(Throwable throwable) {\n+        StringWriter stackTrace = new StringWriter();\n+        throwable.printStackTrace(new PrintWriter(stackTrace));\n+        return stackTrace.getBuffer().toString();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/AnswerTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.IAnswer;\n+import org.easymock.tests.IMethods;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class AnswerTest {\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        mock = createMock(IMethods.class);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void answer() {\n+        IAnswer firstAnswer = new IAnswer() {\n+            public Object answer() {\n+                assertEquals(new Object[] { 1, \"2\", \"3\" },\n+                        getCurrentArguments());\n+                return \"Call answered\";\n+            }\n+        };\n+\n+        IAnswer secondAnswer = new IAnswer() {\n+            public Object answer() {\n+                assertEquals(new Object[] { 1, \"2\", \"3\" },\n+                        getCurrentArguments());\n+                throw new IllegalStateException(\"Call answered\");\n+            }\n+        };\n+\n+        expect(mock.threeArgumentMethod(1, \"2\", \"3\")).andAnswer(firstAnswer)\n+                .andReturn(\"Second call\").andAnswer(secondAnswer).andReturn(\n+                        \"Fourth call\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"Call answered\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+        assertEquals(\"Second call\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+        try {\n+            mock.threeArgumentMethod(1, \"2\", \"3\");\n+            fail();\n+        } catch (IllegalStateException expected) {\n+            assertEquals(\"Call answered\", expected.getMessage());\n+        }\n+        assertEquals(\"Fourth call\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+\n+        verify(mock);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void stubAnswer() {\n+        IAnswer firstAnswer = new IAnswer() {\n+            public Object answer() {\n+                assertEquals(new Object[] { 1, \"2\", \"3\" },\n+                        getCurrentArguments());\n+                return \"Call answered\";\n+            }\n+        };\n+\n+        IAnswer secondAnswer = new IAnswer() {\n+            public Object answer() {\n+                assertEquals(new Object[] { 1, \"2\", \"4\" },\n+                        getCurrentArguments());\n+                return \"Call answered\";\n+            }\n+        };\n+\n+        expect(mock.threeArgumentMethod(1, \"2\", \"3\")).andReturn(42)\n+                .andStubAnswer(firstAnswer);\n+        expect(mock.threeArgumentMethod(1, \"2\", \"4\")).andStubAnswer(\n+                secondAnswer);\n+\n+        replay(mock);\n+\n+        assertEquals(42, mock.threeArgumentMethod(1, \"2\", \"3\"));\n+        assertEquals(\"Call answered\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+        assertEquals(\"Call answered\", mock.threeArgumentMethod(1, \"2\", \"4\"));\n+        assertEquals(\"Call answered\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+        assertEquals(\"Call answered\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void nullAnswerNotAllowed() {\n+        try {\n+            expect(mock.threeArgumentMethod(1, \"2\", \"3\")).andAnswer(null);\n+            fail();\n+        } catch (NullPointerException expected) {\n+            assertEquals(\"answer object must not be null\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void nullStubAnswerNotAllowed() {\n+        try {\n+            expect(mock.threeArgumentMethod(1, \"2\", \"3\")).andStubAnswer(null);\n+            fail();\n+        } catch (NullPointerException expected) {\n+            assertEquals(\"answer object must not be null\", expected\n+                    .getMessage());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/CallbackAndArgumentsTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.IAnswer;\n+import org.easymock.tests.IMethods;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class CallbackAndArgumentsTest {\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        mock = createStrictMock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void callbackGetsArguments() {\n+\n+        final StringBuffer buffer = new StringBuffer();\n+\n+        mock.simpleMethodWithArgument((String) notNull());\n+        expectLastCall().andAnswer(new IAnswer<Object>() {\n+            public Object answer() {\n+                buffer.append((String) getCurrentArguments()[0]);\n+                return null;\n+            }\n+        }).times(2);\n+\n+        replay(mock);\n+\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        verify(mock);\n+\n+        assertEquals(\"12\", buffer.toString());\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void currentArgumentsFailsOutsideCallbacks() {\n+        getCurrentArguments();\n+    }\n+\n+    @Test\n+    public void callbackGetsArgumentsEvenIfAMockCallsAnother() {\n+\n+        final StringBuffer buffer = new StringBuffer();\n+\n+        final IMethods mock2 = createStrictMock(IMethods.class);\n+        mock2.simpleMethod();\n+        expectLastCall().andAnswer(new IAnswer<Object>() {\n+            public Object answer() {\n+                // empty, only needed to force deletion of arguments\n+                return null;\n+            }\n+        }).times(2);\n+\n+        mock.simpleMethodWithArgument((String) notNull());\n+        expectLastCall().andAnswer(new IAnswer<Object>() {\n+            public Object answer() {\n+                mock2.simpleMethod();\n+                buffer.append((String) getCurrentArguments()[0]);\n+                return null;\n+            }\n+        }).times(2);\n+\n+        replay(mock);\n+        replay(mock2);\n+\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        verify(mock);\n+        verify(mock2);\n+\n+        assertEquals(\"12\", buffer.toString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/CallbackTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.IAnswer;\n+import org.easymock.tests.IMethods;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class CallbackTest {\n+\n+    private IMethods mock;\n+\n+    private static class Callback<T> implements IAnswer<T> {\n+        private int callCount;\n+\n+        private T result;\n+\n+        public Callback(T result) {\n+            this.result = result;\n+        }\n+\n+        public void run() {\n+        }\n+\n+        public int getCallCount() {\n+            return callCount;\n+        }\n+\n+        public T answer() throws Throwable {\n+            callCount++;\n+            return result;\n+        }\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        mock = createStrictMock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void callback() {\n+        Callback<String> c1 = new Callback<String>(\"1\");\n+        Callback<Object> c2 = new Callback<Object>(null);\n+        Callback<Object> c3 = new Callback<Object>(null);\n+\n+        expect(mock.oneArg(\"2\")).andAnswer(c1).times(2);\n+        mock.simpleMethodWithArgument(\"One\");\n+        expectLastCall().andAnswer(c2);\n+        mock.simpleMethodWithArgument(\"Two\");\n+        expectLastCall().andAnswer(c3).times(2);\n+\n+        replay(mock);\n+\n+        mock.oneArg(\"2\");\n+        mock.oneArg(\"2\");\n+        try {\n+            mock.oneArg(\"2\");\n+        } catch (AssertionError ignored) {\n+        }\n+        try {\n+            mock.simpleMethodWithArgument(\"Two\");\n+        } catch (AssertionError ignored) {\n+        }\n+        mock.simpleMethodWithArgument(\"One\");\n+        try {\n+            mock.simpleMethodWithArgument(\"One\");\n+        } catch (AssertionError ignored) {\n+        }\n+        mock.simpleMethodWithArgument(\"Two\");\n+        mock.simpleMethodWithArgument(\"Two\");\n+        try {\n+            mock.simpleMethodWithArgument(\"Two\");\n+        } catch (AssertionError ignored) {\n+        }\n+        verify(mock);\n+\n+        assertEquals(2, c1.getCallCount());\n+        assertEquals(1, c2.getCallCount());\n+        assertEquals(2, c3.getCallCount());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/CompareToTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.junit.Assert.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.easymock.internal.matchers.*;\n+import org.junit.Test;\n+\n+public class CompareToTest {\n+\n+    @Test\n+    public void testNotComparable() {\n+        CompareTo<Long> cmpTo = new CompareTo<Long>(5L) {\n+\n+            @Override\n+            protected String getName() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected boolean matchResult(int result) {\n+                fail(\"Shouldn't be called since the passed argument is not Comparable\");\n+                return true;\n+            }\n+            \n+        };\n+        \n+        assertFalse(cmpTo.matches(new Object()));\n+    }\n+    @Test\n+    public void testLessThan() {\n+        test(new LessThan<String>(\"b\"), true, false, false, \"lt\");\n+    }\n+\n+    @Test\n+    public void testGreateThan() {\n+        test(new GreaterThan<String>(\"b\"), false, true, false, \"gt\");\n+    }\n+\n+    @Test\n+    public void testLessOrEqual() {\n+        test(new LessOrEqual<String>(\"b\"), true, false, true, \"leq\");\n+    }\n+\n+    @Test\n+    public void testGreateOrEqual() {\n+        test(new GreaterOrEqual<String>(\"b\"), false, true, true, \"geq\");\n+    }\n+\n+    @Test\n+    public void testCompareEqual() {\n+        test(new CompareEqual<String>(\"b\"), false, false, true, \"cmpEq\");\n+\n+        // Make sure it works when equals provide a different result than\n+        // compare\n+        CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(\n+                new BigDecimal(\"5.00\"));\n+        assertTrue(cmpEq.matches(new BigDecimal(\"5\")));\n+    }\n+\n+    private void test(CompareTo<String> cmpTo, boolean lower, boolean higher,\n+            boolean equals, String name) {\n+\n+        assertEquals(lower, cmpTo.matches(\"a\"));\n+        assertEquals(equals, cmpTo.matches(\"b\"));\n+        assertEquals(higher, cmpTo.matches(\"c\"));\n+\n+        StringBuffer sb = new StringBuffer();\n+        cmpTo.appendTo(sb);\n+        assertEquals(name + \"(b)\", sb.toString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/ConstraintsToStringTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.easymock.IArgumentMatcher;\n+import org.easymock.internal.matchers.*;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ConstraintsToStringTest {\n+    private StringBuffer buffer;\n+\n+    @Before\n+    public void setup() {\n+        buffer = new StringBuffer();\n+    }\n+\n+    @Test\n+    public void sameToStringWithString() {\n+        new Same(\"X\").appendTo(buffer);\n+        assertEquals(\"same(\\\"X\\\")\", buffer.toString());\n+\n+    }\n+\n+    @Test\n+    public void nullToString() {\n+        Null.NULL.appendTo(buffer);\n+        assertEquals(\"isNull()\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void notNullToString() {\n+        NotNull.NOT_NULL.appendTo(buffer);\n+        assertEquals(\"notNull()\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void anyToString() {\n+        Any.ANY.appendTo(buffer);\n+        assertEquals(\"<any>\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void sameToStringWithChar() {\n+        new Same('x').appendTo(buffer);\n+        assertEquals(\"same('x')\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void sameToStringWithObject() {\n+        Object o = new Object() {\n+            @Override\n+            public String toString() {\n+                return \"X\";\n+            }\n+        };\n+        new Same(o).appendTo(buffer);\n+        assertEquals(\"same(X)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void equalsToStringWithString() {\n+        new Equals(\"X\").appendTo(buffer);\n+        assertEquals(\"\\\"X\\\"\", buffer.toString());\n+\n+    }\n+\n+    @Test\n+    public void equalsToStringWithChar() {\n+        new Equals('x').appendTo(buffer);\n+        assertEquals(\"'x'\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void equalsToStringWithObject() {\n+        Object o = new Object() {\n+            @Override\n+            public String toString() {\n+                return \"X\";\n+            }\n+        };\n+        new Equals(o).appendTo(buffer);\n+        assertEquals(\"X\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void orToString() {\n+        List<IArgumentMatcher> matchers = new ArrayList<IArgumentMatcher>();\n+        matchers.add(new Equals(1));\n+        matchers.add(new Equals(2));\n+        new Or(matchers).appendTo(buffer);\n+        assertEquals(\"or(1, 2)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void notToString() {\n+        new Not(new Equals(1)).appendTo(buffer);\n+        assertEquals(\"not(1)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void andToString() {\n+        List<IArgumentMatcher> matchers = new ArrayList<IArgumentMatcher>();\n+        matchers.add(new Equals(1));\n+        matchers.add(new Equals(2));\n+        new And(matchers).appendTo(buffer);\n+        assertEquals(\"and(1, 2)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void startsWithToString() {\n+        new StartsWith(\"AB\").appendTo(buffer);\n+        assertEquals(\"startsWith(\\\"AB\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void endsWithToString() {\n+        new EndsWith(\"AB\").appendTo(buffer);\n+        assertEquals(\"endsWith(\\\"AB\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void containsToString() {\n+        new Contains(\"AB\").appendTo(buffer);\n+        assertEquals(\"contains(\\\"AB\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void findToString() {\n+        new Find(\"\\\\s+\").appendTo(buffer);\n+        assertEquals(\"find(\\\"\\\\\\\\s+\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void matchesToString() {\n+        new Matches(\"\\\\s+\").appendTo(buffer);\n+        assertEquals(\"matches(\\\"\\\\\\\\s+\\\")\", buffer.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/NameTest.java\n+package org.easymock.tests2;\n+\n+import org.easymock.IMocksControl;\n+import org.easymock.tests.IMethods;\n+import org.junit.Test;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+public class NameTest {\n+    @Test\n+    public void nameForMock() {\n+        IMethods mock = createMock(\"mock\", IMethods.class);\n+        mock.simpleMethod();\n+        replay(mock);\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \"\\n  Expectation failure on verify:\\n    mock.simpleMethod(): expected: 1, actual: 0\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    @Test\n+    public void nameForStrictMock() {\n+        IMethods mock = createStrictMock(\"mock\", IMethods.class);\n+        mock.simpleMethod();\n+        replay(mock);\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \"\\n  Expectation failure on verify:\\n    mock.simpleMethod(): expected: 1, actual: 0\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    @Test\n+    public void nameForNiceMock() {\n+        IMethods mock = createNiceMock(\"mock\", IMethods.class);\n+        mock.simpleMethod();\n+        replay(mock);\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \"\\n  Expectation failure on verify:\\n    mock.simpleMethod(): expected: 1, actual: 0\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    @Test\n+    public void nameForMocksControl() {\n+        IMocksControl control = createControl();\n+        IMethods mock = control.createMock(\"mock\", IMethods.class);\n+        mock.simpleMethod();\n+        replay(mock);\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \"\\n  Expectation failure on verify:\\n    mock.simpleMethod(): expected: 1, actual: 0\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldThrowIllegalArgumentExceptionIfNameIsNoValidJavaIdentifier() {\n+        try {\n+            createMock(\"no-valid-java-identifier\", IMethods.class);\n+            throw new AssertionError();\n+        } catch (IllegalArgumentException expected) {\n+            assertEquals(\"'no-valid-java-identifier' is not a valid Java identifier.\", expected.getMessage());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/NiceMockReturnsEmptyCollectionsTest.java\n+package org.easymock.tests2;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public class NiceMockReturnsEmptyCollectionsTest {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testBeNiceConvertsDefaultMock() {\n+        CollectionServer mock = EasyMock.createNiceMock(CollectionServer.class);\n+        \n+        EasyMock.replay(mock);\n+        \n+        assertTrue(mock.list().isEmpty());\n+        assertTrue(mock.linkedList().isEmpty());\n+        assertTrue(mock.map().isEmpty());\n+        assertTrue(mock.hashSet().isEmpty());\n+\n+        EasyMock.verify(mock);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private interface CollectionServer {\n+        List list();\n+        LinkedList linkedList();\n+        Map map();\n+        java.util.HashSet hashSet();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/NiceMockTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.tests.IMethods;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class NiceMockTest {\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = createNiceMock(IMethods.class);\n+        replay(mock);\n+    }\n+\n+    @Test\n+    public void defaultReturnValueBoolean() {\n+        assertEquals(false, mock.booleanReturningMethod(12));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void defaultReturnValueFloat() {\n+        assertEquals(0.0f, mock.floatReturningMethod(12), 0.0f);\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void defaultReturnValueDouble() {\n+        assertEquals(0.0d, mock.doubleReturningMethod(12), 0.0d);\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void defaultReturnValueObject() {\n+        assertEquals(null, mock.objectReturningMethod(12));\n+        verify(mock);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/StubTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.tests.IMethods;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class StubTest {\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = createStrictMock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void stub() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        expectLastCall().anyTimes();\n+        mock.simpleMethodWithArgument(\"2\");\n+        expectLastCall().anyTimes();\n+        mock.simpleMethodWithArgument(\"3\");\n+        expectLastCall().asStub();\n+\n+        replay(mock);\n+\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"3\");\n+\n+        verify(mock);\n+\n+    }\n+\n+    @Test\n+    public void stubWithReturnValue() {\n+        expect(mock.oneArg(\"1\")).andReturn(\"A\").andStubReturn(\"B\");\n+        expect(mock.oneArg(\"2\")).andThrow(new IllegalArgumentException())\n+                .andStubThrow(new IllegalStateException());\n+\n+        replay(mock);\n+\n+        assertEquals(\"A\", mock.oneArg(\"1\"));\n+        assertEquals(\"B\", mock.oneArg(\"1\"));\n+        assertEquals(\"B\", mock.oneArg(\"1\"));\n+        try {\n+            mock.oneArg(\"2\");\n+        } catch (IllegalArgumentException ignored) {\n+        }\n+        assertEquals(\"B\", mock.oneArg(\"1\"));\n+        try {\n+            mock.oneArg(\"2\");\n+        } catch (IllegalStateException ignored) {\n+        }\n+        assertEquals(\"B\", mock.oneArg(\"1\"));\n+        try {\n+            mock.oneArg(\"2\");\n+        } catch (IllegalStateException ignored) {\n+        }\n+        verify(mock);\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/UsageConstraintsTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.junit.Assert.*;\n+import static org.easymock.EasyMock.*;\n+\n+import java.math.*;\n+import java.util.*;\n+\n+import org.easymock.*;\n+import org.easymock.internal.matchers.*;\n+import org.easymock.tests.*;\n+import org.junit.*;\n+\n+public class UsageConstraintsTest {\n+    private IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        mock = createMock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void equalsMissing() {\n+        mock.simpleMethodWithArgument(not(eq(\"asd\")));\n+        try {\n+            mock.simpleMethodWithArgument(not(\"jkl\"));\n+            fail();\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"no matchers found.\", e.getMessage());\n+        }\n+        try {\n+            mock.simpleMethodWithArgument(or(eq(\"jkl\"), \"asd\"));\n+            fail();\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"2 matchers expected, 1 recorded.\", e.getMessage());\n+        }\n+        try {\n+            mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n+            fail();\n+        } catch (IllegalStateException e) {\n+            assertEquals(\"3 matchers expected, 1 recorded.\", e.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void differentConstraintsOnSameCall() {\n+        mock.simpleMethodWithArgument((String) isNull());\n+        mock.simpleMethodWithArgument((String) notNull());\n+        replay(mock);\n+        mock.simpleMethodWithArgument(null);\n+        mock.simpleMethodWithArgument(\"2\");\n+    }\n+\n+    @Test\n+    public void equals() {\n+        assertEquals(new Equals(null), new Equals(null));\n+        assertEquals(new Equals(new Integer(2)), new Equals(new Integer(2)));\n+        assertFalse(new Equals(null).equals(null));\n+        assertFalse(new Equals(null).equals(\"Test\"));\n+        try {\n+            new Equals(null).hashCode();\n+            fail();\n+        } catch (UnsupportedOperationException expected) {\n+        }\n+    }\n+\n+    @Test\n+    public void constraints() {\n+        expect(\n+                mock.threeArgumentMethod(and(geq(7), leq(10)),\n+                        isA(String.class), contains(\"123\"))).andReturn(\"456\")\n+                .atLeastOnce();\n+        replay(mock);\n+        boolean failed = false;\n+        try {\n+            mock.threeArgumentMethod(11, \"\", \"01234\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail();\n+        }\n+        failed = false;\n+        try {\n+            mock.threeArgumentMethod(8, new Object(), \"01234\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail();\n+        }\n+        failed = false;\n+        try {\n+            mock.threeArgumentMethod(8, \"\", \"no match\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail();\n+        }\n+        assertEquals(\"456\", mock.threeArgumentMethod(8, \"\", \"01234\"));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void andOverloaded() {\n+        expect(mock.oneArg(and(eq(false), eq(false)))).andReturn(\"0\");\n+        expect(mock.oneArg(and(eq((byte) 1), eq((byte) 1)))).andReturn(\"1\");\n+        expect(mock.oneArg(and(eq('a'), eq('a')))).andReturn(\"2\");\n+        expect(mock.oneArg(and(eq((double) 1), eq((double) 1)))).andReturn(\"3\");\n+        expect(mock.oneArg(and(eq((float) 1), eq((float) 1)))).andReturn(\"4\");\n+        expect(mock.oneArg(and(eq((int) 1), eq((int) 1)))).andReturn(\"5\");\n+        expect(mock.oneArg(and(eq((long) 1), eq((long) 1)))).andReturn(\"6\");\n+        expect(mock.oneArg(and(eq((short) 1), eq((short) 1)))).andReturn(\"7\");\n+        expect(mock.oneArg(and(contains(\"a\"), contains(\"d\")))).andReturn(\"8\");\n+        expect(mock.oneArg(and(isA(Class.class), eq(Object.class)))).andReturn(\n+                \"9\");\n+        replay(mock);\n+        assertEquals(\"9\", mock.oneArg(Object.class));\n+        assertEquals(\"0\", mock.oneArg(false));\n+        assertEquals(\"1\", mock.oneArg((byte) 1));\n+        assertEquals(\"2\", mock.oneArg('a'));\n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 1));\n+        assertEquals(\"8\", mock.oneArg(\"abcde\"));\n+        assertEquals(\"4\", mock.oneArg((float) 1));\n+        assertEquals(\"5\", mock.oneArg((int) 1));\n+        assertEquals(\"6\", mock.oneArg((long) 1));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void orOverloaded() {\n+        expect(mock.oneArg(or(eq(false), eq(true)))).andReturn(\"0\");\n+        expect(mock.oneArg(or(eq((byte) 1), eq((byte) 2)))).andReturn(\"1\");\n+        expect(mock.oneArg(or(eq((char) 1), eq((char) 2)))).andReturn(\"2\");\n+        expect(mock.oneArg(or(eq((double) 1), eq((double) 2)))).andReturn(\"3\");\n+        expect(mock.oneArg(or(eq((float) 1), eq((float) 2)))).andReturn(\"4\");\n+        expect(mock.oneArg(or(eq((int) 1), eq((int) 2)))).andReturn(\"5\");\n+        expect(mock.oneArg(or(eq((long) 1), eq((long) 2)))).andReturn(\"6\");\n+        expect(mock.oneArg(or(eq((short) 1), eq((short) 2)))).andReturn(\"7\");\n+        expect(mock.oneArg(or(eq(\"asd\"), eq(\"jkl\")))).andReturn(\"8\");\n+        expect(mock.oneArg(or(eq(this.getClass()), eq(Object.class))))\n+                .andReturn(\"9\");\n+        replay(mock);\n+        assertEquals(\"9\", mock.oneArg(Object.class));\n+        assertEquals(\"0\", mock.oneArg(true));\n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(\"2\", mock.oneArg((char) 1));\n+        assertEquals(\"3\", mock.oneArg((double) 2));\n+        assertEquals(\"7\", mock.oneArg((short) 1));\n+        assertEquals(\"8\", mock.oneArg(\"jkl\"));\n+        assertEquals(\"4\", mock.oneArg((float) 1));\n+        assertEquals(\"5\", mock.oneArg((int) 2));\n+        assertEquals(\"6\", mock.oneArg((long) 1));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void notOverloaded() {\n+        expect(mock.oneArg(not(eq(false)))).andReturn(\"0\");\n+        expect(mock.oneArg(not(eq((byte) 1)))).andReturn(\"1\");\n+        expect(mock.oneArg(not(eq('a')))).andReturn(\"2\");\n+        expect(mock.oneArg(not(eq((double) 1)))).andReturn(\"3\");\n+        expect(mock.oneArg(not(eq((float) 1)))).andReturn(\"4\");\n+        expect(mock.oneArg(not(eq((int) 1)))).andReturn(\"5\");\n+        expect(mock.oneArg(not(eq((long) 1)))).andReturn(\"6\");\n+        expect(mock.oneArg(not(eq((short) 1)))).andReturn(\"7\");\n+        expect(mock.oneArg(not(contains(\"a\")))).andReturn(\"8\");\n+        expect(mock.oneArg(not(isA(Class.class)))).andReturn(\"9\");\n+        replay(mock);\n+        assertEquals(\"9\", mock.oneArg(new Object()));\n+        assertEquals(\"0\", mock.oneArg(true));\n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(\"2\", mock.oneArg('b'));\n+        assertEquals(\"3\", mock.oneArg((double) 2));\n+        assertEquals(\"7\", mock.oneArg((short) 2));\n+        assertEquals(\"8\", mock.oneArg(\"bcde\"));\n+        assertEquals(\"4\", mock.oneArg((float) 2));\n+        assertEquals(\"5\", mock.oneArg((int) 2));\n+        assertEquals(\"6\", mock.oneArg((long) 2));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void lessOrEqualOverloaded() {\n+        expect(mock.oneArg(leq((byte) 1))).andReturn(\"1\");\n+        expect(mock.oneArg(leq((double) 1))).andReturn(\"3\");\n+        expect(mock.oneArg(leq((float) 1))).andReturn(\"4\");\n+        expect(mock.oneArg(leq((int) 1))).andReturn(\"5\");\n+        expect(mock.oneArg(leq((long) 1))).andReturn(\"6\");\n+        expect(mock.oneArg(leq((short) 1))).andReturn(\"7\");\n+        expect(mock.oneArg(leq(new BigDecimal(\"1\")))).andReturn(\"8\");\n+        replay(mock);\n+        assertEquals(\"1\", mock.oneArg((byte) 1));\n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 0));\n+        assertEquals(\"4\", mock.oneArg((float) -5));\n+        assertEquals(\"5\", mock.oneArg((int) -2));\n+        assertEquals(\"6\", mock.oneArg((long) -3));\n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"0.5\")));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void lessThanOverloaded() {\n+        expect(mock.oneArg(lt((byte) 1))).andReturn(\"1\");\n+        expect(mock.oneArg(lt((double) 1))).andReturn(\"3\");\n+        expect(mock.oneArg(lt((float) 1))).andReturn(\"4\");\n+        expect(mock.oneArg(lt((int) 1))).andReturn(\"5\");\n+        expect(mock.oneArg(lt((long) 1))).andReturn(\"6\");\n+        expect(mock.oneArg(lt((short) 1))).andReturn(\"7\");\n+        expect(mock.oneArg(lt(new BigDecimal(\"1\")))).andReturn(\"8\");\n+        replay(mock);\n+        assertEquals(\"1\", mock.oneArg((byte) 0));\n+        assertEquals(\"3\", mock.oneArg((double) 0));\n+        assertEquals(\"7\", mock.oneArg((short) 0));\n+        assertEquals(\"4\", mock.oneArg((float) -4));\n+        assertEquals(\"5\", mock.oneArg((int) -34));\n+        assertEquals(\"6\", mock.oneArg((long) -6));\n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"0.5\")));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void greaterOrEqualOverloaded() {\n+        expect(mock.oneArg(geq((byte) 1))).andReturn(\"1\");\n+        expect(mock.oneArg(geq((double) 1))).andReturn(\"3\");\n+        expect(mock.oneArg(geq((float) 1))).andReturn(\"4\");\n+        expect(mock.oneArg(geq((int) 1))).andReturn(\"5\");\n+        expect(mock.oneArg(geq((long) 1))).andReturn(\"6\");\n+        expect(mock.oneArg(geq((short) 1))).andReturn(\"7\");\n+        expect(mock.oneArg(geq(new BigDecimal(\"1\")))).andReturn(\"8\");\n+        replay(mock);\n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 2));\n+        assertEquals(\"4\", mock.oneArg((float) 3));\n+        assertEquals(\"5\", mock.oneArg((int) 4));\n+        assertEquals(\"6\", mock.oneArg((long) 5));\n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"1.5\")));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void greaterThanOverloaded() {\n+        expect(mock.oneArg(gt((byte) 1))).andReturn(\"1\");\n+        expect(mock.oneArg(gt((double) 1))).andReturn(\"3\");\n+        expect(mock.oneArg(gt((float) 1))).andReturn(\"4\");\n+        expect(mock.oneArg(gt((int) 1))).andReturn(\"5\");\n+        expect(mock.oneArg(gt((long) 1))).andReturn(\"6\");\n+        expect(mock.oneArg(gt((short) 1))).andReturn(\"7\");\n+        expect(mock.oneArg(gt(new BigDecimal(\"1\")))).andReturn(\"8\");\n+        replay(mock);\n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(\"3\", mock.oneArg((double) 2));\n+        assertEquals(\"7\", mock.oneArg((short) 2));\n+        assertEquals(\"4\", mock.oneArg((float) 3));\n+        assertEquals(\"5\", mock.oneArg((int) 2));\n+        assertEquals(\"6\", mock.oneArg((long) 5));\n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"1.5\")));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void cmpTo() {\n+        expect(mock.oneArg(cmpEq(new BigDecimal(\"1.5\")))).andReturn(\"0\");\n+        replay(mock);\n+        assertEquals(\"0\", mock.oneArg(new BigDecimal(\"1.50\")));\n+        verify(mock);\n+    }\n+\n+    public static class A {\n+        private int value;\n+\n+        public A(int value) {\n+            this.value = value;\n+        }\n+\n+        public int getValue() {\n+            return value;\n+        }\n+    }\n+\n+    @Test\n+    public void compareWithComparator() {\n+        Comparator<A> comparator = new Comparator<A>() {\n+            public int compare(A a1, A a2) {\n+                return a1.getValue() - a2.getValue();\n+            }\n+        };\n+\n+        // Check my comparator works\n+        assertTrue(comparator.compare(new A(1), new A(2)) < 0);\n+        assertTrue(comparator.compare(new A(2), new A(1)) > 0);\n+        assertTrue(comparator.compare(new A(1), new A(1)) == 0);\n+\n+        // Now test EasyMock.cmp\n+        checkOrder(mock, true);\n+        \n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.EQUAL))).andReturn(\"0\");\n+        \n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.GREATER))).andReturn(\"1\");\n+        \n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.GREATER_OR_EQUAL))).andReturn(\"2\");\n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.GREATER_OR_EQUAL))).andReturn(\"2\");\n+        \n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.LESS_OR_EQUAL))).andReturn(\"3\");\n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.LESS_OR_EQUAL))).andReturn(\"3\");\n+        \n+        expect(mock.oneArg(cmp(new A(5), comparator, \n+                LogicalOperator.LESS_THAN))).andReturn(\"4\");\n+                \n+        replay(mock);\n+        \n+        checkItFails(null); // null is not comparable so always return false\n+        try {\n+            mock.oneArg(\"\");\n+            fail();\n+        }\n+        catch(AssertionError e) {} // different type isn't either\n+        \n+        checkItFails(new A(4));\n+        checkItFails(new A(6));\n+        assertEquals(\"0\", mock.oneArg(new A(5)));\n+\n+        checkItFails(new A(4));\n+        checkItFails(new A(5));        \n+        assertEquals(\"1\", mock.oneArg(new A(6)));\n+        \n+        checkItFails(new A(4));\n+        assertEquals(\"2\", mock.oneArg(new A(6)));\n+        assertEquals(\"2\", mock.oneArg(new A(5)));\n+        \n+        checkItFails(new A(6));\n+        assertEquals(\"3\", mock.oneArg(new A(4)));\n+        assertEquals(\"3\", mock.oneArg(new A(5)));\n+\n+        checkItFails(new A(5));\n+        checkItFails(new A(6));\n+        assertEquals(\"4\", mock.oneArg(new A(4)));\n+        \n+        verify(mock);\n+    }\n+\n+    private void checkItFails(A a) {\n+        try {\n+            mock.oneArg(a);\n+            fail();\n+        }\n+        catch(AssertionError e) {}\n+    }\n+\n+    @Test\n+    public void any() {\n+        expect(mock.oneArg(anyBoolean())).andReturn(\"0\");\n+        expect(mock.oneArg(anyByte())).andReturn(\"1\");\n+        expect(mock.oneArg(anyChar())).andReturn(\"2\");\n+        expect(mock.oneArg(anyDouble())).andReturn(\"3\");\n+        expect(mock.oneArg(anyFloat())).andReturn(\"4\");\n+        expect(mock.oneArg(anyInt())).andReturn(\"5\");\n+        expect(mock.oneArg(anyLong())).andReturn(\"6\");\n+        expect(mock.oneArg(anyShort())).andReturn(\"7\");\n+        expect(mock.oneArg((String) anyObject())).andReturn(\"8\");\n+        expect(mock.oneArg(anyObject())).andReturn(\"9\");\n+        replay(mock);\n+        assertEquals(\"9\", mock.oneArg(new Object()));\n+        assertEquals(\"0\", mock.oneArg(true));\n+        assertEquals(\"1\", mock.oneArg((byte) 1));\n+        assertEquals(\"2\", mock.oneArg((char) 1));\n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 1));\n+        assertEquals(\"8\", mock.oneArg(\"Test\"));\n+        assertEquals(\"4\", mock.oneArg((float) 1));\n+        assertEquals(\"5\", mock.oneArg((int) 1));\n+        assertEquals(\"6\", mock.oneArg((long) 1));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void arrayEquals() {\n+        expect(mock.oneArray(aryEq(new boolean[] { true }))).andReturn(\"0\");\n+        expect(mock.oneArray(aryEq(new byte[] { 1 }))).andReturn(\"1\");\n+        expect(mock.oneArray(aryEq(new char[] { 1 }))).andReturn(\"2\");\n+        expect(mock.oneArray(aryEq(new double[] { 1 }))).andReturn(\"3\");\n+        expect(mock.oneArray(aryEq(new float[] { 1 }))).andReturn(\"4\");\n+        expect(mock.oneArray(aryEq(new int[] { 1 }))).andReturn(\"5\");\n+        expect(mock.oneArray(aryEq(new long[] { 1 }))).andReturn(\"6\");\n+        expect(mock.oneArray(aryEq(new short[] { 1 }))).andReturn(\"7\");\n+        expect(mock.oneArray(aryEq(new String[] { \"Test\" }))).andReturn(\"8\");\n+        expect(mock.oneArray(aryEq(new Object[] { \"Test\" }))).andReturn(\"9\");\n+        replay(mock);\n+        assertEquals(\"9\", mock.oneArray(new Object[] { \"Test\" }));\n+        assertEquals(\"0\", mock.oneArray(new boolean[] { true }));\n+        assertEquals(\"1\", mock.oneArray(new byte[] { 1 }));\n+        assertEquals(\"2\", mock.oneArray(new char[] { 1 }));\n+        assertEquals(\"3\", mock.oneArray(new double[] { 1 }));\n+        assertEquals(\"7\", mock.oneArray(new short[] { 1 }));\n+        assertEquals(\"8\", mock.oneArray(new String[] { \"Test\" }));\n+        assertEquals(\"4\", mock.oneArray(new float[] { 1 }));\n+        assertEquals(\"5\", mock.oneArray(new int[] { 1 }));\n+        assertEquals(\"6\", mock.oneArray(new long[] { 1 }));\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void greaterOrEqual() {\n+        expect(mock.oneArg(geq(7))).andReturn(\"1\").times(3);\n+        expect(mock.oneArg(lt(7))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(7));\n+        assertEquals(\"2\", mock.oneArg(6));\n+        assertEquals(\"1\", mock.oneArg(8));\n+        assertEquals(\"2\", mock.oneArg(6));\n+        assertEquals(\"1\", mock.oneArg(9));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void greaterThan() {\n+        expect(mock.oneArg(gt(7))).andReturn(\"1\").times(3);\n+        expect(mock.oneArg(leq(7))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(8));\n+        assertEquals(\"2\", mock.oneArg(7));\n+        assertEquals(\"1\", mock.oneArg(9));\n+        assertEquals(\"2\", mock.oneArg(6));\n+        assertEquals(\"1\", mock.oneArg(10));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void lessOrEqual() {\n+        expect(mock.oneArg(leq(7))).andReturn(\"1\").times(3);\n+        expect(mock.oneArg(gt(7))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(7));\n+        assertEquals(\"2\", mock.oneArg(8));\n+        assertEquals(\"1\", mock.oneArg(6));\n+        assertEquals(\"2\", mock.oneArg(9));\n+        assertEquals(\"1\", mock.oneArg(5));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void lessThan() {\n+        expect(mock.oneArg(lt(7))).andReturn(\"1\").times(3);\n+        expect(mock.oneArg(geq(7))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(5));\n+        assertEquals(\"2\", mock.oneArg(7));\n+        assertEquals(\"1\", mock.oneArg(6));\n+        assertEquals(\"2\", mock.oneArg(8));\n+        assertEquals(\"1\", mock.oneArg(4));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testOr() {\n+        expect(mock.oneArg(or(eq(7), eq(9)))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(anyInt())).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(7));\n+        assertEquals(\"1\", mock.oneArg(9));\n+        assertEquals(\"2\", mock.oneArg(10));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        expect(mock.threeArgumentMethod(eq(1), isNull(), eq(\"\")))\n+                .andReturn(\"1\").atLeastOnce();\n+        expect(mock.threeArgumentMethod(eq(1), not(isNull()), eq(\"\")))\n+                .andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.threeArgumentMethod(1, null, \"\"));\n+        assertEquals(\"2\", mock.threeArgumentMethod(1, new Object(), \"\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testNotNull() {\n+        expect(mock.threeArgumentMethod(eq(1), notNull(), eq(\"\"))).andReturn(\n+                \"1\").atLeastOnce();\n+        expect(mock.threeArgumentMethod(eq(1), not(notNull()), eq(\"\")))\n+                .andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.threeArgumentMethod(1, new Object(), \"\"));\n+        assertEquals(\"2\", mock.threeArgumentMethod(1, null, \"\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testFind() {\n+        expect(mock.oneArg(find(\"[a-z]+\\\\d\"))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(find(\"\\\\d\\\\d\"))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(\"1ab12\"));\n+        assertEquals(\"2\", mock.oneArg(\"312xx\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testMatches() {\n+        expect(mock.oneArg(matches(\"[a-z]+\\\\d\\\\d\"))).andReturn(\"1\")\n+                .atLeastOnce();\n+        expect(mock.oneArg(matches(\"\\\\d\\\\d\\\\d\"))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(\"a12\"));\n+        assertEquals(\"2\", mock.oneArg(\"131\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testContains() {\n+        expect(mock.oneArg(contains(\"ab\"))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(contains(\"bc\"))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(\"xabcx\"));\n+        assertEquals(\"2\", mock.oneArg(\"xdbcx\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testStartsWith() {\n+        expect(mock.oneArg(startsWith(\"ab\"))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(startsWith(\"bc\"))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(\"abcx\"));\n+        assertEquals(\"2\", mock.oneArg(\"bcxe\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testEndsWith() {\n+        expect(mock.oneArg(endsWith(\"ab\"))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(endsWith(\"bc\"))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(\"xab\"));\n+        assertEquals(\"2\", mock.oneArg(\"xbc\"));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void equalsWithDelta() {\n+        expect(mock.oneArg(eq(1.0D, 0.1D))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(eq(2.0D, 0.1D))).andStubReturn(\"2\");\n+        expect(mock.oneArg(eq(1.0F, 0.1F))).andReturn(\"3\").atLeastOnce();\n+        expect(mock.oneArg(eq(2.0F, 0.1F))).andStubReturn(\"4\");\n+        expect(mock.oneArg(eq(2.0F, 0.1F))).andStubReturn(\"4\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(1.0));\n+        assertEquals(\"1\", mock.oneArg(0.91));\n+        assertEquals(\"1\", mock.oneArg(1.09));\n+        assertEquals(\"2\", mock.oneArg(2.0));\n+\n+        assertEquals(\"3\", mock.oneArg(1.0F));\n+        assertEquals(\"3\", mock.oneArg(0.91F));\n+        assertEquals(\"3\", mock.oneArg(1.09F));\n+        assertEquals(\"4\", mock.oneArg(2.0F));\n+\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void testSame() {\n+        Object one = new String(\"1243\");\n+        Object two = new String(\"1243\");\n+\n+        assertNotSame(one, two);\n+        assertEquals(one, two);\n+\n+        expect(mock.oneArg(same(one))).andReturn(\"1\").atLeastOnce();\n+        expect(mock.oneArg(same(two))).andStubReturn(\"2\");\n+\n+        replay(mock);\n+\n+        assertEquals(\"1\", mock.oneArg(one));\n+        assertEquals(\"2\", mock.oneArg(two));\n+\n+        verify(mock);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/UsageMatchersTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+\n+import org.easymock.tests.IMethods;\n+import org.junit.Test;\n+\n+public class UsageMatchersTest {\n+    @Test(expected = IllegalStateException.class)\n+    public void additionalMatchersFailAtReplay() {\n+\n+        IMethods mock = createMock(IMethods.class);\n+        lt(5);\n+\n+        replay(mock);\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/UsageStrictMockTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.internal.ReplayState;\n+import org.easymock.tests.IMethods;\n+import org.easymock.tests.Util;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageStrictMockTest {\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = createStrictMock(IMethods.class);\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+        replay(mock);\n+    }\n+\n+    @Test\n+    public void orderedCallsSucces() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+        verify(mock);\n+    }\n+\n+    @Test\n+    public void unorderedCallsFailure() {\n+        boolean failed = false;\n+        try {\n+            mock.simpleMethodWithArgument(\"2\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail(\"unordered calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void tooManyCallsFailure() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        boolean failed = false;\n+        try {\n+            mock.simpleMethodWithArgument(\"2\");\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail(\"too many calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void tooFewCallsFailure() {\n+        mock.simpleMethodWithArgument(\"1\");\n+        boolean failed = false;\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertTrue(\"stack trace must be filled in\", Util.getStackTrace(\n+                    expected).indexOf(ReplayState.class.getName()) == -1);\n+        }\n+        if (!failed) {\n+            fail(\"too few calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void differentMethods() {\n+\n+        reset(mock);\n+\n+        mock.booleanReturningMethod(0);\n+        expectLastCall().andReturn(true);\n+        mock.simpleMethod();\n+        mock.booleanReturningMethod(1);\n+        expectLastCall().andReturn(false).times(2, 3);\n+        mock.simpleMethod();\n+        expectLastCall().atLeastOnce();\n+\n+        replay(mock);\n+        assertEquals(true, mock.booleanReturningMethod(0));\n+        mock.simpleMethod();\n+\n+        boolean failed = false;\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    simpleMethod(): expected: 1, actual: 1\"\n+                            + \"\\n    booleanReturningMethod(1): expected: between 2 and 3, actual: 0\"\n+                            + \"\\n    simpleMethod(): expected: at least 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"too few calls accepted\");\n+        }\n+\n+        assertEquals(false, mock.booleanReturningMethod(1));\n+\n+        failed = false;\n+        try {\n+            mock.simpleMethod();\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethod():\"\n+                            + \"\\n    booleanReturningMethod(1): expected: between 2 and 3, actual: 1\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"wrong call accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void range() {\n+\n+        reset(mock);\n+\n+        mock.booleanReturningMethod(0);\n+        expectLastCall().andReturn(true);\n+        mock.simpleMethod();\n+        mock.booleanReturningMethod(1);\n+        expectLastCall().andReturn(false).times(2, 3);\n+        mock.simpleMethod();\n+        expectLastCall().atLeastOnce();\n+        expect(mock.booleanReturningMethod(1)).andReturn(false);\n+\n+        replay(mock);\n+\n+        mock.booleanReturningMethod(0);\n+        mock.simpleMethod();\n+\n+        mock.booleanReturningMethod(1);\n+        mock.booleanReturningMethod(1);\n+        mock.booleanReturningMethod(1);\n+\n+        boolean failed = false;\n+\n+        try {\n+            mock.booleanReturningMethod(1);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Unexpected method call booleanReturningMethod(1):\"\n+                            + \"\\n    booleanReturningMethod(1): expected: between 2 and 3, actual: 3 (+1)\"\n+                            + \"\\n    simpleMethod(): expected: at least 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"too many calls accepted\");\n+        }\n+    }\n+\n+    @Test\n+    public void stubBehavior() {\n+        reset(mock);\n+\n+        mock.booleanReturningMethod(1);\n+        expectLastCall().andReturn(true).andReturn(false).andReturn(true);\n+        mock.booleanReturningMethod(anyInt());\n+        expectLastCall().andStubReturn(true);\n+\n+        replay(mock);\n+\n+        assertEquals(true, mock.booleanReturningMethod(2));\n+        assertEquals(true, mock.booleanReturningMethod(3));\n+        assertEquals(true, mock.booleanReturningMethod(1));\n+        assertEquals(false, mock.booleanReturningMethod(1));\n+        assertEquals(true, mock.booleanReturningMethod(3));\n+\n+        boolean failed = false;\n+        try {\n+            verify(mock);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    booleanReturningMethod(1): expected: 3, actual: 2\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"too few calls accepted\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/easymock/tests2/UsageTest.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.easymock.tests2;\n+\n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n+\n+import org.easymock.tests.IMethods;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class UsageTest {\n+\n+    IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = createMock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void exactCallCountByLastCall() {\n+        expect(mock.oneArg(false)).andReturn(\"Test\").andReturn(\"Test2\");\n+        replay(mock);\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+\n+        boolean failed = false;\n+        try {\n+            mock.oneArg(false);\n+        } catch (AssertionError expected) {\n+            failed = true;\n+        }\n+        if (!failed)\n+            fail(\"expected AssertionError\");\n+    }\n+\n+    @Test\n+    public void openCallCountByLastCall() {\n+        expect(mock.oneArg(false)).andReturn(\"Test\").andReturn(\"Test2\")\n+                .atLeastOnce();\n+\n+        replay(mock);\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+    }\n+\n+    @Test\n+    public void exactCallCountByLastThrowable() {\n+        expect(mock.oneArg(false)).andReturn(\"Test\").andReturn(\"Test2\")\n+                .andThrow(new IndexOutOfBoundsException());\n+\n+        replay(mock);\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+\n+        try {\n+            mock.oneArg(false);\n+            fail();\n+        } catch (IndexOutOfBoundsException expected) {\n+        }\n+\n+        boolean failed = true;\n+        try {\n+            mock.oneArg(false);\n+            failed = false;\n+        } catch (AssertionError expected) {\n+        }\n+        if (!failed)\n+            fail(\"expected AssertionError\");\n+    }\n+\n+    @Test\n+    public void openCallCountByLastThrowable() {\n+        expect(mock.oneArg(false)).andReturn(\"Test\").andReturn(\"Test2\")\n+                .andThrow(new IndexOutOfBoundsException()).atLeastOnce();\n+\n+        replay(mock);\n+\n+        assertEquals(\"Test\", mock.oneArg(false));\n+        assertEquals(\"Test2\", mock.oneArg(false));\n+\n+        try {\n+            mock.oneArg(false);\n+        } catch (IndexOutOfBoundsException expected) {\n+        }\n+        try {\n+            mock.oneArg(false);\n+        } catch (IndexOutOfBoundsException expected) {\n+        }\n+    }\n+\n+    @Test\n+    public void moreThanOneArgument() {\n+        expect(mock.threeArgumentMethod(1, \"2\", \"3\")).andReturn(\"Test\")\n+                .times(2);\n+\n+        replay(mock);\n+\n+        assertEquals(\"Test\", mock.threeArgumentMethod(1, \"2\", \"3\"));\n+\n+        boolean failed = true;\n+        try {\n+            verify(mock);\n+            failed = false;\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Expectation failure on verify:\"\n+                            + \"\\n    threeArgumentMethod(1, \\\"2\\\", \\\"3\\\"): expected: 2, actual: 1\",\n+                    expected.getMessage());\n+        }\n+        if (!failed) {\n+            fail(\"exception expected\");\n+        }\n+    }\n+\n+    @Test\n+    public void wrongArguments() {\n+        mock.simpleMethodWithArgument(\"3\");\n+        replay(mock);\n+\n+        try {\n+            mock.simpleMethodWithArgument(\"5\");\n+            fail();\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethodWithArgument(\\\"5\\\"):\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"3\\\"): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void summarizeSameObjectArguments() {\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"3\");\n+        replay(mock);\n+\n+        try {\n+            mock.simpleMethodWithArgument(\"5\");\n+            fail();\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethodWithArgument(\\\"5\\\"):\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"3\\\"): expected: 2, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void argumentsOrdered() {\n+        mock.simpleMethodWithArgument(\"4\");\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"2\");\n+        mock.simpleMethodWithArgument(\"0\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        replay(mock);\n+\n+        try {\n+            mock.simpleMethodWithArgument(\"5\");\n+            fail(\"exception expected\");\n+        } catch (AssertionError expected) {\n+            assertEquals(\n+                    \"\\n  Unexpected method call simpleMethodWithArgument(\\\"5\\\"):\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"4\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"3\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"2\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"0\\\"): expected: 1, actual: 0\"\n+                            + \"\\n    simpleMethodWithArgument(\\\"1\\\"): expected: 1, actual: 0\",\n+                    expected.getMessage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void mixingOrderedAndUnordered() {\n+        mock.simpleMethodWithArgument(\"2\");\n+        mock.simpleMethodWithArgument(\"1\");\n+        checkOrder(mock, true);\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"4\");\n+        checkOrder(mock, false);\n+        mock.simpleMethodWithArgument(\"6\");\n+        mock.simpleMethodWithArgument(\"7\");\n+        mock.simpleMethodWithArgument(\"5\");\n+\n+        replay(mock);\n+\n+        mock.simpleMethodWithArgument(\"1\");\n+        mock.simpleMethodWithArgument(\"2\");\n+\n+        boolean failed = false;\n+        try {\n+            mock.simpleMethodWithArgument(\"4\");\n+        } catch (AssertionError e) {\n+            failed = true;\n+        }\n+        if (!failed) {\n+            fail();\n+        }\n+\n+        mock.simpleMethodWithArgument(\"3\");\n+        mock.simpleMethodWithArgument(\"4\");\n+        mock.simpleMethodWithArgument(\"5\");\n+        mock.simpleMethodWithArgument(\"6\");\n+        mock.simpleMethodWithArgument(\"7\");\n+\n+        verify(mock);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/MockUtilTest.java\n+/*\n+ * Copyright (c) 2007 Szczepan Faber \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.MockUtil.*;\n+\n+import java.util.*;\n+\n+import net.sf.cglib.proxy.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.NotAMockException;\n+\n+public class MockUtilTest {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test \n+    public void shouldGetControl() {\n+        List mock = Mockito.mock(List.class);\n+        assertNotNull(getControl(mock));\n+    }\n+\n+    @Test \n+    public void shouldScreamWhenEnhancedButNotAMockPassed() {\n+        Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);\n+        try {\n+            getControl(o);\n+            fail();\n+        } catch (NotAMockException e) {}\n+    }\n+\n+    @Test (expected=NotAMockException.class)\n+    public void shouldScreamWhenNotAMockPassed() {\n+        getControl(\"\");\n+    }\n+    \n+    @Test (expected=NotAMockException.class)\n+    public void shouldValidateMock() {\n+        validateMock(\"\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/MockitoOperationsTest.java\n+package org.mockito;\n+\n+import org.junit.Test;\n+import org.mockito.*;\n+\n+import static org.junit.Assert.*;\n+\n+public class MockitoOperationsTest {\n+\n+    @Test\n+    public void shouldSwitchVerifyingMode() throws Exception {\n+        MockitoOperations.reportVerifyingMode(VerifyingMode.anyTimes());\n+        \n+        assertTrue(MockitoOperations.mockVerificationScenario());\n+        \n+        MockitoOperations.reportVerifyingMode(null);\n+        \n+        assertFalse(MockitoOperations.mockVerificationScenario());\n+        \n+        MockitoOperations.reportVerifyingMode(VerifyingMode.times(100));\n+        \n+        assertTrue(MockitoOperations.mockVerificationScenario());\n+        \n+        assertEquals(100, MockitoOperations.removeVerifyingMode().getExactNumberOfInvocations());\n+        \n+        assertFalse(MockitoOperations.mockVerificationScenario());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/MockitoProvidesObjectMethodsTest.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.junit.Assert.assertThat;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class MockitoProvidesObjectMethodsTest {\n+\n+    /**\n+     * Class overwrites object methods but implementation from Mockito will be called anyway.\n+     */\n+    public static class ClassToMockWithOverride {\n+\n+        public boolean equals(Object o) {\n+            return false;\n+        }\n+\n+        public int hashCode() {\n+            return -1;\n+        }\n+\n+        public String toString() {\n+            return \"super\";\n+        }\n+    }\n+    \n+    public static class ClassWithAnotherOverride extends ClassToMockWithOverride {\n+        \n+        public String toString() {\n+            return \"super.super\";\n+        }\n+    }\n+\n+    @Test \n+    public void testShouldReplaceObjectMethods() {\n+        Object mock = Mockito.mock(ClassToMockWithOverride.class);\n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock.hashCode(), not(equalTo(-1)));\n+        assertThat(mock.toString(), not(equalTo(\"super\")));\n+    }\n+    \n+    @Test \n+    public void testShouldReplaceObjectMethodsWhenOverridden() {\n+        Object mock = Mockito.mock(ClassToMockWithOverride.class);\n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock.hashCode(), not(equalTo(-1)));\n+        assertThat(mock.toString(), not(equalTo(\"super\")));\n+        assertThat(mock.toString(), not(equalTo(\"super.super\")));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/VerifyingModeTest.java\n+package org.mockito;\n+\n+import org.junit.Test;\n+import org.mockito.VerifyingMode;\n+\n+import static org.junit.Assert.*;\n+\n+\n+public class VerifyingModeTest {\n+\n+    @Test\n+    public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n+        VerifyingMode mode = VerifyingMode.anyTimes();\n+        assertFalse(mode.numberOfInvocationsMatters());\n+        \n+        mode = VerifyingMode.times(50);\n+        assertTrue(mode.numberOfInvocationsMatters());\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            VerifyingMode.times(-50);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/BasicStubbingTest.java\n+package org.mockito.usage;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.Matchers.contains;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class BasicStubbingTest {\n+\n+    private interface DummyInterface {\n+        int getInt(String value);\n+        String getString(int argumentOne, String argumentTwo);\n+        List<String> getList();\n+    }\n+    \n+    @Test\n+    public void shouldStubAllMethodsByDefault() throws Exception {\n+        DummyInterface mock = Mockito.mock(DummyInterface.class);\n+\n+        assertEquals(0, mock.getInt(\"test\"));\n+        assertEquals(0, mock.getInt(\"testTwo\"));\n+        \n+        assertNull(mock.getString(0, null));\n+        assertNull(mock.getString(100, null));\n+        \n+        assertEquals(0, mock.getList().size());\n+        assertEquals(0, mock.getList().size());\n+    }\n+    \n+    @Test\n+    public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n+        DummyInterface mock = Mockito.mock(DummyInterface.class);\n+        \n+        Mockito.stub(mock.getInt(\"14\")).andReturn(14);\n+        \n+        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        \n+        Mockito.stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n+        \n+        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n+        \n+        Mockito.stub(mock.getString(10, \"test\")).andReturn(\"test\");\n+        \n+        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/BasicVerificationTest.java\n+package org.mockito.usage;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class BasicVerificationTest {\n+\n+    @Test\n+    public void shouldVerify() throws Exception {\n+        List mock = Mockito.mock(List.class);\n+\n+        mock.clear();\n+        Mockito.verify(mock).clear();\n+\n+        mock.add(\"test\");\n+        Mockito.verify(mock).add(\"test\");\n+\n+        Mockito.verifyNoMoreInteractions(mock);\n+    }\n+\n+    @Test\n+    public void shouldFailVerification() throws Exception {\n+        List mock = Mockito.mock(List.class);\n+\n+        try {\n+            Mockito.verify(mock).clear();\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Mock verification failed\"));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailVerificationOnMethodArgument() throws Exception {\n+        List mock = Mockito.mock(List.class);\n+        mock.clear();\n+        mock.add(\"foo\");\n+\n+        Mockito.verify(mock).clear();\n+        try {\n+            Mockito.verify(mock).add(\"bar\");\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Mock verification failed\"));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldLetYouVerifyTheSameMethodAnyTimes() throws Exception {\n+        List mock = Mockito.mock(List.class);\n+        mock.clear();\n+\n+        Mockito.verify(mock).clear();\n+        Mockito.verify(mock).clear();\n+        Mockito.verify(mock).clear();\n+    }\n+\n+    @Test\n+    public void shouldDetectRedundantInvocation() throws Exception {\n+        List mock = Mockito.mock(List.class);\n+        mock.clear();\n+        mock.add(\"foo\");\n+        mock.add(\"bar\");\n+\n+        Mockito.verify(mock).clear();\n+        Mockito.verify(mock).add(\"foo\");\n+\n+        try {\n+            Mockito.verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Mock verification failed\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStubbedMethods() throws Exception {\n+        LinkedList mock = Mockito.mock(LinkedList.class);\n+        \n+        Mockito.stub(mock.add(\"test\")).andReturn(Boolean.FALSE);\n+        \n+        mock.add(\"test\");\n+        \n+        Mockito.verify(mock).add(\"test\");\n+    }\n+\n+    @Test\n+    public void easyMockNotVerify() throws Exception {\n+        List mock = EasyMock.createMock(List.class);\n+//        mock.clear();\n+        EasyMock.replay(mock);\n+        \n+        EasyMock.verify(mock);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/ExactNumberOfTimesVerificationTest.java\n+package org.mockito.usage;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.junit.Assert.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ExactNumberOfTimesVerificationTest {\n+\n+    @Test\n+    public void shouldVerifyActualNumberOfInvocationsSmallerThanExpected() throws Exception {\n+        LinkedList mock = Mockito.mock(LinkedList.class);\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+\n+        Mockito.verify(mock, 3).clear();\n+        try {\n+            Mockito.verify(mock, 100).clear();\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 100 times but was 3\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyActualNumberOfInvocationsLargerThanExpected() throws Exception {\n+        LinkedList mock = Mockito.mock(LinkedList.class);\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+\n+        Mockito.verify(mock, 3).clear();\n+        try {\n+            Mockito.verify(mock, 1).clear();\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 1 times but was 3\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyProperlyIfMethodWasNotInvoked() throws Exception {\n+        LinkedList mock = Mockito.mock(LinkedList.class);\n+\n+        Mockito.verify(mock, 0).clear();\n+        try {\n+            Mockito.verify(mock, 15).clear();\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 15 times but was 0\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyProperlyIfMethodWasInvokedOnce() throws Exception {\n+        LinkedList mock = Mockito.mock(LinkedList.class);\n+\n+        mock.clear();\n+        \n+        Mockito.verify(mock, 1).clear();\n+        try {\n+            Mockito.verify(mock, 15).clear();\n+            fail();\n+        } catch (AssertionError error) {\n+            assertThat(error.getMessage(), equalTo(\"Expected to be invoked 15 times but was 1\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldNotCountInStubbedInvocations() throws Exception {\n+        LinkedList mock = Mockito.mock(LinkedList.class);\n+        \n+        Mockito.stub(mock.add(\"test\")).andReturn(false);\n+        Mockito.stub(mock.add(\"test\")).andReturn(true);\n+        \n+        mock.add(\"test\");\n+        mock.add(\"test\");\n+        \n+        Mockito.verify(mock, 2).add(\"test\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/MockReturnsEmptyCollectionsTest.java\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class MockReturnsEmptyCollectionsTest {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test \n+    public void shouldReturnEmptyCollections() {\n+        CollectionsServer mock = Mockito.mock(CollectionsServer.class);\n+        \n+        assertTrue(mock.list().isEmpty());\n+        assertTrue(mock.linkedList().isEmpty());\n+        assertTrue(mock.map().isEmpty());\n+        assertTrue(mock.hashSet().isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private class CollectionsServer {\n+        List list() {\n+            return null;\n+        }\n+\n+        LinkedList linkedList() {\n+            return null;\n+        }\n+\n+        Map map() {\n+            return null;\n+        }\n+\n+        java.util.HashSet hashSet() {\n+            return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/MockitoExploitsTest.java\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.hamcrest.CoreMatchers.*;\n+\n+import java.util.List;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.*;\n+\n+/**\n+ * TODO find out what is important to protect ourselves and what's just too defensive \n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoExploitsTest {\n+    \n+    @Test\n+    public void rubbishPassedToStubMethod1() {\n+        MockitoOperations.reportControlForStubbing(null);\n+        try {\n+            stub(\"blah\".contains(\"blah\")).andReturn(Boolean.TRUE);\n+            fail();\n+        } catch (NotAMockMethodException e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void unfinishedStubbingDetectedOnVerify() {\n+        List mock = mock(List.class);\n+        \n+        stub(mock.add(\"test\"));\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (UnfinishedStubbingException e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void unfinishedStubbingDetectedWhenAnotherStubbingIsStarted() {\n+        List mock = mock(List.class);\n+        \n+        stub(mock.add(\"test\"));\n+        \n+        try {\n+            stub(mock.add(\"test\")).andThrows(new Exception(\"ssdf\"));\n+            fail();\n+        } catch (UnfinishedStubbingException e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void rubbishPassedToStubMethodButThereIsAlreadyMethodCalledOnTheMock() {\n+        List mock = mock(List.class);\n+        \n+        mock.add(\"test\");\n+        \n+        stub(\"blah\".contains(\"blah\")).andReturn(Boolean.TRUE);\n+        \n+        assertFalse(mock.add(\"test\"));\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void rubbishPassedToStubMethodAndThrowableSet() {\n+        List mock = mock(List.class);\n+        try {\n+            stub(\"asdf\".charAt(1)).andThrows(new RuntimeException());\n+            fail();\n+        } catch (Exception e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldLetVerifyOnlyMocks() throws Exception {\n+        try {\n+            Mockito.verify(\"not a mock\");\n+            fail();\n+        } catch (NotAMockException e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldMockString() throws Exception {\n+        String s = Mockito.mock(String.class);\n+        stub(s.concat(\"world\")).andReturn(\"hello world\");\n+        \n+        assertThat(s.concat(\"world\"), equalTo(\"hello world\"));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/MockitoSyntaxExperiments.java\n+package org.mockito.usage;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoSyntaxExperiments {\n+    \n+    public void goodOldEasyMockVerifySyntax() {\n+        List mock = mock(List.class);\n+        \n+        //stub it\n+        stub(mock.add(\"test\")).andReturn(true);\n+        \n+        //use it\n+        mock.add(2, \"test2\");\n+\n+        Mockito.verify(mock).add(2, \"test2\");\n+        Mockito.verify(mock, 5).add(2, \"test2\");\n+            //or\n+//            Mockito.verify(mock).times(5).add(2, \"test2\");\n+        Mockito.verifyNoMoreInteractions(mock);\n+        Mockito.verifyZeroInteractions(mock);\n+    }\n+    \n+    public void oldSchoolAssertSyntax() {\n+        List mock = mock(List.class);\n+        \n+        //stub it\n+        stub(mock.add(\"test\")).andReturn(true);\n+        \n+        //use it\n+        mock.add(2, \"test2\");\n+\n+        //Second for old style assertions\n+        Mockito.assertInvoked(mock).add(2, \"test2\");\n+        Mockito.assertInvoked(mock, 5).add(2, \"test2\");\n+            //or\n+//            Mockito.assertInvoked(mock).times(5).add(2, \"test2\");\n+        Mockito.assertNoMoreInteractions(mock);\n+        Mockito.assertZeroInteractions(mock);\n+    }\n+    \n+    public void shinyNewAssertThatSyntax() {\n+        List mock = mock(List.class);\n+        \n+        //stub it\n+        stub(mock.add(\"test\")).andReturn(true);\n+        \n+        //use it\n+        mock.add(2, \"test2\");\n+        \n+        Mockito.assertThat(wasInvoked(mock)).add(2, \"test2\");\n+        Mockito.assertThat(wasInvoked(mock, 5)).add(2, \"test2\");\n+        Mockito.assertThat(noMoreInteractions(mock));\n+        Mockito.assertThat(zeroInteractions(mock));\n+    }\n+    \n+    public void verifiesMocksInOrder() {\n+//        Mockito.verifyInOrder(new Ordering() { void sequence() {\n+//            Mockito.verify(mock).clear();\n+//            Mockito.verify(mock2).clear();\n+//        }};);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/NoMoreInteractionsVerificationTest.java\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.MockVerificationAssertionError;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class NoMoreInteractionsVerificationTest {\n+\n+    @Test\n+    public void shouldStubbingNotRegisterRedundantInteractions() throws Exception {\n+        List mock = mock(List.class);\n+        stub(mock.add(\"one\")).andReturn(true);\n+        stub(mock.add(\"two\")).andReturn(true);\n+\n+        mock.add(\"one\");\n+        \n+        verify(mock).add(\"one\");\n+        verifyNoMoreInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyWhenExactNumberOfInvocationsUsed() throws Exception {\n+        List mock = mock(List.class);\n+\n+        mock.add(\"one\");\n+        mock.add(\"one\");\n+        mock.add(\"one\");\n+        \n+        verify(mock, 3).add(\"one\");\n+        \n+        verifyNoMoreInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyNoInteractions() throws Exception {\n+        List mock = mock(List.class);\n+\n+        verifyNoMoreInteractions(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldFailNoInteractionsVerification() throws Exception {\n+        List mock = mock(List.class);\n+\n+        mock.clear();\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (MockVerificationAssertionError e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFailNoMoreInteractionsVerification() throws Exception {\n+        List mock = mock(List.class);\n+\n+        mock.clear();\n+        \n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (MockVerificationAssertionError e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyOneMockButFailOnOther() throws Exception {\n+        List list = mock(List.class);\n+        Map map = mock(Map.class);\n+\n+        list.add(\"one\");\n+        list.add(\"one\");\n+        \n+        map.put(\"one\", 1);\n+        \n+        verify(list, 2).add(\"one\");\n+        \n+        verifyNoMoreInteractions(list);\n+        try {\n+            verifyZeroInteractions(map);\n+            fail();\n+        } catch (MockVerificationAssertionError e) {\n+            //cool\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/StubbingWithThrowablesTest.java\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.io.*;\n+import java.util.LinkedList;\n+\n+import org.junit.Test;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingWithThrowablesTest {\n+\n+    @Test\n+    public void shouldStubWithThrowable() throws Exception {\n+        LinkedList mock = mock(LinkedList.class);\n+\n+        IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n+        stub(mock.add(\"throw\")).andThrows(expected);\n+        \n+        try {\n+            mock.add(\"throw\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(expected, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldSetThrowableToVoidMethod() throws Exception {\n+        LinkedList mock = mock(LinkedList.class);\n+\n+        IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n+        \n+        stubVoid(mock).toThrow(expected).on().clear();\n+        \n+        try {\n+            mock.clear();\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(expected, e);\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldAllowSettingCheckedException() throws Exception {\n+        Reader reader = mock(Reader.class);\n+        IOException ioException = new IOException();\n+        \n+        stub(reader.read()).andThrows(ioException);\n+        \n+        try {\n+            reader.read();\n+        } catch (Exception e) {\n+            assertEquals(ioException, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldAllowSettingError() throws Exception {\n+        LinkedList mock = mock(LinkedList.class);\n+        Error error = new Error();\n+        \n+        stub(mock.add(\"quake\")).andThrows(error);\n+        \n+        try {\n+            mock.add(\"quake\");\n+        } catch (Error e) {\n+            assertEquals(error, e);\n+        }\n+    }    \n+    \n+    @Test\n+    public void shouldNotAllowSettingCheckedException() throws Exception {\n+        LinkedList list = mock(LinkedList.class);\n+        Exception checkedException = new Exception();\n+        \n+        try {\n+            stub(list.add(\"monkey island\")).andThrows(checkedException);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Given checked exception is invalid for this method\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowSettingNullThrowable() throws Exception {\n+        LinkedList list = mock(LinkedList.class);\n+        \n+        try {\n+            stub(list.add(\"monkey island\")).andThrows(null);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(\"Cannot set null throwable\", e.getMessage());\n+        }\n+    }    \n+    \n+    @Test\n+    public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n+        \n+    }\n+    \n+    @Test\n+    public void shouldVerifyWhenStubbedWithThrowable() throws Exception {\n+        \n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/VerificationOnMultipleMocksUsingMatchersTest.java\n+package org.mockito.usage;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class VerificationOnMultipleMocksUsingMatchersTest {\n+\n+    @Test\n+    public void shouldVerifyUsingMatchers() throws Exception {\n+        List list = Mockito.mock(List.class);\n+        HashMap map = Mockito.mock(HashMap.class);\n+        \n+        list.add(\"test\");\n+        list.add(1, \"test two\");\n+        \n+        map.put(\"test\", 100);\n+        map.put(\"test two\", 200);\n+        \n+        verify(list).add(EasyMock.anyObject());\n+        verify(list).add(EasyMock.anyInt(), EasyMock.eq(\"test two\"));\n+        \n+        verify(map).put(EasyMock.anyObject(), EasyMock.anyObject());\n+        verify(map).put(EasyMock.eq(\"test two\"), EasyMock.eq(200));\n+        \n+        verifyNoMoreInteractions(list, map);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMultipleMocks() throws Exception {\n+        List list = mock(List.class);\n+        Map map = mock(Map.class);\n+        Set set = mock(Set.class);\n+\n+        list.add(\"one\");\n+        list.add(\"one\");\n+        list.add(\"two\");\n+        \n+        map.put(\"one\", 1);\n+        map.put(\"one\", 1);\n+        \n+        verify(list, 2).add(\"one\");\n+        verify(list, 1).add(\"two\");\n+        verify(list, 0).add(\"three\");\n+        \n+        verify(map, 2).put(EasyMock.anyObject(), EasyMock.anyInt());\n+        \n+        verifyNoMoreInteractions(list, map);\n+        verifyZeroInteractions(set);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/util/Matchers.java\n+package org.mockito.util;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+\n+public class Matchers {\n+\n+    public static <T> Matcher<Collection<T>> contains(final T ... elements) {\n+        return new BaseMatcher<Collection<T>>() {\n+\n+            public boolean matches(Object collection) {\n+                for (T element : elements) {\n+                    if (((Collection)collection).contains(element) == false) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"collection doesn't containg one of: \" + Arrays.toString(elements));\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/vs/easymock/ArticleCalculator.java\n+package org.mockito.vs.easymock;\n+\n+public interface ArticleCalculator {\n+    int countArticles(String newspaper);\n+    int countArticlesInPolish(String newspaper);\n+}\n--- /dev/null\n+++ b/test/org/mockito/vs/easymock/ArticleDatabase.java\n+package org.mockito.vs.easymock;\n+\n+public class ArticleDatabase {\n+\n+    public void updateNumberOfArticles(String newspaper, int articles) {\n+    }\n+\n+    public void updateNumberOfPolishArticles(String newspaper, int polishArticles) {\n+    }\n+\n+    public void updateNumberOfEnglishArticles(String newspaper, int i) {\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/vs/easymock/ArticleManager.java\n+package org.mockito.vs.easymock;\n+\n+public class ArticleManager {\n+    \n+    private final ArticleCalculator calculator;\n+    private final ArticleDatabase database;\n+\n+    public ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {\n+        this.calculator = calculator;\n+        this.database = database;\n+    }\n+    \n+    public void updateArticleCounters(String newspaper) {\n+        int articles = calculator.countArticles(newspaper);\n+        int polishArticles = calculator.countArticlesInPolish(newspaper);\n+        \n+        database.updateNumberOfArticles(newspaper, articles);\n+        database.updateNumberOfPolishArticles(newspaper, polishArticles);\n+        database.updateNumberOfEnglishArticles(newspaper, articles - polishArticles);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/vs/easymock/MockitoVsEasyMockTest.java\n+package org.mockito.vs.easymock;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class MockitoVsEasyMockTest {\n+    \n+    @Test\n+    public void easyMockRocks() {\n+        ArticleCalculator mockCalculator = EasyMock.createMock(ArticleCalculator.class);\n+        ArticleDatabase mockDatabase = EasyMock.createMock(ArticleDatabase.class);\n+        \n+        ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n+              \n+        EasyMock.expect(mockCalculator.countArticles(\"Guardian\")).andReturn(12);\n+        EasyMock.expect(mockCalculator.countArticlesInPolish(\"Guardian\")).andReturn(5);\n+        \n+        mockDatabase.updateNumberOfArticles(\"Guardian\", 12);\n+        mockDatabase.updateNumberOfPolishArticles(\"Guardian\", 5);\n+        mockDatabase.updateNumberOfEnglishArticles(\"Guardian\", 7);\n+        \n+        EasyMock.replay(mockCalculator, mockDatabase);\n+        \n+        articleManager.updateArticleCounters(\"Guardian\");\n+        \n+        EasyMock.verify(mockCalculator, mockDatabase);\n+    }\n+\n+    @Test\n+    public void managerCountsArticlesAndSavesThemInTheDatabase() {\n+        ArticleCalculator mockCalculator = Mockito.mock(ArticleCalculator.class);\n+        ArticleDatabase mockDatabase = Mockito.mock(ArticleDatabase.class);\n+        \n+        ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n+\n+        Mockito.stub(mockCalculator.countArticles(\"Guardian\")).andReturn(12);\n+        Mockito.stub(mockCalculator.countArticlesInPolish(\"Guardian\")).andReturn(5);\n+        \n+        articleManager.updateArticleCounters(\"Guardian\");\n+        \n+        Mockito.verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 12);\n+        Mockito.verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 5);\n+        Mockito.verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 7);\n+    }\n+    \n+    @Test\n+    public void managerCountsArticlesUsingCalculator() {\n+        ArticleCalculator mockCalculator = Mockito.mock(ArticleCalculator.class);\n+        ArticleDatabase mockDatabase = Mockito.mock(ArticleDatabase.class);\n+        \n+        ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n+\n+        articleManager.updateArticleCounters(\"Guardian\");\n+\n+        Mockito.verify(mockCalculator).countArticles(\"Guardian\");\n+        Mockito.verify(mockCalculator).countArticlesInPolish(\"Guardian\");\n+        \n+        Mockito.verifyNoMoreInteractions(mockCalculator);\n+    }\n+    \n+    @Test\n+    public void managerSavesArticlesInTheDatabase() {\n+        ArticleCalculator mockCalculator = Mockito.mock(ArticleCalculator.class);\n+        ArticleDatabase mockDatabase = Mockito.mock(ArticleDatabase.class);\n+        \n+        ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n+\n+        articleManager.updateArticleCounters(\"Guardian\");\n+\n+        Mockito.verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 0);\n+        Mockito.verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 0);\n+        Mockito.verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 0);\n+        \n+        Mockito.verifyNoMoreInteractions(mockDatabase);\n+    }\n+}", "timestamp": 1195122595, "metainfo": ""}