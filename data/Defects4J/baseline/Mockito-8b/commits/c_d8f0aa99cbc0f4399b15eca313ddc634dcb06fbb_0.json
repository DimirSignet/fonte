{"sha": "d8f0aa99cbc0f4399b15eca313ddc634dcb06fbb", "log": "Almost there, now can resolve most TypeVariables declaration, certainly not exhaustive  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n+++ b/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n import org.mockito.Incubating;\n import org.mockito.exceptions.base.MockitoException;\n \n-import java.lang.reflect.Method;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n+import java.lang.reflect.*;\n+import java.util.*;\n \n @Incubating\n public abstract class MockitoGenericMetadata {\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n-            GenericTypeInfo.logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"' }\");\n-        }\n-    }\n-\n-    protected void registerTypeVariablesOn(Class<?> clazz) {\n-        TypeVariable[] typeParameters = clazz.getTypeParameters();\n+            GenericTypeInfo.logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n+        }\n+    }\n+\n+    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n         for (TypeVariable typeParameter : typeParameters) {\n             contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n-            GenericTypeInfo.logger.log(\"For '\" + clazz.getCanonicalName() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+            GenericTypeInfo.logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n         }\n     }\n \n      */\n     public abstract Class<?> rawType();\n \n+\n+    /**\n+     * @return Returns extra interfaces if relevant, otherwise empty List.\n+     */\n+    public List<Type> extraInterfaces() {\n+        return Collections.emptyList();\n+    }\n+\n+\n+\n     /**\n      * @return Actual type arguments matching the type variables of the raw type represented by this {@link MockitoGenericMetadata} instance.\n      */\n     public Map<TypeVariable, Type> actualTypeArguments() {\n+        TypeVariable[] typeParameters = rawType().getTypeParameters();\n         LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n \n-        TypeVariable[] typeParameters = rawType().getTypeParameters();\n         for (TypeVariable typeParameter : typeParameters) {\n \n             Type actualType = getActualTypeArgumentFor(typeParameter);\n         if (genericReturnType instanceof Class) {\n             return new NotGenericReturnType(genericReturnType);\n         }\n-\n         if (genericReturnType instanceof ParameterizedType) {\n-            ParameterizedType returnType = (ParameterizedType) genericReturnType;\n-            return new ParameterizedReturnType(this, method);\n-        }\n-\n-        return new MethodGenericReturnTypeMockitoGenericMetadata(this, method);\n+            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n+        }\n+        if (genericReturnType instanceof TypeVariable) {\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n+        }\n+\n+        throw new IllegalStateException(\"ouch\");\n     }\n \n     /**\n         }\n \n         private void readActualTypeParametersOnDeclaringClass() {\n-            registerTypeVariablesOn(clazz);\n+            registerTypeParametersOn(clazz.getTypeParameters());\n             registerTypeVariablesOn(clazz.getGenericSuperclass());\n             for (Type genericInterface : clazz.getGenericInterfaces()) {\n                 registerTypeVariablesOn(genericInterface);\n \n \n     private static class ParameterizedReturnType extends MockitoGenericMetadata {\n-\n-\n         private final ParameterizedType parameterizedType;\n-        private final TypeVariable<Method>[] typeParameters;\n-\n-        public ParameterizedReturnType(MockitoGenericMetadata source, Method method) {\n-            parameterizedType = (ParameterizedType) method.getGenericReturnType();\n-            typeParameters = method.getTypeParameters();\n+        private final TypeVariable[] typeParameters;\n+\n+        public ParameterizedReturnType(MockitoGenericMetadata source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            this.typeParameters = typeParameters;\n             this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n \n             readTypeVariables();\n \n \n \n+    private static class TypeVariableReturnType extends MockitoGenericMetadata {\n+        private final TypeVariable typeVariable;\n+        private final TypeVariable[] typeParameters;\n+\n+\n+        public TypeVariableReturnType(MockitoGenericMetadata source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n+            this.typeParameters = typeParameters;\n+            this.typeVariable = typeVariable;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            for (Type type : typeVariable.getBounds()) {\n+                registerTypeVariablesOn(type);\n+            }\n+            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return extractRawTypeOf(typeVariable);\n+        }\n+\n+        private Class<?> extractRawTypeOf(Type type) {\n+            if (type instanceof Class) {\n+                return (Class<?>) type;\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) type).getRawType();\n+            }\n+            if (type instanceof BoundedType) {\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\n+            }\n+            if (type instanceof TypeVariable) {\n+                /*\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                on the class definition, such as such as List<E>.\n+                */\n+                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            throw new MockitoException(\"Raw extraction not managed for : '\" + type + \"'\");\n+        }\n+\n+        @Override\n+        public List<Type> extraInterfaces() {\n+            Type type = extractActualBoundedTypeOf(typeVariable);\n+            if (type instanceof BoundedType) {\n+                return Arrays.asList(((BoundedType) type).interfaceBounds());\n+            }\n+            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n+        }\n+\n+        private Type extractActualBoundedTypeOf(Type type) {\n+            if (type instanceof TypeVariable) {\n+                /*\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                on the class definition, such as such as List<E>.\n+                */\n+                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            if (type instanceof BoundedType) {\n+                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n+                if (!(actualFirstBound instanceof BoundedType)) {\n+                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n+                }\n+                return actualFirstBound;\n+            }\n+            return type; // irrelevant, we don't manage other types.\n+        }\n+    }\n+\n+\n+\n     private static class MethodGenericReturnTypeMockitoGenericMetadata extends MockitoGenericMetadata {\n+\n         private final TypeVariable<Method>[] typeParameters;\n \n         private final Type genericReturnType;\n             throw new MockitoException(\"Raw extraction not managed for : '\" + type + \"'\");\n         }\n \n-    }\n+\n+\n+    }\n+\n+\n+\n     private static class NotGenericReturnType extends MockitoGenericMetadata {\n+\n         private final Class<?> returnType;\n \n         public NotGenericReturnType(Type genericReturnType) {\n             returnType = (Class<?>) genericReturnType;\n         }\n-\n         @Override\n         public Class<?> rawType() {\n             return returnType;\n         }\n+\n     }\n }\n--- a/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n+++ b/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n         Set<Number> remove(Object key); // override with fixed ParameterizedType\n         List<? super Integer> returningWildcard();\n         K returningK();\n-        <O extends K> O paramTypeWithTypeParams();\n+        <O extends K> List<O> paramTypeWithTypeParams();\n+        <O extends K> O typeVarWithTypeParams();\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void typeVariable_return_type_of___returningK___resolved_to_Comparable_and_with_BoundedType() throws Exception {\n+    public void bounded_typeVariable_return_type_of___returningK___resolved_to_Comparable_and_with_BoundedType() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n-        BoundedType boundedType = (BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"T\");\n-        assertThat(boundedType.firstBound()); // use MockitoGenericMetadata ?\n-        fail(\"API design to do\");\n+        MockitoGenericMetadata extraInterface1 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface1.rawType()).isEqualTo(Cloneable.class);\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void paramType_return_type_of___returningWildcard___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+    public void paramType_with_wildcard_return_type_of___returningWildcard___resolved_to_List_and_type_argument_to_Integer() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningWildcard\", GenericsNest.class));\n \n         fail(\"TODO\");\n     }\n \n     @Test\n-    public void paramType_return_type_of___paramTypeWithTypeParams___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+    public void paramType_with_type_parameters_return_type_of___paramTypeWithTypeParams___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramTypeWithTypeParams\", GenericsNest.class));\n \n         fail(\"TODO\");\n+    }\n+\n+    @Test\n+    public void typeVariable_with_type_parameters_return_type_of___typeVarWithTypeParams___resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVarWithTypeParams\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        MockitoGenericMetadata extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n     }\n \n ", "timestamp": 1343133825, "metainfo": ""}