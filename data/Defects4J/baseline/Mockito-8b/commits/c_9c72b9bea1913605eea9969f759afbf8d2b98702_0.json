{"sha": "9c72b9bea1913605eea9969f759afbf8d2b98702", "log": "Tidied-up the tests and behavior  Changed the code so that we don't allow creating spies for interfaces (this is how it worked before recent changes, so it is a change that makes Mockito more backwards compatible). Tidied up tests and test names. Tightened test coverage.", "commit": "\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n \n /**\n  * Process fields annotated with &#64;Spy.\n- *\n+ * <p/>\n  * <p>\n  * Will try transform the field in a spy as with <code>Mockito.spy()</code>.\n  * </p>\n- *\n+ * <p/>\n  * <p>\n  * If the field is not initialized, will try to initialize it, with a no-arg constructor.\n  * </p>\n- *\n+ * <p/>\n  * <p>\n  * If the field is also annotated with the <strong>compatible</strong> &#64;InjectMocks then the field will be ignored,\n  * The injection engine will handle this specific case.\n  * </p>\n- *\n+ * <p/>\n  * <p>This engine will fail, if the field is also annotated with incompatible Mockito annotations.\n  */\n @SuppressWarnings({\"unchecked\"})\n                 Object instance;\n                 try {\n                     instance = field.get(testInstance);\n+                    assertNotInterface(instance, field.getType());\n                     if (new MockUtil().isMock(instance)) {\n                         // instance has been spied earlier\n                         // for example happens when MockitoAnnotations.initMocks is called two times.\n                     } else {\n                         field.set(testInstance, newSpyInstance(testInstance, field));\n                     }\n-                } catch (MockitoException e) {\n-                    throw e;\n                 } catch (Exception e) {\n-                    throw new MockitoException(\"Problems initiating @Spy annotated field '\" + field.getName() + \"'\", e);\n+                    throw new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName() + \"'.\\n\" + e.getMessage(), e);\n                 }\n             }\n         }\n     }\n-  \n+\n+    private static void assertNotInterface(Object testInstance, Class<?> type) {\n+        type = testInstance != null? testInstance.getClass() : type;\n+        if (type.isInterface()) {\n+            throw new MockitoException(\"Type '\" + type.getSimpleName() + \"' is an interface and it cannot be spied on.\");\n+        }\n+    }\n+\n     private static Object newSpyInstance(Object testInstance, Field field)\n-    \t\tthrows InstantiationException, IllegalAccessException, InvocationTargetException {\n-    \tMockSettings settings = withSettings()\n-    \t\t\t.defaultAnswer(Mockito.CALLS_REAL_METHODS)\n-    \t\t\t.name(field.getName());\n-    \tClass<?> type = field.getType();\n-    \tif (type.isInterface()) {\n-    \t\treturn Mockito.mock(type,settings.useConstructor());\n-    \t}\n-    \ttry {\n-\t    \tif (!Modifier.isStatic(type.getModifiers())) {\n-\t        \tClass<?> enclosing = type.getEnclosingClass();\n-\t        \tif (enclosing != null) {\n-\t        \t\tif (!enclosing.isInstance(testInstance)) {\n-\t        \t\t\tthrow new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName() + \"'.\"\n-                                + \"\\nIf you are mocking an inner class please ensure the instance of the outer class is supplied via withSettings().outerInstance()\"\n-                                + \"\\nThe outer class is: '\" + enclosing.getSimpleName() + \"'\");\n-\t        \t\t}\n-                    //TODO SF find out if it is useful\n+            throws InstantiationException, IllegalAccessException, InvocationTargetException {\n+        MockSettings settings = withSettings()\n+                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n+                .name(field.getName());\n+        Class<?> type = field.getType();\n+        if (type.isInterface()) {\n+            return Mockito.mock(type, settings.useConstructor());\n+        }\n+        if (!Modifier.isStatic(type.getModifiers())) {\n+            Class<?> enclosing = type.getEnclosingClass();\n+            if (enclosing != null) {\n+                if (!enclosing.isInstance(testInstance)) {\n+                    throw new MockitoException(\"If you are mocking an inner class please ensure the instance of the outer class is supplied via withSettings().outerInstance()\"\n+                            + \"\\nThe outer class is: '\" + enclosing.getSimpleName() + \"'\");\n+                }\n+                //TODO SF find out if it is useful\n //\t        \t\tif (Modifier.isPrivate(type.getDeclaredConstructor(enclosing).getModifiers())) {\n //                        throw new AssertionError();\n //\t        \t\t\tthrow new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName() + \"'. \"\n //                                + \"Cannot spy inner type '\" + type.getSimpleName() + \"' because it has private constructor.\");\n //\t        \t\t}\n-\t        \t\treturn Mockito.mock(type, settings\n-\t        \t\t\t\t.useConstructor()\n-\t        \t\t\t\t.outerInstance(testInstance));\n-\t        \t}\n-\t    \t}\n-\t    \tConstructor<?> constructor = type.getDeclaredConstructor();\n-\t    \tif (Modifier.isPrivate(constructor.getModifiers())) {\n-\t    \t\tconstructor.setAccessible(true);\n-\t    \t\treturn Mockito.mock(type, settings\n-\t    \t\t\t\t.spiedInstance(constructor.newInstance()));\n-\t    \t} else {\n-\t    \t\treturn Mockito.mock(type, settings.useConstructor());\n-\t    \t}\n-    \t} catch (NoSuchMethodException noDefaultConstructor) {\n-    \t\tthrow new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName()\n-                    + \"'. Please ensure that the type '\" + type.getSimpleName()  + \"' has 0-arg constructor.\");\n-    \t}\n+                return Mockito.mock(type, settings\n+                        .useConstructor()\n+                        .outerInstance(testInstance));\n+            }\n+        }\n+        Constructor<?> constructor;\n+        try {\n+            constructor = type.getDeclaredConstructor();\n+        } catch (NoSuchMethodException e) {\n+            throw new MockitoException(\"Please ensure that the type '\" + type.getSimpleName() + \"' has 0-arg constructor.\");\n+        }\n+\n+        if (Modifier.isPrivate(constructor.getModifiers())) {\n+            constructor.setAccessible(true);\n+            return Mockito.mock(type, settings\n+                    .spiedInstance(constructor.newInstance()));\n+        } else {\n+            return Mockito.mock(type, settings.useConstructor());\n+        }\n     }\n-    \n+\n     //TODO duplicated elsewhere\n     void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n         for (Class u : undesiredAnnotations) {\n             if (field.isAnnotationPresent(u)) {\n                 new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n             }\n-        }        \n-    }    \n+        }\n+    }\n }\n--- a/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n+++ b/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\n     }\n \n     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {\n-        return new InstantationException(\"Unable to create mock instance of '\"\n-                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e);\n+        return new InstantationException(\"Unable to create instance of '\"\n+                + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has 0-arg constructor.\", e);\n     }\n \n     private static boolean paramsMatch(Class<?>[] types, Object[] params) {\n     private static <T> T noArgConstructor(Class<T> cls) {\n         try {\n             return cls.newInstance();\n-        } catch (Exception e) {\n-            throw new InstantationException(\"Unable to create mock instance of '\"\n-                    + cls.getSimpleName() + \"'.\\nPlease ensure it has parameter-less constructor.\", e);\n+        } catch (Throwable t) {\n+            throw new InstantationException(\"Unable to create instance of '\"\n+                    + cls.getSimpleName() + \"'.\\nPlease ensure it has 0-arg constructor which invokes cleanly.\", t);\n         }\n     }\n }\n--- a/src/org/mockito/internal/creation/instance/InstantationException.java\n+++ b/src/org/mockito/internal/creation/instance/InstantationException.java\n package org.mockito.internal.creation.instance;\n \n-public class InstantationException extends RuntimeException {\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class InstantationException extends MockitoException {\n \n     public InstantationException(String message, Throwable cause) {\n         super(message, cause);\n--- a/test/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java\n+++ b/test/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java\n             fail();\n         } catch (InstantationException e) {\n             assertEquals(\"Unable to create mock instance of 'SomeClass2'.\\n\" +\n-                    \"Please ensure it has parameter-less constructor.\", e.getMessage());\n+                    \"Please ensure it has 0-arg constructor which invokes cleanly.\", e.getMessage());\n         }\n     }\n }\n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n \n-import java.util.AbstractList;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.*;\n \n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.*;\n \n @SuppressWarnings({\"unchecked\", \"unused\"})\n public class SpyAnnotationTest extends TestBase {\n     @Rule public final ExpectedException shouldThrow = ExpectedException.none();\n \n \t@Test\n-    public void shouldInitSpies() throws Exception {\n+    public void should_init_spy_by_instance() throws Exception {\n         doReturn(\"foo\").when(spiedList).get(10);\n-\n         assertEquals(\"foo\", spiedList.get(10));\n         assertTrue(spiedList.isEmpty());\n     }\n \n     @Test\n-    public void shouldInitSpyIfNestedStaticClass() throws Exception {\n-\t\tassertNotNull(staticTypeWithNoArgConstructor);\n-\t\tassertNotNull(staticTypeWithoutDefinedConstructor);\n+    public void should_init_spy_and_automatically_create_instance() throws Exception {\n+        when(staticTypeWithNoArgConstructor.toString()).thenReturn(\"x\");\n+        when(staticTypeWithoutDefinedConstructor.toString()).thenReturn(\"y\");\n+        assertEquals(\"x\", staticTypeWithNoArgConstructor.toString());\n+        assertEquals(\"y\", staticTypeWithoutDefinedConstructor.toString());\n     }\n \n     @Test\n-    public void spyInterface() throws Exception {\n+    public void should_prevent_spying_on_interfaces() throws Exception {\n \t\tclass WithSpy {\n \t\t\t@Spy List<String> list;\n \t\t}\n \n \t\tWithSpy withSpy = new WithSpy();\n-        MockitoAnnotations.initMocks(withSpy);\n-        assertEquals(0, withSpy.list.size());\n-        //TODO SF prevent\n+        try {\n+            MockitoAnnotations.initMocks(withSpy);\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"is an interface and it cannot be spied on\");\n+        }\n     }\n \n     @Test\n-    public void shouldReportWhenNoArgConstructor() throws Exception {\n+    public void should_allow_spying_on_interfaces_when_instance_is_concrete() throws Exception {\n+        class WithSpy {\n+            @Spy List<String> list = new LinkedList<String>();\n+        }\n+\n+        WithSpy withSpy = new WithSpy();\n+        //when\n+        MockitoAnnotations.initMocks(withSpy);\n+\n+        //then\n+        verify(withSpy.list, never()).clear();\n+    }\n+\n+    @Test\n+    public void should_report_when_no_arg_less_constructor() throws Exception {\n \t\tclass FailingSpy {\n \t        @Spy\n             NoValidConstructor noValidConstructor;\n     }\n     \n     @Test\n-    public void shouldReportWhenConstructorThrows() throws Exception {\n+    public void should_report_when_constructor_is_explosive() throws Exception {\n \t\tclass FailingSpy {\n \t        @Spy\n             ThrowingConstructor throwingConstructor;\n     }\n \n     @Test\n-    public void spyAbstractClass() throws Exception {\n+    public void should_spy_abstract_class() throws Exception {\n \t\tclass SpyAbstractClass {\n \t\t\t@Spy AbstractList<String> list;\n \t\t\t\n     }\n \n     @Test\n-    public void spyInnerClass() throws Exception {\n+    public void should_spy_inner_class() throws Exception {\n     \t \n      class WithMockAndSpy {\n     \t\t@Spy private InnerStrength strength;\n     }\n \n \t@Test(expected = IndexOutOfBoundsException.class)\n-    public void shouldResetSpies() throws Exception {\n+    public void should_reset_spy() throws Exception {\n         spiedList.get(10); // see shouldInitSpy\n     }\n \n \t@Test\n-\tpublic void shouldReportWhenInnerClassNotEnclosedByTestInstance() throws Exception {\n+\tpublic void should_report_when_encosing_instance_is_needed() throws Exception {\n \t\tclass Outer {\n \t\t\tclass Inner {}\n \t\t}\n--- a/test/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java\n+++ b/test/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java\n package org.mockitousage.constructor;\n-\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.mock.SerializableMode;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n \n import static org.mockito.Mockito.*;\n \n             fail();\n         } catch (MockitoException e) {\n             assertEquals(\"Unable to create mock instance of type 'HasConstructor'\", e.getMessage());\n-            assertContains(\"Please ensure it has parameter-less constructor\", e.getCause().getMessage());\n+            assertContains(\"0-arg constructor\", e.getCause().getMessage());\n         }\n     }\n \n             fail();\n         } catch (MockitoException e) {\n             assertEquals(\"Unable to create mock instance of type 'InnerClass'\", e.getMessage());\n-            assertContains(\"Please ensure that the outer instance has correct type and that the target class has parameter-less constructor\", e.getCause().getMessage());\n+            assertContains(\"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.\", e.getCause().getMessage());\n         }\n     }\n ", "timestamp": 1417513678, "metainfo": ""}