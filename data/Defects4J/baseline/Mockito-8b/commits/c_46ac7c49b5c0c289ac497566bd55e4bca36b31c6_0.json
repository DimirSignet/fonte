{"sha": "46ac7c49b5c0c289ac497566bd55e4bca36b31c6", "log": "first hacky implementation of strict order checking 8-)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4074", "commit": "\n--- a/src/org/mockito/Strictly.java\n+++ b/src/org/mockito/Strictly.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n+\n+import org.mockito.internal.VerifyingMode;\n \n public interface Strictly {\n \n     //TODO get rid of interface with int\n     <T> T verify(T mock, int expectedNumberOfInvocations);\n     \n+    <T> T verify(T mock, VerifyingMode verifyingMode);\n+    \n }\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n \n     private static final long serialVersionUID = 1L;\n \n-    public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked, ExpectedInvocation invocation) {\n+    public NumberOfInvocationsAssertionError(int expectedCount, int actualCount, ExpectedInvocation expected) {\n         super(  \"\\n\" +\n-                invocation.toString() +\n+                expected.toString() +\n         \t\t\"\\n\" +\n-        \t\t\"Expected \" + pluralize(expectedInvoked) + \" but was \" + actuallyInvoked);\n+        \t\t\"Expected \" + pluralize(expectedCount) + \" but was \" + actualCount);\n     }\n \n     private static String pluralize(int expectedInvoked) {\n--- a/src/org/mockito/exceptions/StrictVerificationError.java\n+++ b/src/org/mockito/exceptions/StrictVerificationError.java\n     public StrictVerificationError() {\n         super(\"blah\");\n     }\n+\n+    public StrictVerificationError(String string) {\n+        super(string);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationChunk.java\n+package org.mockito.internal;\n+\n+import java.util.*;\n+\n+public class InvocationChunk {\n+\n+    private final List<Invocation> invocations = new LinkedList<Invocation>();\n+\n+    public InvocationChunk(Invocation invocation) {\n+        invocations.add(invocation);\n+    }\n+    \n+    public Invocation getInvocation() {\n+        return invocations.get(0);\n+    }\n+\n+    public boolean isVerified() {\n+        return getInvocation().isVerified();\n+    }\n+\n+    public int getCount() {\n+        return invocations.size();\n+    }\n+\n+    public void add(Invocation invocation) {\n+        invocations.add(invocation);\n+    }\n+    \n+    public String toString() {\n+        return getInvocation() + \" x \" + getCount();\n+    }\n+\n+    public void markAllInvocationsAsVerified() {\n+        for (Invocation invocation : invocations) {\n+            invocation.markVerified();\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n         markInvocationsAsVerified(expected, verifyingMode);\n     }\n     \n-    void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        int verifiedSoFar = 0;        \n-        for (Invocation invocation : registeredInvocations) {\n-            boolean shouldMarkAsVerified = \n-                verifyingMode.atLeastOnceMode() || \n-                verifyingMode.getExpectedNumberOfInvocations() > verifiedSoFar;\n-            if (expected.matches(invocation) && shouldMarkAsVerified) {\n-                invocation.markVerified();\n-                verifiedSoFar++;\n+    void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode mode) {\n+        if (mode.expectedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (mode.orderOfInvocationsMatters()) {\n+            List<InvocationChunk> chunks = getUnverifiedInvocationChunks(mode);\n+            chunks.get(0).markAllInvocationsAsVerified();\n+        } else {\n+            for (Invocation invocation : registeredInvocations) {\n+                if (expected.matches(invocation)) {\n+                    invocation.markVerified();\n+                }\n             }\n         }\n     }\n \n     private void checkForMissingInvocation(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        int actuallyInvoked = numberOfActualInvocations(expected);\n-        Integer expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n+        int actualCount = numberOfActualInvocations(expected);\n+        Integer expectedCount = verifyingMode.expectedCount();\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n                \n-        if ((atLeastOnce || expectedInvoked == 1) && actuallyInvoked == 0) {\n+        if ((atLeastOnce || expectedCount == 1) && actualCount == 0) {\n             reportMissingInvocationError(expected);\n         }\n     }\n \n-    private void checkForWrongNumberOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) throws NumberOfInvocationsAssertionError {\n+    void checkForWrongNumberOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) throws NumberOfInvocationsAssertionError {\n+        if (verifyingMode.orderOfInvocationsMatters()) {\n+            return;\n+        }\n+        \n         int actuallyInvoked = numberOfActualInvocations(expected);\n-        Integer expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n+        Integer expectedInvoked = verifyingMode.expectedCount();\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n         \n         if (!atLeastOnce && actuallyInvoked != expectedInvoked) {\n         throw new VerificationAssertionError(message);\n     }\n \n-    private void checkOrderOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n-        if (!verifyingMode.orderOfInvocationsMatters()) {\n-            return;\n-        }\n-        \n-        Map<Invocation, Integer> sequenceOfInvocations = getSequenceOfInvocations(verifyingMode);\n-        Invocation firstUnverifiedInvocation = null;\n-        for (Invocation registered : sequenceOfInvocations.keySet()) {\n-            if (!registered.isVerified()) {\n-                firstUnverifiedInvocation = registered;\n-            } else {\n-                break;\n-            }\n-        }\n-        //TODO cover this scenario firstUnverified == null\n-        assert firstUnverifiedInvocation != null;\n-        \n-        if (!expected.matches(firstUnverifiedInvocation)) {\n-            throw new StrictVerificationError();\n-        }\n-    }\n-\n-    private Map<Invocation, Integer> getSequenceOfInvocations(VerifyingMode verifyingMode) {\n+    private void checkOrderOfInvocations(ExpectedInvocation expected, VerifyingMode mode) {\n+        if (!mode.orderOfInvocationsMatters()) {\n+            return;\n+        }\n+        \n+        List<InvocationChunk> chunks = getUnverifiedInvocationChunks(mode);\n+        \n+        if (mode.expectedCountIsZero() && !chunks.isEmpty() && expected.matches(chunks.get(0).getInvocation())) {\n+            throw new NumberOfInvocationsAssertionError(0, chunks.get(0).getCount(), expected);\n+        } else if (mode.expectedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (chunks.isEmpty()) {\n+            throw new StrictVerificationError(\"everything was already verified\");\n+        }\n+        \n+        if (!expected.matches(chunks.get(0).getInvocation())) {\n+            throw new StrictVerificationError(\"this is not expected here\");\n+        }\n+        \n+        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.expectedCount()) {\n+            throw new NumberOfInvocationsAssertionError(mode.expectedCount(), chunks.get(0).getCount(), expected);\n+        }\n+    }\n+\n+    private List<InvocationChunk> getUnverifiedInvocationChunks(VerifyingMode verifyingMode) {\n         Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n                 new Comparator<Invocation>(){\n                     public int compare(Invocation o1, Invocation o2) {\n             allInvocationsInOrder.addAll(invocations);\n         }\n         \n-        Map<Invocation, Integer> sequenceOfInvocations = new LinkedHashMap<Invocation, Integer>();\n+        List<InvocationChunk> chunks = new LinkedList<InvocationChunk>();\n         for (Invocation i : allInvocationsInOrder) {\n-            if (sequenceOfInvocations.containsKey(i)) {\n-                int currentCount = sequenceOfInvocations.get(i).intValue();\n-                sequenceOfInvocations.put(i, currentCount + 1);\n+            if (i.isVerified()) {\n+                continue;\n+            }\n+            if (!chunks.isEmpty() \n+                    && chunks.get(chunks.size()-1).getInvocation().equals(i)) {\n+                chunks.get(chunks.size()-1).add(i);\n             } else {\n-                sequenceOfInvocations.put(i, 1);\n-            }\n-        }\n-        \n-        return sequenceOfInvocations;\n+                chunks.add(new InvocationChunk(i));\n+            }\n+        }\n+        \n+        return chunks;\n     }\n \n     /**\n--- a/src/org/mockito/internal/StrictOrderVerifier.java\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n     public <T> T verify(T mock, int expectedNumberOfInvocations) {\n         return Mockito.verify(mock, VerifyingMode.inOrder(expectedNumberOfInvocations, mocksToBeVerifiedInOrder));\n     }\n+    \n+    public <T> T verify(T mock, VerifyingMode verifyingMode) {\n+        return Mockito.verify(mock, VerifyingMode.inOrder(verifyingMode.expectedCount(), mocksToBeVerifiedInOrder));\n+    }\n \n     public void verifyNoMoreInteractions() {\n         Mockito.verifyNoMoreInteractions(mocksToBeVerifiedInOrder.toArray());\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n \n public class VerifyingMode {\n \n-    private final Integer expectedNumberOfInvocations;\n+    private final Integer expectedInvocationCount;\n     private final List<Object> mocksToBeVerifiedInSequence;\n \n     private VerifyingMode(Integer expectedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n         if (expectedNumberOfInvocations != null && expectedNumberOfInvocations.intValue() < 0) {\n             throw new MockitoException(\"Negative value is not allowed here\");\n         }\n-        this.expectedNumberOfInvocations = expectedNumberOfInvocations;\n+        this.expectedInvocationCount = expectedNumberOfInvocations;\n         this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n     }\n     \n     }\n \n     boolean atLeastOnceMode() {\n-        return expectedNumberOfInvocations == null;\n+        return expectedInvocationCount == null;\n     }\n \n-    Integer getExpectedNumberOfInvocations() {\n-        return expectedNumberOfInvocations;\n+    Integer expectedCount() {\n+        return expectedInvocationCount;\n     }\n \n     List<Object> getAllMocksToBeVerifiedInSequence() {\n     boolean orderOfInvocationsMatters() {\n         return !mocksToBeVerifiedInSequence.isEmpty();\n     }\n+\n+    public boolean expectedCountIsZero() {\n+        return expectedInvocationCount != null && expectedInvocationCount == 0;\n+    }\n }\n--- a/test/org/mockito/internal/MockitoBehaviorTest.java\n+++ b/test/org/mockito/internal/MockitoBehaviorTest.java\n package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n \n import java.lang.reflect.Method;\n import java.util.*;\n \n import org.junit.*;\n-import static org.junit.Assert.*;\n+import org.mockito.exceptions.NumberOfInvocationsAssertionError;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoBehaviorTest {\n         behavior.addInvocation(toLowerCaseInvocationThree);\n     }\n     \n-    @Test\n-    public void shouldMarkTwoInvocationsAsVerified() throws Exception {\n-        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(2));\n-        \n-        List<Invocation> invocations = behavior.getRegisteredInvocations();\n-        assertEquals(true, invocations.get(0).isVerified());\n-        assertEquals(true, invocations.get(1).isVerified());\n-        assertEquals(false, invocations.get(2).isVerified());\n-        assertEquals(false, invocations.get(3).isVerified());\n-    }\n+    //TODO use some of this test to create test for invocationsChunker\n     \n     @Test\n-    public void shouldMarkAllThreeInvocationsAsVerified() throws Exception {\n-        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(3));\n+    public void shouldMarkAllInvocationsAsVerified() throws Exception {\n+        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(2));\n         \n         List<Invocation> invocations = behavior.getRegisteredInvocations();\n         assertEquals(true, invocations.get(0).isVerified());\n         assertEquals(false, invocations.get(2).isVerified());\n         assertEquals(true, invocations.get(3).isVerified());\n     }\n+    \n+    @Test\n+    public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n+        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(0));\n+        \n+        List<Invocation> invocations = behavior.getRegisteredInvocations();\n+        assertEquals(false, invocations.get(0).isVerified());\n+        assertEquals(false, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n+        try {\n+            behavior.checkForWrongNumberOfInvocations(toLowerCaseInvocation, VerifyingMode.inOrder(1, Arrays.asList(new Object())));\n+        } catch (NumberOfInvocationsAssertionError e) {\n+            fail();\n+        }\n+    }\n }\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n         mockOne.simpleMethod(4);\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldVerifyInOrder() {\n-        verify(mockOne).simpleMethod(1);\n-        verify(mockTwo, 2).simpleMethod(2);\n-        verify(mockThree).simpleMethod(3);\n-        verify(mockTwo).simpleMethod(2);\n-        verify(mockOne).simpleMethod(4);\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n     } \n     \n-    @Ignore\n     @Test\n     public void shouldVerifyInOrderUsingAtLeastOnce() {\n-        verify(mockOne, atLeastOnce()).simpleMethod(1);\n-        verify(mockTwo, atLeastOnce()).simpleMethod(2);\n-        verify(mockThree).simpleMethod(3);\n-        verify(mockTwo).simpleMethod(2);\n-        verify(mockOne, atLeastOnce()).simpleMethod(4);\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(4);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n     } \n     \n-    @Ignore\n-    @Test\n-    public void shouldVerifyInOrderWhenExpectedEqualsZero() {\n-        verify(mockOne, 0).oneArg(false);\n-        verify(mockOne).simpleMethod(1);\n-        verify(mockTwo, 2).simpleMethod(2);\n-        verify(mockThree).simpleMethod(3);\n-        verify(mockTwo).simpleMethod(2);\n-        verify(mockOne).simpleMethod(4);\n-        verify(mockThree, 0).oneArg(false);\n+    @Test\n+    public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n+        strictly.verify(mockOne, 0).oneArg(false);\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        strictly.verify(mockThree, 0).oneArg(false);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n     } \n     \n-    @Ignore\n-    @Test\n-    public void shouldFailBecauseMethodWasInvokedTwice() {\n-        verify(mockOne).simpleMethod(1);\n-        try {\n-            verify(mockTwo).simpleMethod(2);\n-            fail();\n-        } catch (NumberOfInvocationsAssertionError e) {}\n-    }\n-\n-    @Ignore\n-    @Test(expected = VerificationAssertionError.class)\n-    public void shouldFailOnWrongStartWithWrongArguments() {\n+    @Test\n+    public void shouldFailWhenFirstMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(1);\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test(expected=NumberOfInvocationsAssertionError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationExpected() {\n+        strictly.verify(mockOne, 0).simpleMethod(1);\n+    }\n+    \n+    @Test(expected=NumberOfInvocationsAssertionError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationExpectedAgain() {\n+        strictly.verify(mockOne, 2).simpleMethod(1);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsExpected() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 3).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsExpectedAgain() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 0).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationExpected() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, 0).simpleMethod(4);\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationExpectedAgain() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, 2).simpleMethod(4);\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {}\n+    }    \n+    \n+    /* ------------- */\n+    \n+    @Test(expected=VerificationAssertionError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentArgsExpected() {\n         strictly.verify(mockOne).simpleMethod(100);\n     }\n     \n-    @Ignore\n-    @Test(expected = NumberOfInvocationsAssertionError.class)\n-    public void shouldFailOnStartWithWrongMethod() {\n+    @Test(expected=VerificationAssertionError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentMethodExpected() {\n         strictly.verify(mockOne).oneArg(true);\n     }\n     \n-    @Ignore\n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentArgsExpected() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 2).simpleMethod(-999);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+        //TODO those guys need tests around nice messages from exceptions and it's quite inconsistent\n+        //when StrictVerificationError and when VerificationAssertionError is fired\n+        //algorithm should be as follows:\n+        //  1. check if according to order: mock and method matches -> StrictVerificationError\n+        //  2. check method arguments -> VerificationAssertionError\n+        //  3. check invocation count -> NumberOfInvocationsAssertionError\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentMethodExpected() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 2).oneArg(true);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentArgsExpected() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(-666);\n+            fail();\n+        } catch (VerificationAssertionError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentMethodExpected() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).oneArg(false);\n+            fail();\n+        } catch (VerificationAssertionError e) {}\n+    }    \n+    \n+    /* -------------- */\n+    \n     @Test(expected = StrictVerificationError.class)\n     public void shouldFailWhenLastMethodCalledFirst() {\n         strictly.verify(mockOne).simpleMethod(4);\n     }\n     \n-    @Ignore\n     @Test(expected = StrictVerificationError.class)\n     public void shouldFailWhenSecondMethodCalledFirst() {\n         strictly.verify(mockTwo, 2).simpleMethod(2);\n     }\n     \n-//    @Test\n-//    public void shouldFailOnWrongOrder() {\n-//        strictly.verify(list, 1).add(\"one\");\n-//        strictly.verify(map).put(\"two\", \"two\");\n-//        try {\n-//            strictly.verify(map).put(\"five\", \"five\");\n-//            fail();\n-//        } catch (StrictVerificationError e) {}\n-//    }\n-//    \n-//    @Test\n-//    public void shouldFailOnWrongOrderWhenCheckingExpectedNumberOfInvocations() {\n-//        strictly.verify(list, 1).add(\"one\");\n-//        strictly.verify(map).put(\"two\", \"two\");\n-//        try {\n-//            strictly.verify(map, 1).put(\"five\", \"five\");\n-//            fail();\n-//        } catch (StrictVerificationError e) {}\n-//    }\n-//    \n-//    @Test\n-//    public void shouldFailWhenPriorVerificationCalledAgain() {\n-//        strictly.verify(list, 1).add(\"one\");\n-//        strictly.verify(map).put(\"two\", \"two\");\n-//        strictly.verify(list, 2).add(\"three and four\");\n-//        try {\n-//            strictly.verify(list, 1).add(\"one\");\n-//            fail();\n-//        } catch (StrictVerificationError e) {}\n-//    }\n-//    \n-//    @Test\n-//    public void shouldFailOnVerifyNoMoreInteractions() {\n-//        strictly.verify(list).add(\"one\");\n-//        strictly.verify(map).put(\"two\", \"two\");\n-//        strictly.verify(list, 2).add(\"three and four\");\n-//        strictly.verify(map).put(\"five\", \"five\");\n-//        try {\n-//            verifyNoMoreInteractions(list, map, set);\n-//            fail();\n-//        } catch (VerificationAssertionError e) {}\n-//    } \n-//    \n-//    @Test\n-//    public void shouldFailWhenLastMethodDontMatch() {\n-//        strictly.verify(list).add(\"one\");\n-//        strictly.verify(map).put(\"two\", \"two\");\n-//        strictly.verify(list, 2).add(\"three and four\");\n-//        strictly.verify(map).put(\"five\", \"five\");\n-//        try {\n-//            strictly.verify(set).add(\"not six but something else\");\n-//            fail();\n-//        } catch (VerificationAssertionError e) {}\n-//    }\n-//    \n-//    @Test(expected = VerificationAssertionError.class)\n-//    public void shouldFailOnVerifyZeroInteractions() {\n-//        verifyZeroInteractions(list, map, set);\n-//    } \n+    @Test\n+    public void shouldFailWhenLastMethodCalledToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoIsToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        try {\n+            strictly.verify(mockTwo, 1).simpleMethod(2);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockIsToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnVerifyNoMoreInteractions() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationAssertionError e) {}\n+    } \n+    \n+    @Test(expected=VerificationAssertionError.class)\n+    public void shouldFailOnVerifyZeroInteractions() {\n+        verifyZeroInteractions(mockOne);\n+    }\n }", "timestamp": 1196118242, "metainfo": ""}