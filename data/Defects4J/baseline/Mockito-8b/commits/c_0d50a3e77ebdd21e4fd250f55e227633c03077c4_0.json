{"sha": "0d50a3e77ebdd21e4fd250f55e227633c03077c4", "log": "Tidy-up, removed some duplication", "commit": "\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.configuration;\n-\n-import static org.mockito.Mockito.withSettings;\n+package org.mockito.internal.configuration;\n+\n+import org.mockito.*;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n \n-import org.mockito.Captor;\n-import org.mockito.InjectMocks;\n-import org.mockito.Mock;\n-import org.mockito.MockSettings;\n-import org.mockito.Mockito;\n-import org.mockito.Spy;\n-import org.mockito.configuration.AnnotationEngine;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.MockUtil;\n-\n-/**\n- * Process fields annotated with &#64;Spy.\n- *\n- * <p>\n- * Will try transform the field in a spy as with <code>Mockito.spy()</code>.\n- * </p>\n- *\n- * <p>\n- * If the field is not initialized, will try to initialize it, with a no-arg constructor.\n- * </p>\n- *\n- * <p>\n- * If the field is also annotated with the <strong>compatible</strong> &#64;InjectMocks then the field will be ignored,\n- * The injection engine will handle this specific case.\n- * </p>\n- *\n- * <p>This engine will fail, if the field is also annotated with incompatible Mockito annotations.\n- */\n-@SuppressWarnings({\"unchecked\"})\n-public class SpyAnnotationEngine implements AnnotationEngine {\n-\n-    public Object createMockFor(Annotation annotation, Field field) {\n-        return null;\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n-    public void process(Class<?> context, Object testInstance) {\n-        Field[] fields = context.getDeclaredFields();\n-        for (Field field : fields) {\n-            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n+import static org.mockito.Mockito.withSettings;\n+\n+/**\n+ * Process fields annotated with &#64;Spy.\n+ *\n+ * <p>\n+ * Will try transform the field in a spy as with <code>Mockito.spy()</code>.\n+ * </p>\n+ *\n+ * <p>\n+ * If the field is not initialized, will try to initialize it, with a no-arg constructor.\n+ * </p>\n+ *\n+ * <p>\n+ * If the field is also annotated with the <strong>compatible</strong> &#64;InjectMocks then the field will be ignored,\n+ * The injection engine will handle this specific case.\n+ * </p>\n+ *\n+ * <p>This engine will fail, if the field is also annotated with incompatible Mockito annotations.\n+ */\n+@SuppressWarnings({\"unchecked\"})\n+public class SpyAnnotationEngine implements AnnotationEngine {\n+\n+    public Object createMockFor(Annotation annotation, Field field) {\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n+    public void process(Class<?> context, Object testInstance) {\n+        Field[] fields = context.getDeclaredFields();\n+        for (Field field : fields) {\n+            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n                 assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n-                field.setAccessible(true);\n-                Object instance = null;\n-                try {\n-                    instance = field.get(testInstance);\n-                    if (new MockUtil().isMock(instance)) {\n-                        // instance has been spied earlier\n-                        // for example happens when MockitoAnnotations.initMocks is called two times.\n-                        Mockito.reset(instance);\n-                    } else if (instance != null) {\n-                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n-                                .spiedInstance(instance)\n-                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n-                                .name(field.getName())));\n+                field.setAccessible(true);\n+                Object instance;\n+                try {\n+                    instance = field.get(testInstance);\n+                    if (new MockUtil().isMock(instance)) {\n+                        // instance has been spied earlier\n+                        // for example happens when MockitoAnnotations.initMocks is called two times.\n+                        Mockito.reset(instance);\n+                    } else if (instance != null) {\n+                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n+                                .spiedInstance(instance)\n+                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n+                                .name(field.getName())));\n                     } else {\n                     \tfield.set(testInstance, newSpyInstance(testInstance, field));\n-                    }\n-                } catch (IllegalAccessException e) {\n-                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n-                } catch (InstantiationException e) {\n-                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n-                } catch (InvocationTargetException e) {\n-                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n-                }\n-            }\n-        }\n+                    }\n+                } catch (Exception e) {\n+                    throw new MockitoException(\"Problems initiating @Spy annotated field '\" + field.getName() + \"'\", e);\n+                }\n+            }\n+        }\n     }\n   \n     private static Object newSpyInstance(Object testInstance, Field field)\n     \t} catch (NoSuchMethodException noDefaultConstructor) {\n     \t\tthrow new MockitoException(\"0-arg constructor is required to spy \" + type);\n     \t}\n-    }\n-    \n-    //TODO duplicated elsewhere\n-    void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n-        for (Class u : undesiredAnnotations) {\n-            if (field.isAnnotationPresent(u)) {\n-                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n-            }\n-        }        \n-    }    \n-}\n+    }\n+    \n+    //TODO duplicated elsewhere\n+    void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n+        for (Class u : undesiredAnnotations) {\n+            if (field.isAnnotationPresent(u)) {\n+                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n+            }\n+        }        \n+    }    \n+}", "timestamp": 1417513677, "metainfo": ""}