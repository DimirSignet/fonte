{"sha": "377de51ddf90e01c50646f34e353bbf01844c677", "log": "issue 238 : reworked inject mocks engine to allow constructor injection, constructor injection is still a work in progress  --HG-- branch : issue 238 : constructor injection rename : src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java rename : src/org/mockito/internal/configuration/injection/MockCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java rename : src/org/mockito/internal/configuration/injection/NameBasedCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java rename : src/org/mockito/internal/configuration/injection/OngoingInjecter.java => src/org/mockito/internal/configuration/injection/filter/OngoingInjecter.java rename : src/org/mockito/internal/configuration/injection/TypeBasedCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java rename : src/org/mockito/internal/util/reflection/ConstructorInitializer.java => src/org/mockito/internal/util/reflection/FieldConstructorInitializer.java", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n  */\n package org.mockito.exceptions;\n \n-import static org.mockito.exceptions.Pluralizer.pluralize;\n-import static org.mockito.internal.util.StringJoiner.join;\n-\n-import java.util.List;\n-\n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.*;\n-import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n-import org.mockito.exceptions.verification.NeverWantedButInvoked;\n-import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.SmartNullPointerException;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.*;\n import org.mockito.exceptions.verification.junit.JUnitTool;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+\n+import java.util.List;\n+\n+import static org.mockito.exceptions.Pluralizer.pluralize;\n+import static org.mockito.internal.util.StringJoiner.join;\n \n /**\n  * Reports verification and misusing errors.\n     }\n \n     public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n-        throw new MockitoException(join(\"Cannot instianate a @Spy for '\" + fieldName + \"' field.\",\n+        throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n             \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n             \"However, I failed because: \" + details.getMessage(),\n             \"Examples of correct usage of @Spy:\",\n     }\n \n     public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n-        throw new MockitoException(join(\"Cannot instianate @InjectMocks field named '\" + fieldName + \"'.\",\n-            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n+        throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n+            \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n             \"However, I failed because: \" + details.getMessage(),\n             \"Examples of correct usage of @InjectMocks:\",\n             \"   @InjectMocks Service service = new Service();\",\n                 \"If you want to find out more please refer to issue 235\",\n                 \"\"));\n     }\n-}\n+}\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\n-import org.mockito.internal.configuration.injection.MockCandidateFilter;\n-import org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\n-import org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\n-import org.mockito.internal.util.reflection.FieldInitializer;\n+import org.mockito.internal.configuration.injection.MockInjection;\n+import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n \n import java.lang.reflect.Field;\n-import java.util.Arrays;\n import java.util.Comparator;\n-import java.util.HashSet;\n import java.util.Set;\n \n /**\n         }\n     };\n \n-    /**\n-     * Inject mocks in injectMocksFields, and initialize them if needed.\n-     *\n-     * <p>\n-     * <u>Algorithm :<br></u>\n-     * for each field annotated by @InjectMocks\n-     *   <ul>\n-     *   <li>copy mocks set\n-     *   <li>initialize field annotated by @InjectMocks\n-     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n-     *     <ul>\n-     *     <li>find mock candidate by type\n-     *     <li>if more than *one* candidate find mock candidate on name\n-     *     <li>if one mock candidate then\n-     *       <ul>\n-     *       <li>set mock by property setter if possible\n-     *       <li>else set mock by field injection\n-     *       </ul>\n-     *     <li>remove mock from mocks copy (mocks are just injected once)\n-     *     <li>else don't fail, user will then provide dependencies\n-     *     </ul>\n-     *   </ul>\n-     * </p>\n-     *\n-     * @param injectMocksFields Fields annotated by @InjectMocks\n-     * @param mocks Mocks\n-     * @param testClassInstance The test class instance\n-     */\n-    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n-        for (Field field : injectMocksFields) {\n-            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n-            Object injectMocksFieldInstance = null;\n-            try {\n-                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n-            } catch (MockitoException e) {\n-                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n-            }\n \n-            // for each field in the class hierarchy\n-            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n-            while (fieldClass != Object.class) {\n-                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n-                fieldClass = fieldClass.getSuperclass();\n-            }\n-        }\n+    public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {\n+        MockInjection.onFields(needingInjection, testClassInstance)\n+                .withMocks(mocks)\n+                .tryConstructorInjection()\n+                .tryPropertyOrFieldInjection()\n+                .apply();\n     }\n \n-    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n-            mocks.remove(injected);\n-        }\n-    }\n \n-    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n-        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n-        Arrays.sort(declaredFields, supertypesLast);\n-        return declaredFields;\n-    }\n+\n+    /*\n+        XXX         Attention en fait le SpyAnnotationEngine peut tenter d'instancier le field\n+                    annot\u00e9 par @InjectMocks\n+\n+        Solution :  Dans SpyAnnotationEngine, ne pas essayer d'instancier un field annot\u00e9 par @InjectMocks\n+        Drawbacks : il faut g\u00e9rer de mani\u00e8re particuli\u00e8re le @Spy depuis DefaultInjectionEngine\n+     */\n+\n+    /*\n+        XXX :   Autre soucis qui arrive avec l'injection par constructeur de @InjectMocks\n+                il faut pte pr\u00e9voir le nettoyage des instances\n+     */\n+\n \n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+/**\n+ * Injection strategy based on constructor.\n+ *\n+ * <p>\n+ * The strategy will search for the constructor with most parameters\n+ * and try to resolve mocks by type.\n+ * </p>\n+ *\n+ * <blockquote>\n+ * TODO on missing mock type, shall it abandon or create \"noname\" mocks.\n+ * TODO and what if the arg type is not mockable.\n+ * </blockquote>\n+ *\n+ * <p>\n+ * For now the algorithm tries to create anonymous mocks if an argument type is missing.\n+ * If not possible the algorithm abandon resolution.\n+ * </p>\n+ */\n+public class ConstructorInjection extends MockInjectionStrategy {\n+\n+    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+\n+        // new FieldConstructorInitializer(field, fieldOwner).initialize(mockCandidates);\n+\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.mockito.internal.util.Checks.checkItemsNotNull;\n+import static org.mockito.internal.util.Checks.checkNotNull;\n+\n+/**\n+ * Internal injection configuration utility.\n+ *\n+ * <p>\n+ * Allow the user of this class to configure the way the injection of mocks will happen.\n+ * </p>\n+ *\n+ */\n+public class MockInjection {\n+\n+    /**\n+     * Create a new configuration setup for a field\n+     *\n+     *\n+     * @param field Field needing mock injection\n+     * @param ofInstance Instance owning the <code>field</code>\n+     * @return New configuration builder\n+     */\n+    public static OngoingMockInjection onField(Field field, Object ofInstance) {\n+        return new OngoingMockInjection(field, ofInstance);\n+    }\n+\n+    /**\n+     * Create a new configuration setup for fields\n+     *\n+     *\n+     * @param fields Fields needing mock injection\n+     * @param ofInstance Instance owning the <code>field</code>\n+     * @return New configuration builder\n+     */\n+    public static OngoingMockInjection onFields(Set<Field> fields, Object ofInstance) {\n+        return new OngoingMockInjection(fields, ofInstance);\n+    }\n+\n+    public static class OngoingMockInjection {\n+        private Set<Field> fields = new HashSet<Field>();\n+        private Set<Object> mocks = new HashSet<Object>();\n+        private Object fieldOwner;\n+        private MockInjectionStrategy injectionStrategies;\n+\n+        private OngoingMockInjection(Field field, Object fieldOwner) {\n+            this(Collections.singleton(field), fieldOwner);\n+        }\n+\n+        private OngoingMockInjection(Set<Field> fields, Object fieldOwner) {\n+            this.fieldOwner = checkNotNull(fieldOwner, \"fieldOwner\");\n+            this.fields.addAll(checkItemsNotNull(fields, \"fields\"));\n+        }\n+\n+        public OngoingMockInjection withMocks(Set<Object> mocks) {\n+            this.mocks.addAll(checkNotNull(mocks, \"mocks\"));\n+            return this;\n+        }\n+\n+        public OngoingMockInjection tryConstructorInjection() {\n+            appendStrategy(new ConstructorInjection());\n+            return this;\n+        }\n+\n+        public OngoingMockInjection tryPropertyOrFieldInjection() {\n+            appendStrategy(new PropertyAndSetterInjection());\n+            return this;\n+        }\n+\n+        private void appendStrategy(MockInjectionStrategy strategy) {\n+            if(injectionStrategies == null) {\n+                injectionStrategies = strategy;\n+            } else {\n+                injectionStrategies.thenTry(strategy);\n+            }\n+\n+        }\n+\n+        public void apply() {\n+            for (Field field : fields) {\n+                injectionStrategies.process(field, fieldOwner, mocks);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+/**\n+ * Injector strategy contract\n+ */\n+public abstract class MockInjectionStrategy {\n+\n+    private MockInjectionStrategy nextStrategy;\n+\n+    /**\n+     * Enqueue next injection strategy.\n+     *\n+     * <p>\n+     * The implementation should take care of the actual calling if required.\n+     * </p>\n+     *\n+     * @param strategy Queued strategy.\n+     * @return The passed strategy instance to allow chaining.\n+     */\n+    public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n+        nextStrategy = strategy;\n+        return strategy;\n+    }\n+\n+    /**\n+     * Actually inject mockCandidates on field.\n+     *\n+     * <p>\n+     * Actual algorithm is defined in the implementations of {@link #processInjection(Field, Object, Set)}.\n+     * However if injection occurred successfully, the process should return <code>true</code>,\n+     * and <code>false</code> otherwise.\n+     * </p>\n+     *\n+     * <p>\n+     * The code takes care of calling the next strategy if available and if of course if required\n+     * </p>\n+     *\n+     * @param onField Field needing injection.\n+     * @param fieldOwnedBy The owning instance of the field.\n+     * @param mockCandidates A set of mock candidate, that might be injected.\n+     * @return <code>true</code> if successful, <code>false</code> otherwise.\n+     */\n+    public boolean process(Field onField, Object fieldOwnedBy, Set<Object> mockCandidates) {\n+        if(processInjection(onField, fieldOwnedBy, mockCandidates)) {\n+            return true;\n+        }\n+        return relayProcessToNextStrategy(onField, fieldOwnedBy, mockCandidates);\n+    }\n+\n+    /**\n+     * Process actual injection.\n+     *\n+     * <p>\n+     * Don't call this method directly, instead call {@link #process(Field, Object, Set)}\n+     * </p>\n+     *\n+     * @param field Field needing injection\n+     * @param fieldOwner Field owner instance.\n+     * @param mockCandidates Pool of mocks to inject.\n+     * @return <code>true</code> if injection occurred, <code>false</code> otherwise\n+     */\n+    protected abstract boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates);\n+\n+    private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        return nextStrategy != null && nextStrategy.processInjection(field, fieldOwner, mockCandidates);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n+import org.mockito.internal.util.reflection.FieldInitializer;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Inject mocks using first setters then fields, if no setters available.\n+ *\n+ * <p>\n+ * <u>Algorithm :<br></u>\n+ * for each field annotated by @InjectMocks\n+ *   <ul>\n+ *   <li>copy mocks set\n+ *   <li>initialize field annotated by @InjectMocks\n+ *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n+ *     <ul>\n+ *     <li>find mock candidate by type\n+ *     <li>if more than *one* candidate find mock candidate on name\n+ *     <li>if one mock candidate then\n+ *       <ul>\n+ *       <li>set mock by property setter if possible\n+ *       <li>else set mock by field injection\n+ *       </ul>\n+ *     <li>remove mock from mocks copy (mocks are just injected once)\n+ *     <li>else don't fail, user will then provide dependencies\n+ *     </ul>\n+ *   </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * <u>Note:</u> If the field needing injection is not initialized, the strategy tries\n+ * to create one using a no-arg constructor of the field type.\n+ * </p>\n+ */\n+public class PropertyAndSetterInjection extends MockInjectionStrategy {\n+\n+    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n+    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n+        public int compare(Field field1, Field field2) {\n+            Class<?> field1Type = field1.getType();\n+            Class<?> field2Type = field2.getType();\n+\n+            if(field1Type.isAssignableFrom(field2Type)) {\n+                return 1;\n+            }\n+            if(field2Type.isAssignableFrom(field1Type)) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+    };\n+\n+\n+    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n+        Object fieldInstanceNeedingInjection = null;\n+        try {\n+            fieldInstanceNeedingInjection = new FieldInitializer(fieldOwner, field).initialize();\n+        } catch (MockitoException e) {\n+            new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n+        }\n+\n+        // for each field in the class hierarchy\n+        Class<?> fieldClass = fieldInstanceNeedingInjection.getClass();\n+        while (fieldClass != Object.class) {\n+            injectMockCandidate(fieldClass, mocksToBeInjected, fieldInstanceNeedingInjection);\n+            fieldClass = fieldClass.getSuperclass();\n+        }\n+        return false;\n+    }\n+\n+\n+    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n+        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n+            mocks.remove(injected);\n+        }\n+    }\n+\n+    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n+        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n+        Arrays.sort(declaredFields, supertypesLast);\n+        return declaredFields;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.BeanPropertySetter;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+\n+/**\n+ * This node returns an actual injecter which will be either :\n+ *\n+ * <ul>\n+ * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n+ * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n+ * </ul>\n+ */\n+public class FinalMockCandidateFilter implements MockCandidateFilter {\n+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n+        if(mocks.size() == 1) {\n+            final Object matchingMock = mocks.iterator().next();\n+\n+            return new OngoingInjecter() {\n+                public Object thenInject() {\n+                    try {\n+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n+                            new FieldSetter(fieldInstance, field).set(matchingMock);\n+                        }\n+                    } catch (Exception e) {\n+                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n+                    }\n+                    return matchingMock;\n+                }\n+            };\n+        }\n+\n+        return new OngoingInjecter() {\n+            public Object thenInject() {\n+                return null;\n+            }\n+        };\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+\n+public interface MockCandidateFilter {\n+\n+    OngoingInjecter filterCandidate(\n+            Collection<Object> mocks,\n+            Field fieldToBeInjected,\n+            Object fieldInstance\n+    );\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class NameBasedCandidateFilter implements MockCandidateFilter {\n+    private final MockCandidateFilter next;\n+    private final MockUtil mockUtil = new MockUtil();\n+\n+    public NameBasedCandidateFilter(MockCandidateFilter next) {\n+        this.next = next;\n+    }\n+\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+        List<Object> mockNameMatches = new ArrayList<Object>();\n+        if(mocks.size() > 1) {\n+            for (Object mock : mocks) {\n+                if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n+                    mockNameMatches.add(mock);\n+                }\n+            }\n+            return next.filterCandidate(mockNameMatches, field, fieldInstance);\n+        }\n+        return next.filterCandidate(mocks, field, fieldInstance);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/OngoingInjecter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+/**\n+ * Allow the ongoing injection of a mock candidate.\n+ */\n+public interface OngoingInjecter {\n+\n+    /**\n+     * Inject the mock.\n+     *\n+     * <p>\n+     * Please check the actual implementation.\n+     * </p>\n+     *\n+     * @return the mock that was injected, <code>null</code> otherwise.\n+     */\n+    Object thenInject();\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class TypeBasedCandidateFilter implements MockCandidateFilter {\n+\n+    MockCandidateFilter next;\n+\n+    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n+        this.next = next;\n+    }\n+\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+        List<Object> mockTypeMatches = new ArrayList<Object>();\n+        for (Object mock : mocks) {\n+            if (field.getType().isAssignableFrom(mock.getClass())) {\n+                mockTypeMatches.add(mock);\n+            }\n+        }\n+\n+        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/Checks.java\n+package org.mockito.internal.util;\n+\n+/**\n+ * Pre-made preconditions\n+ */\n+public class Checks {\n+\n+    public static <T> T checkNotNull(T value, String checkedValue) {\n+        if(value == null) {\n+            throw new NullPointerException(checkedValue + \" should not be null\");\n+        }\n+        return value;\n+    }\n+\n+    public static <T extends Iterable> T checkItemsNotNull(T iterable, String checkedIterable) {\n+        checkNotNull(iterable, checkedIterable);\n+        for (Object item : iterable) {\n+            checkNotNull(item, \"item in \" + checkedIterable);\n+        }\n+        return iterable;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/FieldConstructorInitializer.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.exceptions.Reporter;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.mock;\n+\n+public class FieldConstructorInitializer {\n+\n+    private final Field field;\n+    private final Object target;\n+\n+    public FieldConstructorInitializer(Field field, Object target) {\n+        this.field = field;\n+        this.target = target;\n+    }\n+\n+\n+    public void initialize(Set<Object> mocks) {\n+        try {\n+            final Object instance = newInstance(mocks);\n+            final AccessibilityChanger changer = new AccessibilityChanger();\n+            changer.enableAccess(field);\n+            field.set(target, instance);\n+            changer.safelyDisableAccess(field);\n+        } catch (Exception e) {\n+            new Reporter().cannotInitializeForInjectMocksAnnotation(\n+                    field.getName(), e);\n+        }\n+    }\n+\n+    private Object newInstance(Set<Object> mocks) throws Exception {\n+        final Constructor<?> c = biggestConstructor(field.getType());\n+        final Object[] args = args(c, mocks);\n+        final AccessibilityChanger changer = new AccessibilityChanger();\n+        changer.enableAccess(c);\n+        final Object instance = c.newInstance(args);\n+        changer.safelyDisableAccess(c);\n+        return instance;\n+    }\n+\n+    private Object[] args(Constructor<?> c, Set<Object> mocks) {\n+        final List<Object> args = new ArrayList<Object>(c.getParameterTypes().length);\n+\n+        for (Class<?> paramClass : c.getParameterTypes()) {\n+            args.add(findMockByTypeOrCreateOne(mocks, paramClass));\n+        }\n+        return args.toArray();\n+    }\n+\n+    private Object findMockByTypeOrCreateOne(Set<Object> mocks, Class<?> paramClass) {\n+        for (Object mock : mocks) {\n+            if (paramClass.isAssignableFrom(mock.getClass())) {\n+                return mock;\n+            }\n+        }\n+        return notMockFoundForClass(paramClass);\n+    }\n+\n+    private Object notMockFoundForClass(Class<?> paramClass) {\n+        return mock(paramClass);\n+    }\n+\n+    private Constructor<?> biggestConstructor(Class<?> clazz) {\n+        final List<Constructor<?>> constructors = Arrays.asList(clazz.getConstructors());\n+        Collections.sort(constructors, new Comparator<Constructor<?>>() {\n+\n+            public int compare(Constructor<?> o1, Constructor<?> o2) {\n+                return o2.getParameterTypes().length - o1.getParameterTypes().length;\n+            }\n+        });\n+        return constructors.get(0);\n+    }\n+\n+}\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n \n /**\n  * Initialize a field with type instance if a default constructor can be found.\n  *\n  * <p>\n- * If the given field is already initialize\n+ * If the given field is already initialized, then <strong>the actual instance is returned</strong>.\n  * This initializer doesn't work with inner classes, local classes, interfaces or abstract types.\n  * </p>\n  *\n  */\n public class FieldInitializer {\n \n-    private Object testClass;\n+    private Object fieldOwner;\n     private Field field;\n-\n-\n-    /**\n-     * Initialize the given field on the given instance.\n+    private ConstructorInstantiator instantiator;\n+\n+\n+    /**\n+     * Prepare initializer with the given field on the given instance.\n      *\n      * <p>\n      * This constructor fail fast if the field type cannot be handled.\n      * </p>\n      *\n-     * @param testClass Instance of the test.\n+     * @param fieldOwner Instance of the test.\n      * @param field Field to be initialize.\n      */\n-    public FieldInitializer(Object testClass, Field field) {\n-        if(new FieldReader(testClass, field).isNull()) {\n+    public FieldInitializer(Object fieldOwner, Field field) {\n+        this(fieldOwner, field, new NoArgConstructorInstantiator(fieldOwner, field));\n+    }\n+\n+    /**\n+     * Prepare initializer with the given field on the given instance.\n+     *\n+     * <p>\n+     * This constructor fail fast if the field type cannot be handled.\n+     * </p>\n+     *\n+     * @param fieldOwner Instance of the test.\n+     * @param field Field to be initialize.\n+     */\n+    public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver resolver) {\n+        this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, resolver));\n+    }\n+\n+    private FieldInitializer(Object fieldOwner, Field field, ConstructorInstantiator instantiator) {\n+        if(new FieldReader(fieldOwner, field).isNull()) {\n             checkNotLocal(field);\n             checkNotInner(field);\n             checkNotInterface(field);\n             checkNotAbstract(field);\n         }\n-        this.testClass = testClass;\n+        this.fieldOwner = fieldOwner;\n         this.field = field;\n-    }\n-\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Initialize field if no initialized and return the actual instance.\n+     *\n+     * @return Actual field instance.\n+     */\n     public Object initialize() {\n         final AccessibilityChanger changer = new AccessibilityChanger();\n         changer.enableAccess(field);\n \n         try {\n-            return acquireFieldInstance(testClass, field);\n+            return acquireFieldInstance();\n         } catch(IllegalAccessException e) {\n-            throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+            throw new MockitoException(\"Problems initializing field '\" + field.getName() + \"' of type '\" + field.getType().getSimpleName() + \"'\", e);\n         } finally {\n             changer.safelyDisableAccess(field);\n-        }\n-    }\n-\n-    private void initializeField(Object testClass, Field field) {\n-        final AccessibilityChanger changer = new AccessibilityChanger();\n-        Constructor<?> constructor = null;\n-        try {\n-            constructor = field.getType().getDeclaredConstructor();\n-            changer.enableAccess(constructor);\n-\n-            final Object[] noArg = new Object[0];\n-            Object newFieldInstance = constructor.newInstance(noArg);\n-            new FieldSetter(testClass, field).set(newFieldInstance);\n-        } catch (NoSuchMethodException e) {\n-            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n-        } catch (InvocationTargetException e) {\n-            throw new MockitoException(\"the default constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n-        } catch (InstantiationException e) {\n-            throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n-        } catch (IllegalAccessException e) {\n-            throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n-        } finally {\n-            if(constructor != null) {\n-                changer.safelyDisableAccess(constructor);\n-            }\n         }\n     }\n \n         }\n     }\n \n-    private Object acquireFieldInstance(Object testClass, Field field) throws IllegalAccessException {\n-        Object fieldInstance = field.get(testClass);\n+    private Object acquireFieldInstance() throws IllegalAccessException {\n+        Object fieldInstance = field.get(fieldOwner);\n         if(fieldInstance != null) {\n             return fieldInstance;\n         }\n \n-        initializeField(testClass, field);\n-        return field.get(testClass);\n+        instantiator.instantiate();\n+        return field.get(fieldOwner);\n+    }\n+\n+    public interface ConstructorArgumentResolver {\n+        Object[] resolveTypeInstances(Class<?>... argTypes);\n+    }\n+\n+    private interface ConstructorInstantiator {\n+        Object instantiate();\n+    }\n+\n+    /**\n+     * Constructor instantiating strategy for no-arg constructor.\n+     *\n+     * <p>\n+     * If a no-arg constructor can be found then the instance is created using\n+     * this constructor.\n+     * Otherwise a technical MockitoException is thrown.\n+     * </p>\n+     */\n+    static class NoArgConstructorInstantiator implements ConstructorInstantiator {\n+        private Object testClass;\n+        private Field field;\n+\n+        /**\n+         * Internal, checks are done by FieldInitializer.\n+         * Fields are assumed to be accessible.\n+         */\n+        NoArgConstructorInstantiator(Object testClass, Field field) {\n+            this.testClass = testClass;\n+            this.field = field;\n+        }\n+\n+        public Object instantiate() {\n+            final AccessibilityChanger changer = new AccessibilityChanger();\n+            Constructor<?> constructor = null;\n+            try {\n+                constructor = field.getType().getDeclaredConstructor();\n+                changer.enableAccess(constructor);\n+\n+                final Object[] noArg = new Object[0];\n+                Object newFieldInstance = constructor.newInstance(noArg);\n+                new FieldSetter(testClass, field).set(newFieldInstance);\n+\n+                return field.get(testClass);\n+            } catch (NoSuchMethodException e) {\n+                throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n+            } catch (InvocationTargetException e) {\n+                throw new MockitoException(\"the default constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n+            } catch (InstantiationException e) {\n+                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n+            } catch (IllegalAccessException e) {\n+                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n+            } finally {\n+                if(constructor != null) {\n+                    changer.safelyDisableAccess(constructor);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Constructor instantiating strategy for parameterized constructors.\n+     *\n+     * <p>\n+     * Choose the constructor with the highest number of parameters, then\n+     * call the ConstructorArgResolver to get actual argument instances.\n+     * If the resolver fail, then a technical MockitoException is thrown is thrown.\n+     * Otherwise the instance is created with the resolved arguments.\n+     * </p>\n+     */\n+    static class ParameterizedConstructorInstantiator implements ConstructorInstantiator {\n+        private Object testClass;\n+        private Field field;\n+        private ConstructorArgumentResolver resolver;\n+        private Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {\n+            public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {\n+                return constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n+            }\n+        };\n+\n+        /**\n+         * Internal, checks are done by FieldInitializer.\n+         * Fields are assumed to be accessible.\n+         */\n+        ParameterizedConstructorInstantiator(Object testClass, Field field, ConstructorArgumentResolver resolver) {\n+            this.testClass = testClass;\n+            this.field = field;\n+            this.resolver = resolver;\n+        }\n+\n+        public Object instantiate() {\n+            final AccessibilityChanger changer = new AccessibilityChanger();\n+            Constructor<?> constructor = null;\n+            try {\n+                constructor = biggestConstructor(field.getType());\n+                checkParameterized(constructor, field);\n+                changer.enableAccess(constructor);\n+\n+                final Object[] args = resolver.resolveTypeInstances(constructor.getParameterTypes());\n+                Object newFieldInstance = constructor.newInstance(args);\n+                new FieldSetter(testClass, field).set(newFieldInstance);\n+\n+                return field.get(testClass);\n+            } catch (IllegalArgumentException e) {\n+                throw new MockitoException(\"internal error : resolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n+            } catch (InvocationTargetException e) {\n+                throw new MockitoException(\"the constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n+            } catch (InstantiationException e) {\n+                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n+            } catch (IllegalAccessException e) {\n+                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n+            } finally {\n+                if(constructor != null) {\n+                    changer.safelyDisableAccess(constructor);\n+                }\n+            }\n+        }\n+\n+        private void checkParameterized(Constructor<?> constructor, Field field) {\n+            if(constructor.getParameterTypes().length == 0) {\n+                throw new MockitoException(\"the field \" + field.getName() + \" of type \" + field.getType() + \" has no parameterized constructor\");\n+            }\n+        }\n+\n+        private Constructor<?> biggestConstructor(Class<?> clazz) {\n+            final List<Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());\n+            Collections.sort(constructors, byParameterNumber);\n+            return constructors.get(0);\n+        }\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/MockInjectionTest.java\n+package org.mockito.internal.configuration;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.internal.configuration.injection.MockInjection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Observer;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockInjectionTest {\n+\n+    private AnObjectWithConstructor withConstructor;\n+    private AnObjectWithoutConstructor withoutConstructor;\n+\n+    @After\n+    public void reset() throws Exception {\n+        withConstructor = null;\n+        withoutConstructor = null;\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_field() {\n+        MockInjection.onField((Field) null, this);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_fields() {\n+        MockInjection.onFields((Set<Field>) null, this);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_instance_owning_the_field() throws Exception {\n+        MockInjection.onField(field(\"withConstructor\"), null);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_mocks() throws Exception {\n+        MockInjection.onField(field(\"withConstructor\"), this).withMocks(null);\n+    }\n+\n+\n+    @Test\n+    public void can_try_constructor_injection() throws Exception {\n+        MockInjection.onField(field(\"withConstructor\"), this).withMocks(oneSetMock()).tryConstructorInjection().apply();\n+\n+        assertThat(withConstructor.initializedWithConstructor).isEqualTo(true);\n+    }\n+\n+    @Test\n+    public void should_not_fail_if_constructor_injection_is_not_possible() throws Exception {\n+        MockInjection.onField(field(\"withoutConstructor\"), this).withMocks(otherKindOfMocks()).tryConstructorInjection().apply();\n+\n+        assertThat(withoutConstructor).isNull();\n+    }\n+\n+    @Test\n+    public void can_try_property_or_setter_injection() throws Exception {\n+        MockInjection.onField(field(\"withoutConstructor\"), this).withMocks(oneSetMock()).tryPropertyOrFieldInjection().apply();\n+\n+        assertThat(withoutConstructor.theSet).isNotNull();\n+    }\n+\n+    @Test\n+    public void should_not_fail_if_property_or_field_injection_is_not_possible() throws Exception {\n+        MockInjection.onField(field(\"withoutConstructor\"), this).withMocks(otherKindOfMocks()).tryPropertyOrFieldInjection().apply();\n+\n+        assertThat(withoutConstructor.theSet).isNull();\n+    }\n+\n+    private Set oneSetMock() {\n+        return Collections.singleton(mock(Set.class));\n+    }\n+\n+    private Set otherKindOfMocks() {\n+        return Collections.singleton(mock(Observer.class));\n+    }\n+\n+    private Field field(String field) throws NoSuchFieldException {\n+        return getClass().getDeclaredField(field);\n+    }\n+\n+\n+    public static class AnObjectWithConstructor {\n+        public boolean initializedWithConstructor = false;\n+        public AnObjectWithConstructor(Set<String> strings) {\n+            initializedWithConstructor = true;\n+        }\n+    }\n+\n+    public static class AnObjectWithoutConstructor {\n+        private Set theSet;\n+    }\n+}\n--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n import org.junit.Test;\n import org.mockito.InjectMocks;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n \n+import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n \n import static org.junit.Assert.*;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+\n+\n \n public class FieldInitializerTest {\n \n     private InnerClassType instantiatedInnerClassType = new InnerClassType();\n \n     @Test\n-    public void shouldKeepSameInstanceIfFieldInitialized() throws Exception {\n+    public void should_keep_same_instance_if_field_initialized() throws Exception {\n         final StaticClass backupInstance = alreadyInstantiated;\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"alreadyInstantiated\"));\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"alreadyInstantiated\"));\n         assertSame(backupInstance, fieldInitializer.initialize());\n     }\n \n     @Test\n-    public void shouldInstantiateFieldWhenTypeHasNoConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"noConstructor\"));\n+    public void should_instantiate_field_when_type_has_no_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"noConstructor\"));\n         assertNotNull(fieldInitializer.initialize());\n     }\n \n     @Test\n-    public void shouldInstantiateFieldWithDefaultConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"defaultConstructor\"));\n+    public void should_instantiate_field_with_default_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"defaultConstructor\"));\n         assertNotNull(fieldInitializer.initialize());\n     }\n \n     @Test\n-    public void shouldInstantiateFieldWithPrivateDefaultConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"privateDefaultConstructor\"));\n+    public void should_instantiate_field_with_private_default_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"privateDefaultConstructor\"));\n         assertNotNull(fieldInitializer.initialize());\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailToInstantiateFieldIfNoDefaultConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"noDefaultConstructor\"));\n+    public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"noDefaultConstructor\"));\n         fieldInitializer.initialize();\n     }\n \n     @Test\n-    public void shouldFailToInstantiateFieldIfDefaultConstructorThrowsException() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"throwingExDefaultConstructor\"));\n+    public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"throwingExDefaultConstructor\"));\n         try {\n             fieldInitializer.initialize();\n             fail();\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForAbstractField() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"abstractType\"));\n+    public void should_fail_for_abstract_field() throws Exception {\n+        new FieldInitializer(this, field(\"abstractType\"));\n     }\n \n-    public void shouldNotFailIfAbstractFieldIsInstantiated() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedAbstractType\"));\n+    @Test\n+    public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {\n+        new FieldInitializer(this, field(\"instantiatedAbstractType\"));\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForInterfaceField() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"interfaceType\"));\n+    public void should_fail_for_interface_field() throws Exception {\n+        new FieldInitializer(this, field(\"interfaceType\"));\n     }\n \n-    public void shouldNotFailIfInterfaceFieldIsInstantiated() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedInterfaceType\"));\n+    @Test\n+    public void should_not_fail_if_interface_field_is_instantiated() throws Exception {\n+        new FieldInitializer(this, field(\"instantiatedInterfaceType\"));\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForLocalTypeField() throws Exception {\n+    public void should_fail_for_local_type_field() throws Exception {\n         // when\n-        class LocalType { };\n+        class LocalType { }\n \n         class TheTestWithLocalType {\n             @InjectMocks LocalType field;\n         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField(\"field\"));\n     }\n \n-    public void shouldNotFailIfLocalTypeFieldIsInstantiated() throws Exception {\n+    @Test\n+    public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {\n         // when\n-        class LocalType { };\n+        class LocalType { }\n \n         class TheTestWithLocalType {\n             @InjectMocks LocalType field = new LocalType();\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForInnerClassField() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"innerClassType\"));\n+    public void should_fail_for_inner_class_field() throws Exception {\n+        new FieldInitializer(this, field(\"innerClassType\"));\n     }\n \n-    public void shouldNotFailIfInnerClassFieldIsInstantiated() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedInnerClassType\"));\n+    @Test\n+    public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {\n+        new FieldInitializer(this, field(\"instantiatedInnerClassType\"));\n+    }\n+\n+    @Test\n+    public void can_instantiate_class_with_parameterized_constructor() throws Exception {\n+        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))\n+                        .willReturn(new Object[] { null }).getMock();\n+\n+        new FieldInitializer(this, field(\"noDefaultConstructor\"), resolver).initialize();\n+\n+        assertNotNull(noDefaultConstructor);\n+    }\n+\n+    private Field field(String fieldName) throws NoSuchFieldException {\n+        return this.getClass().getDeclaredField(fieldName);\n     }\n \n     static class StaticClass {\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java\n+package org.mockito.internal.util.reflection;\n+\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n+import org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+import java.util.Observer;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+@RunWith(MockitoJUnitRunner.class)\n+public class ParameterizedConstructorInstantiatorTest {\n+\n+    private Set whateverForNow;\n+    private OneConstructor withOneConstructor;\n+    private MultipleConstructor withMultipleConstructor;\n+    private NoArgConstructor withNoArgConstructor;\n+    private ThrowingConstructor withThrowingConstructor;\n+    private VarargConstructor withVarargConstructor;\n+\n+    @After\n+    public void ensure_instances_to_create_are_null() {\n+        withMultipleConstructor = null;\n+        withOneConstructor = null;\n+        withNoArgConstructor = null;\n+        withThrowingConstructor = null;\n+        withVarargConstructor = null;\n+    }\n+\n+    @Mock private ConstructorArgumentResolver resolver;\n+\n+    @Test\n+    public void should_be_created_with_an_argument_resolver() throws Exception {\n+        new ParameterizedConstructorInstantiator(this, field(\"whateverForNow\"), resolver);\n+    }\n+\n+    @Test\n+    public void should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types() throws Exception {\n+        try {\n+            new ParameterizedConstructorInstantiator(this, field(\"withNoArgConstructor\"), resolver).instantiate();\n+            fail();\n+        } catch (MockitoException me) {\n+            assertThat(me.getMessage()).contains(\"no parameterized constructor\").contains(\"withNoArgConstructor\").contains(\"NoArgConstructor\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {\n+        Observer observer = mock(Observer.class);\n+        Map map = mock(Map.class);\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, map });\n+\n+        new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n+\n+        assertNotNull(withMultipleConstructor);\n+        assertNotNull(withMultipleConstructor.observer);\n+        assertNotNull(withMultipleConstructor.map);\n+    }\n+\n+    @Test\n+    public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type() throws Exception {\n+        Observer observer = mock(Observer.class);\n+        Set wrongArg = mock(Set.class);\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, wrongArg });\n+\n+        try {\n+            new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage()).contains(\"resolver\").contains(\"incorrect types\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_report_failure_if_constructor_throws_exception() throws Exception {\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ null });\n+\n+        try {\n+            new ParameterizedConstructorInstantiator(this, field(\"withThrowingConstructor\"), resolver).instantiate();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage()).contains(\"constructor\").contains(\"raised an exception\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_instantiate_type_with_vararg_constructor() throws Exception {\n+        Observer[] vararg = new Observer[] {  };\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ \"\", vararg});\n+\n+        new ParameterizedConstructorInstantiator(this, field(\"withVarargConstructor\"), resolver).instantiate();\n+\n+        assertNotNull(withVarargConstructor);\n+    }\n+\n+    private Field field(String fieldName) throws NoSuchFieldException {\n+        Field field = this.getClass().getDeclaredField(fieldName);\n+        field.setAccessible(true);\n+        return field;\n+    }\n+\n+    private static class NoArgConstructor {\n+        NoArgConstructor() { }\n+    }\n+\n+    private static class OneConstructor {\n+        public OneConstructor(Observer observer) { }\n+    }\n+\n+    private static class ThrowingConstructor {\n+        public ThrowingConstructor(Observer observer) throws IOException { throw new IOException(); }\n+    }\n+\n+    private static class MultipleConstructor extends OneConstructor {\n+        Observer observer;\n+        Map map;\n+\n+        public MultipleConstructor(Observer observer) { this(observer, null); }\n+        public MultipleConstructor(Observer observer, Map map) {\n+            super(observer);\n+            this.observer = observer;\n+            this.map = map;\n+        }\n+    }\n+\n+    private static class VarargConstructor {\n+        VarargConstructor(String whatever, Observer... observers) { }\n+    }\n+}\n--- a/test/org/mockitousage/annotation/MockInjectionTest.java\n+++ b/test/org/mockitousage/annotation/MockInjectionTest.java\n import org.mockito.MockitoAnnotations;\n import org.mockito.Spy;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n import org.mockitoutil.TestBase;\n \n import java.util.List;\n \t@Mock private Set histogram1;\n \t@Mock private Set histogram2;\n \t@Spy private TreeSet searchTree = new TreeSet();\n+    private MockUtil mockUtil = new MockUtil();\n \n-\t@Before\n+    @Before\n \tpublic void init() {\n \t\t// initMocks called in TestBase Before method, so instances ar not the same\n \t\tMockitoAnnotations.initMocks(this);\n     @Test\n     public void shouldIInjectMocksInSpy() {\n         assertNotNull(initializedSpy.getAList());\n+        assertTrue(mockUtil.isMock(initializedSpy));\n     }\n     @Test\n     public void shouldInitializeSpyIfNullAndInjectMocks() {\n         assertNotNull(notInitializedSpy);\n         assertNotNull(notInitializedSpy.getAList());\n+        assertTrue(mockUtil.isMock(notInitializedSpy));\n     }\n \n \t@Test\n--- a/test/org/mockitousage/bugs/ParentTestMockInjectionTest.java\n+++ b/test/org/mockitousage/bugs/ParentTestMockInjectionTest.java\n         @Mock protected DaoA daoFromParent;\n     }\n \n-    @Ignore(\"JUnit : don't this test!\")\n+    @Ignore(\"JUnit test under test : don't test this!\")\n     public static class ImplicitTest extends BaseTest {\n         @InjectMocks private TestedSystem sut = new TestedSystem();\n ", "timestamp": 1300324785, "metainfo": ""}