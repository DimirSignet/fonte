{"sha": "abe99491fe3e6a8d57f40a59653d5ab77ae73517", "log": "added few tests to Invocation  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40136", "commit": "\n--- a/test/org/mockito/InvocationTest.java\n+++ b/test/org/mockito/InvocationTest.java\n \n import static org.junit.Assert.*;\n \n+import java.lang.reflect.Method;\n import java.util.*;\n \n import org.junit.*;\n import org.mockito.internal.*;\n import org.mockito.util.RequiresValidState;\n+import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationTest extends RequiresValidState {\n \n-    private Invocation call;\n-    private Invocation equalCall;\n-    private Invocation nonEqualCall;\n-    private Invocation callWithNewStringInstance;\n+    private Invocation invocation;\n \n     @Before\n     public void setup() throws SecurityException, NoSuchMethodException {\n-        call            = new InvocationBuilder().args(\" \").mock(\"mock\").seq(1).toInvocation();\n-        equalCall       = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n-        nonEqualCall    = new InvocationBuilder().args(\"X\").mock(\"mock\").seq(3).toInvocation();\n-        \n-        callWithNewStringInstance    = new InvocationBuilder().args(new String(\" \")).mock(\"mock\").seq(4).toInvocation();\n+        invocation = new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n     }\n \n     @Test\n     public void shouldKnowIfIsEqualTo() {\n-        assertFalse(call.equals(null));\n-        assertFalse(call.equals(\"\"));\n-        assertTrue(call.equals(equalCall));\n-        assertFalse(call.equals(nonEqualCall));\n-        assertTrue(call.equals(callWithNewStringInstance));\n+        Invocation equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+        Invocation nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n+        Invocation withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n+\n+        assertFalse(invocation.equals(null));\n+        assertFalse(invocation.equals(\"\"));\n+        assertTrue(invocation.equals(equal));\n+        assertFalse(invocation.equals(nonEqual));\n+        assertTrue(invocation.equals(withNewStringInstance));\n     }\n     \n     @Test\n     public void shouldEqualToNotConsiderSequenceNumber() {\n-        assertTrue(call.getSequenceNumber() != equalCall.getSequenceNumber());\n-        assertTrue(call.equals(equalCall));\n+        Invocation equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        \n+        assertTrue(invocation.equals(equal));\n+        assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());\n     }\n     \n     @Test\n     public void shouldNotBeACitizenOfHashes() {\n         Map map = new HashMap();\n         try {\n-            map.put(call, \"one\");\n+            map.put(invocation, \"one\");\n             fail();\n         } catch (RuntimeException e) {\n             assertEquals(\"hashCode() is not implemented\", e.getMessage());\n     \n     @Test\n     public void shouldPrintMethodName() {\n-        call = new InvocationBuilder().toInvocation();\n-        assertEquals(\"Object.simpleMethod()\", call.toString());\n+        invocation = new InvocationBuilder().toInvocation();\n+        assertEquals(\"Object.simpleMethod()\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintMethodArgs() {\n-        call = new InvocationBuilder().args(\"foo\").toInvocation();\n-        assertEquals(\"Object.simpleMethod(\\\"foo\\\")\", call.toString());\n+        invocation = new InvocationBuilder().args(\"foo\").toInvocation();\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\")\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintMethodIntegerArgAndString() {\n-        call = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n-        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1)\", call.toString());\n+        invocation = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1)\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintNull() {\n+        invocation = new InvocationBuilder().args((String)null).toInvocation();\n+        assertEquals(\"Object.simpleMethod(null)\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintArray() {\n+        invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] {1,2,3}).toInvocation();\n+        assertEquals(\"Object.oneArray([1, 2, 3])\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintNullIfArrayIsNull() throws Exception {\n+        Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n+        invocation = new InvocationBuilder().method(m).args((Object)null).toInvocation();\n+        assertEquals(\"Object.oneArray(null)\", invocation.toString());\n     }\n }\n--- a/test/org/mockito/internal/InvocationBuilder.java\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n     private int sequenceNumber = 0;\n     private Object[] args = new Object[] {};\n     private Object mock = \"mock\";\n+    private Method method;\n \n     public Invocation toInvocation() {\n-        Method method;\n+        if (method != null) {\n+            return new Invocation(mock, method, args, sequenceNumber);\n+        }\n+        \n+        Method m;\n         List<Class> argTypes = new LinkedList<Class>();\n         for (Object arg : args) {\n-            argTypes.add(arg.getClass());\n+            if (arg == null) {\n+                argTypes.add(Object.class);\n+            } else {\n+                argTypes.add(arg.getClass());\n+            }\n         }\n         \n         try {\n-            method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n+            m = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n         } catch (Exception e) {\n             throw new RuntimeException(\"builder only creates invocations of IMethods interface\", e);\n         }\n-        Invocation i = new Invocation(mock, method, args, sequenceNumber);\n-        return i;\n+        return new Invocation(mock, m, args, sequenceNumber);\n     }\n \n     public InvocationBuilder method(String methodName) {\n         this.mock = mock;\n         return this;\n     }\n+\n+    public InvocationBuilder method(Method method) {\n+        this.method = method;\n+        return this;\n+    }\n }\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n \n     String simpleMethod(String argument);\n     \n+    String simpleMethod(Object argument);\n+    \n     String simpleMethod(int argument);\n     \n     String simpleMethod(String argOne, Integer argTwo);", "timestamp": 1196901680, "metainfo": ""}