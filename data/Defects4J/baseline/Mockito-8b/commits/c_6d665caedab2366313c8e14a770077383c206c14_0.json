{"sha": "6d665caedab2366313c8e14a770077383c206c14", "log": "Moved classes to better packages.  This change fixes #107 at least for now.", "commit": "\n--- a/src/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/cglib/AcrossJVMSerializationFeature.java\n      * </p>\n      *\n      * <p>\n-     *     When this marker is found, {@link ClassImposterizer} methods are being used to create the mock class.\n+     *     When this marker is found, {@link org.mockito.internal.creation.cglib.ClassImposterizer} methods are being used to create the mock class.\n      *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the\n-     *     {@link SearchingClassLoader} that will look if this enhanced class has\n+     *     {@link org.mockito.internal.creation.util.SearchingClassLoader} that will look if this enhanced class has\n      *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer\n      *     code.</em>\n      * </p>\n--- a/src/org/mockito/internal/creation/cglib/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/cglib/ClassImposterizer.java\n import org.mockito.cglib.proxy.*;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.instance.Instantiator;\n+import org.mockito.internal.creation.util.SearchingClassLoader;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n--- a/src/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java\n+++ b/src/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java\n package org.mockito.internal.creation.cglib;\n \n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n \n class DelegatingMockitoMethodProxy implements MockitoMethodProxy {\n \n--- a/src/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java\n import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.MockitoMethod;\n import org.mockito.internal.invocation.SerializableMethod;\n-import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n+import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod;\n import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.invocation.Invocation;\n         \n         MockitoMethod mockitoMethod = createMockitoMethod(method);\n         \n-        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n+        CleanTraceRealMethod realMethod = new CleanTraceRealMethod(mockitoMethodProxy);\n         Invocation invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n         return handler.handle(invocation);\n     }\n--- a/src/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java\n+++ b/src/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java\n package org.mockito.internal.creation.cglib;\n \n import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n import org.mockito.internal.util.reflection.Whitebox;\n \n import java.io.Serializable;\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/util/MockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.util;\n+\n+//TODO SF Replace with RealMethod and get rid of (possibly).\n+public interface MockitoMethodProxy {\n+    Object invokeSuper(Object target, Object[] arguments) throws Throwable;\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/util/SearchingClassLoader.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.util;\n+\n+import static java.lang.Thread.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Inspired on jMock (thanks jMock guys!!!)\n+ */\n+public class SearchingClassLoader extends ClassLoader {\n+    private final ClassLoader nextToSearch;\n+    \n+    public SearchingClassLoader(ClassLoader parent, ClassLoader nextToSearch) {\n+        super(parent);\n+        this.nextToSearch = nextToSearch;\n+    }\n+    \n+    public static ClassLoader combineLoadersOf(Class<?>... classes) {\n+        return combineLoadersOf(classes[0], classes);\n+    }\n+    \n+    private static ClassLoader combineLoadersOf(Class<?> first, Class<?>... others) {\n+        List<ClassLoader> loaders = new ArrayList<ClassLoader>();\n+        \n+        addIfNewElement(loaders, first.getClassLoader());\n+        for (Class<?> c : others) {\n+            addIfNewElement(loaders, c.getClassLoader());\n+        }\n+        \n+        // To support Eclipse Plug-in tests.\n+        // In an Eclipse plug-in, we will not be on the system class loader\n+        // but in the class loader of the plug-in.\n+        //\n+        // Note: I've been unable to reproduce the error in the test suite.\n+        addIfNewElement(loaders, SearchingClassLoader.class.getClassLoader());\n+        \n+        // To support the Maven Surefire plugin.\n+        // Note: I've been unable to reproduce the error in the test suite.\n+        addIfNewElement(loaders, currentThread().getContextClassLoader());\n+\n+        //Had to comment that out because it didn't work with in-container Spring tests\n+        //addIfNewElement(loaders, ClassLoader.getSystemClassLoader());\n+        \n+        return combine(loaders);\n+    }\n+    \n+    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n+        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n+        \n+        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n+            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n+        }\n+        \n+        return loader;\n+    }\n+    \n+    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n+        if (c != null && !loaders.contains(c)) {\n+            loaders.add(c);\n+        }\n+    }\n+    \n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        if (nextToSearch != null) {\n+            return nextToSearch.loadClass(name);\n+        } else {\n+            return super.findClass(name); // will throw ClassNotFoundException\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/CleanTraceRealMethod.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Provides stack trace filtering on exception.\n+ */\n+public class CleanTraceRealMethod implements RealMethod, Serializable {\n+\n+    private static final long serialVersionUID = 3596550785818938496L;\n+    private final RealMethod realMethod;\n+\n+    public CleanTraceRealMethod(MockitoMethodProxy methodProxy) {\n+        this(new DefaultRealMethod(methodProxy));\n+    }\n+\n+    public CleanTraceRealMethod(RealMethod realMethod) {\n+        this.realMethod = realMethod;\n+    }\n+\n+    public Object invoke(Object target, Object[] arguments) throws Throwable {\n+        try {\n+            return realMethod.invoke(target, arguments);\n+        } catch (Throwable t) {\n+            new ConditionalStackTraceFilter().filter(t);\n+            throw t;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/realmethod/DefaultRealMethod.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.invocation.realmethod;\n+\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n+\n+import java.io.Serializable;\n+\n+public class DefaultRealMethod implements RealMethod, Serializable {\n+\n+    private static final long serialVersionUID = -4596470901191501582L;\n+    private final MockitoMethodProxy methodProxy;\n+\n+    public DefaultRealMethod(MockitoMethodProxy methodProxy) {\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    public Object invoke(Object target, Object[] arguments) throws Throwable {\n+        return methodProxy.invokeSuper(target, arguments);\n+    }\n+}\n--- a/test/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java\n+++ b/test/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java\n  */\n package org.mockito.internal.creation.cglib;\n \n-import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.cglib.proxy.MethodProxy;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.creation.DelegatingMethod;\n import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.creation.util.MockitoMethodProxy;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.invocation.MockitoMethod;\n--- /dev/null\n+++ b/test/org/mockitousage/internal/invocation/realmethod/CleanTraceRealMethodTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.internal.invocation.realmethod;\n+\n+import static org.mockitoutil.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockitoutil.TestBase;\n+\n+public class CleanTraceRealMethodTest extends TestBase {\n+\n+    @Before\n+    public void keepStackTracesClean() {\n+        makeStackTracesClean();\n+    }\n+    \n+    class Foo {\n+        public String throwSomething() {\n+            throw new RuntimeException();\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows() throws Throwable {\n+        //given\n+        CleanTraceRealMethod realMethod = new CleanTraceRealMethod(new RealMethod() {\n+            public Object invoke(Object target, Object[] arguments) throws Throwable {\n+                return new Foo().throwSomething();\n+            }});\n+        \n+        //when\n+        try {\n+            realMethod.invoke(null, null);\n+            fail();\n+        //then\n+        } catch (Exception e) {\n+            assertThat(e, hasMethodInStackTraceAt(0, \"throwSomething\"));\n+            assertThat(e, hasMethodInStackTraceAt(1, \"invoke\"));\n+            assertThat(e, hasMethodInStackTraceAt(2, \"shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows\"));\n+        }\n+    }\n+}", "timestamp": 1413967013, "metainfo": ""}