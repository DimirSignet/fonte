{"sha": "7da0ee70a5f450976b024ab04a50eb3222b3cd48", "log": "Fixed the documentation  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401876", "commit": "\n--- a/src/org/mockito/Captor.java\n+++ b/src/org/mockito/Captor.java\n  *    ...\n  * }\n  * </pre>\n+ * <p>\n+ * One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.FIELD)\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n import java.lang.annotation.*;\n \n /**\n- * Allows shorthand wrapping of field instances in an spy object. <b>Warning</b> if you call\n- * <code>MockitoAnnotations.init(this)</code> in a super class this will not work. Since\n- *  fields in subclass are only instantiated after super class constructor has returned.\n- *\n- * <p>Example:\n+ * Allows shorthand wrapping of field instances in an spy object.\n+ * \n+ * <p>\n+ * Example:\n+ * \n  * <pre>\n  * public class Test{\n- *\n  *    &#64;Spy Foo spyOnFoo = new Foo();\n- *\n  *    &#64;Before\n  *    public void init(){\n  *       MockitoAnnotations.init(this);\n  *    ...\n  * }\n  * </pre>\n- * <p>Same as doing:\n+ * <p>\n+ * Same as doing:\n+ * \n  * <pre>\n- *    Foo spyOnFoo = Mockito.spy(new Foo());\n+ * Foo spyOnFoo = Mockito.spy(new Foo());\n  * </pre>\n+ * \n+ * <b>Warning</b> if you call <code>MockitoAnnotations.init(this)</code> in a\n+ * super class <b>constructor</b> then this will not work. It is because fields\n+ * in subclass are only instantiated after super class constructor has returned.\n+ * It's better to use &#64;Before.\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.FIELD)", "timestamp": 1267561348, "metainfo": ""}