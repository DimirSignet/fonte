{"sha": "01b9ebd8ab76460d8b2b59ec581a72aee08b89f9", "log": "added stack filtering for exceptions  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4038", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n package org.mockito;\n \n-import org.mockito.exceptions.MissingMethodInvocationException;\n+import org.mockito.exceptions.*;\n import org.mockito.internal.*;\n \n @SuppressWarnings(\"unchecked\")\n     }\n     \n     public static <T> T verify(T mock) {\n-        try {\n-            MockUtil.validateMock(mock);\n-            MockitoState.instance().verifyingStarted(VerifyingMode.anyTimes());\n-            return mock; \n-        } catch (RuntimeException e) {\n-            throw filterStackTrace(e);\n-        } catch (Error e) {\n-            throw filterStackTrace(e);\n-        }\n+        MockUtil.validateMock(mock);\n+        MockitoState.instance().verifyingStarted(VerifyingMode.anyTimes());\n+        return mock; \n     }\n     \n-    private static Error filterStackTrace(Error e) {\n-        return (Error) e.fillInStackTrace();\n-    }\n-\n-    private static RuntimeException filterStackTrace(RuntimeException e) {\n-        return (RuntimeException) e.fillInStackTrace();\n-    }\n-\n     public static <T> T verify(T mock, int exactNumberOfInvocations) {\n         MockUtil.validateMock(mock);\n         MockitoState.instance().verifyingStarted(VerifyingMode.times(exactNumberOfInvocations));\n--- /dev/null\n+++ b/src/org/mockito/exceptions/HasFilterableStackTrace.java\n+package org.mockito.exceptions;\n+\n+public interface HasFilterableStackTrace {\n+    \n+    void setStackTrace(StackTraceElement[] stackTrace);\n+    \n+    StackTraceElement[] getStackTrace();\n+    \n+    StackTraceElement[] getUnfilteredStackTrace();\n+\n+}\n--- a/src/org/mockito/exceptions/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/MockitoAssertionError.java\n package org.mockito.exceptions;\n \n-import java.util.*;\n \n-import org.mockito.exceptions.stacktrace.StackTraceFilter;\n-\n-public class MockitoAssertionError extends AssertionError {\n+public class MockitoAssertionError extends AssertionError implements HasFilterableStackTrace {\n \n     private static final long serialVersionUID = 1L;\n-    protected List<StackTraceElement> unfilteredStackTrace;\n+    protected StackTraceElement[] unfilteredStackTrace;\n \n-    public MockitoAssertionError(String message, StackTraceFilter filter) {\n+    public MockitoAssertionError(String message) {\n         super(message);\n+\n+        unfilteredStackTrace = getStackTrace();\n         \n-        unfilteredStackTrace = Arrays.asList(getStackTrace());\n-        int lastToRemove = -1;\n-        int i = 0;\n-        for (StackTraceElement trace : unfilteredStackTrace) {\n-            if (filter.isLastStackElementToRemove(trace)) {\n-                lastToRemove = i;\n-                break;\n-            }\n-            i++;\n-        }\n-        \n-        List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove+1, unfilteredStackTrace.size() - 1);\n-        setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+        MockitoStackTraceFilter filter = new MockitoStackTraceFilter();\n+        filter.filterStackTrace(this);\n     }\n     \n     public StackTraceElement[] getUnfilteredStackTrace() {\n-        return unfilteredStackTrace.toArray(new StackTraceElement[]{});\n+        return unfilteredStackTrace;\n     }\n }\n--- a/src/org/mockito/exceptions/MockitoException.java\n+++ b/src/org/mockito/exceptions/MockitoException.java\n package org.mockito.exceptions;\n \n-public class MockitoException extends RuntimeException {\n+public class MockitoException extends RuntimeException implements HasFilterableStackTrace {\n \n     private static final long serialVersionUID = 1L;\n \n+    protected StackTraceElement[] unfilteredStackTrace;\n+\n     public MockitoException(String message) {\n         super(message);\n+\n+        unfilteredStackTrace = getStackTrace();\n+        \n+        MockitoStackTraceFilter filter = new MockitoStackTraceFilter();\n+        filter.filterStackTrace(this);\n+    }\n+    \n+    public StackTraceElement[] getUnfilteredStackTrace() {\n+        return unfilteredStackTrace;\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/MockitoStackTraceFilter.java\n+/*\n+ * Copyright (c) 2007, Szczepan Faber. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+import java.util.*;\n+\n+public class MockitoStackTraceFilter {\n+    \n+    public boolean isLastStackElementToRemove(StackTraceElement e) {\n+        boolean firstOnStackIsMockitoClass = e.getClassName().equals(\"org.mockito.Mockito\");\n+        boolean firstOnStackIsMockObject = e.getClassName().contains(\"$$EnhancerByCGLIB$$\");\n+        return firstOnStackIsMockitoClass || firstOnStackIsMockObject;\n+    }\n+\n+    public void filterStackTrace(HasFilterableStackTrace hasFilterableStackTrace) {\n+        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasFilterableStackTrace.getStackTrace());\n+        int lastToRemove = -1;\n+        int i = 0;\n+        for (StackTraceElement trace : unfilteredStackTrace) {\n+            if (this.isLastStackElementToRemove(trace)) {\n+                lastToRemove = i;\n+                break;\n+            }\n+            i++;\n+        }\n+        \n+        List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove+1, unfilteredStackTrace.size() - 1);\n+        hasFilterableStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+    }\n+}\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n package org.mockito.exceptions;\n \n-import org.mockito.exceptions.stacktrace.LastClassIsCglibEnchantedFilter;\n \n public class NumberOfInvocationsAssertionError extends MockitoAssertionError {\n \n     private static final long serialVersionUID = 1L;\n \n     public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked) {\n-        super(\"Expected to be invoked \" + expectedInvoked + \" times but was \" + actuallyInvoked, new LastClassIsCglibEnchantedFilter());\n+        super(\"Expected to be invoked \" + expectedInvoked + \" times but was \" + actuallyInvoked);\n     }\n }\n--- a/src/org/mockito/exceptions/VerificationAssertionError.java\n+++ b/src/org/mockito/exceptions/VerificationAssertionError.java\n package org.mockito.exceptions;\n-\n-import org.mockito.exceptions.stacktrace.*;\n-\n \n public class VerificationAssertionError extends MockitoAssertionError {\n \n     private static final long serialVersionUID = 1L;\n \n-    private VerificationAssertionError(String message, StackTraceFilter filter) {\n-        super(message, filter);\n-    }\n-    \n-    public static VerificationAssertionError createNotInvokedError(String message) {\n-        return new VerificationAssertionError(message, new LastClassIsCglibEnchantedFilter());\n-    }\n-\n-    public static VerificationAssertionError createNoMoreInteractionsError(String message) {\n-        return new VerificationAssertionError(message, new LastClassIsMockitoFilter());\n+    public VerificationAssertionError(String message) {\n+        super(message);\n     }\n }\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n         return result;\n     }\n \n-    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n+    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) throws InvalidUseOfMatchersException {\n         if (matchers != null && matchers.size() != invocation.getArguments().length) {\n             throw new InvalidUseOfMatchersException(\n                     + invocation.getArguments().length\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n             } \n         } else {\n             if (actuallyInvoked == 0) {\n-                throw VerificationAssertionError.createNotInvokedError(\n+                throw new VerificationAssertionError(\n                         \"\\n\" +\n                         \"Not invoked: \" + invocation.toString());\n             }\n         for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n             if (!registeredInvocation.getInvocation().isVerified()) {\n                 String mockName = Namer.nameForMock(mock);\n-                throw VerificationAssertionError.createNoMoreInteractionsError(\n+                throw new VerificationAssertionError(\n                         \"\\n\" +\n                         verificationErrorMessage + \" on \" + mockName + \" but found: \" + registeredInvocation.toString());\n             }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         try {\n             verify(mock).get(0);\n             fail();\n-        } catch (UnfinishedVerificationException e) {}\n+        } catch (MockitoException e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (UnfinishedVerificationException e) {}\n+        } catch (MockitoException e) {}\n     }\n     \n     @Test\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (UnfinishedVerificationException e) {}\n+        } catch (MockitoException e) {}\n     }\n }\n--- a/test/org/mockito/internal/MockitoStateTest.java\n+++ b/test/org/mockito/internal/MockitoStateTest.java\n import static org.junit.Assert.*;\n \n import org.junit.*;\n-import org.mockito.exceptions.UnfinishedVerificationException;\n+import org.mockito.exceptions.MockitoException;\n \n public class MockitoStateTest {\n \n         try {\n             mockitoState.verifyingStarted(VerifyingMode.anyTimes());\n             fail();\n-        } catch (UnfinishedVerificationException e) {}\n+        } catch (MockitoException e) {}\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/usage/StackTrackeFilteringTest.java\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.*;\n+\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+public class StackTrackeFilteringTest {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerify() {\n+        try {\n+            verify(mock).simpleMethod();\n+        } catch (VerificationAssertionError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerify\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"verify\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyNoMoreInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+        } catch (VerificationAssertionError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"verifyNoMoreInteractions\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyZeroInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyZeroInteractions(mock);\n+        } catch (VerificationAssertionError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"verifyNoMoreInteractions\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceOnUnfinishedVerification() {\n+        verify(mock);\n+        try {\n+            verify(mock).oneArg(true); \n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceOnUnfinishedVerification\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"checkForUnfinishedVerification\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n+    \n+    //TODO add all other stack filtering stuff\n+}\n--- a/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n                     , e.getMessage());\n         }\n     }\n+    \n+    @Test\n+    public void shouldFilterStackTraceDetectStupidUseOfMatchersWhenVerifying() {\n+        mock.oneArg(true);\n+        eq(\"that's the stupid way\");\n+        eq(\"of using matchers\");\n+        try {\n+            Mockito.verify(mock).oneArg(true);\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {}\n+    }\n }", "timestamp": 1195580973, "metainfo": ""}