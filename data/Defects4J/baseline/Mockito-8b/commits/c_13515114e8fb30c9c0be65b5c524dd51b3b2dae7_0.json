{"sha": "13515114e8fb30c9c0be65b5c524dd51b3b2dae7", "log": "Merged asolntsev code simplification fixes (with some small modifications).", "commit": "\n--- a/src/org/mockito/AdditionalMatchers.java\n+++ b/src/org/mockito/AdditionalMatchers.java\n  */\n public class AdditionalMatchers {\n     \n-    private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n \n     /**\n      * argument greater than or equal the given value.\n      * @return <code>false</code>.\n      */\n     public static boolean and(boolean first, boolean second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnFalse();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnFalse();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static byte and(byte first, byte second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static char and(char first, char second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnChar();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnChar();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static double and(double first, double second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static float and(float first, float second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static int and(int first, int second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static long and(long first, long second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static short and(short first, short second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().returnZero();\n     }\n \n     /**\n      * @return <code>null</code>.\n      */\n     public static <T> T and(T first, T second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportAnd().<T>returnNull();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportAnd().<T>returnNull();\n     }\n \n     /**\n      * @return <code>false</code>.\n      */\n     public static boolean or(boolean first, boolean second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnFalse();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnFalse();\n     }\n \n     /**\n      * @return <code>null</code>.\n      */\n     public static <T> T or(T first, T second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().<T>returnNull();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().<T>returnNull();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static short or(short first, short second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static long or(long first, long second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static int or(int first, int second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static float or(float first, float second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static double or(double first, double second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static char or(char first, char second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnChar();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnChar();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static byte or(byte first, byte second) {\n-        return mockingProgress.getArgumentMatcherStorage().reportOr().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportOr().returnZero();\n     }\n \n     /**\n      * @return <code>null</code>.\n      */\n     public static <T> T not(T first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().<T>returnNull();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().<T>returnNull();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static short not(short first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static int not(int first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static long not(long first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static float not(float first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static double not(double first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static char not(char first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnChar();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnChar();\n     }\n \n     /**\n      * @return <code>false</code>.\n      */\n     public static boolean not(boolean first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnFalse();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnFalse();\n     }\n \n     /**\n      * @return <code>0</code>.\n      */\n     public static byte not(byte first) {\n-        return mockingProgress.getArgumentMatcherStorage().reportNot().returnZero();\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportNot().returnZero();\n     }\n \n     /**\n     }\n     \n     private static HandyReturnValues reportMatcher(ArgumentMatcher<?> matcher) {\n-        return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);\n     }\n }\n--- a/src/org/mockito/Answers.java\n+++ b/src/org/mockito/Answers.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.stubbing.answers.CallsRealMethods;\n     CALLS_REAL_METHODS(new CallsRealMethods())\n     ;\n \n-    private Answer<Object> implementation;\n+    private final Answer<Object> implementation;\n \n     private Answers(Answer<Object> implementation) {\n         this.implementation = implementation;\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n @SuppressWarnings(\"unchecked\")\n public class Matchers {\n     \n-    private static MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+    private static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n \n     /**\n      * Any <code>boolean</code>, <code>Boolean</code> or <code>null</code>.\n     }\n \n     private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n-        return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n+        return MOCKING_PROGRESS.getArgumentMatcherStorage().reportMatcher(matcher);\n     }\n }\n--- a/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.configuration;\n \n import org.mockito.ReturnValues;\n  * <p>\n  * See javadocs for {@link IMockitoConfiguration} on info how to configure Mockito\n  */\n-@SuppressWarnings(\"deprecation\")//supressed until ReturnValues are removed\n+@SuppressWarnings(\"deprecation\")//suppressed until ReturnValues are removed\n public class DefaultMockitoConfiguration implements IMockitoConfiguration {\n     \n     /* (non-Javadoc)\n--- a/src/org/mockito/configuration/IMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/IMockitoConfiguration.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.configuration;\n \n import org.mockito.ReturnValues;\n  * <p>\n  * If you have comments on Mockito configuration feature don't hesitate to write to mockito@googlegroups.com\n  */\n-@SuppressWarnings(\"deprecation\")//supressed until ReturnValues are removed\n+@SuppressWarnings(\"deprecation\")//suppressed until ReturnValues are removed\n public interface IMockitoConfiguration {\n \n     /**\n--- a/src/org/mockito/exceptions/base/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/base/MockitoAssertionError.java\n public class MockitoAssertionError extends AssertionError {\n \n     private static final long serialVersionUID = 1L;\n-    private StackTraceElement[] unfilteredStackTrace;\n+    private final StackTraceElement[] unfilteredStackTrace;\n \n     public MockitoAssertionError(String message) {\n         super(message);\n--- a/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n     \n     private static final long serialVersionUID = 1L;\n     private final String message;\n-    private StackTraceElement[] unfilteredStackTrace;\n+    private final StackTraceElement[] unfilteredStackTrace;\n \n     public ArgumentsAreDifferent(String message, String wanted, String actual) {\n         super(message, wanted, actual);\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.ReturnValues;\n /**\n  * Thread-safe wrapper on user-defined org.mockito.configuration.MockitoConfiguration implementation\n  */\n-@SuppressWarnings(\"deprecation\")//supressed until ReturnValues are removed\n+@SuppressWarnings(\"deprecation\")//suppressed until ReturnValues are removed\n public class GlobalConfiguration implements IMockitoConfiguration, Serializable {\n-    static final long serialVersionUID = -2860353062105505938L;\n+    private static final long serialVersionUID = -2860353062105505938L;\n     \n-    private static ThreadLocal<IMockitoConfiguration> globalConfiguration = new ThreadLocal<IMockitoConfiguration>();\n+    private static final ThreadLocal<IMockitoConfiguration> GLOBAL_CONFIGURATION = new ThreadLocal<IMockitoConfiguration>();\n \n     //back door for testing\n     IMockitoConfiguration getIt() {\n-        return globalConfiguration.get();\n+        return GLOBAL_CONFIGURATION.get();\n     }\n \n     public GlobalConfiguration() {\n         //Configuration should be loaded only once but I cannot really test it\n-        if (globalConfiguration.get() == null) {\n-            globalConfiguration.set(createConfig());\n+        if (GLOBAL_CONFIGURATION.get() == null) {\n+            GLOBAL_CONFIGURATION.set(createConfig());\n         }\n     }\n \n     }\n \n     public ReturnValues getReturnValues() {\n-        return globalConfiguration.get().getReturnValues();\n+        return GLOBAL_CONFIGURATION.get().getReturnValues();\n     }\n \n     public AnnotationEngine getAnnotationEngine() {\n-        return globalConfiguration.get().getAnnotationEngine();\n+        return GLOBAL_CONFIGURATION.get().getAnnotationEngine();\n     }\n \n     public boolean cleansStackTrace() {\n-        return globalConfiguration.get().cleansStackTrace();\n+        return GLOBAL_CONFIGURATION.get().cleansStackTrace();\n     }\n     \n     public boolean enableClassCache() {\n-        return globalConfiguration.get().enableClassCache();\n+        return GLOBAL_CONFIGURATION.get().enableClassCache();\n     }\n \n     public Answer<Object> getDefaultAnswer() {\n-        return globalConfiguration.get().getDefaultAnswer();\n+        return GLOBAL_CONFIGURATION.get().getDefaultAnswer();\n     }\n }\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.*;\n  */\n @SuppressWarnings({\"deprecation\", \"unchecked\"})\n public class InjectingAnnotationEngine implements AnnotationEngine {\n-    private AnnotationEngine delegate = new DefaultAnnotationEngine();\n-    private AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n+    private final AnnotationEngine delegate = new DefaultAnnotationEngine();\n+    private final AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n \n     /***\n      * Create a mock using {@link DefaultAnnotationEngine}\n--- a/src/org/mockito/internal/configuration/injection/MockInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n      * Ongoing configuration of the mock injector.\n      */\n     public static class OngoingMockInjection {\n-        private Set<Field> fields = new HashSet<Field>();\n-        private Set<Object> mocks = newMockSafeHashSet();\n-        private Object fieldOwner;\n-        private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n-        private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n+        private final Set<Field> fields = new HashSet<Field>();\n+        private final Set<Object> mocks = newMockSafeHashSet();\n+        private final Object fieldOwner;\n+        private final MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n+        private final MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n \n         private OngoingMockInjection(Field field, Object fieldOwner) {\n             this(Collections.singleton(field), fieldOwner);\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n public class PropertyAndSetterInjection extends MockInjectionStrategy {\n \n     private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n-    private Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();\n+    private final Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();\n \n-    private ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n+    private final ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n         public boolean isOut(Field object) {\n             return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());\n         }\n--- a/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n+++ b/src/org/mockito/internal/configuration/injection/scanner/MockScanner.java\n  * Scan mocks, and prepare them if needed.\n  */\n public class MockScanner {\n-    private MockUtil mockUtil = new MockUtil();\n+    private final MockUtil mockUtil = new MockUtil();\n     private final Object instance;\n     private final Class<?> clazz;\n \n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n     private static final long serialVersionUID = 7411152578314420778L;\n     private static final String MOCKITO_PROXY_MARKER = \"MockitoProxyMarker\";\n     private boolean instanceLocalCurrentlySerializingFlag = false;\n-    private Lock mutex = new ReentrantLock();\n+    private final Lock mutex = new ReentrantLock();\n \n     public boolean isWriteReplace(Method method) {\n         return  method.getReturnType() == Object.class\n \n \n         private static final long serialVersionUID = -7600267929109286514L;\n-        private byte[] serializedMock;\n-        private Class typeToMock;\n-        private Set<Class> extraInterfaces;\n+        private final byte[] serializedMock;\n+        private final Class typeToMock;\n+        private final Set<Class> extraInterfaces;\n         /**\n          * Creates the wrapper that be used in the serialization stream.\n          *\n      * </p>\n      */\n     public static class MockitoMockObjectInputStream extends ObjectInputStream {\n-        private Class typeToMock;\n-        private Set<Class> extraInterfaces;\n+        private final Class typeToMock;\n+        private final Set<Class> extraInterfaces;\n \n         public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {\n             super(in) ;\n      */\n     private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n         private static final String NOTHING = \"\";\n-        private MockUtil mockUtil = new MockUtil();\n \n         public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n             super(out);\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n     private static final long serialVersionUID = 6182795666612683784L;\n     private final InternalMockHandler handler;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n-    ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n+    final ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n     private final MockCreationSettings mockSettings;\n-    private AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();\n+    private final AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();\n \n     public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {\n         this.handler = handler;\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n     //TODO: in order to provide decent exception message when objenesis is not found,\n     //have a constructor in this class that tries to instantiate ObjenesisStd and if it fails then show decent exception that dependency is missing\n     //TODO: for the same reason catch and give better feedback when hamcrest core is not found.\n-    private ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());\n+    private final ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());\n     \n     private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {\n         @Override\n--- a/src/org/mockito/internal/debugging/LoggingListener.java\n+++ b/src/org/mockito/internal/debugging/LoggingListener.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n import static org.mockito.internal.util.StringJoiner.join;\n \n public class LoggingListener implements FindingsListener {\n-    private boolean warnAboutUnstubbed;\n+    private final boolean warnAboutUnstubbed;\n     private final MockitoLogger logger;\n \n     public LoggingListener(boolean warnAboutUnstubbed, MockitoLogger logger) {\n--- a/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n+++ b/src/org/mockito/internal/debugging/MockitoDebuggerImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n import org.mockito.MockitoDebugger;\n \n public class MockitoDebuggerImpl implements MockitoDebugger {\n \n-    private AllInvocationsFinder allInvocationsFinder = new AllInvocationsFinder();\n-    private UnusedStubsFinder unusedStubsFinder = new UnusedStubsFinder();\n+    private final AllInvocationsFinder allInvocationsFinder = new AllInvocationsFinder();\n+    private final UnusedStubsFinder unusedStubsFinder = new UnusedStubsFinder();\n \n     public String printInvocations(Object ... mocks) {\n         String out = \"\";\n--- a/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinterImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n-\n-import java.util.List;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.MockitoLogger;\n import org.mockito.internal.util.SimpleMockitoLogger;\n import org.mockito.invocation.Invocation;\n \n+import java.util.List;\n+\n public class WarningsPrinterImpl {\n \n     private final boolean warnAboutUnstubbed;\n-    private WarningsFinder finder;\n+    private final WarningsFinder finder;\n \n     public WarningsPrinterImpl(List<Invocation> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n         this(unusedStubs, unstubbedInvocations, false);\n--- a/src/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java\n+++ b/src/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java\n import java.io.Serializable;\n \n public class ConditionalStackTraceFilter implements Serializable {\n-    static final long serialVersionUID = -8085849703510292641L;\n+    private static final long serialVersionUID = -8085849703510292641L;\n     \n-    private IMockitoConfiguration config = new GlobalConfiguration();\n-    private StackTraceFilter filter = new StackTraceFilter();\n+    private final IMockitoConfiguration config = new GlobalConfiguration();\n+    private final StackTraceFilter filter = new StackTraceFilter();\n     \n     public void filter(Throwable throwable) {\n         if (!config.cleansStackTrace()) {\n--- a/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n+++ b/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n \n     static final long serialVersionUID = -5499819791513105700L;\n \n-    private static StackTraceCleaner cleaner =\n+    private static final StackTraceCleaner CLEANER =\n             ClassPathLoader.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());\n     \n     /**\n         int lastBad = -1;\n         int firstBad = -1;\n         for (int i = 0; i < unfilteredStackTrace.size(); i++) {\n-            if (!cleaner.isOut(unfilteredStackTrace.get(i))) {\n+            if (!CLEANER.isOut(unfilteredStackTrace.get(i))) {\n                 continue;\n             }\n             lastBad = i;\n--- a/src/org/mockito/internal/handler/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/handler/InvocationNotifierHandler.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.handler;\n \n import org.mockito.exceptions.Reporter;\n  */\n class InvocationNotifierHandler<T> implements MockHandler, InternalMockHandler<T> {\n \n-    private List<InvocationListener> invocationListeners;\n-    private InternalMockHandler<T> mockHandler;\n+    private final List<InvocationListener> invocationListeners;\n+    private final InternalMockHandler<T> mockHandler;\n \n     public InvocationNotifierHandler(InternalMockHandler<T> mockHandler, MockCreationSettings settings) {\n         this.mockHandler = mockHandler;\n--- a/src/org/mockito/internal/invocation/SerializableMethod.java\n+++ b/src/org/mockito/internal/invocation/SerializableMethod.java\n  */\n package org.mockito.internal.invocation;\n \n+import org.mockito.exceptions.base.MockitoException;\n+\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n import java.util.Arrays;\n \n-import org.mockito.exceptions.base.MockitoException;\n-\n public class SerializableMethod implements Serializable, MockitoMethod {\n \n     private static final long serialVersionUID = 6005610965006048445L;\n-    \n-    private Class<?> declaringClass;\n-    private String methodName;\n-    private Class<?>[] parameterTypes;\n-    private Class<?> returnType;\n-    private Class<?>[] exceptionTypes;\n-    private boolean isVarArgs;\n-    private boolean isAbstract;\n+\n+    private final Class<?> declaringClass;\n+    private final String methodName;\n+    private final Class<?>[] parameterTypes;\n+    private final Class<?> returnType;\n+    private final Class<?>[] exceptionTypes;\n+    private final boolean isVarArgs;\n+    private final boolean isAbstract;\n \n     public SerializableMethod(Method method) {\n         declaringClass = method.getDeclaringClass();\n         return isVarArgs;\n     }\n \n-    @Override\n     public boolean isAbstract() {\n         return isAbstract;\n     }\n--- a/src/org/mockito/internal/invocation/StubInfoImpl.java\n+++ b/src/org/mockito/internal/invocation/StubInfoImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.mockito.invocation.DescribedInvocation;\n \n public class StubInfoImpl implements StubInfo, Serializable {\n     private static final long serialVersionUID = 2125827349332068867L;\n-    private DescribedInvocation stubbedAt;\n+    private final DescribedInvocation stubbedAt;\n \n     public StubInfoImpl(DescribedInvocation stubbedAt) {\n         this.stubbedAt = stubbedAt;\n--- a/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n+++ b/src/org/mockito/internal/listeners/CollectCreatedMocks.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n-\n-import org.mockito.MockSettings;\n \n import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class CollectCreatedMocks implements MockingStartedListener {\n     \n-    private List toBeFilled;\n+    private final List toBeFilled;\n \n     public CollectCreatedMocks(List toBeFilled) {\n         this.toBeFilled = toBeFilled;\n--- a/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n+++ b/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.listeners;\n \n import org.mockito.invocation.DescribedInvocation;\n import org.mockito.invocation.Invocation;\n import org.mockito.listeners.MethodInvocationReport;\n \n+import static org.mockito.internal.matchers.Equality.areEqual;\n+\n /**\n  * Report on a method call\n  */\n public class NotifiedMethodInvocationReport implements MethodInvocationReport {\n     private final Invocation invocation;\n-    private Object returnedValue;\n-    private Throwable throwable;\n+    private final Object returnedValue;\n+    private final Throwable throwable;\n \n \n     /**\n     public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n         this.invocation = invocation;\n         this.returnedValue = returnedValue;\n+        this.throwable = null;\n     }\n \n     /**\n      */\n     public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n         this.invocation = invocation;\n+        this.returnedValue = null;\n         this.throwable = throwable;\n     }\n \n \n         NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;\n \n-        if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;\n-        if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)\n-            return false;\n-        if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;\n-\n-        return true;\n+        return areEqual(invocation, that.invocation) &&\n+               areEqual(returnedValue, that.returnedValue) &&\n+               areEqual(throwable, that.throwable);\n     }\n \n     public int hashCode() {\n--- a/src/org/mockito/internal/matchers/CapturingMatcher.java\n+++ b/src/org/mockito/internal/matchers/CapturingMatcher.java\n public class CapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {\n     \n     private static final long serialVersionUID = 4274067078639307295L;\n-    private LinkedList<Object> arguments = new LinkedList<Object>();\n+    private final LinkedList<Object> arguments = new LinkedList<Object>();\n \n     /* (non-Javadoc)\n      * @see org.mockito.ArgumentMatcher#matches(java.lang.Object)\n--- a/src/org/mockito/internal/matchers/Equals.java\n+++ b/src/org/mockito/internal/matchers/Equals.java\n     }\n \n     public String describe(Object object) {\n-        String text = quoting();\n-        text+=\"\" + object;\n-        text+= quoting();\n-        return text;\n+        return quoting() + object + quoting();\n     }\n \n     private String quoting() {\n--- a/src/org/mockito/internal/matchers/LocalizedMatcher.java\n+++ b/src/org/mockito/internal/matchers/LocalizedMatcher.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.matchers;\n \n-import java.io.Serializable;\n-\n-import org.hamcrest.*;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.SelfDescribing;\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.invocation.Location;\n+\n+import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class LocalizedMatcher implements Matcher, ContainsExtraTypeInformation, CapturesArguments, MatcherDecorator, Serializable {\n \n     private static final long serialVersionUID = 6748641229659825725L;\n     private final Matcher actualMatcher;\n-    private Location location;\n+    private final Location location;\n \n     public LocalizedMatcher(Matcher actualMatcher) {\n         this.actualMatcher = actualMatcher;\n--- a/src/org/mockito/internal/matchers/VarargCapturingMatcher.java\n+++ b/src/org/mockito/internal/matchers/VarargCapturingMatcher.java\n @SuppressWarnings(\"unchecked\")\n public class VarargCapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {\n     private static final long serialVersionUID = 4057053345838026645L;\n-    private LinkedList<List<T>> arguments = new LinkedList<List<T>>();\n+    private final LinkedList<List<T>> arguments = new LinkedList<List<T>>();\n \n     public boolean matches(Object argument) {\n         return true;\n--- a/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java\n+++ b/src/org/mockito/internal/matchers/apachecommons/EqualsBuilder.java\n      * @since 2.0\n      */\n     public EqualsBuilder appendSuper(boolean superEquals) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = superEquals;\n+        isEquals &= superEquals;\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(Object lhs, Object rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(long lhs, long rhs) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = (lhs == rhs);\n+        isEquals &= (lhs == rhs);\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(int lhs, int rhs) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = (lhs == rhs);\n+        isEquals &= (lhs == rhs);\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(short lhs, short rhs) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = (lhs == rhs);\n+        isEquals &= (lhs == rhs);\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(char lhs, char rhs) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = (lhs == rhs);\n+        isEquals &= (lhs == rhs);\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(byte lhs, byte rhs) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = (lhs == rhs);\n+        isEquals &= (lhs == rhs);\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(double lhs, double rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(float lhs, float rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n      * @return EqualsBuilder - used to chain calls.\n       */\n     public EqualsBuilder append(boolean lhs, boolean rhs) {\n-        if (isEquals == false) {\n-            return this;\n-        }\n-        isEquals = (lhs == rhs);\n+        isEquals &= (lhs == rhs);\n         return this;\n     }\n \n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(long[] lhs, long[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(int[] lhs, int[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(short[] lhs, short[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(char[] lhs, char[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(double[] lhs, double[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(float[] lhs, float[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n      * @return EqualsBuilder - used to chain calls.\n      */\n     public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n-        if (isEquals == false) {\n+        if (!isEquals) {\n             return this;\n         }\n         if (lhs == rhs) {\n--- a/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n+++ b/src/org/mockito/internal/progress/ArgumentMatcherStorageImpl.java\n \n     public static final int TWO_SUB_MATCHERS = 2;\n     public static final int ONE_SUB_MATCHER = 1;\n-    private Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();\n+    private final Stack<LocalizedMatcher> matcherStack = new Stack<LocalizedMatcher>();\n     \n     /* (non-Javadoc)\n      * @see org.mockito.internal.progress.ArgumentMatcherStorage#reportMatcher(org.hamcrest.Matcher)\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n \n package org.mockito.internal.progress;\n \n-import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.Localized;\n     }\n \n     public void mockingStarted(Object mock, Class classToMock) {\n-        if (listener != null && listener instanceof MockingStartedListener) {\n+        if (listener instanceof MockingStartedListener) {\n             ((MockingStartedListener) listener).mockingStarted(mock, classToMock);\n         }\n         validateMostStuff();\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n \n package org.mockito.internal.progress;\n \n-import java.io.Serializable;\n-\n-import org.mockito.MockSettings;\n import org.mockito.internal.listeners.MockingProgressListener;\n import org.mockito.invocation.Invocation;\n import org.mockito.verification.VerificationMode;\n+\n+import java.io.Serializable;\n \n @SuppressWarnings(\"unchecked\")\n public class ThreadSafeMockingProgress implements MockingProgress, Serializable {\n     \n     private static final long serialVersionUID = 6839454041642082618L;\n-    private static ThreadLocal<MockingProgress> mockingProgress = new ThreadLocal<MockingProgress>();\n+    private static final ThreadLocal<MockingProgress> mockingProgress = new ThreadLocal<MockingProgress>();\n \n     static MockingProgress threadSafely() {\n         if (mockingProgress.get() == null) {\n--- a/src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java\n+++ b/src/org/mockito/internal/runners/JUnit45AndHigherRunnerImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.runners;\n \n import org.junit.runner.Description;\n \n public class JUnit45AndHigherRunnerImpl implements RunnerImpl {\n \n-    private BlockJUnit4ClassRunner runner;\n+    private final BlockJUnit4ClassRunner runner;\n \n     public JUnit45AndHigherRunnerImpl(Class<?> klass) throws InitializationError {\n         runner = new BlockJUnit4ClassRunner(klass) {\n--- a/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing;\n \n import org.mockito.internal.stubbing.answers.DoesNothing;\n \n public class VoidMethodStubbableImpl<T> implements VoidMethodStubbable<T> {\n     private final T mock;\n-    private InvocationContainerImpl invocationContainerImpl;\n+    private final InvocationContainerImpl invocationContainerImpl;\n \n     public VoidMethodStubbableImpl(T mock, InvocationContainerImpl invocationContainerImpl) {\n         this.mock = mock;\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n \n public class AnswersValidator {\n \n-    private Reporter reporter = new Reporter();\n+    private final Reporter reporter = new Reporter();\n     \n     public void validate(Answer<?> answer, Invocation invocation) {\n         MethodInfo methodInfo = new MethodInfo(invocation);\n--- a/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+++ b/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n  */\n public class MethodInfo implements AbstractAwareMethod {\n \n-    private Method method;\n+    private final Method method;\n \n     public MethodInfo(Invocation theInvocation) {\n         this.method = theInvocation.getMethod();\n         return method.getDeclaringClass().isInterface();\n     }\n \n-    @Override\n     public boolean isAbstract() {\n         return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n     }\n--- a/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n \n public class ThrowsExceptionClass implements Answer<Object>, Serializable {\n \n-    private Class<? extends Throwable> throwableClass;\n+    private final Class<? extends Throwable> throwableClass;\n     private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n \n     public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/Answers.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/Answers.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.mockito.Mockito;\n     CALLS_REAL_METHODS(new CallsRealMethods())\n \t;\n \n-    private Answer<Object> implementation;\n+    private final Answer<Object> implementation;\n \n     private Answers(Answer<Object> implementation) {\n         this.implementation = implementation;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n \n     private static class DeeplyStubbedAnswer implements Answer<Object>, Serializable {\n         @SuppressWarnings(\"serial\") // serialization will fail with a nice message if mock not serializable\n-        private Object mock;\n+        private final Object mock;\n \n         DeeplyStubbedAnswer(Object mock) {\n             this.mock = mock;\n         }\n-        @Override\n         public Object answer(InvocationOnMock invocation) throws Throwable {\n             return mock;\n         }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n-\n-import java.io.Serializable;\n \n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n+import java.io.Serializable;\n+\n public class ReturnsMocks implements Answer<Object>, Serializable {\n     \n     private static final long serialVersionUID = -6755257986994634579L;\n-    private MockitoCore mockitoCore = new MockitoCore();\n-    private Answer<Object> delegate = new ReturnsMoreEmptyValues();\n+    private final MockitoCore mockitoCore = new MockitoCore();\n+    private final Answer<Object> delegate = new ReturnsMoreEmptyValues();\n     \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         Object ret = delegate.answer(invocation);\n         \n         return mockitoCore.mock(clazz, new MockSettingsImpl().defaultAnswer(this));\n     }\n-}\n+}\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.java\n \n package org.mockito.internal.stubbing.defaultanswers;\n \n-import java.io.Serializable;\n-import java.lang.reflect.Array;\n-\n import org.mockito.Mockito;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n \n /**\n  * It's likely this implementation will be used by default by every Mockito 2.0 mock.\n public class ReturnsMoreEmptyValues implements Answer<Object>, Serializable {\n     \n     private static final long serialVersionUID = -2816745041482698471L;\n-    private Answer<Object> delegate = new ReturnsEmptyValues();\n+    private final Answer<Object> delegate = new ReturnsEmptyValues();\n     \n     /* (non-Javadoc)\n      * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n--- a/src/org/mockito/internal/util/DefaultMockingDetails.java\n+++ b/src/org/mockito/internal/util/DefaultMockingDetails.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-\n import org.mockito.MockingDetails;\n-import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.Invocation;\n+\n+import java.util.Collection;\n \n /**\n  * Class to inspect any object, and identify whether a particular object is either a mock or a spy.  This is\n  */\n public class DefaultMockingDetails implements MockingDetails {\n \n-    private Object toInspect;\n-    private MockUtil delegate;\n+    private final Object toInspect;\n+    private final MockUtil delegate;\n \n     public DefaultMockingDetails(Object toInspect, MockUtil delegate){\n         this.toInspect = toInspect;\n      */\n     public boolean isSpy(){\n         return delegate.isSpy( toInspect );\n-    }\n-    \n-    public Collection<Invocation> getInvocations() {\n-    \treturn delegate.getMockHandler(toInspect).getInvocationContainer().getInvocations();\n+    }\n+    \n+    public Collection<Invocation> getInvocations() {\n+    \treturn delegate.getMockHandler(toInspect).getInvocationContainer().getInvocations();\n     }\n }\n \n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n @SuppressWarnings(\"unchecked\")\n public class Primitives {\n \n-    private static Map<Class<?>, Class<?>> primitiveTypes = new HashMap<Class<?>, Class<?>>();\n-    private static Map<Class<?>, Object> primitiveOrWrapperDefaultValues = new HashMap<Class<?>, Object>();\n+    private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>();\n+    private static final Map<Class<?>, Object> PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES = new HashMap<Class<?>, Object>();\n \n \n     /**\n         if (clazz.isPrimitive()) {\n             return clazz;\n         }\n-        return (Class<T>) primitiveTypes.get(clazz);\n+        return (Class<T>) PRIMITIVE_TYPES.get(clazz);\n     }\n \n     /**\n      * @return <code>true</code> if primitive or wrapper, <code>false</code> otherwise.\n      */\n     public static boolean isPrimitiveOrWrapper(Class<?> type) {\n-        return primitiveOrWrapperDefaultValues.containsKey(type);\n+        return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.containsKey(type);\n     }\n \n     /**\n      *         <code>null</code> if the type is neither a primitive nor a wrapper\n      */\n     public static <T> T defaultValueForPrimitiveOrWrapper(Class<T> primitiveOrWrapperType) {\n-        return (T) primitiveOrWrapperDefaultValues.get(primitiveOrWrapperType);\n+        return (T) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.get(primitiveOrWrapperType);\n     }\n \n \n     static {\n-        primitiveTypes.put(Boolean.class, Boolean.TYPE);\n-        primitiveTypes.put(Character.class, Character.TYPE);\n-        primitiveTypes.put(Byte.class, Byte.TYPE);\n-        primitiveTypes.put(Short.class, Short.TYPE);\n-        primitiveTypes.put(Integer.class, Integer.TYPE);\n-        primitiveTypes.put(Long.class, Long.TYPE);\n-        primitiveTypes.put(Float.class, Float.TYPE);\n-        primitiveTypes.put(Double.class, Double.TYPE);\n+        PRIMITIVE_TYPES.put(Boolean.class, Boolean.TYPE);\n+        PRIMITIVE_TYPES.put(Character.class, Character.TYPE);\n+        PRIMITIVE_TYPES.put(Byte.class, Byte.TYPE);\n+        PRIMITIVE_TYPES.put(Short.class, Short.TYPE);\n+        PRIMITIVE_TYPES.put(Integer.class, Integer.TYPE);\n+        PRIMITIVE_TYPES.put(Long.class, Long.TYPE);\n+        PRIMITIVE_TYPES.put(Float.class, Float.TYPE);\n+        PRIMITIVE_TYPES.put(Double.class, Double.TYPE);\n     }\n \n     static {\n-        primitiveOrWrapperDefaultValues.put(Boolean.class, false);\n-        primitiveOrWrapperDefaultValues.put(Character.class, '\\u0000');\n-        primitiveOrWrapperDefaultValues.put(Byte.class, (byte) 0);\n-        primitiveOrWrapperDefaultValues.put(Short.class, (short) 0);\n-        primitiveOrWrapperDefaultValues.put(Integer.class, 0);\n-        primitiveOrWrapperDefaultValues.put(Long.class, 0L);\n-        primitiveOrWrapperDefaultValues.put(Float.class, 0F);\n-        primitiveOrWrapperDefaultValues.put(Double.class, 0D);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Boolean.class, false);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Character.class, '\\u0000');\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Byte.class, (byte) 0);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Short.class, (short) 0);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Integer.class, 0);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Long.class, 0L);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Float.class, 0F);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(Double.class, 0D);\n \n-        primitiveOrWrapperDefaultValues.put(boolean.class, false);\n-        primitiveOrWrapperDefaultValues.put(char.class, '\\u0000');\n-        primitiveOrWrapperDefaultValues.put(byte.class, (byte) 0);\n-        primitiveOrWrapperDefaultValues.put(short.class, (short) 0);\n-        primitiveOrWrapperDefaultValues.put(int.class, 0);\n-        primitiveOrWrapperDefaultValues.put(long.class, 0L);\n-        primitiveOrWrapperDefaultValues.put(float.class, 0F);\n-        primitiveOrWrapperDefaultValues.put(double.class, 0D);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(boolean.class, false);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(char.class, '\\u0000');\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(byte.class, (byte) 0);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(short.class, (short) 0);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(int.class, 0);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(long.class, 0L);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(float.class, 0F);\n+        PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES.put(double.class, 0D);\n     }\n }\n--- a/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsMockWrapper.java\n  */\n public class HashCodeAndEqualsMockWrapper {\n \n-    private Object mockInstance;\n+    private final Object mockInstance;\n \n     public HashCodeAndEqualsMockWrapper(Object mockInstance) {\n         this.mockInstance = mockInstance;\n--- a/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n+++ b/src/org/mockito/internal/util/collections/HashCodeAndEqualsSafeSet.java\n  */\n public class HashCodeAndEqualsSafeSet implements Set<Object> {\n \n-    private HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n+    private final HashSet<HashCodeAndEqualsMockWrapper> backingHashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n \n     public Iterator<Object> iterator() {\n         return new Iterator<Object>() {\n-            private Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n+            private final Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n \n             public boolean hasNext() {\n                 return iterator.hasNext();\n--- a/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n+++ b/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.Field;\n     private static final String SET_PREFIX = \"set\";\n \n     private final Object target;\n-    private boolean reportNoSetterFound;\n+    private final boolean reportNoSetterFound;\n     private final Field field;\n \n     /**\n--- a/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n  * Report on field initialization\n  */\n public class FieldInitializationReport {\n-    private Object fieldInstance;\n-    private boolean wasInitialized;\n-    private boolean wasInitializedUsingConstructorArgs;\n+    private final Object fieldInstance;\n+    private final boolean wasInitialized;\n+    private final boolean wasInitializedUsingConstructorArgs;\n \n     public FieldInitializationReport(Object fieldInstance, boolean wasInitialized, boolean wasInitializedUsingConstructorArgs) {\n         this.fieldInstance = fieldInstance;\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util.reflection;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n-\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.MockUtil;\n \n /**\n  * Initialize a field with type instance if a default constructor can be found.\n  */\n public class FieldInitializer {\n \n-    private Object fieldOwner;\n-    private Field field;\n-    private ConstructorInstantiator instantiator;\n+    private final Object fieldOwner;\n+    private final Field field;\n+    private final ConstructorInstantiator instantiator;\n \n \n     /**\n      * </p>\n      */\n     static class NoArgConstructorInstantiator implements ConstructorInstantiator {\n-        private Object testClass;\n-        private Field field;\n+        private final Object testClass;\n+        private final Field field;\n \n         /**\n          * Internal, checks are done by FieldInitializer.\n      * </p>\n      */\n     static class ParameterizedConstructorInstantiator implements ConstructorInstantiator {\n-        private Object testClass;\n-        private Field field;\n-        private ConstructorArgumentResolver argResolver;\n-\t    private final MockUtil mockUtil = new MockUtil();\n-        private Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {\n+        private final Object testClass;\n+        private final Field field;\n+        private final ConstructorArgumentResolver argResolver;\n+\t      private final MockUtil mockUtil = new MockUtil();\n+        private final Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {\n             public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {\n \t            int argLengths = constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n \t            if (argLengths == 0) {\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n      */\n     public Class getGenericType(Field field) {        \n         Type generic = field.getGenericType();\n-        if (generic != null && generic instanceof ParameterizedType) {\n+        if (generic instanceof ParameterizedType) {\n             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n             if (actual instanceof Class) {\n                 return (Class) actual;\n--- a/src/org/mockito/internal/util/reflection/InstanceField.java\n+++ b/src/org/mockito/internal/util/reflection/InstanceField.java\n         if (o == null || getClass() != o.getClass()) return false;\n \n         InstanceField that = (InstanceField) o;\n-\n-        if (!field.equals(that.field)) return false;\n-        if (!instance.equals(that.instance)) return false;\n-\n-        return true;\n+        return field.equals(that.field) && instance.equals(that.instance);\n     }\n \n     @Override\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.verification;\n-\n-import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.invocation.Invocation;\n+\n+import java.util.List;\n \n public class VerificationDataImpl implements VerificationData {\n \n         return wanted;\n     }\n \n-    void assertWantedIsVerifiable() {\n+    private void assertWantedIsVerifiable() {\n         if (wanted == null) {\n             return;\n         }\n-        ObjectMethodsGuru o = new ObjectMethodsGuru();\n+        ObjectMethodsGuru o =  new ObjectMethodsGuru();\n         if (o.isToString(wanted.getMethod())) {\n             new Reporter().cannotVerifyToString();\n         }\n--- a/src/org/mockito/invocation/InvocationOnMock.java\n+++ b/src/org/mockito/invocation/InvocationOnMock.java\n     * @param clazz argument type\n     * @return casted argument on position\n     */\n-    <T extends Object> T getArgumentAt(int index, Class<T> clazz);\n+    <T> T getArgumentAt(int index, Class<T> clazz);\n \n \n     /**\n--- a/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ConsoleSpammingMockitoJUnitRunner.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.runners;\n-\n-import java.lang.reflect.InvocationTargetException;\n \n import org.junit.runner.Description;\n import org.junit.runner.Runner;\n import org.mockito.internal.runners.RunnerImpl;\n import org.mockito.internal.util.ConsoleMockitoLogger;\n import org.mockito.internal.util.MockitoLogger;\n+\n+import java.lang.reflect.InvocationTargetException;\n \n /**\n  * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n public class ConsoleSpammingMockitoJUnitRunner extends Runner implements Filterable {\n \n     private final MockitoLogger logger;\n-    private RunnerImpl runner;\n+    private final RunnerImpl runner;\n     \n     public ConsoleSpammingMockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {\n         this(new ConsoleMockitoLogger(), new RunnerFactory().create(klass));\n--- a/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/VerboseMockitoJUnitRunner.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.runners;\n-\n-import java.lang.reflect.InvocationTargetException;\n \n import org.junit.runner.Description;\n import org.junit.runner.Runner;\n import org.mockito.internal.runners.RunnerImpl;\n import org.mockito.internal.util.junit.JUnitFailureHacker;\n \n+import java.lang.reflect.InvocationTargetException;\n+\n /**\n  * Experimental implementation that suppose to improve tdd/testing experience. \n  * Don't hesitate to send feedback to mockito@googlegroups.com\n  * adds extra Mocktio hints to the exception message. \n  * The point is that Mockito should help the tdd developer to quickly figure out if the test fails for the right reason and track the reason. \n  * <p>\n- * The implemntation is pretty hacky - it uses brute force of reflection to modify the exception message and add extra mockito hints.\n+ * The implementation is pretty hacky - it uses brute force of reflection to modify the exception message and add extra mockito hints.\n  * You've been warned. \n  * <p>\n  * Do you think it is useful or not? Drop us an email at mockito@googlegroups.com\n  */\n public class VerboseMockitoJUnitRunner extends Runner implements Filterable {\n \n-    private RunnerImpl runner;\n+    private final RunnerImpl runner;\n \n     public VerboseMockitoJUnitRunner(Class<?> klass) throws InvocationTargetException {\n         this(new RunnerFactory().create(klass));\n--- a/test/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java\n+++ b/test/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java\n \n public class StackTraceFilterTest extends TestBase {\n     \n-    private StackTraceFilter filter = new StackTraceFilter();\n+    private final StackTraceFilter filter = new StackTraceFilter();\n     \n     @Test\n     public void shouldFilterOutCglibGarbage() {\n--- a/test/org/mockito/internal/matchers/ComparableMatchersTest.java\n+++ b/test/org/mockito/internal/matchers/ComparableMatchersTest.java\n \n package org.mockito.internal.matchers;\n \n-import java.math.BigDecimal;\n-\n import org.junit.Test;\n import org.mockitoutil.TestBase;\n+\n+import java.math.BigDecimal;\n \n public class ComparableMatchersTest extends TestBase {\n \n     }\n \n     @Test\n-    public void testGreateThan() {\n+    public void testGreaterThan() {\n         test(new GreaterThan<String>(\"b\"), false, true, false, \"gt\");\n     }\n \n     }\n \n     @Test\n-    public void testGreateOrEqual() {\n+    public void testGreaterOrEqual() {\n         test(new GreaterOrEqual<String>(\"b\"), false, true, true, \"geq\");\n     }\n \n     public void testCompareEqual() {\n         test(new CompareEqual<String>(\"b\"), false, false, true, \"cmpEq\");\n \n-        // Make sure it works when equals provide a different result than\n-        // compare\n-        CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(\n-                new BigDecimal(\"5.00\"));\n+        // Make sure it works when equals provide a different result than compare\n+        CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(new BigDecimal(\"5.00\"));\n         assertTrue(cmpEq.matches(new BigDecimal(\"5\")));\n     }\n ", "timestamp": 1397320391, "metainfo": ""}