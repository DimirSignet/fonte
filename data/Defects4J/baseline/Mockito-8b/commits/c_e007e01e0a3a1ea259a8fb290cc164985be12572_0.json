{"sha": "e007e01e0a3a1ea259a8fb290cc164985be12572", "log": "Support @Spy AbstractClass/Interface  Fixes #126", "commit": "\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.*;\n-import org.mockito.configuration.AnnotationEngine;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.reflection.FieldInitializationReport;\n-import org.mockito.internal.util.reflection.FieldInitializer;\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-\n-import static org.mockito.Mockito.withSettings;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import org.mockito.Captor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n \n /**\n  * Process fields annotated with &#64;Spy.\n         Field[] fields = context.getDeclaredFields();\n         for (Field field : fields) {\n             if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n-                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+                field.setAccessible(true);\n                 Object instance = null;\n                 try {\n-                    FieldInitializationReport report = new FieldInitializer(testInstance, field).initialize();\n-                    instance = report.fieldInstance();\n-                } catch (MockitoException e) {\n-                    new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n-                }\n-                try {\n+                    instance = field.get(testInstance);\n                     if (new MockUtil().isMock(instance)) {\n                         // instance has been spied earlier\n                         // for example happens when MockitoAnnotations.initMocks is called two times.\n                         Mockito.reset(instance);\n-                    } else {\n-                        field.setAccessible(true);\n+                    } else if (instance != null) {\n                         field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                 .spiedInstance(instance)\n                                 .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                 .name(field.getName())));\n+                    } else {\n+                    \tMockSettings settings = withSettings()\n+                    \t\t\t.useConstructor()\n+                    \t\t\t.defaultAnswer(Mockito.CALLS_REAL_METHODS)\n+                    \t\t\t.name(field.getName());\n+                    \tif (field.getType().getEnclosingClass() != null\n+                    \t\t\t&& !Modifier.isStatic(field.getType().getModifiers())\n+                    \t\t\t&& field.getType().getEnclosingClass().isInstance(testInstance)) {\n+                    \t\tsettings.outerInstance(testInstance);\n+                    \t}\n+\t\t\t\t\t\tfield.set(testInstance, Mockito.mock(field.getType(), settings));\n                     }\n                 } catch (IllegalAccessException e) {\n                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n     }\n \n     public boolean isSpy(Object mock) {\n-        return isMockitoMock(mock) && getMockSettings(mock).getSpiedInstance() != null;\n+        return isMockitoMock(mock) &&\n+        \t\t(getMockSettings(mock).getSpiedInstance() != null\n+        \t\t    || getMockSettings(mock).isUsingConstructor());\n     }\n \n     private <T> boolean isMockitoMock(T mock) {\n--- a/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingOnPurposeBecauseIncorrectAnnotationUsage.java\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingOnPurposeBecauseIncorrectAnnotationUsage.java\n package org.mockitousage.testng.failuretests;\n \n+import org.mockito.Mock;\n import org.mockito.Spy;\n import org.mockito.testng.MockitoTestNGListener;\n import org.testng.annotations.Listeners;\n @Listeners(MockitoTestNGListener.class)\n @Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n public class FailingOnPurposeBecauseIncorrectAnnotationUsage {\n-    @Spy Map spy_cant_initialize_interface_fields;\n+    @Mock @Spy Map cant_mock_and_spy_at_the_same_time;\n     @Test public void dummy_test_method() throws Exception { }\n }\n--- a/test/org/mockito/internal/handler/InvocationNotifierHandlerTest.java\n+++ b/test/org/mockito/internal/handler/InvocationNotifierHandlerTest.java\n         verify(mockHandler).setAnswersForStubbing(anyList());\n     }\n \n-    private static class CustomListener implements InvocationListener {\n+    private static class CustomListener implements InvocationListener {\n+    \tCustomListener() {}\n         public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n             // nop\n         }\n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n \n import org.fest.assertions.Assertions;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n import org.mockito.Spy;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n-\n+\n import java.util.AbstractList;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n-\n+\n import static org.mockito.Mockito.*;\n \n @SuppressWarnings({\"unchecked\", \"unused\"})\n     }\n \n     @Test\n-    public void shouldFailIfTypeIsAnInterface() throws Exception {\n-\t\tclass FailingSpy {\n-\t\t\t@Spy private List spyTypeIsInterface;\n+    public void spyInterface() throws Exception {\n+\t\tclass WithSpy {\n+\t\t\t@Spy List<String> list;\n \t\t}\n-\n-        try {\n-            MockitoAnnotations.initMocks(new FailingSpy());\n-            fail();\n-        } catch (Exception e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"an interface\");\n-        }\n+\n+\t\tWithSpy withSpy = new WithSpy();\n+        MockitoAnnotations.initMocks(withSpy);\n+        assertEquals(0, withSpy.list.size());\n     }\n \n     @Test\n         try {\n             MockitoAnnotations.initMocks(new FailingSpy());\n             fail();\n-        } catch (Exception e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"default constructor\");\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"Unable to create mock instance\");\n         }\n     }\n     \n         try {\n             MockitoAnnotations.initMocks(new FailingSpy());\n             fail();\n-        } catch (Exception e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"raised an exception\");\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"Unable to create mock instance\");\n         }\n     }\n \n     @Test\n-    public void shouldFailIfTypeIsAbstract() throws Exception {\n-\t\tclass FailingSpy {\n-\t\t\t@Spy private AbstractList spyTypeIsAbstract;\n-\t\t}\n-\n-        try {\n-            MockitoAnnotations.initMocks(new FailingSpy());\n-            fail();\n-        } catch (Exception e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"abstract class\");\n-        }\n-    }\n+    public void spyAbstractClass() throws Exception {\n+\t\tclass SpyAbstractClass {\n+\t\t\t@Spy AbstractList<String> list;\n+\t\t\t\n+\t\t\tList<String> asSingletonList(String s) {\n+\t\t\t\twhen(list.size()).thenReturn(1);\n+\t\t\t\twhen(list.get(0)).thenReturn(s);\n+\t\t\t\treturn list;\n+\t\t\t}\n+\t\t}\n+\t\tSpyAbstractClass withSpy = new SpyAbstractClass();\n+        MockitoAnnotations.initMocks(withSpy);\n+        assertEquals(Arrays.asList(\"a\"), withSpy.asSingletonList(\"a\"));\n+    }\n \n     @Test\n-    public void shouldFailIfTypeIsInnerClass() throws Exception {\n-\t\tclass FailingSpy {\n-\t\t\t@Spy private TheInnerClass spyTypeIsInner;\n-            class TheInnerClass { }\n-\t\t}\n-\n-        try {\n-            MockitoAnnotations.initMocks(new FailingSpy());\n-            fail();\n-        } catch (MockitoException e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"inner class\");\n-        }\n+    public void spyInnerClass() throws Exception {\n+    \t \n+     class WithMockAndSpy {\n+    \t\t@Spy private InnerStrength strength;\n+    \t\t@Mock private List<String> list;\n+\n+            abstract class InnerStrength {\n+            \tprivate final String name;\n+\n+            \tInnerStrength() {\n+            \t\t// Make sure that @Mock fields are always injected before @Spy fields.\n+            \t\tassertNotNull(list);\n+            \t\t// Make sure constructor is indeed called.\n+            \t\tthis.name = \"inner\";\n+            \t}\n+            \t\n+            \tabstract String strength();\n+            \t\n+            \tString fullStrength() {\n+            \t\treturn name + \" \" + strength();\n+            \t}\n+            }\n+    \t}\n+\t\tWithMockAndSpy outer = new WithMockAndSpy();\n+        MockitoAnnotations.initMocks(outer);\n+        when(outer.strength.strength()).thenReturn(\"strength\");\n+        assertEquals(\"inner strength\", outer.strength.fullStrength());\n     }\n \n \t@Test(expected = IndexOutOfBoundsException.class)\n--- a/test/org/mockitousage/basicapi/MockingDetailsTest.java\n+++ b/test/org/mockitousage/basicapi/MockingDetailsTest.java\n \n public class MockingDetailsTest {\n     \n-    private static class TestClass{\n+    private static class TestClass{\n+    \tTestClass() {}\n     }\n \n     @Mock", "timestamp": 1417513666, "metainfo": ""}