{"sha": "05930a300f030f034af656e0165aab9f395efd85", "log": "Fixed issue 54 The exception message now shows where one misused the framework  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401258", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockito.exceptions.verification.junit.JUnitTool;\n+import org.mockito.internal.debugging.Location;\n \n /**\n  * Reports verification and misusing errors.\n         ));\n     }\n \n-    public void unfinishedVerificationException() {\n-        throw new UnfinishedVerificationException(join(\n-                \"Previous verify(mock) doesn't have a method call!\",\n+    public void unfinishedVerificationException(Location location) {\n+        UnfinishedVerificationException exception = new UnfinishedVerificationException(join(\n+                \"Missing method call for verify(mock) method\",\n+                \" -> Located at \" + location,\n+                \"\",\n                 \"Example of correct verification:\",\n                 \"    verify(mock).doSomething()\",\n-                \"Also make sure the method is not final - you cannot verify final methods.\"\n-        ));\n+                \"Also make sure the method is not final - you cannot verify final methods.\",\n+                \"\"\n+        ));\n+        \n+        throw exception;\n     }\n     \n     public void notAMockPassedToVerify() {\n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n     }\n \n     public void filterStackTrace(HasStackTrace hasStackTrace) {\n-        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(hasStackTrace.getStackTrace());\n+        StackTraceElement[] filtered = filterStackTrace(hasStackTrace.getStackTrace());\n+        hasStackTrace.setStackTrace(filtered);\n+    }\n+\n+    public StackTraceElement[] filterStackTrace(StackTraceElement[] target) {\n+        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n         \n         int lastToRemove = -1;\n         int i = 0;\n         }\n         \n         List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove + 1, unfilteredStackTrace.size());\n-        hasStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+        return filtered.toArray(new StackTraceElement[]{});\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/Localized.java\n+package org.mockito.internal.debugging;\n+\n+import org.mockito.exceptions.base.StackTraceFilter;\n+\n+public class Localized<T> {\n+\n+    private final T object;\n+    private StackTraceElement[] stackTrace;\n+\n+    public Localized(T object) {\n+        this.object = object;\n+        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n+        StackTraceFilter filter = new StackTraceFilter();\n+        this.stackTrace = filter.filterStackTrace(stackTrace);\n+    }\n+\n+    public T getObject() {\n+        return object;\n+    }\n+\n+    public StackTraceElement[] getStackTrace() {\n+        return stackTrace;\n+    }\n+\n+    public Location getLocation() {\n+        return new Location(stackTrace);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/Location.java\n+package org.mockito.internal.debugging;\n+\n+public class Location {\n+\n+    private final StackTraceElement[] stackTrace;\n+\n+    public Location(StackTraceElement[] stackTrace) {\n+        assert stackTrace != null;\n+        assert stackTrace.length > 0;\n+        this.stackTrace = stackTrace;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return this.stackTrace[0].toString();\n+    }\n+}\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.debugging.Localized;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n     private final DebuggingInfo debuggingInfo = new DebuggingInfo();\n \n     OngoingStubbing ongoingStubbing;\n-    private VerificationMode verificationMode;\n+    private Localized<VerificationMode> verificationMode;\n     private boolean stubbingInProgress = false;\n \n     public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n     public void verificationStarted(VerificationMode verify) {\n         validateState();\n         resetOngoingStubbing();\n-        verificationMode = (VerificationMode) verify;\n+        verificationMode = new Localized(verify);\n     }\n \n     /* (non-Javadoc)\n     }\n \n     public VerificationMode pullVerificationMode() {\n-        VerificationMode temp = verificationMode;\n+        if (verificationMode == null) {\n+            return null;\n+        }\n+        \n+        VerificationMode temp = verificationMode.getObject();\n         verificationMode = null;\n         return temp;\n     }\n         GlobalConfiguration.validate();\n         \n         if (verificationMode != null) {\n+            Location location = verificationMode.getLocation();\n             verificationMode = null;\n-            reporter.unfinishedVerificationException();\n+            reporter.unfinishedVerificationException(location);\n         }\n         \n         if (stubbingInProgress) {\n--- a/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n     }\n     \n     @Test\n+    public void shouldShowWhereIsUnfinishedVerification() throws Exception {\n+        unfinishedVerificationHere();\n+        try {\n+            unfinishedVerificationHere();\n+            fail();\n+        } catch (UnfinishedVerificationException e) {\n+            assertContains(\"InvalidStateDetectionTest.unfinishedVerificationHere\", e.getMessage());\n+        }\n+    }\n+\n+    private void unfinishedVerificationHere() {\n+        verify(mock);\n+    }\n+    \n+    @Test\n     public void shouldDetectUnfinishedStubbing() {\n         when(mock.simpleMethod());\n         detectsAndCleansUp(new OnMethodCallOnMock(), UnfinishedStubbingException.class);\n     \n     @Test\n     public void shouldDetectUnfinishedVerification() {\n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnStub(), UnfinishedVerificationException.class);\n         \n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnStubVoid(), UnfinishedVerificationException.class);\n         \n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnVerify(), UnfinishedVerificationException.class);\n         \n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedVerificationException.class);\n         \n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedVerificationException.class);\n         \n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedVerificationException.class);\n         \n-        verify(mock);\n+        unfinishedVerificationHere();\n         detectsAndCleansUp(new OnDoAnswer(), UnfinishedVerificationException.class);\n     }\n \n     @Test\n     public void shouldCorrectStateAfterDetectingUnfinishedVerification() {\n         mock.simpleMethod();\n-        verify(mock);\n+        unfinishedVerificationHere();\n         \n         try {\n             verify(mock).simpleMethod();", "timestamp": 1234516792, "metainfo": ""}