{"sha": "db2989fc55c6b90ba1027ac60f6ca1648ce83b2d", "log": "Added partial mock warning in javadocs  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401486", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n \n     /**\n      * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n+     * Sets the real implementation to be called when the method is called on a mock object.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * Trust me, this is not the way you want to design your application. \n+     * In most cases, this is not the way you want to design your application.\n      * <p>\n      * However, there are rare cases when partial mocks come handy: \n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * I wouldn't use partial mocks in new code, though.\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Enough warnings about partial mocks, see an example how spiedInstance() works:\n      * <pre>\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n  * \n  * <p>\n- * Spying on real objects is often associated with \"partial mocking\" concept. \n- * However, Mockito spies are not partial mocks. Mockito spy is meant to help testing other classes - not the spy itself. \n- * Therefore spy will not help if you intend to verify if method calls other method on the same object. \n- * In this case I suggest being OO/SRPy (for example you might extract new class/interface...)\n- * \n+ * Spying on real objects can be associated with \"partial mocking\" concept. \n+ * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \n+ * The reason was we thought partial mock is a code smell. \n+ * At some point we found legitimate use cases for partial mocks \n+ * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\n+ * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\n+ * >here</a>)\n+ * <p>\n+ *\n  * <pre>\n  *   List list = new LinkedList();\n  *   List spy = spy(list);\n      * When this implementation is used, unstubbed methods will delegate to the real implementation.\n      * This is a way to create a partial mock object that calls real methods by default.\n      * <p>\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * In most cases, this is not the way you want to design your application.\n+     * <p>\n+     * However, there are rare cases when partial mocks come handy: \n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+     * <p>\n      * Example:\n      * <pre>\n      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);\n      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * Trust me, this is not the way you want to design your application. \n+     * In most cases, this is not the way you want to design your application.\n      * <p>\n      * However, there are rare cases when partial mocks come handy: \n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * I wouldn't use partial mocks in new code, though.\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Example:\n      * \n      * Use doCallRealMethod() when you want to call the real implementation of a method.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * Trust me, this is not the way you want to design your application. \n+     * In most cases, this is not the way you want to design your application.\n      * <p>\n      * However, there are rare cases when partial mocks come handy: \n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * I wouldn't use partial mocks in new code, though.\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks\n      * <p>\n--- a/src/org/mockito/internal/progress/NewOngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/NewOngoingStubbing.java\n     /**     \n      * Sets the real implementation to be called when the method is called on a mock object.\n      * <p>\n-     * TODO: polish the partial mocks warning\n      * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more less tackling complexity by spliting the complexity into separate, specific objects.\n+     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * Trust me, this is not the way you want to design your application. \n+     * In most cases, this is not the way you want to design your application.\n      * <p>\n      * However, there are rare cases when partial mocks come handy: \n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * I wouldn't use partial mocks in new code, though.\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * <pre>\n      * when(mock.someMethod()).thenCallRealMethod();\n--- a/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n+++ b/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java\n  * When this implementation is used, unstubbed methods will delegate to the real implementation.\n  * This is a way to create a partial mock object that calls real methods by default.\n  * <p>\n+ * As usual you are going to read <b>the partial mock warning</b>:\n+ * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+ * How does partial mock fit into this paradigm? Well, it just doesn't... \n+ * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+ * In most cases, this is not the way you want to design your application.\n+ * <p>\n+ * However, there are rare cases when partial mocks come handy: \n+ * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+ * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+ * <p>\n  */\n public class CallsRealMethods implements Answer<Object> {\n     public Object answer(InvocationOnMock invocation) throws Throwable {", "timestamp": 1244555716, "metainfo": ""}