{"sha": "c178b8497318194335ee6669bb297321e2b77579", "log": "added some initial code to use ComparisonFailure descendant when junit is on path. Using ComparisonFailure gives better IDE support.  deprecated stub() in favor of when() (it had to happen some day...)  --HG-- rename : src/org/mockito/internal/progress/OngoingStubbing.java => src/org/mockito/internal/progress/DeprecatedOngoingStubbing.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40821", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.Returns;\n-import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.StubberImpl;\n import org.mockito.internal.stubbing.ThrowsException;\n  * false, ... for int/Integer, boolean/Boolean, ...). </li>\n  * \n  * <li> Stubbing can be overridden: for example common stubbing can go to\n- * fixture setup but test methods can override it. </li>\n- * \n- * <li> Once stubbed, mocked method will always return stubbed value regardless\n+ * fixture setup but the test methods can override it. </li>\n+ * \n+ * <li> Once stubbed, the method will always return stubbed value regardless\n  * of how many times it is called. </li>\n  * \n  * <li> Last stubbing is more important - when you stubbed the same method with\n     }\n \n     /**\n-     * Stubs with return value or exception. E.g:\n-     * \n-     * <pre>\n-     *   stub(mock.someMethod()).toReturn(10);\n-     *   \n-     *   //you can use flexible argument matchers, e.g:\n-     *   stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n-     *   \n-     *   //setting exception to be thrown:\n-     *   stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n-     *   \n-     *   //you can stub with different behavior for consecutive calls.\n-     *   //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.   \n-     *   stub(mock.someMethod(\"some arg\"))\n-     *    .toThrow(new RuntimeException())\n-     *    .toReturn(\"foo\");\n+     * <b>Deprecated</b>\n+     * TODO regexp\n+     * \n+     * <pre>\n+     *   //Instead of:\n+     *   stub(mock.count()).toReturn(10);\n+     * \n+     *   //Please do:\n+     *   when(mock.count()).thenReturn(10);\n+     * </pre> \n+     * \n+     * Please use {@link Mockito#when}. We received many signals and \n+     * <p>\n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param methodCall\n+     *            method call\n+     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return (DeprecatedOngoingStubbing) stub();\n+    }\n+    \n+    /**\n+     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n+     * <p>\n+     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\". E.g:\n+     * <p>\n+     * If you're familiar with Mockito then know that when() is a successor of {@link Mockito#stub()}\n+     * \n+     * <pre>\n+     * when(mock.someMethod()).thenReturn(10);\n+     *\n+     * //you can use flexible argument matchers, e.g:\n+     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n+     *\n+     * //setting exception to be thrown:\n+     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n+     *\n+     * //you can set different behavior for consecutive method calls.\n+     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenThrow(new RuntimeException())\n+     *  .thenReturn(\"foo\");\n      *   \n      * </pre>\n      * \n      * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n      * <p>\n      * Stubbing can be overridden: for example common stubbing can go to fixture\n-     * setup but test methods can override it.\n-     * <p>\n-     * Once stubbed, mocked method will always return stubbed value regardless\n+     * setup but the test methods can override it.\n+     * <p>\n+     * Once stubbed, the method will always return stubbed value regardless\n      * of how many times it is called.\n      * <p>\n      * Last stubbing is more important - when you stubbed the same method with\n      * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     * @param <T>\n      * @param methodCall\n-     *            method call\n-     * @return OngoingStubbing object to set stubbed value/exception\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> OngoingStubbing<T> stub(T methodCall) {\n+     * @return\n+     */\n+    public static <T> NewOngoingStubbing<T> when(T methodCall) {\n         MOCKING_PROGRESS.stubbingStarted();\n-\n-        OngoingStubbing stubbable = MOCKING_PROGRESS.pullOngoingStubbing();\n-        if (stubbable == null) {\n+        return (NewOngoingStubbing) stub();\n+    }\n+\n+    private static OngoingStubbing stub() {\n+        OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n+        if (stubbing == null) {\n             REPORTER.missingMethodInvocation();\n         }\n-        return stubbable;\n+        return stubbing;\n     }\n \n     /**\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.VerifcationInOrderFailure;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.junit.JUnitTool;\n \n /**\n  * Reports verification and misusing errors.\n         \n         cause.setStackTrace(actualStackTrace.getStackTrace());\n         \n-        throw new ArgumentsAreDifferent(join(\n-                \"Argument(s) are different! Wanted:\",\n-                wanted.toString()\n-            ), cause);\n+        if (JUnitTool.hasJUnit()) {\n+            throw JUnitTool.createArgumentsAreDifferentException(\n+                    join(\"Argument(s) are different! Wanted:\", wanted.toString()),\n+                    cause,\n+                    wanted.toString(),\n+                    actual.toString());\n+        } else {\n+            throw new ArgumentsAreDifferent(join(\n+                    \"Argument(s) are different! Wanted:\",\n+                    wanted.toString()\n+                ), cause);\n+        }\n     }\n     \n     public void wantedButNotInvoked(PrintableInvocation wanted) {\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferentJUnitStyle.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification.junit;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.ComparisonFailure;\n+import org.mockito.exceptions.base.CommonStackTraceRemover;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.exceptions.base.StackTraceFilter;\n+\n+\n+public class ArgumentsAreDifferentJUnitStyle extends ComparisonFailure implements HasStackTrace {\n+    \n+    private static final long serialVersionUID = 1L;\n+    private final String message;\n+    private StackTraceElement[] unfilteredStackTrace;\n+\n+    public ArgumentsAreDifferentJUnitStyle(String message, Throwable cause, String wanted, String actual) {\n+        super(message, wanted, actual);\n+        this.message = message;\n+        \n+        unfilteredStackTrace = getStackTrace();\n+        StackTraceFilter filter = new StackTraceFilter();\n+        filter.filterStackTrace(this);\n+        \n+        this.initCause(cause);\n+        CommonStackTraceRemover remover = new CommonStackTraceRemover();\n+        remover.remove(this, Arrays.asList(cause.getStackTrace()));\n+    }\n+    \n+    @Override\n+    public String getMessage() {\n+        return message;\n+    }\n+    \n+    public StackTraceElement[] getUnfilteredStackTrace() {\n+        return unfilteredStackTrace;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/junit/JUnitTool.java\n+package org.mockito.exceptions.verification.junit;\n+\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+\n+public class JUnitTool {\n+\n+    private static boolean hasJUnit;\n+\n+    static {\n+        try {\n+            Class.forName(\"junit.framework.ComparisonFailure\");\n+            hasJUnit = true;\n+        } catch (Throwable t) {\n+            hasJUnit = false;\n+        }\n+    }\n+    \n+    public static boolean hasJUnit() {\n+        return hasJUnit;\n+    }\n+\n+    public static AssertionError createArgumentsAreDifferentException(String message, Throwable cause, String wanted, String actual)  {\n+        //TODO commented out for now...\n+//        try {\n+//            Class<?> clazz = Class.forName(\"org.mockito.exceptions.verification.junit.ArgumentsAreDifferentJUnitStyle\");\n+//            AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, cause, wanted, actual);\n+//            return throwable;\n+//        } catch (Throwable t) {\n+            //throw the default exception in case of problems\n+            return new ArgumentsAreDifferent(message, cause);\n+//        }\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.MockitoStubber;\n         mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n         verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n \n-        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n-\n-        \n+        mockingProgress.reportOngoingStubbing(new DeprecatedOngoingStubbingImpl());\n+\n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n         if (answer != null) {\n             return answer.answer(invocation);\n         }\n     }\n \n-    private class OngoingStubbingImpl implements OngoingStubbing<T> {\n-        public OngoingStubbing<T> toReturn(Object value) {\n+    //@Deprecated - remove when stub...toReturn disappears\n+    private class DeprecatedOngoingStubbingImpl implements DeprecatedOngoingStubbing<T> {\n+        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n+            return toAnswer(new Returns(value));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+            return toAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n             verifyingRecorder.eraseLastInvocation();\n-            mockitoStubber.addAnswer(new Returns(value));\n-            return new ConsecutiveStubbing();\n-        }\n-\n-        public OngoingStubbing<T> toThrow(Throwable throwable) {\n-            verifyingRecorder.eraseLastInvocation();\n-            mockitoStubber.addAnswer(new ThrowsException(throwable));\n-            return new ConsecutiveStubbing();\n-        }\n-\n-        public OngoingStubbing<T> toAnswer(Answer<?> answer) {\n+            mockitoStubber.addAnswer(answer);\n+            return new DeprecatedConsecutiveStubbing();\n+        }\n+    }\n+\n+    //@Deprecated - remove when stub...toReturn disappears\n+    private class DeprecatedConsecutiveStubbing implements DeprecatedOngoingStubbing<T> {\n+        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n+            return toAnswer(new Returns(value));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+            return toAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+            mockitoStubber.addConsecutiveAnswer(answer);\n+            return this;\n+        }\n+    }\n+    \n+    private class OngoingStubbingImpl implements NewOngoingStubbing<T> {\n+        public NewOngoingStubbing<T> thenReturn(Object value) {\n+            return thenAnswer(new Returns(value));\n+        }\n+\n+        public NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n+            return thenAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n             verifyingRecorder.eraseLastInvocation();\n             mockitoStubber.addAnswer(answer);\n             return new ConsecutiveStubbing();\n         }\n     }\n \n-    private class ConsecutiveStubbing implements OngoingStubbing<T> {\n-        public OngoingStubbing<T> toReturn(Object value) {\n-            mockitoStubber.addConsecutiveAnswer(new Returns(value));\n-            return this;\n-        }\n-\n-        public OngoingStubbing<T> toThrow(Throwable throwable) {\n-            mockitoStubber.addConsecutiveAnswer(new ThrowsException(throwable));\n-            return this;\n-        }\n-\n-        public OngoingStubbing<T> toAnswer(Answer<?> answer) {\n+    private class ConsecutiveStubbing implements NewOngoingStubbing<T> {\n+        public NewOngoingStubbing<T> thenReturn(Object value) {\n+            return thenAnswer(new Returns(value));\n+        }\n+\n+        public NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n+            return thenAnswer(new ThrowsException(throwable));\n+        }\n+\n+        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n             mockitoStubber.addConsecutiveAnswer(answer);\n             return this;\n         }\n-    }\n-\n+    }    \n+    \n     @SuppressWarnings(\"unchecked\")\n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/DeprecatedOngoingStubbing.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import org.mockito.Mockito;\n+import org.mockito.stubbing.Answer;\n+\n+/**\n+ * Stubs a method call with return value or an exception. E.g:\n+ *\n+ * <pre>\n+ * stub(mock.someMethod()).toReturn(10);\n+ *\n+ * //you can use flexible argument matchers, e.g:\n+ * stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n+ *\n+ * //setting exception to be thrown:\n+ * stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n+ *\n+ * //you can stub with different behavior for consecutive method calls.\n+ * //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.\n+ * stub(mock.someMethod(\"some arg\"))\n+ *  .toThrow(new RuntimeException())\n+ *  .toReturn(\"foo\");\n+ *\n+ * </pre>\n+ *\n+ * See examples in javadoc for {@link Mockito#stub}\n+ */\n+public interface DeprecatedOngoingStubbing<T> extends OngoingStubbing {\n+\n+    /**\n+     * Set a return value for the stubbed method. E.g:\n+     * <pre>\n+     * stub(mock.someMethod()).toReturn(10);\n+     * </pre>\n+     *\n+     * See examples in javadoc for {@link Mockito#stub}\n+     *\n+     * @param value return value\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    DeprecatedOngoingStubbing<T> toReturn(T value);\n+\n+    /**\n+     * Set a Throwable to be thrown when the stubbed method is called. E.g:\n+     * <pre>\n+     * stub(mock.someMethod()).toThrow(new RuntimeException());\n+     * </pre>\n+     *\n+     * If throwable is a checked exception then it has to\n+     * match one of the checked exceptions of method signature.\n+     *\n+     * See examples in javadoc for {@link Mockito#stub}\n+     *\n+     * @param throwable to be thrown on method invocation\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    DeprecatedOngoingStubbing<T> toThrow(Throwable throwable);\n+\n+    /**\n+     * Set a generic Answer for the stubbed method. E.g:\n+     * <pre>\n+     * stub(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n+     *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n+     *         return (Integer) invocation.getArguments()[0];\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param answer the custom answer to execute.\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer);\n+}\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n \n @SuppressWarnings(\"unchecked\")\n public interface MockingProgress {\n-\n+    \n     void reportOngoingStubbing(OngoingStubbing ongoingStubbing);\n \n     OngoingStubbing pullOngoingStubbing();\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/NewOngoingStubbing.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import org.mockito.Mockito;\n+import org.mockito.stubbing.Answer;\n+\n+/**\n+ * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\". E.g:\n+ *\n+ * <pre>\n+ * when(mock.someMethod()).thenReturn(10);\n+ *\n+ * //you can use flexible argument matchers, e.g:\n+ * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n+ *\n+ * //setting exception to be thrown:\n+ * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n+ *\n+ * //you can set different behavior for consecutive method calls.\n+ * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n+ * when(mock.someMethod(\"some arg\"))\n+ *  .thenThrow(new RuntimeException())\n+ *  .thenReturn(\"foo\");\n+ *\n+ * </pre>\n+ *\n+ * See examples in javadoc for {@link Mockito#when}\n+ */\n+public interface NewOngoingStubbing<T> {\n+\n+    /**\n+     * Sets a return value to be returned when the method is called. E.g:\n+     * <pre>\n+     * when(mock.someMethod()).thenReturn(10);\n+     * </pre>\n+     *\n+     * See examples in javadoc for {@link Mockito#when}\n+     *\n+     * @param value return value\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    NewOngoingStubbing<T> thenReturn(T value);\n+\n+    /**\n+     * Sets a Throwable to be thrown when the method is called. E.g:\n+     * <pre>\n+     * when(mock.someMethod()).thenThrow(new RuntimeException());\n+     * </pre>\n+     *\n+     * If throwable is a checked exception then it has to\n+     * match one of the checked exceptions of method signature.\n+     *\n+     * See examples in javadoc for {@link Mockito#when}\n+     *\n+     * @param throwable to be thrown on method invocation\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    NewOngoingStubbing<T> thenThrow(Throwable throwable);\n+\n+    /**\n+     * Sets a generic Answer for the method. E.g:\n+     * <pre>\n+     * when(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n+     *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n+     *         return (Integer) invocation.getArguments()[0];\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param answer the custom answer to execute.\n+     *\n+     * @return ongoingStubbing object that allows stubbing consecutive calls\n+     */\n+    NewOngoingStubbing<T> thenAnswer(Answer<?> answer);\n+}\n--- a/src/org/mockito/internal/progress/OngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n  */\n package org.mockito.internal.progress;\n \n-import org.mockito.Mockito;\n-import org.mockito.stubbing.Answer;\n \n /**\n- * Stubs a method call with return value or an exception. E.g:\n- *\n- * <pre>\n- * stub(mock.someMethod()).toReturn(10);\n- *\n- * //you can use flexible argument matchers, e.g:\n- * stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);\n- *\n- * //setting exception to be thrown:\n- * stub(mock.someMethod(\"some arg\")).toThrow(new RuntimeException());\n- *\n- * //you can stub with different behavior for consecutive method calls.\n- * //Last stubbing (e.g: toReturn(\"foo\")) determines the behavior for further consecutive calls.\n- * stub(mock.someMethod(\"some arg\"))\n- *  .toThrow(new RuntimeException())\n- *  .toReturn(\"foo\");\n- *\n- * </pre>\n- *\n- * See examples in javadoc for {@link Mockito#stub}\n+ * Marking interface to be removed when DeprecatedOngoingStubbing gets deleted\n  */\n-public interface OngoingStubbing<T> {\n-\n-    /**\n-     * Set a return value for the stubbed method. E.g:\n-     * <pre>\n-     * stub(mock.someMethod()).toReturn(10);\n-     * </pre>\n-     *\n-     * See examples in javadoc for {@link Mockito#stub}\n-     *\n-     * @param value return value\n-     *\n-     * @return ongoingStubbing object that allows stubbing consecutive calls\n-     */\n-    OngoingStubbing<T> toReturn(T value);\n-\n-    /**\n-     * Set a Throwable to be thrown when the stubbed method is called. E.g:\n-     * <pre>\n-     * stub(mock.someMethod()).toThrow(new RuntimeException());\n-     * </pre>\n-     *\n-     * If throwable is a checked exception then it has to\n-     * match one of the checked exceptions of method signature.\n-     *\n-     * See examples in javadoc for {@link Mockito#stub}\n-     *\n-     * @param throwable to be thrown on method invocation\n-     *\n-     * @return ongoingStubbing object that allows stubbing consecutive calls\n-     */\n-    OngoingStubbing<T> toThrow(Throwable throwable);\n-\n-    /**\n-     * Set a generic Answer for the stubbed method. E.g:\n-     * <pre>\n-     * stub(mock.someMethod(10)).toAnswer(new Answer&lt;Integer&gt;() {\n-     *     public Integer answer(InvocationOnMock invocation) throws Throwable {\n-     *         return (Integer) invocation.getArguments()[0];\n-     *     }\n-     * }\n-     * </pre>\n-     *\n-     * @param answer the custom answer to execute.\n-     *\n-     * @return ongoingStubbing object that allows stubbing consecutive calls\n-     */\n-    OngoingStubbing<T> toAnswer(Answer<?> answer);\n-}\n+public interface OngoingStubbing {}\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.progress;\n-\n-\n \n @SuppressWarnings(\"unchecked\")\n public class ThreadSafeMockingProgress implements MockingProgress {\n     public void reset() {\n         threadSafely().reset();\n     }\n-}\n+}\n--- a/test/org/mockitousage/matchers/CustomMatchersTest.java\n+++ b/test/org/mockitousage/matchers/CustomMatchersTest.java\n import org.junit.Test;\n import org.mockito.ArgumentMatcher;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n         try {\n             verify(mock).simpleMethod(containsTest());\n             fail();\n-        } catch (ArgumentsAreDifferent e) {\n+        } catch (AssertionError e) {\n             assertThat(e, messageContains(\"<String that contains xxx>\"));\n         }\n     }\n                     return false;\n                 }}));\n             fail();\n-        } catch (ArgumentsAreDifferent e) {\n+        } catch (AssertionError e) {\n             assertThat(e, messageContains(\"<custom argument matcher>\"));\n             assertThat(e, causeMessageContains(\"foo\"));\n         }\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n import org.junit.Test;\n import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferentJUnitStyle;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferentJUnitStyle;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n ", "timestamp": 1219763182, "metainfo": ""}