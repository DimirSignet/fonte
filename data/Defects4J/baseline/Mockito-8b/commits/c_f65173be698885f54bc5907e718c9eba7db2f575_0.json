{"sha": "f65173be698885f54bc5907e718c9eba7db2f575", "log": "Added code that guards from misusing extraInterfaces() Not finished yet. The multithreaded test fails and I'm just going to fix it  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401418", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"\"\n                 ));\n     }\n+\n+    public void extraInterfacesDoesNotAcceptNullParameters() {\n+        throw new MockitoException(join(\n+                \"extraInterfaces() does not accept null parameters.\"\n+                ));\n+    }\n+\n+    public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n+        throw new MockitoException(join(\n+                \"extraInterfaces() accepts only interfaces.\",\n+                \"You passed following type: \" + wrongType.getSimpleName() + \" which is not an interface.\"\n+        ));\n+    }\n+\n+    public void extraInterfacesCannotContainMockedType(Class<?> wrongType) {\n+        throw new MockitoException(join(\n+                \"extraInterfaces() does not accept the same type as the mocked type.\",\n+                \"You mocked following type: \" + wrongType.getSimpleName(), \n+                \"and you passed the same very interface to the extraInterfaces()\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n import org.mockito.MockSettings;\n import org.mockito.ReturnValues;\n+import org.mockito.exceptions.Reporter;\n \n public class MockSettingsImpl implements MockSettings {\n \n     private Object spiedInstance;\n \n     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {\n+        for (Class<?> i : extraInterfaces) {\n+            if (i == null) {\n+                new Reporter().extraInterfacesDoesNotAcceptNullParameters();\n+            } else if (!i.isInterface()) {\n+                new Reporter().extraInterfacesAcceptsOnlyInterfaces(i);\n+            }\n+        }\n         this.extraInterfaces = extraInterfaces;\n         return this;\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/CreationValidator.java\n+package org.mockito.internal.util;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CreationValidator {\n+\n+    public void validateType(Class classToMock) {\n+        if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n+            new Reporter().cannotMockFinalClass(classToMock);\n+        }\n+    }\n+    \n+    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n+        if (extraInterfaces == null) {\n+            return;\n+        }\n+        \n+        for (Class i : extraInterfaces) {\n+            if (classToMock == i) {\n+                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n+            }\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n \n-import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.creation.MethodInterceptorFilter;\n import org.mockito.internal.util.copy.LenientCopyTool;\n \n public class MockUtil {\n+    \n+    public static CreationValidator creationValidator = new CreationValidator();\n \n     public static <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\n-        validateType(classToMock);\n+        creationValidator.validateType(classToMock);\n+        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n+        \n         MockName mockName = new MockName(settings.getMockName(), classToMock);\n         MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings.getReturnValues());\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n         MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>>(Object.class, newMockHandler);\n         newFilter.setInstance(mock);\n         ((Factory) mock).setCallback(0, newFilter);\n-    }\n-\n-    private static <T> void validateType(Class<T> classToMock) {\n-        if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n-            new Reporter().cannotMockFinalClass(classToMock);\n-        }\n     }\n \n     public static <T> MockHandler<T> getMockHandler(T mock) {\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+package org.mockito.internal.creation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockSettingsImplTest extends TestBase {\n+\n+    @Test\n+    public void shouldNotAllowSettingNullInterface() {\n+        try {\n+            //when\n+            new MockSettingsImpl().extraInterfaces(List.class, null);\n+            fail();\n+            //then\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowNonInterfaces() {\n+        try {\n+            //when\n+            new MockSettingsImpl().extraInterfaces(List.class, LinkedList.class);\n+            fail();\n+            //then\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowUsingTheSameInterfaceAsExtra() {\n+        try {\n+            //when\n+            new MockSettingsImpl().extraInterfaces(List.class, LinkedList.class);\n+            fail();\n+            //then\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowMultipleInterfaces() {\n+        //given\n+        MockSettingsImpl settings = new MockSettingsImpl();\n+        \n+        //when\n+        settings.extraInterfaces(List.class, Set.class);\n+        \n+        //then\n+        assertEquals(List.class, settings.getExtraInterfaces()[0]);\n+        assertEquals(Set.class, settings.getExtraInterfaces()[1]);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/CreationValidatorTest.java\n+package org.mockito.internal.util;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class CreationValidatorTest extends TestBase {\n+\n+    final class FinalClass {}\n+    \n+    @Test\n+    public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n+        //given\n+        CreationValidator validator = new CreationValidator();\n+        \n+        try {\n+            //when\n+            validator.validateExtraInterfaces(IMethods.class, new Class<?>[] {IMethods.class});\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"You mocked following type: IMethods\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldIgnoreIfExtraInterfacesAreNull() throws Exception {\n+        //given\n+        CreationValidator validator = new CreationValidator();\n+        \n+        //when\n+        validator.validateExtraInterfaces(IMethods.class, (Class[]) null);\n+\n+        //then ok\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowFinalClasses() throws Exception {\n+        //given\n+        CreationValidator validator = new CreationValidator();\n+        \n+        try {\n+            //when\n+            validator.validateType(FinalClass.class);\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"Cannot mock/spy\", e.getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.NoOp;\n \n+import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+@SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n+    \n+    public class CreationValidatorStub extends CreationValidator {\n+        private boolean extraInterfacesValidated;\n+        private boolean typeValidated;\n+        public void validateType(Class classToMock) {\n+            typeValidated = true;\n+        }\n+        public void validateExtraInterfaces(Class classToMock, Class ... interfaces) {\n+            extraInterfacesValidated = true;\n+        }\n+    }\n \n-    @SuppressWarnings(\"unchecked\")\n+    @Before\n+    public void setUp() {\n+        MockUtil.creationValidator = new CreationValidatorStub();\n+    }\n+    \n+    @After\n+    public void restoreValidator() {\n+        MockUtil.creationValidator = new CreationValidator();\n+    }\n+    \n+    @Test \n+    public void shouldValidate() {\n+        //given\n+        assertFalse(((CreationValidatorStub) MockUtil.creationValidator).extraInterfacesValidated);\n+        assertFalse(((CreationValidatorStub) MockUtil.creationValidator).typeValidated);\n+\n+        //when\n+        MockUtil.createMock(IMethods.class, new ThreadSafeMockingProgress(), new MockSettingsImpl());\n+        \n+        //then\n+        assertTrue(((CreationValidatorStub) MockUtil.creationValidator).extraInterfacesValidated);\n+        assertTrue(((CreationValidatorStub) MockUtil.creationValidator).typeValidated);\n+    }\n+\n     @Test \n     public void shouldGetHandler() {\n         List mock = Mockito.mock(List.class);\n         assertFalse(MockUtil.isMock(\"i mock a mock\"));\n         assertTrue(MockUtil.isMock(Mockito.mock(List.class)));\n     }\n-}\n+}\n--- a/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n+++ b/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n public class MockingMultipleInterfacesTest extends TestBase {\n         assertThat(mock, is(IFoo.class));\n         assertThat(mock, is(IBar.class));\n     }\n+    \n+    @Test\n+    public void shouldScreamWhenNullPassedInsteadOfAnInterface() {\n+        try {\n+            //when\n+            mock(Foo.class, configureWith().extraInterfaces(IFoo.class, null));\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"extraInterfaces() does not accept null parameters\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenNonInterfacePassed() {\n+        try {\n+            //when\n+            mock(Foo.class, configureWith().extraInterfaces(Foo.class));\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"Foo which is not an interface\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenTheSameInterfacesPassed() {\n+        try {\n+            //when\n+            mock(IMethods.class, configureWith().extraInterfaces(IMethods.class));\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"You mocked following type: IMethods\", e.getMessage());\n+        }\n+    }\n }\n--- a/test/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java\n+++ b/test/org/mockitousage/stacktrace/ModellingDescriptiveMessagesTest.java\n \n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.junit.Before;\n import org.junit.Ignore;\n         argument.capture();\n         argument.getValue();\n     }\n+    \n+    @Test\n+    public void shouldScreamWhenNullPassedInsteadOfAnInterface() {\n+        mock(IMethods.class, configureWith().extraInterfaces(List.class, null));\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenNonInterfacePassed() {\n+        mock(IMethods.class, configureWith().extraInterfaces(LinkedList.class));\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenExtraIsTheSame() {\n+        mock(IMethods.class, configureWith().extraInterfaces(IMethods.class));\n+    }\n }", "timestamp": 1242076229, "metainfo": ""}