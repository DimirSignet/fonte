{"sha": "1cdf03fdb8b2d8e3e52c5331f6d65be8c92f7138", "log": "renamed the runner minor fixes to the javadoc  --HG-- rename : src/org/junit/mockito/ExperimentalMockitoJUnitRunner.java => src/org/junit/mockito/VerboseMockitoJUnitRunner.java rename : test/org/junit/mockito/ExperimentalMockitoJUnitRunnerTest.java => test/org/junit/mockito/VerboseMockitoJUnitRunnerTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401191", "commit": "\n--- /dev/null\n+++ b/src/org/junit/mockito/VerboseMockitoJUnitRunner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.junit.mockito;\n+\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.BlockJUnit4ClassRunner;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+/**\n+ * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n+ * <p>\n+ * Experimental implementation that suppose to enhance tdd/testing experience. \n+ * Don't hesitate to send feedback to mockito@googlegroups.com\n+ * <p>\n+ * This runner does exactly what {@link MockitoJUnitRunner} does but also  \n+ * prints useful warnings that can enhance testing experience. \n+ * The point is that Mockito should help the tdd developer to quickly figure out if the test fails for the right reason. \n+ * Then the developer can implement the functionality. \n+ * Also when the test fails it should be easy to figure out why the test fails. \n+ * <p>\n+ * Sometimes when the test fails, the underlying reason is that stubbed method was called with wrong arguments. \n+ * Sometimes it fails because one forgets to stub a method or forgets to call a stubbed method. \n+ * All above problems are not immediately obvious.\n+ * <p>\n+ * One way of approaching this problem is full-blown 'expect' API. \n+ * However it means the 'expectations upfront' business which is not in line with core Mockito concepts.\n+ * After all, one of the key points of Mockito are <b>explicit assertions</b> that are always placed at the <b>bottom of the test</b> method.\n+ * <p>\n+ * Let's look at different ways of addressing the issue.\n+ * Here's the experiment: a warning is printed to the standard output if the test fails.\n+ * Also, you get a clickabe link to the line of code. You can immediately jump to the place in code where the potential problem is.\n+ * <p> \n+ * Let's say your test fails on assertion. \n+ * Let's say the underlying reason is a stubbed method that was called with different arguments:\n+ * <pre>\n+ * //test:\n+ * when(translator.translate(\"Mockito\")).thenReturn(\"cool framework\");\n+ * String translated = dictionary.search(\"Mockito\");\n+ * assertEquals(\"cool framework\", translated);\n+ * \n+ * //code:\n+ * public String search(String word) {\n+ *     ...\n+ *     return translator.translate(\"oups\");\n+ *\n+ * </pre>\n+ * On standard output you'll see something like that:\n+ * <pre>\n+ * [Mockito] Warning - stubbed method called with different arguments.\n+ * Stubbed this way:\n+ * translator.translate(\"Mockito\");\n+ * org.dictionary.SmartDictionaryTest.shouldFindTranslation(SmartDictionaryTest.java:27)\n+ *  \n+ * But called with different arguments:\n+ * translator.translate(\"oups\");\n+ * org.dictionary.SmartDictionary.search(SmartDictionary.java:15)\n+ * </pre>\n+ * <p>\n+ * Note that it is just a warning, not an assertion. \n+ * The test fails on assertion because it's the assertion's task to document what the test stands for and what behavior it proves. \n+ * Warnings just helps debugging tests.\n+ * <p>\n+ * Note that code links printed to the console are clickable in any decent IDE (e.g. Eclipse).\n+ * <p>\n+ * So far I identified 3 cases when warnings are printed:\n+ * <li>unstubbed method</li>\n+ * <li>unsued stub</li>\n+ * <li>stubbed method but called with different arguments</li> \n+ * <p>\n+ * <br/>\n+ * This runner lives under org.junit.mockito package \n+ * so that it automatically takes advantage on clean stack traces in most IDEs \n+ * <p>\n+ * Do you think it is useful or not? Drop us an email at mockito@googlegroups.com\n+ */\n+public class VerboseMockitoJUnitRunner extends MockitoJUnitRunner {\n+\n+    private final MockitoLogger logger;\n+    \n+    public VerboseMockitoJUnitRunner(Class<?> klass) throws InitializationError {\n+        this(klass, new MockitoLoggerImpl());\n+    }\n+    \n+    public VerboseMockitoJUnitRunner(Class<?> klass, MockitoLogger logger) throws InitializationError {\n+        super(klass);\n+        this.logger = logger;\n+    }\n+    \n+    //this is what is really executed when the test runs\n+    static interface JunitTestBody {\n+        void run(RunNotifier notifier);\n+    }\n+    \n+    @Override\n+    public void run(RunNotifier notifier) {\n+        this.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                VerboseMockitoJUnitRunner.super.run(notifier);\n+            }\n+        });\n+    }\n+    \n+    public void run(RunNotifier notifier, JunitTestBody junitTestBody) {\n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n+        \n+        beforeRun(notifier, debuggingInfo);\n+        \n+        junitTestBody.run(notifier);\n+        \n+        afterRun(debuggingInfo);\n+    }\n+\n+    private void afterRun(final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.clearData();\n+    }\n+\n+    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.collectData();\n+\n+        RunListener listener = new RunListener() {\n+            @Override public void testFailure(Failure failure) throws Exception {\n+                debuggingInfo.printWarnings(logger);\n+            }\n+        };\n+        \n+        notifier.addListener(listener);\n+    }\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n import java.util.Arrays;\n \n-import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n+import org.junit.mockito.VerboseMockitoJUnitRunner;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.MockHandler;\n  *      12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids <br/>\n  *      13. Spying on real objects <br/>\n  *      14. (**New**) Changing default return values of unstubbed invocations <br/>\n- *      15. (**New**) ExperimentalMockitoJUnitRunner to help with debugging failing tests <br/>\n+ *      15. (**New**) VerboseMockitoJUnitRunner to help with debugging failing tests <br/>\n  * </b>\n  * \n  * <p>\n  * <p>\n  * Optionally, you can configure default return values using {@link IMockitoConfiguration}.\n  * \n- * <h3>15. (**New**) ExperimentalMockitoJUnitRunner to enhance testing experience</h3>\n+ * <h3>15. (**New**) VerboseMockitoJUnitRunner to enhance testing experience</h3>\n  *      \n- * ExperimentalMockitoJUnitRunner initializes &#064;Mock annotated mocks and prints useful warnings that can enhance testing experience.\n- * <p>\n- * The point is that Mockito should help the tdd developer to quickly figure out if the test fails for the right reason. \n- * Then the developer can implement the functionality. \n- * Also when the test fails it should be easy to figure out why the test fails.\n- * <p>\n- * Read more in javadocs for ExperimentalMockitoJUnitRunner class: {@link ExperimentalMockitoJUnitRunner}\n- * <pre>\n- * \n- * &#064;RunWith(\"ExperimentalMockitoJUnitRunner.class\")\n- * YourTest extends TestCase {\n- *     \n- *     &#064;Mock private List list;\n- * \n- * </pre>\n+ * Experimental VerboseMockitoJUnitRunner initializes &#064;Mock annotated mocks and prints useful warnings that can enhance testing experience.\n+ * <p>\n+ * Read more in javadoc for {@link VerboseMockitoJUnitRunner} class.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n--- /dev/null\n+++ b/test/org/junit/mockito/VerboseMockitoJUnitRunnerTest.java\n+package org.junit.mockito;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.mockito.VerboseMockitoJUnitRunner.JunitTestBody;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class VerboseMockitoJUnitRunnerTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+    \n+    private VerboseMockitoJUnitRunner runner;\n+    private MockitoLoggerStub loggerStub;\n+    private RunNotifier notifier;\n+\n+    @Before\n+    public void setup() throws InitializationError {\n+        loggerStub = new MockitoLoggerStub();\n+        notifier = new RunNotifier();\n+        runner = new VerboseMockitoJUnitRunner(this.getClass(), loggerStub);\n+    }\n+    \n+    //TODO after 1.7 refactor it to override-and-subclass\n+    @Test(expected=RunWasCalled.class)\n+    public void shouldRunTests() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                throw new RunWasCalled();\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                //this is what happens when the test runs:\n+                //first, unused stubbing:\n+                unusedStubbingThatQualifiesForWarning();\n+                //then, let's make the test fail so that warnings are printed\n+                notifier.fireTestFailure(null);\n+                //assert\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n+                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                callUnstubbedMethodThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this method was not stubbed\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(456);\"));\n+                assertThat(loggedInfo, contains(\".callUnstubbedMethodThatQualifiesForWarning(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                someStubbing();\n+                callStubbedMethodWithDifferentArgs();\n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - stubbed method called with different arguments\"));\n+                assertThat(loggedInfo, contains(\"Stubbed this way:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(789);\"));\n+                assertThat(loggedInfo, contains(\".someStubbing(\"));\n+                \n+                assertThat(loggedInfo, contains(\"But called with different arguments:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(10);\"));\n+                assertThat(loggedInfo, contains(\".callStubbedMethodWithDifferentArgs(\"));\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldNotLogAnythingWhenStubCalledCorrectly() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod(1)).thenReturn(\"foo\");\n+                mock.simpleMethod(1);\n+\n+                notifier.fireTestFailure(null);\n+                \n+                assertEquals(\"\", loggerStub.getLoggedInfo());\n+            }\n+        });\n+    }\n+    \n+    @Test\n+    public void shouldNotLogWhenTestPasses() throws Exception {\n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                when(mock.simpleMethod()).thenReturn(\"foo\");\n+                \n+                notifier.fireTestFinished(null);\n+                \n+                assertEquals(\"\", loggerStub.getLoggedInfo());\n+            }\n+        });\n+    }\n+    \n+    \n+    public void shouldClearDebuggingDataAfterwards() throws Exception {\n+        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n+        \n+        runner.run(notifier, new JunitTestBody() {\n+            public void run(RunNotifier notifier) {\n+                unusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                assertTrue(debuggingInfo.hasData());\n+            }\n+        });\n+        \n+        assertFalse(debuggingInfo.hasData());\n+    }    \n+\n+    private void unusedStubbingThatQualifiesForWarning() {\n+        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n+    }\n+\n+    private void callUnstubbedMethodThatQualifiesForWarning() {\n+        mock.simpleMethod(456);\n+    }\n+    \n+    private void someStubbing() {\n+        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n+    }\n+    \n+    private void callStubbedMethodWithDifferentArgs() {\n+        mock.simpleMethod(10);\n+    }\n+    \n+    public class MockitoLoggerStub extends MockitoLoggerImpl {\n+        \n+        StringBuilder loggedInfo = new StringBuilder();\n+        \n+        public void log(Object what) {\n+            super.log(what);\n+            loggedInfo.append(what);\n+        }\n+\n+        public String getLoggedInfo() {\n+            return loggedInfo.toString();\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    private static class RunWasCalled extends RuntimeException {}; \n+}\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkInOrderTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n+import org.junit.mockito.VerboseMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.InOrder;\n import org.mockito.Mockito;\n import org.mockitoutil.TestBase;\n \n //This is required to make sure stack trace is well filtered when runner is ON\n-@RunWith(ExperimentalMockitoJUnitRunner.class)\n+@RunWith(VerboseMockitoJUnitRunner.class)\n public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {\n     \n     private IMethods mock;\n--- a/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/stacktrace/PointingStackTraceToActualInvocationChunkTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.junit.mockito.ExperimentalMockitoJUnitRunner;\n+import org.junit.mockito.VerboseMockitoJUnitRunner;\n import org.junit.runner.RunWith;\n import org.mockito.Mockito;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockitoutil.TestBase;\n \n //This is required to make sure stack trace is well filtered when runner is ON\n-@RunWith(ExperimentalMockitoJUnitRunner.class)\n+@RunWith(VerboseMockitoJUnitRunner.class)\n public class PointingStackTraceToActualInvocationChunkTest extends TestBase {\n     \n     private IMethods mock;", "timestamp": 1231945097, "metainfo": ""}