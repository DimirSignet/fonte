{"sha": "28be0f6b10316a709e4fd466c3e155c5a1bc1d16", "log": "got rid of special handling of overloading puzzle  --HG-- rename : test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java => test/org/mockitousage/binding/OverloadingPuzzleTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40420", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         return qualifiedMethodName() + \"(...)\";\n     }\n \n-    public String getTypedArgs() {\n-        StringBuilder result = new StringBuilder();\n-        Class<?>[] types = getMethod().getParameterTypes();\n-        for (int i = 0; i < types.length; i++) {\n-            Class<?> paramType = types[i];\n-            result.append(TAB).append(i+1).append(\": \").append(paramType);\n-            if (i != types.length-1) {\n-                result.append(\"\\n\");\n-            }\n-        } \n-        return result.toString();\n-    }\n-    \n     public String getArgs() {\n         return getArgs(argumentsToMatchers());\n     }\n     public String getArgs(List<Matcher> matchers) {\n         //TODO some unit testing please\n         if (matchers.isEmpty()) {\n-            return TAB + \"<no arguments>\"; \n+            return TAB + \"<NO ARGUMENTS>\"; \n         }\n         \n         Description d = new StringDescription();\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n                 && argumentsMatch(actual.getArguments());\n     }\n     \n-    public boolean differsWithArgumentTypes(Invocation actual) {\n+    public boolean isOverloadedVersionOf(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n             && argumentsMatch(actual.getArguments())\n             && invocation.getMethod().getName().equals(actual.getMethod().getName())\n         return invocation.getMethodName();\n     }\n \n-    public String getTypedArgs() {\n-        return invocation.getTypedArgs();\n-    }\n-    \n     public String getArgs() {\n         return invocation.getArgs(matchers);\n     }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         for (Invocation invocation : invocations) {\n+            //TODO shit code - refactor to InvocationMatcher wanted.isSimilar(invocation) and add test for overloading check, make it also efficient\n             String wantedMethodName = wanted.getMethod().getName();\n             String currentMethodName = invocation.getMethod().getName();\n             \n             boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n             boolean isUnverified = !invocation.isVerified();\n             boolean mockIsTheSame = wanted.getInvocation().getMock() == invocation.getMock();\n+            boolean isOverloaded = wanted.isOverloadedVersionOf(invocation);\n             \n-            if (methodNameEquals && isUnverified && mockIsTheSame ) {\n+            if (methodNameEquals && isUnverified && mockIsTheSame && !isOverloaded) {\n                 return invocation;\n             }\n         }\n--- a/src/org/mockito/internal/invocation/InvocationsPrinter.java\n+++ b/src/org/mockito/internal/invocation/InvocationsPrinter.java\n \n     public InvocationsPrinter(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n         wanted = wantedInvocation.getMethodName();\n-        if (wantedInvocation.differsWithArgumentTypes(actualInvocation)) {\n-            wantedArgs = wantedInvocation.getTypedArgs();\n-            actualArgs = actualInvocation.getTypedArgs();\n-        } else {\n-            wantedArgs = wantedInvocation.getArgs();\n-            actualArgs = actualInvocation.getArgs();\n-        }\n+        wantedArgs = wantedInvocation.getArgs();\n+        actualArgs = actualInvocation.getArgs();\n     }\n \n     public Printable getWanted() {\n--- a/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsPrinterTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static org.junit.Assert.assertEquals;\n-\n-import java.lang.reflect.Method;\n+import static org.junit.Assert.*;\n \n import org.junit.Test;\n import org.mockito.TestBase;\n public class InvocationsPrinterTest extends TestBase{\n \n     @Test\n+    //TODO kill it\n     public void shouldPrintWantedAndActualInvocation() throws Exception {\n         InvocationMatcher simpleMethod = new InvocationBuilder().simpleMethod().arg(\"test\").toInvocationMatcher();\n         Invocation differentMethod = new InvocationBuilder().differentMethod().arg(\"foo\").toInvocation();\n         assertEquals(\"    1st: \\\"test\\\"\", printer.getWantedArgs().toString());\n         assertEquals(\"    1st: \\\"foo\\\"\", printer.getActualArgs().toString());\n     }\n-    \n-    class Super {\n-        void test(Object o) {};\n-    }\n-    \n-    class Sub extends Super {\n-        void test(String s) {};\n-    }\n-\n-    @Test\n-    public void shouldPrintTypesWhenOnlyTypesDiffer() throws Exception {\n-        Method methodOne = Super.class.getDeclaredMethod(\"test\", Object.class);\n-        Method methodTwo = Sub.class.getDeclaredMethod(\"test\", String.class);\n-        \n-        InvocationMatcher invocationOne = new InvocationBuilder().method(methodOne).toInvocationMatcher();\n-        Invocation invocationTwo = new InvocationBuilder().method(methodTwo).toInvocation();\n-        InvocationsPrinter printer = new InvocationsPrinter(invocationOne, invocationTwo);\n-        \n-        assertEquals(invocationOne.toString(), invocationTwo.toString());\n-        \n-        assertEquals(\"Object.test(...)\", printer.getWanted().toString());\n-        assertEquals(\"    1: class java.lang.Object\", printer.getWantedArgs().toString());\n-        assertEquals(\"    1: class java.lang.String\", printer.getActualArgs().toString());\n-    }\n-    \n-    class Dummy {\n-        void test(String ... s) {};\n-        void test(Object ... o) {};\n-    }\n-    \n-    @Test\n-    public void shouldPrintVarargTypesWhenOnlyTypesDiffer() throws Exception {\n-        Method methodOne = Dummy.class.getDeclaredMethod(\"test\", new Object[]{}.getClass());\n-        Method methodTwo = Dummy.class.getDeclaredMethod(\"test\", new String[]{}.getClass());\n-        \n-        InvocationMatcher invocationOne = new InvocationBuilder().method(methodOne).arg(new Object[]{}).toInvocationMatcher();\n-        Invocation invocationTwo = new InvocationBuilder().method(methodTwo).arg(new String[]{}).toInvocation();\n-        InvocationsPrinter printer = new InvocationsPrinter(invocationOne, invocationTwo);\n-        \n-        assertEquals(invocationOne.toString(), invocationTwo.toString());\n-        \n-        assertEquals(\"Object.test(...)\", printer.getWanted().toString());\n-        assertEquals(\"    1: class [Ljava.lang.Object;\", printer.getWantedArgs().toString());\n-        assertEquals(\"    1: class [Ljava.lang.String;\", printer.getActualArgs().toString());\n-    }\n }\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n import org.mockito.internal.verification.VerifyingRecorderTest;\n import org.mockitousage.binding.BridgeMethodPuzzleTest;\n-import org.mockitousage.binding.IncorectBindingPuzzleFixedTest;\n+import org.mockitousage.binding.OverloadingPuzzleTest;\n import org.mockitousage.matchers.ComparableMatchersTest;\n import org.mockitousage.matchers.CustomMatchersTest;\n import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n                     MockitoExceptionTest.class,\n                     StackTraceFilteringTest.class,\n                     BridgeMethodPuzzleTest.class,\n-                    IncorectBindingPuzzleFixedTest.class,\n+                    OverloadingPuzzleTest.class,\n                     InvalidUsageTest.class,\n                     UsingVarargsTest.class,\n                     CustomMatchersTest.class,\n--- /dev/null\n+++ b/test/org/mockitousage/binding/OverloadingPuzzleTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.binding;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+\n+public class OverloadingPuzzleTest extends TestBase {\n+\n+    private Super mock;\n+\n+    private void setMockWithDowncast(Super mock) {\n+        this.mock = mock;\n+    }\n+\n+    private interface Super {\n+        void say(Object message);\n+    }\n+\n+    private interface Sub extends Super {\n+        void say(String message);\n+    }\n+\n+    private void say(Object message) {\n+        mock.say(message);\n+    }\n+\n+    @Test\n+    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected() throws Exception {\n+        Sub sub = mock(Sub.class);\n+        setMockWithDowncast(sub);\n+        say(\"Hello\");\n+        try {\n+            verify(sub).say(\"Hello\");\n+            fail();\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+}\n--- a/test/org/mockitousage/verification/BasicVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n \n import java.util.List;\n \n-import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.ArgumentsAreDifferentException;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicVerificationTest extends TestBase {\n \n-    private List mock;\n-    private List mockTwo;\n+    @Mock private List mock;\n+    @Mock private List mockTwo;\n     \n-    @Before \n-    public void setup() {\n-        mock = Mockito.mock(List.class);\n-        mockTwo = Mockito.mock(List.class);\n-    }\n-\n     @Test\n     public void shouldVerify() throws Exception {\n         mock.clear();\n         \n         verify(mock).add(\"test\");\n     }\n+    \n+\n+    @Test\n+    public void shouldDetectWhenOverloadedMethodCalled() throws Exception {\n+        IMethods mockThree = mock(IMethods.class);\n+        \n+        mockThree.varargs((Object[]) new Object[] {});\n+        try {\n+            verify(mockThree).varargs((String[]) new String[] {});\n+            fail();\n+        } catch(WantedButNotInvoked e) {}\n+    }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n             fail();\n         } catch (ArgumentsAreDifferentException e) {\n             assertThat(e, messageContains(\"    1st: \\\"test\\\"\"));\n-            assertThat(e, causeMessageContains(\"    <no arguments>\"));\n+            assertThat(e, causeMessageContains(\"    <NO ARGUMENTS>\"));\n         }\n     }\n \n             assertThat(e, causeMessageContains(\"2nd: null\"));\n         }\n     }\n-\n-    @Test\n-    public void shouldPrintTypesWhenMethodSupposablyTheSame() throws Exception {\n-        mock.varargs((Object[]) new Object[] {});\n-        try {\n-            verify(mock).varargs((String[]) new String[] {});\n-            fail();\n-        } catch(ArgumentsAreDifferentException e) {\n-            assertThat(e, messageContains(\"1: class [Ljava.lang.String;\"));\n-            assertThat(e, causeMessageContains(\"1: class [Ljava.lang.Object;\"));\n-        }\n-    }\n     \n     @Test\n     public void shouldSayNeverWantedButInvoked() throws Exception {", "timestamp": 1204472352, "metainfo": ""}