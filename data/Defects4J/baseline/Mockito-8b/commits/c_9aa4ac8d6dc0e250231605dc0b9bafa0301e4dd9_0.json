{"sha": "9aa4ac8d6dc0e250231605dc0b9bafa0301e4dd9", "log": "Shorter syntax for consecutive method calls using thenThrows. Refactoring of consecutive stubbing.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401058", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n      * when(mock.someMethod(\"some arg\"))\n      *  .thenReturn(\"one\")\n      *  .thenReturn(\"two\");\n+     *\n+     * //shorter version for consecutive method calls throwing exceptions:\n+     * when(mock.someMethod(\"some arg\"))\n+     *  .thenThrow(new RuntimeException(), new NullPointerException();\n      *   \n      * </pre>\n      * \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         }\n     }\n \n-    private class OngoingStubbingImpl implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n+    private abstract class BaseStubbing implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n         public NewOngoingStubbing<T> thenReturn(Object value) {\n             return thenAnswer(new Returns(value));\n         }\n \n         public NewOngoingStubbing<T> thenReturn(Object value, Object... values) {\n-            NewOngoingStubbing<T> stubbing = thenAnswer(new Returns(value));\n+            NewOngoingStubbing<T> stubbing = thenReturn(value);            \n+            if (values == null) {\n+                return stubbing.thenReturn(null);\n+            }\n             for (Object v: values) {\n-                stubbing = stubbing.thenAnswer(new Returns(v));\n+                stubbing = stubbing.thenReturn(v);\n             }\n             return stubbing;\n         }\n \n-        public NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n+        private NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n             return thenAnswer(new ThrowsException(throwable));\n         }\n \n+        public NewOngoingStubbing<T> thenThrow(Throwable... throwables) {\n+            if (throwables == null) {\n+                thenThrow((Throwable) null);\n+            }\n+            NewOngoingStubbing<T> stubbing = null;\n+            for (Throwable t: throwables) {\n+                if (stubbing == null) {\n+                    stubbing = thenThrow(t);                    \n+                } else {\n+                    stubbing = stubbing.thenThrow(t);\n+                }\n+            }\n+            return stubbing;\n+        }        \n+\n+        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n+            return toAnswer(new Returns(value));\n+        }\n+\n+        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+            return toAnswer(new ThrowsException(throwable));\n+        }\n+    }\n+    \n+    private class OngoingStubbingImpl extends BaseStubbing {\n         public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n             registeredInvocations.removeLast();\n             mockitoStubber.addAnswer(answer);\n             return new ConsecutiveStubbing();\n         }\n \n-        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n-            return toAnswer(new Returns(value));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n-            return toAnswer(new ThrowsException(throwable));\n-        }\n-\n         public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n             registeredInvocations.removeLast();\n             mockitoStubber.addAnswer(answer);\n         }\n     }\n \n-    private class ConsecutiveStubbing implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n-        public NewOngoingStubbing<T> thenReturn(Object value) {\n-            return thenAnswer(new Returns(value));\n-        }\n-\n-        public NewOngoingStubbing<T> thenReturn(Object value, Object... values) {\n-            NewOngoingStubbing<T> stubbing = thenAnswer(new Returns(value));            \n-            for (Object v: values) {\n-                stubbing = stubbing.thenAnswer(new Returns(v));\n-            }\n-            return stubbing;\n-        }\n-\n-        public NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n-            return thenAnswer(new ThrowsException(throwable));\n-        }\n-\n+    private class ConsecutiveStubbing extends BaseStubbing {\n         public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n             mockitoStubber.addConsecutiveAnswer(answer);\n             return this;\n         }\n         \n-        public DeprecatedOngoingStubbing<T> toReturn(Object value) {\n-            return toAnswer(new Returns(value));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n-            return toAnswer(new ThrowsException(throwable));\n-        }\n-\n         public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n             mockitoStubber.addConsecutiveAnswer(answer);\n             return this;\n--- a/src/org/mockito/internal/matchers/ArrayEquals.java\n+++ b/src/org/mockito/internal/matchers/ArrayEquals.java\n \n     public boolean matches(Object actual) {\n         Object wanted = getWanted();\n-        if (wanted == null) {\n+        if (wanted == null || actual == null) {\n             return super.matches(actual);\n-        } else if (actual == null) {\n-            return false;\n         } else if (wanted instanceof boolean[] && actual instanceof boolean[]) {\n             return Arrays.equals((boolean[]) wanted, (boolean[]) actual);\n         } else if (wanted instanceof byte[] && actual instanceof byte[]) {\n--- a/src/org/mockito/internal/progress/NewOngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/NewOngoingStubbing.java\n     NewOngoingStubbing<T> thenReturn(Object value, Object... values);\n \n     /**\n-     * Sets a Throwable to be thrown when the method is called. E.g:\n+     * Sets Throwable objects to be thrown when the method is called. E.g:\n      * <pre>\n      * when(mock.someMethod()).thenThrow(new RuntimeException());\n      * </pre>\n      *\n-     * If throwable is a checked exception then it has to\n+     * If throwables contain a checked exception then it has to\n      * match one of the checked exceptions of method signature.\n      *\n      * See examples in javadoc for {@link Mockito#when}\n      *\n-     * @param throwable to be thrown on method invocation\n+     * @param throwables to be thrown on method invocation\n      *\n      * @return ongoingStubbing object that allows stubbing consecutive calls\n      */\n-    NewOngoingStubbing<T> thenThrow(Throwable throwable);\n+    NewOngoingStubbing<T> thenThrow(Throwable... throwables);\n \n     /**\n      * Sets a generic Answer for the method. E.g:\n--- a/test/org/mockitousage/stubbing/StubbingConsecutiveReturnValuesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingConsecutiveReturnValuesTest.java\n         assertEquals(\"three\", mock.simpleMethod());\n     }\n \n+    @SuppressWarnings(\"all\")\n+    @Test\n+    public void shouldReturnConsecutiveValuesForTwoNulls() throws Exception {\n+        when(mock.simpleMethod()).thenReturn(null, null);\n+        \n+        assertNull(mock.simpleMethod());        \n+        assertNull(mock.simpleMethod());        \n+    }\n+\n     @Test\n     public void shouldReturnConsecutiveValuesSetByShortenThenReturnMethod() throws Exception {        \n         when(mock.simpleMethod())\n     }\n \n     @Test\n-    public void shouldReturnConsecutiveValuesSetByShortenThenReturnMethodAndThrowException()\n+    public void shouldReturnConsecutiveValueAndThrowExceptionssSetByShortenReturnMethods()\n             throws Exception {\n         when(mock.simpleMethod())\n             .thenReturn(\"zero\")\n             .thenReturn(\"one\", \"two\")\n+            .thenThrow(new NullPointerException(), new RuntimeException())\n             .thenReturn(\"three\")\n-            .thenThrow(new NullPointerException());\n+            .thenThrow(new IllegalArgumentException());\n \n         assertEquals(\"zero\", mock.simpleMethod());\n         assertEquals(\"one\", mock.simpleMethod());\n         assertEquals(\"two\", mock.simpleMethod());\n-        assertEquals(\"three\", mock.simpleMethod());\n-        try {\n-            mock.simpleMethod();\n-            fail();\n-        } catch (NullPointerException e) {}\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (NullPointerException e) {}\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (RuntimeException e) {}\n+        assertEquals(\"three\", mock.simpleMethod());\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (IllegalArgumentException e) {}\n     }\n     \n     @Test\n             .thenThrow(new RuntimeException())\n             .thenThrow(new IllegalArgumentException())\n             .thenThrow(new NullPointerException());\n+\n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (RuntimeException e) {}\n+        \n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (IllegalArgumentException e) {}\n+        \n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (NullPointerException e) {}\n+        \n+        try {\n+            mock.simpleMethod();\n+            fail();\n+        } catch (NullPointerException e) {}\n+    }\n+\n+    @Test\n+    public void shouldThrowConsecutivelySetByShortenThenThrowMethod() throws Exception {\n+        when(mock.simpleMethod())\n+            .thenThrow(new RuntimeException(), new IllegalArgumentException(), new NullPointerException());\n \n         try {\n             mock.simpleMethod();", "timestamp": 1225377716, "metainfo": ""}