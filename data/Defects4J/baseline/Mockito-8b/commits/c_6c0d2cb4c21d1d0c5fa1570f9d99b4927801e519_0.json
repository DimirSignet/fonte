{"sha": "6c0d2cb4c21d1d0c5fa1570f9d99b4927801e519", "log": "merged trunk in issue230 to see if everything is still correct  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n      * </p>\n      *\n      * <pre class=\"code\"><code class=\"java\">given(carKeyFob.authenticate(carKey)).will(returnsFirstArg());\n-     * daAnswer(returnsFirstArg()).when(carKeyFob).authenticate(carKey)</code></pre>\n+     * doAnswer(returnsFirstArg()).when(carKeyFob).authenticate(carKey)</code></pre>\n      *\n      * @param <T> Return type of the invocation.\n      * @return Answer that will return the first argument of the invocation.\n      * </p>\n      *\n      * <pre class=\"code\"><code class=\"java\">given(trader.apply(leesFormula, onCreditDefaultSwap)).will(returnsSecondArg());\n-     * daAnswer(returnsSecondArg()).when(trader).apply(leesFormula, onCreditDefaultSwap)</code></pre>\n+     * doAnswer(returnsSecondArg()).when(trader).apply(leesFormula, onCreditDefaultSwap)</code></pre>\n      *\n      * @param <T> Return type of the invocation.\n      * @return Answer that will return the second argument of the invocation.\n      * </p>\n      *\n      * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsLastArg());\n-     * daAnswer(returnsLastArg()).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n+     * doAnswer(returnsLastArg()).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n      *\n      * @param <T> Return type of the invocation.\n      * @return Answer that will return the last argument of the invocation.\n      * </p>\n      *\n      * <pre class=\"code\"><code class=\"java\">given(person.remember(dream1, dream2, dream3, dream4)).will(returnsArgAt(3));\n-     * daAnswer(returnsArgAt(3)).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n+     * doAnswer(returnsArgAt(3)).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n      *\n      * @param <T> Return type of the invocation.\n      * @return Answer that will return the second argument of the invocation.\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n \n package org.mockito;\n \n-import org.hamcrest.*;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n import org.mockito.internal.util.Decamelizer;\n \n /**\n      */\n     public abstract boolean matches(Object argument);\n \n-    /* \n-     * By default this method decamlizes matchers name to promote meaningful names for matchers.\n+    /**\n+     * By default this method decamelizes matchers name to promote meaningful names for matchers.\n      * <p>\n      * For example <b>StringWithStrongLanguage</b> matcher will generate 'String with strong language' description in case of failure.\n      * <p>\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.hamcrest.Matcher;\n     public static <T> T anyObject() {\n         return (T) reportMatcher(Any.ANY).returnNull();\n     }\n-    //TODO: after 1.8 check out Jay Fields' idea on any() matcher\n \n     /**\n      * Any vararg, meaning any number and values of arguments.\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito;\n-\n-import org.mockito.listeners.InvocationListener;\n-import org.mockito.mock.MockCreationSettings;\n-import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-\n-/**\n- * Allows mock creation with additional mock settings.\n- * <p/>\n- * Don't use it too often.\n- * Consider writing simple tests that use simple mocks.\n- * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n- * If you cannot write a test in a simple way - refactor the code under test.\n- * <p/>\n- * Examples of mock settings:\n- * <pre class=\"code\"><code class=\"java\">\n- *   //Creates mock with different default answer & name\n- *   Foo mock = mock(Foo.class, withSettings()\n- *                                .defaultAnswer(RETURNS_SMART_NULLS)\n- *                                .name(\"cool mockie\")\n- *                                );\n- *\n- *   //Creates mock with different default answer, descriptive name and extra interfaces\n- *   Foo mock = mock(Foo.class, withSettings()\n- *                                .defaultAnswer(RETURNS_SMART_NULLS)\n- *                                .name(\"cool mockie\")\n- *                                .extraInterfaces(Bar.class));\n- * </code></pre>\n- * {@link MockSettings} has been introduced for two reasons.\n- * Firstly, to make it easy to add another mock setting when the demand comes.\n- * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n- */\n-public interface MockSettings extends Serializable {\n-\n-    /**\n-     * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n-     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n-     * <p>\n-     * This mysterious feature should be used very occasionally.\n-     * The object under test should know exactly its collaborators & dependencies.\n-     * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n-     * <p>\n-     * Examples:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n-     *\n-     *   //now, the mock implements extra interfaces, so following casting is possible:\n-     *   Bar bar = (Bar) foo;\n-     *   Baz baz = (Baz) foo;\n-     * </code></pre>\n-     *\n-     * @param interfaces extra interfaces the should implement.\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings extraInterfaces(Class<?>... interfaces);\n-\n-    /**\n-     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n-     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n-     * <p>\n-     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n-     * <p>\n-     * Examples:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n-     *\n-     *   //Below does exactly the same:\n-     *   Foo foo = mock(Foo.class, \"foo\");\n-     * </code></pre>\n-     * @param name the name of the mock, later used in all verification errors\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings name(String name);\n-\n-    /**\n-     * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n-     *\n-     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n-     * <p>\n-     * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't...\n-     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * In most cases, this is not the way you want to design your application.\n-     * <p>\n-     * However, there are rare cases when partial mocks come handy:\n-     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n-     * <p>\n-     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n-     *\n-     *   //Below does exactly the same:\n-     *   Foo foo = spy(fooInstance);\n-     * </code></pre>\n-     *\n-     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n-     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n-     *\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   List list = new LinkedList();\n-     *   List spy = spy(list);\n-     *\n-     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   when(spy.get(0)).thenReturn(\"foo\");\n-     *\n-     *   //You have to use doReturn() for stubbing\n-     *   doReturn(\"foo\").when(spy).get(0);\n-     * </code>\n-     *\n-     * @param instance to spy on\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings spiedInstance(Object instance);\n-\n-    /**\n-     * Specifies default answers to interactions.\n-     * It's quite advanced feature and typically you don't need it to write decent tests.\n-     * However it can be helpful when working with legacy systems.\n-     * <p>\n-     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n-     *\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n-     *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n-     *\n-     *   //Below does exactly the same:\n-     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n-     * </code></pre>\n-     *\n-     * @param defaultAnswer default answer to be used by mock when not stubbed\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    MockSettings defaultAnswer(Answer defaultAnswer);\n-\n-    /**\n-     * Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n-     * <p>\n-     * WARNING: This should be rarely used in unit testing.\n-     * <p>\n-     * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n-     * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n-     * <p>\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   List serializableMock = mock(List.class, withSettings().serializable());\n-     * </code></pre>\n-     *\n-     * @return settings instance so that you can fluently specify other settings\n-     * @since 1.8.1\n-     */\n-    MockSettings serializable();\n-\n-    /**\n-     * Enables real-time logging of method invocations on this mock. Can be used\n-     * during test debugging in order to find wrong interactions with this mock.\n-     * <p>\n-     * Invocations are logged as they happen to the standard output stream.\n-     * <p>\n-     * Calling this method multiple times makes no difference.\n-     * <p>\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n-     * </code></pre>\n-     *\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings verboseLogging();\n-\n-    /**\n-     * Registers a listener for method invocations on this mock. The listener is\n-     * notified every time a method on this mock is called.\n-     * <p>\n-     * Multiple listeners may be added, but the same object is only added once.\n-     * The order, in which the listeners are added, is not guaranteed to be the\n-     * order in which the listeners are notified.\n-     *\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n-     * </code></pre>\n-     *\n-     * See the {@link InvocationListener listener interface} for more details.\n-     *\n-     * @param listeners The invocation listeners to add. May not be null.\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings invocationListeners(InvocationListener... listeners);\n-}\n+package org.mockito;\n+\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Allows mock creation with additional mock settings.\n+ * <p/>\n+ * Don't use it too often.\n+ * Consider writing simple tests that use simple mocks.\n+ * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n+ * If you cannot write a test in a simple way - refactor the code under test.\n+ * <p/>\n+ * Examples of mock settings:\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   //Creates mock with different default answer & name\n+ *   Foo mock = mock(Foo.class, withSettings()\n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                );\n+ *\n+ *   //Creates mock with different default answer, descriptive name and extra interfaces\n+ *   Foo mock = mock(Foo.class, withSettings()\n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                .extraInterfaces(Bar.class));\n+ * </code></pre>\n+ * {@link MockSettings} has been introduced for two reasons.\n+ * Firstly, to make it easy to add another mock setting when the demand comes.\n+ * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n+ */\n+public interface MockSettings extends Serializable {\n+\n+    /**\n+     * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n+     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n+     * <p>\n+     * This mysterious feature should be used very occasionally.\n+     * The object under test should know exactly its collaborators & dependencies.\n+     * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n+     * <p>\n+     * Examples:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n+     *\n+     *   //now, the mock implements extra interfaces, so following casting is possible:\n+     *   Bar bar = (Bar) foo;\n+     *   Baz baz = (Baz) foo;\n+     * </code></pre>\n+     *\n+     * @param interfaces extra interfaces the should implement.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings extraInterfaces(Class<?>... interfaces);\n+\n+    /**\n+     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n+     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n+     * <p>\n+     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n+     * <p>\n+     * Examples:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n+     *\n+     *   //Below does exactly the same:\n+     *   Foo foo = mock(Foo.class, \"foo\");\n+     * </code></pre>\n+     * @param name the name of the mock, later used in all verification errors\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings name(String name);\n+\n+    /**\n+     * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n+     *\n+     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n+     * <p>\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * In most cases, this is not the way you want to design your application.\n+     * <p>\n+     * However, there are rare cases when partial mocks come handy:\n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+     * <p>\n+     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n+     *\n+     *   //Below does exactly the same:\n+     *   Foo foo = spy(fooInstance);\n+     * </code></pre>\n+     *\n+     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n+     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *\n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </code>\n+     *\n+     * @param instance to spy on\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings spiedInstance(Object instance);\n+\n+    /**\n+     * Specifies default answers to interactions.\n+     * It's quite advanced feature and typically you don't need it to write decent tests.\n+     * However it can be helpful when working with legacy systems.\n+     * <p>\n+     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n+     *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n+     *\n+     *   //Below does exactly the same:\n+     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n+     * </code></pre>\n+     *\n+     * @param defaultAnswer default answer to be used by mock when not stubbed\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    MockSettings defaultAnswer(Answer defaultAnswer);\n+\n+    /**\n+     * Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n+     * <p>\n+     * WARNING: This should be rarely used in unit testing.\n+     * <p>\n+     * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n+     * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List serializableMock = mock(List.class, withSettings().serializable());\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     * @since 1.8.1\n+     */\n+    MockSettings serializable();\n+\n+    /**\n+     * Enables real-time logging of method invocations on this mock. Can be used\n+     * during test debugging in order to find wrong interactions with this mock.\n+     * <p>\n+     * Invocations are logged as they happen to the standard output stream.\n+     * <p>\n+     * Calling this method multiple times makes no difference.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings verboseLogging();\n+\n+    /**\n+     * Registers a listener for method invocations on this mock. The listener is\n+     * notified every time a method on this mock is called.\n+     * <p>\n+     * Multiple listeners may be added, but the same object is only added once.\n+     * The order, in which the listeners are added, is not guaranteed to be the\n+     * order in which the listeners are notified.\n+     *\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n+     * </code></pre>\n+     *\n+     * See the {@link InvocationListener listener interface} for more details.\n+     *\n+     * @param listeners The invocation listeners to add. May not be null.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings invocationListeners(InvocationListener... listeners);\n+\n+    /**\n+     * Sets whether this mock should only provide stubbing of methods.\n+     * A stub-only mock does not record method\n+     * invocations, thus saving memory but\n+     * disallowing verification of invocations.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * List stubOnly = mock(List.class, withSettings().stubOnly());\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings stubOnly();}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.MockitoCore;\n      * \n      * @return verification mode\n      */\n-    //TODO make exception message nicer\n     public static VerificationMode only() {\n     \treturn VerificationModeFactory.only();\n     }    \n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.misusing.FriendlyReminderException;\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n-import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.exceptions.misusing.NullInsteadOfMockException;\n-import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n-import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n-import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n-import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n-import org.mockito.exceptions.verification.NeverWantedButInvoked;\n-import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.SmartNullPointerException;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.misusing.*;\n+import org.mockito.exceptions.verification.*;\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n         throw new MockitoException(join(\n                 \"Checked exception is invalid for this method!\",\n                 \"Invalid: \" + t\n-                ));\n+        ));\n     }\n \n     public void cannotStubWithNullThrowable() {\n         throw new MockitoException(join(\n                 \"Cannot stub with null throwable!\"\n-                ));\n+        ));\n \n     }\n \n                 \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                 \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void notAMockPassedToVerifyNoMoreInteractions() {\n         throw new NotAMockException(join(\n-            \"Argument(s) passed is not a mock!\",\n-            \"Examples of correct verifications:\",\n-            \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n-            \"    verifyZeroInteractions(mockOne, mockTwo);\",\n-            \"\"\n+                \"Argument(s) passed is not a mock!\",\n+                \"Examples of correct verifications:\",\n+                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n+                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n+                \"\"\n         ));\n     }\n \n                 \"Pass mocks that require verification in order.\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n-                ));\n+        ));\n     }\n \n     public void nullPassedWhenCreatingInOrder() {\n                 \"Pass mocks that require verification in order.\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n-                ));\n+        ));\n     }\n \n     public void mocksHaveToBePassedWhenCreatingInOrder() {\n                 \"Pass mocks that require verification in order.\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n-                ));\n+        ));\n     }\n \n     public void inOrderRequiresFamiliarMock() {\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne);\",\n                 \"    inOrder.verify(mockOne).doStuff();\"\n-                ));\n+        ));\n     }\n \n     public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Invalid use of argument matchers!\",\n                 expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n-                locationsOf(recordedMatchers),\n+                        locationsOf(recordedMatchers),\n                 \"\",\n                 \"This exception may occur if matchers are combined with raw values:\",\n                 \"    //incorrect:\",\n         ));\n     }\n \n+    public void stubPassedToVerify() {\n+        throw new CannotVerifyStubOnlyMock(join(\n+                \"Argument passed to verify() is a stubOnly() mock, not a full blown mock!\",\n+                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n+        ));\n+    }\n+\n     public void reportNoSubMatchersFound(String additionalMatcherName) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"No matchers found for additional matcher \" + additionalMatcherName,\n     private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n         List<String> description = new ArrayList<String>();\n         for (LocalizedMatcher matcher : matchers)\n-\t\t\tdescription.add(matcher.getLocation().toString());\n+            description.add(matcher.getLocation().toString());\n         return join(description.toArray());\n     }\n \n                 actual,\n                 actualLocation,\n                 \"\"\n-                );\n+        );\n \n         if (JUnitTool.hasJUnit()) {\n             throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n         } else {\n             StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n             for (DescribedInvocation i : invocations) {\n-                 sb.append(i.getLocation());\n-                 sb.append(\"\\n\");\n+                sb.append(i.toString())\n+                        .append(\"\\n\")\n+                        .append(i.getLocation())\n+                        .append(\"\\n\\n\");\n             }\n             allInvocations = sb.toString();\n         }\n \n     public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n         throw new VerificationInOrderFailure(join(\n-                    \"Verification in order failure\",\n-                    \"Wanted but not invoked:\",\n-                    wanted.toString(),\n-                    new LocationImpl(),\n-                    \"Wanted anywhere AFTER following interaction:\",\n-                    previous.toString(),\n-                    previous.getLocation(),\n-                    \"\"\n+                \"Verification in order failure\",\n+                \"Wanted but not invoked:\",\n+                wanted.toString(),\n+                new LocationImpl(),\n+                \"Wanted anywhere AFTER following interaction:\",\n+                previous.toString(),\n+                previous.getLocation(),\n+                \"\"\n         ));\n     }\n \n     }\n \n     private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n-            Location firstUndesired) {\n+                                                   Location firstUndesired) {\n         return join(\n                 wanted.toString(),\n                 \"Wanted \" + pluralize(wantedCount) + \":\",\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n-                ));\n+        ));\n     }\n \n     private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n-            Location lastActualInvocation) {\n+                                                     Location lastActualInvocation) {\n         String ending =\n-            (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n-\n-            String message = join(\n-                    wanted.toString(),\n-                    \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n-                    new LocationImpl(),\n-                    \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n-                    ending\n-            );\n-            return message;\n+                (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n+\n+        String message = join(\n+                wanted.toString(),\n+                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n+                new LocationImpl(),\n+                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n+                ending\n+        );\n+        return message;\n     }\n \n     public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n \n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n-                ));\n+        ));\n     }\n \n     public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n                 \"But found this interaction:\",\n                 undesired.getLocation(),\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void cannotMockFinalClass(Class<?> clazz) {\n                 \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                 \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                 \"\"\n-             ));\n+        ));\n     }\n \n     public void onlyVoidMethodsCanBeSetToDoNothing() {\n                 \"    .when(mock).someVoidMethod();\",\n                 \"Above means:\",\n                 \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n-             ));\n+        ));\n     }\n \n     public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n                 \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                 \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n                 \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                 \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void smartNullPointerException(String invocation, Location location) {\n                 location,\n                 invocation,\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void noArgumentValueWasCaptured() {\n                 \"    verify(mock).doSomething(argument.capture());\",\n                 \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void extraInterfacesDoesNotAcceptNullParameters() {\n         throw new MockitoException(join(\n                 \"extraInterfaces() does not accept null parameters.\"\n-                ));\n+        ));\n     }\n \n     public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n \n     public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n         throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n-            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n-            \"However, I failed because: \" + details.getMessage(),\n-            \"Examples of correct usage of @Spy:\",\n-            \"   @Spy List mock = new LinkedList();\",\n-            \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n-            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n+                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n+                \"However, I failed because: \" + details.getMessage(),\n+                \"Examples of correct usage of @Spy:\",\n+                \"   @Spy List mock = new LinkedList();\",\n+                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n+                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                 \"\"), details);\n     }\n \n     public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n         throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n-            \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n-            \"However, I failed because: \" + details.getMessage(),\n-            \"Examples of correct usage of @InjectMocks:\",\n-            \"   @InjectMocks Service service = new Service();\",\n-            \"   @InjectMocks Service service;\",\n-            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n-            \"   //and... don't forget about some @Mocks for injection :)\",\n+                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n+                \"However, I failed because: \" + details.getMessage(),\n+                \"Examples of correct usage of @InjectMocks:\",\n+                \"   @InjectMocks Service service = new Service();\",\n+                \"   @InjectMocks Service service;\",\n+                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n+                \"   //and... don't forget about some @Mocks for injection :)\",\n                 \"\"), details);\n     }\n \n         ), details);\n     }\n \n-\tpublic void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n-\t\tthrow new MockitoException(join(\n+    public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n+        throw new MockitoException(join(\n                 \"Mocked type must be the same as the type of your delegated instance.\",\n                 \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                 \"  //correct delegate:\",\n                 \"  //incorrect - types don't match:\",\n                 \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n         ));\n-\t}\n-\n-\tpublic void spyAndDelegateAreMutuallyExclusive() {\n-\t\tthrow new MockitoException(join(\n-\t\t\t\t\"Settings should not define a spy instance and a delegated instance at the same time.\"\n-\t\t\t\t)) ;\n-\t}\n+    }\n+\n+    public void spyAndDelegateAreMutuallyExclusive() {\n+        throw new MockitoException(join(\n+                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n+        )) ;\n+    }\n \n     public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n         throw new MockitoException(join(\"Invalid argument index.\",\n-                                        \"The index need to be a positive number that indicates the position of the argument to return.\",\n-                                        \"However it is possible to use the -1 value to indicates that the last argument should be\",\n-                                        \"returned.\"));\n+                \"The index need to be a positive number that indicates the position of the argument to return.\",\n+                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n+                \"returned.\"));\n     }\n \n     public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n         throw new MockitoException(\n                 join(\"Invalid argument index for the current invocation of method : \",\n-                     \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n-                     \"\",\n-                     (willReturnLastParameter ?\n-                             \"Last parameter wanted\" :\n-                             \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n-                     \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n-                     \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n-                     \"\"));\n+                        \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n+                        \"\",\n+                        (willReturnLastParameter ?\n+                                \"Last parameter wanted\" :\n+                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n+                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n+                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n+                        \"\"));\n     }\n \n     private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n     public void defaultAnswerDoesNotAcceptNullParameter() {\n         throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n     }\n+\n+    public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n+        throw new MockitoException(join(\n+                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n+                \" do not implement Serializable.\",\n+                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n+                \"\",\n+                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n+                \"i.e. the top-most superclass has to implements Serializable.\",\n+                \"\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/exceptions/base/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/base/MockitoAssertionError.java\n \n package org.mockito.exceptions.base;\n \n-import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n \n \n \n--- a/src/org/mockito/exceptions/base/MockitoException.java\n+++ b/src/org/mockito/exceptions/base/MockitoException.java\n \n package org.mockito.exceptions.base;\n \n-import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n \n \n public class MockitoException extends RuntimeException {\n--- /dev/null\n+++ b/src/org/mockito/exceptions/misusing/CannotVerifyStubOnlyMock.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.exceptions.misusing;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+public class CannotVerifyStubOnlyMock extends MockitoException {\n+\n+    public CannotVerifyStubOnlyMock(String message) {\n+        super(message);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/stacktrace/StackTraceCleaner.java\n+package org.mockito.exceptions.stacktrace;\n+\n+import org.mockito.Incubating;\n+\n+/**\n+ * Decides if particular StackTraceElement is excluded from the human-readable stack trace output.\n+ * Mockito stack trace filtering mechanism uses this information.\n+ * <p>\n+ * Excluding an element will make it not show in the cleaned stack trace.\n+ * Not-excluding an element does not guarantee it will be shown\n+ * (e.g. it depends on the implementation of\n+ * Mockito internal {@link org.mockito.internal.exceptions.stacktrace.StackTraceFilter}).\n+ * <p>\n+ * The implementations are required to be thread safe. For example, make them stateless.\n+ * <p>\n+ * See the default implementation: {@link org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleaner}.\n+ *\n+ */\n+@Incubating\n+public interface StackTraceCleaner {\n+\n+    /**\n+     * Decides if element is excluded.\n+     *\n+     * @param candidate element of the actual stack trace\n+     * @return whether the element should be excluded from cleaned stack trace.\n+     */\n+    boolean isOut(StackTraceElement candidate);\n+}\n--- a/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n package org.mockito.exceptions.verification.junit;\n \n import junit.framework.ComparisonFailure;\n-\n-import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n import org.mockito.internal.util.RemoveFirstLine;\n \n \n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.configuration;\n \n import org.mockito.configuration.IMockitoConfiguration;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MockitoConfigurationException;\n import org.mockito.internal.creation.CglibMockMaker;\n+import org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider;\n import org.mockito.plugins.MockMaker;\n+import org.mockito.plugins.StackTraceCleanerProvider;\n \n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n+import java.io.*;\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.Collections;\n  */\n public class ClassPathLoader {\n     private static final MockMaker mockMaker = findPlatformMockMaker();\n+    private static final StackTraceCleanerProvider stackTraceCleanerProvider =\n+            findPluginImplementation(StackTraceCleanerProvider.class, new DefaultStackTraceCleanerProvider());\n     public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n \n     /**\n         return mockMaker;\n     }\n \n+    public static StackTraceCleanerProvider getStackTraceCleanerProvider() {\n+        //TODO we should throw some sensible exception if this is null.\n+        return stackTraceCleanerProvider;\n+    }\n+\n     /**\n      * Scans the classpath to find a mock maker plugin if one is available,\n      * allowing mockito to run on alternative platforms like Android.\n      */\n     static MockMaker findPlatformMockMaker() {\n-        for (MockMaker mockMaker : loadImplementations(MockMaker.class)) {\n-            return mockMaker; // return the first one service loader finds (if any)\n+        return findPluginImplementation(MockMaker.class, new CglibMockMaker());\n+    }\n+\n+    static <T> T findPluginImplementation(Class<T> pluginType, T defaultPlugin) {\n+        for (T plugin : loadImplementations(pluginType)) {\n+            return plugin; // return the first one service loader finds (if any)\n         }\n-        return new CglibMockMaker(); // default implementation\n+        return defaultPlugin; // default implementation\n     }\n \n     /**\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.configuration.injection.filter.*;\n+import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n-import java.util.*;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n \n import static org.mockito.internal.util.collections.Sets.newSet;\n \n @SuppressWarnings(\"unchecked\")\n public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSettings, MockCreationSettings<T> {\n \n-    private static final long serialVersionUID = 4475297236197939568L;\n+    private static final long serialVersionUID = 4475297236197939569L;\n \n     public MockSettings serializable() {\n         this.serializable = true;\n         return serializable;\n     }\n \n-\tpublic MockSettings verboseLogging() {\n+    public MockSettingsImpl stubOnly() {\n+        this.stubOnly = true;\n+        return this;\n+    }\n+\n+    public boolean isStubOnly() {\n+        return this.stubOnly;\n+    }\n+\n+    public MockSettings verboseLogging() {\n         if (!invocationListenersContainsType(VerboseMockInvocationLogger.class)) {\n             invocationListeners(new VerboseMockInvocationLogger());\n         }\n         return this;\n-\t}\n+    }\n \n     public MockSettings invocationListeners(InvocationListener... listeners) {\n         if (listeners == null || listeners.length == 0) {\n             }\n             this.invocationListeners.add(listener);\n         }\n-\t\treturn this;\n-\t}\n+        return this;\n+    }\n \n-\tprivate boolean invocationListenersContainsType(Class<?> clazz) {\n-\t\tfor (InvocationListener listener : invocationListeners) {\n-\t\t\tif (listener.getClass().equals(clazz)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n+    private boolean invocationListenersContainsType(Class<?> clazz) {\n+        for (InvocationListener listener : invocationListeners) {\n+            if (listener.getClass().equals(clazz)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n \n     public List<InvocationListener> getInvocationListeners() {\n         return this.invocationListeners;\n         //TODO SF - add this validation and also add missing coverage\n //        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n \n+        validator.validateSerializable(typeToMock, source.isSerializable());\n+\n         CreationSettings<T> settings = new CreationSettings<T>(source);\n         settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n         settings.setTypeToMock(typeToMock);\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.jmock;\n \n import org.mockito.cglib.core.CodeGenerationException;\n     \n     private ClassImposterizer() {}\n     \n-    //TODO: after 1.8, in order to provide decent exception message when objenesis is not found,\n+    //TODO: in order to provide decent exception message when objenesis is not found,\n     //have a constructor in this class that tries to instantiate ObjenesisStd and if it fails then show decent exception that dependency is missing\n-    //TODO: after 1.8, for the same reason catch and give better feedback when hamcrest core is not found.\n+    //TODO: for the same reason catch and give better feedback when hamcrest core is not found.\n     private ObjenesisStd objenesis = new ObjenesisStd(new GlobalConfiguration().enableClassCache());\n     \n     private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n     protected boolean serializable;\n     protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n     protected GenericMetadataSupport mockitoGenericMetadata;\n+    protected boolean stubOnly;\n \n     public CreationSettings() {}\n \n         this.serializable = copy.serializable;\n         this.invocationListeners = copy.invocationListeners;\n         this.mockitoGenericMetadata = copy.mockitoGenericMetadata;\n+        this.stubOnly = copy.stubOnly;\n     }\n \n     public Class<T> getTypeToMock() {\n     public void setMockitoGenericMetadata(GenericMetadataSupport mockitoGenericMetadata) {\n         this.mockitoGenericMetadata = mockitoGenericMetadata;\n     }\n+\n+    public boolean isStubOnly() {\n+        return stubOnly;\n+    }\n+\n }\n--- a/src/org/mockito/internal/debugging/LocationImpl.java\n+++ b/src/org/mockito/internal/debugging/LocationImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.debugging;\n \n+import org.mockito.internal.exceptions.stacktrace.StackTraceFilter;\n+import org.mockito.invocation.Location;\n+\n import java.io.Serializable;\n-\n-import org.mockito.internal.exceptions.base.StackTraceFilter;\n-import org.mockito.invocation.Location;\n \n public class LocationImpl implements Location, Serializable {\n \n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.exceptions.stacktrace;\n+\n+import org.mockito.configuration.IMockitoConfiguration;\n+import org.mockito.internal.configuration.GlobalConfiguration;\n+\n+import java.io.Serializable;\n+\n+public class ConditionalStackTraceFilter implements Serializable {\n+    static final long serialVersionUID = -8085849703510292641L;\n+    \n+    private IMockitoConfiguration config = new GlobalConfiguration();\n+    private StackTraceFilter filter = new StackTraceFilter();\n+    \n+    public void filter(Throwable throwable) {\n+        if (!config.cleansStackTrace()) {\n+            return;\n+        }\n+        StackTraceElement[] filtered = filter.filter(throwable.getStackTrace(), true);\n+        throwable.setStackTrace(filtered);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleaner.java\n+package org.mockito.internal.exceptions.stacktrace;\n+\n+import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n+\n+/**\n+* by Szczepan Faber, created at: 7/29/12\n+*/\n+public class DefaultStackTraceCleaner implements StackTraceCleaner {\n+    public boolean isOut(StackTraceElement e) {\n+        boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n+        boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n+        boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n+        boolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\n+        return (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/stacktrace/DefaultStackTraceCleanerProvider.java\n+package org.mockito.internal.exceptions.stacktrace;\n+\n+import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n+import org.mockito.plugins.StackTraceCleanerProvider;\n+\n+/**\n+ * by Szczepan Faber, created at: 7/29/12\n+ */\n+public class DefaultStackTraceCleanerProvider implements StackTraceCleanerProvider {\n+\n+    public StackTraceCleaner getStackTraceCleaner(StackTraceCleaner defaultCleaner) {\n+        return defaultCleaner;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.exceptions.stacktrace;\n+\n+import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n+import org.mockito.internal.configuration.ClassPathLoader;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class StackTraceFilter implements Serializable {\n+\n+    static final long serialVersionUID = -5499819791513105700L;\n+\n+    private static StackTraceCleaner cleaner =\n+            ClassPathLoader.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());\n+    \n+    /**\n+     * Example how the filter works (+/- means good/bad):\n+     * [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+]\n+     * Basically removes all bad from the middle. If any good are in the middle of bad those are also removed. \n+     */\n+    public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n+        //TODO: profile\n+        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n+        \n+        int lastBad = -1;\n+        int firstBad = -1;\n+        for (int i = 0; i < unfilteredStackTrace.size(); i++) {\n+            if (!cleaner.isOut(unfilteredStackTrace.get(i))) {\n+                continue;\n+            }\n+            lastBad = i;\n+            if (firstBad == -1) {\n+                firstBad = i;\n+            }\n+        }\n+        \n+        List<StackTraceElement> top;\n+        if (keepTop && firstBad != -1) {\n+            top = unfilteredStackTrace.subList(0, firstBad);\n+        } else {\n+            top = new LinkedList<StackTraceElement>();\n+        }\n+        \n+        List<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\n+        List<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\n+        filtered.addAll(bottom);\n+        return filtered.toArray(new StackTraceElement[]{});\n+    }\n+}\n--- a/src/org/mockito/internal/handler/MockHandlerImpl.java\n+++ b/src/org/mockito/internal/handler/MockHandlerImpl.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.handler;\n-\n-import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.*;\n-import org.mockito.internal.verification.MockAwareVerificationMode;\n-import org.mockito.internal.verification.VerificationDataImpl;\n-import org.mockito.invocation.Invocation;\n-import org.mockito.mock.MockCreationSettings;\n-import org.mockito.stubbing.Answer;\n-import org.mockito.stubbing.VoidMethodStubbable;\n-import org.mockito.verification.VerificationMode;\n-\n-import java.util.List;\n-\n-/**\n- * Invocation handler set on mock objects.\n- * \n- * @param <T>\n- *            type of mock object to handle\n- */\n-class MockHandlerImpl<T> implements InternalMockHandler<T> {\n-\n-    private static final long serialVersionUID = -2917871070982574165L;\n-\n-    InvocationContainerImpl invocationContainerImpl;\n-    MatchersBinder matchersBinder = new MatchersBinder();\n-    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n-\n-    private final MockCreationSettings mockSettings;\n-\n-    public MockHandlerImpl(MockCreationSettings mockSettings) {\n-        this.mockSettings = mockSettings;\n-        this.mockingProgress = new ThreadSafeMockingProgress();\n-        this.matchersBinder = new MatchersBinder();\n-        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n-    }\n-\n-    public Object handle(Invocation invocation) throws Throwable {\n-\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n-            // stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n-                    mockingProgress.getArgumentMatcherStorage(),\n-                    invocation\n-            );\n-            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n-            return null;\n-        }\n-        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n-\n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n-                mockingProgress.getArgumentMatcherStorage(),\n-                invocation\n-        );\n-\n-        mockingProgress.validateState();\n-\n-        // if verificationMode is not null then someone is doing verify()\n-        if (verificationMode != null) {\n-            // We need to check if verification was started on the correct mock\n-            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            // TODO: can I avoid this cast here?\n-            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n-                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n-                verificationMode.verify(data);\n-                return null;\n-            } else {\n-                // this means there is an invocation on a different mock. Re-adding verification mode\n-                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-                mockingProgress.verificationStarted(verificationMode);\n-            }\n-        }\n-\n-        // prepare invocation for stubbing\n-        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n-        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n-\n-        // look for existing answer for this invocation\n-        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n-\n-        if (stubbedInvocation != null) {\n-            stubbedInvocation.captureArgumentsFrom(invocation);\n-            return stubbedInvocation.answer(invocation);\n-        } else {\n-             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n-\n-            // redo setting invocation for potential stubbing in case of partial\n-            // mocks / spies.\n-            // Without it, the real method inside 'when' might have delegated\n-            // to other self method and overwrite the intended stubbed method\n-            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n-            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n-            return ret;\n-        }\n-\t}\n-\n-    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n-        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n-    }\n-\n-    public MockCreationSettings getMockSettings() {\n-        return mockSettings;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void setAnswersForStubbing(List<Answer> answers) {\n-        invocationContainerImpl.setAnswersForStubbing(answers);\n-    }\n-\n-    public InvocationContainer getInvocationContainer() {\n-        return invocationContainerImpl;\n-    }\n-}\n-\n+package org.mockito.internal.handler;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.verification.MockAwareVerificationMode;\n+import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n+ */\n+class MockHandlerImpl<T> implements InternalMockHandler<T> {\n+\n+    private static final long serialVersionUID = -2917871070982574165L;\n+\n+    InvocationContainerImpl invocationContainerImpl;\n+    MatchersBinder matchersBinder = new MatchersBinder();\n+    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+\n+    private final MockCreationSettings mockSettings;\n+\n+    public MockHandlerImpl(MockCreationSettings mockSettings) {\n+        this.mockSettings = mockSettings;\n+        this.mockingProgress = new ThreadSafeMockingProgress();\n+        this.matchersBinder = new MatchersBinder();\n+        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress, mockSettings);\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n+            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+            return null;\n+        }\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n+\n+        mockingProgress.validateState();\n+\n+        // if verificationMode is not null then someone is doing verify()\n+        if (verificationMode != null) {\n+            // We need to check if verification was started on the correct mock\n+            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = createVerificationData(invocationContainerImpl, invocationMatcher);\n+                verificationMode.verify(data);\n+                return null;\n+            } else {\n+                // this means there is an invocation on a different mock. Re-adding verification mode\n+                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+                mockingProgress.verificationStarted(verificationMode);\n+            }\n+        }\n+\n+        // prepare invocation for stubbing\n+        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+        // look for existing answer for this invocation\n+        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+        if (stubbedInvocation != null) {\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n+        } else {\n+             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n+        }\n+\t}\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n+    }\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        invocationContainerImpl.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return invocationContainerImpl;\n+    }\n+\n+    private VerificationDataImpl createVerificationData(InvocationContainerImpl invocationContainerImpl, InvocationMatcher invocationMatcher) {\n+        if (mockSettings.isStubOnly()) {\n+            new Reporter().stubPassedToVerify();     // this throws an exception\n+        }\n+\n+        return new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+    }\n+}\n+\n--- a/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation.realmethod;\n \n+import org.mockito.internal.creation.MockitoMethodProxy;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n+\n import java.io.Serializable;\n-\n-import org.mockito.internal.creation.MockitoMethodProxy;\n-import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n \n public class FilteredCGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy, Serializable {\n \n--- a/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n \n package org.mockito.internal.matchers;\n \n-import java.io.Serializable;\n-\n import org.hamcrest.Description;\n import org.mockito.ArgumentMatcher;\n+\n+import java.io.Serializable;\n \n \n public class EqualsWithDelta extends ArgumentMatcher<Number> implements Serializable {\n \n     public boolean matches(Object actual) {\n         Number actualNumber = (Number) actual;\n+        if (wanted == null ^ actual == null) {\n+            return false;\n+        }\n+\n+        if (wanted == null && actual == null) {\n+            return true;\n+        }\n+\n         return wanted.doubleValue() - delta.doubleValue() <= actualNumber.doubleValue()\n                 && actualNumber.doubleValue() <= wanted.doubleValue()\n                         + delta.doubleValue();\n--- a/src/org/mockito/internal/progress/HandyReturnValues.java\n+++ b/src/org/mockito/internal/progress/HandyReturnValues.java\n  */\n package org.mockito.internal.progress;\n \n-import static org.mockito.internal.util.Primitives.*;\n+import java.util.*;\n \n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import static org.mockito.internal.util.Primitives.defaultValueForPrimitiveOrWrapper;\n+import static org.mockito.internal.util.Primitives.isPrimitiveOrWrapper;\n \n @SuppressWarnings(\"unchecked\")\n public class HandyReturnValues {\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.stubbing;\n-\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.StubInfoImpl;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.stubbing.answers.AnswersValidator;\n-import org.mockito.internal.verification.RegisteredInvocations;\n-import org.mockito.invocation.Invocation;\n-import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-@SuppressWarnings(\"unchecked\")\n-public class InvocationContainerImpl implements InvocationContainer, Serializable {\n-\n-    private static final long serialVersionUID = -5334301962749537176L;\n-    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n-    private final MockingProgress mockingProgress;\n-    private final List<Answer> answersForStubbing = new ArrayList<Answer>();\n-    private final RegisteredInvocations registeredInvocations = new RegisteredInvocations();\n-\n-    private InvocationMatcher invocationForStubbing;\n-\n-    public InvocationContainerImpl(MockingProgress mockingProgress) {\n-        this.mockingProgress = mockingProgress;\n-    }\n-\n-    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n-        registeredInvocations.add(invocation.getInvocation());\n-        this.invocationForStubbing = invocation;\n-    }\n-\n-    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n-        this.invocationForStubbing = invocationMatcher;\n-    }\n-\n-    public void addAnswer(Answer answer) {\n-        registeredInvocations.removeLast();\n-        addAnswer(answer, false);\n-    }\n-\n-    public void addConsecutiveAnswer(Answer answer) {\n-        addAnswer(answer, true);\n-    }\n-\n-    public void addAnswer(Answer answer, boolean isConsecutive) {\n-        Invocation invocation = invocationForStubbing.getInvocation();\n-        mockingProgress.stubbingCompleted(invocation);\n-        AnswersValidator answersValidator = new AnswersValidator();\n-        answersValidator.validate(answer, invocation);\n-\n-        synchronized (stubbed) {\n-            if (isConsecutive) {\n-                stubbed.getFirst().addAnswer(answer);\n-            } else {\n-                stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-            }\n-        }\n-    }\n-\n-    Object answerTo(Invocation invocation) throws Throwable {\n-        return findAnswerFor(invocation).answer(invocation);\n-    }\n-\n-    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n-        synchronized (stubbed) {\n-            for (StubbedInvocationMatcher s : stubbed) {\n-                if (s.matches(invocation)) {\n-                    s.markStubUsed(invocation);\n-                    invocation.markStubbed(new StubInfoImpl(s));\n-                    return s;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    public void addAnswerForVoidMethod(Answer answer) {\n-        answersForStubbing.add(answer);\n-    }\n-\n-    public void setAnswersForStubbing(List<Answer> answers) {\n-        answersForStubbing.addAll(answers);\n-    }\n-\n-    public boolean hasAnswersForStubbing() {\n-        return !answersForStubbing.isEmpty();\n-    }\n-\n-    public boolean hasInvocationForPotentialStubbing() {\n-        return !registeredInvocations.isEmpty();\n-    }\n-\n-    public void setMethodForStubbing(InvocationMatcher invocation) {\n-        invocationForStubbing = invocation;\n-        assert hasAnswersForStubbing();\n-        for (int i = 0; i < answersForStubbing.size(); i++) {\n-            addAnswer(answersForStubbing.get(i), i != 0);\n-        }\n-        answersForStubbing.clear();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"invocationForStubbing: \" + invocationForStubbing;\n-    }\n-\n-    public List<Invocation> getInvocations() {\n-        return registeredInvocations.getAll();\n-    }\n-\n-    public List<StubbedInvocationMatcher> getStubbedInvocations() {\n-        return stubbed;\n-    }\n-\n-    public Object invokedMock() {\n-        return invocationForStubbing.getInvocation().getMock();\n-    }\n-    \n-    public InvocationMatcher getInvocationForStubbing() {\n-    \treturn invocationForStubbing;\n-    }\n-}\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.StubInfoImpl;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.stubbing.answers.AnswersValidator;\n+import org.mockito.internal.verification.DefaultRegisteredInvocations;\n+import org.mockito.internal.verification.RegisteredInvocations;\n+import org.mockito.internal.verification.SingleRegisteredInvocation;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationContainerImpl implements InvocationContainer, Serializable {\n+\n+    private static final long serialVersionUID = -5334301962749537177L;\n+    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n+    private final MockingProgress mockingProgress;\n+    private final List<Answer> answersForStubbing = new ArrayList<Answer>();\n+    private final RegisteredInvocations registeredInvocations;\n+\n+    private InvocationMatcher invocationForStubbing;\n+\n+    public InvocationContainerImpl(MockingProgress mockingProgress, MockCreationSettings mockSettings) {\n+        this.mockingProgress = mockingProgress;\n+        this.registeredInvocations = createRegisteredInvocations(mockSettings);\n+    }\n+\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        registeredInvocations.add(invocation.getInvocation());\n+        this.invocationForStubbing = invocation;\n+    }\n+\n+    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n+        this.invocationForStubbing = invocationMatcher;\n+    }\n+\n+    public void addAnswer(Answer answer) {\n+        registeredInvocations.removeLast();\n+        addAnswer(answer, false);\n+    }\n+\n+    public void addConsecutiveAnswer(Answer answer) {\n+        addAnswer(answer, true);\n+    }\n+\n+    public void addAnswer(Answer answer, boolean isConsecutive) {\n+        Invocation invocation = invocationForStubbing.getInvocation();\n+        mockingProgress.stubbingCompleted(invocation);\n+        AnswersValidator answersValidator = new AnswersValidator();\n+        answersValidator.validate(answer, invocation);\n+\n+        synchronized (stubbed) {\n+            if (isConsecutive) {\n+                stubbed.getFirst().addAnswer(answer);\n+            } else {\n+                stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+            }\n+        }\n+    }\n+\n+    Object answerTo(Invocation invocation) throws Throwable {\n+        return findAnswerFor(invocation).answer(invocation);\n+    }\n+\n+    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n+        synchronized (stubbed) {\n+            for (StubbedInvocationMatcher s : stubbed) {\n+                if (s.matches(invocation)) {\n+                    s.markStubUsed(invocation);\n+                    invocation.markStubbed(new StubInfoImpl(s));\n+                    return s;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public void addAnswerForVoidMethod(Answer answer) {\n+        answersForStubbing.add(answer);\n+    }\n+\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        answersForStubbing.addAll(answers);\n+    }\n+\n+    public boolean hasAnswersForStubbing() {\n+        return !answersForStubbing.isEmpty();\n+    }\n+\n+    public boolean hasInvocationForPotentialStubbing() {\n+        return !registeredInvocations.isEmpty();\n+    }\n+\n+    public void setMethodForStubbing(InvocationMatcher invocation) {\n+        invocationForStubbing = invocation;\n+        assert hasAnswersForStubbing();\n+        for (int i = 0; i < answersForStubbing.size(); i++) {\n+            addAnswer(answersForStubbing.get(i), i != 0);\n+        }\n+        answersForStubbing.clear();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"invocationForStubbing: \" + invocationForStubbing;\n+    }\n+\n+    public List<Invocation> getInvocations() {\n+        return registeredInvocations.getAll();\n+    }\n+\n+    public List<StubbedInvocationMatcher> getStubbedInvocations() {\n+        return stubbed;\n+    }\n+\n+    public Object invokedMock() {\n+        return invocationForStubbing.getInvocation().getMock();\n+    }\n+    \n+    public InvocationMatcher getInvocationForStubbing() {\n+    \treturn invocationForStubbing;\n+    }\n+\n+    private RegisteredInvocations createRegisteredInvocations(MockCreationSettings mockSettings) {\n+        return mockSettings.isStubOnly()\n+          ? new SingleRegisteredInvocation()\n+          : new DefaultRegisteredInvocations();\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n-import java.io.Serializable;\n-\n-import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n \n public class ThrowsException implements Answer<Object>, Serializable {\n \n--- a/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java\n \n package org.mockito.internal.stubbing.answers;\n \n-import org.mockito.internal.exceptions.base.ConditionalStackTraceFilter;\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.objenesis.ObjenesisHelper;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n  */\n \n package org.mockito.internal.stubbing.defaultanswers;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.SortedMap;\n-import java.util.SortedSet;\n-import java.util.TreeMap;\n-import java.util.TreeSet;\n \n import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.mock.MockName;\n import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.*;\n \n /**\n  * Default answer of every Mockito mock.\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n \n+import java.io.Serializable;\n import java.util.Collection;\n \n @SuppressWarnings(\"unchecked\")\n     }\n \n     public void validateDelegatedInstance(Class classToMock, Object delegatedInstance) {\n-    \tif (classToMock == null || delegatedInstance == null) {\n+        if (classToMock == null || delegatedInstance == null) {\n             return;\n         }\n-    \tif (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n+        if (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n             new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n         }\n     }\n+\n+    public void validateSerializable(Class classToMock, boolean serializable) {\n+        // We can't catch all the errors with this piece of code\n+        // Having a **superclass that do not implements Serializable** might fail as well when serialized\n+        // Though it might prevent issues when mockito is mocking a class without superclass.\n+        if(serializable && !classToMock.isInterface() && !(Serializable.class.isAssignableFrom(classToMock))) {\n+            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/DefaultRegisteredInvocations.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockito.invocation.Invocation;\n+\n+import java.io.Serializable;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+public class DefaultRegisteredInvocations implements RegisteredInvocations, Serializable {\n+\n+    private static final long serialVersionUID = -2674402327380736290L;\n+    private final LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n+\n+    public void add(Invocation invocation) {\n+        synchronized (invocations) {\n+            invocations.add(invocation);\n+        }\n+    }\n+\n+    public void removeLast() {\n+        //TODO: add specific test for synchronization of this block (it is tested by InvocationContainerImplTest at the moment)\n+        synchronized (invocations) {\n+            if (! invocations.isEmpty()) {\n+                invocations.removeLast();\n+            }\n+        }\n+    }\n+\n+    public List<Invocation> getAll() {\n+    \tList<Invocation> copiedList;\n+    \tsynchronized (invocations) {\n+\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n+\t\t}\n+\n+        return ListUtil.filter(copiedList, new RemoveToString());\n+    }\n+\n+    public boolean isEmpty() {\n+        synchronized (invocations) {\n+            return invocations.isEmpty();\n+        }\n+    }\n+\n+    private static class RemoveToString implements Filter<Invocation> {\n+        public boolean isOut(Invocation invocation) {\n+            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n+        }\n+    }\n+\n+}\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n \n package org.mockito.internal.verification;\n \n-import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.util.collections.ListUtil;\n import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.invocation.Invocation;\n \n-import java.io.Serializable;\n-import java.util.Collections;\n-import java.util.LinkedList;\n import java.util.List;\n \n \n-public class RegisteredInvocations implements Serializable {\n+public interface RegisteredInvocations {\n \n-    private static final long serialVersionUID = -2674402327380736290L;\n-    private final List<Invocation> invocations = Collections.synchronizedList(new LinkedList<Invocation>());\n+    void add(Invocation invocation);\n \n-    public void add(Invocation invocation) {\n-        invocations.add(invocation);\n-    }\n+    void removeLast();\n \n-    public void removeLast() {\n-        //TODO: add specific test for synchronization of this block (it is tested by InvocationContainerImplTest at the moment)\n-        synchronized (invocations) {\n-            int last = invocations.size() - 1;\n-            invocations.remove(last);\n-        }\n-    }\n+    List<Invocation> getAll();\n \n-    public List<Invocation> getAll() {\n-    \tList<Invocation> copiedList;\n-    \tsynchronized (invocations) {\n-\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n-\t\t}\n+    boolean isEmpty();\n \n-        return ListUtil.filter(copiedList, new RemoveToString());\n-    }\n-\n-    public boolean isEmpty() {\n-        return invocations.isEmpty();\n-    }\n-\n-    private static class RemoveToString implements Filter<Invocation> {\n-        public boolean isOut(Invocation invocation) {\n-            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/SingleRegisteredInvocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.invocation.Invocation;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class SingleRegisteredInvocation implements RegisteredInvocations, Serializable {\n+\n+    private Invocation invocation;\n+\n+    public void add(Invocation invocation) {\n+        this.invocation = invocation;\n+    }\n+\n+    public void removeLast() {\n+        invocation = null;\n+    }\n+\n+    public List<Invocation> getAll() {\n+        return Collections.emptyList();\n+    }\n+\n+    public boolean isEmpty() {\n+        return invocation == null;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerificationModeFactory.java\n+++ b/src/org/mockito/internal/verification/VerificationModeFactory.java\n     }\n \n     public static VerificationMode only() {\n-        return new Only();\n+        return new Only(); //TODO make exception message nicer\n     }\n \n     public static Times times(int wantedNumberOfInvocations) {\n--- a/src/org/mockito/mock/MockCreationSettings.java\n+++ b/src/org/mockito/mock/MockCreationSettings.java\n     boolean isSerializable();\n \n     /**\n+     * Whether the mock is only for stubbing, i.e. does not remember\n+     * parameters on its invocation and therefore cannot\n+     * be used for verification\n+     */\n+    boolean isStubOnly();\n+\n+    /**\n      * the invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n      */\n     List<InvocationListener> getInvocationListeners();\n--- /dev/null\n+++ b/src/org/mockito/plugins/StackTraceCleanerProvider.java\n+package org.mockito.plugins;\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n+\n+/**\n+ * An extension point to register custom {@link StackTraceCleaner}.\n+ * You can replace Mockito's default StackTraceCleaner.\n+ * You can also 'enhance' Mockito's default behavior\n+ * because the default cleaner is passed as parameter to the method.\n+ * <p>\n+ * For more information how to register custom StackTraceCleaner\n+ * please refer to the documentation of {@link MockMaker}.\n+ * We will update the documentation shortly.\n+ * <p>\n+ * See the default implementation: {@link org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider}\n+ */\n+@Incubating\n+public interface StackTraceCleanerProvider {\n+\n+    /**\n+     * Allows configuring custom StackTraceCleaner.\n+     *\n+     * @param defaultCleaner - Mockito's default StackTraceCleaner\n+     * @return StackTraceCleaner to use\n+     */\n+    StackTraceCleaner getStackTraceCleaner(StackTraceCleaner defaultCleaner);\n+}\n--- /dev/null\n+++ b/subprojects/extTest/src/test/java/org/mockitousage/plugins/stacktrace/MyStackTraceCleanerProvider.java\n+package org.mockitousage.plugins.stacktrace;\n+\n+import org.mockito.exceptions.stacktrace.StackTraceCleaner;\n+import org.mockito.plugins.StackTraceCleanerProvider;\n+\n+/**\n+ * By Szczepan Faber on 9/15/12\n+ */\n+public class MyStackTraceCleanerProvider implements StackTraceCleanerProvider {\n+\n+    public static boolean ENABLED = true;\n+\n+    public StackTraceCleaner getStackTraceCleaner(final StackTraceCleaner defaultCleaner) {\n+        return new StackTraceCleaner() {\n+            public boolean isOut(StackTraceElement candidate) {\n+                if (ENABLED && candidate.getMethodName().contains(\"excludeMe\")) {\n+                    return true;\n+                }\n+                return defaultCleaner.isOut(candidate);\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/subprojects/extTest/src/test/java/org/mockitousage/plugins/stacktrace/PluginStackTraceFilteringTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.plugins.stacktrace;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockito.Mockito.verify;\n+\n+public class PluginStackTraceFilteringTest extends TestBase {\n+    \n+    @Mock private IMethods mock;\n+\n+    @After\n+    public void resetState() {\n+        super.resetState();\n+    }\n+\n+    @Before\n+    public void setup() {\n+        super.makeStackTracesClean();\n+    }\n+\n+    @Test\n+    public void pluginFiltersOutStackTraceElement() {\n+        try {\n+            MyStackTraceCleanerProvider.ENABLED = true;\n+            verifyMock_x();\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            String trace = getStackTrace(e);\n+            assertContains(\"verifyMock_x\", trace);\n+            assertNotContains(\"verify_excludeMe_x\", trace);\n+        }\n+    }\n+\n+    @Test\n+    public void pluginDoesNotFilterOutStackTraceElement() {\n+        try {\n+            MyStackTraceCleanerProvider.ENABLED = false;\n+            verifyMock_x();\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            String trace = getStackTrace(e);\n+            assertContains(\"verifyMock_x\", trace);\n+            assertContains(\"verify_excludeMe_x\", trace);\n+        }\n+    }\n+\n+    private void verify_excludeMe_x() {\n+        verify(mock).simpleMethod();\n+    }\n+\n+    private void verifyMock_x() {\n+        verify_excludeMe_x();\n+    }\n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.concurrentmockito;\n-\n-import org.junit.Test;\n-import org.junit.runner.JUnitCore;\n-import org.junit.runner.Result;\n-import org.junit.runner.notification.Failure;\n-import org.mockito.MockitoTest;\n-import org.mockito.exceptions.ReporterTest;\n-import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n-import org.mockito.exceptions.base.MockitoExceptionTest;\n-import org.mockito.internal.AllInvocationsFinderTest;\n-import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n-import org.mockito.internal.handler.MockHandlerImplTest;\n-import org.mockito.internal.invocation.InvocationImplTest;\n-import org.mockito.internal.invocation.InvocationMatcherTest;\n-import org.mockito.internal.invocation.InvocationsFinderTest;\n-import org.mockito.internal.matchers.ComparableMatchersTest;\n-import org.mockito.internal.matchers.EqualsTest;\n-import org.mockito.internal.matchers.MatchersToStringTest;\n-import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.TimesTest;\n-import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n-import org.mockito.internal.util.MockUtilTest;\n-import org.mockito.internal.util.collections.ListUtilTest;\n-import org.mockito.internal.verification.RegisteredInvocationsTest;\n-import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n-import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n-import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n-import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n-import org.mockitousage.basicapi.ReplacingObjectMethodsTest;\n-import org.mockitousage.basicapi.ResetTest;\n-import org.mockitousage.basicapi.UsingVarargsTest;\n-import org.mockitousage.examples.use.ExampleTest;\n-import org.mockitousage.matchers.CustomMatchersTest;\n-import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n-import org.mockitousage.matchers.MatchersTest;\n-import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n-import org.mockitousage.misuse.InvalidUsageTest;\n-import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n-import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n-import org.mockitousage.stacktrace.ClickableStackTracesTest;\n-import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n-import org.mockitousage.stacktrace.StackTraceFilteringTest;\n-import org.mockitousage.stubbing.BasicStubbingTest;\n-import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n-import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n-import org.mockitousage.verification.*;\n-import org.mockitoutil.TestBase;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n-    \n-    private static class AllTestsRunner extends Thread {\n-        \n-        private boolean failed;\n-\n-        public void run() {\n-            Result result = JUnitCore.runClasses(\n-                    EqualsTest.class,\n-                    ListUtilTest.class,\n-                    MockingProgressImplTest.class,\n-                    TimesTest.class,\n-                    MockHandlerImplTest.class,\n-                    AllInvocationsFinderTest.class,\n-                    ReturnsEmptyValuesTest.class,\n-                    NumberOfInvocationsCheckerTest.class,\n-                    RegisteredInvocationsTest.class,\n-                    MissingInvocationCheckerTest.class,\n-                    NumberOfInvocationsInOrderCheckerTest.class,\n-                    MissingInvocationInOrderCheckerTest.class,\n-                    ClassImposterizerTest.class,\n-                    InvocationMatcherTest.class,\n-                    InvocationsFinderTest.class,\n-                    InvocationImplTest.class,\n-                    MockitoTest.class,\n-                    MockUtilTest.class,\n-                    ReporterTest.class,\n-                    MockitoAssertionErrorTest.class,\n-                    MockitoExceptionTest.class,\n-                    StackTraceFilteringTest.class,\n-                    BridgeMethodPuzzleTest.class,\n-                    OverloadingPuzzleTest.class,\n-                    InvalidUsageTest.class,\n-                    UsingVarargsTest.class,\n-                    CustomMatchersTest.class,\n-                    ComparableMatchersTest.class,\n-                    InvalidUseOfMatchersTest.class,\n-                    MatchersTest.class,\n-                    MatchersToStringTest.class,\n-                    VerificationAndStubbingUsingMatchersTest.class,\n-                    BasicStubbingTest.class,\n-                    ReturningDefaultValuesTest.class,\n-                    StubbingWithThrowablesTest.class,\n-                    AtMostXVerificationTest.class,\n-                    BasicVerificationTest.class,\n-                    ExactNumberOfTimesVerificationTest.class,\n-                    VerificationInOrderTest.class,\n-                    NoMoreInteractionsVerificationTest.class,\n-                    SelectedMocksInOrderVerificationTest.class,\n-                    VerificationOnMultipleMocksUsingMatchersTest.class,\n-                    VerificationUsingMatchersTest.class,\n-                    RelaxedVerificationInOrderTest.class,\n-                    DescriptiveMessagesWhenVerificationFailsTest.class,\n-                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n-                    BasicVerificationInOrderTest.class,\n-                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n-                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n-                    InvalidStateDetectionTest.class,\n-                    ReplacingObjectMethodsTest.class,\n-                    ClickableStackTracesTest.class,\n-                    ExampleTest.class,\n-                    PointingStackTraceToActualInvocationTest.class,\n-                    VerificationInOrderFromMultipleThreadsTest.class,\n-                    ResetTest.class\n-                );\n-                \n-                if (!result.wasSuccessful()) {\n-                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n-                    List<Failure> failures = result.getFailures();\n-                    System.err.println(failures.size());\n-                    for (Failure failure : failures) {\n-                        System.err.println(failure.getTrace());\n-                        failed = true;\n-                    }\n-                }\n-        }\n-\n-        public boolean isFailed() {\n-            return failed;\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldRunInMultipleThreads() throws Exception {\n-        //this test ALWAYS fails if there is a single failing unit\n-        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(3));\n-    }\n-    \n-    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n-        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n-        for (int i = 1; i <= numberOfThreads; i++) {\n-            threads.add(new AllTestsRunner());\n-        }\n-\n-        for (Thread t : threads) {\n-            t.start();\n-        }\n-\n-        boolean failed = false;\n-        for (AllTestsRunner t : threads) {\n-            t.join();\n-            failed = failed ? true : t.isFailed();\n-        }\n-        \n-        return failed;\n-    }\n-    \n-    public static void main(String[] args) throws Exception {\n-        int numberOfThreads = 20; \n-        long before = System.currentTimeMillis();\n-        runInMultipleThreads(numberOfThreads);\n-        long after = System.currentTimeMillis();\n-        long executionTime = (after-before)/1000;\n-        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n-    }\n+package org.concurrentmockito;\n+\n+import org.junit.Test;\n+import org.junit.runner.JUnitCore;\n+import org.junit.runner.Result;\n+import org.junit.runner.notification.Failure;\n+import org.mockito.MockitoTest;\n+import org.mockito.exceptions.ReporterTest;\n+import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n+import org.mockito.exceptions.base.MockitoExceptionTest;\n+import org.mockito.internal.AllInvocationsFinderTest;\n+import org.mockito.internal.InvalidStateDetectionTest;\n+import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.handler.MockHandlerImplTest;\n+import org.mockito.internal.invocation.InvocationImplTest;\n+import org.mockito.internal.invocation.InvocationMatcherTest;\n+import org.mockito.internal.invocation.InvocationsFinderTest;\n+import org.mockito.internal.matchers.ComparableMatchersTest;\n+import org.mockito.internal.matchers.EqualsTest;\n+import org.mockito.internal.matchers.MatchersToStringTest;\n+import org.mockito.internal.progress.MockingProgressImplTest;\n+import org.mockito.internal.progress.TimesTest;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n+import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.util.collections.ListUtilTest;\n+import org.mockito.internal.verification.DefaultRegisteredInvocationsTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n+import org.mockitousage.basicapi.ReplacingObjectMethodsTest;\n+import org.mockitousage.basicapi.ResetTest;\n+import org.mockitousage.basicapi.UsingVarargsTest;\n+import org.mockitousage.examples.use.ExampleTest;\n+import org.mockitousage.matchers.CustomMatchersTest;\n+import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n+import org.mockitousage.matchers.MatchersTest;\n+import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n+import org.mockitousage.misuse.InvalidUsageTest;\n+import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n+import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n+import org.mockitousage.stacktrace.ClickableStackTracesTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n+import org.mockitousage.stacktrace.StackTraceFilteringTest;\n+import org.mockitousage.stubbing.BasicStubbingTest;\n+import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n+import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n+import org.mockitousage.verification.*;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n+    \n+    private static class AllTestsRunner extends Thread {\n+        \n+        private boolean failed;\n+\n+        public void run() {\n+            Result result = JUnitCore.runClasses(\n+                    EqualsTest.class,\n+                    ListUtilTest.class,\n+                    MockingProgressImplTest.class,\n+                    TimesTest.class,\n+                    MockHandlerImplTest.class,\n+                    AllInvocationsFinderTest.class,\n+                    ReturnsEmptyValuesTest.class,\n+                    NumberOfInvocationsCheckerTest.class,\n+                    DefaultRegisteredInvocationsTest.class,\n+                    MissingInvocationCheckerTest.class,\n+                    NumberOfInvocationsInOrderCheckerTest.class,\n+                    MissingInvocationInOrderCheckerTest.class,\n+                    ClassImposterizerTest.class,\n+                    InvocationMatcherTest.class,\n+                    InvocationsFinderTest.class,\n+                    InvocationImplTest.class,\n+                    MockitoTest.class,\n+                    MockUtilTest.class,\n+                    ReporterTest.class,\n+                    MockitoAssertionErrorTest.class,\n+                    MockitoExceptionTest.class,\n+                    StackTraceFilteringTest.class,\n+                    BridgeMethodPuzzleTest.class,\n+                    OverloadingPuzzleTest.class,\n+                    InvalidUsageTest.class,\n+                    UsingVarargsTest.class,\n+                    CustomMatchersTest.class,\n+                    ComparableMatchersTest.class,\n+                    InvalidUseOfMatchersTest.class,\n+                    MatchersTest.class,\n+                    MatchersToStringTest.class,\n+                    VerificationAndStubbingUsingMatchersTest.class,\n+                    BasicStubbingTest.class,\n+                    ReturningDefaultValuesTest.class,\n+                    StubbingWithThrowablesTest.class,\n+                    AtMostXVerificationTest.class,\n+                    BasicVerificationTest.class,\n+                    ExactNumberOfTimesVerificationTest.class,\n+                    VerificationInOrderTest.class,\n+                    NoMoreInteractionsVerificationTest.class,\n+                    SelectedMocksInOrderVerificationTest.class,\n+                    VerificationOnMultipleMocksUsingMatchersTest.class,\n+                    VerificationUsingMatchersTest.class,\n+                    RelaxedVerificationInOrderTest.class,\n+                    DescriptiveMessagesWhenVerificationFailsTest.class,\n+                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n+                    BasicVerificationInOrderTest.class,\n+                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n+                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n+                    InvalidStateDetectionTest.class,\n+                    ReplacingObjectMethodsTest.class,\n+                    ClickableStackTracesTest.class,\n+                    ExampleTest.class,\n+                    PointingStackTraceToActualInvocationTest.class,\n+                    VerificationInOrderFromMultipleThreadsTest.class,\n+                    ResetTest.class\n+                );\n+                \n+                if (!result.wasSuccessful()) {\n+                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n+                    List<Failure> failures = result.getFailures();\n+                    System.err.println(failures.size());\n+                    for (Failure failure : failures) {\n+                        System.err.println(failure.getTrace());\n+                        failed = true;\n+                    }\n+                }\n+        }\n+\n+        public boolean isFailed() {\n+            return failed;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRunInMultipleThreads() throws Exception {\n+        //this test ALWAYS fails if there is a single failing unit\n+        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(3));\n+    }\n+    \n+    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n+        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n+        for (int i = 1; i <= numberOfThreads; i++) {\n+            threads.add(new AllTestsRunner());\n+        }\n+\n+        for (Thread t : threads) {\n+            t.start();\n+        }\n+\n+        boolean failed = false;\n+        for (AllTestsRunner t : threads) {\n+            t.join();\n+            failed = failed ? true : t.isFailed();\n+        }\n+        \n+        return failed;\n+    }\n+    \n+    public static void main(String[] args) throws Exception {\n+        int numberOfThreads = 20; \n+        long before = System.currentTimeMillis();\n+        runInMultipleThreads(numberOfThreads);\n+        long after = System.currentTimeMillis();\n+        long executionTime = (after-before)/1000;\n+        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n+    }\n }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n \n package org.mockito;\n \n-import static org.mockito.Mockito.*;\n-\n-import java.util.List;\n-\n import org.junit.Test;\n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.times;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoTest extends TestBase {\n         assertEquals(Mockito.RETURNS_DEFAULTS, settings.getDefaultAnswer());\n     }\n     \n-    //TODO: after 1.8 stack filter does not work very well when it comes to threads?\n+    //TODO: stack filter does not work very well when it comes to threads?\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/exceptions/stacktrace/ConditionalStackTraceFilterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.exceptions.stacktrace;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.TraceBuilder;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockitoutil.ExtraMatchers.hasOnlyThoseClassesInStackTrace;\n+\n+public class ConditionalStackTraceFilterTest extends TestBase {\n+    \n+    private ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n+\n+    @Test\n+    public void shouldNotFilterWhenConfigurationSaysNo() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(false);\n+        \n+        Throwable t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\" \n+        ).toThrowable();\n+        \n+        filter.filter(t);\n+        \n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.mockito.Mockito\", \"org.test.MockitoSampleTest\"));\n+    }\n+\n+    @Test\n+    public void shouldFilterWhenConfigurationSaysYes() {\n+        ConfigurationAccess.getConfig().overrideCleansStackTrace(true);\n+        \n+        Throwable t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\" \n+        ).toThrowable();\n+        \n+        filter.filter(t);\n+        \n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.test.MockitoSampleTest\"));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/exceptions/stacktrace/StackTraceFilterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.exceptions.stacktrace;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.TraceBuilder;\n+import org.mockitoutil.TestBase;\n+\n+import static org.mockitoutil.ExtraMatchers.hasOnlyThoseClasses;\n+\n+public class StackTraceFilterTest extends TestBase {\n+    \n+    private StackTraceFilter filter = new StackTraceFilter();\n+    \n+    @Test\n+    public void shouldFilterOutCglibGarbage() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+            \"MockitoExampleTest\",\n+            \"List$$EnhancerByMockitoWithCGLIB$$2c406024\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, false);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"MockitoExampleTest\"));\n+    }\n+    \n+    @Test\n+    public void shouldFilterOutMockitoPackage() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+            \"org.test.MockitoSampleTest\",\n+            \"org.mockito.Mockito\"\n+        ).toTraceArray();\n+            \n+        StackTraceElement[] filtered = filter.filter(t, false);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\"));\n+    }\n+    \n+    @Test\n+    public void shouldFilterOutTracesMiddleBadTraces() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.test.TestSupport\",\n+                \"org.mockito.Mockito\", \n+                \"org.test.TestSupport\",\n+                \"org.mockito.Mockito\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, false);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n+    }\n+    \n+    @Test\n+    public void shouldKeepRunners() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.mockito.runners.Runner\",\n+                \"junit.stuff\",\n+                \"org.test.MockitoSampleTest\",\n+                \"org.mockito.Mockito\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, false);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"junit.stuff\", \"org.mockito.runners.Runner\"));\n+    }\n+    \n+    @Test\n+    public void shouldKeepInternalRunners() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.mockito.internal.runners.Runner\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, false);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"org.mockito.internal.runners.Runner\"));\n+    }\n+    \n+    @Test\n+    public void shouldStartFilteringAndKeepTop() {\n+        //given\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.test.Good\",\n+                \"org.mockito.internal.Bad\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        //when\n+        StackTraceElement[] filtered = filter.filter(t, true);\n+        \n+        //then\n+        assertThat(filtered, hasOnlyThoseClasses(\"org.test.MockitoSampleTest\", \"org.test.Good\"));\n+    }\n+\n+    @Test\n+    public void shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions() {\n+        StackTraceElement[] t = new TraceBuilder().classes(\n+                \"org.good.Trace\",\n+                \"org.yet.another.good.Trace\",\n+                \"org.mockito.internal.to.be.Filtered\",\n+                \"org.test.MockitoSampleTest\"\n+        ).toTraceArray();\n+        \n+        StackTraceElement[] filtered = filter.filter(t, true);\n+        \n+        assertThat(filtered, hasOnlyThoseClasses(\n+                \"org.test.MockitoSampleTest\",\n+                \"org.yet.another.good.Trace\",\n+                \"org.good.Trace\"\n+                ));\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyArrayWhenInputIsEmpty() throws Exception {\n+        //when\n+        StackTraceElement[] filtered = filter.filter(new StackTraceElement[0], false);\n+        //then\n+        assertEquals(0, filtered.length);\n+    }\n+}\n--- a/test/org/mockito/internal/runners/util/TestMethodsFinderTest.java\n+++ b/test/org/mockito/internal/runners/util/TestMethodsFinderTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.runners.util;\n \n import org.junit.Test;\n \n public class TestMethodsFinderTest extends TestBase {\n \n-    static class HasTests {\n+    public static class HasTests {\n         @Test public void someTest() {}\n     }\n \n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplStubbingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.stubbing;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.invocation.Invocation;\n+import org.mockitoutil.TestBase;\n+\n+public class InvocationContainerImplStubbingTest extends TestBase {\n+\n+    private InvocationContainerImpl invocationContainerImpl;\n+    private InvocationContainerImpl invocationContainerImplStubOnly;\n+    private MockingProgress state;\n+    private Invocation simpleMethod;\n+\n+    @Before\n+    public void setup() {\n+        state = new MockingProgressImpl();\n+\n+        invocationContainerImpl = new InvocationContainerImpl(state, new MockSettingsImpl());\n+        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+\n+        invocationContainerImplStubOnly =\n+          new InvocationContainerImpl(state, new MockSettingsImpl().stubOnly());\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+\n+        simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+    }\n+\n+    @Test\n+    public void should_finish_stubbing_when_wrong_throwable_is_set() throws Exception {\n+        state.stubbingStarted();\n+        try {\n+            invocationContainerImpl.addAnswer(new ThrowsException(new Exception()));\n+            fail();\n+        } catch (MockitoException e) {\n+            state.validateState();\n+        }\n+    }\n+\n+    @Test\n+    public void should_finish_stubbing_on_adding_return_value() throws Exception {\n+        state.stubbingStarted();\n+        invocationContainerImpl.addAnswer(new Returns(\"test\"));\n+        state.validateState();\n+    }\n+\n+    @Test\n+    public void should_get_results_for_methods() throws Throwable {\n+        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        invocationContainerImpl.addAnswer(new Returns(\"simpleMethod\"));\n+\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));\n+\n+        assertEquals(\"simpleMethod\", invocationContainerImpl.answerTo(simpleMethod));\n+\n+        try {\n+            invocationContainerImpl.answerTo(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_get_results_for_methods_stub_only() throws Throwable {\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        invocationContainerImplStubOnly.addAnswer(new Returns(\"simpleMethod\"));\n+\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        invocationContainerImplStubOnly.addAnswer(new ThrowsException(new MyException()));\n+\n+        assertEquals(\"simpleMethod\", invocationContainerImplStubOnly.answerTo(simpleMethod));\n+\n+        try {\n+            invocationContainerImplStubOnly.answerTo(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_add_throwable_for_void_method() throws Throwable {\n+        invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new MyException()));\n+        invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));\n+\n+        try {\n+            invocationContainerImpl.answerTo(simpleMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_validate_throwable_for_void_method() throws Throwable {\n+        invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new Exception()));\n+\n+        try {\n+            invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @Test\n+    public void should_validate_throwable() throws Throwable {\n+        try {\n+            invocationContainerImpl.addAnswer(new ThrowsException(null));\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    class MyException extends RuntimeException {};\n+}\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.stubbing;\n-\n-import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.answers.Returns;\n-import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n-import org.mockito.invocation.Invocation;\n-\n-import java.util.LinkedList;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-/**\n- * Author: Szczepan Faber\n- */\n-public class InvocationContainerImplTest {\n-\n-    InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress());\n-    Invocation invocation = new InvocationBuilder().toInvocation();\n-    LinkedList<Throwable> exceptions = new LinkedList<Throwable>();\n-\n-    @Test\n-    //works 50% of the time\n-    public void shouldBeThreadSafe() throws Throwable {\n-        //given\n-        Thread[] t = new Thread[200];\n-        for (int i = 0; i < t.length; i++ ) {\n-            t[i] = new Thread() {\n-                public void run() {\n-                    try {\n-                        Thread.sleep(10); //NOPMD\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n-                    container.addAnswer(new Returns(\"foo\"));\n-                    container.findAnswerFor(invocation);\n-                }\n-            };\n-            t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-                public void uncaughtException(Thread t, Throwable e) {\n-                    exceptions.add(e);\n-                }\n-            });\n-            t[i].start();\n-        }\n-\n-        //when\n-        for (Thread aT : t) {\n-            aT.join();\n-        }\n-\n-        //then\n-        if (exceptions.size() != 0) {\n-            throw exceptions.getFirst();\n-        }\n-    }\n-\n-    @Test\n-    public void shouldReturnInvokedMock() throws Exception {\n-        container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n-\n-        assertEquals(invocation.getMock(), container.invokedMock());\n-    }\n-\n-    @Test\n-    public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {\n-        container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n-        assertTrue(container.hasInvocationForPotentialStubbing());\n-\n-        container.addAnswer(new ReturnsEmptyValues());\n-        assertFalse(container.hasInvocationForPotentialStubbing());\n-    }\n-}\n+package org.mockito.internal.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n+import org.mockito.invocation.Invocation;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.mock.MockCreationSettings;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Author: Szczepan Faber\n+ */\n+public class InvocationContainerImplTest {\n+\n+    InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());\n+    InvocationContainerImpl containerStubOnly =\n+      new InvocationContainerImpl(new ThreadSafeMockingProgress(), (MockCreationSettings) new MockSettingsImpl().stubOnly());\n+    Invocation invocation = new InvocationBuilder().toInvocation();\n+    LinkedList<Throwable> exceptions = new LinkedList<Throwable>();\n+\n+    @Test\n+    public void should_be_thread_safe() throws Throwable {\n+        doShouldBeThreadSafe(container);\n+    }\n+\n+    @Test\n+    public void should_be_thread_safe_stub_only() throws Throwable {\n+        doShouldBeThreadSafe(containerStubOnly);\n+    }\n+\n+    //works 50% of the time\n+    private void doShouldBeThreadSafe(final InvocationContainerImpl c) throws Throwable {\n+        //given\n+        Thread[] t = new Thread[200];\n+        final CountDownLatch starter = new CountDownLatch(200);\n+        for (int i = 0; i < t.length; i++ ) {\n+            t[i] = new Thread() {\n+                public void run() {\n+                    try {\n+                        starter.await(); //NOPMD\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    c.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+                    c.addAnswer(new Returns(\"foo\"));\n+                    c.findAnswerFor(invocation);\n+                }\n+            };\n+            t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+                public void uncaughtException(Thread t, Throwable e) {\n+                    exceptions.add(e);\n+                }\n+            });\n+            t[i].start();\n+\n+            starter.countDown();\n+        }\n+\n+        //when\n+        for (Thread aT : t) {\n+            aT.join();\n+        }\n+\n+        //then\n+        if (exceptions.size() != 0) {\n+            throw exceptions.getFirst();\n+        }\n+    }\n+\n+    @Test\n+    public void should_return_invoked_mock() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+\n+        assertEquals(invocation.getMock(), container.invokedMock());\n+    }\n+\n+    @Test\n+    public void should_return_invoked_mock_stub_only() throws Exception {\n+        containerStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+\n+        assertEquals(invocation.getMock(), containerStubOnly.invokedMock());\n+    }\n+\n+    @Test\n+    public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        assertTrue(container.hasInvocationForPotentialStubbing());\n+\n+        container.addAnswer(new ReturnsEmptyValues());\n+        assertFalse(container.hasInvocationForPotentialStubbing());\n+    }\n+\n+    @Test\n+    public void should_tell_if_has_invocation_for_potential_stubbing_stub_only() throws Exception {\n+        containerStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        assertTrue(containerStubOnly.hasInvocationForPotentialStubbing());\n+\n+        containerStubOnly.addAnswer(new ReturnsEmptyValues());\n+        assertFalse(containerStubOnly.hasInvocationForPotentialStubbing());\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n \n package org.mockito.internal.stubbing.defaultanswers;\n \n-import java.util.*;\n-\n import org.junit.Test;\n import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n \n import static org.mockito.Mockito.mock;\n \n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsMocksTest.java\n     }\n \n     @Test\n-    //TODO split into separate\n     public void should_return_mock_value_for_interface() throws Exception {\n         Object interfaceMock = values.returnValueFor(FooInterface.class);\n         assertTrue(new MockUtil().isMock(interfaceMock));\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n-import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n \n import static java.util.Arrays.asList;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockCreationValidatorTest extends TestBase {\n+public class MockCreationValidatorTest {\n \n     final class FinalClass {}\n     MockCreationValidator validator = new MockCreationValidator();\n-    \n+\n     @Test\n-    public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n+    public void should_not_allow_extra_interface_that_is_the_same_as_the_mocked_type() throws Exception {\n         try {\n             //when\n             validator.validateExtraInterfaces(IMethods.class, (Collection) asList(IMethods.class));\n             fail();\n         } catch (MockitoException e) {\n             //then\n-            assertContains(\"You mocked following type: IMethods\", e.getMessage());\n+            assertThat(e.getMessage()).contains(\"You mocked following type: IMethods\");\n         }\n     }\n-        \n+\n+    @Test(expected = MockitoException.class)\n+    public void should_not_allow_inconsistent_types() throws Exception {\n+        //when\n+        validator.validateMockedType(List.class, new ArrayList());\n+        //then\n+    }\n+\n     @Test\n-    public void shouldNotAllowsInconsistentTypes() throws Exception {\n-        try {\n-            //when\n-            validator.validateMockedType(List.class, new ArrayList());\n-            fail();\n-            //then\n-        } catch(MockitoException e) {}\n-    }\n-    \n-    @Test\n-    public void shouldAllowOnlyConsistentTypes() throws Exception {\n+    public void should_allow_only_consistent_types() throws Exception {\n         //when\n         validator.validateMockedType(ArrayList.class, new ArrayList());\n         //then no exception is thrown\n     }\n-    \n+\n     @Test\n-    public void shouldValidationBeSafeWhenNullsPassed() throws Exception {\n+    public void should_validation_be_safe_when_nulls_passed() throws Exception {\n         //when\n         validator.validateMockedType(null, new ArrayList());\n         //or\n         validator.validateMockedType(ArrayList.class, null);\n         //then no exception is thrown\n     }\n+\n+    @Test(expected = MockitoException.class)\n+    public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable() {\n+        boolean serializable = true;\n+        validator.validateSerializable(Observable.class, serializable);\n+    }\n+\n+    @Test\n+    public void should_allow_serializable_with_interfaces_or_Serializable_objects() {\n+        boolean serializable = true;\n+        validator.validateSerializable(Observer.class, serializable);\n+        validator.validateSerializable(Integer.class, serializable);\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/DefaultRegisteredInvocationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n+import org.mockitoutil.TestBase;\n+\n+public class DefaultRegisteredInvocationsTest extends TestBase {\n+    \n+    private DefaultRegisteredInvocations invocations;\n+    \n+    @Before\n+    public void setup() {\n+        invocations = new DefaultRegisteredInvocations();\n+    }\n+    \n+    @Test\n+    public void should_not_return_to_string_method() throws Exception {\n+        Invocation toString = new InvocationBuilder().method(\"toString\").toInvocation();\n+        Invocation simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+        \n+        invocations.add(toString);\n+        invocations.add(simpleMethod);\n+        \n+        assertTrue(invocations.getAll().contains(simpleMethod));\n+        assertFalse(invocations.getAll().contains(toString));\n+    }\n+}\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n \n package org.mockitousage.basicapi;\n \n-import static org.mockito.Mockito.*;\n-\n-import java.io.*;\n-import java.util.*;\n-\n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockito.InOrder;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.matchers.Any;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import static org.mockito.Mockito.*;\n+\n @SuppressWarnings({\"unchecked\", \"serial\"})\n public class MocksSerializationTest extends TestBase implements Serializable {\n \n     private static final long serialVersionUID = 6160482220413048624L;\n \n     @Test\n-    public void shouldAllowThrowsExceptionToBeSerializable() throws Exception {\n+    public void should_allow_throws_exception_to_be_serializable() throws Exception {\n         // given\n         Bar mock = mock(Bar.class, new ThrowsException(new RuntimeException()));\n         // when-serialize then-deserialize\n     }\n \n     @Test\n-    public void shouldAllowMethodDelegation() throws Exception {\n+    public void should_allow_method_delegation() throws Exception {\n         // given\n         Bar barMock = mock(Bar.class, withSettings().serializable());\n         Foo fooMock = mock(Foo.class);\n         //when-serialize then-deserialize\n         serializeAndBack(barMock);\n     }\n-    \n-    @Test\n-    public void shouldAllowMockToBeSerializable() throws Exception {\n+\n+    @Test\n+    public void should_allow_mock_to_be_serializable() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n \n     }\n \n     @Test\n-    public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {\n+    public void should_allow_mock_and_boolean_value_to_serializable() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         when(mock.booleanReturningMethod()).thenReturn(true);\n     }\n \n     @Test\n-    public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {\n+    public void should_allow_mock_and_string_value_to_be_serializable() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         String value = \"value\";\n     }\n \n     @Test\n-    public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {\n+    public void should_all_mock_and_serializable_value_to_be_serialized() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n     }\n \n     @Test\n-    public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {\n+    public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(value)).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {\n+    public void should_serialize_method_calls_using_any_string_matcher() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {\n+    public void should_verify_called_n_times_for_serialized_mock() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldVerifyEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n+    public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {\n         //given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n \n     }\n \n     @Test\n-    public void shouldSerializationWork() throws Exception {\n+    public void should_serialization_work() throws Exception {\n         //given\n         Foo foo = new Foo();\n         //when\n     }\n \n     @Test\n-    public void shouldStubEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n+    public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {\n         //given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n \n     }\n \n     @Test\n-    public void shouldVerifyCallOrderForSerializedMock() throws Exception {\n+    public void should_verify_call_order_for_serialized_mock() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         IMethods mock2 = mock(IMethods.class, withSettings().serializable());\n         mock.arrayReturningMethod();\n     }\n \n     @Test\n-    public void shouldRememberInteractionsForSerializedMock() throws Exception {\n+    public void should_remember_interactions_for_serialized_mock() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldSerializeWithStubbingCallback() throws Exception {\n-\n-        // given\n-        IMethods mock = mock(IMethods.class, withSettings().serializable());\n-        CustomAnswersMustImplementSerializableForSerializationToWork answer = \n-            new CustomAnswersMustImplementSerializableForSerializationToWork();\n+    public void should_serialize_with_stubbing_callback() throws Exception {\n+\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().serializable());\n+        CustomAnswersMustImplementSerializableForSerializationToWork answer =\n+                new CustomAnswersMustImplementSerializableForSerializationToWork();\n         answer.string = \"return value\";\n         when(mock.objectArgMethod(anyString())).thenAnswer(answer);\n \n         assertEquals(answer.string, readObject.objectArgMethod(\"\"));\n     }\n \n-    class CustomAnswersMustImplementSerializableForSerializationToWork \n-        implements Answer<Object>, Serializable {\n+    class CustomAnswersMustImplementSerializableForSerializationToWork\n+            implements Answer<Object>, Serializable {\n         private String string;\n         public Object answer(InvocationOnMock invocation) throws Throwable {\n             invocation.getArguments();\n             return string;\n         }\n     }\n-  \n-    @Test\n-    public void shouldSerializeWithRealObjectSpy() throws Exception {\n+\n+    @Test\n+    public void should_serialize_with_real_object_spy() throws Exception {\n         // given\n         List<Object> list = new ArrayList<Object>();\n         List<Object> spy = mock(ArrayList.class, withSettings()\n-                        .spiedInstance(list)\n-                        .defaultAnswer(CALLS_REAL_METHODS)\n-                        .serializable());\n+                .spiedInstance(list)\n+                .defaultAnswer(CALLS_REAL_METHODS)\n+                .serializable());\n         when(spy.size()).thenReturn(100);\n \n         // when\n     }\n \n     @Test\n-    public void shouldSerializeObjectMock() throws Exception {\n+    public void should_serialize_object_mock() throws Exception {\n         // given\n         Any mock = mock(Any.class);\n \n     }\n \n     @Test\n-    public void shouldSerializeRealPartialMock() throws Exception {\n+    public void should_serialize_real_partial_mock() throws Exception {\n         // given\n         Any mock = mock(Any.class, withSettings().serializable());\n         when(mock.matches(anyObject())).thenCallRealMethod();\n     class AlreadySerializable implements Serializable {}\n \n     @Test\n-    public void shouldSerializeAlreadySerializableClass() throws Exception {\n+    public void should_serialize_already_serializable_class() throws Exception {\n         // given\n         AlreadySerializable mock = mock(AlreadySerializable.class, withSettings().serializable());\n         when(mock.toString()).thenReturn(\"foo\");\n     }\n \n     @Test\n-    public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n+    public void should_be_serialize_and_have_extra_interfaces() throws Exception {\n         //when\n         IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n         IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n         serializeAndBack((List) mock);\n         serializeAndBack((List) mockTwo);\n     }\n+\n+    @Test\n+    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+        try {\n+            serializeMock(mock(Observable.class, withSettings().serializable()));\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(Observable.class.getSimpleName()).contains(\"serializable()\").contains(\"implement Serializable\");\n+        }\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/EqualsWithDeltaTest.java\n+package org.mockitousage.bugs;\n+\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+import org.mockito.internal.matchers.EqualsWithDelta;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class EqualsWithDeltaTest {\n+\n+\t@Test\n+\tpublic void testEqualsWithDelta_NullExpected() throws Exception {\n+\t\tMatcher<Number> matcher = equalsWithDelta(null);\n+\t\tassertThat(matcher.matches(1.0)).isFalse();\n+\t}\n+\n+\t@Test\n+\tpublic void testEqualsWithDelta_NullActual() throws Exception {\n+\t\tMatcher<Number> matcher = equalsWithDelta(1.0);\n+\t\tassertThat(matcher.matches(null)).isFalse();\n+\t}\n+\n+    @Test\n+    public void testEqualsWithDelta_NullActualAndExpected() throws Exception {\n+        Matcher<Number> matcher = equalsWithDelta(null);\n+        assertThat(matcher.matches(null)).isTrue();\n+    }\n+\n+\tpublic Matcher<Number> equalsWithDelta(final Double expected) {\n+\t\treturn new EqualsWithDelta(expected, .000001);\n+\t}\n+}\n--- a/test/org/mockitousage/bugs/Issue353InjectionMightNotHappenInCertainConfigurationTest.java\n+++ b/test/org/mockitousage/bugs/Issue353InjectionMightNotHappenInCertainConfigurationTest.java\n import org.mockito.Mock;\n import org.mockito.runners.MockitoJUnitRunner;\n \n+import java.util.HashMap;\n+import java.util.Map;\n+\n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.assertSame;\n-\n-import java.util.*;\n \n @RunWith(MockitoJUnitRunner.class)\n public class Issue353InjectionMightNotHappenInCertainConfigurationTest {\n--- a/test/org/mockitousage/bugs/MockitoRunnerBreaksWhenNoTestMethodsTest.java\n+++ b/test/org/mockitousage/bugs/MockitoRunnerBreaksWhenNoTestMethodsTest.java\n \n package org.mockitousage.bugs;\n \n-import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.internal.TextListener;\n+import org.junit.runner.JUnitCore;\n+import org.junit.runner.Result;\n import org.junit.runner.RunWith;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockitoutil.TestBase;\n \n-@RunWith(MockitoJUnitRunner.class)\n-@Ignore(\"for demo only. this test cannot be enabled as it fails :)\")\n+\n+// @Ignore(\"for demo only. this test cannot be enabled as it fails :)\")\n public class MockitoRunnerBreaksWhenNoTestMethodsTest extends TestBase {\n-    public void notATestMethod() {}\n+\n+    @Test\n+    public void ensure_the_test_runner_breaks() throws Exception {\n+        JUnitCore runner = new JUnitCore();\n+        runner.addListener(new TextListener(System.out));\n+\n+        Result result = runner.run(TestClassWithoutTestMethod.class);\n+\n+        assertEquals(1, result.getFailureCount());\n+        assertFalse(result.wasSuccessful());\n+    }\n+\n+    @RunWith(MockitoJUnitRunner.class)\n+    static class TestClassWithoutTestMethod { // package visibility is important\n+        public void notATestMethod() { }\n+    }\n+\n }\n--- a/test/org/mockitousage/internal/debugging/LocationImplTest.java\n+++ b/test/org/mockitousage/internal/debugging/LocationImplTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.internal.debugging;\n \n import org.junit.Test;\n import org.mockito.internal.debugging.LocationImpl;\n-import org.mockito.internal.exceptions.base.StackTraceFilter;\n+import org.mockito.internal.exceptions.stacktrace.StackTraceFilter;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"serial\")\n--- a/test/org/mockitousage/junitrunner/VerboseMockitoRunnerTest.java\n+++ b/test/org/mockitousage/junitrunner/VerboseMockitoRunnerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.junitrunner;\n \n-import static org.mockito.Mockito.*;\n import junit.framework.TestCase;\n-\n import org.junit.Ignore;\n import org.junit.Test;\n import org.junit.runner.JUnitCore;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import static org.mockito.Mockito.*;\n+\n //@RunWith(ConsoleSpammingMockitoJUnitRunner.class)\n @RunWith(VerboseMockitoJUnitRunner.class)\n-@Ignore\n //TODO\n public class VerboseMockitoRunnerTest extends TestBase {\n     \n     @Mock private IMethods mock;\n     \n-    protected static class NoWarnings {       \n+    public static class NoWarnings {\n         \n         @Test\n+        @Ignore\n         public void test() {\n             IMethods mock = mock(IMethods.class);\n             mock.simpleMethod(1);\n             throw new RuntimeException(\"boo\");\n         }\n     }\n-    \n-    protected static class ContainsWarnings extends TestCase {\n+\n+    public static class ContainsWarnings extends TestCase {\n         \n         public ContainsWarnings() {\n             super(\"test\");\n         }\n-        \n-        @Test\n-        public void test() {\n+\n+        public void testIgnored() {}\n+\n+        public void _test() {\n             IMethods mock = mock(IMethods.class);\n             \n             //some stubbing\n     }\n     \n     @Test\n+    @Ignore\n     public void shouldContainWarnings() throws Exception {\n         //when\n         Result result = new JUnitCore().run(new ContainsWarnings());\n     }\n \n     @Test\n+    @Ignore\n     public void shouldNotContainWarnings() throws Exception {\n         Result result = new JUnitCore().run(NoWarnings.class);\n         assertEquals(1, result.getFailures().size());\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockitousage.IMethods;\n     }\n     \n     @Test\n-    public void shouldEvaluateLatestStubbingFirst() throws Exception {\n+    public void should_evaluate_latest_stubbing_first() throws Exception {\n         when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n         when(mock.objectReturningMethod(200)).thenReturn(200);\n         \n     }\n     \n     @Test\n-    public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n+    public void should_stubbing_be_treated_as_interaction() throws Exception {\n         when(mock.booleanReturningMethod()).thenReturn(true);\n         \n         mock.booleanReturningMethod();\n     }\n     \n     @Test\n-    public void shouldAllowStubbingToString() throws Exception {\n+    public void should_allow_stubbing_to_string() throws Exception {\n         IMethods mockTwo = mock(IMethods.class);\n         when(mockTwo.toString()).thenReturn(\"test\");\n         \n     }\n     \n     @Test\n-    public void shouldStubbingNotBeTreatedAsInteraction() {\n+    public void should_stubbing_not_be_treated_as_interaction() {\n         when(mock.simpleMethod(\"one\")).thenThrow(new RuntimeException());\n         doThrow(new RuntimeException()).when(mock).simpleMethod(\"two\");\n         \n     }\n \n     @Test\n-    public void unfinishedStubbingCleansUpTheState() {\n+    public void unfinished_stubbing_cleans_up_the_state() {\n         reset(mock);\n         try {\n             when(\"\").thenReturn(\"\");\n     }\n     \n     @Test\n-    public void shouldToStringMockName() {\n+    public void should_to_string_mock_name() {\n         IMethods mock = mock(IMethods.class, \"mockie\");\n         IMethods mockTwo = mock(IMethods.class);\n         \n     }\n     \n     @Test\n-    public void shouldAllowMockingWhenToStringIsFinal() throws Exception {\n+    public void should_allow_mocking_when_to_string_is_final() throws Exception {\n         mock(Foo.class);\n     }\n+\n+    @Test\n+    public void test_stub_only_not_verifiable() throws Exception {\n+        IMethods localMock = mock(IMethods.class, withSettings().stubOnly());\n+\n+        when(localMock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n+        when(localMock.objectReturningMethod(200)).thenReturn(200);\n+\n+        assertEquals(200, localMock.objectReturningMethod(200));\n+        assertEquals(100, localMock.objectReturningMethod(666));\n+        assertEquals(\"default behavior should return null\", null, localMock.objectReturningMethod(\"blah\"));\n+\n+        try {\n+            verify(localMock, atLeastOnce()).objectReturningMethod(eq(200));\n+            fail();\n+        } catch (CannotVerifyStubOnlyMock e) {}\n+    }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n     }\n \n     @Test\n-    public void shouldPrintMethodName() {\n+    public void should_print_method_name() {\n         try {\n             verify(mock).simpleMethod();\n             fail();\n     }\n \n     @Test\n-    public void shouldPrintMethodNameAndArguments() {\n+    public void should_print_method_name_and_arguments() {\n         try {\n             verify(mock).threeArgumentMethod(12, new Foo(), \"xx\");\n             fail();\n     }\n \n     @Test\n-    public void shouldPrintActualAndWantedInLine() {\n+    public void should_print_actual_and_wanted_in_line() {\n         mock.varargs(1, 2);\n \n         try {\n     }\n     \n     @Test\n-    public void shouldPrintActualAndWantedInMultipleLines() {\n+    public void should_print_actual_and_wanted_in_multiple_lines() {\n         mock.varargs(\"this is very long string\", \"this is another very long string\");\n \n         try {\n     }\n \n     @Test\n-    public void shouldPrintActualAndWantedWhenActualMethodNameAndWantedMethodNameAreTheSame() {\n+    public void should_print_actual_and_wanted_when_actual_method_name_and_wanted_method_name_are_the_same() {\n         mock.simpleMethod();\n \n         try {\n     }\n \n     @Test\n-    public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments() {\n+    public void should_print_actual_and_unverified_wanted_when_the_difference_is_about_arguments() {\n         mock.twoArgumentMethod(1, 1);\n         mock.twoArgumentMethod(2, 2);\n \n     }\n \n     @Test\n-    public void shouldPrintFirstUnexpectedInvocation() {\n+    public void should_print_first_unexpected_invocation() {\n         mock.oneArg(true);\n         mock.oneArg(false);\n         mock.threeArgumentMethod(1, \"2\", \"3\");\n     }\n \n     @Test\n-    public void shouldPrintFirstUnexpectedInvocationWhenVerifyingZeroInteractions() {\n+    public void should_print_first_unexpected_invocation_when_verifying_zero_interactions() {\n         mock.twoArgumentMethod(1, 2);\n         mock.threeArgumentMethod(1, \"2\", \"3\");\n \n     }\n \n     @Test\n-    public void shouldPrintMethodNameWhenVerifyingAtLeastOnce() throws Exception {\n+    public void should_print_method_name_when_verifying_at_least_once() throws Exception {\n         try {\n             verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);\n             fail();\n     }\n \n     @Test\n-    public void shouldPrintMethodWhenMatcherUsed() throws Exception {\n+    public void should_print_method_when_matcher_used() throws Exception {\n         try {\n             verify(mock, atLeastOnce()).twoArgumentMethod(anyInt(), eq(100));\n             fail();\n     }\n \n     @Test\n-    public void shouldPrintMethodWhenMissingInvocationWithArrayMatcher() {\n+    public void should_print_method_when_missing_invocation_with_array_matcher() {\n         mock.oneArray(new boolean[] { true, false, false });\n \n         try {\n     }\n \n     @Test\n-    public void shouldPrintMethodWhenMissingInvocationWithVarargMatcher() {\n+    public void should_print_method_when_missing_invocation_with_vararg_matcher() {\n         mock.varargsString(10, \"xxx\", \"yyy\", \"zzz\");\n \n         try {\n     }\n \n     @Test\n-    public void shouldPrintMethodWhenMissingInvocationWithMatcher() {\n+    public void should_print_method_when_missing_invocation_with_matcher() {\n         mock.simpleMethod(\"foo\");\n \n         try {\n     }\n \n     @Test\n-    public void shouldPrintNullArguments() throws Exception {\n+    public void should_print_null_arguments() throws Exception {\n         mock.simpleMethod(null, (Integer) null);\n         try {\n             verify(mock).simpleMethod(\"test\");\n     }\n     \n     @Test\n-    public void shouldSayNeverWantedButInvoked() throws Exception {\n+    public void should_say_never_wanted_but_invoked() throws Exception {\n         mock.simpleMethod(1);\n     \n         verify(mock, never()).simpleMethod(2);\n     }\n     \n     @Test\n-    public void shouldShowRightActualMethod() throws Exception {\n+    public void should_show_right_actual_method() throws Exception {\n         mock.simpleMethod(9191);\n         mock.simpleMethod(\"foo\");\n     \n     @Mock private IMethods iHavefunkyName;\n     \n     @Test\n-    public void shouldPrintFieldNameWhenAnnotationsUsed() throws Exception {\n+    public void should_print_field_name_when_annotations_used() throws Exception {\n         iHavefunkyName.simpleMethod(10);\n     \n         try {\n     }\n     \n     @Test\n-    public void shouldPrintInteractionsOnMockWhenOrdinaryVerificationFail() throws Exception {\n+    public void should_print_interactions_on_mock_when_ordinary_verification_fail() throws Exception {\n         mock.otherMethod();\n         mock.booleanReturningMethod();\n         \n     @Mock private IMethods veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock; \n     \n     @Test\n-    public void shouldNeverBreakMethodStringWhenNoArgsInMethod() throws Exception {\n+    public void should_never_break_method_string_when_no_args_in_method() throws Exception {\n         try {\n             verify(veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock).simpleMethod();\n             fail();\n             assertContains(\"veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock.simpleMethod()\", e.getMessage());\n         }\n     }\n+\n+    @Test\n+    public void should_print_method_name_and_arguments_of_other_interactions() throws Exception {\n+        try {\n+            mock.arrayMethod(new String[] {\"a\", \"b\", \"c\"});\n+            mock.forByte((byte) 25);\n+\n+            verify(mock).threeArgumentMethod(12, new Foo(), \"xx\");\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            System.out.println(e);\n+            assertContains(\"iMethods.threeArgumentMethod(12, foo, \\\"xx\\\")\", e.getMessage());\n+            assertContains(\"iMethods.arrayMethod([\\\"a\\\", \\\"b\\\", \\\"c\\\"])\", e.getMessage());\n+            assertContains(\"iMethods.forByte(25)\", e.getMessage());\n+        }\n+    }\n }\n--- a/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n+++ b/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n  */\n \n package org.mockitousage.verification;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n \n import org.junit.After;\n import org.junit.Ignore;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.*;\n \n @SuppressWarnings(\"unchecked\")\n public class VerificationWithTimeoutTest extends TestBase {\n     @Test\n     public void shouldFailVerificationWithTimeout() throws Exception {\n         //given\n-        Thread t = waitAndExerciseMock(40);\n+        Thread t = waitAndExerciseMock(80);\n         \n         //when\n         t.start();\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n             }\n         });\n     }\n+\n+    protected String getStackTrace(Throwable e) {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        e.printStackTrace(new PrintStream(out));\n+        try {\n+            out.close();\n+        } catch (IOException ex) {}\n+        return out.toString();\n+    }\n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         ));\n     }\n \n+    public void defaultAnswerDoesNotAcceptNullParameter() {\n+        throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n+    }\n+\n     public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n         throw new MockitoException(join(\n                 \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockNameImpl;\n import org.mockito.internal.util.MockitoSpy;\n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n \n     public MockSettings defaultAnswer(Answer defaultAnswer) {\n         this.defaultAnswer = defaultAnswer;\n+        if (defaultAnswer == null) {\n+            new Reporter().defaultAnswerDoesNotAcceptNullParameter();\n+        }\n         return this;\n     }\n \n         }\n         return interfaces;\n     }\n+\n+    public MockSettings parameterizedInfo(GenericMetadataSupport mockitoGenericMetadata) {\n+        this.mockitoGenericMetadata = mockitoGenericMetadata;\n+        return this;\n+    }\n }\n \n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n  */\n package org.mockito.internal.creation.settings;\n \n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n  * by Szczepan Faber, created at: 4/9/12\n  */\n public class CreationSettings<T> implements MockCreationSettings<T>, Serializable {\n+    private static final long serialVersionUID = -6789800638070123629L;\n \n     protected Class<T> typeToMock;\n     protected Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n     protected Answer<Object> defaultAnswer;\n     protected MockName mockName;\n     protected boolean serializable;\n+    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n+    protected GenericMetadataSupport mockitoGenericMetadata;\n     protected boolean stubOnly;\n-    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public CreationSettings() {}\n \n+    @SuppressWarnings(\"unchecked\")\n     public CreationSettings(CreationSettings copy) {\n         this.typeToMock = copy.typeToMock;\n         this.extraInterfaces = copy.extraInterfaces;\n         this.mockName = copy.mockName;\n         this.serializable = copy.serializable;\n         this.invocationListeners = copy.invocationListeners;\n+        this.mockitoGenericMetadata = copy.mockitoGenericMetadata;\n         this.stubOnly = copy.stubOnly;\n     }\n \n         return serializable;\n     }\n \n+    public List<InvocationListener> getInvocationListeners() {\n+        return invocationListeners;\n+    }\n+\n+    public GenericMetadataSupport getMockitoGenericMetadata() {\n+        if (mockitoGenericMetadata == null) {\n+            this.mockitoGenericMetadata = GenericMetadataSupport.from(typeToMock);\n+        }\n+        return mockitoGenericMetadata;\n+    }\n+\n+    public void setMockitoGenericMetadata(GenericMetadataSupport mockitoGenericMetadata) {\n+        this.mockitoGenericMetadata = mockitoGenericMetadata;\n+    }\n+\n     public boolean isStubOnly() {\n         return stubOnly;\n     }\n \n-    public List<InvocationListener> getInvocationListeners() {\n-        return invocationListeners;\n-    }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n import org.mockito.Mockito;\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubs.java\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.Incubating;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.util.MockCreationValidator;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Returning generic deep stub implementation.\n+ *\n+ * Will return previously created mock if the invocation matches.\n+ *\n+ *\n+ * <p>Supports nested generic information, with this answer you can write code like this :\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n+ *\n+ *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+ *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+ * </code></pre>\n+ * </p>\n+ *\n+ * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n+ * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n+ */\n+@Incubating\n+public class ReturnsGenericDeepStubs extends ReturnsDeepStubs implements Answer<Object>, Serializable {\n+\n+    private static final long serialVersionUID = -7105341425736035847L;\n+\n+    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        GenericMetadataSupport returnTypeGenericMetadata =\n+                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n+\n+        Class<?> rawType = returnTypeGenericMetadata.rawType();\n+        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n+            return delegate.returnValueFor(rawType);\n+        }\n+\n+        return getMock(invocation, returnTypeGenericMetadata);\n+    }\n+\n+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n+    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n+\n+        // matches invocation for verification\n+        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n+    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n+    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n+    \t\t}\n+\t\t}\n+\n+        // deep stub\n+        return recordDeepStubMock(returnTypeGenericMetadata.toMock(this), container);\n+    }\n+\n+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n+\n+        container.addAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return mock;\n+            }\n+        }, false);\n+\n+        return mock;\n+    }\n+\n+    private GenericMetadataSupport actualParameterizedType(Object mock) {\n+        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n+        return mockSettings.getMockitoGenericMetadata();\n+    }\n+}\n--- a/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n+++ b/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n public class ConsoleMockitoLogger implements MockitoLogger {\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n     public void log(Object what) {\n-        System.out.print(what);\n+        System.out.println(what);\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.Field;\n         \n         return Object.class;\n     }\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+\n+import org.mockito.Incubating;\n+import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.stubbing.Answer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.withSettings;\n+\n+\n+/**\n+ * This class can retrieve generic meta-data that the compiler stores on classes\n+ * and accessible members.\n+ *\n+ * <p>\n+ *     The main idea of this code is to create a Map that will help to resolve return types.\n+ *     In order to actually work with nested generics, this map will have to be passed along new instances\n+ *     as a type context.\n+ * </p>\n+ *\n+ * <p>\n+ *     Hence :\n+ *     <ul>\n+ *         <li>the metadata is created using the {@link #from(Type)} method from a real\n+ *         Class or from a ParameterizedType, other types are not yet supported.</li>\n+ *\n+ *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n+ *         {@link #resolveGenericReturnType(Method)}.</li>\n+ *\n+ *         <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n+ *         we need to create the mock ourselves as we know how to create it, depending on the kind of Type (Class,\n+ *         ParameterizedType, TypeVariable), the method {@link #toMock(Answer)} assumes this responsibility.</li>\n+ *     </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * For now this code support the following kind of generic declarations :\n+ * <pre class=\"code\"><code class=\"java\">\n+ * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n+ *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n+ *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n+ *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n+ *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n+ *     K returningK();\n+ *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n+ *     &lt;S, T extends S&gt; T two_type_params();\n+ *     &lt;O extends K&gt; O typeVar_with_type_params();\n+ *     Number returningNonGeneric();\n+ * }\n+ * </code></pre>\n+ *\n+ * @see #from(Type)\n+ * @see #resolveGenericReturnType(Method)\n+ * @see #toMock(Answer)\n+ * @see org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubs\n+ */\n+@Incubating\n+public abstract class GenericMetadataSupport {\n+\n+    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n+\n+    /**\n+     * Represents actual type variables resolved for current class.\n+     */\n+    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n+\n+\n+    protected void registerTypeVariablesOn(Type classType) {\n+        if (!(classType instanceof ParameterizedType)) {\n+            return;\n+        }\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            TypeVariable typeParameter = typeParameters[i];\n+            Type actualTypeArgument = actualTypeArguments[i];\n+\n+            if (actualTypeArgument instanceof WildcardType) {\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n+            } else {\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n+            }\n+            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n+        }\n+    }\n+\n+    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n+        for (TypeVariable typeParameter : typeParameters) {\n+            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n+            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    /**\n+     * @param typeParameter The TypeVariable parameter\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(TypeVariable typeParameter) {\n+        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n+        }\n+        return new TypeVarBoundedType(typeParameter);\n+    }\n+\n+    /**\n+     * @param wildCard The WildCard type\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(WildcardType wildCard) {\n+        /*\n+         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n+         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n+         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n+         */\n+\n+        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n+        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n+        }\n+\n+        return wildCardBoundedType;\n+    }\n+\n+\n+\n+    /**\n+     * @return Raw type of the current instance.\n+     */\n+    public abstract Class<?> rawType();\n+\n+\n+\n+    /**\n+     * @return Returns extra interfaces if relevant, otherwise empty List.\n+     */\n+    public List<Type> extraInterfaces() {\n+        return Collections.emptyList();\n+    }\n+\n+\n+\n+    /**\n+     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n+     */\n+    public Map<TypeVariable, Type> actualTypeArguments() {\n+        TypeVariable[] typeParameters = rawType().getTypeParameters();\n+        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n+\n+        for (TypeVariable typeParameter : typeParameters) {\n+\n+            Type actualType = getActualTypeArgumentFor(typeParameter);\n+\n+            actualTypeArguments.put(typeParameter, actualType);\n+            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n+        }\n+\n+        return actualTypeArguments;\n+    }\n+\n+    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n+        Type type = this.contextualActualTypeParameters.get(typeParameter);\n+        if (type instanceof TypeVariable) {\n+            TypeVariable typeVariable = (TypeVariable) type;\n+            return getActualTypeArgumentFor(typeVariable);\n+        }\n+\n+        return type;\n+    }\n+\n+\n+\n+    /**\n+     * Creates a mock using the Generics Metadata represented by this instance.\n+     *\n+     * @param answer The answer to use in mock settings.\n+     * @return The mock or null if not mockable.\n+     */\n+    public Object toMock(Answer answer) {\n+        return createMock(rawType(), ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this));\n+    }\n+\n+    private Object createMock(Class<?> rawType, MockSettings mockSettings) {\n+        return Mockito.mock(rawType, mockSettings);\n+    }\n+\n+\n+    /**\n+     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n+     *\n+     * @param method Method to resolve the return type.\n+     * @return {@link GenericMetadataSupport} representing this generic return type.\n+     */\n+    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n+        Type genericReturnType = method.getGenericReturnType();\n+        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n+\n+        if (genericReturnType instanceof Class) {\n+            return new NotGenericReturnTypeSupport(genericReturnType);\n+        }\n+        if (genericReturnType instanceof ParameterizedType) {\n+            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n+        }\n+        if (genericReturnType instanceof TypeVariable) {\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n+        }\n+\n+        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n+    }\n+\n+    /**\n+     * Create an new GenericMetadataSupport from a {@link Type}.\n+     *\n+     * <p>\n+     *     Supports only {@link Class} and {@link ParameterizedType}, otherwise throw a {@link MockitoException}.\n+     * </p>\n+     *\n+     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n+     * @return The new {@link GenericMetadataSupport}.\n+     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n+     */\n+    public static GenericMetadataSupport from(Type type) {\n+        Checks.checkNotNull(type, \"type\");\n+        if (type instanceof Class) {\n+            return new FromClassGenericMetadataSupport((Class<?>) type);\n+        }\n+        if (type instanceof ParameterizedType) {\n+            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n+        }\n+\n+        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n+    }\n+\n+\n+    /**\n+     * Metadata for source {@link Class}\n+     */\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n+        private Class<?> clazz;\n+\n+        public FromClassGenericMetadataSupport(Class<?> clazz) {\n+            this.clazz = clazz;\n+            readActualTypeParametersOnDeclaringClass();\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass() {\n+            registerTypeParametersOn(clazz.getTypeParameters());\n+            registerTypeVariablesOn(clazz.getGenericSuperclass());\n+            for (Type genericInterface : clazz.getGenericInterfaces()) {\n+                registerTypeVariablesOn(genericInterface);\n+            }\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return clazz;\n+        }\n+    }\n+\n+\n+    /**\n+     * Metadata for source {@link ParameterizedType}.\n+     * Don't work with ParameterizedType returned in {@link Method#getGenericReturnType()}.\n+     */\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n+        private ParameterizedType parameterizedType;\n+\n+        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            readActualTypeParameters();\n+        }\n+\n+        private void readActualTypeParameters() {\n+            registerTypeVariablesOn(parameterizedType.getRawType());\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+    }\n+\n+\n+    /**\n+     * Metadata specific to {@link ParameterizedType} generic return types.\n+     */\n+    private static class ParameterizedReturnType extends GenericMetadataSupport {\n+        private final ParameterizedType parameterizedType;\n+        private final TypeVariable[] typeParameters;\n+\n+        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            this.typeParameters = typeParameters;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Metadata specific to {@link TypeVariable} generic return type.\n+     */\n+    private static class TypeVariableReturnType extends GenericMetadataSupport {\n+        private final TypeVariable typeVariable;\n+        private final TypeVariable[] typeParameters;\n+        private Class<?> rawType;\n+\n+\n+\n+        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n+            this.typeParameters = typeParameters;\n+            this.typeVariable = typeVariable;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            for (Type type : typeVariable.getBounds()) {\n+                registerTypeVariablesOn(type);\n+            }\n+            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            if (rawType == null) {\n+                rawType = extractRawTypeOf(typeVariable);\n+            }\n+            return rawType;\n+        }\n+\n+        private Class<?> extractRawTypeOf(Type type) {\n+            if (type instanceof Class) {\n+                return (Class<?>) type;\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) type).getRawType();\n+            }\n+            if (type instanceof BoundedType) {\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\n+            }\n+            if (type instanceof TypeVariable) {\n+                /*\n+                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                 * on the class definition, such as such as List<E>.\n+                 */\n+                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n+        }\n+\n+        @Override\n+        public List<Type> extraInterfaces() {\n+            Type type = extractActualBoundedTypeOf(typeVariable);\n+            if (type instanceof BoundedType) {\n+                return Arrays.asList(((BoundedType) type).interfaceBounds());\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return Collections.singletonList(type);\n+            }\n+            if (type instanceof Class) {\n+                return Collections.emptyList();\n+            }\n+            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n+        }\n+\n+        private Class<?>[] rawExtraInterfaces() {\n+            List<Type> extraInterfaces = extraInterfaces();\n+            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n+            for (Type extraInterface : extraInterfaces) {\n+                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n+                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n+                if(!rawType().equals(rawInterface)) {\n+                    rawExtraInterfaces.add(rawInterface);\n+                }\n+            }\n+            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n+        }\n+\n+        private Type extractActualBoundedTypeOf(Type type) {\n+            if (type instanceof TypeVariable) {\n+                /*\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                on the class definition, such as such as List<E>.\n+                */\n+                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            if (type instanceof BoundedType) {\n+                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n+                if (!(actualFirstBound instanceof BoundedType)) {\n+                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n+                }\n+                return actualFirstBound;\n+            }\n+            return type; // irrelevant, we don't manage other types.\n+        }\n+\n+        public Object toMock(Answer answer) {\n+            Class<?>[] rawExtraInterfaces = rawExtraInterfaces();\n+            if (rawExtraInterfaces.length <= 0) {\n+                return super.toMock(answer);\n+            }\n+\n+            return super.createMock(\n+                    rawType(),\n+                    ((MockSettingsImpl) withSettings()\n+                            .defaultAnswer(answer)\n+                            .extraInterfaces(rawExtraInterfaces))\n+                            .parameterizedInfo(this)\n+            );\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Metadata specific to {@link Class} return type.\n+     */\n+    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n+        private final Class<?> returnType;\n+\n+        public NotGenericReturnTypeSupport(Type genericReturnType) {\n+            returnType = (Class<?>) genericReturnType;\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return returnType;\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Type representing bounds of a type\n+     *\n+     * @see TypeVarBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     * @see WildCardBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n+     */\n+    public static interface BoundedType extends Type {\n+        Type firstBound();\n+\n+        Type[] interfaceBounds();\n+    }\n+\n+    /**\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\n+     *\n+     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n+     * one element (Object is always here if no bounds are declared).</p>\n+     *\n+     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n+     * interfacesBound will be an array of the additional interfaces.\n+     *\n+     * i.e. <code>SomeClass</code>.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n+     *         E get();\n+     *     }\n+     *     // will return Comparable type\n+     * </code></pre>\n+     * </p>\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class TypeVarBoundedType implements BoundedType {\n+        private TypeVariable typeVariable;\n+\n+\n+        public TypeVarBoundedType(TypeVariable typeVariable) {\n+            this.typeVariable = typeVariable;\n+        }\n+\n+        /**\n+         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n+         */\n+        public Type firstBound() {\n+            return typeVariable.getBounds()[0]; //\n+        }\n+\n+        /**\n+         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n+         * containing I_1 and I_2.\n+         *\n+         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n+         * empty array if no other bound declared.\n+         */\n+        public Type[] interfaceBounds() {\n+            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n+            return interfaceBounds;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return typeVariable.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+\n+        public TypeVariable typeVariable() {\n+            return typeVariable;\n+        }\n+    }\n+\n+    /**\n+     * Type representing bounds of a wildcard, allows to keep all bounds information.\n+     *\n+     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n+     * are not allowed.\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class WildCardBoundedType implements BoundedType {\n+        private WildcardType wildcard;\n+\n+\n+        public WildCardBoundedType(WildcardType wildcard) {\n+            this.wildcard = wildcard;\n+        }\n+\n+        /**\n+         * @return The first bound, either a type or a reference to a TypeVariable\n+         */\n+        public Type firstBound() {\n+            Type[] lowerBounds = wildcard.getLowerBounds();\n+            Type[] upperBounds = wildcard.getUpperBounds();\n+\n+            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n+        }\n+\n+        /**\n+         * @return An empty array as, wildcard don't support multiple bounds.\n+         */\n+        public Type[] interfaceBounds() {\n+            return new Type[0];\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return wildcard.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=[]}\");\n+            return sb.toString();\n+        }\n+\n+        public WildcardType wildCard() {\n+            return wildcard;\n+        }\n+    }\n+\n+}\n+\n+\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.junit.Test;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unused\")\n+public class ReturnsGenericDeepStubsTest {\n+    interface ListOfInteger extends List<Integer> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Number> returningWildcard();\n+        Map<String, K> returningNonMockableNestedGeneric();\n+        K returningK();\n+        <O extends K> List<O> paramTypeWithTypeParams();\n+        <S extends Appendable, T extends S> T twoTypeParams(S s);\n+        <O extends K> O typeVarWithTypeParams();\n+        Number returnsNormalType();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_1() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n+        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n+        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n+\n+        Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n+        Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n+\n+        Set<Number> value = mock.entrySet().iterator().next().getValue();\n+        Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n+        Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_2() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        Cloneable cloneable1 = mock.paramTypeWithTypeParams().get(0);\n+        Comparable<?> comparable1 = mock.paramTypeWithTypeParams().get(0);\n+        Cloneable cloneable2 = mock.returningK();\n+        Comparable<?> comparable2 = mock.returningK();\n+        Cloneable cloneable3 = (Cloneable) mock.typeVarWithTypeParams();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_3() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        List<? super Integer> objects = mock.returningWildcard();\n+        Number n = (Number) mock.returningWildcard().get(45);\n+        n.floatValue();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_4() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        Number n = mock.returnsNormalType();\n+        n.floatValue();\n+    }\n+\n+    @Test\n+    public void return_default_value_on_non_mockable_nested_generic() throws Exception {\n+        GenericsNest<?> genericsNest = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+        ListOfInteger listOfInteger = mock(ListOfInteger.class, new ReturnsGenericDeepStubs());\n+\n+        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();\n+        assertThat(listOfInteger.get(25)).isEqualTo(0);\n+    }\n+\n+    @Test(expected = ClassCastException.class)\n+    public void returning_deep_stub_dont_work_because_StringBuilder_is_subject_to_erasure() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        StringBuilder stringBuilder = mock.twoTypeParams(new StringBuilder()).append(2).append(3); // ClassCastException\n+    }\n+}\n--- a/test/org/mockito/internal/util/reflection/GenericMasterTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMasterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n-import static org.junit.Assert.*;\n+import org.junit.Test;\n \n import java.lang.reflect.Field;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.lang.reflect.Type;\n+import java.util.*;\n \n-import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n \n public class GenericMasterTest {\n     \n     String nonGeneric;\n     List<Set<String>> nested;\n     List<Set<Collection<String>>> multiNested;\n-    \n+\n+    public interface ListSet extends List<Set> {}\n+    public interface MapNumberString extends Map<Number, String> {}\n+    public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}\n+\n+    public List<Number> numberList() { return null; }\n+    public Comparable<Number> numberComparable() { return null; }\n+    public List rawList() { return null; }\n+    public List<? extends Type> typeList() { return null; }\n+\n+\n+\n     @Test\n-    public void shouldFindGenericClass() throws Exception {\n+    public void should_find_generic_class() throws Exception {\n         assertEquals(String.class, m.getGenericType(field(\"one\")));\n         assertEquals(Integer.class, m.getGenericType(field(\"two\")));\n         assertEquals(Double.class, m.getGenericType(field(\"map\")));\n     }\n     \n     @Test\n-    public void shouldGetObjectForNonGeneric() throws Exception {\n+    public void should_get_object_for_non_generic() throws Exception {\n         assertEquals(Object.class, m.getGenericType(field(\"nonGeneric\")));\n     }\n     \n     @Test\n-    public void shouldDealWithNestedGenerics() throws Exception {\n+    public void should_deal_with_nested_generics() throws Exception {\n         assertEquals(Set.class, m.getGenericType(field(\"nested\")));\n         assertEquals(Set.class, m.getGenericType(field(\"multiNested\")));\n     }\n     private Field field(String fieldName) throws SecurityException, NoSuchFieldException {\n         return this.getClass().getDeclaredField(fieldName);\n     }\n+\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.RETURNS_DEFAULTS;\n+import static org.mockito.internal.util.reflection.GenericMetadataSupport.from;\n+\n+@SuppressWarnings(\"unused\")\n+public class GenericMetadataSupportTest {\n+\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Integer> returning_wildcard_with_class_lower_bound();\n+        List<? super K> returning_wildcard_with_typeVar_lower_bound();\n+        List<? extends K> returning_wildcard_with_typeVar_upper_bound();\n+        K returningK();\n+        <O extends K> List<O> paramType_with_type_params();\n+        <S, T extends S> T two_type_params();\n+        <O extends K> O typeVar_with_type_params();\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_from_Class() throws Exception {\n+        assertThat(from(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n+        assertThat(from(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n+        assertThat(from(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+    }\n+\n+\n+    @Test\n+    public void can_get_raw_type_from_ParameterizedType() throws Exception {\n+        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(from(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_Class() throws Exception {\n+        assertThat(from(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"K\");\n+        assertThat(from(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(from(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n+        assertThat(from(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(from(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_ParameterizedType() throws Exception {\n+        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n+        assertThat(from(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n+        assertThat(from(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n+    }\n+\n+    @Test\n+    public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);\n+        GenericMetadataSupport fromTypeVariableE = from(typeVariableValue(genericMetadata.actualTypeArguments(), \"E\"));\n+        assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);\n+        assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramType_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n+        assertThat(from(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n+    }\n+\n+    @Test\n+    public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVar_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n+    }\n+\n+    @Test\n+    public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n+        assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n+    }\n+\n+\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+        assertThat(boundedType.firstBound()).isEqualTo(Integer.class);\n+        assertThat(boundedType.interfaceBounds()).isEmpty();\n+    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_upper_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);\n+    }\n+\n+\n+\n+\n+    @Test(expected = MockitoException.class)\n+    public void toMock_propagate_MockitoException_if_type_unmockable() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);\n+    }\n+\n+    @Test\n+    public void toMock_returns_mock_of_correct_type() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Comparable.class);\n+        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Cloneable.class);\n+    }\n+\n+\n+    private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {\n+        for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {\n+            if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {\n+                return typeVariableTypeEntry.getValue();\n+            }\n+        }\n+\n+        fail(\"'\" + typeVariableName + \"' was not found in \" + typeVariables);\n+        return null; // unreachable\n+    }\n+\n+    private Method firstNamedMethod(String methodName, Class<?> clazz) {\n+        for (Method method : clazz.getMethods()) {\n+            if (method.getName().contains(methodName)) {\n+                return method;\n+            }\n+        }\n+        throw new IllegalStateException(\"The method : '\" + methodName + \"' do not exist in '\" + clazz.getSimpleName() + \"'\");\n+    }\n+\n+\n+}", "timestamp": 1348757257, "metainfo": ""}