{"sha": "b10d431ad21e1402f9dc8d56af84aa9768b6a182", "log": "Mock return values implementation  --HG-- rename : src/org/mockito/InOrderImpl.java => src/org/mockito/internal/InOrderImpl.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401324", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  */\n package org.mockito;\n \n-import java.util.Arrays;\n \n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.internal.MockHandler;\n+import org.mockito.internal.MockitoCore;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n-import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n-import org.mockito.internal.progress.OngoingStubbing;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.returnvalues.EmptyReturnValues;\n import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n+import org.mockito.internal.returnvalues.MockReturnValues;\n import org.mockito.internal.returnvalues.MoreEmptyReturnValues;\n import org.mockito.internal.returnvalues.SmartNullReturnValues;\n import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.Returns;\n import org.mockito.internal.stubbing.Stubber;\n-import org.mockito.internal.stubbing.StubberImpl;\n import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n-import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.api.VerificationMode;\n import org.mockito.runners.MockitoJUnit44Runner;\n      */\n     public static final ReturnValues RETURNS_SMART_NULLS = new SmartNullReturnValues();\n     \n-    static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n-    private static final Reporter REPORTER = new Reporter();\n-\n+    /**\n+     * Optional ReturnValues to be used with {@link Mockito#mock(Class, ReturnValues)}\n+     * <p>\n+     * {@link ReturnValues} defines the return values of unstubbed invocations.\n+     * <p>\n+     * This implementation can be helpful when working with legacy code. \n+     * <p>\n+     * MockReturnValues first tries to return ordinary return values (see {@link MoreEmptyReturnValues})\n+     * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\n+     * <p>\n+     */\n+    public static final ReturnValues RETURNS_MOCKS = new MockReturnValues();\n+    \n     /**\n      * Creates mock object of given class or interface.\n      * <p>\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n-        return mock(classToMock, null, null, RETURNS_DEFAULTS);\n+        return MockitoCore.mock(classToMock, null, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, String name) {\n-        return mock(classToMock, name, null, RETURNS_DEFAULTS);\n+        return MockitoCore.mock(classToMock, name, null, RETURNS_DEFAULTS);\n     }\n     \n     /**\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n-        return mock(classToMock, null, (T) null, returnValues);\n-    }\n-    \n-    private static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n-        MOCKING_PROGRESS.validateState();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n-        return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n-    }    \n-\n+        return MockitoCore.mock(classToMock, null, (T) null, returnValues);\n+    }\n+    \n     /**\n      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n      * <p>\n      * @return a spy of the real object\n      */\n     public static <T> T spy(T object) {\n-        return mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n+        return MockitoCore.mock((Class<T>) object.getClass(), null, object, RETURNS_DEFAULTS);\n     }\n \n     /**\n-     * <pre>\n-     *   //Instead of:\n-     *   stub(mock.count()).toReturn(10);\n-     * \n-     *   //Please do:\n-     *   when(mock.count()).thenReturn(10);\n-     * </pre> \n-     * \n-     * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n-     * <p>\n-     * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n-     * <pre>\n-     *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n-     *   stub(          <i>replace with:</i>  when(\n-     *   .toReturn(     <i>replace with:</i>  .thenReturn(\n-     *   .toThrow(      <i>replace with:</i>  .thenThrow(\n-     *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n-     * </pre>\n-     * If you're an existing user then sorry for making your code littered with deprecation warnings. \n-     * This change was required to make Mockito better.\n-     * \n-     * @param methodCall\n-     *            method call\n-     * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    @Deprecated\n-    public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return (DeprecatedOngoingStubbing) stub();\n-    }\n-    \n-    /**\n-     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n-     * <p>\n-     * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n-     * <p>\n-     * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n-     * <p>\n-     * Examples:\n-     * \n-     * <pre>\n-     * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n-     *\n-     * //you can use flexible argument matchers, e.g:\n-     * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n-     *\n-     * //setting exception to be thrown:\n-     * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n-     *\n-     * //you can set different behavior for consecutive method calls.\n-     * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenThrow(new RuntimeException())\n-     *  .thenReturn(\"foo\");\n-     *  \n-     * //Alternative, shorter version for consecutive stubbing:\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenReturn(\"one\", \"two\");\n-     * //is the same as:\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenReturn(\"one\")\n-     *  .thenReturn(\"two\");\n-     *\n-     * //shorter version for consecutive method calls throwing exceptions:\n-     * when(mock.someMethod(\"some arg\"))\n-     *  .thenThrow(new RuntimeException(), new NullPointerException();\n-     *   \n-     * </pre>\n-     * \n-     * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n-     * <p>\n-     * Stubbing can be overridden: for example common stubbing can go to fixture\n-     * setup but the test methods can override it.\n-     * <p>\n-     * Once stubbed, the method will always return stubbed value regardless\n-     * of how many times it is called.\n-     * <p>\n-     * Last stubbing is more important - when you stubbed the same method with\n-     * the same arguments many times.\n+\t * <pre>\n+\t *   //Instead of:\n+\t *   stub(mock.count()).toReturn(10);\n+\t * \n+\t *   //Please do:\n+\t *   when(mock.count()).thenReturn(10);\n+\t * </pre> \n+\t * \n+\t * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} \n+\t * <p>\n+\t * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:\n+\t * <pre>\n+\t *   Mockito.stub;  <i>replace with:</i>  Mockito.when;\n+\t *   stub(          <i>replace with:</i>  when(\n+\t *   .toReturn(     <i>replace with:</i>  .thenReturn(\n+\t *   .toThrow(      <i>replace with:</i>  .thenThrow(\n+\t *   .toAnswer(     <i>replace with:</i>  .thenAnswer(\n+\t * </pre>\n+\t * If you're an existing user then sorry for making your code littered with deprecation warnings. \n+\t * This change was required to make Mockito better.\n+\t * \n+\t * @param methodCall\n+\t *            method call\n+\t * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n+\t */\n+\t@Deprecated\n+\tpublic static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+\t\treturn MockitoCore.stub(methodCall);\n+\t}\n+    \n+    /**\n+\t * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n+\t * <p>\n+\t * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n+\t * <p>\n+\t * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n+\t * <p>\n+\t * Examples:\n+\t * \n+\t * <pre>\n+\t * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n+\t *\n+\t * //you can use flexible argument matchers, e.g:\n+\t * when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);\n+\t *\n+\t * //setting exception to be thrown:\n+\t * when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());\n+\t *\n+\t * //you can set different behavior for consecutive method calls.\n+\t * //Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls.\n+\t * when(mock.someMethod(\"some arg\"))\n+\t *  .thenThrow(new RuntimeException())\n+\t *  .thenReturn(\"foo\");\n+\t *  \n+\t * //Alternative, shorter version for consecutive stubbing:\n+\t * when(mock.someMethod(\"some arg\"))\n+\t *  .thenReturn(\"one\", \"two\");\n+\t * //is the same as:\n+\t * when(mock.someMethod(\"some arg\"))\n+\t *  .thenReturn(\"one\")\n+\t *  .thenReturn(\"two\");\n+\t *\n+\t * //shorter version for consecutive method calls throwing exceptions:\n+\t * when(mock.someMethod(\"some arg\"))\n+\t *  .thenThrow(new RuntimeException(), new NullPointerException();\n+\t *   \n+\t * </pre>\n+\t * \n+\t * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n+\t * <p>\n+\t * Stubbing can be overridden: for example common stubbing can go to fixture\n+\t * setup but the test methods can override it.\n+\t * <p>\n+\t * Once stubbed, the method will always return stubbed value regardless\n+\t * of how many times it is called.\n+\t * <p>\n+\t * Last stubbing is more important - when you stubbed the same method with\n+\t * the same arguments many times.\n+\t * <p>\n+\t * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n+\t * Let's say you've stubbed foo.bar(). \n+\t * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n+\t * If your code doesn't care what get(0) returns then it should not be stubbed. \n+\t * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+\t * \n+\t * <p>\n+\t * See examples in javadoc for {@link Mockito} class\n+\t * @param methodCall method to be stubbed\n+\t */\n+\tpublic static <T> NewOngoingStubbing<T> when(T methodCall) {\n+\t\treturn MockitoCore.when(methodCall);\n+\t}\n+\n+    /**\n+     * Verifies certain behavior <b>happened once</b> \n+     * <p>\n+     * Alias to <code>verify(mock, times(1))</code> E.g:\n+     * <pre>\n+     *   verify(mock).someMethod(\"some arg\");\n+     * </pre>\n+     * Above is equivalent to:\n+     * <pre>\n+     *   verify(mock, times(1)).someMethod(\"some arg\");\n+     * </pre>\n+     * \n      * <p>\n      * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n      * Let's say you've stubbed foo.bar(). \n      * \n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * @param methodCall method to be stubbed\n-     */\n-    public static <T> NewOngoingStubbing<T> when(T methodCall) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return (NewOngoingStubbing) stub();\n-    }\n-\n-    private static OngoingStubbing stub() {\n-        OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n-        if (stubbing == null) {\n-            MOCKING_PROGRESS.reset();\n-            REPORTER.missingMethodInvocation();\n-        }\n-        return stubbing;\n-    }\n-\n-    /**\n-     * Verifies certain behavior <b>happened once</b> \n-     * <p>\n-     * Alias to <code>verify(mock, times(1))</code> E.g:\n-     * <pre>\n-     *   verify(mock).someMethod(\"some arg\");\n-     * </pre>\n-     * Above is equivalent to:\n-     * <pre>\n-     *   verify(mock, times(1)).someMethod(\"some arg\");\n-     * </pre>\n-     * \n-     * <p>\n-     * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n-     * Let's say you've stubbed foo.bar(). \n-     * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n-     * If your code doesn't care what get(0) returns then it should not be stubbed. \n-     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n-     * \n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n      * \n      * @param mock to be verified\n      * @return mock object itself\n      */\n     public static <T> T verify(T mock) {\n-        return verify(mock, times(1));\n-    }\n-    \n-    /**\n-     * TODO javadoc\n-     * \n-     * @param <T>\n-     * @param mock\n-     */\n-    public static <T> void reset(T mock) {\n-        //TODO Perhaps we should validate the state instead of resetting?\n-        MOCKING_PROGRESS.reset();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n-        //TODO Perhaps we should maintain previous ReturnValues?\n-        MockUtil.resetMock(mock, MOCKING_PROGRESS, RETURNS_DEFAULTS);\n-    }\n+        return MockitoCore.verify(mock, times(1));\n+    }\n+    \n+    /**\n+\t * TODO javadoc\n+\t * \n+\t * @param <T>\n+\t * @param mock\n+\t */\n+\tpublic static <T> void reset(T mock) {\n+\t\tMockitoCore.reset(mock);\n+\t}\n \n  \n     /**\n-     * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n-     * <pre>\n-     *   verify(mock, times(5)).someMethod(\"was called five times\");\n-     *   \n-     *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n-     *   \n-     *   //you can use flexible argument matchers, e.g:\n-     *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n-     * </pre>\n-     * \n-     * <b>times(1) is the default</b> and can be omitted\n-     * <p>\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mock to be verified\n-     * @param mode times(x), atLeastOnce() or never()\n-     * \n-     * @return mock object itself\n-     */\n-    public static <T> T verify(T mock, VerificationMode mode) {\n-        if (mock == null) {\n-            REPORTER.nullPassedToVerify();\n-        } else if (!MockUtil.isMock(mock)) {\n-            REPORTER.notAMockPassedToVerify();\n-        }\n-        MOCKING_PROGRESS.verificationStarted(mode);\n-        return mock;\n-    }\n+\t * Verifies certain behavior happened at least once / exact number of times / never. E.g:\n+\t * <pre>\n+\t *   verify(mock, times(5)).someMethod(\"was called five times\");\n+\t *   \n+\t *   verify(mock, atLeast(2)).someMethod(\"was called at least two times\");\n+\t *   \n+\t *   //you can use flexible argument matchers, e.g:\n+\t *   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);\n+\t * </pre>\n+\t * \n+\t * <b>times(1) is the default</b> and can be omitted\n+\t * <p>\n+\t * See examples in javadoc for {@link Mockito} class\n+\t * \n+\t * @param mock to be verified\n+\t * @param mode times(x), atLeastOnce() or never()\n+\t * \n+\t * @return mock object itself\n+\t */\n+\tpublic static <T> T verify(T mock, VerificationMode mode) {\n+\t\treturn MockitoCore.verify(mock, mode);\n+\t}\n \n     /**\n-     * Checks if any of given mocks has any unverified interaction.\n-     * <p>\n-     * You can use this method after you verified your mocks - to make sure that nothing\n-     * else was invoked on your mocks.\n-     * <p>\n-     * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n-     * <p>\n-     * Stubbed invocations (if called) are also treated as interactions.\n-     * <p>\n-     * A word of <b>warning</b>: \n-     * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n-     * verifyNoMoreInteractions() is not recommended to use in every test method. \n-     * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n-     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n-     * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n-     * <p>\n-     * This method will also detect unverified invocations that occurred before the test method,\n-     * for example: in setUp(), &#064;Before method or in constructor.\n-     * Consider writing nice code that makes interactions only in test methods.\n-     * \n-     * <p>\n-     * Example:\n-     * \n-     * <pre>\n-     * //interactions\n-     * mock.doSomething();\n-     * mock.doSomethingUnexpected();\n-     * \n-     * //verification\n-     * verify(mock).doSomething();\n-     * \n-     * //following will fail because 'doSomethingUnexpected()' is unexpected\n-     * verifyNoMoreInteractions(mock);\n-     * \n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mocks to be verified\n-     */\n-    public static void verifyNoMoreInteractions(Object... mocks) {\n-        assertMocksNotEmpty(mocks);\n-        MOCKING_PROGRESS.validateState();\n-        for (Object mock : mocks) {\n-            try {\n-                if (mock == null) {\n-                    REPORTER.nullPassedToVerifyNoMoreInteractions();\n-                }\n-                MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n-            } catch (NotAMockException e) {\n-                REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n-            }\n-        }\n-    }\n+\t * Checks if any of given mocks has any unverified interaction.\n+\t * <p>\n+\t * You can use this method after you verified your mocks - to make sure that nothing\n+\t * else was invoked on your mocks.\n+\t * <p>\n+\t * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n+\t * <p>\n+\t * Stubbed invocations (if called) are also treated as interactions.\n+\t * <p>\n+\t * A word of <b>warning</b>: \n+\t * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. \n+\t * verifyNoMoreInteractions() is not recommended to use in every test method. \n+\t * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n+\t * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+\t * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n+\t * <p>\n+\t * This method will also detect unverified invocations that occurred before the test method,\n+\t * for example: in setUp(), &#064;Before method or in constructor.\n+\t * Consider writing nice code that makes interactions only in test methods.\n+\t * \n+\t * <p>\n+\t * Example:\n+\t * \n+\t * <pre>\n+\t * //interactions\n+\t * mock.doSomething();\n+\t * mock.doSomethingUnexpected();\n+\t * \n+\t * //verification\n+\t * verify(mock).doSomething();\n+\t * \n+\t * //following will fail because 'doSomethingUnexpected()' is unexpected\n+\t * verifyNoMoreInteractions(mock);\n+\t * \n+\t * </pre>\n+\t * \n+\t * See examples in javadoc for {@link Mockito} class\n+\t * \n+\t * @param mocks to be verified\n+\t */\n+\tpublic static void verifyNoMoreInteractions(Object... mocks) {\n+\t\tMockitoCore.verifyNoMoreInteractions(mocks);\n+\t}\n \n     /**\n      * Verifies that no interactions happened on given mocks.\n      * @param mocks to be verified\n      */\n     public static void verifyZeroInteractions(Object... mocks) {\n-        verifyNoMoreInteractions(mocks);\n+        MockitoCore.verifyNoMoreInteractions(mocks);\n     }\n \n-    private static void assertMocksNotEmpty(Object[] mocks) {\n-        if (mocks == null || mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n-        }\n-    }\n+    public static void assertMocksNotEmpty(Object[] mocks) {\n+\t\tMockitoCore.assertMocksNotEmpty(mocks);\n+\t}\n \n     /**\n-     * <pre>\n-     *   //Instead of:\n-     *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n-     * \n-     *   //Please do:\n-     *   doThrow(e).when(mock).someVoidMethod();\n-     * </pre> \n-     * \n-     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n-     * <p>\n-     * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n-     * \n-     * <pre>\n-     * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n-     * \n-     * //you can stub with different behavior for consecutive calls.\n-     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n-     * stubVoid(mock)\n-     *   .toThrow(new RuntimeException())\n-     *   .toReturn()\n-     *   .on().someMethod();\n-     * </pre>\n-     * \n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n-     * \n-     * @param mock\n-     *            to stub\n-     * @return stubbable object that allows stubbing with throwable\n-     */\n-    public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-        MockHandler<T> handler = MockUtil.getMockHandler(mock);\n-        MOCKING_PROGRESS.stubbingStarted();\n-        return handler.voidMethodStubbable(mock);\n-    }\n+\t * <pre>\n+\t *   //Instead of:\n+\t *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n+\t * \n+\t *   //Please do:\n+\t *   doThrow(e).when(mock).someVoidMethod();\n+\t * </pre> \n+\t * \n+\t * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n+\t * <p>\n+\t * Originally, stubVoid() was used for stubbing void methods with exceptions. E.g:\n+\t * \n+\t * <pre>\n+\t * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n+\t * \n+\t * //you can stub with different behavior for consecutive calls.\n+\t * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n+\t * stubVoid(mock)\n+\t *   .toThrow(new RuntimeException())\n+\t *   .toReturn()\n+\t *   .on().someMethod();\n+\t * </pre>\n+\t * \n+\t * See examples in javadoc for {@link Mockito} class\n+\t * \n+\t * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n+\t * \n+\t * @param mock\n+\t *            to stub\n+\t * @return stubbable object that allows stubbing with throwable\n+\t */\n+\tpublic static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n+\t\treturn MockitoCore.stubVoid(mock);\n+\t}\n     \n     /**\n      * Use doThrow() when you want to stub the void method with an exception.\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doThrow(Throwable toBeThrown) {\n-        return doAnswer(new ThrowsException(toBeThrown));\n-    }\n-    \n-    /**\n-     * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n-     * <p>\n-     * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n-     * <p>\n-     * Example:\n-     * \n-     * <pre>\n-     *  doAnswer(new Answer() {\n-     *      public Object answer(InvocationOnMock invocation) {\n-     *          Object[] args = invocation.getArguments();\n-     *          Mock mock = invocation.getMock();\n-     *          return null;\n-     *      }})\n-     *  .when(mock).someMethod();\n-     * </pre>\n-     * \n-     * @param answer to answer when the stubbed method is called\n-     * @return stubber - to select a method for stubbing\n-     */\n-    public static Stubber doAnswer(Answer answer) {\n-        MOCKING_PROGRESS.stubbingStarted();\n-        MOCKING_PROGRESS.resetOngoingStubbing();\n-        return new StubberImpl().doAnswer(answer);\n-    }  \n+        return MockitoCore.doAnswer(new ThrowsException(toBeThrown));\n+    }\n+    \n+    /**\n+\t * Use doAnswer() when you want to stub a void method with generic {@link Answer}.\n+\t * <p>\n+\t * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n+\t * <p>\n+\t * Example:\n+\t * \n+\t * <pre>\n+\t *  doAnswer(new Answer() {\n+\t *      public Object answer(InvocationOnMock invocation) {\n+\t *          Object[] args = invocation.getArguments();\n+\t *          Mock mock = invocation.getMock();\n+\t *          return null;\n+\t *      }})\n+\t *  .when(mock).someMethod();\n+\t * </pre>\n+\t * \n+\t * @param answer to answer when the stubbed method is called\n+\t * @return stubber - to select a method for stubbing\n+\t */\n+\tpublic static Stubber doAnswer(Answer answer) {\n+\t\treturn MockitoCore.doAnswer(answer);\n+\t}  \n     \n     /**\n      * Use doNothing() for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b> \n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doNothing() {\n-        return doAnswer(new DoesNothing());\n+        return MockitoCore.doAnswer(new DoesNothing());\n     }    \n     \n     /**\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doReturn(Object toBeReturned) {\n-        return doAnswer(new Returns(toBeReturned));\n+        return MockitoCore.doAnswer(new Returns(toBeReturned));\n     }\n  \n     /**\n-     * Creates InOrder object that allows verifying mocks in order.\n-     * \n-     * <pre>\n-     *   InOrder inOrder = inOrder(firstMock, secondMock);\n-     *   \n-     *   inOrder.verify(firstMock).add(\"was called first\");\n-     *   inOrder.verify(secondMock).add(\"was called second\");\n-     * </pre>\n-     * \n-     * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n-     * but only those that you are interested in testing in order.\n-     * <p>\n-     * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n-     *\n-     * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param mocks to be verified in order\n-     * \n-     * @return InOrder object to be used to verify in order\n-     */\n-    public static InOrder inOrder(Object... mocks) {\n-        if (mocks == null || mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n-        }\n-        for (Object mock : mocks) {\n-            if (mock == null) {\n-                REPORTER.nullPassedWhenCreatingInOrder();\n-            } else if (!MockUtil.isMock(mock)) {\n-                REPORTER.notAMockPassedWhenCreatingInOrder();\n-            }\n-        }\n-        InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n-        return inOrder;\n-    }\n+\t * Creates InOrder object that allows verifying mocks in order.\n+\t * \n+\t * <pre>\n+\t *   InOrder inOrder = inOrder(firstMock, secondMock);\n+\t *   \n+\t *   inOrder.verify(firstMock).add(\"was called first\");\n+\t *   inOrder.verify(secondMock).add(\"was called second\");\n+\t * </pre>\n+\t * \n+\t * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n+\t * but only those that you are interested in testing in order.\n+\t * <p>\n+\t * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.  \n+\t *\n+\t * See examples in javadoc for {@link Mockito} class\n+\t * \n+\t * @param mocks to be verified in order\n+\t * \n+\t * @return InOrder object to be used to verify in order\n+\t */\n+\tpublic static InOrder inOrder(Object... mocks) {\n+\t\treturn MockitoCore.inOrder(mocks);\n+\t}\n   \n     /**\n      * Allows verifying exact number of invocations. E.g:\n--- /dev/null\n+++ b/src/org/mockito/internal/InOrderImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.verification.InOrderWrapper;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.internal.verification.api.VerificationInOrderMode;\n+import org.mockito.internal.verification.api.VerificationMode;\n+\n+/**\n+ * Allows verifying in order. This class should not be exposed, hence default access.\n+ */\n+class InOrderImpl implements InOrder {\n+    \n+    private final Reporter reporter = new Reporter();\n+    private final List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n+    \n+    public InOrderImpl(List<Object> mocksToBeVerifiedInOrder) {\n+        this.mocksToBeVerifiedInOrder.addAll(mocksToBeVerifiedInOrder);\n+    }\n+\n+    public <T> T verify(T mock) {\n+        return this.verify(mock, VerificationModeFactory.times(1));\n+    }\n+    \n+    public <T> T verify(T mock, VerificationMode mode) {\n+        if (!mocksToBeVerifiedInOrder.contains(mock)) {\n+            reporter.inOrderRequiresFamiliarMock();\n+        } else if (!(mode instanceof VerificationInOrderMode)) {\n+            throw new MockitoException(mode.getClass().getSimpleName() + \" is not implemented to work with InOrder\");\n+        }\n+        return MockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, mocksToBeVerifiedInOrder));\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoCore.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.util.Arrays;\n+\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.mockito.ReturnValues;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.internal.progress.OngoingStubbing;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.StubberImpl;\n+import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.verification.api.VerificationMode;\n+import org.mockito.stubbing.Answer;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoCore {\n+\n+\tstatic final Reporter REPORTER = new Reporter();\n+\tpublic static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n+\t\n+\tpublic static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n+\t    MOCKING_PROGRESS.validateState();\n+\t    MOCKING_PROGRESS.resetOngoingStubbing();\n+\t    return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n+\t}\n+\t\n+\tpublic static OngoingStubbing stub() {\n+\t    OngoingStubbing stubbing = MOCKING_PROGRESS.pullOngoingStubbing();\n+\t    if (stubbing == null) {\n+\t        MOCKING_PROGRESS.reset();\n+\t        REPORTER.missingMethodInvocation();\n+\t    }\n+\t    return stubbing;\n+\t}\n+\n+\t@Deprecated\n+\tpublic static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n+\t    MOCKING_PROGRESS.stubbingStarted();\n+\t    return (DeprecatedOngoingStubbing) stub();\n+\t}\n+\n+\tpublic static <T> NewOngoingStubbing<T> when(T methodCall) {\n+\t    MOCKING_PROGRESS.stubbingStarted();\n+\t    return (NewOngoingStubbing) stub();\n+\t}\n+\t\n+\t\n+\tpublic static <T> T verify(T mock, VerificationMode mode) {\n+\t    if (mock == null) {\n+\t        REPORTER.nullPassedToVerify();\n+\t    } else if (!MockUtil.isMock(mock)) {\n+\t        REPORTER.notAMockPassedToVerify();\n+\t    }\n+\t    MOCKING_PROGRESS.verificationStarted(mode);\n+\t    return mock;\n+\t}\n+\t\n+\tpublic static <T> void reset(T mock) {\n+\t    //TODO Perhaps we should validate the state instead of resetting?\n+\t    MOCKING_PROGRESS.reset();\n+\t    MOCKING_PROGRESS.resetOngoingStubbing();\n+\t    //TODO Perhaps we should maintain previous ReturnValues?\n+\t    MockUtil.resetMock(mock, MOCKING_PROGRESS, Mockito.RETURNS_DEFAULTS);\n+\t}\n+\t\n+\tpublic static void verifyNoMoreInteractions(Object... mocks) {\n+\t    MockitoCore.assertMocksNotEmpty(mocks);\n+\t    MOCKING_PROGRESS.validateState();\n+\t    for (Object mock : mocks) {\n+\t        try {\n+\t            if (mock == null) {\n+\t                REPORTER.nullPassedToVerifyNoMoreInteractions();\n+\t            }\n+\t            MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n+\t        } catch (NotAMockException e) {\n+\t            REPORTER.notAMockPassedToVerifyNoMoreInteractions();\n+\t        }\n+\t    }\n+\t}\n+\t\n+\tpublic static void assertMocksNotEmpty(Object[] mocks) {\n+\t    if (mocks == null || mocks.length == 0) {\n+\t        REPORTER.mocksHaveToBePassedToVerifyNoMoreInteractions();\n+\t    }\n+\t}\n+\t\n+\tpublic static InOrder inOrder(Object... mocks) {\n+\t    if (mocks == null || mocks.length == 0) {\n+\t        REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n+\t    }\n+\t    for (Object mock : mocks) {\n+\t        if (mock == null) {\n+\t            REPORTER.nullPassedWhenCreatingInOrder();\n+\t        } else if (!MockUtil.isMock(mock)) {\n+\t            REPORTER.notAMockPassedWhenCreatingInOrder();\n+\t        }\n+\t    }\n+\t    InOrder inOrder = new InOrderImpl(Arrays.asList(mocks));\n+\t    return inOrder;\n+\t}\n+\t\n+\tpublic static Stubber doAnswer(Answer answer) {\n+\t    MOCKING_PROGRESS.stubbingStarted();\n+\t    MOCKING_PROGRESS.resetOngoingStubbing();\n+\t    return new StubberImpl().doAnswer(answer);\n+\t}\n+\t\n+\tpublic static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n+\t    MockHandler<T> handler = MockUtil.getMockHandler(mock);\n+\t    MOCKING_PROGRESS.stubbingStarted();\n+\t    return handler.voidMethodStubbable(mock);\n+\t}\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/returnvalues/MockReturnValues.java\n+package org.mockito.internal.returnvalues;\n+\n+import org.mockito.ReturnValues;\n+import org.mockito.internal.MockitoCore;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+public class MockReturnValues implements ReturnValues {\n+\t\n+\tprivate ReturnValues delegate = new MoreEmptyReturnValues();\n+\t\n+\tpublic Object valueFor(InvocationOnMock invocation){\n+\t\tObject ret = delegate.valueFor(invocation);\n+\t\tif (ret != null) {\n+\t\t\treturn ret;\n+\t\t}\n+\t\t\t\n+\t\treturn returnValueFor(invocation.getMethod().getReturnType());\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tObject returnValueFor(Class<?> class1) {\n+\t\tif (!ClassImposterizer.INSTANCE.canImposterise(class1)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\t\n+\t\treturn MockitoCore.mock((Class)class1, null, null, this);\n+\t}\n+\n+}\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n  */\n package org.mockito;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.times;\n \n import java.util.List;\n \n import org.junit.Test;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n     public void shouldRemoveStubbableFromProgressAfterStubbing() {\n         List mock = Mockito.mock(List.class);\n         Mockito.when(mock.add(\"test\")).thenReturn(true);\n-        \n-        assertNull(Mockito.MOCKING_PROGRESS.pullOngoingStubbing());\n+        //FIXME Consider to move to separate test\n+        assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing());\n     }\n     \n     @Test(expected=NotAMockException.class)\n--- a/test/org/mockito/StateMaster.java\n+++ b/test/org/mockito/StateMaster.java\n  */\n package org.mockito;\n \n+import org.mockito.internal.MockitoCore;\n+\n public class StateMaster {\n     \n     public static void reset() {\n-        Mockito.MOCKING_PROGRESS.reset();\n+        MockitoCore.MOCKING_PROGRESS.reset();\n     }\n     \n     public static void validate() {\n-        Mockito.MOCKING_PROGRESS.validateState();\n+        MockitoCore.MOCKING_PROGRESS.validateState();\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/returnvalues/HasPrimitiveMethods.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.returnvalues;\n+\n+interface HasPrimitiveMethods {\n+    boolean booleanMethod();\n+    char charMethod();\n+    int intMethod();\n+    long longMethod();\n+    float floatMethod();\n+    double doubleMethod();\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/returnvalues/MockReturnValuesTest.java\n+package org.mockito.internal.returnvalues;\n+\n+import java.lang.reflect.Method;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockitoutil.TestBase;\n+\n+public class MockReturnValuesTest extends TestBase {\n+    private MockReturnValues values = new MockReturnValues();\n+\n+    interface FooInterface {\n+    }\n+\n+    class BarClass {\n+    }\n+\n+    final class Baz {\n+\n+    }\n+\n+    @Test\n+    // FIXME split into separate\n+    public void shouldReturnMockValueForInterface() throws Exception {\n+        Object interfaceMock = values.returnValueFor(FooInterface.class);\n+        assertTrue(MockUtil.isMock(interfaceMock));\n+    }\n+\n+    public void shouldReturnMockValueForClass() throws Exception {\n+        Object classMock = values.returnValueFor(BarClass.class);\n+        assertTrue(MockUtil.isMock(classMock));\n+    }\n+\n+    @Test\n+    public void shouldReturnNullForFinalClass() throws Exception {\n+        assertNull(values.returnValueFor(Baz.class));\n+    }\n+\n+    private Invocation invocationOf(Class<?> type, String methodName)\n+            throws NoSuchMethodException {\n+        return new Invocation(new Object(), type.getMethod(methodName,\n+                new Class[0]), new Object[0], 1);\n+    }\n+\n+    @Test\n+    public void shouldReturnTheUsualDefaultValuesForPrimitives()\n+            throws Exception {\n+        MockReturnValues returnValues = new MockReturnValues();\n+        assertEquals(false, returnValues.valueFor(invocationOf(HasPrimitiveMethods.class, \"booleanMethod\")));\n+        assertEquals((char) 0, returnValues.valueFor(invocationOf(HasPrimitiveMethods.class, \"charMethod\")));\n+        assertEquals(0, returnValues.valueFor(invocationOf(HasPrimitiveMethods.class, \"intMethod\")));\n+        assertEquals(0, returnValues.valueFor(invocationOf(HasPrimitiveMethods.class, \"longMethod\")));\n+        assertEquals(0, returnValues.valueFor(invocationOf(HasPrimitiveMethods.class, \"floatMethod\")));\n+        assertEquals(0, returnValues.valueFor(invocationOf(HasPrimitiveMethods.class, \"doubleMethod\")));\n+    }\n+    \n+    interface StringMethods {\n+        String stringMethod();\n+        String[] stringArrayMethod();\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyArray() throws Exception{\n+        String[] ret = (String[]) values.valueFor(invocationOf(StringMethods.class, \"stringArrayMethod\"));\n+        \n+        assertTrue(ret.getClass().isArray());\n+        assertTrue(ret.length == 0);\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyString() throws Exception{\n+        assertEquals(\"\", values.valueFor(invocationOf(StringMethods.class, \"stringMethod\")));\n+    }\n+}\n--- a/test/org/mockito/internal/returnvalues/MoreEmptyReturnValuesTest.java\n+++ b/test/org/mockito/internal/returnvalues/MoreEmptyReturnValuesTest.java\n     @Test\n     public void shouldReturnEmptyArray() {\n         String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());\n-        ret.getClass().isArray();\n+        assertTrue(ret.getClass().isArray());\n         assertTrue(ret.length == 0);\n     }\n     \n--- a/test/org/mockito/internal/returnvalues/SmartNullReturnValuesTest.java\n+++ b/test/org/mockito/internal/returnvalues/SmartNullReturnValuesTest.java\n \n public class SmartNullReturnValuesTest extends TestBase {\n     \n-    interface HasPrimitiveMethods {\n-        boolean booleanMethod();\n-        char charMethod();\n-        int intMethod();\n-        long longMethod();\n-        float floatMethod();\n-        double doubleMethod();\n-    }\n-\n     private Invocation invocationOf(Class<?> type, String methodName) throws NoSuchMethodException {\n         return new Invocation(new Object(), type.getMethod(methodName, new Class[0]), new Object[0], 1);\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/ReturningMockValuesTest.java\n+package org.mockitousage.stubbing;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+//FIXME add test to demonstrate usage\n+public class ReturningMockValuesTest extends TestBase {\n+\n+    @Test\n+    public void should() throws Exception {\n+        \n+    }\n+}", "timestamp": 1239800544, "metainfo": ""}