{"sha": "d0a486abd85215ac528b901febddd2c17bfda58b", "log": "massive change: renamed strictly into inOrder  --HG-- rename : src/org/mockito/Strictly.java => src/org/mockito/InOrder.java rename : src/org/mockito/StrictOrderVerifier.java => src/org/mockito/InOrderVerifier.java rename : src/org/mockito/exceptions/verification/StrictVerificationFailure.java => src/org/mockito/exceptions/verification/VerifcationInOrderFailed.java rename : src/org/mockito/internal/verification/StrictlyMissingInvocationVerifier.java => src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java rename : src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java => src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java rename : test/org/mockito/internal/verification/StrictlyMissingInvocationVerifierTest.java => test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java rename : test/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifierTest.java => test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java rename : test/org/mockitousage/verification/BasicStrictVerificationTest.java => test/org/mockitousage/verification/BasicVerificationInOrderTest.java rename : test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java => test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java rename : test/org/mockitousage/verification/RelaxedStrictVerificationTest.java => test/org/mockitousage/verification/RelaxedVerificationInOrderTest.java rename : test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java => test/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java rename : test/org/mockitousage/verification/StrictVerificationTest.java => test/org/mockitousage/verification/VerificationInOrderTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40286", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/InOrder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import org.mockito.internal.progress.VerificationMode;\n+\n+//TODO add pattern for not creating it for all mocks\n+\n+/**\n+ * Allows verification in order. E.g:\n+ * \n+ * <pre>\n+ * InOrder inOrder = inOrder(firstMock, secondMock);\n+ * \n+ * inOrder.verify(firstMock).add(\"should be called first\");\n+ * inOrder.verify(secondMock).add(\"should be called second\");\n+ * </pre>\n+ * \n+ * See examples {@link Mockito#inOrder(Object...)}\n+ */\n+public interface InOrder {\n+    /**\n+     * Verifies mock object in order. E.g:\n+     * \n+     * <pre>\n+     * InOrder inOrder = inOrder(firstMock, secondMock);\n+     * \n+     * inOrder.verify(firstMock).someMethod(\"should be called first\");\n+     * inOrder.verify(secondMock).someMethod(\"should be called second\");\n+     * </pre>\n+     * <p>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mock to be verified\n+     * \n+     * @return mock object itself\n+     */\n+    <T> T verify(T mock);\n+\n+    /**\n+     * Verifies mock object in order. E.g:\n+     * \n+     * <pre>\n+     * InOrder inOrder = inOrder(firstMock, secondMock);\n+     * \n+     * inOrder.verify(firstMock, times(2)).someMethod(\"should be called first two times\");\n+     * inOrder.verify(secondMock, atLeastOnce()).someMethod(\"should be called second\");\n+     * </pre>\n+     * <p>\n+     * \n+     * See examples {@link Mockito}\n+     * \n+     * @param mock to be verified\n+     * @param mode times(x) or atLeastOnce()\n+     * \n+     * @return mock object itself\n+     */\n+    <T> T verify(T mock, VerificationMode mode);\n+}\n--- /dev/null\n+++ b/src/org/mockito/InOrderVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.progress.VerificationMode;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+/**\n+ * Allows verifying in order. This class should not be exposed, hence default access.\n+ */\n+class InOrderVerifier implements InOrder {\n+    \n+    private final Reporter reporter = new Reporter();\n+    private final List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n+    \n+    public InOrderVerifier(List<Object> mocksToBeVerifiedInOrder) {\n+        this.mocksToBeVerifiedInOrder.addAll(mocksToBeVerifiedInOrder);\n+    }\n+\n+    public <T> T verify(T mock) {\n+        return this.verify(mock, VerificationModeImpl.times(1));\n+    }\n+    \n+    public <T> T verify(T mock, VerificationMode mode) {\n+        if (!mocksToBeVerifiedInOrder.contains(mock)) {\n+            reporter.inOrderRequiresFamiliarMock();\n+        }\n+        Integer wantedCount = ((VerificationModeImpl) mode).wantedCount();\n+        return Mockito.verify(mock, VerificationModeImpl.inOrder(wantedCount, mocksToBeVerifiedInOrder));\n+    }\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * \n  * See more {@link Mockito#verifyNoMoreInteractions}\n  * \n- * <h3>Strict order verification</h3>\n+ * <h3>Verification in order</h3>\n  * \n  * <pre>\n  *   List firstMock = mock(List.class);\n  *   firstMock.add(\"one\");\n  *   secondMock.add(\"two\");\n  *   \n- *   //create strictly \n- *   Strictly strictly = strictly(firstMock, secondMock);\n+ *   //create inOrder object\n+ *   InOrder inOrder = inOrder(firstMock, secondMock);\n  *   \n  *   //following will make sure that firstMock was called before secondMock\n- *   strictly.verify(firstMock).add(\"should be called first\");\n- *   strictly.verify(secondMock).add(\"should be called second\");\n- * </pre>\n- * \n- * <p>\n- * Strict verification is required only in some cases and mostly ordinary verification is enough. \n+ *   inOrder.verify(firstMock).add(\"should be called first\");\n+ *   inOrder.verify(secondMock).add(\"should be called second\");\n+ * </pre>\n+ * \n+ * <p>\n+ * Verification in order is required only in some cases and mostly ordinary verification is enough. \n  * \n  * <h3>Making sure no interactions happened on mock</h3>\n  * \n     }\n \n     /**\n-     * Creates strictly that allows verifying mocks in order.\n-     * \n-     * <pre>\n-     *   Strictly strictly = strictly(firstMock, secondMock);\n+     * Creates InOrder object that allows verifying mocks in order.\n+     * \n+     * <pre>\n+     *   InOrder inOrder = inOrder(firstMock, secondMock);\n      *   \n-     *   strictly.verify(firstMock).add(\"should be called first\");\n-     *   strictly.verify(secondMock).add(\"should be called second\");\n+     *   inOrder.verify(firstMock).add(\"should be called first\");\n+     *   inOrder.verify(secondMock).add(\"should be called second\");\n      * </pre>\n      *\n      * See examples in javadoc for {@link Mockito}\n      * \n-     * @param mocks to be verified in strict order\n-     * \n-     * @return verifier object to be used to verify strictly\n-     */\n-    public static Strictly strictly(Object... mocks) {\n+     * @param mocks to be verified in order\n+     * \n+     * @return InOrder object to be used to verify in order\n+     */\n+    public static InOrder inOrder(Object... mocks) {\n         if (mocks.length == 0) {\n-            REPORTER.mocksHaveToBePassedWhenCreatingStrictly();\n+            REPORTER.mocksHaveToBePassedWhenCreatingInOrder();\n         }\n         for (Object mock : mocks) {\n             MockUtil.validateMock(mock);\n         }\n-        Strictly strictOrderVerifier = new StrictOrderVerifier(Arrays.asList(mocks));\n-        return strictOrderVerifier;\n+        InOrder inOrderVerifier = new InOrderVerifier(Arrays.asList(mocks));\n+        return inOrderVerifier;\n     }\n \n     /**\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n         throw new MockitoException(join(\n                 \"Method requires arguments.\",\n                 \"Pass mocks that should be verified, e.g:\",\n-                \"verifyNoMoreInteractions(mockOne, mockTwo)\"\n-                ));\n-    }\n-\n-    public void strictlyRequiresFamiliarMock() {\n-        throw new MockitoException(join(\n-                \"Strictly can only verify mocks that were passed in during creation of Strictly. E.g:\",\n-                \"Strictly strictly = strictly(mockOne)\",\n-                \"strictly.verify(mockOne).doStuff()\"\n-                ));\n-    }\n-\n-    public void mocksHaveToBePassedWhenCreatingStrictly() {\n+                \"verifyNoMoreInteractions(mockOne, mockTwo);\"\n+                ));\n+    }\n+\n+    public void inOrderRequiresFamiliarMock() {\n+        throw new MockitoException(join(\n+                \"InOrder can only verify mocks that were passed in during creation of InOrder. E.g:\",\n+                \"InOrder inOrder = inOrder(mockOne);\",\n+                \"inOrder.verify(mockOne).doStuff();\"\n+                ));\n+    }\n+\n+    public void mocksHaveToBePassedWhenCreatingInOrder() {\n         throw new MockitoException(join(\n                 \"Method requires arguments.\",\n-                \"Pass mocks that require strict order verification, e.g:\",\n-                \"strictly(mockOne, mockTwo)\"\n+                \"Pass mocks that require verification in order, e.g:\",\n+                \"InOrder inOrder = inOrder(mockOne, mockTwo);\"\n                 ));\n     }\n \n             ), cause);\n     }\n     \n-    public void strictlyWantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+    public void wantedDiffersFromActualInOrder(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n         WantedDiffersFromActual cause = createDiscrepancyCause(actual, actualInvocationStackTrace);\n \n-        throw new StrictVerificationFailure(join(\n-                \"Strict verification failure\",\n+        throw new VerifcationInOrderFailed(join(\n+                \"Verification in order failed\",\n                 \"Wanted invocation:\",\n                 wanted\n             ), cause);\n         ));\n     }\n     \n-    public void strictlyWantedButNotInvoked(String wanted) {\n-        throw new StrictVerificationFailure(join(\n-                    \"Strict verification failure\",\n+    public void wantedButNotInvokedInOrder(String wanted) {\n+        throw new VerifcationInOrderFailed(join(\n+                    \"Verification in order failed\",\n                     \"Wanted but not invoked:\",\n                     wanted\n         ));\n         ), cause);\n     }\n     \n-    public void strictlyTooManyActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n+    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n         UndesiredInvocation cause = createUndesiredInvocationCause(firstUndesired);\n \n-        throw new StrictVerificationFailure(join(\n-                \"Strict verification failure\",\n+        throw new VerifcationInOrderFailed(join(\n+                \"Verification in order failed\",\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n     }\n \n     \n-    public void strictlyTooLittleActualInvocations(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualStackTrace) {\n+    public void tooLittleActualInvocationsInOrder(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualStackTrace) {\n         TooLittleInvocations cause = createTooLittleInvocationsCause(lastActualStackTrace);\n \n-        throw new StrictVerificationFailure(join(\n-                \"Strict verification failure\",\n+        throw new VerifcationInOrderFailed(join(\n+                \"Verification in order failed\",\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/VerifcationInOrderFailed.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class VerifcationInOrderFailed extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public VerifcationInOrderFailed(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public VerifcationInOrderFailed(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n-import org.mockito.internal.verification.StrictlyMissingInvocationVerifier;\n-import org.mockito.internal.verification.StrictlyNumberOfInvocationsVerifier;\n+import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n+import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifier;\n import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n \n     \n     private VerifyingRecorder createRecorder() {\n         List<Verifier> verifiers = Arrays.asList(\n-                new StrictlyMissingInvocationVerifier(),\n-                new StrictlyNumberOfInvocationsVerifier(),\n+                new MissingInvocationInOrderVerifier(),\n+                new NumberOfInvocationsInOrderVerifier(),\n                 new MissingInvocationVerifier(),\n                 new NumberOfInvocationsVerifier(),\n                 new NoMoreInvocationsVerifier());\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n  * Method call on a mock object. \n  * <p>\n  * Contains sequence number which should be\n- * globally unique and is used for strict order verification.\n+ * globally unique and is used for verification in order.\n  * <p>\n  * Contains stack trace of invocation\n  */\n     private final HasStackTrace stackTrace;\n \n     private boolean verified;\n-    private boolean verifiedStrictly;\n+    private boolean verifiedInOrder;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n         this.mock = mock;\n         return sequenceNumber;\n     }\n \n-    public void markVerifiedStrictly() {\n+    public void markVerifiedInOrder() {\n         this.markVerified();\n-        this.verifiedStrictly = true;\n+        this.verifiedInOrder = true;\n     }\n \n-    public boolean isVerifiedStrictly() {\n-        return verifiedStrictly;\n+    public boolean isVerifiedInOrder() {\n+        return verifiedInOrder;\n     }\n     \n     public HasStackTrace getStackTrace() {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n     }\n \n     public List<Invocation> findFirstUnverifiedChunk(List<Invocation> invocations, InvocationMatcher wanted) {\n-        List<Invocation> unverified = ListUtil.filter(invocations, new RemoveVerifiedStrictly());\n+        List<Invocation> unverified = ListUtil.filter(invocations, new RemoveVerifiedInOrder());\n         List<Invocation> firstChunk = new LinkedList<Invocation>();\n         for (Invocation invocation : unverified) {\n             if (wanted.matches(invocation)) {\n         }\n     }\n \n-    private final class RemoveVerifiedStrictly implements Filter<Invocation> {\n+    private final class RemoveVerifiedInOrder implements Filter<Invocation> {\n         public boolean isOut(Invocation invocation) {\n-            return invocation.isVerifiedStrictly();\n+            return invocation.isVerifiedInOrder();\n         }\n     }\n }\n--- a/src/org/mockito/internal/progress/VerificationModeImpl.java\n+++ b/src/org/mockito/internal/progress/VerificationModeImpl.java\n     enum Verification { EXPLICIT, NO_MORE_WANTED };\n     \n     private final Integer wantedInvocationCount;\n-    private final List<? extends Object> mocksToBeVerifiedStrictly;\n+    private final List<? extends Object> mocksToBeVerifiedInOrder;\n     private final Verification verification;\n     \n-    private VerificationModeImpl(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedStrictly, Verification verification) {\n+    private VerificationModeImpl(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder, Verification verification) {\n         if (wantedNumberOfInvocations != null && wantedNumberOfInvocations.intValue() < 0) {\n             throw new MockitoException(\"Negative value is not allowed here\");\n         }\n-        assert mocksToBeVerifiedStrictly != null;\n+        assert mocksToBeVerifiedInOrder != null;\n         this.wantedInvocationCount = wantedNumberOfInvocations;\n-        this.mocksToBeVerifiedStrictly = mocksToBeVerifiedStrictly;\n+        this.mocksToBeVerifiedInOrder = mocksToBeVerifiedInOrder;\n         this.verification = verification;\n     }\n     \n         return new VerificationModeImpl(wantedNumberOfInvocations, Collections.emptyList(), Verification.EXPLICIT);\n     }\n \n-    public static VerificationModeImpl strict(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedStrictly) {\n-        assert !mocksToBeVerifiedStrictly.isEmpty();\n-        return new VerificationModeImpl(wantedNumberOfInvocations, mocksToBeVerifiedStrictly, Verification.EXPLICIT);\n+    public static VerificationModeImpl inOrder(Integer wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder) {\n+        assert !mocksToBeVerifiedInOrder.isEmpty();\n+        return new VerificationModeImpl(wantedNumberOfInvocations, mocksToBeVerifiedInOrder, Verification.EXPLICIT);\n     }\n     \n     public static VerificationModeImpl noMoreInteractions() {\n         return wantedInvocationCount;\n     }\n \n-    public List<? extends Object> getMocksToBeVerifiedStrictly() {\n-        return mocksToBeVerifiedStrictly;\n+    public List<? extends Object> getMocksToBeVerifiedInOrder() {\n+        return mocksToBeVerifiedInOrder;\n     }\n \n     boolean atLeastOnceMode() {\n         return verification == Verification.EXPLICIT;\n     }\n     \n-    public boolean strictMode() {\n-        return !mocksToBeVerifiedStrictly.isEmpty() && explicitMode();\n+    public boolean inOrderMode() {\n+        return !mocksToBeVerifiedInOrder.isEmpty() && explicitMode();\n     }\n     \n     public boolean missingMethodMode() {\n         return explicitMode() && (atLeastOnceMode() || wantedInvocationCount > 0);\n     }\n     \n-    public boolean strictlyMissingMethodMode() {\n-        return strictMode() && missingMethodMode();\n+    public boolean missingMethodInOrderMode() {\n+        return inOrderMode() && missingMethodMode();\n     }\n     \n     public boolean exactNumberOfInvocationsMode() {\n-        return !strictMode() && explicitMode();\n+        return !inOrderMode() && explicitMode();\n     }\n \n     public boolean matchesActualCount(int actualCount) {\n     \n     @Override\n     public String toString() {\n-        return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedStrictly;\n+        return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedInOrder;\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/MissingInvocationInOrderVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.invocation.InvocationsPrinter;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+public class MissingInvocationInOrderVerifier implements Verifier {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+    \n+    public MissingInvocationInOrderVerifier() {\n+        this(new InvocationsFinder(), new Reporter());\n+    }\n+    \n+    public MissingInvocationInOrderVerifier(InvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        if (!mode.missingMethodInOrderMode()) {\n+            return;\n+        }\n+        \n+        List<Invocation> chunk = finder.findFirstUnverifiedChunk(invocations, wanted);\n+        \n+        if (chunk.size() == 0) {\n+            reporter.wantedButNotInvokedInOrder(wanted.toString());\n+        } else if (!wanted.matches(chunk.get(0))) {\n+            Invocation actual = chunk.get(0);\n+            InvocationsPrinter printer = new InvocationsPrinter(wanted, actual);\n+            reporter.wantedDiffersFromActualInOrder(printer.printWanted(), printer.printActual(), actual.getStackTrace());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.List;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.progress.VerificationModeImpl;\n+\n+public class NumberOfInvocationsInOrderVerifier implements Verifier {\n+    \n+    private final Reporter reporter;\n+    private final InvocationsFinder finder;\n+    \n+    public NumberOfInvocationsInOrderVerifier() {\n+        this(new InvocationsFinder(), new Reporter());\n+    }\n+    \n+    public NumberOfInvocationsInOrderVerifier(InvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n+        this.reporter = reporter;\n+    }\n+\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        if (!mode.inOrderMode()) {\n+            return;\n+        }\n+        \n+        List<Invocation> chunk = finder.findFirstUnverifiedChunk(invocations, wanted);\n+        \n+        boolean noMatchFound = chunk.size() == 0 || !wanted.matches(chunk.get(0));\n+        if (mode.wantedCountIsZero() && noMatchFound) {\n+            return;\n+        }\n+        \n+        int actualCount = chunk.size();\n+        \n+        if (mode.tooLittleActualInvocations(actualCount)) {\n+            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n+            reporter.tooLittleActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n+        }\n+        \n+        if (mode.tooManyActualInvocations(actualCount)) {\n+            HasStackTrace firstUndesired = chunk.get(mode.wantedCount()).getStackTrace();\n+            reporter.tooManyActualInvocationsInOrder(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n+        }\n+        \n+        for (Invocation i : chunk) {\n+            i.markVerifiedInOrder();\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n \n     public void verify(InvocationMatcher wanted, VerificationModeImpl mode) {\n         List<Invocation> invocations;\n-        if (mode.strictMode()) {\n-            invocations = globalInvocationsFinder.getAllInvocations(mode.getMocksToBeVerifiedStrictly());\n+        if (mode.inOrderMode()) {\n+            invocations = globalInvocationsFinder.getAllInvocations(mode.getMocksToBeVerifiedInOrder());\n         } else {\n             invocations = registeredInvocations;\n         }\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n     }\n     \n     @Test(expected=NotAMockException.class)\n-    public void shouldValidateMockWhenGettingStrictVerifier() {\n-        Mockito.strictly(\"notMock\");\n+    public void shouldValidateMockWhenCreatingInOrderObject() {\n+        Mockito.inOrder(\"notMock\");\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     }\n     \n     @Test\n-    public void shouldMarkVerifiedWhenMarkingVerifiedStrictly() throws Exception {\n+    public void shouldMarkVerifiedWhenMarkingVerifiedInOrder() throws Exception {\n         assertFalse(invocation.isVerified());\n-        assertFalse(invocation.isVerifiedStrictly());\n+        assertFalse(invocation.isVerifiedInOrder());\n         \n-        invocation.markVerifiedStrictly();\n+        invocation.markVerifiedInOrder();\n         \n         assertTrue(invocation.isVerified());\n-        assertTrue(invocation.isVerifiedStrictly());\n+        assertTrue(invocation.isVerifiedInOrder());\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n     \n     @Test\n     public void shouldFindFirstChunkAndSkipVerifiedInvocations() throws Exception {\n-        simpleMethodInvocation.markVerifiedStrictly();\n-        simpleMethodInvocationTwo.markVerifiedStrictly();\n+        simpleMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocationTwo.markVerifiedInOrder();\n         \n         List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n         \n     \n     @Test\n     public void shouldFindFirstChunkAndSkipAllInvocations() throws Exception {\n-        simpleMethodInvocation.markVerifiedStrictly();\n-        simpleMethodInvocationTwo.markVerifiedStrictly();\n-        differentMethodInvocation.markVerifiedStrictly();\n+        simpleMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocationTwo.markVerifiedInOrder();\n+        differentMethodInvocation.markVerifiedInOrder();\n         \n         List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n         \n--- a/test/org/mockito/internal/progress/VerificationModeBuilder.java\n+++ b/test/org/mockito/internal/progress/VerificationModeBuilder.java\n \n     private Integer times;\n \n-    public VerificationModeImpl strict() {\n-        return VerificationModeImpl.strict(times, Arrays.asList(new Object()));\n+    public VerificationModeImpl inOrder() {\n+        return VerificationModeImpl.inOrder(times, Arrays.asList(new Object()));\n     }\n \n     public VerificationModeBuilder times(int times) {\n--- a/test/org/mockito/internal/progress/VerificationModeImplTest.java\n+++ b/test/org/mockito/internal/progress/VerificationModeImplTest.java\n import static org.junit.Assert.fail;\n import static org.mockito.internal.progress.VerificationModeImpl.atLeastOnce;\n import static org.mockito.internal.progress.VerificationModeImpl.noMoreInteractions;\n-import static org.mockito.internal.progress.VerificationModeImpl.strict;\n+import static org.mockito.internal.progress.VerificationModeImpl.inOrder;\n import static org.mockito.internal.progress.VerificationModeImpl.times;\n \n import org.junit.Test;\n     }\n     \n     @Test\n-    public void shouldKnowIfIsStrictlyMissingMethodMode() throws Exception {\n-        assertTrue(strict(null, asList(\"mock\")).strictlyMissingMethodMode());\n-        assertTrue(strict(1, asList(\"mock\")).strictlyMissingMethodMode());\n-        assertTrue(strict(10, asList(\"mock\")).strictlyMissingMethodMode());\n+    public void shouldKnowIfIsMissingMethodInOrderMode() throws Exception {\n+        assertTrue(inOrder(null, asList(\"mock\")).missingMethodInOrderMode());\n+        assertTrue(inOrder(1, asList(\"mock\")).missingMethodInOrderMode());\n+        assertTrue(inOrder(10, asList(\"mock\")).missingMethodInOrderMode());\n         \n-        assertFalse(times(10).strictlyMissingMethodMode());\n-        assertFalse(noMoreInteractions().strictlyMissingMethodMode());\n-        assertFalse(times(0).strictlyMissingMethodMode());\n+        assertFalse(times(10).missingMethodInOrderMode());\n+        assertFalse(noMoreInteractions().missingMethodInOrderMode());\n+        assertFalse(times(0).missingMethodInOrderMode());\n     }\n     \n     @Test\n-    public void shouldKnowIfIsStrict() throws Exception {\n-        assertTrue(strict(1, asList(new Object())).strictMode());\n+    public void shouldKnowIfIsInOrderMode() throws Exception {\n+        assertTrue(inOrder(1, asList(new Object())).inOrderMode());\n         \n-        assertFalse(times(0).strictMode());\n-        assertFalse(times(2).strictMode());\n-        assertFalse(atLeastOnce().strictMode());\n-        assertFalse(noMoreInteractions().strictMode());\n+        assertFalse(times(0).inOrderMode());\n+        assertFalse(times(2).inOrderMode());\n+        assertFalse(atLeastOnce().inOrderMode());\n+        assertFalse(noMoreInteractions().inOrderMode());\n     }\n     \n     @Test\n         assertTrue(atLeastOnce().exactNumberOfInvocationsMode());\n         \n         assertFalse(noMoreInteractions().exactNumberOfInvocationsMode());\n-        assertFalse(strict(1, asList(new Object())).exactNumberOfInvocationsMode());\n+        assertFalse(inOrder(1, asList(new Object())).exactNumberOfInvocationsMode());\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+\n+public class MissingInvocationInOrderVerifierTest extends RequiresValidState {\n+\n+    private MissingInvocationInOrderVerifier verifier;\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new MissingInvocationInOrderVerifier(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }                                                                    \n+\n+    @Test\n+    public void shouldNeverVerifyIfModeIsNotMissingInvocationInOrderMode() throws Exception {\n+        verifier.verify(null, null, atLeastOnce());\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedButNotInvoked() throws Exception {\n+        assertTrue(finderStub.firstUnverifiedChunkToReturn.isEmpty());\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        \n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportWantedDiffersFromActual() throws Exception {\n+        Invocation different = new InvocationBuilder().differentMethod().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.add(different);\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().inOrder());\n+        \n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+        assertEquals(different.toString(), reporterStub.actual);\n+        assertSame(different.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+    }\n+    \n+    class ReporterStub extends Reporter {\n+        private String wanted;\n+        private String actual;\n+        private HasStackTrace actualInvocationStackTrace;\n+\n+        @Override public void wantedButNotInvokedInOrder(String wanted) {\n+            this.wanted = wanted;\n+        }\n+        \n+        @Override public void wantedDiffersFromActualInOrder(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n+            this.wanted = wanted;\n+            this.actual = actual;\n+            this.actualInvocationStackTrace = actualInvocationStackTrace;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.internal.progress.VerificationModeImpl.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.VerificationModeBuilder;\n+\n+public class NumberOfInvocationsInOrderVerifierTest extends RequiresValidState {\n+\n+    private NumberOfInvocationsInOrderVerifier verifier;\n+    private ReporterStub reporterStub;\n+    private InvocationMatcher wanted;\n+    private LinkedList<Invocation> invocations;\n+    private InvocationsFinderStub finderStub;\n+    \n+    @Before\n+    public void setup() {\n+        reporterStub = new ReporterStub();\n+        finderStub = new InvocationsFinderStub();\n+        verifier = new NumberOfInvocationsInOrderVerifier(finderStub, reporterStub);\n+        \n+        wanted = new InvocationBuilder().toInvocationMatcher();\n+        invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));\n+    }\n+    \n+    @Test\n+    public void shouldNeverVerifyIfModeIsNotInOrder() throws Exception {\n+        verifier.verify(null, wanted, atLeastOnce());\n+    }\n+    \n+    @Test\n+    public void shouldPassIfWantedIsZeroAndFirstUnverifiedChunkIsEmpty() throws Exception {\n+        assertTrue(finderStub.firstUnverifiedChunkToReturn.isEmpty());\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).inOrder());\n+    }\n+    \n+    @Test\n+    public void shouldPassIfWantedIsZeroAndFirstUnverifiedChunkDoesNotMatch() throws Exception {\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.add(differentMethod); \n+        \n+        assertFalse(wanted.matches(differentMethod));\n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(0).inOrder());\n+    }\n+    \n+    @Test\n+    public void shouldReportTooLittleInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.addAll(asList(first, second)); \n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).inOrder());\n+        \n+        assertEquals(4, reporterStub.wantedCount);\n+        assertEquals(2, reporterStub.actualCount);\n+        assertSame(second.getStackTrace(), reporterStub.lastActualStackTrace);\n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.addAll(asList(first, second)); \n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+        \n+        assertEquals(1, reporterStub.wantedCount);\n+        assertEquals(2, reporterStub.actualCount);\n+        assertSame(second.getStackTrace(), reporterStub.firstUndesired);\n+        assertEquals(wanted.toString(), reporterStub.wanted);\n+    }\n+    \n+    @Test\n+    public void shouldMarkInvocationsAsVerified() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        finderStub.firstUnverifiedChunkToReturn.add(invocation);\n+        assertFalse(invocation.isVerifiedInOrder());\n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+        \n+        assertTrue(invocation.isVerifiedInOrder());\n+    }\n+\n+    class ReporterStub extends Reporter {\n+        private HasStackTrace lastActualStackTrace;\n+        private int actualCount;\n+        private int wantedCount;\n+        private HasStackTrace firstUndesired;\n+        private String wanted;\n+\n+        @Override public void tooLittleActualInvocationsInOrder(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualStackTrace) {\n+            this.wantedCount = wantedCount;\n+            this.actualCount = actualCount;\n+            this.wanted = wanted;\n+            this.lastActualStackTrace = lastActualStackTrace;\n+        }\n+        \n+        @Override public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n+            this.wantedCount = wantedCount;\n+            this.actualCount = actualCount;\n+            this.wanted = wanted;\n+            this.firstUndesired = firstUndesired;\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n     }\n \n     @Test\n-    public void shouldNeverVerifyWhenNotModeIsStrict() throws Exception {\n-        verifier.verify(null, null, new VerificationModeBuilder().strict());\n+    public void shouldNeverVerifyWhenNotModeIsInOrder() throws Exception {\n+        verifier.verify(null, null, new VerificationModeBuilder().inOrder());\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n     }\n     \n     @Test\n-    public void shouldVerifyStrictly() {\n-        VerificationModeImpl strictMode = new VerificationModeBuilder().strict();\n-        recorder.verify(differentMethod, strictMode);\n+    public void shouldVerifyInOrder() {\n+        VerificationModeImpl inOrderMode = new VerificationModeBuilder().inOrder();\n+        recorder.verify(differentMethod, inOrderMode);\n         \n         assertThat(verifierStub.invocations, collectionHasExactlyInOrder(simpleMethod, differentMethod.getInvocation()));\n     }\n--- a/test/org/mockitousage/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/InvalidStateDetectionTest.java\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.strictly;\n+import static org.mockito.Mockito.inOrder;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.stub;\n import static org.mockito.Mockito.stubVoid;\n  *    -on verify\n  *    -on verifyZeroInteractions\n  *    -on verifyNoMoreInteractions\n- *    -on verify on strictly\n+ *    -on verify in order\n  *    -on stub\n  *    -on stubVoid\n  */\n         detects(new OnVerify(), UnfinishedStubbingException.class);\n         \n         stub(mock.simpleMethod());\n-        detects(new OnStrictVerify(), UnfinishedStubbingException.class);\n+        detects(new OnVerifyInOrder(), UnfinishedStubbingException.class);\n         \n         stub(mock.simpleMethod());\n         detects(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);\n         detects(new OnVerify(), UnfinishedStubbingException.class);\n         \n         stubVoid(mock);\n-        detects(new OnStrictVerify(), UnfinishedStubbingException.class);\n+        detects(new OnVerifyInOrder(), UnfinishedStubbingException.class);\n         \n         stubVoid(mock);\n         detects(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);\n         detects(new OnVerify(), UnfinishedVerificationException.class);\n         \n         verify(mock);\n-        detects(new OnStrictVerify(), UnfinishedVerificationException.class);\n+        detects(new OnVerifyInOrder(), UnfinishedVerificationException.class);\n         \n         verify(mock);\n         detects(new OnVerifyZeroInteractions(), UnfinishedVerificationException.class);\n         }\n     }\n     \n-    private static class OnStrictVerify implements DetectsInvalidState {\n-        public void detect(IMethods mock) {\n-            strictly(mock).verify(mock);\n+    private static class OnVerifyInOrder implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            inOrder(mock).verify(mock);\n         }\n     }\n     \n--- a/test/org/mockitousage/InvalidUsageTest.java\n+++ b/test/org/mockitousage/InvalidUsageTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.StateResetter;\n-import org.mockito.Strictly;\n+import org.mockito.InOrder;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n \n     }\n     \n     @Test(expected=MockitoException.class)\n-    public void shouldNotCreateStrictlyWithoutMocks() {\n-        strictly();\n+    public void shouldNotCreateInOrderObjectWithoutMocks() {\n+        inOrder();\n     }\n     \n     @Test(expected=MockitoException.class)\n-    public void shouldNotStrictlyVerifyUnfamilarMocks() {\n-        Strictly strictly = strictly(mock);\n-        strictly.verify(mockTwo).simpleMethod();\n+    public void shouldNotAllowVerifyingInOrderUnfamilarMocks() {\n+        InOrder inOrder = inOrder(mock);\n+        inOrder.verify(mockTwo).simpleMethod();\n     }\n     \n     @Test(expected=MissingMethodInvocationException.class)\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n import org.mockitousage.verification.AtLeastOnceVerificationTest;\n import org.mockitousage.verification.BasicVerificationTest;\n-import org.mockitousage.verification.DescriptiveMessagesOnStrictOrderErrorsTest;\n+import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;\n import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n-import org.mockitousage.verification.StrictVerificationMixedWithOrdiraryVerificationTest;\n-import org.mockitousage.verification.StrictVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderTest;\n import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n import org.mockitousage.verification.VerificationUsingMatchersTest;\n \n                     ExactNumberOfTimesVerificationTest.class, \n                     DescriptiveMessagesWhenVerificationFailsTest.class, \n                     NoMoreInteractionsVerificationTest.class, \n-                    StrictVerificationMixedWithOrdiraryVerificationTest.class, \n-                    StrictVerificationTest.class, \n+                    VerificationInOrderMixedWithOrdiraryVerificationTest.class, \n+                    VerificationInOrderTest.class, \n                     VerificationOnMultipleMocksUsingMatchersTest.class, \n                     VerificationUsingMatchersTest.class, \n                     MatchersTest.class,\n                     MockitoTest.class,\n                     InvalidUsageTest.class,\n                     InvalidUseOfMatchersTest.class,\n-                    DescriptiveMessagesOnStrictOrderErrorsTest.class,\n+                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n                     InvalidStateDetectionTest.class,\n                     StackTraceFilteringTest.class\n                 );\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n     \n     private IMethods mock;\n     private IMethods mockTwo;\n-    private Strictly strictly;\n+    private InOrder inOrder;\n \n     @Before\n     public void setup() {\n         mock = Mockito.mock(IMethods.class);\n         mockTwo = Mockito.mock(IMethods.class);\n-        strictly = strictly(mock, mockTwo);\n+        inOrder = inOrder(mock, mockTwo);\n         \n         firstChunk();\n         secondChunk();\n     \n     @Test\n     public void shouldPointStackTraceToActualInvocation() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mock).simpleMethod(999);\n+            inOrder.verify(mock).simpleMethod(999);\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToActualInvocation() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo).simpleMethod(999);\n+            inOrder.verify(mockTwo).simpleMethod(999);\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToUnverifiedInvocation() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo, times(3)).simpleMethod(999);\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToTooManyInvocationsChunk() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo).simpleMethod(anyInt());\n+            inOrder.verify(mockTwo).simpleMethod(anyInt());\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo, times(3)).simpleMethod(anyInt());\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n         }\n     }\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n     \n     private IMethods mock;\n     private IMethods mockTwo;\n-    private Strictly strictly;\n+    private InOrder inOrder;\n \n     @Before\n     public void setup() {\n         mock = Mockito.mock(IMethods.class);\n         mockTwo = Mockito.mock(IMethods.class);\n-        strictly = strictly(mock, mockTwo);\n+        inOrder = inOrder(mock, mockTwo);\n         \n         first();\n         second();\n     \n     @Test\n     public void shouldPointStackTraceToActualInvocation() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n-        strictly.verify(mockTwo).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mock).simpleMethod(999);\n+            inOrder.verify(mock).simpleMethod(999);\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"third\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToActualInvocation() {\n-        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo).simpleMethod(999);\n+            inOrder.verify(mockTwo).simpleMethod(999);\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToUnverifiedInvocation() {\n-        strictly.verify(mock).simpleMethod(anyInt());\n-        strictly.verify(mockTwo).simpleMethod(anyInt());\n-        strictly.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n+        inOrder.verify(mock).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo, times(3)).simpleMethod(999);\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(999);\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToTooManyInvocationsChunk() {\n-        strictly.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mock).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo, times(0)).simpleMethod(anyInt());\n+            inOrder.verify(mockTwo, times(0)).simpleMethod(anyInt());\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"second\"));\n         }\n     }\n     \n     @Test\n     public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n-        strictly.verify(mock).simpleMethod(anyInt());\n-        strictly.verify(mockTwo).simpleMethod(anyInt());\n-        strictly.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mock).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).simpleMethod(anyInt());\n+        inOrder.verify(mock).simpleMethod(anyInt());\n         \n         try {\n-            strictly.verify(mockTwo, times(3)).simpleMethod(anyInt());\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourth\"));\n         }\n     }\n--- a/test/org/mockitousage/StackTraceFilteringTest.java\n+++ b/test/org/mockitousage/StackTraceFilteringTest.java\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n import org.mockito.StateResetter;\n-import org.mockito.Strictly;\n+import org.mockito.InOrder;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n public class StackTraceFilteringTest extends RequiresValidState {\n     }\n     \n     @Test\n-    public void shouldFilterStacktraceWhenStrictlyVerifying() {\n-        Strictly strictly = strictly(mock);\n+    public void shouldFilterStacktraceWhenVerifyingInOrder() {\n+        InOrder inOrder = inOrder(mock);\n         mock.oneArg(true);\n         mock.oneArg(false);\n         \n         try {\n-            strictly.verify(mock).oneArg(false); \n+            inOrder.verify(mock).oneArg(false); \n             fail();\n-        } catch (StrictVerificationFailure e) {\n-            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n+        } catch (VerifcationInOrderFailed e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenVerifyingInOrder\"));\n         }\n     }\n     \n     @Test\n-    public void shouldFilterStacktraceWhenStrictlyThrowsMockitoException() {\n+    public void shouldFilterStacktraceWhenInOrderThrowsMockitoException() {\n         try {\n-            strictly();\n+            inOrder();\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyThrowsMockitoException\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenInOrderThrowsMockitoException\"));\n         }\n     }\n     \n     @Test\n-    public void shouldFilterStacktraceWhenStrictlyVerifies() {\n+    public void shouldFilterStacktraceWhenInOrderVerifies() {\n         try {\n-            Strictly strictly = strictly(mock);\n-            strictly.verify(null);\n+            InOrder inOrder = inOrder(mock);\n+            inOrder.verify(null);\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifies\"));\n+            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenInOrderVerifies\"));\n         }\n     }\n     \n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.Strictly;\n+import org.mockito.InOrder;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n-import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n \n public class IncorectBindingPuzzleFixedTest extends RequiresValidState {\n \n     }\n \n     @Test\n-    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetectedByStrictly() throws Exception {\n+    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetectedByVerificationInOrder() throws Exception {\n         Sub sub = mock(Sub.class);\n         setMockWithDowncast(sub);\n         say(\"Hello\");\n-        Strictly strictly = strictly(mock);\n+        InOrder inOrder = inOrder(mock);\n         try {\n-            strictly.verify(sub).say(\"Hello\");\n+            inOrder.verify(sub).say(\"Hello\");\n             fail();\n-        } catch (StrictVerificationFailure e) {\n+        } catch (VerifcationInOrderFailed e) {\n             assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n             assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n         }\n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.Strictly;\n+import org.mockito.InOrder;\n \n public class MockitoSampleTest extends RequiresValidState {\n     \n     }\n     \n     @Test\n-    public void strictVerificationAndArgumentMatchers() {\n+    public void verificationInOrderAndArgumentMatchers() {\n         ArticleCalculator mockCalculator = Mockito.mock(ArticleCalculator.class);\n         ArticleDatabase mockDatabase = Mockito.mock(ArticleDatabase.class);\n         \n         \n         articleManager.updateRelatedArticlesCounters(\"Guardian\");\n \n-        Strictly strictly = strictly(mockDatabase);\n+        InOrder inOrder = inOrder(mockDatabase);\n         \n-        strictly.verify(mockDatabase, atLeastOnce()).getArticlesFor(anyString());\n-        strictly.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());\n-//        strictly.verify(mockDatabase, atLeastOnce()).save(null);\n+        inOrder.verify(mockDatabase, atLeastOnce()).getArticlesFor(anyString());\n+        inOrder.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());\n+//        inOrder.verify(mockDatabase, atLeastOnce()).save(null);\n+        \n+        //TODO review messages once more and remove commented out code\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class BasicVerificationInOrderTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        inOrder = inOrder(mockOne, mockTwo, mockThree);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrder() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyInOrderUsingAtLeastOnce() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n+        inOrder.verify(mockOne, times(0)).oneArg(false);\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockTwo, times(0)).simpleMethod(22);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        inOrder.verify(mockThree, times(0)).oneArg(false);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldFailWhenFirstMockCalledTwice() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        try {\n+            inOrder.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockCalledTwice() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        try {\n+            inOrder.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n+        inOrder.verify(mockOne, times(0)).simpleMethod(1);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n+        inOrder.verify(mockOne, times(2)).simpleMethod(1);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWanted() {\n+        inOrder.verify(mockOne, times(1)).simpleMethod(1);\n+        try {\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(2);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n+        inOrder.verify(mockOne, times(1)).simpleMethod(1);\n+        try {\n+            inOrder.verify(mockTwo, times(0)).simpleMethod(2);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            inOrder.verify(mockOne, times(0)).simpleMethod(4);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            inOrder.verify(mockOne, times(2)).simpleMethod(4);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }    \n+    \n+    /* ------------- */\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n+        inOrder.verify(mockOne).simpleMethod(100);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n+        inOrder.verify(mockOne).oneArg(true);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        try {\n+            inOrder.verify(mockTwo, times(2)).simpleMethod(-999);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n+        inOrder.verify(mockOne, times(1)).simpleMethod(1);\n+        try {\n+            inOrder.verify(mockTwo, times(2)).oneArg(true);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        try {\n+            inOrder.verify(mockOne).simpleMethod(-666);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        try {\n+            inOrder.verify(mockOne).oneArg(false);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }    \n+    \n+    /* -------------- */\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailWhenLastMethodVerifiedFirst() {\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailWhenMiddleMethodVerifiedFirst() {\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailWhenMiddleMethodVerifiedFirstInAtLeastOnceMode() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailWhenSomeMiddleMethodsAreLeftOut() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailWhenSomeMiddleMethodsInAtLeastOnceModeAreLeftOut() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=VerifcationInOrderFailed.class)\n+    public void shouldFailWhenLastMethodIsTooEarly() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnVerifyNoMoreInteractions() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    } \n+    \n+    @Test(expected=NoInteractionsWanted.class)\n+    public void shouldFailOnVerifyZeroInteractions() {\n+        verifyZeroInteractions(mockOne);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.cause.TooLittleInvocations;\n+import org.mockito.exceptions.cause.UndesiredInvocation;\n+import org.mockito.exceptions.cause.WantedDiffersFromActual;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockitousage.IMethods;\n+\n+public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends RequiresValidState {\n+    \n+    private IMethods one;\n+    private IMethods two;\n+    private IMethods three;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setup() {\n+        one = Mockito.mock(IMethods.class);\n+        two = Mockito.mock(IMethods.class);\n+        three = Mockito.mock(IMethods.class);\n+        \n+        one.simpleMethod(1);\n+        one.simpleMethod(11);\n+        two.simpleMethod(2);\n+        two.simpleMethod(2);\n+        three.simpleMethod(3);\n+        \n+        inOrder = inOrder(one, two, three);\n+    }\n+    \n+    @Test\n+    public void shouldPrintVerificationInOrderErrorAndShowBothWantedAndActual() {\n+        inOrder.verify(one, atLeastOnce()).simpleMethod(1);\n+        \n+        try {\n+            inOrder.verify(one).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            String expected = \n+                    \"\\n\" +\n+                    \"Verification in order failed\" +\n+                    \"\\n\" +\n+                    \"Wanted invocation:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(999)\"; \n+            \n+            assertEquals(expected, e.getMessage());\n+            \n+            assertEquals(e.getCause().getClass(), WantedDiffersFromActual.class);\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Actual invocation:\" +\n+                \"\\n\" +\n+                \"IMethods.simpleMethod(11)\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintMethodThatWasNotInvoked() {\n+        inOrder.verify(one).simpleMethod(1);\n+        inOrder.verify(one).simpleMethod(11);\n+        inOrder.verify(two, times(2)).simpleMethod(2);\n+        inOrder.verify(three).simpleMethod(3);\n+        try {\n+            inOrder.verify(three).simpleMethod(999);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            String actualMessage = e.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Verification in order failed\" +\n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(999)\"; \n+            assertEquals(expectedMessage, actualMessage);     \n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPrintTooManyInvocations() {\n+        inOrder.verify(one).simpleMethod(1);\n+        inOrder.verify(one).simpleMethod(11);\n+        try {\n+            inOrder.verify(two, times(1)).simpleMethod(2);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            String actualMessage = e.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Verification in order failed\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 1 time but was 2\"; \n+            assertEquals(expectedMessage, actualMessage);      \n+            \n+            assertEquals(UndesiredInvocation.class, e.getCause().getClass());\n+\n+            String expectedCause =\n+                \"\\n\" +\n+                \"Undesired invocation:\";\n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintTooLittleInvocations() {\n+        two.simpleMethod(2);\n+        \n+        inOrder.verify(one, atLeastOnce()).simpleMethod(anyInt());\n+        inOrder.verify(two, times(2)).simpleMethod(2);\n+        inOrder.verify(three, atLeastOnce()).simpleMethod(3);\n+        \n+        try {\n+            inOrder.verify(two, times(2)).simpleMethod(2);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            String actualMessage = e.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Verification in order failed\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 2 times but was 1\";\n+            assertEquals(expectedMessage, actualMessage);\n+            \n+            assertEquals(e.getCause().getClass(), TooLittleInvocations.class);\n+            \n+            String expectedCause = \n+                \"\\n\" +\n+                \"Too little invocations:\";\n+            \n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }   \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/RelaxedVerificationInOrderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockitousage.IMethods;\n+\n+/**\n+ * ignored since 'relaxed' in order verification is not implemented (too complex to bother, maybe later).\n+ */\n+@Ignore\n+@SuppressWarnings(\"unchecked\")  \n+public class RelaxedVerificationInOrderTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        inOrder = inOrder(mockOne, mockTwo, mockThree);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrderAllInvocations() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyInOrderMockTwoAndThree() {\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo, mockThree);\n+    }     \n+    \n+    @Test\n+    public void shouldVerifyInOrderMockOneAndThree() {\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyInOrderOnlyTwoInvocations() {\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrderOnlyMockTwo() {\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        verifyNoMoreInteractions(mockTwo);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMockTwoCalledOnce() {\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+    }\n+\n+    @Test\n+    public void shouldVerifyMockTwoCalledTwice() {\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMockTwoCalledAtLeastOnce() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+    }\n+    \n+    @Test(expected=InvocationDiffersFromActual.class)\n+    public void shouldFailOnWrongMethodCalledOnMockTwo() {\n+        inOrder.verify(mockTwo, atLeastOnce()).differentMethod();\n+    }\n+    \n+    @Test\n+    public void shouldAllowTimesZeroButOnlyInOrder() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockOne, times(0)).simpleMethod(1);\n+        \n+        try {\n+            verify(mockOne, times(0)).simpleMethod(1);\n+            fail();\n+        } catch (TooManyActualInvocations e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailTimesZeroInOrder() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            inOrder.verify(mockThree, times(0)).simpleMethod(3);\n+            fail();\n+        } catch (TooManyActualInvocations e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractionsWantedForMockTwo() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            verifyNoMoreInteractions(mockTwo);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoWantedZeroTimes() {\n+        try {\n+            inOrder.verify(mockTwo, times(0)).simpleMethod(2);\n+            fail();\n+        } catch(TooManyActualInvocations e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoWantedThreeTimes() {\n+        try {\n+            inOrder.verify(mockTwo, times(3)).simpleMethod(2);\n+            fail();\n+        } catch(TooLittleActualInvocations e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyLastInvocation() {\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyLastTwoInvocations() {\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySecondAndLastInvocation() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySecondAndLastInvocationWhenAtLeastOnceUsed() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastTwoInvocationsInWrongOrder() {\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        try {\n+            inOrder.verify(mockTwo).simpleMethod(2);\n+            fail();\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastAndFirstInWrongOrder() {\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        try {\n+            inOrder.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongMethodAfterLastInvocation() {\n+        inOrder.verify(mockOne).simpleMethod(4);\n+        try {\n+            inOrder.verify(mockOne).simpleMethod(999);\n+            fail();\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+}\n--- a/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n+++ b/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.Strictly;\n+import org.mockito.InOrder;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.StrictVerificationFailure;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n     }\n     \n     @Test\n-    public void shouldVerifyStrictlyAllInvocations() {\n-        Strictly strictly = strictly(mockOne, mockTwo, mockThree);\n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n-        strictly.verify(mockOne).simpleMethod(4);\n+    public void shouldVerifyAllInvocationsInOrder() {\n+        InOrder inOrder = inOrder(mockOne, mockTwo, mockThree);\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockOne).simpleMethod(4);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n     } \n     \n     @Test\n-    public void shouldVerifyStrictlyMockTwoAndThree() {\n-        Strictly strictly = strictly(mockTwo, mockThree);\n+    public void shouldVerifyInOrderMockTwoAndThree() {\n+        InOrder inOrder = inOrder(mockTwo, mockThree);\n         \n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n         verifyNoMoreInteractions(mockTwo, mockThree);\n     }     \n     \n     @Test\n-    public void shouldVerifyStrictlyMockOneAndThree() {\n-        Strictly strictly = strictly(mockOne, mockThree);\n+    public void shouldVerifyInOrderMockOneAndThree() {\n+        InOrder inOrder = inOrder(mockOne, mockThree);\n         \n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockOne).simpleMethod(4);\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockOne).simpleMethod(4);\n         verifyNoMoreInteractions(mockOne, mockThree);\n     } \n     \n     @Test\n-    public void shouldVerifyStrictlyMockOne() {\n-        Strictly strictly = strictly(mockOne);\n+    public void shouldVerifyMockOneInOrder() {\n+        InOrder inOrder = inOrder(mockOne);\n         \n-        strictly.verify(mockOne).simpleMethod(1);\n-        strictly.verify(mockOne).simpleMethod(4);\n+        inOrder.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockOne).simpleMethod(4);\n         \n         verifyNoMoreInteractions(mockOne);\n     } \n     \n     @Test\n     public void shouldFailVerificationForMockOne() {\n-        Strictly strictly = strictly(mockOne);\n+        InOrder inOrder = inOrder(mockOne);\n         \n-        strictly.verify(mockOne).simpleMethod(1);\n+        inOrder.verify(mockOne).simpleMethod(1);\n         try {\n-            strictly.verify(mockOne).differentMethod();\n+            inOrder.verify(mockOne).differentMethod();\n             fail();\n-        } catch (StrictVerificationFailure e) {}\n+        } catch (VerifcationInOrderFailed e) {}\n     } \n     \n     @Test\n     public void shouldFailVerificationForMockOneBecauseOfWrongOrder() {\n-        Strictly strictly = strictly(mockOne);\n+        InOrder inOrder = inOrder(mockOne);\n         \n         try {\n-            strictly.verify(mockOne).simpleMethod(4);\n+            inOrder.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (StrictVerificationFailure e) {}\n+        } catch (VerifcationInOrderFailed e) {}\n     } \n \n     @Test\n-    public void shouldVerifyStrictlyMockTwoWhenThreeTimesUsed() {\n-        Strictly strictly = strictly(mockTwo);\n+    public void shouldVerifyMockTwoWhenThreeTimesUsed() {\n+        InOrder inOrder = inOrder(mockTwo);\n         \n-        strictly.verify(mockTwo, times(3)).simpleMethod(2);\n+        inOrder.verify(mockTwo, times(3)).simpleMethod(2);\n         \n         verifyNoMoreInteractions(mockTwo);\n     } \n     \n     @Test\n-    public void shouldVerifyStrictlyMockTwo() {\n-        Strictly strictly = strictly(mockTwo);\n+    public void shouldVerifyMockTwo() {\n+        InOrder inOrder = inOrder(mockTwo);\n         \n-        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n         \n         verifyNoMoreInteractions(mockTwo);\n     } \n     \n     @Test\n     public void shouldFailVerificationForMockTwo() {\n-        Strictly strictly = strictly(mockTwo);\n+        InOrder inOrder = inOrder(mockTwo);\n \n         try {\n-            strictly.verify(mockTwo).simpleMethod(2);\n+            inOrder.verify(mockTwo).simpleMethod(2);\n             fail();\n-        } catch (StrictVerificationFailure e) {}\n+        } catch (VerifcationInOrderFailed e) {}\n     }\n     \n     @Test\n     public void shouldThrowNoMoreInvocationsForMockTwo() {\n-        Strictly strictly = strictly(mockTwo);\n+        InOrder inOrder = inOrder(mockTwo);\n \n         try {\n-            strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+            inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n             fail();\n-        } catch (StrictVerificationFailure e) {}\n+        } catch (VerifcationInOrderFailed e) {}\n     }\n     \n     @Test\n     public void shouldThrowTooLittleInvocationsForMockTwo() {\n-        Strictly strictly = strictly(mockTwo);\n+        InOrder inOrder = inOrder(mockTwo);\n \n         try {\n-            strictly.verify(mockTwo, times(4)).simpleMethod(2);\n+            inOrder.verify(mockTwo, times(4)).simpleMethod(2);\n             fail();\n-        } catch (StrictVerificationFailure e) {}\n+        } catch (VerifcationInOrderFailed e) {}\n     }\n     \n     @Test\n     public void shouldThrowTooManyInvocationsForMockTwo() {\n-        Strictly strictly = strictly(mockTwo);\n+        InOrder inOrder = inOrder(mockTwo);\n \n         try {\n-            strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+            inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n             fail();\n-        } catch (StrictVerificationFailure e) {}\n+        } catch (VerifcationInOrderFailed e) {}\n     }\n     \n     @Test\n     public void shouldAllowThreeTimesOnMockTwo() {\n-        Strictly strictly = strictly(mockTwo);\n+        InOrder inOrder = inOrder(mockTwo);\n \n-        strictly.verify(mockTwo, times(3)).simpleMethod(2);\n+        inOrder.verify(mockTwo, times(3)).simpleMethod(2);\n         verifyNoMoreInteractions(mockTwo);\n     }\n     \n     @Test\n     public void shouldVerifyMockTwoCompletely() {\n-        Strictly strictly = strictly(mockTwo, mockThree);\n+        InOrder inOrder = inOrder(mockTwo, mockThree);\n \n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n-        strictly.verify(mockThree).simpleMethod(3);\n-        strictly.verify(mockTwo).simpleMethod(2);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockTwo).simpleMethod(2);\n         verifyNoMoreInteractions(mockTwo, mockThree);\n     }\n     \n     @Test\n     public void shouldAllowTwoTimesOnMockTwo() {\n-        Strictly strictly = strictly(mockTwo, mockThree);\n+        InOrder inOrder = inOrder(mockTwo, mockThree);\n \n-        strictly.verify(mockTwo, times(2)).simpleMethod(2);\n+        inOrder.verify(mockTwo, times(2)).simpleMethod(2);\n         try {\n             verifyNoMoreInteractions(mockTwo);\n             fail();\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class VerificationInOrderMixedWithOrdiraryVerificationTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+\n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockThree.simpleMethod(4);\n+\n+        inOrder = inOrder(mockOne, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldMixVerificationInOrderAndOrdinaryVerification() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowOrdinarilyVerifyingMockPassedToInOrderObject() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowRedundantVerifications() {\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        \n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockThree).simpleMethod(4);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractions() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        inOrder.verify(mockThree).simpleMethod(4);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractionsOnMockVerifiedInOrder() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        inOrder.verify(mockThree).simpleMethod(3);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+    \n+    @Test\n+    public void shouldAllowOneMethodVerifiedInOrder() {\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastInvocationTooEarly() {\n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        try {\n+            inOrder.verify(mockThree).simpleMethod(4);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldScreamWhenUnfamiliarMockPassedToInOrderObject() {\n+        inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(1);\n+    } \n+    \n+    @Test\n+    public void shouldUseEqualsToVerifyMethodArguments() {\n+        mockOne = mock(IMethods.class);\n+        \n+        String textOne = \"test\";\n+        String textTwo = new String(textOne);\n+        \n+        assertEquals(textOne, textTwo);\n+        assertNotSame(textOne, textTwo);\n+        \n+        mockOne.simpleMethod(textOne);\n+        mockOne.simpleMethod(textTwo);\n+        \n+        verify(mockOne, times(2)).simpleMethod(textOne);\n+        \n+        inOrder = inOrder(mockOne);\n+        inOrder.verify(mockOne, times(2)).simpleMethod(textOne);\n+    } \n+    \n+    @Test\n+    public void shouldUseEqualsToVerifyMethodVarargs() {\n+        mockOne = mock(IMethods.class);\n+        \n+        String textOne = \"test\";\n+        String textTwo = new String(textOne);\n+        \n+        assertEquals(textOne, textTwo);\n+        assertNotSame(textOne, textTwo);\n+        \n+        mockOne.varargsObject(1, textOne, textOne);\n+        mockOne.varargsObject(1, textTwo, textTwo);\n+        \n+        verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n+        \n+        inOrder = inOrder(mockOne);\n+        inOrder.verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n+    } \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.InOrder;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class VerificationInOrderTest extends RequiresValidState {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private InOrder inOrder;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        inOrder = inOrder(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySingleMockInOrderAndNotInOrder() {\n+        mockOne = mock(IMethods.class);\n+        inOrder = inOrder(mockOne);\n+        \n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(2);\n+        \n+        verify(mockOne).simpleMethod(2);\n+        verify(mockOne).simpleMethod(1);\n+        \n+        try {\n+            inOrder.verify(mockOne).simpleMethod(2);\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    } \n+    \n+    @Test\n+    public void shouldMessagesPointToProperMethod() {\n+        mockTwo.differentMethod();\n+        mockOne.simpleMethod();\n+        \n+        try {\n+            inOrder.verify(mockOne, atLeastOnce()).differentMethod();\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            assertThat(e, messageContains(\"IMethods.differentMethod()\"));\n+            assertThat(e, causeMessageContains(\"IMethods.differentMethod()\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrderWhenTwoChunksAreEqual() {\n+        mockOne.simpleMethod();\n+        mockOne.simpleMethod();\n+        mockTwo.differentMethod();\n+        mockOne.simpleMethod();\n+        mockOne.simpleMethod();\n+        \n+        inOrder.verify(mockOne, atLeastOnce()).simpleMethod();\n+        inOrder.verify(mockTwo).differentMethod();\n+        inOrder.verify(mockOne, times(2)).simpleMethod();\n+        try {\n+            inOrder.verify(mockOne, atLeastOnce()).simpleMethod();\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrderUsingMatcher() {\n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(2);\n+        mockTwo.differentMethod();\n+        mockOne.simpleMethod(3);\n+        mockOne.simpleMethod(4);\n+        \n+        verify(mockOne, times(4)).simpleMethod(anyInt());\n+        \n+        inOrder.verify(mockOne, times(2)).simpleMethod(anyInt());\n+        inOrder.verify(mockTwo).differentMethod();\n+        inOrder.verify(mockOne, times(2)).simpleMethod(anyInt());\n+        try {\n+            inOrder.verify(mockOne, times(3)).simpleMethod(anyInt());\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {}\n+    }\n+}", "timestamp": 1200154916, "metainfo": ""}