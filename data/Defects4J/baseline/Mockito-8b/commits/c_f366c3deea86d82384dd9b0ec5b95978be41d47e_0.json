{"sha": "f366c3deea86d82384dd9b0ec5b95978be41d47e", "log": "Rename job  Prepping for extracting an interface.", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n import org.mockito.Incubating;\n import org.mockito.exceptions.base.MockitoSerializationIssue;\n import org.mockito.internal.creation.instance.InstantiatorProvider;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.creation.jmock.DefaultClassImposterizer;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.reflection.FieldSetter;\n import org.mockito.mock.MockCreationSettings;\n      * </p>\n      *\n      * <p>\n-     *     When this marker is found, {@link ClassImposterizer} methods are being used to create the mock class.\n+     *     When this marker is found, {@link org.mockito.internal.creation.jmock.DefaultClassImposterizer} methods are being used to create the mock class.\n      *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the\n      *     {@link org.mockito.internal.creation.jmock.SearchingClassLoader} that will look if this enhanced class has\n      *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer\n \n             // create the Mockito mock class before it can even be deserialized\n             //TODO SF unify creation of imposterizer, constructor code duplicated\n-            ClassImposterizer imposterizer = new ClassImposterizer(new InstantiatorProvider().getInstantiator());\n+            DefaultClassImposterizer imposterizer = new DefaultClassImposterizer(new InstantiatorProvider().getInstantiator());\n             imposterizer.setConstructorsAccessible(typeToMock, true);\n             Class<?> proxyClass = imposterizer.createProxyClass(\n                     typeToMock,\n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.creation.instance.InstantiatorProvider;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.creation.jmock.DefaultClassImposterizer;\n import org.mockito.invocation.MockHandler;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.plugins.MockMaker;\n     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n         InternalMockHandler mockitoHandler = cast(handler);\n         new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);\n-        return new ClassImposterizer(new InstantiatorProvider().getInstantiator()).imposterise(\n+        return new DefaultClassImposterizer(new InstantiatorProvider().getInstantiator()).imposterise(\n                 new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/jmock/DefaultClassImposterizer.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.jmock;\n+\n+import org.mockito.cglib.core.CodeGenerationException;\n+import org.mockito.cglib.core.NamingPolicy;\n+import org.mockito.cglib.core.Predicate;\n+import org.mockito.cglib.proxy.*;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.cglib.MockitoNamingPolicy;\n+import org.mockito.internal.creation.instance.Instantiator;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n+\n+/**\n+ * Thanks to jMock guys for this handy class that wraps all the cglib magic. \n+ */\n+public class DefaultClassImposterizer {\n+\n+    private final Instantiator instantiator;\n+\n+    public DefaultClassImposterizer(Instantiator instantiator) {\n+        this.instantiator = instantiator;\n+    }\n+    \n+    private static final NamingPolicy NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES = new MockitoNamingPolicy() {\n+        @Override\n+        public String getClassName(String prefix, String source, Object key, Predicate names) {\n+            return \"codegen.\" + super.getClassName(prefix, source, key, names);\n+        }\n+    };\n+    \n+    private static final CallbackFilter IGNORE_BRIDGE_METHODS = new CallbackFilter() {\n+        public int accept(Method method) {\n+            return method.isBridge() ? 1 : 0;\n+        }\n+    };\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n+        return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n+    }\n+    \n+    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n+        Class<Factory> proxyClass = null;\n+        Object proxyInstance = null;\n+        try {\n+            setConstructorsAccessible(mockedType, true);\n+            proxyClass = createProxyClass(mockedType, ancillaryTypes);\n+            proxyInstance = createProxy(proxyClass, interceptor);\n+            return mockedType.cast(proxyInstance);\n+        } catch (ClassCastException cce) {\n+            throw new MockitoException(join(\n+                \"ClassCastException occurred while creating the mockito proxy :\",\n+                \"  class to mock : \" + describeClass(mockedType),\n+                \"  created class : \" + describeClass(proxyClass),\n+                \"  proxy instance class : \" + describeClass(proxyInstance),\n+                \"  instance creation by : \" + instantiator.getClass().getSimpleName(),\n+                \"\",\n+                \"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)\"\n+            ), cce);\n+        } finally {\n+            setConstructorsAccessible(mockedType, false);\n+        }\n+    }\n+\n+    private static String describeClass(Class type) {\n+        return type == null? \"null\" : \"'\" + type.getCanonicalName() + \"', loaded by classloader : '\" + type.getClassLoader() + \"'\";\n+    }\n+\n+    private static String describeClass(Object instance) {\n+        return instance == null? \"null\" : describeClass(instance.getClass());\n+    }\n+\n+    //TODO this method does not belong here\n+    public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n+        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n+            constructor.setAccessible(accessible);\n+        }\n+    }\n+    \n+    public Class<Factory> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {\n+        if (mockedType == Object.class) {\n+            mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n+        }\n+        \n+        Enhancer enhancer = new Enhancer() {\n+            @Override\n+            @SuppressWarnings(\"unchecked\")\n+            protected void filterConstructors(Class sc, List constructors) {\n+                // Don't filter\n+            }\n+        };\n+        Class<?>[] allMockedTypes = prepend(mockedType, interfaces);\n+\t\tenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));\n+        enhancer.setUseFactory(true);\n+        if (mockedType.isInterface()) {\n+            enhancer.setSuperclass(Object.class);\n+            enhancer.setInterfaces(allMockedTypes);\n+        } else {\n+            enhancer.setSuperclass(mockedType);\n+            enhancer.setInterfaces(interfaces);\n+        }\n+        enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class, NoOp.class});\n+        enhancer.setCallbackFilter(IGNORE_BRIDGE_METHODS);\n+        if (mockedType.getSigners() != null) {\n+            enhancer.setNamingPolicy(NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES);\n+        } else {\n+            enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\n+        }\n+\n+        enhancer.setSerialVersionUID(42L);\n+        \n+        try {\n+            return enhancer.createClass(); \n+        } catch (CodeGenerationException e) {\n+            if (Modifier.isPrivate(mockedType.getModifiers())) {\n+                throw new MockitoException(\"\\n\"\n+                        + \"Mockito cannot mock this class: \" + mockedType \n+                        + \".\\n\"\n+                        + \"Most likely it is a private class that is not visible by Mockito\");\n+            }\n+            throw new MockitoException(\"\\n\"\n+                    + \"Mockito cannot mock this class: \" + mockedType \n+                    + \"\\n\" \n+                    + \"Mockito can only mock visible & non-final classes.\"\n+                    + \"\\n\" \n+                    + \"If you're not sure why you're getting this error, please report to the mailing list.\", e);\n+        }\n+    }\n+    \n+    private Object createProxy(Class<Factory> proxyClass, final MethodInterceptor interceptor) {\n+        Factory proxy = instantiator.newInstance(proxyClass);\n+        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n+        return proxy;\n+    }\n+    \n+    private Class<?>[] prepend(Class<?> first, Class<?>... rest) {\n+        Class<?>[] all = new Class<?>[rest.length+1];\n+        all[0] = first;\n+        System.arraycopy(rest, 0, all, 1, rest.length);\n+        return all;\n+    }\n+    \n+    public static class ClassWithSuperclassToWorkAroundCglibBug {}\n+    \n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.creation.jmock.DefaultClassImposterizerTest;\n import org.mockito.internal.handler.MockHandlerImplTest;\n import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n                     MissingInvocationCheckerTest.class,\n                     NumberOfInvocationsInOrderCheckerTest.class,\n                     MissingInvocationInOrderCheckerTest.class,\n-                    ClassImposterizerTest.class,\n+                    DefaultClassImposterizerTest.class,\n                     InvocationMatcherTest.class,\n                     InvocationsFinderTest.class,\n                     InvocationImplTest.class,\n--- /dev/null\n+++ b/test/org/mockito/internal/creation/jmock/DefaultClassImposterizerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.jmock;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.instance.ConstructorInstantiator;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class DefaultClassImposterizerTest extends TestBase {\n+\n+    DefaultClassImposterizer imposterizer = new DefaultClassImposterizer(new InstantiatorProvider().getInstantiator());\n+\n+    @Test\n+    public void shouldCreateMockFromInterface() throws Exception {\n+        SomeInterface proxy = imposterizer.imposterise(new MethodInterceptorStub(), SomeInterface.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(Object.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClass() throws Exception {\n+        ClassWithoutConstructor proxy = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithoutConstructor.class);\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertEquals(ClassWithoutConstructor.class, superClass);\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {\n+        try {\n+            new ClassWithDodgyConstructor();\n+            fail();\n+        } catch (Exception e) {}\n+        \n+        ClassWithDodgyConstructor mock = imposterizer.imposterise(new MethodInterceptorStub(), ClassWithDodgyConstructor.class);\n+        assertNotNull(mock);\n+    }\n+    \n+    @Test \n+    public void shouldMocksHaveDifferentInterceptors() throws Exception {\n+        SomeClass mockOne = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        SomeClass mockTwo = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class);\n+        \n+        Factory cglibFactoryOne = (Factory) mockOne;\n+        Factory cglibFactoryTwo = (Factory) mockTwo;\n+        \n+        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n+    }\n+    \n+    @Test\n+    public void shouldUseAnicilliaryTypes() {\n+        SomeClass mock = imposterizer.imposterise(new MethodInterceptorStub(), SomeClass.class, SomeInterface.class);\n+        \n+        assertThat(mock, is(instanceOf(SomeInterface.class)));\n+    }\n+\n+    @Test\n+    public void shouldCreateClassByConstructor() {\n+        imposterizer = new DefaultClassImposterizer(new ConstructorInstantiator());\n+        OtherClass mock = imposterizer.imposterise(new MethodInterceptorStub(), OtherClass.class);\n+        assertNotNull(mock);\n+    }\n+\n+    class SomeClass {}\n+    interface SomeInterface {}\n+    static class OtherClass {}\n+    \n+    private class ClassWithoutConstructor {}\n+\n+    private class ClassWithDodgyConstructor {\n+        public ClassWithDodgyConstructor() {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private final class MethodInterceptorStub implements MethodInterceptor {\n+\n+        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+            return null;\n+        }\n+    }\n+}", "timestamp": 1413584845, "metainfo": ""}