{"sha": "afc5bb89eaae10a75e1baaa9f3bfcb19d930f17e", "log": "Issue 399: Removed unnecessary implementation of Serializable interfaces, removed unnecessary transient fields, added proper field initialization", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n  */\n package org.mockito.internal;\n \n-import java.io.Serializable;\n import java.util.Arrays;\n import java.util.List;\n \n import org.mockito.verification.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockitoCore implements Serializable {\n+public class MockitoCore {\n \n-    private final transient Reporter reporter = new Reporter();\n-    private final transient MockUtil mockUtil = new MockUtil();\n-    private final transient MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+    private final Reporter reporter = new Reporter();\n+    private final MockUtil mockUtil = new MockUtil();\n+    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n \n     public boolean isTypeMockable(Class<?> typeToMock) {\n         return mockUtil.isTypeMockable(typeToMock);\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n-    private MockitoCore mockitoCore = new MockitoCore();\n-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n+    private transient MockitoCore mockitoCore;\n+    private transient ReturnsEmptyValues delegate;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n+\t    instantiateFieldsIfNeeded();\n         if (!mockitoCore.isTypeMockable(rawType)) {\n             return delegate.returnValueFor(rawType);\n         }\n         return getMock(invocation, returnTypeGenericMetadata);\n     }\n \n-    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n+\tprivate void instantiateFieldsIfNeeded() {\n+\t\tif (mockitoCore == null) {\n+\t\t\tmockitoCore = new MockitoCore();\n+\t\t}\n+\t\tif (delegate == null) {\n+\t\t\tdelegate = new ReturnsEmptyValues();\n+\t\t}\n+\t}\n+\n+\tprivate Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import java.io.Serializable;\n import java.lang.reflect.Modifier;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.plugins.MockMaker;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockUtil implements Serializable {\n+public class MockUtil {\n \n     private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n \n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n      * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n      * the class and its ancestors and interfaces.\n      */\n-    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport implements Serializable {\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n         private Class<?> clazz;\n \n         public FromClassGenericMetadataSupport(Class<?> clazz) {\n      * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n      * Instead use {@link ParameterizedReturnType}.\n      */\n-    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport implements Serializable {\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n         private ParameterizedType parameterizedType;\n \n         public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n     /**\n      * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n      */\n-    private static class ParameterizedReturnType extends GenericMetadataSupport implements Serializable {\n+    private static class ParameterizedReturnType extends GenericMetadataSupport {\n         private final ParameterizedType parameterizedType;\n         private final TypeVariable[] typeParameters;\n \n     /**\n      * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n      */\n-    private static class TypeVariableReturnType extends GenericMetadataSupport implements Serializable {\n+    private static class TypeVariableReturnType extends GenericMetadataSupport {\n         private final TypeVariable typeVariable;\n         private final TypeVariable[] typeParameters;\n         private Class<?> rawType;\n--- a/test/org/mockitousage/stubbing/DeepStubsSerializableTest.java\n+++ b/test/org/mockitousage/stubbing/DeepStubsSerializableTest.java\n \n public class DeepStubsSerializableTest {\n \n-    public static final boolean STUBBED_VALUE = true;\n+    public static final boolean STUBBED_BOOLEAN_VALUE = true;\n+    public static final int STUBBED_INTEGER_VALUE = 999;\n \n     @Test\n     public void should_serialize_and_deserialize_mock_created_by_deep_stubs() throws Exception {\n         // given\n         SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());\n-        when(sampleClass.getSample().isSth()).thenReturn(STUBBED_VALUE);\n+        when(sampleClass.getSample().isSth()).thenReturn(STUBBED_BOOLEAN_VALUE);\n+        when(sampleClass.getSample().getNumber()).thenReturn(STUBBED_INTEGER_VALUE);\n \n         // when\n         Object o = SimpleSerializationUtil.serializeAndBack(sampleClass);\n         // then\n         assertThat(o).isInstanceOf(SampleClass.class);\n         SampleClass deserializedSample = (SampleClass) o;\n-        assertThat(deserializedSample.getSample().isSth()).isEqualTo(STUBBED_VALUE);\n+        assertThat(deserializedSample.getSample().isSth()).isEqualTo(STUBBED_BOOLEAN_VALUE);\n+        assertThat(deserializedSample.getSample().getNumber()).isEqualTo(STUBBED_INTEGER_VALUE);\n     }\n \n \n         boolean isSth() {\n             return false;\n         }\n+\t    int getNumber(){\n+\t\t    return 100; \n+\t    }\n     }\n \n }", "timestamp": 1389350982, "metainfo": ""}