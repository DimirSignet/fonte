{"sha": "00b5122c24e3d9ab1db23743b213d620fd0d8a1d", "log": "Remove class mockable test from ClassImposterizer  ClassImposterizer is not otherwise used when a custom MockMaker is used. This change avoids calling to ClassImposterizer from the API portions of Mockito which are used with any MockMaker.", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n     private final Reporter reporter = new Reporter();\n     private final MockUtil mockUtil = new MockUtil();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n-    \n+\n+    public boolean isTypeMockable(Class<?> typeToMock) {\n+        return mockUtil.isTypeMockable(typeToMock);\n+    }\n+\n     public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n         if (!MockSettingsImpl.class.isInstance(settings)) {\n             throw new IllegalArgumentException(\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n         }\n     };\n     \n-    public boolean canImposterise(Class<?> type) {\n-        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n-    }\n-\n     public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n         return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n     }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n \n import org.mockito.MockSettings;\n import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n \n import java.io.Serializable;\n \n-import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.withSettings;\n \n /**\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n+    private MockitoCore mockitoCore = new MockitoCore();\n     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n-        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n+        if (!mockitoCore.isTypeMockable(rawType)) {\n             return delegate.returnValueFor(rawType);\n         }\n \n      * @return The mock\n      */\n     private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n-        return mock(\n+        return mockitoCore.mock(\n                 returnTypeGenericMetadata.rawType(),\n                 withSettingsUsing(returnTypeGenericMetadata)\n         );\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsMocks.java\n     }\n \n     Object returnValueFor(Class<?> clazz) {\n-        if (!ClassImposterizer.INSTANCE.canImposterise(clazz)) {\n+        if (!mockitoCore.isTypeMockable(clazz)) {\n             return null;\n         }\n         \n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.jmock.ClassImposterizer;\n \n import java.io.Serializable;\n import java.util.Collection;\n @SuppressWarnings(\"unchecked\")\n public class MockCreationValidator {\n \n-    public boolean isTypeMockable(Class<?> clz) {\n-        return ClassImposterizer.INSTANCE.canImposterise(clz);\n-    }\n+    private final MockUtil mockUtil = new MockUtil();\n \n     public void validateType(Class classToMock) {\n-        if (!isTypeMockable(classToMock)) {\n+        if (!mockUtil.isTypeMockable(classToMock)) {\n             new Reporter().cannotMockFinalClass(classToMock);\n         }\n     }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n import org.mockito.plugins.MockMaker;\n+\n+import java.lang.reflect.Modifier;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n \n     private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n+\n+    public boolean isTypeMockable(Class<?> type) {\n+      return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n+    }\n \n     public <T> T createMock(MockCreationSettings<T> settings) {\n         MockHandler mockHandler = new MockHandlerFactory().create(settings);\n--- a/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n+++ b/test/org/mockito/internal/creation/jmock/ClassImposterizerTest.java\n         assertThat(mock, is(instanceOf(SomeInterface.class)));\n     }\n \n-    final class FinalClass {}\n     class SomeClass {}\n     interface SomeInterface {}\n-\n-    @Test\n-    public void shouldKnowIfCanImposterize() throws Exception {\n-        assertFalse(ClassImposterizer.INSTANCE.canImposterise(FinalClass.class));\n-        assertFalse(ClassImposterizer.INSTANCE.canImposterise(int.class));\n-\n-        assertTrue(ClassImposterizer.INSTANCE.canImposterise(SomeClass.class));\n-        assertTrue(ClassImposterizer.INSTANCE.canImposterise(SomeInterface.class));\n-    } \n     \n     private class ClassWithoutConstructor {}\n \n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n \n         Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo(\"original\");\n     }\n+\n+    final class FinalClass {}\n+    class SomeClass {}\n+    interface SomeInterface {}\n+\n+    @Test\n+    public void shouldKnowIfTypeIsMockable() throws Exception {\n+        assertFalse(mockUtil.isTypeMockable(FinalClass.class));\n+        assertFalse(mockUtil.isTypeMockable(int.class));\n+\n+        assertTrue(mockUtil.isTypeMockable(SomeClass.class));\n+        assertTrue(mockUtil.isTypeMockable(SomeInterface.class));\n+    }\n }", "timestamp": 1354205184, "metainfo": ""}