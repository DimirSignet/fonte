{"sha": "c25ae9e2e867646ab9774e8390ecfdfdc0b1dc0c", "log": "Added a subproject that repackages cglib and asm. I need that because jarjar that was used previously for this was not good enough (didn't update the source files)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401430", "commit": "\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/AnnotationVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A visitor to visit a Java annotation. The methods of this interface must be\n+ * called in the following order: (<tt>visit<tt> | <tt>visitEnum<tt> | \n+ * <tt>visitAnnotation<tt> | <tt>visitArray<tt>)* <tt>visitEnd<tt>.\n+ *\n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public interface AnnotationVisitor {\n+\n+    /**\n+     * Visits a primitive value of the annotation.\n+     * \n+     * @param name the value name.\n+     * @param value the actual value, whose type must be {@link Byte},\n+     *        {@link Boolean}, {@link Character}, {@link Short},\n+     *        {@link Integer}, {@link Long}, {@link Float}, {@link Double},\n+     *        {@link String} or {@link Type}. This value can also be an array\n+     *        of byte, boolean, short, char, int, long, float or double values\n+     *        (this is equivalent to using {@link #visitArray visitArray} and\n+     *        visiting each array element in turn, but is more convenient).\n+     */\n+    void visit(String name, Object value);\n+\n+    /**\n+     * Visits an enumeration value of the annotation.\n+     * \n+     * @param name the value name.\n+     * @param desc the class descriptor of the enumeration class.\n+     * @param value the actual enumeration value.\n+     */\n+    void visitEnum(String name, String desc, String value);\n+\n+    /**\n+     * Visits a nested annotation value of the annotation.\n+     * \n+     * @param name the value name.\n+     * @param desc the class descriptor of the nested annotation class.\n+     * @return a visitor to visit the actual nested annotation value, or\n+     *         <tt>null</tt> if this visitor is not interested in visiting\n+     *         this nested annotation. <i>The nested annotation value must be\n+     *         fully visited before calling other methods on this annotation\n+     *         visitor</i>.\n+     */\n+    AnnotationVisitor visitAnnotation(String name, String desc);\n+\n+    /**\n+     * Visits an array value of the annotation. Note that arrays of primitive\n+     * types (such as byte, boolean, short, char, int, long, float or double)\n+     * can be passed as value to {@link #visit visit}. This is what\n+     * {@link ClassReader} does.\n+     * \n+     * @param name the value name.\n+     * @return a visitor to visit the actual array value elements, or\n+     *         <tt>null</tt> if this visitor is not interested in visiting\n+     *         these values. The 'name' parameters passed to the methods of this\n+     *         visitor are ignored. <i>All the array values must be visited\n+     *         before calling other methods on this annotation visitor</i>.\n+     */\n+    AnnotationVisitor visitArray(String name);\n+\n+    /**\n+     * Visits the end of the annotation.\n+     */\n+    void visitEnd();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/AnnotationWriter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * An {@link AnnotationVisitor} that generates annotations in bytecode form.\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+final class AnnotationWriter implements AnnotationVisitor {\n+\n+    /**\n+     * The class writer to which this annotation must be added.\n+     */\n+    private final ClassWriter cw;\n+\n+    /**\n+     * The number of values in this annotation.\n+     */\n+    private int size;\n+\n+    /**\n+     * <tt>true<tt> if values are named, <tt>false</tt> otherwise. Annotation \n+     * writers used for annotation default and annotation arrays use unnamed\n+     * values.\n+     */\n+    private final boolean named;\n+\n+    /**\n+     * The annotation values in bytecode form. This byte vector only contains\n+     * the values themselves, i.e. the number of values must be stored as a\n+     * unsigned short just before these bytes.\n+     */\n+    private final ByteVector bv;\n+\n+    /**\n+     * The byte vector to be used to store the number of values of this\n+     * annotation. See {@link #bv}.\n+     */\n+    private final ByteVector parent;\n+\n+    /**\n+     * Where the number of values of this annotation must be stored in\n+     * {@link #parent}.\n+     */\n+    private final int offset;\n+\n+    /**\n+     * Next annotation writer. This field is used to store annotation lists.\n+     */\n+    AnnotationWriter next;\n+\n+    /**\n+     * Previous annotation writer. This field is used to store annotation lists.\n+     */\n+    AnnotationWriter prev;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new {@link AnnotationWriter}.\n+     * \n+     * @param cw the class writer to which this annotation must be added.\n+     * @param named <tt>true<tt> if values are named, <tt>false</tt> otherwise.\n+     * @param bv where the annotation values must be stored.\n+     * @param parent where the number of annotation values must be stored.\n+     * @param offset where in <tt>parent</tt> the number of annotation values must \n+     *      be stored.\n+     */\n+    AnnotationWriter(\n+        final ClassWriter cw,\n+        final boolean named,\n+        final ByteVector bv,\n+        final ByteVector parent,\n+        final int offset)\n+    {\n+        this.cw = cw;\n+        this.named = named;\n+        this.bv = bv;\n+        this.parent = parent;\n+        this.offset = offset;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the AnnotationVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(final String name, final Object value) {\n+        ++size;\n+        if (named) {\n+            bv.putShort(cw.newUTF8(name));\n+        }\n+        if (value instanceof String) {\n+            bv.put12('s', cw.newUTF8((String) value));\n+        } else if (value instanceof Byte) {\n+            bv.put12('B', cw.newInteger(((Byte) value).byteValue()).index);\n+        } else if (value instanceof Boolean) {\n+            int v = ((Boolean) value).booleanValue() ? 1 : 0;\n+            bv.put12('Z', cw.newInteger(v).index);\n+        } else if (value instanceof Character) {\n+            bv.put12('C', cw.newInteger(((Character) value).charValue()).index);\n+        } else if (value instanceof Short) {\n+            bv.put12('S', cw.newInteger(((Short) value).shortValue()).index);\n+        } else if (value instanceof Type) {\n+            bv.put12('c', cw.newUTF8(((Type) value).getDescriptor()));\n+        } else if (value instanceof byte[]) {\n+            byte[] v = (byte[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('B', cw.newInteger(v[i]).index);\n+            }\n+        } else if (value instanceof boolean[]) {\n+            boolean[] v = (boolean[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('Z', cw.newInteger(v[i] ? 1 : 0).index);\n+            }\n+        } else if (value instanceof short[]) {\n+            short[] v = (short[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('S', cw.newInteger(v[i]).index);\n+            }\n+        } else if (value instanceof char[]) {\n+            char[] v = (char[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('C', cw.newInteger(v[i]).index);\n+            }\n+        } else if (value instanceof int[]) {\n+            int[] v = (int[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('I', cw.newInteger(v[i]).index);\n+            }\n+        } else if (value instanceof long[]) {\n+            long[] v = (long[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('J', cw.newLong(v[i]).index);\n+            }\n+        } else if (value instanceof float[]) {\n+            float[] v = (float[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('F', cw.newFloat(v[i]).index);\n+            }\n+        } else if (value instanceof double[]) {\n+            double[] v = (double[]) value;\n+            bv.put12('[', v.length);\n+            for (int i = 0; i < v.length; i++) {\n+                bv.put12('D', cw.newDouble(v[i]).index);\n+            }\n+        } else {\n+            Item i = cw.newConstItem(value);\n+            bv.put12(\".s.IFJDCS\".charAt(i.type), i.index);\n+        }\n+    }\n+\n+    public void visitEnum(\n+        final String name,\n+        final String desc,\n+        final String value)\n+    {\n+        ++size;\n+        if (named) {\n+            bv.putShort(cw.newUTF8(name));\n+        }\n+        bv.put12('e', cw.newUTF8(desc)).putShort(cw.newUTF8(value));\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String name,\n+        final String desc)\n+    {\n+        ++size;\n+        if (named) {\n+            bv.putShort(cw.newUTF8(name));\n+        }\n+        // write tag and type, and reserve space for values count\n+        bv.put12('@', cw.newUTF8(desc)).putShort(0);\n+        return new AnnotationWriter(cw, true, bv, bv, bv.length - 2);\n+    }\n+\n+    public AnnotationVisitor visitArray(final String name) {\n+        ++size;\n+        if (named) {\n+            bv.putShort(cw.newUTF8(name));\n+        }\n+        // write tag, and reserve space for array size\n+        bv.put12('[', 0);\n+        return new AnnotationWriter(cw, false, bv, bv, bv.length - 2);\n+    }\n+\n+    public void visitEnd() {\n+        if (parent != null) {\n+            byte[] data = parent.data;\n+            data[offset] = (byte) (size >>> 8);\n+            data[offset + 1] = (byte) size;\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the size of this annotation writer list.\n+     * \n+     * @return the size of this annotation writer list.\n+     */\n+    int getSize() {\n+        int size = 0;\n+        AnnotationWriter aw = this;\n+        while (aw != null) {\n+            size += aw.bv.length;\n+            aw = aw.next;\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Puts the annotations of this annotation writer list into the given byte\n+     * vector.\n+     * \n+     * @param out where the annotations must be put.\n+     */\n+    void put(final ByteVector out) {\n+        int n = 0;\n+        int size = 2;\n+        AnnotationWriter aw = this;\n+        AnnotationWriter last = null;\n+        while (aw != null) {\n+            ++n;\n+            size += aw.bv.length;\n+            aw.visitEnd(); // in case user forgot to call visitEnd\n+            aw.prev = last;\n+            last = aw;\n+            aw = aw.next;\n+        }\n+        out.putInt(size);\n+        out.putShort(n);\n+        aw = last;\n+        while (aw != null) {\n+            out.putByteArray(aw.bv.data, 0, aw.bv.length);\n+            aw = aw.prev;\n+        }\n+    }\n+\n+    /**\n+     * Puts the given annotation lists into the given byte vector.\n+     * \n+     * @param panns an array of annotation writer lists.\n+     * @param off index of the first annotation to be written.\n+     * @param out where the annotations must be put.\n+     */\n+    static void put(\n+        final AnnotationWriter[] panns,\n+        final int off,\n+        final ByteVector out)\n+    {\n+        int size = 1 + 2 * (panns.length - off);\n+        for (int i = off; i < panns.length; ++i) {\n+            size += panns[i] == null ? 0 : panns[i].getSize();\n+        }\n+        out.putInt(size).putByte(panns.length - off);\n+        for (int i = off; i < panns.length; ++i) {\n+            AnnotationWriter aw = panns[i];\n+            AnnotationWriter last = null;\n+            int n = 0;\n+            while (aw != null) {\n+                ++n;\n+                aw.visitEnd(); // in case user forgot to call visitEnd\n+                aw.prev = last;\n+                last = aw;\n+                aw = aw.next;\n+            }\n+            out.putShort(n);\n+            aw = last;\n+            while (aw != null) {\n+                out.putByteArray(aw.bv.data, 0, aw.bv.length);\n+                aw = aw.prev;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Attribute.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A non standard class, field, method or code attribute.\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public class Attribute {\n+\n+    /**\n+     * The type of this attribute.\n+     */\n+    public final String type;\n+\n+    /**\n+     * The raw value of this attribute, used only for unknown attributes.\n+     */\n+    byte[] value;\n+\n+    /**\n+     * The next attribute in this attribute list. May be <tt>null</tt>.\n+     */\n+    Attribute next;\n+\n+    /**\n+     * Constructs a new empty attribute.\n+     * \n+     * @param type the type of the attribute.\n+     */\n+    protected Attribute(final String type) {\n+        this.type = type;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this type of attribute is unknown. The default\n+     * implementation of this method always returns <tt>true</tt>.\n+     * \n+     * @return <tt>true</tt> if this type of attribute is unknown.\n+     */\n+    public boolean isUnknown() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this type of attribute is a code attribute.\n+     * \n+     * @return <tt>true</tt> if this type of attribute is a code attribute.\n+     */\n+    public boolean isCodeAttribute() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the labels corresponding to this attribute.\n+     * \n+     * @return the labels corresponding to this attribute, or <tt>null</tt> if\n+     *         this attribute is not a code attribute that contains labels.\n+     */\n+    protected Label[] getLabels() {\n+        return null;\n+    }\n+\n+    /**\n+     * Reads a {@link #type type} attribute. This method must return a <i>new</i>\n+     * {@link Attribute} object, of type {@link #type type}, corresponding to\n+     * the <tt>len</tt> bytes starting at the given offset, in the given class\n+     * reader.\n+     * \n+     * @param cr the class that contains the attribute to be read.\n+     * @param off index of the first byte of the attribute's content in {@link\n+     *        ClassReader#b cr.b}. The 6 attribute header bytes, containing the\n+     *        type and the length of the attribute, are not taken into account\n+     *        here.\n+     * @param len the length of the attribute's content.\n+     * @param buf buffer to be used to call\n+     *        {@link ClassReader#readUTF8 readUTF8},\n+     *        {@link ClassReader#readClass(int,char[]) readClass} or\n+     *        {@link ClassReader#readConst readConst}.\n+     * @param codeOff index of the first byte of code's attribute content in\n+     *        {@link ClassReader#b cr.b}, or -1 if the attribute to be read is\n+     *        not a code attribute. The 6 attribute header bytes, containing the\n+     *        type and the length of the attribute, are not taken into account\n+     *        here.\n+     * @param labels the labels of the method's code, or <tt>null</tt> if the\n+     *        attribute to be read is not a code attribute.\n+     * @return a <i>new</i> {@link Attribute} object corresponding to the given\n+     *         bytes.\n+     */\n+    protected Attribute read(\n+        final ClassReader cr,\n+        final int off,\n+        final int len,\n+        final char[] buf,\n+        final int codeOff,\n+        final Label[] labels)\n+    {\n+        Attribute attr = new Attribute(type);\n+        attr.value = new byte[len];\n+        System.arraycopy(cr.b, off, attr.value, 0, len);\n+        return attr;\n+    }\n+\n+    /**\n+     * Returns the byte array form of this attribute.\n+     * \n+     * @param cw the class to which this attribute must be added. This parameter\n+     *        can be used to add to the constant pool of this class the items\n+     *        that corresponds to this attribute.\n+     * @param code the bytecode of the method corresponding to this code\n+     *        attribute, or <tt>null</tt> if this attribute is not a code\n+     *        attributes.\n+     * @param len the length of the bytecode of the method corresponding to this\n+     *        code attribute, or <tt>null</tt> if this attribute is not a code\n+     *        attribute.\n+     * @param maxStack the maximum stack size of the method corresponding to\n+     *        this code attribute, or -1 if this attribute is not a code\n+     *        attribute.\n+     * @param maxLocals the maximum number of local variables of the method\n+     *        corresponding to this code attribute, or -1 if this attribute is\n+     *        not a code attribute.\n+     * @return the byte array form of this attribute.\n+     */\n+    protected ByteVector write(\n+        final ClassWriter cw,\n+        final byte[] code,\n+        final int len,\n+        final int maxStack,\n+        final int maxLocals)\n+    {\n+        ByteVector v = new ByteVector();\n+        v.data = value;\n+        v.length = value.length;\n+        return v;\n+    }\n+\n+    /**\n+     * Returns the length of the attribute list that begins with this attribute.\n+     * \n+     * @return the length of the attribute list that begins with this attribute.\n+     */\n+    final int getCount() {\n+        int count = 0;\n+        Attribute attr = this;\n+        while (attr != null) {\n+            count += 1;\n+            attr = attr.next;\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Returns the size of all the attributes in this attribute list.\n+     * \n+     * @param cw the class writer to be used to convert the attributes into byte\n+     *        arrays, with the {@link #write write} method.\n+     * @param code the bytecode of the method corresponding to these code\n+     *        attributes, or <tt>null</tt> if these attributes are not code\n+     *        attributes.\n+     * @param len the length of the bytecode of the method corresponding to\n+     *        these code attributes, or <tt>null</tt> if these attributes are\n+     *        not code attributes.\n+     * @param maxStack the maximum stack size of the method corresponding to\n+     *        these code attributes, or -1 if these attributes are not code\n+     *        attributes.\n+     * @param maxLocals the maximum number of local variables of the method\n+     *        corresponding to these code attributes, or -1 if these attributes\n+     *        are not code attributes.\n+     * @return the size of all the attributes in this attribute list. This size\n+     *         includes the size of the attribute headers.\n+     */\n+    final int getSize(\n+        final ClassWriter cw,\n+        final byte[] code,\n+        final int len,\n+        final int maxStack,\n+        final int maxLocals)\n+    {\n+        Attribute attr = this;\n+        int size = 0;\n+        while (attr != null) {\n+            cw.newUTF8(attr.type);\n+            size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;\n+            attr = attr.next;\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Writes all the attributes of this attribute list in the given byte\n+     * vector.\n+     * \n+     * @param cw the class writer to be used to convert the attributes into byte\n+     *        arrays, with the {@link #write write} method.\n+     * @param code the bytecode of the method corresponding to these code\n+     *        attributes, or <tt>null</tt> if these attributes are not code\n+     *        attributes.\n+     * @param len the length of the bytecode of the method corresponding to\n+     *        these code attributes, or <tt>null</tt> if these attributes are\n+     *        not code attributes.\n+     * @param maxStack the maximum stack size of the method corresponding to\n+     *        these code attributes, or -1 if these attributes are not code\n+     *        attributes.\n+     * @param maxLocals the maximum number of local variables of the method\n+     *        corresponding to these code attributes, or -1 if these attributes\n+     *        are not code attributes.\n+     * @param out where the attributes must be written.\n+     */\n+    final void put(\n+        final ClassWriter cw,\n+        final byte[] code,\n+        final int len,\n+        final int maxStack,\n+        final int maxLocals,\n+        final ByteVector out)\n+    {\n+        Attribute attr = this;\n+        while (attr != null) {\n+            ByteVector b = attr.write(cw, code, len, maxStack, maxLocals);\n+            out.putShort(cw.newUTF8(attr.type)).putInt(b.length);\n+            out.putByteArray(b.data, 0, b.length);\n+            attr = attr.next;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/ByteVector.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A dynamically extensible vector of bytes. This class is roughly equivalent to\n+ * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ByteVector {\n+\n+    /**\n+     * The content of this vector.\n+     */\n+    byte[] data;\n+\n+    /**\n+     * Actual number of bytes in this vector.\n+     */\n+    int length;\n+\n+    /**\n+     * Constructs a new {@link ByteVector ByteVector} with a default initial\n+     * size.\n+     */\n+    public ByteVector() {\n+        data = new byte[64];\n+    }\n+\n+    /**\n+     * Constructs a new {@link ByteVector ByteVector} with the given initial\n+     * size.\n+     * \n+     * @param initialSize the initial size of the byte vector to be constructed.\n+     */\n+    public ByteVector(final int initialSize) {\n+        data = new byte[initialSize];\n+    }\n+\n+    /**\n+     * Puts a byte into this byte vector. The byte vector is automatically\n+     * enlarged if necessary.\n+     * \n+     * @param b a byte.\n+     * @return this byte vector.\n+     */\n+    public ByteVector putByte(final int b) {\n+        int length = this.length;\n+        if (length + 1 > data.length) {\n+            enlarge(1);\n+        }\n+        data[length++] = (byte) b;\n+        this.length = length;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts two bytes into this byte vector. The byte vector is automatically\n+     * enlarged if necessary.\n+     * \n+     * @param b1 a byte.\n+     * @param b2 another byte.\n+     * @return this byte vector.\n+     */\n+    ByteVector put11(final int b1, final int b2) {\n+        int length = this.length;\n+        if (length + 2 > data.length) {\n+            enlarge(2);\n+        }\n+        byte[] data = this.data;\n+        data[length++] = (byte) b1;\n+        data[length++] = (byte) b2;\n+        this.length = length;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts a short into this byte vector. The byte vector is automatically\n+     * enlarged if necessary.\n+     * \n+     * @param s a short.\n+     * @return this byte vector.\n+     */\n+    public ByteVector putShort(final int s) {\n+        int length = this.length;\n+        if (length + 2 > data.length) {\n+            enlarge(2);\n+        }\n+        byte[] data = this.data;\n+        data[length++] = (byte) (s >>> 8);\n+        data[length++] = (byte) s;\n+        this.length = length;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts a byte and a short into this byte vector. The byte vector is\n+     * automatically enlarged if necessary.\n+     * \n+     * @param b a byte.\n+     * @param s a short.\n+     * @return this byte vector.\n+     */\n+    ByteVector put12(final int b, final int s) {\n+        int length = this.length;\n+        if (length + 3 > data.length) {\n+            enlarge(3);\n+        }\n+        byte[] data = this.data;\n+        data[length++] = (byte) b;\n+        data[length++] = (byte) (s >>> 8);\n+        data[length++] = (byte) s;\n+        this.length = length;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts an int into this byte vector. The byte vector is automatically\n+     * enlarged if necessary.\n+     * \n+     * @param i an int.\n+     * @return this byte vector.\n+     */\n+    public ByteVector putInt(final int i) {\n+        int length = this.length;\n+        if (length + 4 > data.length) {\n+            enlarge(4);\n+        }\n+        byte[] data = this.data;\n+        data[length++] = (byte) (i >>> 24);\n+        data[length++] = (byte) (i >>> 16);\n+        data[length++] = (byte) (i >>> 8);\n+        data[length++] = (byte) i;\n+        this.length = length;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts a long into this byte vector. The byte vector is automatically\n+     * enlarged if necessary.\n+     * \n+     * @param l a long.\n+     * @return this byte vector.\n+     */\n+    public ByteVector putLong(final long l) {\n+        int length = this.length;\n+        if (length + 8 > data.length) {\n+            enlarge(8);\n+        }\n+        byte[] data = this.data;\n+        int i = (int) (l >>> 32);\n+        data[length++] = (byte) (i >>> 24);\n+        data[length++] = (byte) (i >>> 16);\n+        data[length++] = (byte) (i >>> 8);\n+        data[length++] = (byte) i;\n+        i = (int) l;\n+        data[length++] = (byte) (i >>> 24);\n+        data[length++] = (byte) (i >>> 16);\n+        data[length++] = (byte) (i >>> 8);\n+        data[length++] = (byte) i;\n+        this.length = length;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts an UTF8 string into this byte vector. The byte vector is\n+     * automatically enlarged if necessary.\n+     * \n+     * @param s a String.\n+     * @return this byte vector.\n+     */\n+    public ByteVector putUTF8(final String s) {\n+        int charLength = s.length();\n+        if (length + 2 + charLength > data.length) {\n+            enlarge(2 + charLength);\n+        }\n+        int len = length;\n+        byte[] data = this.data;\n+        // optimistic algorithm: instead of computing the byte length and then\n+        // serializing the string (which requires two loops), we assume the byte\n+        // length is equal to char length (which is the most frequent case), and\n+        // we start serializing the string right away. During the serialization,\n+        // if we find that this assumption is wrong, we continue with the\n+        // general method.\n+        data[len++] = (byte) (charLength >>> 8);\n+        data[len++] = (byte) charLength;\n+        for (int i = 0; i < charLength; ++i) {\n+            char c = s.charAt(i);\n+            if (c >= '\\001' && c <= '\\177') {\n+                data[len++] = (byte) c;\n+            } else {\n+                int byteLength = i;\n+                for (int j = i; j < charLength; ++j) {\n+                    c = s.charAt(j);\n+                    if (c >= '\\001' && c <= '\\177') {\n+                        byteLength++;\n+                    } else if (c > '\\u07FF') {\n+                        byteLength += 3;\n+                    } else {\n+                        byteLength += 2;\n+                    }\n+                }\n+                data[length] = (byte) (byteLength >>> 8);\n+                data[length + 1] = (byte) byteLength;\n+                if (length + 2 + byteLength > data.length) {\n+                    length = len;\n+                    enlarge(2 + byteLength);\n+                    data = this.data;\n+                }\n+                for (int j = i; j < charLength; ++j) {\n+                    c = s.charAt(j);\n+                    if (c >= '\\001' && c <= '\\177') {\n+                        data[len++] = (byte) c;\n+                    } else if (c > '\\u07FF') {\n+                        data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\n+                        data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\n+                        data[len++] = (byte) (0x80 | c & 0x3F);\n+                    } else {\n+                        data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\n+                        data[len++] = (byte) (0x80 | c & 0x3F);\n+                    }\n+                }\n+                break;\n+            }\n+        }\n+        length = len;\n+        return this;\n+    }\n+\n+    /**\n+     * Puts an array of bytes into this byte vector. The byte vector is\n+     * automatically enlarged if necessary.\n+     * \n+     * @param b an array of bytes. May be <tt>null</tt> to put <tt>len</tt>\n+     *        null bytes into this byte vector.\n+     * @param off index of the fist byte of b that must be copied.\n+     * @param len number of bytes of b that must be copied.\n+     * @return this byte vector.\n+     */\n+    public ByteVector putByteArray(final byte[] b, final int off, final int len)\n+    {\n+        if (length + len > data.length) {\n+            enlarge(len);\n+        }\n+        if (b != null) {\n+            System.arraycopy(b, off, data, length, len);\n+        }\n+        length += len;\n+        return this;\n+    }\n+\n+    /**\n+     * Enlarge this byte vector so that it can receive n more bytes.\n+     * \n+     * @param size number of additional bytes that this byte vector should be\n+     *        able to receive.\n+     */\n+    private void enlarge(final int size) {\n+        int length1 = 2 * data.length;\n+        int length2 = length + size;\n+        byte[] newData = new byte[length1 > length2 ? length1 : length2];\n+        System.arraycopy(data, 0, newData, 0, length);\n+        data = newData;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/ClassAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * An empty {@link ClassVisitor} that delegates to another {@link ClassVisitor}.\n+ * This class can be used as a super class to quickly implement usefull class\n+ * adapter classes, just by overriding the necessary methods.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ClassAdapter implements ClassVisitor {\n+\n+    /**\n+     * The {@link ClassVisitor} to which this adapter delegates calls.\n+     */\n+    protected ClassVisitor cv;\n+\n+    /**\n+     * Constructs a new {@link ClassAdapter} object.\n+     * \n+     * @param cv the class visitor to which this adapter must delegate calls.\n+     */\n+    public ClassAdapter(final ClassVisitor cv) {\n+        this.cv = cv;\n+    }\n+\n+    public void visit(\n+        final int version,\n+        final int access,\n+        final String name,\n+        final String signature,\n+        final String superName,\n+        final String[] interfaces)\n+    {\n+        cv.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    public void visitSource(final String source, final String debug) {\n+        cv.visitSource(source, debug);\n+    }\n+\n+    public void visitOuterClass(\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        cv.visitOuterClass(owner, name, desc);\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        return cv.visitAnnotation(desc, visible);\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        cv.visitAttribute(attr);\n+    }\n+\n+    public void visitInnerClass(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        cv.visitInnerClass(name, outerName, innerName, access);\n+    }\n+\n+    public FieldVisitor visitField(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        return cv.visitField(access, name, desc, signature, value);\n+    }\n+\n+    public MethodVisitor visitMethod(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        return cv.visitMethod(access, name, desc, signature, exceptions);\n+    }\n+\n+    public void visitEnd() {\n+        cv.visitEnd();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/ClassReader.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+ * A Java class parser to make a {@link ClassVisitor} visit an existing class.\n+ * This class parses a byte array conforming to the Java class file format and\n+ * calls the appropriate visit methods of a given class visitor for each field,\n+ * method and bytecode instruction encountered.\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public class ClassReader {\n+\n+    /**\n+     * True to enable signatures support.\n+     */\n+    static final boolean SIGNATURES = true;\n+    \n+    /**\n+     * True to enable annotations support.\n+     */\n+    static final boolean ANNOTATIONS = true;\n+    \n+    /**\n+     * True to enable stack map frames support.\n+     */\n+    static final boolean FRAMES = true;\n+    \n+    /**\n+     * True to enable bytecode writing support.\n+     */\n+    static final boolean WRITER = true;\n+    \n+    /**\n+     * True to enable JSR_W and GOTO_W support.\n+     */\n+    static final boolean RESIZE = true;\n+    \n+    /**\n+     * Flag to skip method code. If this class is set <code>CODE</code>\n+     * attribute won't be visited. This can be used, for example, to retrieve\n+     * annotations for methods and method parameters.\n+     */\n+    public static final int SKIP_CODE = 1;\n+\n+    /**\n+     * Flag to skip the debug information in the class. If this flag is set the\n+     * debug information of the class is not visited, i.e. the\n+     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and\n+     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be\n+     * called.\n+     */\n+    public static final int SKIP_DEBUG = 2;\n+\n+    /**\n+     * Flag to skip the stack map frames in the class. If this flag is set the\n+     * stack map frames of the class is not visited, i.e. the\n+     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.\n+     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is\n+     * used: it avoids visiting frames that will be ignored and recomputed from\n+     * scratch in the class writer.\n+     */\n+    public static final int SKIP_FRAMES = 4;\n+\n+    /**\n+     * Flag to expand the stack map frames. By default stack map frames are\n+     * visited in their original format (i.e. \"expanded\" for classes whose\n+     * version is less than V1_6, and \"compressed\" for the other classes). If\n+     * this flag is set, stack map frames are always visited in expanded format\n+     * (this option adds a decompression/recompression step in ClassReader and\n+     * ClassWriter which degrades performances quite a lot).\n+     */\n+    public static final int EXPAND_FRAMES = 8;\n+\n+    /**\n+     * The class to be parsed. <i>The content of this array must not be\n+     * modified. This field is intended for {@link Attribute} sub classes, and\n+     * is normally not needed by class generators or adapters.</i>\n+     */\n+    public final byte[] b;\n+\n+    /**\n+     * The start index of each constant pool item in {@link #b b}, plus one.\n+     * The one byte offset skips the constant pool item tag that indicates its\n+     * type.\n+     */\n+    private final int[] items;\n+\n+    /**\n+     * The String objects corresponding to the CONSTANT_Utf8 items. This cache\n+     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,\n+     * which GREATLY improves performances (by a factor 2 to 3). This caching\n+     * strategy could be extended to all constant pool items, but its benefit\n+     * would not be so great for these items (because they are much less\n+     * expensive to parse than CONSTANT_Utf8 items).\n+     */\n+    private final String[] strings;\n+\n+    /**\n+     * Maximum length of the strings contained in the constant pool of the\n+     * class.\n+     */\n+    private final int maxStringLength;\n+\n+    /**\n+     * Start index of the class header information (access, name...) in\n+     * {@link #b b}.\n+     */\n+    public final int header;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructors\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new {@link ClassReader} object.\n+     * \n+     * @param b the bytecode of the class to be read.\n+     */\n+    public ClassReader(final byte[] b) {\n+        this(b, 0, b.length);\n+    }\n+\n+    /**\n+     * Constructs a new {@link ClassReader} object.\n+     * \n+     * @param b the bytecode of the class to be read.\n+     * @param off the start offset of the class data.\n+     * @param len the length of the class data.\n+     */\n+    public ClassReader(final byte[] b, final int off, final int len) {\n+        this.b = b;\n+        // parses the constant pool\n+        items = new int[readUnsignedShort(off + 8)];\n+        int n = items.length;\n+        strings = new String[n];\n+        int max = 0;\n+        int index = off + 10;\n+        for (int i = 1; i < n; ++i) {\n+            items[i] = index + 1;\n+            int size;\n+            switch (b[index]) {\n+                case ClassWriter.FIELD:\n+                case ClassWriter.METH:\n+                case ClassWriter.IMETH:\n+                case ClassWriter.INT:\n+                case ClassWriter.FLOAT:\n+                case ClassWriter.NAME_TYPE:\n+                    size = 5;\n+                    break;\n+                case ClassWriter.LONG:\n+                case ClassWriter.DOUBLE:\n+                    size = 9;\n+                    ++i;\n+                    break;\n+                case ClassWriter.UTF8:\n+                    size = 3 + readUnsignedShort(index + 1);\n+                    if (size > max) {\n+                        max = size;\n+                    }\n+                    break;\n+                // case ClassWriter.CLASS:\n+                // case ClassWriter.STR:\n+                default:\n+                    size = 3;\n+                    break;\n+            }\n+            index += size;\n+        }\n+        maxStringLength = max;\n+        // the class header information starts just after the constant pool\n+        header = index;\n+    }\n+\n+    /**\n+     * Returns the class's access flags (see {@link Opcodes}). This value may\n+     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5\n+     * and those flags are represented by attributes.\n+     * \n+     * @return the class access flags\n+     * \n+     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n+     */\n+    public int getAccess() {\n+        return readUnsignedShort(header);\n+    }\n+\n+    /**\n+     * Returns the internal name of the class (see\n+     * {@link Type#getInternalName() getInternalName}).\n+     * \n+     * @return the internal class name\n+     * \n+     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n+     */\n+    public String getClassName() {\n+        return readClass(header + 2, new char[maxStringLength]);\n+    }\n+\n+    /**\n+     * Returns the internal of name of the super class (see\n+     * {@link Type#getInternalName() getInternalName}). For interfaces, the\n+     * super class is {@link Object}.\n+     * \n+     * @return the internal name of super class, or <tt>null</tt> for\n+     *         {@link Object} class.\n+     * \n+     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n+     */\n+    public String getSuperName() {\n+        int n = items[readUnsignedShort(header + 4)];\n+        return n == 0 ? null : readUTF8(n, new char[maxStringLength]);\n+    }\n+\n+    /**\n+     * Returns the internal names of the class's interfaces (see\n+     * {@link Type#getInternalName() getInternalName}).\n+     * \n+     * @return the array of internal names for all implemented interfaces or\n+     *         <tt>null</tt>.\n+     * \n+     * @see ClassVisitor#visit(int, int, String, String, String, String[])\n+     */\n+    public String[] getInterfaces() {\n+        int index = header + 6;\n+        int n = readUnsignedShort(index);\n+        String[] interfaces = new String[n];\n+        if (n > 0) {\n+            char[] buf = new char[maxStringLength];\n+            for (int i = 0; i < n; ++i) {\n+                index += 2;\n+                interfaces[i] = readClass(index, buf);\n+            }\n+        }\n+        return interfaces;\n+    }\n+\n+    /**\n+     * Copies the constant pool data into the given {@link ClassWriter}. Should\n+     * be called before the {@link #accept(ClassVisitor,int)} method.\n+     * \n+     * @param classWriter the {@link ClassWriter} to copy constant pool into.\n+     */\n+    void copyPool(final ClassWriter classWriter) {\n+        char[] buf = new char[maxStringLength];\n+        int ll = items.length;\n+        Item[] items2 = new Item[ll];\n+        for (int i = 1; i < ll; i++) {\n+            int index = items[i];\n+            int tag = b[index - 1];\n+            Item item = new Item(i);\n+            int nameType;\n+            switch (tag) {\n+                case ClassWriter.FIELD:\n+                case ClassWriter.METH:\n+                case ClassWriter.IMETH:\n+                    nameType = items[readUnsignedShort(index + 2)];\n+                    item.set(tag,\n+                            readClass(index, buf),\n+                            readUTF8(nameType, buf),\n+                            readUTF8(nameType + 2, buf));\n+                    break;\n+\n+                case ClassWriter.INT:\n+                    item.set(readInt(index));\n+                    break;\n+\n+                case ClassWriter.FLOAT:\n+                    item.set(Float.intBitsToFloat(readInt(index)));\n+                    break;\n+\n+                case ClassWriter.NAME_TYPE:\n+                    item.set(tag,\n+                            readUTF8(index, buf),\n+                            readUTF8(index + 2, buf),\n+                            null);\n+                    break;\n+\n+                case ClassWriter.LONG:\n+                    item.set(readLong(index));\n+                    ++i;\n+                    break;\n+\n+                case ClassWriter.DOUBLE:\n+                    item.set(Double.longBitsToDouble(readLong(index)));\n+                    ++i;\n+                    break;\n+\n+                case ClassWriter.UTF8: {\n+                    String s = strings[i];\n+                    if (s == null) {\n+                        index = items[i];\n+                        s = strings[i] = readUTF(index + 2,\n+                                readUnsignedShort(index),\n+                                buf);\n+                    }\n+                    item.set(tag, s, null, null);\n+                }\n+                    break;\n+\n+                // case ClassWriter.STR:\n+                // case ClassWriter.CLASS:\n+                default:\n+                    item.set(tag, readUTF8(index, buf), null, null);\n+                    break;\n+            }\n+\n+            int index2 = item.hashCode % items2.length;\n+            item.next = items2[index2];\n+            items2[index2] = item;\n+        }\n+\n+        int off = items[1] - 1;\n+        classWriter.pool.putByteArray(b, off, header - off);\n+        classWriter.items = items2;\n+        classWriter.threshold = (int) (0.75d * ll);\n+        classWriter.index = ll;\n+    }\n+\n+    /**\n+     * Constructs a new {@link ClassReader} object.\n+     * \n+     * @param is an input stream from which to read the class.\n+     * @throws IOException if a problem occurs during reading.\n+     */\n+    public ClassReader(final InputStream is) throws IOException {\n+        this(readClass(is));\n+    }\n+\n+    /**\n+     * Constructs a new {@link ClassReader} object.\n+     * \n+     * @param name the fully qualified name of the class to be read.\n+     * @throws IOException if an exception occurs during reading.\n+     */\n+    public ClassReader(final String name) throws IOException {\n+        this(ClassLoader.getSystemResourceAsStream(name.replace('.', '/')\n+                + \".class\"));\n+    }\n+\n+    /**\n+     * Reads the bytecode of a class.\n+     * \n+     * @param is an input stream from which to read the class.\n+     * @return the bytecode read from the given input stream.\n+     * @throws IOException if a problem occurs during reading.\n+     */\n+    private static byte[] readClass(final InputStream is) throws IOException {\n+        if (is == null) {\n+            throw new IOException(\"Class not found\");\n+        }\n+        byte[] b = new byte[is.available()];\n+        int len = 0;\n+        while (true) {\n+            int n = is.read(b, len, b.length - len);\n+            if (n == -1) {\n+                if (len < b.length) {\n+                    byte[] c = new byte[len];\n+                    System.arraycopy(b, 0, c, 0, len);\n+                    b = c;\n+                }\n+                return b;\n+            }\n+            len += n;\n+            if (len == b.length) {\n+                byte[] c = new byte[b.length + 1000];\n+                System.arraycopy(b, 0, c, 0, len);\n+                b = c;\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Public methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n+     * This class is the one specified in the constructor (see\n+     * {@link #ClassReader(byte[]) ClassReader}).\n+     * \n+     * @param classVisitor the visitor that must visit this class.\n+     * @param flags option flags that can be used to modify the default behavior\n+     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n+     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n+     */\n+    public void accept(final ClassVisitor classVisitor, final int flags) {\n+        accept(classVisitor, new Attribute[0], flags);\n+    }\n+\n+    /**\n+     * Makes the given visitor visit the Java class of this {@link ClassReader}.\n+     * This class is the one specified in the constructor (see\n+     * {@link #ClassReader(byte[]) ClassReader}).\n+     * \n+     * @param classVisitor the visitor that must visit this class.\n+     * @param attrs prototypes of the attributes that must be parsed during the\n+     *        visit of the class. Any attribute whose type is not equal to the\n+     *        type of one the prototypes will not be parsed: its byte array\n+     *        value will be passed unchanged to the ClassWriter. <i>This may\n+     *        corrupt it if this value contains references to the constant pool,\n+     *        or has syntactic or semantic links with a class element that has\n+     *        been transformed by a class adapter between the reader and the\n+     *        writer</i>.\n+     * @param flags option flags that can be used to modify the default behavior\n+     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n+     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n+     */\n+    public void accept(\n+        final ClassVisitor classVisitor,\n+        final Attribute[] attrs,\n+        final int flags)\n+    {\n+        byte[] b = this.b; // the bytecode array\n+        char[] c = new char[maxStringLength]; // buffer used to read strings\n+        int i, j, k; // loop variables\n+        int u, v, w; // indexes in b\n+        Attribute attr;\n+\n+        int access;\n+        String name;\n+        String desc;\n+        String attrName;\n+        String signature;\n+        int anns = 0;\n+        int ianns = 0;\n+        Attribute cattrs = null;\n+\n+        // visits the header\n+        u = header;\n+        access = readUnsignedShort(u);\n+        name = readClass(u + 2, c);\n+        v = items[readUnsignedShort(u + 4)];\n+        String superClassName = v == 0 ? null : readUTF8(v, c);\n+        String[] implementedItfs = new String[readUnsignedShort(u + 6)];\n+        w = 0;\n+        u += 8;\n+        for (i = 0; i < implementedItfs.length; ++i) {\n+            implementedItfs[i] = readClass(u, c);\n+            u += 2;\n+        }\n+\n+        boolean skipCode = (flags & SKIP_CODE) != 0;\n+        boolean skipDebug = (flags & SKIP_DEBUG) != 0;\n+        boolean unzip = (flags & EXPAND_FRAMES) != 0;\n+\n+        // skips fields and methods\n+        v = u;\n+        i = readUnsignedShort(v);\n+        v += 2;\n+        for (; i > 0; --i) {\n+            j = readUnsignedShort(v + 6);\n+            v += 8;\n+            for (; j > 0; --j) {\n+                v += 6 + readInt(v + 2);\n+            }\n+        }\n+        i = readUnsignedShort(v);\n+        v += 2;\n+        for (; i > 0; --i) {\n+            j = readUnsignedShort(v + 6);\n+            v += 8;\n+            for (; j > 0; --j) {\n+                v += 6 + readInt(v + 2);\n+            }\n+        }\n+        // reads the class's attributes\n+        signature = null;\n+        String sourceFile = null;\n+        String sourceDebug = null;\n+        String enclosingOwner = null;\n+        String enclosingName = null;\n+        String enclosingDesc = null;\n+\n+        i = readUnsignedShort(v);\n+        v += 2;\n+        for (; i > 0; --i) {\n+            attrName = readUTF8(v, c);\n+            // tests are sorted in decreasing frequency order\n+            // (based on frequencies observed on typical classes)\n+            if (\"SourceFile\".equals(attrName)) {\n+                sourceFile = readUTF8(v + 6, c);\n+            } else if (\"InnerClasses\".equals(attrName)) {\n+                w = v + 6;\n+            } else if (\"EnclosingMethod\".equals(attrName)) {\n+                enclosingOwner = readClass(v + 6, c);\n+                int item = readUnsignedShort(v + 8);\n+                if (item != 0) {\n+                    enclosingName = readUTF8(items[item], c);\n+                    enclosingDesc = readUTF8(items[item] + 2, c);\n+                }\n+            } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n+                signature = readUTF8(v + 6, c);\n+            } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n+                anns = v + 6;\n+            } else if (\"Deprecated\".equals(attrName)) {\n+                access |= Opcodes.ACC_DEPRECATED;\n+            } else if (\"Synthetic\".equals(attrName)) {\n+                access |= Opcodes.ACC_SYNTHETIC;\n+            } else if (\"SourceDebugExtension\".equals(attrName)) {\n+                int len = readInt(v + 2);\n+                sourceDebug = readUTF(v + 6, len, new char[len]);\n+            } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n+                ianns = v + 6;\n+            } else {\n+                attr = readAttribute(attrs,\n+                        attrName,\n+                        v + 6,\n+                        readInt(v + 2),\n+                        c,\n+                        -1,\n+                        null);\n+                if (attr != null) {\n+                    attr.next = cattrs;\n+                    cattrs = attr;\n+                }\n+            }\n+            v += 6 + readInt(v + 2);\n+        }\n+        // calls the visit method\n+        classVisitor.visit(readInt(4),\n+                access,\n+                name,\n+                signature,\n+                superClassName,\n+                implementedItfs);\n+\n+        // calls the visitSource method\n+        if (!skipDebug && (sourceFile != null || sourceDebug != null)) {\n+            classVisitor.visitSource(sourceFile, sourceDebug);\n+        }\n+\n+        // calls the visitOuterClass method\n+        if (enclosingOwner != null) {\n+            classVisitor.visitOuterClass(enclosingOwner,\n+                    enclosingName,\n+                    enclosingDesc);\n+        }\n+\n+        // visits the class annotations\n+        if (ANNOTATIONS) {\n+            for (i = 1; i >= 0; --i) {\n+                v = i == 0 ? ianns : anns;\n+                if (v != 0) {\n+                    j = readUnsignedShort(v);\n+                    v += 2;\n+                    for (; j > 0; --j) {\n+                        v = readAnnotationValues(v + 2,\n+                                c,\n+                                true,\n+                                classVisitor.visitAnnotation(readUTF8(v, c), i != 0));\n+                    }\n+                }\n+            }\n+        }\n+\n+        // visits the class attributes\n+        while (cattrs != null) {\n+            attr = cattrs.next;\n+            cattrs.next = null;\n+            classVisitor.visitAttribute(cattrs);\n+            cattrs = attr;\n+        }\n+\n+        // calls the visitInnerClass method\n+        if (w != 0) {\n+            i = readUnsignedShort(w);\n+            w += 2;\n+            for (; i > 0; --i) {\n+                classVisitor.visitInnerClass(readUnsignedShort(w) == 0\n+                        ? null\n+                        : readClass(w, c), readUnsignedShort(w + 2) == 0\n+                        ? null\n+                        : readClass(w + 2, c), readUnsignedShort(w + 4) == 0\n+                        ? null\n+                        : readUTF8(w + 4, c), readUnsignedShort(w + 6));\n+                w += 8;\n+            }\n+        }\n+\n+        // visits the fields\n+        i = readUnsignedShort(u);\n+        u += 2;\n+        for (; i > 0; --i) {\n+            access = readUnsignedShort(u);\n+            name = readUTF8(u + 2, c);\n+            desc = readUTF8(u + 4, c);\n+            // visits the field's attributes and looks for a ConstantValue\n+            // attribute\n+            int fieldValueItem = 0;\n+            signature = null;\n+            anns = 0;\n+            ianns = 0;\n+            cattrs = null;\n+\n+            j = readUnsignedShort(u + 6);\n+            u += 8;\n+            for (; j > 0; --j) {\n+                attrName = readUTF8(u, c);\n+                // tests are sorted in decreasing frequency order\n+                // (based on frequencies observed on typical classes)\n+                if (\"ConstantValue\".equals(attrName)) {\n+                    fieldValueItem = readUnsignedShort(u + 6);\n+                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n+                    signature = readUTF8(u + 6, c);\n+                } else if (\"Deprecated\".equals(attrName)) {\n+                    access |= Opcodes.ACC_DEPRECATED;\n+                } else if (\"Synthetic\".equals(attrName)) {\n+                    access |= Opcodes.ACC_SYNTHETIC;\n+                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n+                    anns = u + 6;\n+                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n+                    ianns = u + 6;\n+                } else {\n+                    attr = readAttribute(attrs,\n+                            attrName,\n+                            u + 6,\n+                            readInt(u + 2),\n+                            c,\n+                            -1,\n+                            null);\n+                    if (attr != null) {\n+                        attr.next = cattrs;\n+                        cattrs = attr;\n+                    }\n+                }\n+                u += 6 + readInt(u + 2);\n+            }\n+            // visits the field\n+            FieldVisitor fv = classVisitor.visitField(access,\n+                    name,\n+                    desc,\n+                    signature,\n+                    fieldValueItem == 0 ? null : readConst(fieldValueItem, c));\n+            // visits the field annotations and attributes\n+            if (fv != null) {\n+                if (ANNOTATIONS) {\n+                    for (j = 1; j >= 0; --j) {\n+                        v = j == 0 ? ianns : anns;\n+                        if (v != 0) {\n+                            k = readUnsignedShort(v);\n+                            v += 2;\n+                            for (; k > 0; --k) {\n+                                v = readAnnotationValues(v + 2,\n+                                        c,\n+                                        true,\n+                                        fv.visitAnnotation(readUTF8(v, c), j != 0));\n+                            }\n+                        }\n+                    }\n+                }\n+                while (cattrs != null) {\n+                    attr = cattrs.next;\n+                    cattrs.next = null;\n+                    fv.visitAttribute(cattrs);\n+                    cattrs = attr;\n+                }\n+                fv.visitEnd();\n+            }\n+        }\n+\n+        // visits the methods\n+        i = readUnsignedShort(u);\n+        u += 2;\n+        for (; i > 0; --i) {\n+            int u0 = u + 6;\n+            access = readUnsignedShort(u);\n+            name = readUTF8(u + 2, c);\n+            desc = readUTF8(u + 4, c);\n+            signature = null;\n+            anns = 0;\n+            ianns = 0;\n+            int dann = 0;\n+            int mpanns = 0;\n+            int impanns = 0;\n+            cattrs = null;\n+            v = 0;\n+            w = 0;\n+\n+            // looks for Code and Exceptions attributes\n+            j = readUnsignedShort(u + 6);\n+            u += 8;\n+            for (; j > 0; --j) {\n+                attrName = readUTF8(u, c);\n+                int attrSize = readInt(u + 2);\n+                u += 6;\n+                // tests are sorted in decreasing frequency order\n+                // (based on frequencies observed on typical classes)\n+                if (\"Code\".equals(attrName)) {\n+                    if (!skipCode) {\n+                        v = u;\n+                    }\n+                } else if (\"Exceptions\".equals(attrName)) {\n+                    w = u;\n+                } else if (SIGNATURES && \"Signature\".equals(attrName)) {\n+                    signature = readUTF8(u, c);\n+                } else if (\"Deprecated\".equals(attrName)) {\n+                    access |= Opcodes.ACC_DEPRECATED;\n+                } else if (ANNOTATIONS && \"RuntimeVisibleAnnotations\".equals(attrName)) {\n+                    anns = u;\n+                } else if (ANNOTATIONS && \"AnnotationDefault\".equals(attrName)) {\n+                    dann = u;\n+                } else if (\"Synthetic\".equals(attrName)) {\n+                    access |= Opcodes.ACC_SYNTHETIC;\n+                } else if (ANNOTATIONS && \"RuntimeInvisibleAnnotations\".equals(attrName)) {\n+                    ianns = u;\n+                } else if (ANNOTATIONS && \"RuntimeVisibleParameterAnnotations\".equals(attrName))\n+                {\n+                    mpanns = u;\n+                } else if (ANNOTATIONS && \"RuntimeInvisibleParameterAnnotations\".equals(attrName))\n+                {\n+                    impanns = u;\n+                } else {\n+                    attr = readAttribute(attrs,\n+                            attrName,\n+                            u,\n+                            attrSize,\n+                            c,\n+                            -1,\n+                            null);\n+                    if (attr != null) {\n+                        attr.next = cattrs;\n+                        cattrs = attr;\n+                    }\n+                }\n+                u += attrSize;\n+            }\n+            // reads declared exceptions\n+            String[] exceptions;\n+            if (w == 0) {\n+                exceptions = null;\n+            } else {\n+                exceptions = new String[readUnsignedShort(w)];\n+                w += 2;\n+                for (j = 0; j < exceptions.length; ++j) {\n+                    exceptions[j] = readClass(w, c);\n+                    w += 2;\n+                }\n+            }\n+\n+            // visits the method's code, if any\n+            MethodVisitor mv = classVisitor.visitMethod(access,\n+                    name,\n+                    desc,\n+                    signature,\n+                    exceptions);\n+\n+            if (mv != null) {\n+                /*\n+                 * if the returned MethodVisitor is in fact a MethodWriter, it\n+                 * means there is no method adapter between the reader and the\n+                 * writer. If, in addition, the writer's constant pool was\n+                 * copied from this reader (mw.cw.cr == this), and the signature\n+                 * and exceptions of the method have not been changed, then it\n+                 * is possible to skip all visit events and just copy the\n+                 * original code of the method to the writer (the access, name\n+                 * and descriptor can have been changed, this is not important\n+                 * since they are not copied as is from the reader).\n+                 */\n+                if (WRITER && mv instanceof MethodWriter) {\n+                    MethodWriter mw = (MethodWriter) mv;\n+                    if (mw.cw.cr == this) {\n+                        if (signature == mw.signature) {\n+                            boolean sameExceptions = false;\n+                            if (exceptions == null) {\n+                                sameExceptions = mw.exceptionCount == 0;\n+                            } else {\n+                                if (exceptions.length == mw.exceptionCount) {\n+                                    sameExceptions = true;\n+                                    for (j = exceptions.length - 1; j >= 0; --j)\n+                                    {\n+                                        w -= 2;\n+                                        if (mw.exceptions[j] != readUnsignedShort(w))\n+                                        {\n+                                            sameExceptions = false;\n+                                            break;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            if (sameExceptions) {\n+                                /*\n+                                 * we do not copy directly the code into\n+                                 * MethodWriter to save a byte array copy\n+                                 * operation. The real copy will be done in\n+                                 * ClassWriter.toByteArray().\n+                                 */\n+                                mw.classReaderOffset = u0;\n+                                mw.classReaderLength = u - u0;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (ANNOTATIONS && dann != 0) {\n+                    AnnotationVisitor dv = mv.visitAnnotationDefault();\n+                    readAnnotationValue(dann, c, null, dv);\n+                    if (dv != null) {\n+                        dv.visitEnd();\n+                    }\n+                }\n+                if (ANNOTATIONS) {\n+                    for (j = 1; j >= 0; --j) {\n+                        w = j == 0 ? ianns : anns;\n+                        if (w != 0) {\n+                            k = readUnsignedShort(w);\n+                            w += 2;\n+                            for (; k > 0; --k) {\n+                                w = readAnnotationValues(w + 2,\n+                                        c,\n+                                        true,\n+                                        mv.visitAnnotation(readUTF8(w, c), j != 0));\n+                            }\n+                        }\n+                    }\n+                }\n+                if (ANNOTATIONS && mpanns != 0) {\n+                    readParameterAnnotations(mpanns, desc, c, true, mv);\n+                }\n+                if (ANNOTATIONS && impanns != 0) {\n+                    readParameterAnnotations(impanns, desc, c, false, mv);\n+                }\n+                while (cattrs != null) {\n+                    attr = cattrs.next;\n+                    cattrs.next = null;\n+                    mv.visitAttribute(cattrs);\n+                    cattrs = attr;\n+                }\n+            }\n+\n+            if (mv != null && v != 0) {\n+                int maxStack = readUnsignedShort(v);\n+                int maxLocals = readUnsignedShort(v + 2);\n+                int codeLength = readInt(v + 4);\n+                v += 8;\n+\n+                int codeStart = v;\n+                int codeEnd = v + codeLength;\n+\n+                mv.visitCode();\n+\n+                // 1st phase: finds the labels\n+                int label;\n+                Label[] labels = new Label[codeLength + 2];\n+                readLabel(codeLength + 1, labels);\n+                while (v < codeEnd) {\n+                    w = v - codeStart;\n+                    int opcode = b[v] & 0xFF;\n+                    switch (ClassWriter.TYPE[opcode]) {\n+                        case ClassWriter.NOARG_INSN:\n+                        case ClassWriter.IMPLVAR_INSN:\n+                            v += 1;\n+                            break;\n+                        case ClassWriter.LABEL_INSN:\n+                            readLabel(w + readShort(v + 1), labels);\n+                            v += 3;\n+                            break;\n+                        case ClassWriter.LABELW_INSN:\n+                            readLabel(w + readInt(v + 1), labels);\n+                            v += 5;\n+                            break;\n+                        case ClassWriter.WIDE_INSN:\n+                            opcode = b[v + 1] & 0xFF;\n+                            if (opcode == Opcodes.IINC) {\n+                                v += 6;\n+                            } else {\n+                                v += 4;\n+                            }\n+                            break;\n+                        case ClassWriter.TABL_INSN:\n+                            // skips 0 to 3 padding bytes*\n+                            v = v + 4 - (w & 3);\n+                            // reads instruction\n+                            readLabel(w + readInt(v), labels);\n+                            j = readInt(v + 8) - readInt(v + 4) + 1;\n+                            v += 12;\n+                            for (; j > 0; --j) {\n+                                readLabel(w + readInt(v), labels);\n+                                v += 4;\n+                            }\n+                            break;\n+                        case ClassWriter.LOOK_INSN:\n+                            // skips 0 to 3 padding bytes*\n+                            v = v + 4 - (w & 3);\n+                            // reads instruction\n+                            readLabel(w + readInt(v), labels);\n+                            j = readInt(v + 4);\n+                            v += 8;\n+                            for (; j > 0; --j) {\n+                                readLabel(w + readInt(v + 4), labels);\n+                                v += 8;\n+                            }\n+                            break;\n+                        case ClassWriter.VAR_INSN:\n+                        case ClassWriter.SBYTE_INSN:\n+                        case ClassWriter.LDC_INSN:\n+                            v += 2;\n+                            break;\n+                        case ClassWriter.SHORT_INSN:\n+                        case ClassWriter.LDCW_INSN:\n+                        case ClassWriter.FIELDORMETH_INSN:\n+                        case ClassWriter.TYPE_INSN:\n+                        case ClassWriter.IINC_INSN:\n+                            v += 3;\n+                            break;\n+                        case ClassWriter.ITFMETH_INSN:\n+                            v += 5;\n+                            break;\n+                        // case MANA_INSN:\n+                        default:\n+                            v += 4;\n+                            break;\n+                    }\n+                }\n+                // parses the try catch entries\n+                j = readUnsignedShort(v);\n+                v += 2;\n+                for (; j > 0; --j) {\n+                    Label start = readLabel(readUnsignedShort(v), labels);\n+                    Label end = readLabel(readUnsignedShort(v + 2), labels);\n+                    Label handler = readLabel(readUnsignedShort(v + 4), labels);\n+                    int type = readUnsignedShort(v + 6);\n+                    if (type == 0) {\n+                        mv.visitTryCatchBlock(start, end, handler, null);\n+                    } else {\n+                        mv.visitTryCatchBlock(start,\n+                                end,\n+                                handler,\n+                                readUTF8(items[type], c));\n+                    }\n+                    v += 8;\n+                }\n+                // parses the local variable, line number tables, and code\n+                // attributes\n+                int varTable = 0;\n+                int varTypeTable = 0;\n+                int stackMap = 0;\n+                int frameCount = 0;\n+                int frameMode = 0;\n+                int frameOffset = 0;\n+                int frameLocalCount = 0;\n+                int frameLocalDiff = 0;\n+                int frameStackCount = 0;\n+                Object[] frameLocal = null;\n+                Object[] frameStack = null;\n+                boolean zip = true;\n+                cattrs = null;\n+                j = readUnsignedShort(v);\n+                v += 2;\n+                for (; j > 0; --j) {\n+                    attrName = readUTF8(v, c);\n+                    if (\"LocalVariableTable\".equals(attrName)) {\n+                        if (!skipDebug) {\n+                            varTable = v + 6;\n+                            k = readUnsignedShort(v + 6);\n+                            w = v + 8;\n+                            for (; k > 0; --k) {\n+                                label = readUnsignedShort(w);\n+                                if (labels[label] == null) {\n+                                    readLabel(label, labels).status |= Label.DEBUG;\n+                                }\n+                                label += readUnsignedShort(w + 2);\n+                                if (labels[label] == null) {\n+                                    readLabel(label, labels).status |= Label.DEBUG;\n+                                }\n+                                w += 10;\n+                            }\n+                        }\n+                    } else if (\"LocalVariableTypeTable\".equals(attrName)) {\n+                        varTypeTable = v + 6;\n+                    } else if (\"LineNumberTable\".equals(attrName)) {\n+                        if (!skipDebug) {\n+                            k = readUnsignedShort(v + 6);\n+                            w = v + 8;\n+                            for (; k > 0; --k) {\n+                                label = readUnsignedShort(w);\n+                                if (labels[label] == null) {\n+                                    readLabel(label, labels).status |= Label.DEBUG;\n+                                }\n+                                labels[label].line = readUnsignedShort(w + 2);\n+                                w += 4;\n+                            }\n+                        }\n+                    } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\n+                        if ((flags & SKIP_FRAMES) == 0) {\n+                            stackMap = v + 8;\n+                            frameCount = readUnsignedShort(v + 6);\n+                        }\n+                        /*\n+                         * here we do not extract the labels corresponding to\n+                         * the attribute content. This would require a full\n+                         * parsing of the attribute, which would need to be\n+                         * repeated in the second phase (see below). Instead the\n+                         * content of the attribute is read one frame at a time\n+                         * (i.e. after a frame has been visited, the next frame\n+                         * is read), and the labels it contains are also\n+                         * extracted one frame at a time. Thanks to the ordering\n+                         * of frames, having only a \"one frame lookahead\" is not\n+                         * a problem, i.e. it is not possible to see an offset\n+                         * smaller than the offset of the current insn and for\n+                         * which no Label exist.\n+                         */\n+                        // TODO true for frame offsets,\n+                        // but for UNINITIALIZED type offsets?\n+                    } else if (FRAMES && \"StackMap\".equals(attrName)) {\n+                        if ((flags & SKIP_FRAMES) == 0) {\n+                            stackMap = v + 8;\n+                            frameCount = readUnsignedShort(v + 6);\n+                            zip = false;\n+                        }\n+                        /*\n+                         * IMPORTANT! here we assume that the frames are\n+                         * ordered, as in the StackMapTable attribute, although\n+                         * this is not guaranteed by the attribute format.\n+                         */\n+                    } else {\n+                        for (k = 0; k < attrs.length; ++k) {\n+                            if (attrs[k].type.equals(attrName)) {\n+                                attr = attrs[k].read(this,\n+                                        v + 6,\n+                                        readInt(v + 2),\n+                                        c,\n+                                        codeStart - 8,\n+                                        labels);\n+                                if (attr != null) {\n+                                    attr.next = cattrs;\n+                                    cattrs = attr;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    v += 6 + readInt(v + 2);\n+                }\n+\n+                // 2nd phase: visits each instruction\n+                if (FRAMES && stackMap != 0) {\n+                    // creates the very first (implicit) frame from the method\n+                    // descriptor\n+                    frameLocal = new Object[maxLocals];\n+                    frameStack = new Object[maxStack];\n+                    if (unzip) {\n+                        int local = 0;\n+                        if ((access & Opcodes.ACC_STATIC) == 0) {\n+                            if (\"<init>\".equals(name)) {\n+                                frameLocal[local++] = Opcodes.UNINITIALIZED_THIS;\n+                            } else {\n+                                frameLocal[local++] = readClass(header + 2, c);\n+                            }\n+                        }\n+                        j = 1;\n+                        loop: while (true) {\n+                            k = j;\n+                            switch (desc.charAt(j++)) {\n+                                case 'Z':\n+                                case 'C':\n+                                case 'B':\n+                                case 'S':\n+                                case 'I':\n+                                    frameLocal[local++] = Opcodes.INTEGER;\n+                                    break;\n+                                case 'F':\n+                                    frameLocal[local++] = Opcodes.FLOAT;\n+                                    break;\n+                                case 'J':\n+                                    frameLocal[local++] = Opcodes.LONG;\n+                                    break;\n+                                case 'D':\n+                                    frameLocal[local++] = Opcodes.DOUBLE;\n+                                    break;\n+                                case '[':\n+                                    while (desc.charAt(j) == '[') {\n+                                        ++j;\n+                                    }\n+                                    if (desc.charAt(j) == 'L') {\n+                                        ++j;\n+                                        while (desc.charAt(j) != ';') {\n+                                            ++j;\n+                                        }\n+                                    }\n+                                    frameLocal[local++] = desc.substring(k, ++j);\n+                                    break;\n+                                case 'L':\n+                                    while (desc.charAt(j) != ';') {\n+                                        ++j;\n+                                    }\n+                                    frameLocal[local++] = desc.substring(k + 1,\n+                                            j++);\n+                                    break;\n+                                default:\n+                                    break loop;\n+                            }\n+                        }\n+                        frameLocalCount = local;\n+                    }\n+                    /*\n+                     * for the first explicit frame the offset is not\n+                     * offset_delta + 1 but only offset_delta; setting the\n+                     * implicit frame offset to -1 allow the use of the\n+                     * \"offset_delta + 1\" rule in all cases\n+                     */\n+                    frameOffset = -1;\n+                }\n+                v = codeStart;\n+                Label l;\n+                while (v < codeEnd) {\n+                    w = v - codeStart;\n+\n+                    l = labels[w];\n+                    if (l != null) {\n+                        mv.visitLabel(l);\n+                        if (!skipDebug && l.line > 0) {\n+                            mv.visitLineNumber(l.line, l);\n+                        }\n+                    }\n+\n+                    while (FRAMES && frameLocal != null\n+                            && (frameOffset == w || frameOffset == -1))\n+                    {\n+                        // if there is a frame for this offset,\n+                        // makes the visitor visit it,\n+                        // and reads the next frame if there is one.\n+                        if (!zip || unzip) {\n+                            mv.visitFrame(Opcodes.F_NEW,\n+                                    frameLocalCount,\n+                                    frameLocal,\n+                                    frameStackCount,\n+                                    frameStack);\n+                        } else if (frameOffset != -1) {\n+                            mv.visitFrame(frameMode,\n+                                    frameLocalDiff,\n+                                    frameLocal,\n+                                    frameStackCount,\n+                                    frameStack);\n+                        }\n+\n+                        if (frameCount > 0) {\n+                            int tag, delta, n;\n+                            if (zip) {\n+                                tag = b[stackMap++] & 0xFF;\n+                            } else {\n+                                tag = MethodWriter.FULL_FRAME;\n+                                frameOffset = -1;\n+                            }\n+                            frameLocalDiff = 0;\n+                            if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME)\n+                            {\n+                                delta = tag;\n+                                frameMode = Opcodes.F_SAME;\n+                                frameStackCount = 0;\n+                            } else if (tag < MethodWriter.RESERVED) {\n+                                delta = tag\n+                                        - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;\n+                                stackMap = readFrameType(frameStack,\n+                                        0,\n+                                        stackMap,\n+                                        c,\n+                                        labels);\n+                                frameMode = Opcodes.F_SAME1;\n+                                frameStackCount = 1;\n+                            } else {\n+                                delta = readUnsignedShort(stackMap);\n+                                stackMap += 2;\n+                                if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n+                                {\n+                                    stackMap = readFrameType(frameStack,\n+                                            0,\n+                                            stackMap,\n+                                            c,\n+                                            labels);\n+                                    frameMode = Opcodes.F_SAME1;\n+                                    frameStackCount = 1;\n+                                } else if (tag >= MethodWriter.CHOP_FRAME\n+                                        && tag < MethodWriter.SAME_FRAME_EXTENDED)\n+                                {\n+                                    frameMode = Opcodes.F_CHOP;\n+                                    frameLocalDiff = MethodWriter.SAME_FRAME_EXTENDED\n+                                            - tag;\n+                                    frameLocalCount -= frameLocalDiff;\n+                                    frameStackCount = 0;\n+                                } else if (tag == MethodWriter.SAME_FRAME_EXTENDED)\n+                                {\n+                                    frameMode = Opcodes.F_SAME;\n+                                    frameStackCount = 0;\n+                                } else if (tag < MethodWriter.FULL_FRAME) {\n+                                    j = unzip ? frameLocalCount : 0;\n+                                    for (k = tag\n+                                            - MethodWriter.SAME_FRAME_EXTENDED; k > 0; k--)\n+                                    {\n+                                        stackMap = readFrameType(frameLocal,\n+                                                j++,\n+                                                stackMap,\n+                                                c,\n+                                                labels);\n+                                    }\n+                                    frameMode = Opcodes.F_APPEND;\n+                                    frameLocalDiff = tag\n+                                            - MethodWriter.SAME_FRAME_EXTENDED;\n+                                    frameLocalCount += frameLocalDiff;\n+                                    frameStackCount = 0;\n+                                } else { // if (tag == FULL_FRAME) {\n+                                    frameMode = Opcodes.F_FULL;\n+                                    n = frameLocalDiff = frameLocalCount = readUnsignedShort(stackMap);\n+                                    stackMap += 2;\n+                                    for (j = 0; n > 0; n--) {\n+                                        stackMap = readFrameType(frameLocal,\n+                                                j++,\n+                                                stackMap,\n+                                                c,\n+                                                labels);\n+                                    }\n+                                    n = frameStackCount = readUnsignedShort(stackMap);\n+                                    stackMap += 2;\n+                                    for (j = 0; n > 0; n--) {\n+                                        stackMap = readFrameType(frameStack,\n+                                                j++,\n+                                                stackMap,\n+                                                c,\n+                                                labels);\n+                                    }\n+                                }\n+                            }\n+                            frameOffset += delta + 1;\n+                            readLabel(frameOffset, labels);\n+\n+                            --frameCount;\n+                        } else {\n+                            frameLocal = null;\n+                        }\n+                    }\n+\n+                    int opcode = b[v] & 0xFF;\n+                    switch (ClassWriter.TYPE[opcode]) {\n+                        case ClassWriter.NOARG_INSN:\n+                            mv.visitInsn(opcode);\n+                            v += 1;\n+                            break;\n+                        case ClassWriter.IMPLVAR_INSN:\n+                            if (opcode > Opcodes.ISTORE) {\n+                                opcode -= 59; // ISTORE_0\n+                                mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2),\n+                                        opcode & 0x3);\n+                            } else {\n+                                opcode -= 26; // ILOAD_0\n+                                mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2),\n+                                        opcode & 0x3);\n+                            }\n+                            v += 1;\n+                            break;\n+                        case ClassWriter.LABEL_INSN:\n+                            mv.visitJumpInsn(opcode, labels[w\n+                                    + readShort(v + 1)]);\n+                            v += 3;\n+                            break;\n+                        case ClassWriter.LABELW_INSN:\n+                            mv.visitJumpInsn(opcode - 33, labels[w\n+                                    + readInt(v + 1)]);\n+                            v += 5;\n+                            break;\n+                        case ClassWriter.WIDE_INSN:\n+                            opcode = b[v + 1] & 0xFF;\n+                            if (opcode == Opcodes.IINC) {\n+                                mv.visitIincInsn(readUnsignedShort(v + 2),\n+                                        readShort(v + 4));\n+                                v += 6;\n+                            } else {\n+                                mv.visitVarInsn(opcode,\n+                                        readUnsignedShort(v + 2));\n+                                v += 4;\n+                            }\n+                            break;\n+                        case ClassWriter.TABL_INSN:\n+                            // skips 0 to 3 padding bytes\n+                            v = v + 4 - (w & 3);\n+                            // reads instruction\n+                            label = w + readInt(v);\n+                            int min = readInt(v + 4);\n+                            int max = readInt(v + 8);\n+                            v += 12;\n+                            Label[] table = new Label[max - min + 1];\n+                            for (j = 0; j < table.length; ++j) {\n+                                table[j] = labels[w + readInt(v)];\n+                                v += 4;\n+                            }\n+                            mv.visitTableSwitchInsn(min,\n+                                    max,\n+                                    labels[label],\n+                                    table);\n+                            break;\n+                        case ClassWriter.LOOK_INSN:\n+                            // skips 0 to 3 padding bytes\n+                            v = v + 4 - (w & 3);\n+                            // reads instruction\n+                            label = w + readInt(v);\n+                            j = readInt(v + 4);\n+                            v += 8;\n+                            int[] keys = new int[j];\n+                            Label[] values = new Label[j];\n+                            for (j = 0; j < keys.length; ++j) {\n+                                keys[j] = readInt(v);\n+                                values[j] = labels[w + readInt(v + 4)];\n+                                v += 8;\n+                            }\n+                            mv.visitLookupSwitchInsn(labels[label],\n+                                    keys,\n+                                    values);\n+                            break;\n+                        case ClassWriter.VAR_INSN:\n+                            mv.visitVarInsn(opcode, b[v + 1] & 0xFF);\n+                            v += 2;\n+                            break;\n+                        case ClassWriter.SBYTE_INSN:\n+                            mv.visitIntInsn(opcode, b[v + 1]);\n+                            v += 2;\n+                            break;\n+                        case ClassWriter.SHORT_INSN:\n+                            mv.visitIntInsn(opcode, readShort(v + 1));\n+                            v += 3;\n+                            break;\n+                        case ClassWriter.LDC_INSN:\n+                            mv.visitLdcInsn(readConst(b[v + 1] & 0xFF, c));\n+                            v += 2;\n+                            break;\n+                        case ClassWriter.LDCW_INSN:\n+                            mv.visitLdcInsn(readConst(readUnsignedShort(v + 1),\n+                                    c));\n+                            v += 3;\n+                            break;\n+                        case ClassWriter.FIELDORMETH_INSN:\n+                        case ClassWriter.ITFMETH_INSN:\n+                            int cpIndex = items[readUnsignedShort(v + 1)];\n+                            String iowner = readClass(cpIndex, c);\n+                            cpIndex = items[readUnsignedShort(cpIndex + 2)];\n+                            String iname = readUTF8(cpIndex, c);\n+                            String idesc = readUTF8(cpIndex + 2, c);\n+                            if (opcode < Opcodes.INVOKEVIRTUAL) {\n+                                mv.visitFieldInsn(opcode, iowner, iname, idesc);\n+                            } else {\n+                                mv.visitMethodInsn(opcode, iowner, iname, idesc);\n+                            }\n+                            if (opcode == Opcodes.INVOKEINTERFACE) {\n+                                v += 5;\n+                            } else {\n+                                v += 3;\n+                            }\n+                            break;\n+                        case ClassWriter.TYPE_INSN:\n+                            mv.visitTypeInsn(opcode, readClass(v + 1, c));\n+                            v += 3;\n+                            break;\n+                        case ClassWriter.IINC_INSN:\n+                            mv.visitIincInsn(b[v + 1] & 0xFF, b[v + 2]);\n+                            v += 3;\n+                            break;\n+                        // case MANA_INSN:\n+                        default:\n+                            mv.visitMultiANewArrayInsn(readClass(v + 1, c),\n+                                    b[v + 3] & 0xFF);\n+                            v += 4;\n+                            break;\n+                    }\n+                }\n+                l = labels[codeEnd - codeStart];\n+                if (l != null) {\n+                    mv.visitLabel(l);\n+                }\n+                // visits the local variable tables\n+                if (!skipDebug && varTable != 0) {\n+                    int[] typeTable = null;\n+                    if (varTypeTable != 0) {\n+                        k = readUnsignedShort(varTypeTable) * 3;\n+                        w = varTypeTable + 2;\n+                        typeTable = new int[k];\n+                        while (k > 0) {\n+                            typeTable[--k] = w + 6; // signature\n+                            typeTable[--k] = readUnsignedShort(w + 8); // index\n+                            typeTable[--k] = readUnsignedShort(w); // start\n+                            w += 10;\n+                        }\n+                    }\n+                    k = readUnsignedShort(varTable);\n+                    w = varTable + 2;\n+                    for (; k > 0; --k) {\n+                        int start = readUnsignedShort(w);\n+                        int length = readUnsignedShort(w + 2);\n+                        int index = readUnsignedShort(w + 8);\n+                        String vsignature = null;\n+                        if (typeTable != null) {\n+                            for (int a = 0; a < typeTable.length; a += 3) {\n+                                if (typeTable[a] == start\n+                                        && typeTable[a + 1] == index)\n+                                {\n+                                    vsignature = readUTF8(typeTable[a + 2], c);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        mv.visitLocalVariable(readUTF8(w + 4, c),\n+                                readUTF8(w + 6, c),\n+                                vsignature,\n+                                labels[start],\n+                                labels[start + length],\n+                                index);\n+                        w += 10;\n+                    }\n+                }\n+                // visits the other attributes\n+                while (cattrs != null) {\n+                    attr = cattrs.next;\n+                    cattrs.next = null;\n+                    mv.visitAttribute(cattrs);\n+                    cattrs = attr;\n+                }\n+                // visits the max stack and max locals values\n+                mv.visitMaxs(maxStack, maxLocals);\n+            }\n+\n+            if (mv != null) {\n+                mv.visitEnd();\n+            }\n+        }\n+\n+        // visits the end of the class\n+        classVisitor.visitEnd();\n+    }\n+\n+    /**\n+     * Reads parameter annotations and makes the given visitor visit them.\n+     * \n+     * @param v start offset in {@link #b b} of the annotations to be read.\n+     * @param desc the method descriptor.\n+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n+     *        {@link #readClass(int,char[]) readClass} or\n+     *        {@link #readConst readConst}.\n+     * @param visible <tt>true</tt> if the annotations to be read are visible\n+     *        at runtime.\n+     * @param mv the visitor that must visit the annotations.\n+     */\n+    private void readParameterAnnotations(\n+        int v,\n+        final String desc,\n+        final char[] buf,\n+        final boolean visible,\n+        final MethodVisitor mv)\n+    {\n+        int i;\n+        int n = b[v++] & 0xFF;\n+        // workaround for a bug in javac (javac compiler generates a parameter\n+        // annotation array whose size is equal to the number of parameters in\n+        // the Java source file, while it should generate an array whose size is\n+        // equal to the number of parameters in the method descriptor - which\n+        // includes the synthetic parameters added by the compiler). This work-\n+        // around supposes that the synthetic parameters are the first ones.\n+        int synthetics = Type.getArgumentTypes(desc).length - n;\n+        AnnotationVisitor av;\n+        for (i = 0; i < synthetics; ++i) {\n+            // virtual annotation to detect synthetic parameters in MethodWriter \n+            av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\n+            if (av != null) {\n+                av.visitEnd();\n+            }\n+        }\n+        for (; i < n + synthetics; ++i) {\n+            int j = readUnsignedShort(v);\n+            v += 2;\n+            for (; j > 0; --j) {\n+                av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\n+                v = readAnnotationValues(v + 2, buf, true, av);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reads the values of an annotation and makes the given visitor visit them.\n+     * \n+     * @param v the start offset in {@link #b b} of the values to be read\n+     *        (including the unsigned short that gives the number of values).\n+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n+     *        {@link #readClass(int,char[]) readClass} or\n+     *        {@link #readConst readConst}.\n+     * @param named if the annotation values are named or not.\n+     * @param av the visitor that must visit the values.\n+     * @return the end offset of the annotation values.\n+     */\n+    private int readAnnotationValues(\n+        int v,\n+        final char[] buf,\n+        final boolean named,\n+        final AnnotationVisitor av)\n+    {\n+        int i = readUnsignedShort(v);\n+        v += 2;\n+        if (named) {\n+            for (; i > 0; --i) {\n+                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\n+            }\n+        } else {\n+            for (; i > 0; --i) {\n+                v = readAnnotationValue(v, buf, null, av);\n+            }\n+        }\n+        if (av != null) {\n+            av.visitEnd();\n+        }\n+        return v;\n+    }\n+\n+    /**\n+     * Reads a value of an annotation and makes the given visitor visit it.\n+     * \n+     * @param v the start offset in {@link #b b} of the value to be read (<i>not\n+     *        including the value name constant pool index</i>).\n+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n+     *        {@link #readClass(int,char[]) readClass} or\n+     *        {@link #readConst readConst}.\n+     * @param name the name of the value to be read.\n+     * @param av the visitor that must visit the value.\n+     * @return the end offset of the annotation value.\n+     */\n+    private int readAnnotationValue(\n+        int v,\n+        final char[] buf,\n+        final String name,\n+        final AnnotationVisitor av)\n+    {\n+        int i;\n+        if (av == null) {\n+            switch (b[v] & 0xFF) {\n+                case 'e': // enum_const_value\n+                    return v + 5;\n+                case '@': // annotation_value\n+                    return readAnnotationValues(v + 3, buf, true, null);\n+                case '[': // array_value\n+                    return readAnnotationValues(v + 1, buf, false, null);\n+                default:\n+                    return v + 3;\n+            }\n+        }\n+        switch (b[v++] & 0xFF) {\n+            case 'I': // pointer to CONSTANT_Integer\n+            case 'J': // pointer to CONSTANT_Long\n+            case 'F': // pointer to CONSTANT_Float\n+            case 'D': // pointer to CONSTANT_Double\n+                av.visit(name, readConst(readUnsignedShort(v), buf));\n+                v += 2;\n+                break;\n+            case 'B': // pointer to CONSTANT_Byte\n+                av.visit(name,\n+                        new Byte((byte) readInt(items[readUnsignedShort(v)])));\n+                v += 2;\n+                break;\n+            case 'Z': // pointer to CONSTANT_Boolean\n+                av.visit(name, readInt(items[readUnsignedShort(v)]) == 0\n+                        ? Boolean.FALSE\n+                        : Boolean.TRUE);\n+                v += 2;\n+                break;\n+            case 'S': // pointer to CONSTANT_Short\n+                av.visit(name,\n+                        new Short((short) readInt(items[readUnsignedShort(v)])));\n+                v += 2;\n+                break;\n+            case 'C': // pointer to CONSTANT_Char\n+                av.visit(name,\n+                        new Character((char) readInt(items[readUnsignedShort(v)])));\n+                v += 2;\n+                break;\n+            case 's': // pointer to CONSTANT_Utf8\n+                av.visit(name, readUTF8(v, buf));\n+                v += 2;\n+                break;\n+            case 'e': // enum_const_value\n+                av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\n+                v += 4;\n+                break;\n+            case 'c': // class_info\n+                av.visit(name, Type.getType(readUTF8(v, buf)));\n+                v += 2;\n+                break;\n+            case '@': // annotation_value\n+                v = readAnnotationValues(v + 2,\n+                        buf,\n+                        true,\n+                        av.visitAnnotation(name, readUTF8(v, buf)));\n+                break;\n+            case '[': // array_value\n+                int size = readUnsignedShort(v);\n+                v += 2;\n+                if (size == 0) {\n+                    return readAnnotationValues(v - 2,\n+                            buf,\n+                            false,\n+                            av.visitArray(name));\n+                }\n+                switch (this.b[v++] & 0xFF) {\n+                    case 'B':\n+                        byte[] bv = new byte[size];\n+                        for (i = 0; i < size; i++) {\n+                            bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\n+                            v += 3;\n+                        }\n+                        av.visit(name, bv);\n+                        --v;\n+                        break;\n+                    case 'Z':\n+                        boolean[] zv = new boolean[size];\n+                        for (i = 0; i < size; i++) {\n+                            zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\n+                            v += 3;\n+                        }\n+                        av.visit(name, zv);\n+                        --v;\n+                        break;\n+                    case 'S':\n+                        short[] sv = new short[size];\n+                        for (i = 0; i < size; i++) {\n+                            sv[i] = (short) readInt(items[readUnsignedShort(v)]);\n+                            v += 3;\n+                        }\n+                        av.visit(name, sv);\n+                        --v;\n+                        break;\n+                    case 'C':\n+                        char[] cv = new char[size];\n+                        for (i = 0; i < size; i++) {\n+                            cv[i] = (char) readInt(items[readUnsignedShort(v)]);\n+                            v += 3;\n+                        }\n+                        av.visit(name, cv);\n+                        --v;\n+                        break;\n+                    case 'I':\n+                        int[] iv = new int[size];\n+                        for (i = 0; i < size; i++) {\n+                            iv[i] = readInt(items[readUnsignedShort(v)]);\n+                            v += 3;\n+                        }\n+                        av.visit(name, iv);\n+                        --v;\n+                        break;\n+                    case 'J':\n+                        long[] lv = new long[size];\n+                        for (i = 0; i < size; i++) {\n+                            lv[i] = readLong(items[readUnsignedShort(v)]);\n+                            v += 3;\n+                        }\n+                        av.visit(name, lv);\n+                        --v;\n+                        break;\n+                    case 'F':\n+                        float[] fv = new float[size];\n+                        for (i = 0; i < size; i++) {\n+                            fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\n+                            v += 3;\n+                        }\n+                        av.visit(name, fv);\n+                        --v;\n+                        break;\n+                    case 'D':\n+                        double[] dv = new double[size];\n+                        for (i = 0; i < size; i++) {\n+                            dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\n+                            v += 3;\n+                        }\n+                        av.visit(name, dv);\n+                        --v;\n+                        break;\n+                    default:\n+                        v = readAnnotationValues(v - 3,\n+                                buf,\n+                                false,\n+                                av.visitArray(name));\n+                }\n+        }\n+        return v;\n+    }\n+\n+    private int readFrameType(\n+        final Object[] frame,\n+        final int index,\n+        int v,\n+        final char[] buf,\n+        final Label[] labels)\n+    {\n+        int type = b[v++] & 0xFF;\n+        switch (type) {\n+            case 0:\n+                frame[index] = Opcodes.TOP;\n+                break;\n+            case 1:\n+                frame[index] = Opcodes.INTEGER;\n+                break;\n+            case 2:\n+                frame[index] = Opcodes.FLOAT;\n+                break;\n+            case 3:\n+                frame[index] = Opcodes.DOUBLE;\n+                break;\n+            case 4:\n+                frame[index] = Opcodes.LONG;\n+                break;\n+            case 5:\n+                frame[index] = Opcodes.NULL;\n+                break;\n+            case 6:\n+                frame[index] = Opcodes.UNINITIALIZED_THIS;\n+                break;\n+            case 7: // Object\n+                frame[index] = readClass(v, buf);\n+                v += 2;\n+                break;\n+            default: // Uninitialized\n+                frame[index] = readLabel(readUnsignedShort(v), labels);\n+                v += 2;\n+        }\n+        return v;\n+    }\n+\n+    /**\n+     * Returns the label corresponding to the given offset. The default\n+     * implementation of this method creates a label for the given offset if it\n+     * has not been already created.\n+     * \n+     * @param offset a bytecode offset in a method.\n+     * @param labels the already created labels, indexed by their offset. If a\n+     *        label already exists for offset this method must not create a new\n+     *        one. Otherwise it must store the new label in this array.\n+     * @return a non null Label, which must be equal to labels[offset].\n+     */\n+    protected Label readLabel(int offset, Label[] labels) {\n+        if (labels[offset] == null) {\n+            labels[offset] = new Label();\n+        }\n+        return labels[offset];\n+    }\n+\n+    /**\n+     * Reads an attribute in {@link #b b}.\n+     * \n+     * @param attrs prototypes of the attributes that must be parsed during the\n+     *        visit of the class. Any attribute whose type is not equal to the\n+     *        type of one the prototypes is ignored (i.e. an empty\n+     *        {@link Attribute} instance is returned).\n+     * @param type the type of the attribute.\n+     * @param off index of the first byte of the attribute's content in\n+     *        {@link #b b}. The 6 attribute header bytes, containing the type\n+     *        and the length of the attribute, are not taken into account here\n+     *        (they have already been read).\n+     * @param len the length of the attribute's content.\n+     * @param buf buffer to be used to call {@link #readUTF8 readUTF8},\n+     *        {@link #readClass(int,char[]) readClass} or\n+     *        {@link #readConst readConst}.\n+     * @param codeOff index of the first byte of code's attribute content in\n+     *        {@link #b b}, or -1 if the attribute to be read is not a code\n+     *        attribute. The 6 attribute header bytes, containing the type and\n+     *        the length of the attribute, are not taken into account here.\n+     * @param labels the labels of the method's code, or <tt>null</tt> if the\n+     *        attribute to be read is not a code attribute.\n+     * @return the attribute that has been read, or <tt>null</tt> to skip this\n+     *         attribute.\n+     */\n+    private Attribute readAttribute(\n+        final Attribute[] attrs,\n+        final String type,\n+        final int off,\n+        final int len,\n+        final char[] buf,\n+        final int codeOff,\n+        final Label[] labels)\n+    {\n+        for (int i = 0; i < attrs.length; ++i) {\n+            if (attrs[i].type.equals(type)) {\n+                return attrs[i].read(this, off, len, buf, codeOff, labels);\n+            }\n+        }\n+        return new Attribute(type).read(this, off, len, null, -1, null);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: low level parsing\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the start index of the constant pool item in {@link #b b}, plus\n+     * one. <i>This method is intended for {@link Attribute} sub classes, and is\n+     * normally not needed by class generators or adapters.</i>\n+     * \n+     * @param item the index a constant pool item.\n+     * @return the start index of the constant pool item in {@link #b b}, plus\n+     *         one.\n+     */\n+    public int getItem(final int item) {\n+        return items[item];\n+    }\n+\n+    /**\n+     * Reads a byte value in {@link #b b}. <i>This method is intended for\n+     * {@link Attribute} sub classes, and is normally not needed by class\n+     * generators or adapters.</i>\n+     * \n+     * @param index the start index of the value to be read in {@link #b b}.\n+     * @return the read value.\n+     */\n+    public int readByte(final int index) {\n+        return b[index] & 0xFF;\n+    }\n+\n+    /**\n+     * Reads an unsigned short value in {@link #b b}. <i>This method is\n+     * intended for {@link Attribute} sub classes, and is normally not needed by\n+     * class generators or adapters.</i>\n+     * \n+     * @param index the start index of the value to be read in {@link #b b}.\n+     * @return the read value.\n+     */\n+    public int readUnsignedShort(final int index) {\n+        byte[] b = this.b;\n+        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n+    }\n+\n+    /**\n+     * Reads a signed short value in {@link #b b}. <i>This method is intended\n+     * for {@link Attribute} sub classes, and is normally not needed by class\n+     * generators or adapters.</i>\n+     * \n+     * @param index the start index of the value to be read in {@link #b b}.\n+     * @return the read value.\n+     */\n+    public short readShort(final int index) {\n+        byte[] b = this.b;\n+        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n+    }\n+\n+    /**\n+     * Reads a signed int value in {@link #b b}. <i>This method is intended for\n+     * {@link Attribute} sub classes, and is normally not needed by class\n+     * generators or adapters.</i>\n+     * \n+     * @param index the start index of the value to be read in {@link #b b}.\n+     * @return the read value.\n+     */\n+    public int readInt(final int index) {\n+        byte[] b = this.b;\n+        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)\n+                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n+    }\n+\n+    /**\n+     * Reads a signed long value in {@link #b b}. <i>This method is intended\n+     * for {@link Attribute} sub classes, and is normally not needed by class\n+     * generators or adapters.</i>\n+     * \n+     * @param index the start index of the value to be read in {@link #b b}.\n+     * @return the read value.\n+     */\n+    public long readLong(final int index) {\n+        long l1 = readInt(index);\n+        long l0 = readInt(index + 4) & 0xFFFFFFFFL;\n+        return (l1 << 32) | l0;\n+    }\n+\n+    /**\n+     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method\n+     * is intended for {@link Attribute} sub classes, and is normally not needed\n+     * by class generators or adapters.</i>\n+     * \n+     * @param index the start index of an unsigned short value in {@link #b b},\n+     *        whose value is the index of an UTF8 constant pool item.\n+     * @param buf buffer to be used to read the item. This buffer must be\n+     *        sufficiently large. It is not automatically resized.\n+     * @return the String corresponding to the specified UTF8 item.\n+     */\n+    public String readUTF8(int index, final char[] buf) {\n+        int item = readUnsignedShort(index);\n+        String s = strings[item];\n+        if (s != null) {\n+            return s;\n+        }\n+        index = items[item];\n+        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);\n+    }\n+\n+    /**\n+     * Reads UTF8 string in {@link #b b}.\n+     * \n+     * @param index start offset of the UTF8 string to be read.\n+     * @param utfLen length of the UTF8 string to be read.\n+     * @param buf buffer to be used to read the string. This buffer must be\n+     *        sufficiently large. It is not automatically resized.\n+     * @return the String corresponding to the specified UTF8 string.\n+     */\n+    private String readUTF(int index, final int utfLen, final char[] buf) {\n+        int endIndex = index + utfLen;\n+        byte[] b = this.b;\n+        int strLen = 0;\n+        int c, d, e;\n+        while (index < endIndex) {\n+            c = b[index++] & 0xFF;\n+            switch (c >> 4) {\n+                case 0:\n+                case 1:\n+                case 2:\n+                case 3:\n+                case 4:\n+                case 5:\n+                case 6:\n+                case 7:\n+                    // 0xxxxxxx\n+                    buf[strLen++] = (char) c;\n+                    break;\n+                case 12:\n+                case 13:\n+                    // 110x xxxx 10xx xxxx\n+                    d = b[index++];\n+                    buf[strLen++] = (char) (((c & 0x1F) << 6) | (d & 0x3F));\n+                    break;\n+                default:\n+                    // 1110 xxxx 10xx xxxx 10xx xxxx\n+                    d = b[index++];\n+                    e = b[index++];\n+                    buf[strLen++] = (char) (((c & 0x0F) << 12)\n+                            | ((d & 0x3F) << 6) | (e & 0x3F));\n+                    break;\n+            }\n+        }\n+        return new String(buf, 0, strLen);\n+    }\n+\n+    /**\n+     * Reads a class constant pool item in {@link #b b}. <i>This method is\n+     * intended for {@link Attribute} sub classes, and is normally not needed by\n+     * class generators or adapters.</i>\n+     * \n+     * @param index the start index of an unsigned short value in {@link #b b},\n+     *        whose value is the index of a class constant pool item.\n+     * @param buf buffer to be used to read the item. This buffer must be\n+     *        sufficiently large. It is not automatically resized.\n+     * @return the String corresponding to the specified class item.\n+     */\n+    public String readClass(final int index, final char[] buf) {\n+        // computes the start index of the CONSTANT_Class item in b\n+        // and reads the CONSTANT_Utf8 item designated by\n+        // the first two bytes of this CONSTANT_Class item\n+        return readUTF8(items[readUnsignedShort(index)], buf);\n+    }\n+\n+    /**\n+     * Reads a numeric or string constant pool item in {@link #b b}. <i>This\n+     * method is intended for {@link Attribute} sub classes, and is normally not\n+     * needed by class generators or adapters.</i>\n+     * \n+     * @param item the index of a constant pool item.\n+     * @param buf buffer to be used to read the item. This buffer must be\n+     *        sufficiently large. It is not automatically resized.\n+     * @return the {@link Integer}, {@link Float}, {@link Long},\n+     *         {@link Double}, {@link String} or {@link Type} corresponding to\n+     *         the given constant pool item.\n+     */\n+    public Object readConst(final int item, final char[] buf) {\n+        int index = items[item];\n+        switch (b[index - 1]) {\n+            case ClassWriter.INT:\n+                return new Integer(readInt(index));\n+            case ClassWriter.FLOAT:\n+                return new Float(Float.intBitsToFloat(readInt(index)));\n+            case ClassWriter.LONG:\n+                return new Long(readLong(index));\n+            case ClassWriter.DOUBLE:\n+                return new Double(Double.longBitsToDouble(readLong(index)));\n+            case ClassWriter.CLASS:\n+                return Type.getObjectType(readUTF8(index, buf));\n+                // case ClassWriter.STR:\n+            default:\n+                return readUTF8(index, buf);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/ClassVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A visitor to visit a Java class. The methods of this interface must be called\n+ * in the following order: <tt>visit</tt> [ <tt>visitSource</tt> ] [\n+ * <tt>visitOuterClass</tt> ] ( <tt>visitAnnotation</tt> |\n+ * <tt>visitAttribute</tt> )* (<tt>visitInnerClass</tt> |\n+ * <tt>visitField</tt> | <tt>visitMethod</tt> )* <tt>visitEnd</tt>.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public interface ClassVisitor {\n+\n+    /**\n+     * Visits the header of the class.\n+     * \n+     * @param version the class version.\n+     * @param access the class's access flags (see {@link Opcodes}). This\n+     *        parameter also indicates if the class is deprecated.\n+     * @param name the internal name of the class (see\n+     *        {@link Type#getInternalName() getInternalName}).\n+     * @param signature the signature of this class. May be <tt>null</tt> if\n+     *        the class is not a generic one, and does not extend or implement\n+     *        generic classes or interfaces.\n+     * @param superName the internal of name of the super class (see\n+     *        {@link Type#getInternalName() getInternalName}). For interfaces,\n+     *        the super class is {@link Object}. May be <tt>null</tt>, but\n+     *        only for the {@link Object} class.\n+     * @param interfaces the internal names of the class's interfaces (see\n+     *        {@link Type#getInternalName() getInternalName}). May be\n+     *        <tt>null</tt>.\n+     */\n+    void visit(\n+        int version,\n+        int access,\n+        String name,\n+        String signature,\n+        String superName,\n+        String[] interfaces);\n+\n+    /**\n+     * Visits the source of the class.\n+     * \n+     * @param source the name of the source file from which the class was\n+     *        compiled. May be <tt>null</tt>.\n+     * @param debug additional debug information to compute the correspondance\n+     *        between source and compiled elements of the class. May be\n+     *        <tt>null</tt>.\n+     */\n+    void visitSource(String source, String debug);\n+\n+    /**\n+     * Visits the enclosing class of the class. This method must be called only\n+     * if the class has an enclosing class.\n+     * \n+     * @param owner internal name of the enclosing class of the class.\n+     * @param name the name of the method that contains the class, or\n+     *        <tt>null</tt> if the class is not enclosed in a method of its\n+     *        enclosing class.\n+     * @param desc the descriptor of the method that contains the class, or\n+     *        <tt>null</tt> if the class is not enclosed in a method of its\n+     *        enclosing class.\n+     */\n+    void visitOuterClass(String owner, String name, String desc);\n+\n+    /**\n+     * Visits an annotation of the class.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values, or <tt>null</tt> if\n+     *         this visitor is not interested in visiting this annotation.\n+     */\n+    AnnotationVisitor visitAnnotation(String desc, boolean visible);\n+\n+    /**\n+     * Visits a non standard attribute of the class.\n+     * \n+     * @param attr an attribute.\n+     */\n+    void visitAttribute(Attribute attr);\n+\n+    /**\n+     * Visits information about an inner class. This inner class is not\n+     * necessarily a member of the class being visited.\n+     * \n+     * @param name the internal name of an inner class (see\n+     *        {@link Type#getInternalName() getInternalName}).\n+     * @param outerName the internal name of the class to which the inner class\n+     *        belongs (see {@link Type#getInternalName() getInternalName}). May\n+     *        be <tt>null</tt> for not member classes.\n+     * @param innerName the (simple) name of the inner class inside its\n+     *        enclosing class. May be <tt>null</tt> for anonymous inner\n+     *        classes.\n+     * @param access the access flags of the inner class as originally declared\n+     *        in the enclosing class.\n+     */\n+    void visitInnerClass(\n+        String name,\n+        String outerName,\n+        String innerName,\n+        int access);\n+\n+    /**\n+     * Visits a field of the class.\n+     * \n+     * @param access the field's access flags (see {@link Opcodes}). This\n+     *        parameter also indicates if the field is synthetic and/or\n+     *        deprecated.\n+     * @param name the field's name.\n+     * @param desc the field's descriptor (see {@link Type Type}).\n+     * @param signature the field's signature. May be <tt>null</tt> if the\n+     *        field's type does not use generic types.\n+     * @param value the field's initial value. This parameter, which may be\n+     *        <tt>null</tt> if the field does not have an initial value, must\n+     *        be an {@link Integer}, a {@link Float}, a {@link Long}, a\n+     *        {@link Double} or a {@link String} (for <tt>int</tt>,\n+     *        <tt>float</tt>, <tt>long</tt> or <tt>String</tt> fields\n+     *        respectively). <i>This parameter is only used for static fields</i>.\n+     *        Its value is ignored for non static fields, which must be\n+     *        initialized through bytecode instructions in constructors or\n+     *        methods.\n+     * @return a visitor to visit field annotations and attributes, or\n+     *         <tt>null</tt> if this class visitor is not interested in\n+     *         visiting these annotations and attributes.\n+     */\n+    FieldVisitor visitField(\n+        int access,\n+        String name,\n+        String desc,\n+        String signature,\n+        Object value);\n+\n+    /**\n+     * Visits a method of the class. This method <i>must</i> return a new\n+     * {@link MethodVisitor} instance (or <tt>null</tt>) each time it is\n+     * called, i.e., it should not return a previously returned visitor.\n+     * \n+     * @param access the method's access flags (see {@link Opcodes}). This\n+     *        parameter also indicates if the method is synthetic and/or\n+     *        deprecated.\n+     * @param name the method's name.\n+     * @param desc the method's descriptor (see {@link Type Type}).\n+     * @param signature the method's signature. May be <tt>null</tt> if the\n+     *        method parameters, return type and exceptions do not use generic\n+     *        types.\n+     * @param exceptions the internal names of the method's exception classes\n+     *        (see {@link Type#getInternalName() getInternalName}). May be\n+     *        <tt>null</tt>.\n+     * @return an object to visit the byte code of the method, or <tt>null</tt>\n+     *         if this class visitor is not interested in visiting the code of\n+     *         this method.\n+     */\n+    MethodVisitor visitMethod(\n+        int access,\n+        String name,\n+        String desc,\n+        String signature,\n+        String[] exceptions);\n+\n+    /**\n+     * Visits the end of the class. This method, which is the last one to be\n+     * called, is used to inform the visitor that all the fields and methods of\n+     * the class have been visited.\n+     */\n+    void visitEnd();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/ClassWriter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A {@link ClassVisitor} that generates classes in bytecode form. More\n+ * precisely this visitor generates a byte array conforming to the Java class\n+ * file format. It can be used alone, to generate a Java class \"from scratch\",\n+ * or with one or more {@link ClassReader ClassReader} and adapter class visitor\n+ * to generate a modified class from one or more existing Java classes.\n+ *\n+ * @author Eric Bruneton\n+ */\n+public class ClassWriter implements ClassVisitor {\n+\n+    /**\n+     * Flag to automatically compute the maximum stack size and the maximum\n+     * number of local variables of methods. If this flag is set, then the\n+     * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the\n+     * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}\n+     * method will be ignored, and computed automatically from the signature and\n+     * the bytecode of each method.\n+     *\n+     * @see #ClassWriter(int)\n+     */\n+    public static final int COMPUTE_MAXS = 1;\n+\n+    /**\n+     * Flag to automatically compute the stack map frames of methods from\n+     * scratch. If this flag is set, then the calls to the\n+     * {@link MethodVisitor#visitFrame} method are ignored, and the stack map\n+     * frames are recomputed from the methods bytecode. The arguments of the\n+     * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and\n+     * recomputed from the bytecode. In other words, computeFrames implies\n+     * computeMaxs.\n+     *\n+     * @see #ClassWriter(int)\n+     */\n+    public static final int COMPUTE_FRAMES = 2;\n+\n+    /**\n+     * The type of instructions without any argument.\n+     */\n+    static final int NOARG_INSN = 0;\n+\n+    /**\n+     * The type of instructions with an signed byte argument.\n+     */\n+    static final int SBYTE_INSN = 1;\n+\n+    /**\n+     * The type of instructions with an signed short argument.\n+     */\n+    static final int SHORT_INSN = 2;\n+\n+    /**\n+     * The type of instructions with a local variable index argument.\n+     */\n+    static final int VAR_INSN = 3;\n+\n+    /**\n+     * The type of instructions with an implicit local variable index argument.\n+     */\n+    static final int IMPLVAR_INSN = 4;\n+\n+    /**\n+     * The type of instructions with a type descriptor argument.\n+     */\n+    static final int TYPE_INSN = 5;\n+\n+    /**\n+     * The type of field and method invocations instructions.\n+     */\n+    static final int FIELDORMETH_INSN = 6;\n+\n+    /**\n+     * The type of the INVOKEINTERFACE instruction.\n+     */\n+    static final int ITFMETH_INSN = 7;\n+\n+    /**\n+     * The type of instructions with a 2 bytes bytecode offset label.\n+     */\n+    static final int LABEL_INSN = 8;\n+\n+    /**\n+     * The type of instructions with a 4 bytes bytecode offset label.\n+     */\n+    static final int LABELW_INSN = 9;\n+\n+    /**\n+     * The type of the LDC instruction.\n+     */\n+    static final int LDC_INSN = 10;\n+\n+    /**\n+     * The type of the LDC_W and LDC2_W instructions.\n+     */\n+    static final int LDCW_INSN = 11;\n+\n+    /**\n+     * The type of the IINC instruction.\n+     */\n+    static final int IINC_INSN = 12;\n+\n+    /**\n+     * The type of the TABLESWITCH instruction.\n+     */\n+    static final int TABL_INSN = 13;\n+\n+    /**\n+     * The type of the LOOKUPSWITCH instruction.\n+     */\n+    static final int LOOK_INSN = 14;\n+\n+    /**\n+     * The type of the MULTIANEWARRAY instruction.\n+     */\n+    static final int MANA_INSN = 15;\n+\n+    /**\n+     * The type of the WIDE instruction.\n+     */\n+    static final int WIDE_INSN = 16;\n+\n+    /**\n+     * The instruction types of all JVM opcodes.\n+     */\n+    static final byte[] TYPE;\n+\n+    /**\n+     * The type of CONSTANT_Class constant pool items.\n+     */\n+    static final int CLASS = 7;\n+\n+    /**\n+     * The type of CONSTANT_Fieldref constant pool items.\n+     */\n+    static final int FIELD = 9;\n+\n+    /**\n+     * The type of CONSTANT_Methodref constant pool items.\n+     */\n+    static final int METH = 10;\n+\n+    /**\n+     * The type of CONSTANT_InterfaceMethodref constant pool items.\n+     */\n+    static final int IMETH = 11;\n+\n+    /**\n+     * The type of CONSTANT_String constant pool items.\n+     */\n+    static final int STR = 8;\n+\n+    /**\n+     * The type of CONSTANT_Integer constant pool items.\n+     */\n+    static final int INT = 3;\n+\n+    /**\n+     * The type of CONSTANT_Float constant pool items.\n+     */\n+    static final int FLOAT = 4;\n+\n+    /**\n+     * The type of CONSTANT_Long constant pool items.\n+     */\n+    static final int LONG = 5;\n+\n+    /**\n+     * The type of CONSTANT_Double constant pool items.\n+     */\n+    static final int DOUBLE = 6;\n+\n+    /**\n+     * The type of CONSTANT_NameAndType constant pool items.\n+     */\n+    static final int NAME_TYPE = 12;\n+\n+    /**\n+     * The type of CONSTANT_Utf8 constant pool items.\n+     */\n+    static final int UTF8 = 1;\n+\n+    /**\n+     * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n+     * instead of the constant pool, in order to avoid clashes with normal\n+     * constant pool items in the ClassWriter constant pool's hash table.\n+     */\n+    static final int TYPE_NORMAL = 13;\n+\n+    /**\n+     * Uninitialized type Item stored in the ClassWriter\n+     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n+     * avoid clashes with normal constant pool items in the ClassWriter constant\n+     * pool's hash table.\n+     */\n+    static final int TYPE_UNINIT = 14;\n+\n+    /**\n+     * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},\n+     * instead of the constant pool, in order to avoid clashes with normal\n+     * constant pool items in the ClassWriter constant pool's hash table.\n+     */\n+    static final int TYPE_MERGED = 15;\n+\n+    /**\n+     * The class reader from which this class writer was constructed, if any.\n+     */\n+    ClassReader cr;\n+\n+    /**\n+     * Minor and major version numbers of the class to be generated.\n+     */\n+    int version;\n+\n+    /**\n+     * Index of the next item to be added in the constant pool.\n+     */\n+    int index;\n+\n+    /**\n+     * The constant pool of this class.\n+     */\n+    final ByteVector pool;\n+\n+    /**\n+     * The constant pool's hash table data.\n+     */\n+    Item[] items;\n+\n+    /**\n+     * The threshold of the constant pool's hash table.\n+     */\n+    int threshold;\n+\n+    /**\n+     * A reusable key used to look for items in the {@link #items} hash table.\n+     */\n+    final Item key;\n+\n+    /**\n+     * A reusable key used to look for items in the {@link #items} hash table.\n+     */\n+    final Item key2;\n+\n+    /**\n+     * A reusable key used to look for items in the {@link #items} hash table.\n+     */\n+    final Item key3;\n+\n+    /**\n+     * A type table used to temporarily store internal names that will not\n+     * necessarily be stored in the constant pool. This type table is used by\n+     * the control flow and data flow analysis algorithm used to compute stack\n+     * map frames from scratch. This array associates to each index <tt>i</tt>\n+     * the Item whose index is <tt>i</tt>. All Item objects stored in this\n+     * array are also stored in the {@link #items} hash table. These two arrays\n+     * allow to retrieve an Item from its index or, conversely, to get the index\n+     * of an Item from its value. Each Item stores an internal name in its\n+     * {@link Item#strVal1} field.\n+     */\n+    Item[] typeTable;\n+\n+    /**\n+     * Number of elements in the {@link #typeTable} array.\n+     */\n+    private short typeCount;\n+\n+    /**\n+     * The access flags of this class.\n+     */\n+    private int access;\n+\n+    /**\n+     * The constant pool item that contains the internal name of this class.\n+     */\n+    private int name;\n+\n+    /**\n+     * The internal name of this class.\n+     */\n+    String thisName;\n+\n+    /**\n+     * The constant pool item that contains the signature of this class.\n+     */\n+    private int signature;\n+\n+    /**\n+     * The constant pool item that contains the internal name of the super class\n+     * of this class.\n+     */\n+    private int superName;\n+\n+    /**\n+     * Number of interfaces implemented or extended by this class or interface.\n+     */\n+    private int interfaceCount;\n+\n+    /**\n+     * The interfaces implemented or extended by this class or interface. More\n+     * precisely, this array contains the indexes of the constant pool items\n+     * that contain the internal names of these interfaces.\n+     */\n+    private int[] interfaces;\n+\n+    /**\n+     * The index of the constant pool item that contains the name of the source\n+     * file from which this class was compiled.\n+     */\n+    private int sourceFile;\n+\n+    /**\n+     * The SourceDebug attribute of this class.\n+     */\n+    private ByteVector sourceDebug;\n+\n+    /**\n+     * The constant pool item that contains the name of the enclosing class of\n+     * this class.\n+     */\n+    private int enclosingMethodOwner;\n+\n+    /**\n+     * The constant pool item that contains the name and descriptor of the\n+     * enclosing method of this class.\n+     */\n+    private int enclosingMethod;\n+\n+    /**\n+     * The runtime visible annotations of this class.\n+     */\n+    private AnnotationWriter anns;\n+\n+    /**\n+     * The runtime invisible annotations of this class.\n+     */\n+    private AnnotationWriter ianns;\n+\n+    /**\n+     * The non standard attributes of this class.\n+     */\n+    private Attribute attrs;\n+\n+    /**\n+     * The number of entries in the InnerClasses attribute.\n+     */\n+    private int innerClassesCount;\n+\n+    /**\n+     * The InnerClasses attribute.\n+     */\n+    private ByteVector innerClasses;\n+\n+    /**\n+     * The fields of this class. These fields are stored in a linked list of\n+     * {@link FieldWriter} objects, linked to each other by their\n+     * {@link FieldWriter#next} field. This field stores the first element of\n+     * this list.\n+     */\n+    FieldWriter firstField;\n+\n+    /**\n+     * The fields of this class. These fields are stored in a linked list of\n+     * {@link FieldWriter} objects, linked to each other by their\n+     * {@link FieldWriter#next} field. This field stores the last element of\n+     * this list.\n+     */\n+    FieldWriter lastField;\n+\n+    /**\n+     * The methods of this class. These methods are stored in a linked list of\n+     * {@link MethodWriter} objects, linked to each other by their\n+     * {@link MethodWriter#next} field. This field stores the first element of\n+     * this list.\n+     */\n+    MethodWriter firstMethod;\n+\n+    /**\n+     * The methods of this class. These methods are stored in a linked list of\n+     * {@link MethodWriter} objects, linked to each other by their\n+     * {@link MethodWriter#next} field. This field stores the last element of\n+     * this list.\n+     */\n+    MethodWriter lastMethod;\n+\n+    /**\n+     * <tt>true</tt> if the maximum stack size and number of local variables\n+     * must be automatically computed.\n+     */\n+    private final boolean computeMaxs;\n+\n+    /**\n+     * <tt>true</tt> if the stack map frames must be recomputed from scratch.\n+     */\n+    private final boolean computeFrames;\n+\n+    /**\n+     * <tt>true</tt> if the stack map tables of this class are invalid. The\n+     * {@link MethodWriter#resizeInstructions} method cannot transform existing\n+     * stack map tables, and so produces potentially invalid classes when it is\n+     * executed. In this case the class is reread and rewritten with the\n+     * {@link #COMPUTE_FRAMES} option (the resizeInstructions method can resize\n+     * stack map tables when this option is used).\n+     */\n+    boolean invalidFrames;\n+\n+    // ------------------------------------------------------------------------\n+    // Static initializer\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Computes the instruction types of JVM opcodes.\n+     */\n+    static {\n+        int i;\n+        byte[] b = new byte[220];\n+        String s = \"AAAAAAAAAAAAAAAABCKLLDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADD\"\n+                + \"DDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n+                + \"AAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAIIIIIIIIIIIIIIIIDNOAA\"\n+                + \"AAAAGGGGGGGHAFBFAAFFAAQPIIJJIIIIIIIIIIIIIIIIII\";\n+        for (i = 0; i < b.length; ++i) {\n+            b[i] = (byte) (s.charAt(i) - 'A');\n+        }\n+        TYPE = b;\n+\n+        // code to generate the above string\n+        //\n+        // // SBYTE_INSN instructions\n+        // b[Constants.NEWARRAY] = SBYTE_INSN;\n+        // b[Constants.BIPUSH] = SBYTE_INSN;\n+        //\n+        // // SHORT_INSN instructions\n+        // b[Constants.SIPUSH] = SHORT_INSN;\n+        //\n+        // // (IMPL)VAR_INSN instructions\n+        // b[Constants.RET] = VAR_INSN;\n+        // for (i = Constants.ILOAD; i <= Constants.ALOAD; ++i) {\n+        // b[i] = VAR_INSN;\n+        // }\n+        // for (i = Constants.ISTORE; i <= Constants.ASTORE; ++i) {\n+        // b[i] = VAR_INSN;\n+        // }\n+        // for (i = 26; i <= 45; ++i) { // ILOAD_0 to ALOAD_3\n+        // b[i] = IMPLVAR_INSN;\n+        // }\n+        // for (i = 59; i <= 78; ++i) { // ISTORE_0 to ASTORE_3\n+        // b[i] = IMPLVAR_INSN;\n+        // }\n+        //\n+        // // TYPE_INSN instructions\n+        // b[Constants.NEW] = TYPE_INSN;\n+        // b[Constants.ANEWARRAY] = TYPE_INSN;\n+        // b[Constants.CHECKCAST] = TYPE_INSN;\n+        // b[Constants.INSTANCEOF] = TYPE_INSN;\n+        //\n+        // // (Set)FIELDORMETH_INSN instructions\n+        // for (i = Constants.GETSTATIC; i <= Constants.INVOKESTATIC; ++i) {\n+        // b[i] = FIELDORMETH_INSN;\n+        // }\n+        // b[Constants.INVOKEINTERFACE] = ITFMETH_INSN;\n+        //\n+        // // LABEL(W)_INSN instructions\n+        // for (i = Constants.IFEQ; i <= Constants.JSR; ++i) {\n+        // b[i] = LABEL_INSN;\n+        // }\n+        // b[Constants.IFNULL] = LABEL_INSN;\n+        // b[Constants.IFNONNULL] = LABEL_INSN;\n+        // b[200] = LABELW_INSN; // GOTO_W\n+        // b[201] = LABELW_INSN; // JSR_W\n+        // // temporary opcodes used internally by ASM - see Label and\n+        // MethodWriter\n+        // for (i = 202; i < 220; ++i) {\n+        // b[i] = LABEL_INSN;\n+        // }\n+        //\n+        // // LDC(_W) instructions\n+        // b[Constants.LDC] = LDC_INSN;\n+        // b[19] = LDCW_INSN; // LDC_W\n+        // b[20] = LDCW_INSN; // LDC2_W\n+        //\n+        // // special instructions\n+        // b[Constants.IINC] = IINC_INSN;\n+        // b[Constants.TABLESWITCH] = TABL_INSN;\n+        // b[Constants.LOOKUPSWITCH] = LOOK_INSN;\n+        // b[Constants.MULTIANEWARRAY] = MANA_INSN;\n+        // b[196] = WIDE_INSN; // WIDE\n+        //\n+        // for (i = 0; i < b.length; ++i) {\n+        // System.err.print((char)('A' + b[i]));\n+        // }\n+        // System.err.println();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new {@link ClassWriter} object.\n+     *\n+     * @param flags option flags that can be used to modify the default behavior\n+     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n+     */\n+    public ClassWriter(final int flags) {\n+        index = 1;\n+        pool = new ByteVector();\n+        items = new Item[256];\n+        threshold = (int) (0.75d * items.length);\n+        key = new Item();\n+        key2 = new Item();\n+        key3 = new Item();\n+        this.computeMaxs = (flags & COMPUTE_MAXS) != 0;\n+        this.computeFrames = (flags & COMPUTE_FRAMES) != 0;\n+    }\n+\n+    /**\n+     * Constructs a new {@link ClassWriter} object and enables optimizations for\n+     * \"mostly add\" bytecode transformations. These optimizations are the\n+     * following:\n+     *\n+     * <ul> <li>The constant pool from the original class is copied as is in\n+     * the new class, which saves time. New constant pool entries will be added\n+     * at the end if necessary, but unused constant pool entries <i>won't be\n+     * removed</i>.</li> <li>Methods that are not transformed are copied as\n+     * is in the new class, directly from the original class bytecode (i.e.\n+     * without emitting visit events for all the method instructions), which\n+     * saves a <i>lot</i> of time. Untransformed methods are detected by the\n+     * fact that the {@link ClassReader} receives {@link MethodVisitor} objects\n+     * that come from a {@link ClassWriter} (and not from a custom\n+     * {@link ClassAdapter} or any other {@link ClassVisitor} instance).</li>\n+     * </ul>\n+     *\n+     * @param classReader the {@link ClassReader} used to read the original\n+     *        class. It will be used to copy the entire constant pool from the\n+     *        original class and also to copy other fragments of original\n+     *        bytecode where applicable.\n+     * @param flags option flags that can be used to modify the default behavior\n+     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n+     */\n+    public ClassWriter(final ClassReader classReader, final int flags) {\n+        this(flags);\n+        classReader.copyPool(this);\n+        this.cr = classReader;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the ClassVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(\n+        final int version,\n+        final int access,\n+        final String name,\n+        final String signature,\n+        final String superName,\n+        final String[] interfaces)\n+    {\n+        this.version = version;\n+        this.access = access;\n+        this.name = newClass(name);\n+        thisName = name;\n+        if (ClassReader.SIGNATURES && signature != null) {\n+            this.signature = newUTF8(signature);\n+        }\n+        this.superName = superName == null ? 0 : newClass(superName);\n+        if (interfaces != null && interfaces.length > 0) {\n+            interfaceCount = interfaces.length;\n+            this.interfaces = new int[interfaceCount];\n+            for (int i = 0; i < interfaceCount; ++i) {\n+                this.interfaces[i] = newClass(interfaces[i]);\n+            }\n+        }\n+    }\n+\n+    public void visitSource(final String file, final String debug) {\n+        if (file != null) {\n+            sourceFile = newUTF8(file);\n+        }\n+        if (debug != null) {\n+            sourceDebug = new ByteVector().putUTF8(debug);\n+        }\n+    }\n+\n+    public void visitOuterClass(\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        enclosingMethodOwner = newClass(owner);\n+        if (name != null && desc != null) {\n+            enclosingMethod = newNameType(name, desc);\n+        }\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        if (!ClassReader.ANNOTATIONS) {\n+            return null;\n+        }\n+        ByteVector bv = new ByteVector();\n+        // write type, and reserve space for values count\n+        bv.putShort(newUTF8(desc)).putShort(0);\n+        AnnotationWriter aw = new AnnotationWriter(this, true, bv, bv, 2);\n+        if (visible) {\n+            aw.next = anns;\n+            anns = aw;\n+        } else {\n+            aw.next = ianns;\n+            ianns = aw;\n+        }\n+        return aw;\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        attr.next = attrs;\n+        attrs = attr;\n+    }\n+\n+    public void visitInnerClass(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        if (innerClasses == null) {\n+            innerClasses = new ByteVector();\n+        }\n+        ++innerClassesCount;\n+        innerClasses.putShort(name == null ? 0 : newClass(name));\n+        innerClasses.putShort(outerName == null ? 0 : newClass(outerName));\n+        innerClasses.putShort(innerName == null ? 0 : newUTF8(innerName));\n+        innerClasses.putShort(access);\n+    }\n+\n+    public FieldVisitor visitField(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        return new FieldWriter(this, access, name, desc, signature, value);\n+    }\n+\n+    public MethodVisitor visitMethod(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        return new MethodWriter(this,\n+                access,\n+                name,\n+                desc,\n+                signature,\n+                exceptions,\n+                computeMaxs,\n+                computeFrames);\n+    }\n+\n+    public void visitEnd() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Other public methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the bytecode of the class that was build with this class writer.\n+     *\n+     * @return the bytecode of the class that was build with this class writer.\n+     */\n+    public byte[] toByteArray() {\n+        // computes the real size of the bytecode of this class\n+        int size = 24 + 2 * interfaceCount;\n+        int nbFields = 0;\n+        FieldWriter fb = firstField;\n+        while (fb != null) {\n+            ++nbFields;\n+            size += fb.getSize();\n+            fb = fb.next;\n+        }\n+        int nbMethods = 0;\n+        MethodWriter mb = firstMethod;\n+        while (mb != null) {\n+            ++nbMethods;\n+            size += mb.getSize();\n+            mb = mb.next;\n+        }\n+        int attributeCount = 0;\n+        if (ClassReader.SIGNATURES && signature != 0) {\n+            ++attributeCount;\n+            size += 8;\n+            newUTF8(\"Signature\");\n+        }\n+        if (sourceFile != 0) {\n+            ++attributeCount;\n+            size += 8;\n+            newUTF8(\"SourceFile\");\n+        }\n+        if (sourceDebug != null) {\n+            ++attributeCount;\n+            size += sourceDebug.length + 4;\n+            newUTF8(\"SourceDebugExtension\");\n+        }\n+        if (enclosingMethodOwner != 0) {\n+            ++attributeCount;\n+            size += 10;\n+            newUTF8(\"EnclosingMethod\");\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            ++attributeCount;\n+            size += 6;\n+            newUTF8(\"Deprecated\");\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (version & 0xffff) < Opcodes.V1_5)\n+        {\n+            ++attributeCount;\n+            size += 6;\n+            newUTF8(\"Synthetic\");\n+        }\n+        if (innerClasses != null) {\n+            ++attributeCount;\n+            size += 8 + innerClasses.length;\n+            newUTF8(\"InnerClasses\");\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            ++attributeCount;\n+            size += 8 + anns.getSize();\n+            newUTF8(\"RuntimeVisibleAnnotations\");\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            ++attributeCount;\n+            size += 8 + ianns.getSize();\n+            newUTF8(\"RuntimeInvisibleAnnotations\");\n+        }\n+        if (attrs != null) {\n+            attributeCount += attrs.getCount();\n+            size += attrs.getSize(this, null, 0, -1, -1);\n+        }\n+        size += pool.length;\n+        // allocates a byte vector of this size, in order to avoid unnecessary\n+        // arraycopy operations in the ByteVector.enlarge() method\n+        ByteVector out = new ByteVector(size);\n+        out.putInt(0xCAFEBABE).putInt(version);\n+        out.putShort(index).putByteArray(pool.data, 0, pool.length);\n+        out.putShort(access).putShort(name).putShort(superName);\n+        out.putShort(interfaceCount);\n+        for (int i = 0; i < interfaceCount; ++i) {\n+            out.putShort(interfaces[i]);\n+        }\n+        out.putShort(nbFields);\n+        fb = firstField;\n+        while (fb != null) {\n+            fb.put(out);\n+            fb = fb.next;\n+        }\n+        out.putShort(nbMethods);\n+        mb = firstMethod;\n+        while (mb != null) {\n+            mb.put(out);\n+            mb = mb.next;\n+        }\n+        out.putShort(attributeCount);\n+        if (ClassReader.SIGNATURES && signature != 0) {\n+            out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\n+        }\n+        if (sourceFile != 0) {\n+            out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\n+        }\n+        if (sourceDebug != null) {\n+            int len = sourceDebug.length - 2;\n+            out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\n+            out.putByteArray(sourceDebug.data, 2, len);\n+        }\n+        if (enclosingMethodOwner != 0) {\n+            out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\n+            out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            out.putShort(newUTF8(\"Deprecated\")).putInt(0);\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (version & 0xffff) < Opcodes.V1_5)\n+        {\n+            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\n+        }\n+        if (innerClasses != null) {\n+            out.putShort(newUTF8(\"InnerClasses\"));\n+            out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\n+            out.putByteArray(innerClasses.data, 0, innerClasses.length);\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\n+            anns.put(out);\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\n+            ianns.put(out);\n+        }\n+        if (attrs != null) {\n+            attrs.put(this, null, 0, -1, -1, out);\n+        }\n+        if (invalidFrames) {\n+            ClassWriter cw = new ClassWriter(COMPUTE_FRAMES);\n+            new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES);\n+            return cw.toByteArray();\n+        }\n+        return out.data;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: constant pool management\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Adds a number or string constant to the constant pool of the class being\n+     * build. Does nothing if the constant pool already contains a similar item.\n+     *\n+     * @param cst the value of the constant to be added to the constant pool.\n+     *        This parameter must be an {@link Integer}, a {@link Float}, a\n+     *        {@link Long}, a {@link Double}, a {@link String} or a\n+     *        {@link Type}.\n+     * @return a new or already existing constant item with the given value.\n+     */\n+    Item newConstItem(final Object cst) {\n+        if (cst instanceof Integer) {\n+            int val = ((Integer) cst).intValue();\n+            return newInteger(val);\n+        } else if (cst instanceof Byte) {\n+            int val = ((Byte) cst).intValue();\n+            return newInteger(val);\n+        } else if (cst instanceof Character) {\n+            int val = ((Character) cst).charValue();\n+            return newInteger(val);\n+        } else if (cst instanceof Short) {\n+            int val = ((Short) cst).intValue();\n+            return newInteger(val);\n+        } else if (cst instanceof Boolean) {\n+            int val = ((Boolean) cst).booleanValue() ? 1 : 0;\n+            return newInteger(val);\n+        } else if (cst instanceof Float) {\n+            float val = ((Float) cst).floatValue();\n+            return newFloat(val);\n+        } else if (cst instanceof Long) {\n+            long val = ((Long) cst).longValue();\n+            return newLong(val);\n+        } else if (cst instanceof Double) {\n+            double val = ((Double) cst).doubleValue();\n+            return newDouble(val);\n+        } else if (cst instanceof String) {\n+            return newString((String) cst);\n+        } else if (cst instanceof Type) {\n+            Type t = (Type) cst;\n+            return newClassItem(t.getSort() == Type.OBJECT\n+                    ? t.getInternalName()\n+                    : t.getDescriptor());\n+        } else {\n+            throw new IllegalArgumentException(\"value \" + cst);\n+        }\n+    }\n+\n+    /**\n+     * Adds a number or string constant to the constant pool of the class being\n+     * build. Does nothing if the constant pool already contains a similar item.\n+     * <i>This method is intended for {@link Attribute} sub classes, and is\n+     * normally not needed by class generators or adapters.</i>\n+     *\n+     * @param cst the value of the constant to be added to the constant pool.\n+     *        This parameter must be an {@link Integer}, a {@link Float}, a\n+     *        {@link Long}, a {@link Double} or a {@link String}.\n+     * @return the index of a new or already existing constant item with the\n+     *         given value.\n+     */\n+    public int newConst(final Object cst) {\n+        return newConstItem(cst).index;\n+    }\n+\n+    /**\n+     * Adds an UTF8 string to the constant pool of the class being build. Does\n+     * nothing if the constant pool already contains a similar item. <i>This\n+     * method is intended for {@link Attribute} sub classes, and is normally not\n+     * needed by class generators or adapters.</i>\n+     *\n+     * @param value the String value.\n+     * @return the index of a new or already existing UTF8 item.\n+     */\n+    public int newUTF8(final String value) {\n+        key.set(UTF8, value, null, null);\n+        Item result = get(key);\n+        if (result == null) {\n+            pool.putByte(UTF8).putUTF8(value);\n+            result = new Item(index++, key);\n+            put(result);\n+        }\n+        return result.index;\n+    }\n+\n+    /**\n+     * Adds a class reference to the constant pool of the class being build.\n+     * Does nothing if the constant pool already contains a similar item.\n+     * <i>This method is intended for {@link Attribute} sub classes, and is\n+     * normally not needed by class generators or adapters.</i>\n+     *\n+     * @param value the internal name of the class.\n+     * @return a new or already existing class reference item.\n+     */\n+    Item newClassItem(final String value) {\n+        key2.set(CLASS, value, null, null);\n+        Item result = get(key2);\n+        if (result == null) {\n+            pool.put12(CLASS, newUTF8(value));\n+            result = new Item(index++, key2);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a class reference to the constant pool of the class being build.\n+     * Does nothing if the constant pool already contains a similar item.\n+     * <i>This method is intended for {@link Attribute} sub classes, and is\n+     * normally not needed by class generators or adapters.</i>\n+     *\n+     * @param value the internal name of the class.\n+     * @return the index of a new or already existing class reference item.\n+     */\n+    public int newClass(final String value) {\n+        return newClassItem(value).index;\n+    }\n+\n+    /**\n+     * Adds a field reference to the constant pool of the class being build.\n+     * Does nothing if the constant pool already contains a similar item.\n+     *\n+     * @param owner the internal name of the field's owner class.\n+     * @param name the field's name.\n+     * @param desc the field's descriptor.\n+     * @return a new or already existing field reference item.\n+     */\n+    Item newFieldItem(final String owner, final String name, final String desc)\n+    {\n+        key3.set(FIELD, owner, name, desc);\n+        Item result = get(key3);\n+        if (result == null) {\n+            put122(FIELD, newClass(owner), newNameType(name, desc));\n+            result = new Item(index++, key3);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a field reference to the constant pool of the class being build.\n+     * Does nothing if the constant pool already contains a similar item.\n+     * <i>This method is intended for {@link Attribute} sub classes, and is\n+     * normally not needed by class generators or adapters.</i>\n+     *\n+     * @param owner the internal name of the field's owner class.\n+     * @param name the field's name.\n+     * @param desc the field's descriptor.\n+     * @return the index of a new or already existing field reference item.\n+     */\n+    public int newField(final String owner, final String name, final String desc)\n+    {\n+        return newFieldItem(owner, name, desc).index;\n+    }\n+\n+    /**\n+     * Adds a method reference to the constant pool of the class being build.\n+     * Does nothing if the constant pool already contains a similar item.\n+     *\n+     * @param owner the internal name of the method's owner class.\n+     * @param name the method's name.\n+     * @param desc the method's descriptor.\n+     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n+     * @return a new or already existing method reference item.\n+     */\n+    Item newMethodItem(\n+        final String owner,\n+        final String name,\n+        final String desc,\n+        final boolean itf)\n+    {\n+        int type = itf ? IMETH : METH;\n+        key3.set(type, owner, name, desc);\n+        Item result = get(key3);\n+        if (result == null) {\n+            put122(type, newClass(owner), newNameType(name, desc));\n+            result = new Item(index++, key3);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a method reference to the constant pool of the class being build.\n+     * Does nothing if the constant pool already contains a similar item.\n+     * <i>This method is intended for {@link Attribute} sub classes, and is\n+     * normally not needed by class generators or adapters.</i>\n+     *\n+     * @param owner the internal name of the method's owner class.\n+     * @param name the method's name.\n+     * @param desc the method's descriptor.\n+     * @param itf <tt>true</tt> if <tt>owner</tt> is an interface.\n+     * @return the index of a new or already existing method reference item.\n+     */\n+    public int newMethod(\n+        final String owner,\n+        final String name,\n+        final String desc,\n+        final boolean itf)\n+    {\n+        return newMethodItem(owner, name, desc, itf).index;\n+    }\n+\n+    /**\n+     * Adds an integer to the constant pool of the class being build. Does\n+     * nothing if the constant pool already contains a similar item.\n+     *\n+     * @param value the int value.\n+     * @return a new or already existing int item.\n+     */\n+    Item newInteger(final int value) {\n+        key.set(value);\n+        Item result = get(key);\n+        if (result == null) {\n+            pool.putByte(INT).putInt(value);\n+            result = new Item(index++, key);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a float to the constant pool of the class being build. Does nothing\n+     * if the constant pool already contains a similar item.\n+     *\n+     * @param value the float value.\n+     * @return a new or already existing float item.\n+     */\n+    Item newFloat(final float value) {\n+        key.set(value);\n+        Item result = get(key);\n+        if (result == null) {\n+            pool.putByte(FLOAT).putInt(key.intVal);\n+            result = new Item(index++, key);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a long to the constant pool of the class being build. Does nothing\n+     * if the constant pool already contains a similar item.\n+     *\n+     * @param value the long value.\n+     * @return a new or already existing long item.\n+     */\n+    Item newLong(final long value) {\n+        key.set(value);\n+        Item result = get(key);\n+        if (result == null) {\n+            pool.putByte(LONG).putLong(value);\n+            result = new Item(index, key);\n+            put(result);\n+            index += 2;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a double to the constant pool of the class being build. Does nothing\n+     * if the constant pool already contains a similar item.\n+     *\n+     * @param value the double value.\n+     * @return a new or already existing double item.\n+     */\n+    Item newDouble(final double value) {\n+        key.set(value);\n+        Item result = get(key);\n+        if (result == null) {\n+            pool.putByte(DOUBLE).putLong(key.longVal);\n+            result = new Item(index, key);\n+            put(result);\n+            index += 2;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a string to the constant pool of the class being build. Does nothing\n+     * if the constant pool already contains a similar item.\n+     *\n+     * @param value the String value.\n+     * @return a new or already existing string item.\n+     */\n+    private Item newString(final String value) {\n+        key2.set(STR, value, null, null);\n+        Item result = get(key2);\n+        if (result == null) {\n+            pool.put12(STR, newUTF8(value));\n+            result = new Item(index++, key2);\n+            put(result);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Adds a name and type to the constant pool of the class being build. Does\n+     * nothing if the constant pool already contains a similar item. <i>This\n+     * method is intended for {@link Attribute} sub classes, and is normally not\n+     * needed by class generators or adapters.</i>\n+     *\n+     * @param name a name.\n+     * @param desc a type descriptor.\n+     * @return the index of a new or already existing name and type item.\n+     */\n+    public int newNameType(final String name, final String desc) {\n+        key2.set(NAME_TYPE, name, desc, null);\n+        Item result = get(key2);\n+        if (result == null) {\n+            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\n+            result = new Item(index++, key2);\n+            put(result);\n+        }\n+        return result.index;\n+    }\n+\n+    /**\n+     * Adds the given internal name to {@link #typeTable} and returns its index.\n+     * Does nothing if the type table already contains this internal name.\n+     *\n+     * @param type the internal name to be added to the type table.\n+     * @return the index of this internal name in the type table.\n+     */\n+    int addType(final String type) {\n+        key.set(TYPE_NORMAL, type, null, null);\n+        Item result = get(key);\n+        if (result == null) {\n+            result = addType(key);\n+        }\n+        return result.index;\n+    }\n+\n+    /**\n+     * Adds the given \"uninitialized\" type to {@link #typeTable} and returns its\n+     * index. This method is used for UNINITIALIZED types, made of an internal\n+     * name and a bytecode offset.\n+     *\n+     * @param type the internal name to be added to the type table.\n+     * @param offset the bytecode offset of the NEW instruction that created\n+     *        this UNINITIALIZED type value.\n+     * @return the index of this internal name in the type table.\n+     */\n+    int addUninitializedType(final String type, final int offset) {\n+        key.type = TYPE_UNINIT;\n+        key.intVal = offset;\n+        key.strVal1 = type;\n+        key.hashCode = 0x7FFFFFFF & (TYPE_UNINIT + type.hashCode() + offset);\n+        Item result = get(key);\n+        if (result == null) {\n+            result = addType(key);\n+        }\n+        return result.index;\n+    }\n+\n+    /**\n+     * Adds the given Item to {@link #typeTable}.\n+     *\n+     * @param item the value to be added to the type table.\n+     * @return the added Item, which a new Item instance with the same value as\n+     *         the given Item.\n+     */\n+    private Item addType(final Item item) {\n+        ++typeCount;\n+        Item result = new Item(typeCount, key);\n+        put(result);\n+        if (typeTable == null) {\n+            typeTable = new Item[16];\n+        }\n+        if (typeCount == typeTable.length) {\n+            Item[] newTable = new Item[2 * typeTable.length];\n+            System.arraycopy(typeTable, 0, newTable, 0, typeTable.length);\n+            typeTable = newTable;\n+        }\n+        typeTable[typeCount] = result;\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the index of the common super type of the two given types. This\n+     * method calls {@link #getCommonSuperClass} and caches the result in the\n+     * {@link #items} hash table to speedup future calls with the same\n+     * parameters.\n+     *\n+     * @param type1 index of an internal name in {@link #typeTable}.\n+     * @param type2 index of an internal name in {@link #typeTable}.\n+     * @return the index of the common super type of the two given types.\n+     */\n+    int getMergedType(final int type1, final int type2) {\n+        key2.type = TYPE_MERGED;\n+        key2.longVal = type1 | (((long) type2) << 32);\n+        key2.hashCode = 0x7FFFFFFF & (TYPE_MERGED + type1 + type2);\n+        Item result = get(key2);\n+        if (result == null) {\n+            String t = typeTable[type1].strVal1;\n+            String u = typeTable[type2].strVal1;\n+            key2.intVal = addType(getCommonSuperClass(t, u));\n+            result = new Item((short) 0, key2);\n+            put(result);\n+        }\n+        return result.intVal;\n+    }\n+\n+    /**\n+     * Returns the common super type of the two given types. The default\n+     * implementation of this method <i>loads<i> the two given classes and uses\n+     * the java.lang.Class methods to find the common super class. It can be\n+     * overridden to compute this common super type in other ways, in particular\n+     * without actually loading any class, or to take into account the class\n+     * that is currently being generated by this ClassWriter, which can of\n+     * course not be loaded since it is under construction.\n+     *\n+     * @param type1 the internal name of a class.\n+     * @param type2 the internal name of another class.\n+     * @return the internal name of the common super class of the two given\n+     *         classes.\n+     */\n+    protected String getCommonSuperClass(final String type1, final String type2)\n+    {\n+        Class c, d;\n+        try {\n+            c = Class.forName(type1.replace('/', '.'));\n+            d = Class.forName(type2.replace('/', '.'));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e.toString());\n+        }\n+        if (c.isAssignableFrom(d)) {\n+            return type1;\n+        }\n+        if (d.isAssignableFrom(c)) {\n+            return type2;\n+        }\n+        if (c.isInterface() || d.isInterface()) {\n+            return \"java/lang/Object\";\n+        } else {\n+            do {\n+                c = c.getSuperclass();\n+            } while (!c.isAssignableFrom(d));\n+            return c.getName().replace('.', '/');\n+        }\n+    }\n+\n+    /**\n+     * Returns the constant pool's hash table item which is equal to the given\n+     * item.\n+     *\n+     * @param key a constant pool item.\n+     * @return the constant pool's hash table item which is equal to the given\n+     *         item, or <tt>null</tt> if there is no such item.\n+     */\n+    private Item get(final Item key) {\n+        Item i = items[key.hashCode % items.length];\n+        while (i != null && !key.isEqualTo(i)) {\n+            i = i.next;\n+        }\n+        return i;\n+    }\n+\n+    /**\n+     * Puts the given item in the constant pool's hash table. The hash table\n+     * <i>must</i> not already contains this item.\n+     *\n+     * @param i the item to be added to the constant pool's hash table.\n+     */\n+    private void put(final Item i) {\n+        if (index > threshold) {\n+            int ll = items.length;\n+            int nl = ll * 2 + 1;\n+            Item[] newItems = new Item[nl];\n+            for (int l = ll - 1; l >= 0; --l) {\n+                Item j = items[l];\n+                while (j != null) {\n+                    int index = j.hashCode % newItems.length;\n+                    Item k = j.next;\n+                    j.next = newItems[index];\n+                    newItems[index] = j;\n+                    j = k;\n+                }\n+            }\n+            items = newItems;\n+            threshold = (int) (nl * 0.75);\n+        }\n+        int index = i.hashCode % items.length;\n+        i.next = items[index];\n+        items[index] = i;\n+    }\n+\n+    /**\n+     * Puts one byte and two shorts into the constant pool.\n+     *\n+     * @param b a byte.\n+     * @param s1 a short.\n+     * @param s2 another short.\n+     */\n+    private void put122(final int b, final int s1, final int s2) {\n+        pool.put12(b, s1).putShort(s2);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Edge.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * An edge in the control flow graph of a method body. See {@link Label Label}.\n+ * \n+ * @author Eric Bruneton\n+ */\n+class Edge {\n+\n+    /**\n+     * Denotes a normal control flow graph edge.\n+     */\n+    static final int NORMAL = 0;\n+\n+    /**\n+     * Denotes a control flow graph edge corresponding to an exception handler.\n+     * More precisely any {@link Edge} whose {@link #info} is strictly positive\n+     * corresponds to an exception handler. The actual value of {@link #info} is\n+     * the index, in the {@link ClassWriter} type table, of the exception that\n+     * is catched.\n+     */\n+    static final int EXCEPTION = 0x7FFFFFFF;\n+\n+    /**\n+     * Information about this control flow graph edge. If\n+     * {@link ClassWriter#COMPUTE_MAXS} is used this field is the (relative)\n+     * stack size in the basic block from which this edge originates. This size\n+     * is equal to the stack size at the \"jump\" instruction to which this edge\n+     * corresponds, relatively to the stack size at the beginning of the\n+     * originating basic block. If {@link ClassWriter#COMPUTE_FRAMES} is used,\n+     * this field is the kind of this control flow graph edge (i.e. NORMAL or\n+     * EXCEPTION).\n+     */\n+    int info;\n+\n+    /**\n+     * The successor block of the basic block from which this edge originates.\n+     */\n+    Label successor;\n+\n+    /**\n+     * The next edge in the list of successors of the originating basic block.\n+     * See {@link Label#successors successors}.\n+     */\n+    Edge next;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/FieldVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A visitor to visit a Java field. The methods of this interface must be called\n+ * in the following order: ( <tt>visitAnnotation</tt> |\n+ * <tt>visitAttribute</tt> )* <tt>visitEnd</tt>.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public interface FieldVisitor {\n+\n+    /**\n+     * Visits an annotation of the field.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values, or <tt>null</tt> if\n+     *         this visitor is not interested in visiting this annotation.\n+     */\n+    AnnotationVisitor visitAnnotation(String desc, boolean visible);\n+\n+    /**\n+     * Visits a non standard attribute of the field.\n+     * \n+     * @param attr an attribute.\n+     */\n+    void visitAttribute(Attribute attr);\n+\n+    /**\n+     * Visits the end of the field. This method, which is the last one to be\n+     * called, is used to inform the visitor that all the annotations and\n+     * attributes of the field have been visited.\n+     */\n+    void visitEnd();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/FieldWriter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * An {@link FieldVisitor} that generates Java fields in bytecode form.\n+ * \n+ * @author Eric Bruneton\n+ */\n+final class FieldWriter implements FieldVisitor {\n+\n+    /**\n+     * Next field writer (see {@link ClassWriter#firstField firstField}).\n+     */\n+    FieldWriter next;\n+\n+    /**\n+     * The class writer to which this field must be added.\n+     */\n+    private final ClassWriter cw;\n+\n+    /**\n+     * Access flags of this field.\n+     */\n+    private final int access;\n+\n+    /**\n+     * The index of the constant pool item that contains the name of this\n+     * method.\n+     */\n+    private final int name;\n+\n+    /**\n+     * The index of the constant pool item that contains the descriptor of this\n+     * field.\n+     */\n+    private final int desc;\n+\n+    /**\n+     * The index of the constant pool item that contains the signature of this\n+     * field.\n+     */\n+    private int signature;\n+\n+    /**\n+     * The index of the constant pool item that contains the constant value of\n+     * this field.\n+     */\n+    private int value;\n+\n+    /**\n+     * The runtime visible annotations of this field. May be <tt>null</tt>.\n+     */\n+    private AnnotationWriter anns;\n+\n+    /**\n+     * The runtime invisible annotations of this field. May be <tt>null</tt>.\n+     */\n+    private AnnotationWriter ianns;\n+\n+    /**\n+     * The non standard attributes of this field. May be <tt>null</tt>.\n+     */\n+    private Attribute attrs;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new {@link FieldWriter}.\n+     * \n+     * @param cw the class writer to which this field must be added.\n+     * @param access the field's access flags (see {@link Opcodes}).\n+     * @param name the field's name.\n+     * @param desc the field's descriptor (see {@link Type}).\n+     * @param signature the field's signature. May be <tt>null</tt>.\n+     * @param value the field's constant value. May be <tt>null</tt>.\n+     */\n+    FieldWriter(\n+        final ClassWriter cw,\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        if (cw.firstField == null) {\n+            cw.firstField = this;\n+        } else {\n+            cw.lastField.next = this;\n+        }\n+        cw.lastField = this;\n+        this.cw = cw;\n+        this.access = access;\n+        this.name = cw.newUTF8(name);\n+        this.desc = cw.newUTF8(desc);\n+        if (ClassReader.SIGNATURES && signature != null) {\n+            this.signature = cw.newUTF8(signature);\n+        }\n+        if (value != null) {\n+            this.value = cw.newConstItem(value).index;\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the FieldVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        if (!ClassReader.ANNOTATIONS) {\n+            return null;\n+        }\n+        ByteVector bv = new ByteVector();\n+        // write type, and reserve space for values count\n+        bv.putShort(cw.newUTF8(desc)).putShort(0);\n+        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n+        if (visible) {\n+            aw.next = anns;\n+            anns = aw;\n+        } else {\n+            aw.next = ianns;\n+            ianns = aw;\n+        }\n+        return aw;\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        attr.next = attrs;\n+        attrs = attr;\n+    }\n+\n+    public void visitEnd() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the size of this field.\n+     * \n+     * @return the size of this field.\n+     */\n+    int getSize() {\n+        int size = 8;\n+        if (value != 0) {\n+            cw.newUTF8(\"ConstantValue\");\n+            size += 8;\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (cw.version & 0xffff) < Opcodes.V1_5)\n+        {\n+            cw.newUTF8(\"Synthetic\");\n+            size += 6;\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            cw.newUTF8(\"Deprecated\");\n+            size += 6;\n+        }\n+        if (ClassReader.SIGNATURES && signature != 0) {\n+            cw.newUTF8(\"Signature\");\n+            size += 8;\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            cw.newUTF8(\"RuntimeVisibleAnnotations\");\n+            size += 8 + anns.getSize();\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            cw.newUTF8(\"RuntimeInvisibleAnnotations\");\n+            size += 8 + ianns.getSize();\n+        }\n+        if (attrs != null) {\n+            size += attrs.getSize(cw, null, 0, -1, -1);\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Puts the content of this field into the given byte vector.\n+     * \n+     * @param out where the content of this field must be put.\n+     */\n+    void put(final ByteVector out) {\n+        out.putShort(access).putShort(name).putShort(desc);\n+        int attributeCount = 0;\n+        if (value != 0) {\n+            ++attributeCount;\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (cw.version & 0xffff) < Opcodes.V1_5)\n+        {\n+            ++attributeCount;\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.SIGNATURES && signature != 0) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            ++attributeCount;\n+        }\n+        if (attrs != null) {\n+            attributeCount += attrs.getCount();\n+        }\n+        out.putShort(attributeCount);\n+        if (value != 0) {\n+            out.putShort(cw.newUTF8(\"ConstantValue\"));\n+            out.putInt(2).putShort(value);\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (cw.version & 0xffff) < Opcodes.V1_5)\n+        {\n+            out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0);\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0);\n+        }\n+        if (ClassReader.SIGNATURES && signature != 0) {\n+            out.putShort(cw.newUTF8(\"Signature\"));\n+            out.putInt(2).putShort(signature);\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            out.putShort(cw.newUTF8(\"RuntimeVisibleAnnotations\"));\n+            anns.put(out);\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            out.putShort(cw.newUTF8(\"RuntimeInvisibleAnnotations\"));\n+            ianns.put(out);\n+        }\n+        if (attrs != null) {\n+            attrs.put(cw, null, 0, -1, -1, out);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Frame.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * Information about the input and output stack map frames of a basic block.\n+ * \n+ * @author Eric Bruneton\n+ */\n+final class Frame {\n+\n+    /*\n+     * Frames are computed in a two steps process: during the visit of each\n+     * instruction, the state of the frame at the end of current basic block is\n+     * updated by simulating the action of the instruction on the previous state\n+     * of this so called \"output frame\". In visitMaxs, a fix point algorithm is\n+     * used to compute the \"input frame\" of each basic block, i.e. the stack map\n+     * frame at the begining of the basic block, starting from the input frame\n+     * of the first basic block (which is computed from the method descriptor),\n+     * and by using the previously computed output frames to compute the input\n+     * state of the other blocks.\n+     * \n+     * All output and input frames are stored as arrays of integers. Reference\n+     * and array types are represented by an index into a type table (which is\n+     * not the same as the constant pool of the class, in order to avoid adding\n+     * unnecessary constants in the pool - not all computed frames will end up\n+     * being stored in the stack map table). This allows very fast type\n+     * comparisons.\n+     * \n+     * Output stack map frames are computed relatively to the input frame of the\n+     * basic block, which is not yet known when output frames are computed. It\n+     * is therefore necessary to be able to represent abstract types such as\n+     * \"the type at position x in the input frame locals\" or \"the type at\n+     * position x from the top of the input frame stack\" or even \"the type at\n+     * position x in the input frame, with y more (or less) array dimensions\".\n+     * This explains the rather complicated type format used in output frames.\n+     * \n+     * This format is the following: DIM KIND VALUE (4, 4 and 24 bits). DIM is a\n+     * signed number of array dimensions (from -8 to 7). KIND is either BASE,\n+     * LOCAL or STACK. BASE is used for types that are not relative to the input\n+     * frame. LOCAL is used for types that are relative to the input local\n+     * variable types. STACK is used for types that are relative to the input\n+     * stack types. VALUE depends on KIND. For LOCAL types, it is an index in\n+     * the input local variable types. For STACK types, it is a position\n+     * relatively to the top of input frame stack. For BASE types, it is either\n+     * one of the constants defined in FrameVisitor, or for OBJECT and\n+     * UNINITIALIZED types, a tag and an index in the type table.\n+     * \n+     * Output frames can contain types of any kind and with a positive or\n+     * negative dimension (and even unassigned types, represented by 0 - which\n+     * does not correspond to any valid type value). Input frames can only\n+     * contain BASE types of positive or null dimension. In all cases the type\n+     * table contains only internal type names (array type descriptors are\n+     * forbidden - dimensions must be represented through the DIM field).\n+     * \n+     * The LONG and DOUBLE types are always represented by using two slots (LONG +\n+     * TOP or DOUBLE + TOP), for local variable types as well as in the operand\n+     * stack. This is necessary to be able to simulate DUPx_y instructions,\n+     * whose effect would be dependent on the actual type values if types were\n+     * always represented by a single slot in the stack (and this is not\n+     * possible, since actual type values are not always known - cf LOCAL and\n+     * STACK type kinds).\n+     */\n+\n+    /**\n+     * Mask to get the dimension of a frame type. This dimension is a signed\n+     * integer between -8 and 7.\n+     */\n+    static final int DIM = 0xF0000000;\n+\n+    /**\n+     * Constant to be added to a type to get a type with one more dimension.\n+     */\n+    static final int ARRAY_OF = 0x10000000;\n+\n+    /**\n+     * Constant to be added to a type to get a type with one less dimension.\n+     */\n+    static final int ELEMENT_OF = 0xF0000000;\n+\n+    /**\n+     * Mask to get the kind of a frame type.\n+     * \n+     * @see #BASE\n+     * @see #LOCAL\n+     * @see #STACK\n+     */\n+    static final int KIND = 0xF000000;\n+\n+    /**\n+     * Mask to get the value of a frame type.\n+     */\n+    static final int VALUE = 0xFFFFFF;\n+\n+    /**\n+     * Mask to get the kind of base types.\n+     */\n+    static final int BASE_KIND = 0xFF00000;\n+\n+    /**\n+     * Mask to get the value of base types.\n+     */\n+    static final int BASE_VALUE = 0xFFFFF;\n+\n+    /**\n+     * Kind of the types that are not relative to an input stack map frame.\n+     */\n+    static final int BASE = 0x1000000;\n+\n+    /**\n+     * Base kind of the base reference types. The BASE_VALUE of such types is an\n+     * index into the type table.\n+     */\n+    static final int OBJECT = BASE | 0x700000;\n+\n+    /**\n+     * Base kind of the uninitialized base types. The BASE_VALUE of such types\n+     * in an index into the type table (the Item at that index contains both an\n+     * instruction offset and an internal class name).\n+     */\n+    static final int UNINITIALIZED = BASE | 0x800000;\n+\n+    /**\n+     * Kind of the types that are relative to the local variable types of an\n+     * input stack map frame. The value of such types is a local variable index.\n+     */\n+    private static final int LOCAL = 0x2000000;\n+\n+    /**\n+     * Kind of the the types that are relative to the stack of an input stack\n+     * map frame. The value of such types is a position relatively to the top of\n+     * this stack.\n+     */\n+    private static final int STACK = 0x3000000;\n+\n+    /**\n+     * The TOP type. This is a BASE type.\n+     */\n+    static final int TOP = BASE | 0;\n+\n+    /**\n+     * The BOOLEAN type. This is a BASE type mainly used for array types.\n+     */\n+    static final int BOOLEAN = BASE | 9;\n+\n+    /**\n+     * The BYTE type. This is a BASE type mainly used for array types.\n+     */\n+    static final int BYTE = BASE | 10;\n+\n+    /**\n+     * The CHAR type. This is a BASE type mainly used for array types.\n+     */\n+    static final int CHAR = BASE | 11;\n+\n+    /**\n+     * The SHORT type. This is a BASE type mainly used for array types.\n+     */\n+    static final int SHORT = BASE | 12;\n+\n+    /**\n+     * The INTEGER type. This is a BASE type.\n+     */\n+    static final int INTEGER = BASE | 1;\n+\n+    /**\n+     * The FLOAT type. This is a BASE type.\n+     */\n+    static final int FLOAT = BASE | 2;\n+\n+    /**\n+     * The DOUBLE type. This is a BASE type.\n+     */\n+    static final int DOUBLE = BASE | 3;\n+\n+    /**\n+     * The LONG type. This is a BASE type.\n+     */\n+    static final int LONG = BASE | 4;\n+\n+    /**\n+     * The NULL type. This is a BASE type.\n+     */\n+    static final int NULL = BASE | 5;\n+\n+    /**\n+     * The UNINITIALIZED_THIS type. This is a BASE type.\n+     */\n+    static final int UNINITIALIZED_THIS = BASE | 6;\n+\n+    /**\n+     * The stack size variation corresponding to each JVM instruction. This\n+     * stack variation is equal to the size of the values produced by an\n+     * instruction, minus the size of the values consumed by this instruction.\n+     */\n+    static final int[] SIZE;\n+\n+    /**\n+     * Computes the stack size variation corresponding to each JVM instruction.\n+     */\n+    static {\n+        int i;\n+        int[] b = new int[202];\n+        String s = \"EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDD\"\n+                + \"CDCDEEEEEEEEEEEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCD\"\n+                + \"CDCEEEEDDDDDDDCDCDCEFEFDDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFED\"\n+                + \"DDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE\";\n+        for (i = 0; i < b.length; ++i) {\n+            b[i] = s.charAt(i) - 'E';\n+        }\n+        SIZE = b;\n+\n+        // code to generate the above string\n+        //\n+        // int NA = 0; // not applicable (unused opcode or variable size opcode)\n+        //\n+        // b = new int[] {\n+        // 0, //NOP, // visitInsn\n+        // 1, //ACONST_NULL, // -\n+        // 1, //ICONST_M1, // -\n+        // 1, //ICONST_0, // -\n+        // 1, //ICONST_1, // -\n+        // 1, //ICONST_2, // -\n+        // 1, //ICONST_3, // -\n+        // 1, //ICONST_4, // -\n+        // 1, //ICONST_5, // -\n+        // 2, //LCONST_0, // -\n+        // 2, //LCONST_1, // -\n+        // 1, //FCONST_0, // -\n+        // 1, //FCONST_1, // -\n+        // 1, //FCONST_2, // -\n+        // 2, //DCONST_0, // -\n+        // 2, //DCONST_1, // -\n+        // 1, //BIPUSH, // visitIntInsn\n+        // 1, //SIPUSH, // -\n+        // 1, //LDC, // visitLdcInsn\n+        // NA, //LDC_W, // -\n+        // NA, //LDC2_W, // -\n+        // 1, //ILOAD, // visitVarInsn\n+        // 2, //LLOAD, // -\n+        // 1, //FLOAD, // -\n+        // 2, //DLOAD, // -\n+        // 1, //ALOAD, // -\n+        // NA, //ILOAD_0, // -\n+        // NA, //ILOAD_1, // -\n+        // NA, //ILOAD_2, // -\n+        // NA, //ILOAD_3, // -\n+        // NA, //LLOAD_0, // -\n+        // NA, //LLOAD_1, // -\n+        // NA, //LLOAD_2, // -\n+        // NA, //LLOAD_3, // -\n+        // NA, //FLOAD_0, // -\n+        // NA, //FLOAD_1, // -\n+        // NA, //FLOAD_2, // -\n+        // NA, //FLOAD_3, // -\n+        // NA, //DLOAD_0, // -\n+        // NA, //DLOAD_1, // -\n+        // NA, //DLOAD_2, // -\n+        // NA, //DLOAD_3, // -\n+        // NA, //ALOAD_0, // -\n+        // NA, //ALOAD_1, // -\n+        // NA, //ALOAD_2, // -\n+        // NA, //ALOAD_3, // -\n+        // -1, //IALOAD, // visitInsn\n+        // 0, //LALOAD, // -\n+        // -1, //FALOAD, // -\n+        // 0, //DALOAD, // -\n+        // -1, //AALOAD, // -\n+        // -1, //BALOAD, // -\n+        // -1, //CALOAD, // -\n+        // -1, //SALOAD, // -\n+        // -1, //ISTORE, // visitVarInsn\n+        // -2, //LSTORE, // -\n+        // -1, //FSTORE, // -\n+        // -2, //DSTORE, // -\n+        // -1, //ASTORE, // -\n+        // NA, //ISTORE_0, // -\n+        // NA, //ISTORE_1, // -\n+        // NA, //ISTORE_2, // -\n+        // NA, //ISTORE_3, // -\n+        // NA, //LSTORE_0, // -\n+        // NA, //LSTORE_1, // -\n+        // NA, //LSTORE_2, // -\n+        // NA, //LSTORE_3, // -\n+        // NA, //FSTORE_0, // -\n+        // NA, //FSTORE_1, // -\n+        // NA, //FSTORE_2, // -\n+        // NA, //FSTORE_3, // -\n+        // NA, //DSTORE_0, // -\n+        // NA, //DSTORE_1, // -\n+        // NA, //DSTORE_2, // -\n+        // NA, //DSTORE_3, // -\n+        // NA, //ASTORE_0, // -\n+        // NA, //ASTORE_1, // -\n+        // NA, //ASTORE_2, // -\n+        // NA, //ASTORE_3, // -\n+        // -3, //IASTORE, // visitInsn\n+        // -4, //LASTORE, // -\n+        // -3, //FASTORE, // -\n+        // -4, //DASTORE, // -\n+        // -3, //AASTORE, // -\n+        // -3, //BASTORE, // -\n+        // -3, //CASTORE, // -\n+        // -3, //SASTORE, // -\n+        // -1, //POP, // -\n+        // -2, //POP2, // -\n+        // 1, //DUP, // -\n+        // 1, //DUP_X1, // -\n+        // 1, //DUP_X2, // -\n+        // 2, //DUP2, // -\n+        // 2, //DUP2_X1, // -\n+        // 2, //DUP2_X2, // -\n+        // 0, //SWAP, // -\n+        // -1, //IADD, // -\n+        // -2, //LADD, // -\n+        // -1, //FADD, // -\n+        // -2, //DADD, // -\n+        // -1, //ISUB, // -\n+        // -2, //LSUB, // -\n+        // -1, //FSUB, // -\n+        // -2, //DSUB, // -\n+        // -1, //IMUL, // -\n+        // -2, //LMUL, // -\n+        // -1, //FMUL, // -\n+        // -2, //DMUL, // -\n+        // -1, //IDIV, // -\n+        // -2, //LDIV, // -\n+        // -1, //FDIV, // -\n+        // -2, //DDIV, // -\n+        // -1, //IREM, // -\n+        // -2, //LREM, // -\n+        // -1, //FREM, // -\n+        // -2, //DREM, // -\n+        // 0, //INEG, // -\n+        // 0, //LNEG, // -\n+        // 0, //FNEG, // -\n+        // 0, //DNEG, // -\n+        // -1, //ISHL, // -\n+        // -1, //LSHL, // -\n+        // -1, //ISHR, // -\n+        // -1, //LSHR, // -\n+        // -1, //IUSHR, // -\n+        // -1, //LUSHR, // -\n+        // -1, //IAND, // -\n+        // -2, //LAND, // -\n+        // -1, //IOR, // -\n+        // -2, //LOR, // -\n+        // -1, //IXOR, // -\n+        // -2, //LXOR, // -\n+        // 0, //IINC, // visitIincInsn\n+        // 1, //I2L, // visitInsn\n+        // 0, //I2F, // -\n+        // 1, //I2D, // -\n+        // -1, //L2I, // -\n+        // -1, //L2F, // -\n+        // 0, //L2D, // -\n+        // 0, //F2I, // -\n+        // 1, //F2L, // -\n+        // 1, //F2D, // -\n+        // -1, //D2I, // -\n+        // 0, //D2L, // -\n+        // -1, //D2F, // -\n+        // 0, //I2B, // -\n+        // 0, //I2C, // -\n+        // 0, //I2S, // -\n+        // -3, //LCMP, // -\n+        // -1, //FCMPL, // -\n+        // -1, //FCMPG, // -\n+        // -3, //DCMPL, // -\n+        // -3, //DCMPG, // -\n+        // -1, //IFEQ, // visitJumpInsn\n+        // -1, //IFNE, // -\n+        // -1, //IFLT, // -\n+        // -1, //IFGE, // -\n+        // -1, //IFGT, // -\n+        // -1, //IFLE, // -\n+        // -2, //IF_ICMPEQ, // -\n+        // -2, //IF_ICMPNE, // -\n+        // -2, //IF_ICMPLT, // -\n+        // -2, //IF_ICMPGE, // -\n+        // -2, //IF_ICMPGT, // -\n+        // -2, //IF_ICMPLE, // -\n+        // -2, //IF_ACMPEQ, // -\n+        // -2, //IF_ACMPNE, // -\n+        // 0, //GOTO, // -\n+        // 1, //JSR, // -\n+        // 0, //RET, // visitVarInsn\n+        // -1, //TABLESWITCH, // visiTableSwitchInsn\n+        // -1, //LOOKUPSWITCH, // visitLookupSwitch\n+        // -1, //IRETURN, // visitInsn\n+        // -2, //LRETURN, // -\n+        // -1, //FRETURN, // -\n+        // -2, //DRETURN, // -\n+        // -1, //ARETURN, // -\n+        // 0, //RETURN, // -\n+        // NA, //GETSTATIC, // visitFieldInsn\n+        // NA, //PUTSTATIC, // -\n+        // NA, //GETFIELD, // -\n+        // NA, //PUTFIELD, // -\n+        // NA, //INVOKEVIRTUAL, // visitMethodInsn\n+        // NA, //INVOKESPECIAL, // -\n+        // NA, //INVOKESTATIC, // -\n+        // NA, //INVOKEINTERFACE, // -\n+        // NA, //UNUSED, // NOT VISITED\n+        // 1, //NEW, // visitTypeInsn\n+        // 0, //NEWARRAY, // visitIntInsn\n+        // 0, //ANEWARRAY, // visitTypeInsn\n+        // 0, //ARRAYLENGTH, // visitInsn\n+        // NA, //ATHROW, // -\n+        // 0, //CHECKCAST, // visitTypeInsn\n+        // 0, //INSTANCEOF, // -\n+        // -1, //MONITORENTER, // visitInsn\n+        // -1, //MONITOREXIT, // -\n+        // NA, //WIDE, // NOT VISITED\n+        // NA, //MULTIANEWARRAY, // visitMultiANewArrayInsn\n+        // -1, //IFNULL, // visitJumpInsn\n+        // -1, //IFNONNULL, // -\n+        // NA, //GOTO_W, // -\n+        // NA, //JSR_W, // -\n+        // };\n+        // for (i = 0; i < b.length; ++i) {\n+        // System.err.print((char)('E' + b[i]));\n+        // }\n+        // System.err.println();\n+    }\n+\n+    /**\n+     * The label (i.e. basic block) to which these input and output stack map\n+     * frames correspond.\n+     */\n+    Label owner;\n+\n+    /**\n+     * The input stack map frame locals.\n+     */\n+    int[] inputLocals;\n+\n+    /**\n+     * The input stack map frame stack.\n+     */\n+    int[] inputStack;\n+\n+    /**\n+     * The output stack map frame locals.\n+     */\n+    private int[] outputLocals;\n+\n+    /**\n+     * The output stack map frame stack.\n+     */\n+    private int[] outputStack;\n+\n+    /**\n+     * Relative size of the output stack. The exact semantics of this field\n+     * depends on the algorithm that is used.\n+     * \n+     * When only the maximum stack size is computed, this field is the size of\n+     * the output stack relatively to the top of the input stack.\n+     * \n+     * When the stack map frames are completely computed, this field is the\n+     * actual number of types in {@link #outputStack}.\n+     */\n+    private int outputStackTop;\n+\n+    /**\n+     * Number of types that are initialized in the basic block.\n+     * \n+     * @see #initializations\n+     */\n+    private int initializationCount;\n+\n+    /**\n+     * The types that are initialized in the basic block. A constructor\n+     * invocation on an UNINITIALIZED or UNINITIALIZED_THIS type must replace\n+     * <i>every occurence</i> of this type in the local variables and in the\n+     * operand stack. This cannot be done during the first phase of the\n+     * algorithm since, during this phase, the local variables and the operand\n+     * stack are not completely computed. It is therefore necessary to store the\n+     * types on which constructors are invoked in the basic block, in order to\n+     * do this replacement during the second phase of the algorithm, where the\n+     * frames are fully computed. Note that this array can contain types that\n+     * are relative to input locals or to the input stack (see below for the\n+     * description of the algorithm).\n+     */\n+    private int[] initializations;\n+\n+    /**\n+     * Returns the output frame local variable type at the given index.\n+     * \n+     * @param local the index of the local that must be returned.\n+     * @return the output frame local variable type at the given index.\n+     */\n+    private int get(final int local) {\n+        if (outputLocals == null || local >= outputLocals.length) {\n+            // this local has never been assigned in this basic block,\n+            // so it is still equal to its value in the input frame\n+            return LOCAL | local;\n+        } else {\n+            int type = outputLocals[local];\n+            if (type == 0) {\n+                // this local has never been assigned in this basic block,\n+                // so it is still equal to its value in the input frame\n+                type = outputLocals[local] = LOCAL | local;\n+            }\n+            return type;\n+        }\n+    }\n+\n+    /**\n+     * Sets the output frame local variable type at the given index.\n+     * \n+     * @param local the index of the local that must be set.\n+     * @param type the value of the local that must be set.\n+     */\n+    private void set(final int local, final int type) {\n+        // creates and/or resizes the output local variables array if necessary\n+        if (outputLocals == null) {\n+            outputLocals = new int[10];\n+        }\n+        int n = outputLocals.length;\n+        if (local >= n) {\n+            int[] t = new int[Math.max(local + 1, 2 * n)];\n+            System.arraycopy(outputLocals, 0, t, 0, n);\n+            outputLocals = t;\n+        }\n+        // sets the local variable\n+        outputLocals[local] = type;\n+    }\n+\n+    /**\n+     * Pushes a new type onto the output frame stack.\n+     * \n+     * @param type the type that must be pushed.\n+     */\n+    private void push(final int type) {\n+        // creates and/or resizes the output stack array if necessary\n+        if (outputStack == null) {\n+            outputStack = new int[10];\n+        }\n+        int n = outputStack.length;\n+        if (outputStackTop >= n) {\n+            int[] t = new int[Math.max(outputStackTop + 1, 2 * n)];\n+            System.arraycopy(outputStack, 0, t, 0, n);\n+            outputStack = t;\n+        }\n+        // pushes the type on the output stack\n+        outputStack[outputStackTop++] = type;\n+        // updates the maximun height reached by the output stack, if needed\n+        int top = owner.inputStackTop + outputStackTop;\n+        if (top > owner.outputStackMax) {\n+            owner.outputStackMax = top;\n+        }\n+    }\n+\n+    /**\n+     * Pushes a new type onto the output frame stack.\n+     * \n+     * @param cw the ClassWriter to which this label belongs.\n+     * @param desc the descriptor of the type to be pushed. Can also be a method\n+     *        descriptor (in this case this method pushes its return type onto\n+     *        the output frame stack).\n+     */\n+    private void push(final ClassWriter cw, final String desc) {\n+        int type = type(cw, desc);\n+        if (type != 0) {\n+            push(type);\n+            if (type == LONG || type == DOUBLE) {\n+                push(TOP);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the int encoding of the given type.\n+     * \n+     * @param cw the ClassWriter to which this label belongs.\n+     * @param desc a type descriptor.\n+     * @return the int encoding of the given type.\n+     */\n+    private static int type(final ClassWriter cw, final String desc) {\n+        String t;\n+        int index = desc.charAt(0) == '(' ? desc.indexOf(')') + 1 : 0;\n+        switch (desc.charAt(index)) {\n+            case 'V':\n+                return 0;\n+            case 'Z':\n+            case 'C':\n+            case 'B':\n+            case 'S':\n+            case 'I':\n+                return INTEGER;\n+            case 'F':\n+                return FLOAT;\n+            case 'J':\n+                return LONG;\n+            case 'D':\n+                return DOUBLE;\n+            case 'L':\n+                // stores the internal name, not the descriptor!\n+                t = desc.substring(index + 1, desc.length() - 1);\n+                return OBJECT | cw.addType(t);\n+                // case '[':\n+            default:\n+                // extracts the dimensions and the element type\n+                int data;\n+                int dims = index + 1;\n+                while (desc.charAt(dims) == '[') {\n+                    ++dims;\n+                }\n+                switch (desc.charAt(dims)) {\n+                    case 'Z':\n+                        data = BOOLEAN;\n+                        break;\n+                    case 'C':\n+                        data = CHAR;\n+                        break;\n+                    case 'B':\n+                        data = BYTE;\n+                        break;\n+                    case 'S':\n+                        data = SHORT;\n+                        break;\n+                    case 'I':\n+                        data = INTEGER;\n+                        break;\n+                    case 'F':\n+                        data = FLOAT;\n+                        break;\n+                    case 'J':\n+                        data = LONG;\n+                        break;\n+                    case 'D':\n+                        data = DOUBLE;\n+                        break;\n+                    // case 'L':\n+                    default:\n+                        // stores the internal name, not the descriptor\n+                        t = desc.substring(dims + 1, desc.length() - 1);\n+                        data = OBJECT | cw.addType(t);\n+                }\n+                return (dims - index) << 28 | data;\n+        }\n+    }\n+\n+    /**\n+     * Pops a type from the output frame stack and returns its value.\n+     * \n+     * @return the type that has been popped from the output frame stack.\n+     */\n+    private int pop() {\n+        if (outputStackTop > 0) {\n+            return outputStack[--outputStackTop];\n+        } else {\n+            // if the output frame stack is empty, pops from the input stack\n+            return STACK | -(--owner.inputStackTop);\n+        }\n+    }\n+\n+    /**\n+     * Pops the given number of types from the output frame stack.\n+     * \n+     * @param elements the number of types that must be popped.\n+     */\n+    private void pop(final int elements) {\n+        if (outputStackTop >= elements) {\n+            outputStackTop -= elements;\n+        } else {\n+            // if the number of elements to be popped is greater than the number\n+            // of elements in the output stack, clear it, and pops the remaining\n+            // elements from the input stack.\n+            owner.inputStackTop -= elements - outputStackTop;\n+            outputStackTop = 0;\n+        }\n+    }\n+\n+    /**\n+     * Pops a type from the output frame stack.\n+     * \n+     * @param desc the descriptor of the type to be popped. Can also be a method\n+     *        descriptor (in this case this method pops the types corresponding\n+     *        to the method arguments).\n+     */\n+    private void pop(final String desc) {\n+        char c = desc.charAt(0);\n+        if (c == '(') {\n+            pop((MethodWriter.getArgumentsAndReturnSizes(desc) >> 2) - 1);\n+        } else if (c == 'J' || c == 'D') {\n+            pop(2);\n+        } else {\n+            pop(1);\n+        }\n+    }\n+\n+    /**\n+     * Adds a new type to the list of types on which a constructor is invoked in\n+     * the basic block.\n+     * \n+     * @param var a type on a which a constructor is invoked.\n+     */\n+    private void init(final int var) {\n+        // creates and/or resizes the initializations array if necessary\n+        if (initializations == null) {\n+            initializations = new int[2];\n+        }\n+        int n = initializations.length;\n+        if (initializationCount >= n) {\n+            int[] t = new int[Math.max(initializationCount + 1, 2 * n)];\n+            System.arraycopy(initializations, 0, t, 0, n);\n+            initializations = t;\n+        }\n+        // stores the type to be initialized\n+        initializations[initializationCount++] = var;\n+    }\n+\n+    /**\n+     * Replaces the given type with the appropriate type if it is one of the\n+     * types on which a constructor is invoked in the basic block.\n+     * \n+     * @param cw the ClassWriter to which this label belongs.\n+     * @param t a type\n+     * @return t or, if t is one of the types on which a constructor is invoked\n+     *         in the basic block, the type corresponding to this constructor.\n+     */\n+    private int init(final ClassWriter cw, final int t) {\n+        int s;\n+        if (t == UNINITIALIZED_THIS) {\n+            s = OBJECT | cw.addType(cw.thisName);\n+        } else if ((t & (DIM | BASE_KIND)) == UNINITIALIZED) {\n+            String type = cw.typeTable[t & BASE_VALUE].strVal1;\n+            s = OBJECT | cw.addType(type);\n+        } else {\n+            return t;\n+        }\n+        for (int j = 0; j < initializationCount; ++j) {\n+            int u = initializations[j];\n+            int dim = u & DIM;\n+            int kind = u & KIND;\n+            if (kind == LOCAL) {\n+                u = dim + inputLocals[u & VALUE];\n+            } else if (kind == STACK) {\n+                u = dim + inputStack[inputStack.length - (u & VALUE)];\n+            }\n+            if (t == u) {\n+                return s;\n+            }\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Initializes the input frame of the first basic block from the method\n+     * descriptor.\n+     * \n+     * @param cw the ClassWriter to which this label belongs.\n+     * @param access the access flags of the method to which this label belongs.\n+     * @param args the formal parameter types of this method.\n+     * @param maxLocals the maximum number of local variables of this method.\n+     */\n+    void initInputFrame(\n+        final ClassWriter cw,\n+        final int access,\n+        final Type[] args,\n+        final int maxLocals)\n+    {\n+        inputLocals = new int[maxLocals];\n+        inputStack = new int[0];\n+        int i = 0;\n+        if ((access & Opcodes.ACC_STATIC) == 0) {\n+            if ((access & MethodWriter.ACC_CONSTRUCTOR) == 0) {\n+                inputLocals[i++] = OBJECT | cw.addType(cw.thisName);\n+            } else {\n+                inputLocals[i++] = UNINITIALIZED_THIS;\n+            }\n+        }\n+        for (int j = 0; j < args.length; ++j) {\n+            int t = type(cw, args[j].getDescriptor());\n+            inputLocals[i++] = t;\n+            if (t == LONG || t == DOUBLE) {\n+                inputLocals[i++] = TOP;\n+            }\n+        }\n+        while (i < maxLocals) {\n+            inputLocals[i++] = TOP;\n+        }\n+    }\n+\n+    /**\n+     * Simulates the action of the given instruction on the output stack frame.\n+     * \n+     * @param opcode the opcode of the instruction.\n+     * @param arg the operand of the instruction, if any.\n+     * @param cw the class writer to which this label belongs.\n+     * @param item the operand of the instructions, if any.\n+     */\n+    void execute(\n+        final int opcode,\n+        final int arg,\n+        final ClassWriter cw,\n+        final Item item)\n+    {\n+        int t1, t2, t3, t4;\n+        switch (opcode) {\n+            case Opcodes.NOP:\n+            case Opcodes.INEG:\n+            case Opcodes.LNEG:\n+            case Opcodes.FNEG:\n+            case Opcodes.DNEG:\n+            case Opcodes.I2B:\n+            case Opcodes.I2C:\n+            case Opcodes.I2S:\n+            case Opcodes.GOTO:\n+            case Opcodes.RETURN:\n+                break;\n+            case Opcodes.ACONST_NULL:\n+                push(NULL);\n+                break;\n+            case Opcodes.ICONST_M1:\n+            case Opcodes.ICONST_0:\n+            case Opcodes.ICONST_1:\n+            case Opcodes.ICONST_2:\n+            case Opcodes.ICONST_3:\n+            case Opcodes.ICONST_4:\n+            case Opcodes.ICONST_5:\n+            case Opcodes.BIPUSH:\n+            case Opcodes.SIPUSH:\n+            case Opcodes.ILOAD:\n+                push(INTEGER);\n+                break;\n+            case Opcodes.LCONST_0:\n+            case Opcodes.LCONST_1:\n+            case Opcodes.LLOAD:\n+                push(LONG);\n+                push(TOP);\n+                break;\n+            case Opcodes.FCONST_0:\n+            case Opcodes.FCONST_1:\n+            case Opcodes.FCONST_2:\n+            case Opcodes.FLOAD:\n+                push(FLOAT);\n+                break;\n+            case Opcodes.DCONST_0:\n+            case Opcodes.DCONST_1:\n+            case Opcodes.DLOAD:\n+                push(DOUBLE);\n+                push(TOP);\n+                break;\n+            case Opcodes.LDC:\n+                switch (item.type) {\n+                    case ClassWriter.INT:\n+                        push(INTEGER);\n+                        break;\n+                    case ClassWriter.LONG:\n+                        push(LONG);\n+                        push(TOP);\n+                        break;\n+                    case ClassWriter.FLOAT:\n+                        push(FLOAT);\n+                        break;\n+                    case ClassWriter.DOUBLE:\n+                        push(DOUBLE);\n+                        push(TOP);\n+                        break;\n+                    case ClassWriter.CLASS:\n+                        push(OBJECT | cw.addType(\"java/lang/Class\"));\n+                        break;\n+                    // case ClassWriter.STR:\n+                    default:\n+                        push(OBJECT | cw.addType(\"java/lang/String\"));\n+                }\n+                break;\n+            case Opcodes.ALOAD:\n+                push(get(arg));\n+                break;\n+            case Opcodes.IALOAD:\n+            case Opcodes.BALOAD:\n+            case Opcodes.CALOAD:\n+            case Opcodes.SALOAD:\n+                pop(2);\n+                push(INTEGER);\n+                break;\n+            case Opcodes.LALOAD:\n+            case Opcodes.D2L:\n+                pop(2);\n+                push(LONG);\n+                push(TOP);\n+                break;\n+            case Opcodes.FALOAD:\n+                pop(2);\n+                push(FLOAT);\n+                break;\n+            case Opcodes.DALOAD:\n+            case Opcodes.L2D:\n+                pop(2);\n+                push(DOUBLE);\n+                push(TOP);\n+                break;\n+            case Opcodes.AALOAD:\n+                pop(1);\n+                t1 = pop();\n+                push(ELEMENT_OF + t1);\n+                break;\n+            case Opcodes.ISTORE:\n+            case Opcodes.FSTORE:\n+            case Opcodes.ASTORE:\n+                t1 = pop();\n+                set(arg, t1);\n+                if (arg > 0) {\n+                    t2 = get(arg - 1);\n+                    // if t2 is of kind STACK or LOCAL we cannot know its size!\n+                    if (t2 == LONG || t2 == DOUBLE) {\n+                        set(arg - 1, TOP);\n+                    }\n+                }\n+                break;\n+            case Opcodes.LSTORE:\n+            case Opcodes.DSTORE:\n+                pop(1);\n+                t1 = pop();\n+                set(arg, t1);\n+                set(arg + 1, TOP);\n+                if (arg > 0) {\n+                    t2 = get(arg - 1);\n+                    // if t2 is of kind STACK or LOCAL we cannot know its size!\n+                    if (t2 == LONG || t2 == DOUBLE) {\n+                        set(arg - 1, TOP);\n+                    }\n+                }\n+                break;\n+            case Opcodes.IASTORE:\n+            case Opcodes.BASTORE:\n+            case Opcodes.CASTORE:\n+            case Opcodes.SASTORE:\n+            case Opcodes.FASTORE:\n+            case Opcodes.AASTORE:\n+                pop(3);\n+                break;\n+            case Opcodes.LASTORE:\n+            case Opcodes.DASTORE:\n+                pop(4);\n+                break;\n+            case Opcodes.POP:\n+            case Opcodes.IFEQ:\n+            case Opcodes.IFNE:\n+            case Opcodes.IFLT:\n+            case Opcodes.IFGE:\n+            case Opcodes.IFGT:\n+            case Opcodes.IFLE:\n+            case Opcodes.IRETURN:\n+            case Opcodes.FRETURN:\n+            case Opcodes.ARETURN:\n+            case Opcodes.TABLESWITCH:\n+            case Opcodes.LOOKUPSWITCH:\n+            case Opcodes.ATHROW:\n+            case Opcodes.MONITORENTER:\n+            case Opcodes.MONITOREXIT:\n+            case Opcodes.IFNULL:\n+            case Opcodes.IFNONNULL:\n+                pop(1);\n+                break;\n+            case Opcodes.POP2:\n+            case Opcodes.IF_ICMPEQ:\n+            case Opcodes.IF_ICMPNE:\n+            case Opcodes.IF_ICMPLT:\n+            case Opcodes.IF_ICMPGE:\n+            case Opcodes.IF_ICMPGT:\n+            case Opcodes.IF_ICMPLE:\n+            case Opcodes.IF_ACMPEQ:\n+            case Opcodes.IF_ACMPNE:\n+            case Opcodes.LRETURN:\n+            case Opcodes.DRETURN:\n+                pop(2);\n+                break;\n+            case Opcodes.DUP:\n+                t1 = pop();\n+                push(t1);\n+                push(t1);\n+                break;\n+            case Opcodes.DUP_X1:\n+                t1 = pop();\n+                t2 = pop();\n+                push(t1);\n+                push(t2);\n+                push(t1);\n+                break;\n+            case Opcodes.DUP_X2:\n+                t1 = pop();\n+                t2 = pop();\n+                t3 = pop();\n+                push(t1);\n+                push(t3);\n+                push(t2);\n+                push(t1);\n+                break;\n+            case Opcodes.DUP2:\n+                t1 = pop();\n+                t2 = pop();\n+                push(t2);\n+                push(t1);\n+                push(t2);\n+                push(t1);\n+                break;\n+            case Opcodes.DUP2_X1:\n+                t1 = pop();\n+                t2 = pop();\n+                t3 = pop();\n+                push(t2);\n+                push(t1);\n+                push(t3);\n+                push(t2);\n+                push(t1);\n+                break;\n+            case Opcodes.DUP2_X2:\n+                t1 = pop();\n+                t2 = pop();\n+                t3 = pop();\n+                t4 = pop();\n+                push(t2);\n+                push(t1);\n+                push(t4);\n+                push(t3);\n+                push(t2);\n+                push(t1);\n+                break;\n+            case Opcodes.SWAP:\n+                t1 = pop();\n+                t2 = pop();\n+                push(t1);\n+                push(t2);\n+                break;\n+            case Opcodes.IADD:\n+            case Opcodes.ISUB:\n+            case Opcodes.IMUL:\n+            case Opcodes.IDIV:\n+            case Opcodes.IREM:\n+            case Opcodes.IAND:\n+            case Opcodes.IOR:\n+            case Opcodes.IXOR:\n+            case Opcodes.ISHL:\n+            case Opcodes.ISHR:\n+            case Opcodes.IUSHR:\n+            case Opcodes.L2I:\n+            case Opcodes.D2I:\n+            case Opcodes.FCMPL:\n+            case Opcodes.FCMPG:\n+                pop(2);\n+                push(INTEGER);\n+                break;\n+            case Opcodes.LADD:\n+            case Opcodes.LSUB:\n+            case Opcodes.LMUL:\n+            case Opcodes.LDIV:\n+            case Opcodes.LREM:\n+            case Opcodes.LAND:\n+            case Opcodes.LOR:\n+            case Opcodes.LXOR:\n+                pop(4);\n+                push(LONG);\n+                push(TOP);\n+                break;\n+            case Opcodes.FADD:\n+            case Opcodes.FSUB:\n+            case Opcodes.FMUL:\n+            case Opcodes.FDIV:\n+            case Opcodes.FREM:\n+            case Opcodes.L2F:\n+            case Opcodes.D2F:\n+                pop(2);\n+                push(FLOAT);\n+                break;\n+            case Opcodes.DADD:\n+            case Opcodes.DSUB:\n+            case Opcodes.DMUL:\n+            case Opcodes.DDIV:\n+            case Opcodes.DREM:\n+                pop(4);\n+                push(DOUBLE);\n+                push(TOP);\n+                break;\n+            case Opcodes.LSHL:\n+            case Opcodes.LSHR:\n+            case Opcodes.LUSHR:\n+                pop(3);\n+                push(LONG);\n+                push(TOP);\n+                break;\n+            case Opcodes.IINC:\n+                set(arg, INTEGER);\n+                break;\n+            case Opcodes.I2L:\n+            case Opcodes.F2L:\n+                pop(1);\n+                push(LONG);\n+                push(TOP);\n+                break;\n+            case Opcodes.I2F:\n+                pop(1);\n+                push(FLOAT);\n+                break;\n+            case Opcodes.I2D:\n+            case Opcodes.F2D:\n+                pop(1);\n+                push(DOUBLE);\n+                push(TOP);\n+                break;\n+            case Opcodes.F2I:\n+            case Opcodes.ARRAYLENGTH:\n+            case Opcodes.INSTANCEOF:\n+                pop(1);\n+                push(INTEGER);\n+                break;\n+            case Opcodes.LCMP:\n+            case Opcodes.DCMPL:\n+            case Opcodes.DCMPG:\n+                pop(4);\n+                push(INTEGER);\n+                break;\n+            case Opcodes.JSR:\n+            case Opcodes.RET:\n+                throw new RuntimeException(\"JSR/RET are not supported with computeFrames option\");\n+            case Opcodes.GETSTATIC:\n+                push(cw, item.strVal3);\n+                break;\n+            case Opcodes.PUTSTATIC:\n+                pop(item.strVal3);\n+                break;\n+            case Opcodes.GETFIELD:\n+                pop(1);\n+                push(cw, item.strVal3);\n+                break;\n+            case Opcodes.PUTFIELD:\n+                pop(item.strVal3);\n+                pop();\n+                break;\n+            case Opcodes.INVOKEVIRTUAL:\n+            case Opcodes.INVOKESPECIAL:\n+            case Opcodes.INVOKESTATIC:\n+            case Opcodes.INVOKEINTERFACE:\n+                pop(item.strVal3);\n+                if (opcode != Opcodes.INVOKESTATIC) {\n+                    t1 = pop();\n+                    if (opcode == Opcodes.INVOKESPECIAL\n+                            && item.strVal2.charAt(0) == '<')\n+                    {\n+                        init(t1);\n+                    }\n+                }\n+                push(cw, item.strVal3);\n+                break;\n+            case Opcodes.NEW:\n+                push(UNINITIALIZED | cw.addUninitializedType(item.strVal1, arg));\n+                break;\n+            case Opcodes.NEWARRAY:\n+                pop();\n+                switch (arg) {\n+                    case Opcodes.T_BOOLEAN:\n+                        push(ARRAY_OF | BOOLEAN);\n+                        break;\n+                    case Opcodes.T_CHAR:\n+                        push(ARRAY_OF | CHAR);\n+                        break;\n+                    case Opcodes.T_BYTE:\n+                        push(ARRAY_OF | BYTE);\n+                        break;\n+                    case Opcodes.T_SHORT:\n+                        push(ARRAY_OF | SHORT);\n+                        break;\n+                    case Opcodes.T_INT:\n+                        push(ARRAY_OF | INTEGER);\n+                        break;\n+                    case Opcodes.T_FLOAT:\n+                        push(ARRAY_OF | FLOAT);\n+                        break;\n+                    case Opcodes.T_DOUBLE:\n+                        push(ARRAY_OF | DOUBLE);\n+                        break;\n+                    // case Opcodes.T_LONG:\n+                    default:\n+                        push(ARRAY_OF | LONG);\n+                        break;\n+                }\n+                break;\n+            case Opcodes.ANEWARRAY:\n+                String s = item.strVal1;\n+                pop();\n+                if (s.charAt(0) == '[') {\n+                    push(cw, '[' + s);\n+                } else {\n+                    push(ARRAY_OF | OBJECT | cw.addType(s));\n+                }\n+                break;\n+            case Opcodes.CHECKCAST:\n+                s = item.strVal1;\n+                pop();\n+                if (s.charAt(0) == '[') {\n+                    push(cw, s);\n+                } else {\n+                    push(OBJECT | cw.addType(s));\n+                }\n+                break;\n+            // case Opcodes.MULTIANEWARRAY:\n+            default:\n+                pop(arg);\n+                push(cw, item.strVal1);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Merges the input frame of the given basic block with the input and output\n+     * frames of this basic block. Returns <tt>true</tt> if the input frame of\n+     * the given label has been changed by this operation.\n+     * \n+     * @param cw the ClassWriter to which this label belongs.\n+     * @param frame the basic block whose input frame must be updated.\n+     * @param edge the kind of the {@link Edge} between this label and 'label'.\n+     *        See {@link Edge#info}.\n+     * @return <tt>true</tt> if the input frame of the given label has been\n+     *         changed by this operation.\n+     */\n+    boolean merge(final ClassWriter cw, final Frame frame, final int edge) {\n+        boolean changed = false;\n+        int i, s, dim, kind, t;\n+\n+        int nLocal = inputLocals.length;\n+        int nStack = inputStack.length;\n+        if (frame.inputLocals == null) {\n+            frame.inputLocals = new int[nLocal];\n+            changed = true;\n+        }\n+\n+        for (i = 0; i < nLocal; ++i) {\n+            if (outputLocals != null && i < outputLocals.length) {\n+                s = outputLocals[i];\n+                if (s == 0) {\n+                    t = inputLocals[i];\n+                } else {\n+                    dim = s & DIM;\n+                    kind = s & KIND;\n+                    if (kind == LOCAL) {\n+                        t = dim + inputLocals[s & VALUE];\n+                    } else if (kind == STACK) {\n+                        t = dim + inputStack[nStack - (s & VALUE)];\n+                    } else {\n+                        t = s;\n+                    }\n+                }\n+            } else {\n+                t = inputLocals[i];\n+            }\n+            if (initializations != null) {\n+                t = init(cw, t);\n+            }\n+            changed |= merge(cw, t, frame.inputLocals, i);\n+        }\n+\n+        if (edge > 0) {\n+            for (i = 0; i < nLocal; ++i) {\n+                t = inputLocals[i];\n+                changed |= merge(cw, t, frame.inputLocals, i);\n+            }\n+            if (frame.inputStack == null) {\n+                frame.inputStack = new int[1];\n+                changed = true;\n+            }\n+            changed |= merge(cw, edge, frame.inputStack, 0);\n+            return changed;\n+        }\n+\n+        int nInputStack = inputStack.length + owner.inputStackTop;\n+        if (frame.inputStack == null) {\n+            frame.inputStack = new int[nInputStack + outputStackTop];\n+            changed = true;\n+        }\n+\n+        for (i = 0; i < nInputStack; ++i) {\n+            t = inputStack[i];\n+            if (initializations != null) {\n+                t = init(cw, t);\n+            }\n+            changed |= merge(cw, t, frame.inputStack, i);\n+        }\n+        for (i = 0; i < outputStackTop; ++i) {\n+            s = outputStack[i];\n+            dim = s & DIM;\n+            kind = s & KIND;\n+            if (kind == LOCAL) {\n+                t = dim + inputLocals[s & VALUE];\n+            } else if (kind == STACK) {\n+                t = dim + inputStack[nStack - (s & VALUE)];\n+            } else {\n+                t = s;\n+            }\n+            if (initializations != null) {\n+                t = init(cw, t);\n+            }\n+            changed |= merge(cw, t, frame.inputStack, nInputStack + i);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Merges the type at the given index in the given type array with the given\n+     * type. Returns <tt>true</tt> if the type array has been modified by this\n+     * operation.\n+     * \n+     * @param cw the ClassWriter to which this label belongs.\n+     * @param t the type with which the type array element must be merged.\n+     * @param types an array of types.\n+     * @param index the index of the type that must be merged in 'types'.\n+     * @return <tt>true</tt> if the type array has been modified by this\n+     *         operation.\n+     */\n+    private static boolean merge(\n+        final ClassWriter cw,\n+        int t,\n+        final int[] types,\n+        final int index)\n+    {\n+        int u = types[index];\n+        if (u == t) {\n+            // if the types are equal, merge(u,t)=u, so there is no change\n+            return false;\n+        }\n+        if ((t & ~DIM) == NULL) {\n+            if (u == NULL) {\n+                return false;\n+            }\n+            t = NULL;\n+        }\n+        if (u == 0) {\n+            // if types[index] has never been assigned, merge(u,t)=t\n+            types[index] = t;\n+            return true;\n+        }\n+        int v;\n+        if ((u & BASE_KIND) == OBJECT || (u & DIM) != 0) {\n+            // if u is a reference type of any dimension\n+            if (t == NULL) {\n+                // if t is the NULL type, merge(u,t)=u, so there is no change\n+                return false;\n+            } else if ((t & (DIM | BASE_KIND)) == (u & (DIM | BASE_KIND))) {\n+                if ((u & BASE_KIND) == OBJECT) {\n+                    // if t is also a reference type, and if u and t have the\n+                    // same dimension merge(u,t) = dim(t) | common parent of the\n+                    // element types of u and t\n+                    v = (t & DIM) | OBJECT\n+                            | cw.getMergedType(t & BASE_VALUE, u & BASE_VALUE);\n+                } else {\n+                    // if u and t are array types, but not with the same element\n+                    // type, merge(u,t)=java/lang/Object\n+                    v = OBJECT | cw.addType(\"java/lang/Object\");\n+                }\n+            } else if ((t & BASE_KIND) == OBJECT || (t & DIM) != 0) {\n+                // if t is any other reference or array type,\n+                // merge(u,t)=java/lang/Object\n+                v = OBJECT | cw.addType(\"java/lang/Object\");\n+            } else {\n+                // if t is any other type, merge(u,t)=TOP\n+                v = TOP;\n+            }\n+        } else if (u == NULL) {\n+            // if u is the NULL type, merge(u,t)=t,\n+            // or TOP if t is not a reference type\n+            v = (t & BASE_KIND) == OBJECT || (t & DIM) != 0 ? t : TOP;\n+        } else {\n+            // if u is any other type, merge(u,t)=TOP whatever t\n+            v = TOP;\n+        }\n+        if (u != v) {\n+            types[index] = v;\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Handler.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * Information about an exception handler block.\n+ * \n+ * @author Eric Bruneton\n+ */\n+class Handler {\n+\n+    /**\n+     * Beginning of the exception handler's scope (inclusive).\n+     */\n+    Label start;\n+\n+    /**\n+     * End of the exception handler's scope (exclusive).\n+     */\n+    Label end;\n+\n+    /**\n+     * Beginning of the exception handler's code.\n+     */\n+    Label handler;\n+\n+    /**\n+     * Internal name of the type of exceptions handled by this handler, or\n+     * <tt>null</tt> to catch any exceptions.\n+     */\n+    String desc;\n+\n+    /**\n+     * Constant pool index of the internal name of the type of exceptions\n+     * handled by this handler, or 0 to catch any exceptions.\n+     */\n+    int type;\n+\n+    /**\n+     * Next exception handler block info.\n+     */\n+    Handler next;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Item.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A constant pool item. Constant pool items can be created with the 'newXXX'\n+ * methods in the {@link ClassWriter} class.\n+ * \n+ * @author Eric Bruneton\n+ */\n+final class Item {\n+\n+    /**\n+     * Index of this item in the constant pool.\n+     */\n+    int index;\n+\n+    /**\n+     * Type of this constant pool item. A single class is used to represent all\n+     * constant pool item types, in order to minimize the bytecode size of this\n+     * package. The value of this field is one of {@link ClassWriter#INT},\n+     * {@link ClassWriter#LONG}, {@link ClassWriter#FLOAT},\n+     * {@link ClassWriter#DOUBLE}, {@link ClassWriter#UTF8},\n+     * {@link ClassWriter#STR}, {@link ClassWriter#CLASS},\n+     * {@link ClassWriter#NAME_TYPE}, {@link ClassWriter#FIELD},\n+     * {@link ClassWriter#METH}, {@link ClassWriter#IMETH}.\n+     * \n+     * Special Item types are used for Items that are stored in the ClassWriter\n+     * {@link ClassWriter#typeTable}, instead of the constant pool, in order to\n+     * avoid clashes with normal constant pool items in the ClassWriter constant\n+     * pool's hash table. These special item types are\n+     * {@link ClassWriter#TYPE_NORMAL}, {@link ClassWriter#TYPE_UNINIT} and\n+     * {@link ClassWriter#TYPE_MERGED}.\n+     */\n+    int type;\n+\n+    /**\n+     * Value of this item, for an integer item.\n+     */\n+    int intVal;\n+\n+    /**\n+     * Value of this item, for a long item.\n+     */\n+    long longVal;\n+\n+    /**\n+     * First part of the value of this item, for items that do not hold a\n+     * primitive value.\n+     */\n+    String strVal1;\n+\n+    /**\n+     * Second part of the value of this item, for items that do not hold a\n+     * primitive value.\n+     */\n+    String strVal2;\n+\n+    /**\n+     * Third part of the value of this item, for items that do not hold a\n+     * primitive value.\n+     */\n+    String strVal3;\n+\n+    /**\n+     * The hash code value of this constant pool item.\n+     */\n+    int hashCode;\n+\n+    /**\n+     * Link to another constant pool item, used for collision lists in the\n+     * constant pool's hash table.\n+     */\n+    Item next;\n+\n+    /**\n+     * Constructs an uninitialized {@link Item}.\n+     */\n+    Item() {\n+    }\n+\n+    /**\n+     * Constructs an uninitialized {@link Item} for constant pool element at\n+     * given position.\n+     * \n+     * @param index index of the item to be constructed.\n+     */\n+    Item(final int index) {\n+        this.index = index;\n+    }\n+\n+    /**\n+     * Constructs a copy of the given item.\n+     * \n+     * @param index index of the item to be constructed.\n+     * @param i the item that must be copied into the item to be constructed.\n+     */\n+    Item(final int index, final Item i) {\n+        this.index = index;\n+        type = i.type;\n+        intVal = i.intVal;\n+        longVal = i.longVal;\n+        strVal1 = i.strVal1;\n+        strVal2 = i.strVal2;\n+        strVal3 = i.strVal3;\n+        hashCode = i.hashCode;\n+    }\n+\n+    /**\n+     * Sets this item to an integer item.\n+     * \n+     * @param intVal the value of this item.\n+     */\n+    void set(final int intVal) {\n+        this.type = ClassWriter.INT;\n+        this.intVal = intVal;\n+        this.hashCode = 0x7FFFFFFF & (type + intVal);\n+    }\n+\n+    /**\n+     * Sets this item to a long item.\n+     * \n+     * @param longVal the value of this item.\n+     */\n+    void set(final long longVal) {\n+        this.type = ClassWriter.LONG;\n+        this.longVal = longVal;\n+        this.hashCode = 0x7FFFFFFF & (type + (int) longVal);\n+    }\n+\n+    /**\n+     * Sets this item to a float item.\n+     * \n+     * @param floatVal the value of this item.\n+     */\n+    void set(final float floatVal) {\n+        this.type = ClassWriter.FLOAT;\n+        this.intVal = Float.floatToRawIntBits(floatVal);\n+        this.hashCode = 0x7FFFFFFF & (type + (int) floatVal);\n+    }\n+\n+    /**\n+     * Sets this item to a double item.\n+     * \n+     * @param doubleVal the value of this item.\n+     */\n+    void set(final double doubleVal) {\n+        this.type = ClassWriter.DOUBLE;\n+        this.longVal = Double.doubleToRawLongBits(doubleVal);\n+        this.hashCode = 0x7FFFFFFF & (type + (int) doubleVal);\n+    }\n+\n+    /**\n+     * Sets this item to an item that do not hold a primitive value.\n+     * \n+     * @param type the type of this item.\n+     * @param strVal1 first part of the value of this item.\n+     * @param strVal2 second part of the value of this item.\n+     * @param strVal3 third part of the value of this item.\n+     */\n+    void set(\n+        final int type,\n+        final String strVal1,\n+        final String strVal2,\n+        final String strVal3)\n+    {\n+        this.type = type;\n+        this.strVal1 = strVal1;\n+        this.strVal2 = strVal2;\n+        this.strVal3 = strVal3;\n+        switch (type) {\n+            case ClassWriter.UTF8:\n+            case ClassWriter.STR:\n+            case ClassWriter.CLASS:\n+            case ClassWriter.TYPE_NORMAL:\n+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode());\n+                return;\n+            case ClassWriter.NAME_TYPE:\n+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()\n+                        * strVal2.hashCode());\n+                return;\n+                // ClassWriter.FIELD:\n+                // ClassWriter.METH:\n+                // ClassWriter.IMETH:\n+            default:\n+                hashCode = 0x7FFFFFFF & (type + strVal1.hashCode()\n+                        * strVal2.hashCode() * strVal3.hashCode());\n+        }\n+    }\n+\n+    /**\n+     * Indicates if the given item is equal to this one.\n+     * \n+     * @param i the item to be compared to this one.\n+     * @return <tt>true</tt> if the given item if equal to this one,\n+     *         <tt>false</tt> otherwise.\n+     */\n+    boolean isEqualTo(final Item i) {\n+        if (i.type == type) {\n+            switch (type) {\n+                case ClassWriter.INT:\n+                case ClassWriter.FLOAT:\n+                    return i.intVal == intVal;\n+                case ClassWriter.TYPE_MERGED:\n+                case ClassWriter.LONG:\n+                case ClassWriter.DOUBLE:\n+                    return i.longVal == longVal;\n+                case ClassWriter.UTF8:\n+                case ClassWriter.STR:\n+                case ClassWriter.CLASS:\n+                case ClassWriter.TYPE_NORMAL:\n+                    return i.strVal1.equals(strVal1);\n+                case ClassWriter.TYPE_UNINIT:\n+                    return i.intVal == intVal && i.strVal1.equals(strVal1);\n+                case ClassWriter.NAME_TYPE:\n+                    return i.strVal1.equals(strVal1)\n+                            && i.strVal2.equals(strVal2);\n+                    // ClassWriter.FIELD:\n+                    // ClassWriter.METH:\n+                    // ClassWriter.IMETH:\n+                default:\n+                    return i.strVal1.equals(strVal1)\n+                            && i.strVal2.equals(strVal2)\n+                            && i.strVal3.equals(strVal3);\n+            }\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Label.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A label represents a position in the bytecode of a method. Labels are used\n+ * for jump, goto, and switch instructions, and for try catch blocks.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class Label {\n+\n+    /**\n+     * Indicates if this label is only used for debug attributes. Such a label\n+     * is not the start of a basic block, the target of a jump instruction, or\n+     * an exception handler. It can be safely ignored in control flow graph\n+     * analysis algorithms (for optimization purposes).\n+     */\n+    static final int DEBUG = 1;\n+\n+    /**\n+     * Indicates if the position of this label is known.\n+     */\n+    static final int RESOLVED = 2;\n+\n+    /**\n+     * Indicates if this label has been updated, after instruction resizing.\n+     */\n+    static final int RESIZED = 4;\n+\n+    /**\n+     * Indicates if this basic block has been pushed in the basic block stack.\n+     * See {@link MethodWriter#visitMaxs visitMaxs}.\n+     */\n+    static final int PUSHED = 8;\n+\n+    /**\n+     * Indicates if this label is the target of a jump instruction, or the start\n+     * of an exception handler.\n+     */\n+    static final int TARGET = 16;\n+\n+    /**\n+     * Indicates if a stack map frame must be stored for this label.\n+     */\n+    static final int STORE = 32;\n+\n+    /**\n+     * Indicates if this label corresponds to a reachable basic block.\n+     */\n+    static final int REACHABLE = 64;\n+\n+    /**\n+     * Indicates if this basic block ends with a JSR instruction.\n+     */\n+    static final int JSR = 128;\n+\n+    /**\n+     * Indicates if this basic block ends with a RET instruction.\n+     */\n+    static final int RET = 256;\n+\n+    /**\n+     * Indicates if this basic block is the start of a subroutine.\n+     */\n+    static final int SUBROUTINE = 512;\n+\n+    /**\n+     * Indicates if this subroutine basic block has been visited.\n+     */\n+    static final int VISITED = 1024;\n+\n+    /**\n+     * Field used to associate user information to a label. Warning: this field\n+     * is used by the ASM tree package. In order to use it with the ASM tree\n+     * package you must override the {@link \n+     * org.mockito.asm.tree.MethodNode#getLabelNode} method.\n+     */\n+    public Object info;\n+\n+    /**\n+     * Flags that indicate the status of this label.\n+     * \n+     * @see #DEBUG\n+     * @see #RESOLVED\n+     * @see #RESIZED\n+     * @see #PUSHED\n+     * @see #TARGET\n+     * @see #STORE\n+     * @see #REACHABLE\n+     * @see #JSR\n+     * @see #RET\n+     */\n+    int status;\n+\n+    /**\n+     * The line number corresponding to this label, if known.\n+     */\n+    int line;\n+\n+    /**\n+     * The position of this label in the code, if known.\n+     */\n+    int position;\n+\n+    /**\n+     * Number of forward references to this label, times two.\n+     */\n+    private int referenceCount;\n+\n+    /**\n+     * Informations about forward references. Each forward reference is\n+     * described by two consecutive integers in this array: the first one is the\n+     * position of the first byte of the bytecode instruction that contains the\n+     * forward reference, while the second is the position of the first byte of\n+     * the forward reference itself. In fact the sign of the first integer\n+     * indicates if this reference uses 2 or 4 bytes, and its absolute value\n+     * gives the position of the bytecode instruction. This array is also used\n+     * as a bitset to store the subroutines to which a basic block belongs. This\n+     * information is needed in {@linked  MethodWriter#visitMaxs}, after all\n+     * forward references have been resolved. Hence the same array can be used\n+     * for both purposes without problems.\n+     */\n+    private int[] srcAndRefPositions;\n+\n+    // ------------------------------------------------------------------------\n+\n+    /*\n+     * Fields for the control flow and data flow graph analysis algorithms (used\n+     * to compute the maximum stack size or the stack map frames). A control\n+     * flow graph contains one node per \"basic block\", and one edge per \"jump\"\n+     * from one basic block to another. Each node (i.e., each basic block) is\n+     * represented by the Label object that corresponds to the first instruction\n+     * of this basic block. Each node also stores the list of its successors in\n+     * the graph, as a linked list of Edge objects.\n+     * \n+     * The control flow analysis algorithms used to compute the maximum stack\n+     * size or the stack map frames are similar and use two steps. The first\n+     * step, during the visit of each instruction, builds information about the\n+     * state of the local variables and the operand stack at the end of each\n+     * basic block, called the \"output frame\", <i>relatively</i> to the frame\n+     * state at the beginning of the basic block, which is called the \"input\n+     * frame\", and which is <i>unknown</i> during this step. The second step,\n+     * in {@link MethodWriter#visitMaxs}, is a fix point algorithm that\n+     * computes information about the input frame of each basic block, from the\n+     * input state of the first basic block (known from the method signature),\n+     * and by the using the previously computed relative output frames.\n+     * \n+     * The algorithm used to compute the maximum stack size only computes the\n+     * relative output and absolute input stack heights, while the algorithm\n+     * used to compute stack map frames computes relative output frames and\n+     * absolute input frames.\n+     */\n+\n+    /**\n+     * Start of the output stack relatively to the input stack. The exact\n+     * semantics of this field depends on the algorithm that is used.\n+     * \n+     * When only the maximum stack size is computed, this field is the number of\n+     * elements in the input stack.\n+     * \n+     * When the stack map frames are completely computed, this field is the\n+     * offset of the first output stack element relatively to the top of the\n+     * input stack. This offset is always negative or null. A null offset means\n+     * that the output stack must be appended to the input stack. A -n offset\n+     * means that the first n output stack elements must replace the top n input\n+     * stack elements, and that the other elements must be appended to the input\n+     * stack.\n+     */\n+    int inputStackTop;\n+\n+    /**\n+     * Maximum height reached by the output stack, relatively to the top of the\n+     * input stack. This maximum is always positive or null.\n+     */\n+    int outputStackMax;\n+\n+    /**\n+     * Information about the input and output stack map frames of this basic\n+     * block. This field is only used when {@link ClassWriter#COMPUTE_FRAMES}\n+     * option is used.\n+     */\n+    Frame frame;\n+\n+    /**\n+     * The successor of this label, in the order they are visited. This linked\n+     * list does not include labels used for debug info only. If\n+     * {@link ClassWriter#COMPUTE_FRAMES} option is used then, in addition, it\n+     * does not contain successive labels that denote the same bytecode position\n+     * (in this case only the first label appears in this list).\n+     */\n+    Label successor;\n+\n+    /**\n+     * The successors of this node in the control flow graph. These successors\n+     * are stored in a linked list of {@link Edge Edge} objects, linked to each\n+     * other by their {@link Edge#next} field.\n+     */\n+    Edge successors;\n+\n+    /**\n+     * The next basic block in the basic block stack. This stack is used in the\n+     * main loop of the fix point algorithm used in the second step of the\n+     * control flow analysis algorithms.\n+     * \n+     * @see MethodWriter#visitMaxs\n+     */\n+    Label next;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new label.\n+     */\n+    public Label() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Methods to compute offsets and to manage forward references\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the offset corresponding to this label. This offset is computed\n+     * from the start of the method's bytecode. <i>This method is intended for\n+     * {@link Attribute} sub classes, and is normally not needed by class\n+     * generators or adapters.</i>\n+     * \n+     * @return the offset corresponding to this label.\n+     * @throws IllegalStateException if this label is not resolved yet.\n+     */\n+    public int getOffset() {\n+        if ((status & RESOLVED) == 0) {\n+            throw new IllegalStateException(\"Label offset position has not been resolved yet\");\n+        }\n+        return position;\n+    }\n+\n+    /**\n+     * Puts a reference to this label in the bytecode of a method. If the\n+     * position of the label is known, the offset is computed and written\n+     * directly. Otherwise, a null offset is written and a new forward reference\n+     * is declared for this label.\n+     * \n+     * @param owner the code writer that calls this method.\n+     * @param out the bytecode of the method.\n+     * @param source the position of first byte of the bytecode instruction that\n+     *        contains this label.\n+     * @param wideOffset <tt>true</tt> if the reference must be stored in 4\n+     *        bytes, or <tt>false</tt> if it must be stored with 2 bytes.\n+     * @throws IllegalArgumentException if this label has not been created by\n+     *         the given code writer.\n+     */\n+    void put(\n+        final MethodWriter owner,\n+        final ByteVector out,\n+        final int source,\n+        final boolean wideOffset)\n+    {\n+        if ((status & RESOLVED) == 0) {\n+            if (wideOffset) {\n+                addReference(-1 - source, out.length);\n+                out.putInt(-1);\n+            } else {\n+                addReference(source, out.length);\n+                out.putShort(-1);\n+            }\n+        } else {\n+            if (wideOffset) {\n+                out.putInt(position - source);\n+            } else {\n+                out.putShort(position - source);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds a forward reference to this label. This method must be called only\n+     * for a true forward reference, i.e. only if this label is not resolved\n+     * yet. For backward references, the offset of the reference can be, and\n+     * must be, computed and stored directly.\n+     * \n+     * @param sourcePosition the position of the referencing instruction. This\n+     *        position will be used to compute the offset of this forward\n+     *        reference.\n+     * @param referencePosition the position where the offset for this forward\n+     *        reference must be stored.\n+     */\n+    private void addReference(\n+        final int sourcePosition,\n+        final int referencePosition)\n+    {\n+        if (srcAndRefPositions == null) {\n+            srcAndRefPositions = new int[6];\n+        }\n+        if (referenceCount >= srcAndRefPositions.length) {\n+            int[] a = new int[srcAndRefPositions.length + 6];\n+            System.arraycopy(srcAndRefPositions,\n+                    0,\n+                    a,\n+                    0,\n+                    srcAndRefPositions.length);\n+            srcAndRefPositions = a;\n+        }\n+        srcAndRefPositions[referenceCount++] = sourcePosition;\n+        srcAndRefPositions[referenceCount++] = referencePosition;\n+    }\n+\n+    /**\n+     * Resolves all forward references to this label. This method must be called\n+     * when this label is added to the bytecode of the method, i.e. when its\n+     * position becomes known. This method fills in the blanks that where left\n+     * in the bytecode by each forward reference previously added to this label.\n+     * \n+     * @param owner the code writer that calls this method.\n+     * @param position the position of this label in the bytecode.\n+     * @param data the bytecode of the method.\n+     * @return <tt>true</tt> if a blank that was left for this label was to\n+     *         small to store the offset. In such a case the corresponding jump\n+     *         instruction is replaced with a pseudo instruction (using unused\n+     *         opcodes) using an unsigned two bytes offset. These pseudo\n+     *         instructions will need to be replaced with true instructions with\n+     *         wider offsets (4 bytes instead of 2). This is done in\n+     *         {@link MethodWriter#resizeInstructions}.\n+     * @throws IllegalArgumentException if this label has already been resolved,\n+     *         or if it has not been created by the given code writer.\n+     */\n+    boolean resolve(\n+        final MethodWriter owner,\n+        final int position,\n+        final byte[] data)\n+    {\n+        boolean needUpdate = false;\n+        this.status |= RESOLVED;\n+        this.position = position;\n+        int i = 0;\n+        while (i < referenceCount) {\n+            int source = srcAndRefPositions[i++];\n+            int reference = srcAndRefPositions[i++];\n+            int offset;\n+            if (source >= 0) {\n+                offset = position - source;\n+                if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {\n+                    /*\n+                     * changes the opcode of the jump instruction, in order to\n+                     * be able to find it later (see resizeInstructions in\n+                     * MethodWriter). These temporary opcodes are similar to\n+                     * jump instruction opcodes, except that the 2 bytes offset\n+                     * is unsigned (and can therefore represent values from 0 to\n+                     * 65535, which is sufficient since the size of a method is\n+                     * limited to 65535 bytes).\n+                     */\n+                    int opcode = data[reference - 1] & 0xFF;\n+                    if (opcode <= Opcodes.JSR) {\n+                        // changes IFEQ ... JSR to opcodes 202 to 217\n+                        data[reference - 1] = (byte) (opcode + 49);\n+                    } else {\n+                        // changes IFNULL and IFNONNULL to opcodes 218 and 219\n+                        data[reference - 1] = (byte) (opcode + 20);\n+                    }\n+                    needUpdate = true;\n+                }\n+                data[reference++] = (byte) (offset >>> 8);\n+                data[reference] = (byte) offset;\n+            } else {\n+                offset = position + source + 1;\n+                data[reference++] = (byte) (offset >>> 24);\n+                data[reference++] = (byte) (offset >>> 16);\n+                data[reference++] = (byte) (offset >>> 8);\n+                data[reference] = (byte) offset;\n+            }\n+        }\n+        return needUpdate;\n+    }\n+\n+    /**\n+     * Returns the first label of the series to which this label belongs. For an\n+     * isolated label or for the first label in a series of successive labels,\n+     * this method returns the label itself. For other labels it returns the\n+     * first label of the series.\n+     * \n+     * @return the first label of the series to which this label belongs.\n+     */\n+    Label getFirst() {\n+        return !ClassReader.FRAMES || frame == null ? this : frame.owner;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Methods related to subroutines\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true is this basic block belongs to the given subroutine.\n+     * \n+     * @param id a subroutine id.\n+     * @return true is this basic block belongs to the given subroutine.\n+     */\n+    boolean inSubroutine(final long id) {\n+        if ((status & Label.VISITED) != 0) {\n+            return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true if this basic block and the given one belong to a common\n+     * subroutine.\n+     * \n+     * @param block another basic block.\n+     * @return true if this basic block and the given one belong to a common\n+     *         subroutine.\n+     */\n+    boolean inSameSubroutine(final Label block) {\n+        for (int i = 0; i < srcAndRefPositions.length; ++i) {\n+            if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Marks this basic block as belonging to the given subroutine.\n+     * \n+     * @param id a subroutine id.\n+     * @param nbSubroutines the total number of subroutines in the method.\n+     */\n+    void addToSubroutine(final long id, final int nbSubroutines) {\n+        if ((status & VISITED) == 0) {\n+            status |= VISITED;\n+            srcAndRefPositions = new int[(nbSubroutines - 1) / 32 + 1];\n+        }\n+        srcAndRefPositions[(int) (id >>> 32)] |= (int) id;\n+    }\n+    \n+    /**\n+     * Finds the basic blocks that belong to a given subroutine, and marks these\n+     * blocks as belonging to this subroutine. This recursive method follows the\n+     * control flow graph to find all the blocks that are reachable from the\n+     * current block WITHOUT following any JSR target.\n+     * \n+     * @param JSR a JSR block that jumps to this subroutine. If this JSR is not\n+     *        null it is added to the successor of the RET blocks found in the\n+     *        subroutine.\n+     * @param id the id of this subroutine.\n+     * @param nbSubroutines the total number of subroutines in the method.\n+     */\n+    void visitSubroutine(final Label JSR, final long id, final int nbSubroutines)\n+    {\n+        if (JSR != null) {\n+            if ((status & VISITED) != 0) {\n+                return;\n+            }\n+            status |= VISITED;\n+            // adds JSR to the successors of this block, if it is a RET block\n+            if ((status & RET) != 0) {\n+                if (!inSameSubroutine(JSR)) {\n+                    Edge e = new Edge();\n+                    e.info = inputStackTop;\n+                    e.successor = JSR.successors.successor;\n+                    e.next = successors;\n+                    successors = e;\n+                }\n+            }\n+        } else {\n+            // if this block already belongs to subroutine 'id', returns\n+            if (inSubroutine(id)) {\n+                return;\n+            }\n+            // marks this block as belonging to subroutine 'id'\n+            addToSubroutine(id, nbSubroutines);            \n+        }\n+        // calls this method recursively on each successor, except JSR targets\n+        Edge e = successors;\n+        while (e != null) {\n+            // if this block is a JSR block, then 'successors.next' leads\n+            // to the JSR target (see {@link #visitJumpInsn}) and must therefore\n+            // not be followed\n+            if ((status & Label.JSR) == 0 || e != successors.next) {\n+                e.successor.visitSubroutine(JSR, id, nbSubroutines);\n+            }\n+            e = e.next;\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Overriden Object methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns a string representation of this label.\n+     * \n+     * @return a string representation of this label.\n+     */\n+    public String toString() {\n+        return \"L\" + System.identityHashCode(this);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/MethodAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * An empty {@link MethodVisitor} that delegates to another\n+ * {@link MethodVisitor}. This class can be used as a super class to quickly\n+ * implement usefull method adapter classes, just by overriding the necessary\n+ * methods.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class MethodAdapter implements MethodVisitor {\n+\n+    /**\n+     * The {@link MethodVisitor} to which this adapter delegates calls.\n+     */\n+    protected MethodVisitor mv;\n+\n+    /**\n+     * Constructs a new {@link MethodAdapter} object.\n+     * \n+     * @param mv the code visitor to which this adapter must delegate calls.\n+     */\n+    public MethodAdapter(final MethodVisitor mv) {\n+        this.mv = mv;\n+    }\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        return mv.visitAnnotationDefault();\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        return mv.visitAnnotation(desc, visible);\n+    }\n+\n+    public AnnotationVisitor visitParameterAnnotation(\n+        final int parameter,\n+        final String desc,\n+        final boolean visible)\n+    {\n+        return mv.visitParameterAnnotation(parameter, desc, visible);\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        mv.visitAttribute(attr);\n+    }\n+\n+    public void visitCode() {\n+        mv.visitCode();\n+    }\n+\n+    public void visitFrame(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        mv.visitFrame(type, nLocal, local, nStack, stack);\n+    }\n+\n+    public void visitInsn(final int opcode) {\n+        mv.visitInsn(opcode);\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        mv.visitIntInsn(opcode, operand);\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        mv.visitVarInsn(opcode, var);\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        mv.visitTypeInsn(opcode, type);\n+    }\n+\n+    public void visitFieldInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        mv.visitFieldInsn(opcode, owner, name, desc);\n+    }\n+\n+    public void visitMethodInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        mv.visitMethodInsn(opcode, owner, name, desc);\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        mv.visitJumpInsn(opcode, label);\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        mv.visitLabel(label);\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        mv.visitLdcInsn(cst);\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        mv.visitIincInsn(var, increment);\n+    }\n+\n+    public void visitTableSwitchInsn(\n+        final int min,\n+        final int max,\n+        final Label dflt,\n+        final Label[] labels)\n+    {\n+        mv.visitTableSwitchInsn(min, max, dflt, labels);\n+    }\n+\n+    public void visitLookupSwitchInsn(\n+        final Label dflt,\n+        final int[] keys,\n+        final Label[] labels)\n+    {\n+        mv.visitLookupSwitchInsn(dflt, keys, labels);\n+    }\n+\n+    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n+        mv.visitMultiANewArrayInsn(desc, dims);\n+    }\n+\n+    public void visitTryCatchBlock(\n+        final Label start,\n+        final Label end,\n+        final Label handler,\n+        final String type)\n+    {\n+        mv.visitTryCatchBlock(start, end, handler, type);\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        mv.visitLocalVariable(name, desc, signature, start, end, index);\n+    }\n+\n+    public void visitLineNumber(final int line, final Label start) {\n+        mv.visitLineNumber(line, start);\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        mv.visitMaxs(maxStack, maxLocals);\n+    }\n+\n+    public void visitEnd() {\n+        mv.visitEnd();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/MethodVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A visitor to visit a Java method. The methods of this interface must be\n+ * called in the following order: [ <tt>visitAnnotationDefault</tt> ] (\n+ * <tt>visitAnnotation</tt> | <tt>visitParameterAnnotation</tt> |\n+ * <tt>visitAttribute</tt> )* [ <tt>visitCode</tt> ( <tt>visitFrame</tt> |\n+ * <tt>visit</tt><i>X</i>Insn</tt> | <tt>visitLabel</tt> | <tt>visitTryCatchBlock</tt> |\n+ * <tt>visitLocalVariable</tt> | <tt>visitLineNumber</tt>)* <tt>visitMaxs</tt> ]\n+ * <tt>visitEnd</tt>. In addition, the <tt>visit</tt><i>X</i>Insn</tt>\n+ * and <tt>visitLabel</tt> methods must be called in the sequential order of\n+ * the bytecode instructions of the visited code, <tt>visitTryCatchBlock</tt>\n+ * must be called <i>before</i> the labels passed as arguments have been\n+ * visited, and the <tt>visitLocalVariable</tt> and <tt>visitLineNumber</tt>\n+ * methods must be called <i>after</i> the labels passed as arguments have been\n+ * visited.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public interface MethodVisitor {\n+\n+    // -------------------------------------------------------------------------\n+    // Annotations and non standard attributes\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits the default value of this annotation interface method.\n+     * \n+     * @return a visitor to the visit the actual default value of this\n+     *         annotation interface method, or <tt>null</tt> if this visitor\n+     *         is not interested in visiting this default value. The 'name'\n+     *         parameters passed to the methods of this annotation visitor are\n+     *         ignored. Moreover, exacly one visit method must be called on this\n+     *         annotation visitor, followed by visitEnd.\n+     */\n+    AnnotationVisitor visitAnnotationDefault();\n+\n+    /**\n+     * Visits an annotation of this method.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values, or <tt>null</tt> if\n+     *         this visitor is not interested in visiting this annotation.\n+     */\n+    AnnotationVisitor visitAnnotation(String desc, boolean visible);\n+\n+    /**\n+     * Visits an annotation of a parameter this method.\n+     * \n+     * @param parameter the parameter index.\n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values, or <tt>null</tt> if\n+     *         this visitor is not interested in visiting this annotation.\n+     */\n+    AnnotationVisitor visitParameterAnnotation(\n+        int parameter,\n+        String desc,\n+        boolean visible);\n+\n+    /**\n+     * Visits a non standard attribute of this method.\n+     * \n+     * @param attr an attribute.\n+     */\n+    void visitAttribute(Attribute attr);\n+\n+    /**\n+     * Starts the visit of the method's code, if any (i.e. non abstract method).\n+     */\n+    void visitCode();\n+\n+    /**\n+     * Visits the current state of the local variables and operand stack\n+     * elements. This method must(*) be called <i>just before</i> any\n+     * instruction <b>i</b> that follows an unconditionnal branch instruction\n+     * such as GOTO or THROW, that is the target of a jump instruction, or that\n+     * starts an exception handler block. The visited types must describe the\n+     * values of the local variables and of the operand stack elements <i>just\n+     * before</i> <b>i</b> is executed. <br> <br> (*) this is mandatory only\n+     * for classes whose version is greater than or equal to\n+     * {@link Opcodes#V1_6 V1_6}. <br> <br> Packed frames are basically\n+     * \"deltas\" from the state of the previous frame (very first frame is\n+     * implicitly defined by the method's parameters and access flags): <ul>\n+     * <li>{@link Opcodes#F_SAME} representing frame with exactly the same\n+     * locals as the previous frame and with the empty stack.</li> <li>{@link Opcodes#F_SAME1}\n+     * representing frame with exactly the same locals as the previous frame and\n+     * with single value on the stack (<code>nStack</code> is 1 and\n+     * <code>stack[0]</code> contains value for the type of the stack item).</li>\n+     * <li>{@link Opcodes#F_APPEND} representing frame with current locals are\n+     * the same as the locals in the previous frame, except that additional\n+     * locals are defined (<code>nLocal</code> is 1, 2 or 3 and\n+     * <code>local</code> elements contains values representing added types).</li>\n+     * <li>{@link Opcodes#F_CHOP} representing frame with current locals are\n+     * the same as the locals in the previous frame, except that the last 1-3\n+     * locals are absent and with the empty stack (<code>nLocals</code> is 1,\n+     * 2 or 3). </li> <li>{@link Opcodes#F_FULL} representing complete frame\n+     * data.</li> </li> </ul>\n+     * \n+     * @param type the type of this stack map frame. Must be\n+     *        {@link Opcodes#F_NEW} for expanded frames, or\n+     *        {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},\n+     *        {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or\n+     *        {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed\n+     *        frames.\n+     * @param nLocal the number of local variables in the visited frame.\n+     * @param local the local variable types in this frame. This array must not\n+     *        be modified. Primitive types are represented by\n+     *        {@link Opcodes#TOP}, {@link Opcodes#INTEGER},\n+     *        {@link Opcodes#FLOAT}, {@link Opcodes#LONG},\n+     *        {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or\n+     *        {@link Opcodes#UNINITIALIZED_THIS} (long and double are\n+     *        represented by a single element). Reference types are represented\n+     *        by String objects (representing internal names), and uninitialized \n+     *        types by Label objects (this label designates the NEW instruction \n+     *        that created this uninitialized value).\n+     * @param nStack the number of operand stack elements in the visited frame.\n+     * @param stack the operand stack types in this frame. This array must not\n+     *        be modified. Its content has the same format as the \"local\" array.\n+     */\n+    void visitFrame(\n+        int type,\n+        int nLocal,\n+        Object[] local,\n+        int nStack,\n+        Object[] stack);\n+\n+    // -------------------------------------------------------------------------\n+    // Normal instructions\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits a zero operand instruction.\n+     * \n+     * @param opcode the opcode of the instruction to be visited. This opcode is\n+     *        either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2,\n+     *        ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1, FCONST_0,\n+     *        FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD, FALOAD,\n+     *        DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE, FASTORE,\n+     *        DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2, DUP,\n+     *        DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD, FADD,\n+     *        DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV, LDIV,\n+     *        FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL,\n+     *        LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR,\n+     *        I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B,\n+     *        I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN,\n+     *        FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW,\n+     *        MONITORENTER, or MONITOREXIT.\n+     */\n+    void visitInsn(int opcode);\n+\n+    /**\n+     * Visits an instruction with a single int operand.\n+     * \n+     * @param opcode the opcode of the instruction to be visited. This opcode is\n+     *        either BIPUSH, SIPUSH or NEWARRAY.\n+     * @param operand the operand of the instruction to be visited.<br> When\n+     *        opcode is BIPUSH, operand value should be between Byte.MIN_VALUE\n+     *        and Byte.MAX_VALUE.<br> When opcode is SIPUSH, operand value\n+     *        should be between Short.MIN_VALUE and Short.MAX_VALUE.<br> When\n+     *        opcode is NEWARRAY, operand value should be one of\n+     *        {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},\n+     *        {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},\n+     *        {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},\n+     *        {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.\n+     */\n+    void visitIntInsn(int opcode, int operand);\n+\n+    /**\n+     * Visits a local variable instruction. A local variable instruction is an\n+     * instruction that loads or stores the value of a local variable.\n+     * \n+     * @param opcode the opcode of the local variable instruction to be visited.\n+     *        This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE,\n+     *        LSTORE, FSTORE, DSTORE, ASTORE or RET.\n+     * @param var the operand of the instruction to be visited. This operand is\n+     *        the index of a local variable.\n+     */\n+    void visitVarInsn(int opcode, int var);\n+\n+    /**\n+     * Visits a type instruction. A type instruction is an instruction that\n+     * takes the internal name of a class as parameter.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This\n+     *        opcode is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.\n+     * @param type the operand of the instruction to be visited. This operand\n+     *        must be the internal name of an object or array class (see {@link \n+     *        Type#getInternalName() getInternalName}).\n+     */\n+    void visitTypeInsn(int opcode, String type);\n+\n+    /**\n+     * Visits a field instruction. A field instruction is an instruction that\n+     * loads or stores the value of a field of an object.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This\n+     *        opcode is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n+     * @param owner the internal name of the field's owner class (see {@link\n+     *        Type#getInternalName() getInternalName}).\n+     * @param name the field's name.\n+     * @param desc the field's descriptor (see {@link Type Type}).\n+     */\n+    void visitFieldInsn(int opcode, String owner, String name, String desc);\n+\n+    /**\n+     * Visits a method instruction. A method instruction is an instruction that\n+     * invokes a method.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This\n+     *        opcode is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or\n+     *        INVOKEINTERFACE.\n+     * @param owner the internal name of the method's owner class (see {@link\n+     *        Type#getInternalName() getInternalName}).\n+     * @param name the method's name.\n+     * @param desc the method's descriptor (see {@link Type Type}).\n+     */\n+    void visitMethodInsn(int opcode, String owner, String name, String desc);\n+\n+    /**\n+     * Visits a jump instruction. A jump instruction is an instruction that may\n+     * jump to another instruction.\n+     * \n+     * @param opcode the opcode of the type instruction to be visited. This\n+     *        opcode is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,\n+     *        IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,\n+     *        IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n+     * @param label the operand of the instruction to be visited. This operand\n+     *        is a label that designates the instruction to which the jump\n+     *        instruction may jump.\n+     */\n+    void visitJumpInsn(int opcode, Label label);\n+\n+    /**\n+     * Visits a label. A label designates the instruction that will be visited\n+     * just after it.\n+     * \n+     * @param label a {@link Label Label} object.\n+     */\n+    void visitLabel(Label label);\n+\n+    // -------------------------------------------------------------------------\n+    // Special instructions\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits a LDC instruction.\n+     * \n+     * @param cst the constant to be loaded on the stack. This parameter must be\n+     *        a non null {@link Integer}, a {@link Float}, a {@link Long}, a\n+     *        {@link Double} a {@link String} (or a {@link Type} for\n+     *        <tt>.class</tt> constants, for classes whose version is 49.0 or\n+     *        more).\n+     */\n+    void visitLdcInsn(Object cst);\n+\n+    /**\n+     * Visits an IINC instruction.\n+     * \n+     * @param var index of the local variable to be incremented.\n+     * @param increment amount to increment the local variable by.\n+     */\n+    void visitIincInsn(int var, int increment);\n+\n+    /**\n+     * Visits a TABLESWITCH instruction.\n+     * \n+     * @param min the minimum key value.\n+     * @param max the maximum key value.\n+     * @param dflt beginning of the default handler block.\n+     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is\n+     *        the beginning of the handler block for the <tt>min + i</tt> key.\n+     */\n+    void visitTableSwitchInsn(int min, int max, Label dflt, Label[] labels);\n+\n+    /**\n+     * Visits a LOOKUPSWITCH instruction.\n+     * \n+     * @param dflt beginning of the default handler block.\n+     * @param keys the values of the keys.\n+     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is\n+     *        the beginning of the handler block for the <tt>keys[i]</tt> key.\n+     */\n+    void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels);\n+\n+    /**\n+     * Visits a MULTIANEWARRAY instruction.\n+     * \n+     * @param desc an array type descriptor (see {@link Type Type}).\n+     * @param dims number of dimensions of the array to allocate.\n+     */\n+    void visitMultiANewArrayInsn(String desc, int dims);\n+\n+    // -------------------------------------------------------------------------\n+    // Exceptions table entries, debug information, max stack and max locals\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Visits a try catch block.\n+     * \n+     * @param start beginning of the exception handler's scope (inclusive).\n+     * @param end end of the exception handler's scope (exclusive).\n+     * @param handler beginning of the exception handler's code.\n+     * @param type internal name of the type of exceptions handled by the\n+     *        handler, or <tt>null</tt> to catch any exceptions (for \"finally\"\n+     *        blocks).\n+     * @throws IllegalArgumentException if one of the labels has already been\n+     *         visited by this visitor (by the {@link #visitLabel visitLabel}\n+     *         method).\n+     */\n+    void visitTryCatchBlock(Label start, Label end, Label handler, String type);\n+\n+    /**\n+     * Visits a local variable declaration.\n+     * \n+     * @param name the name of a local variable.\n+     * @param desc the type descriptor of this local variable.\n+     * @param signature the type signature of this local variable. May be\n+     *        <tt>null</tt> if the local variable type does not use generic\n+     *        types.\n+     * @param start the first instruction corresponding to the scope of this\n+     *        local variable (inclusive).\n+     * @param end the last instruction corresponding to the scope of this local\n+     *        variable (exclusive).\n+     * @param index the local variable's index.\n+     * @throws IllegalArgumentException if one of the labels has not already\n+     *         been visited by this visitor (by the\n+     *         {@link #visitLabel visitLabel} method).\n+     */\n+    void visitLocalVariable(\n+        String name,\n+        String desc,\n+        String signature,\n+        Label start,\n+        Label end,\n+        int index);\n+\n+    /**\n+     * Visits a line number declaration.\n+     * \n+     * @param line a line number. This number refers to the source file from\n+     *        which the class was compiled.\n+     * @param start the first instruction corresponding to this line number.\n+     * @throws IllegalArgumentException if <tt>start</tt> has not already been\n+     *         visited by this visitor (by the {@link #visitLabel visitLabel}\n+     *         method).\n+     */\n+    void visitLineNumber(int line, Label start);\n+\n+    /**\n+     * Visits the maximum stack size and the maximum number of local variables\n+     * of the method.\n+     * \n+     * @param maxStack maximum stack size of the method.\n+     * @param maxLocals maximum number of local variables for the method.\n+     */\n+    void visitMaxs(int maxStack, int maxLocals);\n+\n+    /**\n+     * Visits the end of the method. This method, which is the last one to be\n+     * called, is used to inform the visitor that all the annotations and\n+     * attributes of the method have been visited.\n+     */\n+    void visitEnd();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/MethodWriter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * A {@link MethodVisitor} that generates methods in bytecode form. Each visit\n+ * method of this class appends the bytecode corresponding to the visited\n+ * instruction to a byte vector, in the order these methods are called.\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+class MethodWriter implements MethodVisitor {\n+\n+    /**\n+     * Pseudo access flag used to denote constructors.\n+     */\n+    static final int ACC_CONSTRUCTOR = 262144;\n+\n+    /**\n+     * Frame has exactly the same locals as the previous stack map frame and\n+     * number of stack items is zero.\n+     */\n+    static final int SAME_FRAME = 0; // to 63 (0-3f)\n+\n+    /**\n+     * Frame has exactly the same locals as the previous stack map frame and\n+     * number of stack items is 1\n+     */\n+    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)\n+\n+    /**\n+     * Reserved for future use\n+     */\n+    static final int RESERVED = 128;\n+\n+    /**\n+     * Frame has exactly the same locals as the previous stack map frame and\n+     * number of stack items is 1. Offset is bigger then 63;\n+     */\n+    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7\n+\n+    /**\n+     * Frame where current locals are the same as the locals in the previous\n+     * frame, except that the k last locals are absent. The value of k is given\n+     * by the formula 251-frame_type.\n+     */\n+    static final int CHOP_FRAME = 248; // to 250 (f8-fA)\n+\n+    /**\n+     * Frame has exactly the same locals as the previous stack map frame and\n+     * number of stack items is zero. Offset is bigger then 63;\n+     */\n+    static final int SAME_FRAME_EXTENDED = 251; // fb\n+\n+    /**\n+     * Frame where current locals are the same as the locals in the previous\n+     * frame, except that k additional locals are defined. The value of k is\n+     * given by the formula frame_type-251.\n+     */\n+    static final int APPEND_FRAME = 252; // to 254 // fc-fe\n+\n+    /**\n+     * Full frame\n+     */\n+    static final int FULL_FRAME = 255; // ff\n+\n+    /**\n+     * Indicates that the stack map frames must be recomputed from scratch. In\n+     * this case the maximum stack size and number of local variables is also\n+     * recomputed from scratch.\n+     * \n+     * @see #compute\n+     */\n+    private static final int FRAMES = 0;\n+\n+    /**\n+     * Indicates that the maximum stack size and number of local variables must\n+     * be automatically computed.\n+     * \n+     * @see #compute\n+     */\n+    private static final int MAXS = 1;\n+\n+    /**\n+     * Indicates that nothing must be automatically computed.\n+     * \n+     * @see #compute\n+     */\n+    private static final int NOTHING = 2;\n+\n+    /**\n+     * Next method writer (see {@link ClassWriter#firstMethod firstMethod}).\n+     */\n+    MethodWriter next;\n+\n+    /**\n+     * The class writer to which this method must be added.\n+     */\n+    final ClassWriter cw;\n+\n+    /**\n+     * Access flags of this method.\n+     */\n+    private int access;\n+\n+    /**\n+     * The index of the constant pool item that contains the name of this\n+     * method.\n+     */\n+    private final int name;\n+\n+    /**\n+     * The index of the constant pool item that contains the descriptor of this\n+     * method.\n+     */\n+    private final int desc;\n+\n+    /**\n+     * The descriptor of this method.\n+     */\n+    private final String descriptor;\n+\n+    /**\n+     * The signature of this method.\n+     */\n+    String signature;\n+\n+    /**\n+     * If not zero, indicates that the code of this method must be copied from\n+     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n+     * precisely, this field gives the index of the first byte to copied from\n+     * <code>cw.cr.b</code>.\n+     */\n+    int classReaderOffset;\n+\n+    /**\n+     * If not zero, indicates that the code of this method must be copied from\n+     * the ClassReader associated to this writer in <code>cw.cr</code>. More\n+     * precisely, this field gives the number of bytes to copied from\n+     * <code>cw.cr.b</code>.\n+     */\n+    int classReaderLength;\n+\n+    /**\n+     * Number of exceptions that can be thrown by this method.\n+     */\n+    int exceptionCount;\n+\n+    /**\n+     * The exceptions that can be thrown by this method. More precisely, this\n+     * array contains the indexes of the constant pool items that contain the\n+     * internal names of these exception classes.\n+     */\n+    int[] exceptions;\n+\n+    /**\n+     * The annotation default attribute of this method. May be <tt>null</tt>.\n+     */\n+    private ByteVector annd;\n+\n+    /**\n+     * The runtime visible annotations of this method. May be <tt>null</tt>.\n+     */\n+    private AnnotationWriter anns;\n+\n+    /**\n+     * The runtime invisible annotations of this method. May be <tt>null</tt>.\n+     */\n+    private AnnotationWriter ianns;\n+\n+    /**\n+     * The runtime visible parameter annotations of this method. May be\n+     * <tt>null</tt>.\n+     */\n+    private AnnotationWriter[] panns;\n+\n+    /**\n+     * The runtime invisible parameter annotations of this method. May be\n+     * <tt>null</tt>.\n+     */\n+    private AnnotationWriter[] ipanns;\n+\n+    /**\n+     * The number of synthetic parameters of this method.\n+     */\n+    private int synthetics;\n+\n+    /**\n+     * The non standard attributes of the method.\n+     */\n+    private Attribute attrs;\n+\n+    /**\n+     * The bytecode of this method.\n+     */\n+    private ByteVector code = new ByteVector();\n+\n+    /**\n+     * Maximum stack size of this method.\n+     */\n+    private int maxStack;\n+\n+    /**\n+     * Maximum number of local variables for this method.\n+     */\n+    private int maxLocals;\n+\n+    /**\n+     * Number of stack map frames in the StackMapTable attribute.\n+     */\n+    private int frameCount;\n+\n+    /**\n+     * The StackMapTable attribute.\n+     */\n+    private ByteVector stackMap;\n+\n+    /**\n+     * The offset of the last frame that was written in the StackMapTable\n+     * attribute.\n+     */\n+    private int previousFrameOffset;\n+\n+    /**\n+     * The last frame that was written in the StackMapTable attribute.\n+     * \n+     * @see #frame\n+     */\n+    private int[] previousFrame;\n+\n+    /**\n+     * Index of the next element to be added in {@link #frame}.\n+     */\n+    private int frameIndex;\n+\n+    /**\n+     * The current stack map frame. The first element contains the offset of the\n+     * instruction to which the frame corresponds, the second element is the\n+     * number of locals and the third one is the number of stack elements. The\n+     * local variables start at index 3 and are followed by the operand stack\n+     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =\n+     * nStack, frame[3] = nLocal. All types are encoded as integers, with the\n+     * same format as the one used in {@link Label}, but limited to BASE types.\n+     */\n+    private int[] frame;\n+\n+    /**\n+     * Number of elements in the exception handler list.\n+     */\n+    private int handlerCount;\n+\n+    /**\n+     * The first element in the exception handler list.\n+     */\n+    private Handler firstHandler;\n+\n+    /**\n+     * The last element in the exception handler list.\n+     */\n+    private Handler lastHandler;\n+\n+    /**\n+     * Number of entries in the LocalVariableTable attribute.\n+     */\n+    private int localVarCount;\n+\n+    /**\n+     * The LocalVariableTable attribute.\n+     */\n+    private ByteVector localVar;\n+\n+    /**\n+     * Number of entries in the LocalVariableTypeTable attribute.\n+     */\n+    private int localVarTypeCount;\n+\n+    /**\n+     * The LocalVariableTypeTable attribute.\n+     */\n+    private ByteVector localVarType;\n+\n+    /**\n+     * Number of entries in the LineNumberTable attribute.\n+     */\n+    private int lineNumberCount;\n+\n+    /**\n+     * The LineNumberTable attribute.\n+     */\n+    private ByteVector lineNumber;\n+\n+    /**\n+     * The non standard attributes of the method's code.\n+     */\n+    private Attribute cattrs;\n+\n+    /**\n+     * Indicates if some jump instructions are too small and need to be resized.\n+     */\n+    private boolean resize;\n+\n+    /**\n+     * The number of subroutines in this method.\n+     */\n+    private int subroutines;\n+\n+    // ------------------------------------------------------------------------\n+\n+    /*\n+     * Fields for the control flow graph analysis algorithm (used to compute the\n+     * maximum stack size). A control flow graph contains one node per \"basic\n+     * block\", and one edge per \"jump\" from one basic block to another. Each\n+     * node (i.e., each basic block) is represented by the Label object that\n+     * corresponds to the first instruction of this basic block. Each node also\n+     * stores the list of its successors in the graph, as a linked list of Edge\n+     * objects.\n+     */\n+\n+    /**\n+     * Indicates what must be automatically computed.\n+     * \n+     * @see #FRAMES\n+     * @see #MAXS\n+     * @see #NOTHING\n+     */\n+    private final int compute;\n+\n+    /**\n+     * A list of labels. This list is the list of basic blocks in the method,\n+     * i.e. a list of Label objects linked to each other by their\n+     * {@link Label#successor} field, in the order they are visited by\n+     * {@link MethodVisitor#visitLabel}, and starting with the first basic block.\n+     */\n+    private Label labels;\n+\n+    /**\n+     * The previous basic block.\n+     */\n+    private Label previousBlock;\n+\n+    /**\n+     * The current basic block.\n+     */\n+    private Label currentBlock;\n+\n+    /**\n+     * The (relative) stack size after the last visited instruction. This size\n+     * is relative to the beginning of the current basic block, i.e., the true\n+     * stack size after the last visited instruction is equal to the\n+     * {@link Label#inputStackTop beginStackSize} of the current basic block\n+     * plus <tt>stackSize</tt>.\n+     */\n+    private int stackSize;\n+\n+    /**\n+     * The (relative) maximum stack size after the last visited instruction.\n+     * This size is relative to the beginning of the current basic block, i.e.,\n+     * the true maximum stack size after the last visited instruction is equal\n+     * to the {@link Label#inputStackTop beginStackSize} of the current basic\n+     * block plus <tt>stackSize</tt>.\n+     */\n+    private int maxStackSize;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructor\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a new {@link MethodWriter}.\n+     * \n+     * @param cw the class writer in which the method must be added.\n+     * @param access the method's access flags (see {@link Opcodes}).\n+     * @param name the method's name.\n+     * @param desc the method's descriptor (see {@link Type}).\n+     * @param signature the method's signature. May be <tt>null</tt>.\n+     * @param exceptions the internal names of the method's exceptions. May be\n+     *        <tt>null</tt>.\n+     * @param computeMaxs <tt>true</tt> if the maximum stack size and number\n+     *        of local variables must be automatically computed.\n+     * @param computeFrames <tt>true</tt> if the stack map tables must be\n+     *        recomputed from scratch.\n+     */\n+    MethodWriter(\n+        final ClassWriter cw,\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions,\n+        final boolean computeMaxs,\n+        final boolean computeFrames)\n+    {\n+        if (cw.firstMethod == null) {\n+            cw.firstMethod = this;\n+        } else {\n+            cw.lastMethod.next = this;\n+        }\n+        cw.lastMethod = this;\n+        this.cw = cw;\n+        this.access = access;\n+        this.name = cw.newUTF8(name);\n+        this.desc = cw.newUTF8(desc);\n+        this.descriptor = desc;\n+        if (ClassReader.SIGNATURES) {\n+            this.signature = signature;\n+        }\n+        if (exceptions != null && exceptions.length > 0) {\n+            exceptionCount = exceptions.length;\n+            this.exceptions = new int[exceptionCount];\n+            for (int i = 0; i < exceptionCount; ++i) {\n+                this.exceptions[i] = cw.newClass(exceptions[i]);\n+            }\n+        }\n+        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);\n+        if (computeMaxs || computeFrames) {\n+            if (computeFrames && \"<init>\".equals(name)) {\n+                this.access |= ACC_CONSTRUCTOR;\n+            }\n+            // updates maxLocals\n+            int size = getArgumentsAndReturnSizes(descriptor) >> 2;\n+            if ((access & Opcodes.ACC_STATIC) != 0) {\n+                --size;\n+            }\n+            maxLocals = size;\n+            // creates and visits the label for the first basic block\n+            labels = new Label();\n+            labels.status |= Label.PUSHED;\n+            visitLabel(labels);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the MethodVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        if (!ClassReader.ANNOTATIONS) {\n+            return null;\n+        }\n+        annd = new ByteVector();\n+        return new AnnotationWriter(cw, false, annd, null, 0);\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        if (!ClassReader.ANNOTATIONS) {\n+            return null;\n+        }\n+        ByteVector bv = new ByteVector();\n+        // write type, and reserve space for values count\n+        bv.putShort(cw.newUTF8(desc)).putShort(0);\n+        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n+        if (visible) {\n+            aw.next = anns;\n+            anns = aw;\n+        } else {\n+            aw.next = ianns;\n+            ianns = aw;\n+        }\n+        return aw;\n+    }\n+\n+    public AnnotationVisitor visitParameterAnnotation(\n+        final int parameter,\n+        final String desc,\n+        final boolean visible)\n+    {\n+        if (!ClassReader.ANNOTATIONS) {\n+            return null;\n+        }\n+        ByteVector bv = new ByteVector();\n+        if (\"Ljava/lang/Synthetic;\".equals(desc)) {\n+            // workaround for a bug in javac with synthetic parameters\n+            // see ClassReader.readParameterAnnotations\n+            synthetics = Math.max(synthetics, parameter + 1);\n+            return new AnnotationWriter(cw, false, bv, null, 0);\n+        }\n+        // write type, and reserve space for values count\n+        bv.putShort(cw.newUTF8(desc)).putShort(0);\n+        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);\n+        if (visible) {\n+            if (panns == null) {\n+                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n+            }\n+            aw.next = panns[parameter];\n+            panns[parameter] = aw;\n+        } else {\n+            if (ipanns == null) {\n+                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n+            }\n+            aw.next = ipanns[parameter];\n+            ipanns[parameter] = aw;\n+        }\n+        return aw;\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        if (attr.isCodeAttribute()) {\n+            attr.next = cattrs;\n+            cattrs = attr;\n+        } else {\n+            attr.next = attrs;\n+            attrs = attr;\n+        }\n+    }\n+\n+    public void visitCode() {\n+    }\n+\n+    public void visitFrame(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        if (!ClassReader.FRAMES || compute == FRAMES) {\n+            return;\n+        }\n+\n+        if (type == Opcodes.F_NEW) {\n+            startFrame(code.length, nLocal, nStack);\n+            for (int i = 0; i < nLocal; ++i) {\n+                if (local[i] instanceof String) {\n+                    frame[frameIndex++] = Frame.OBJECT\n+                            | cw.addType((String) local[i]);\n+                } else if (local[i] instanceof Integer) {\n+                    frame[frameIndex++] = ((Integer) local[i]).intValue();\n+                } else {\n+                    frame[frameIndex++] = Frame.UNINITIALIZED\n+                            | cw.addUninitializedType(\"\",\n+                                    ((Label) local[i]).position);\n+                }\n+            }\n+            for (int i = 0; i < nStack; ++i) {\n+                if (stack[i] instanceof String) {\n+                    frame[frameIndex++] = Frame.OBJECT\n+                            | cw.addType((String) stack[i]);\n+                } else if (stack[i] instanceof Integer) {\n+                    frame[frameIndex++] = ((Integer) stack[i]).intValue();\n+                } else {\n+                    frame[frameIndex++] = Frame.UNINITIALIZED\n+                            | cw.addUninitializedType(\"\",\n+                                    ((Label) stack[i]).position);\n+                }\n+            }\n+            endFrame();\n+        } else {\n+            int delta;\n+            if (stackMap == null) {\n+                stackMap = new ByteVector();\n+                delta = code.length;\n+            } else {\n+                delta = code.length - previousFrameOffset - 1;\n+            }\n+\n+            switch (type) {\n+                case Opcodes.F_FULL:\n+                    stackMap.putByte(FULL_FRAME)\n+                            .putShort(delta)\n+                            .putShort(nLocal);\n+                    for (int i = 0; i < nLocal; ++i) {\n+                        writeFrameType(local[i]);\n+                    }\n+                    stackMap.putShort(nStack);\n+                    for (int i = 0; i < nStack; ++i) {\n+                        writeFrameType(stack[i]);\n+                    }\n+                    break;\n+                case Opcodes.F_APPEND:\n+                    stackMap.putByte(SAME_FRAME_EXTENDED + nLocal)\n+                            .putShort(delta);\n+                    for (int i = 0; i < nLocal; ++i) {\n+                        writeFrameType(local[i]);\n+                    }\n+                    break;\n+                case Opcodes.F_CHOP:\n+                    stackMap.putByte(SAME_FRAME_EXTENDED - nLocal)\n+                            .putShort(delta);\n+                    break;\n+                case Opcodes.F_SAME:\n+                    if (delta < 64) {\n+                        stackMap.putByte(delta);\n+                    } else {\n+                        stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n+                    }\n+                    break;\n+                case Opcodes.F_SAME1:\n+                    if (delta < 64) {\n+                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n+                    } else {\n+                        stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n+                                .putShort(delta);\n+                    }\n+                    writeFrameType(stack[0]);\n+                    break;\n+            }\n+\n+            previousFrameOffset = code.length;\n+            ++frameCount;\n+        }\n+    }\n+\n+    public void visitInsn(final int opcode) {\n+        // adds the instruction to the bytecode of the method\n+        code.putByte(opcode);\n+        // update currentBlock\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, 0, null, null);\n+            } else {\n+                // updates current and max stack sizes\n+                int size = stackSize + Frame.SIZE[opcode];\n+                if (size > maxStackSize) {\n+                    maxStackSize = size;\n+                }\n+                stackSize = size;\n+            }\n+            // if opcode == ATHROW or xRETURN, ends current block (no successor)\n+            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN)\n+                    || opcode == Opcodes.ATHROW)\n+            {\n+                noSuccessor();\n+            }\n+        }\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, operand, null, null);\n+            } else if (opcode != Opcodes.NEWARRAY) {\n+                // updates current and max stack sizes only for NEWARRAY\n+                // (stack size variation = 0 for BIPUSH or SIPUSH)\n+                int size = stackSize + 1;\n+                if (size > maxStackSize) {\n+                    maxStackSize = size;\n+                }\n+                stackSize = size;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        if (opcode == Opcodes.SIPUSH) {\n+            code.put12(opcode, operand);\n+        } else { // BIPUSH or NEWARRAY\n+            code.put11(opcode, operand);\n+        }\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, var, null, null);\n+            } else {\n+                // updates current and max stack sizes\n+                if (opcode == Opcodes.RET) {\n+                    // no stack change, but end of current block (no successor)\n+                    currentBlock.status |= Label.RET;\n+                    // save 'stackSize' here for future use\n+                    // (see {@link #findSubroutineSuccessors})\n+                    currentBlock.inputStackTop = stackSize;\n+                    noSuccessor();\n+                } else { // xLOAD or xSTORE\n+                    int size = stackSize + Frame.SIZE[opcode];\n+                    if (size > maxStackSize) {\n+                        maxStackSize = size;\n+                    }\n+                    stackSize = size;\n+                }\n+            }\n+        }\n+        if (compute != NOTHING) {\n+            // updates max locals\n+            int n;\n+            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD\n+                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE)\n+            {\n+                n = var + 2;\n+            } else {\n+                n = var + 1;\n+            }\n+            if (n > maxLocals) {\n+                maxLocals = n;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        if (var < 4 && opcode != Opcodes.RET) {\n+            int opt;\n+            if (opcode < Opcodes.ISTORE) {\n+                /* ILOAD_0 */\n+                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + var;\n+            } else {\n+                /* ISTORE_0 */\n+                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + var;\n+            }\n+            code.putByte(opt);\n+        } else if (var >= 256) {\n+            code.putByte(196 /* WIDE */).put12(opcode, var);\n+        } else {\n+            code.put11(opcode, var);\n+        }\n+        if (opcode >= Opcodes.ISTORE && compute == FRAMES && handlerCount > 0) {\n+            visitLabel(new Label());\n+        }\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        Item i = cw.newClassItem(type);\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, code.length, cw, i);\n+            } else if (opcode == Opcodes.NEW) {\n+                // updates current and max stack sizes only if opcode == NEW\n+                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)\n+                int size = stackSize + 1;\n+                if (size > maxStackSize) {\n+                    maxStackSize = size;\n+                }\n+                stackSize = size;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        code.put12(opcode, i.index);\n+    }\n+\n+    public void visitFieldInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        Item i = cw.newFieldItem(owner, name, desc);\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, 0, cw, i);\n+            } else {\n+                int size;\n+                // computes the stack size variation\n+                char c = desc.charAt(0);\n+                switch (opcode) {\n+                    case Opcodes.GETSTATIC:\n+                        size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);\n+                        break;\n+                    case Opcodes.PUTSTATIC:\n+                        size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);\n+                        break;\n+                    case Opcodes.GETFIELD:\n+                        size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);\n+                        break;\n+                    // case Constants.PUTFIELD:\n+                    default:\n+                        size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);\n+                        break;\n+                }\n+                // updates current and max stack sizes\n+                if (size > maxStackSize) {\n+                    maxStackSize = size;\n+                }\n+                stackSize = size;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        code.put12(opcode, i.index);\n+    }\n+\n+    public void visitMethodInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        boolean itf = opcode == Opcodes.INVOKEINTERFACE;\n+        Item i = cw.newMethodItem(owner, name, desc, itf);\n+        int argSize = i.intVal;\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, 0, cw, i);\n+            } else {\n+                /*\n+                 * computes the stack size variation. In order not to recompute\n+                 * several times this variation for the same Item, we use the\n+                 * intVal field of this item to store this variation, once it\n+                 * has been computed. More precisely this intVal field stores\n+                 * the sizes of the arguments and of the return value\n+                 * corresponding to desc.\n+                 */\n+                if (argSize == 0) {\n+                    // the above sizes have not been computed yet,\n+                    // so we compute them...\n+                    argSize = getArgumentsAndReturnSizes(desc);\n+                    // ... and we save them in order\n+                    // not to recompute them in the future\n+                    i.intVal = argSize;\n+                }\n+                int size;\n+                if (opcode == Opcodes.INVOKESTATIC) {\n+                    size = stackSize - (argSize >> 2) + (argSize & 0x03) + 1;\n+                } else {\n+                    size = stackSize - (argSize >> 2) + (argSize & 0x03);\n+                }\n+                // updates current and max stack sizes\n+                if (size > maxStackSize) {\n+                    maxStackSize = size;\n+                }\n+                stackSize = size;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        if (itf) {\n+            if (argSize == 0) {\n+                argSize = getArgumentsAndReturnSizes(desc);\n+                i.intVal = argSize;\n+            }\n+            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);\n+        } else {\n+            code.put12(opcode, i.index);\n+        }\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        Label nextInsn = null;\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(opcode, 0, null, null);\n+                // 'label' is the target of a jump instruction\n+                label.getFirst().status |= Label.TARGET;\n+                // adds 'label' as a successor of this basic block\n+                addSuccessor(Edge.NORMAL, label);\n+                if (opcode != Opcodes.GOTO) {\n+                    // creates a Label for the next basic block\n+                    nextInsn = new Label();\n+                }\n+            } else {\n+                if (opcode == Opcodes.JSR) {\n+                    if ((label.status & Label.SUBROUTINE) == 0) {\n+                        label.status |= Label.SUBROUTINE;\n+                        ++subroutines;\n+                    }\n+                    currentBlock.status |= Label.JSR;\n+                    addSuccessor(stackSize + 1, label);\n+                    // creates a Label for the next basic block\n+                    nextInsn = new Label();\n+                    /*\n+                     * note that, by construction in this method, a JSR block\n+                     * has at least two successors in the control flow graph:\n+                     * the first one leads the next instruction after the JSR,\n+                     * while the second one leads to the JSR target.\n+                     */\n+                } else {\n+                    // updates current stack size (max stack size unchanged\n+                    // because stack size variation always negative in this\n+                    // case)\n+                    stackSize += Frame.SIZE[opcode];\n+                    addSuccessor(stackSize, label);\n+                }\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        if ((label.status & Label.RESOLVED) != 0\n+                && label.position - code.length < Short.MIN_VALUE)\n+        {\n+            /*\n+             * case of a backward jump with an offset < -32768. In this case we\n+             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx\n+             * <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is the\n+             * \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ) and where <l'>\n+             * designates the instruction just after the GOTO_W.\n+             */\n+            if (opcode == Opcodes.GOTO) {\n+                code.putByte(200); // GOTO_W\n+            } else if (opcode == Opcodes.JSR) {\n+                code.putByte(201); // JSR_W\n+            } else {\n+                // if the IF instruction is transformed into IFNOT GOTO_W the\n+                // next instruction becomes the target of the IFNOT instruction\n+                if (nextInsn != null) {\n+                    nextInsn.status |= Label.TARGET;\n+                }\n+                code.putByte(opcode <= 166\n+                        ? ((opcode + 1) ^ 1) - 1\n+                        : opcode ^ 1);\n+                code.putShort(8); // jump offset\n+                code.putByte(200); // GOTO_W\n+            }\n+            label.put(this, code, code.length - 1, true);\n+        } else {\n+            /*\n+             * case of a backward jump with an offset >= -32768, or of a forward\n+             * jump with, of course, an unknown offset. In these cases we store\n+             * the offset in 2 bytes (which will be increased in\n+             * resizeInstructions, if needed).\n+             */\n+            code.putByte(opcode);\n+            label.put(this, code, code.length - 1, false);\n+        }\n+        if (currentBlock != null) {\n+            if (nextInsn != null) {\n+                // if the jump instruction is not a GOTO, the next instruction\n+                // is also a successor of this instruction. Calling visitLabel\n+                // adds the label of this next instruction as a successor of the\n+                // current block, and starts a new basic block\n+                visitLabel(nextInsn);\n+            }\n+            if (opcode == Opcodes.GOTO) {\n+                noSuccessor();\n+            }\n+        }\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        // resolves previous forward references to label, if any\n+        resize |= label.resolve(this, code.length, code.data);\n+        // updates currentBlock\n+        if ((label.status & Label.DEBUG) != 0) {\n+            return;\n+        }\n+        if (compute == FRAMES) {\n+            if (currentBlock != null) {\n+                if (label.position == currentBlock.position) {\n+                    // successive labels, do not start a new basic block\n+                    currentBlock.status |= (label.status & Label.TARGET);\n+                    label.frame = currentBlock.frame;\n+                    return;\n+                }\n+                // ends current block (with one new successor)\n+                addSuccessor(Edge.NORMAL, label);\n+            }\n+            // begins a new current block\n+            currentBlock = label;\n+            if (label.frame == null) {\n+                label.frame = new Frame();\n+                label.frame.owner = label;\n+            }\n+            // updates the basic block list\n+            if (previousBlock != null) {\n+                if (label.position == previousBlock.position) {\n+                    previousBlock.status |= (label.status & Label.TARGET);\n+                    label.frame = previousBlock.frame;\n+                    currentBlock = previousBlock;\n+                    return;\n+                }\n+                previousBlock.successor = label;\n+            }\n+            previousBlock = label;\n+        } else if (compute == MAXS) {\n+            if (currentBlock != null) {\n+                // ends current block (with one new successor)\n+                currentBlock.outputStackMax = maxStackSize;\n+                addSuccessor(stackSize, label);\n+            }\n+            // begins a new current block\n+            currentBlock = label;\n+            // resets the relative current and max stack sizes\n+            stackSize = 0;\n+            maxStackSize = 0;\n+            // updates the basic block list\n+            if (previousBlock != null) {\n+                previousBlock.successor = label;\n+            }\n+            previousBlock = label;\n+        }\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        Item i = cw.newConstItem(cst);\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);\n+            } else {\n+                int size;\n+                // computes the stack size variation\n+                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE)\n+                {\n+                    size = stackSize + 2;\n+                } else {\n+                    size = stackSize + 1;\n+                }\n+                // updates current and max stack sizes\n+                if (size > maxStackSize) {\n+                    maxStackSize = size;\n+                }\n+                stackSize = size;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        int index = i.index;\n+        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {\n+            code.put12(20 /* LDC2_W */, index);\n+        } else if (index >= 256) {\n+            code.put12(19 /* LDC_W */, index);\n+        } else {\n+            code.put11(Opcodes.LDC, index);\n+        }\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(Opcodes.IINC, var, null, null);\n+            }\n+        }\n+        if (compute != NOTHING) {\n+            // updates max locals\n+            int n = var + 1;\n+            if (n > maxLocals) {\n+                maxLocals = n;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        if ((var > 255) || (increment > 127) || (increment < -128)) {\n+            code.putByte(196 /* WIDE */)\n+                    .put12(Opcodes.IINC, var)\n+                    .putShort(increment);\n+        } else {\n+            code.putByte(Opcodes.IINC).put11(var, increment);\n+        }\n+    }\n+\n+    public void visitTableSwitchInsn(\n+        final int min,\n+        final int max,\n+        final Label dflt,\n+        final Label[] labels)\n+    {\n+        // adds the instruction to the bytecode of the method\n+        int source = code.length;\n+        code.putByte(Opcodes.TABLESWITCH);\n+        code.length += (4 - code.length % 4) % 4;\n+        dflt.put(this, code, source, true);\n+        code.putInt(min).putInt(max);\n+        for (int i = 0; i < labels.length; ++i) {\n+            labels[i].put(this, code, source, true);\n+        }\n+        // updates currentBlock\n+        visitSwitchInsn(dflt, labels);\n+    }\n+\n+    public void visitLookupSwitchInsn(\n+        final Label dflt,\n+        final int[] keys,\n+        final Label[] labels)\n+    {\n+        // adds the instruction to the bytecode of the method\n+        int source = code.length;\n+        code.putByte(Opcodes.LOOKUPSWITCH);\n+        code.length += (4 - code.length % 4) % 4;\n+        dflt.put(this, code, source, true);\n+        code.putInt(labels.length);\n+        for (int i = 0; i < labels.length; ++i) {\n+            code.putInt(keys[i]);\n+            labels[i].put(this, code, source, true);\n+        }\n+        // updates currentBlock\n+        visitSwitchInsn(dflt, labels);\n+    }\n+\n+    private void visitSwitchInsn(final Label dflt, final Label[] labels) {\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);\n+                // adds current block successors\n+                addSuccessor(Edge.NORMAL, dflt);\n+                dflt.getFirst().status |= Label.TARGET;\n+                for (int i = 0; i < labels.length; ++i) {\n+                    addSuccessor(Edge.NORMAL, labels[i]);\n+                    labels[i].getFirst().status |= Label.TARGET;\n+                }\n+            } else {\n+                // updates current stack size (max stack size unchanged)\n+                --stackSize;\n+                // adds current block successors\n+                addSuccessor(stackSize, dflt);\n+                for (int i = 0; i < labels.length; ++i) {\n+                    addSuccessor(stackSize, labels[i]);\n+                }\n+            }\n+            // ends current block\n+            noSuccessor();\n+        }\n+    }\n+\n+    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n+        Item i = cw.newClassItem(desc);\n+        // Label currentBlock = this.currentBlock;\n+        if (currentBlock != null) {\n+            if (compute == FRAMES) {\n+                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);\n+            } else {\n+                // updates current stack size (max stack size unchanged because\n+                // stack size variation always negative or null)\n+                stackSize += 1 - dims;\n+            }\n+        }\n+        // adds the instruction to the bytecode of the method\n+        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);\n+    }\n+\n+    public void visitTryCatchBlock(\n+        final Label start,\n+        final Label end,\n+        final Label handler,\n+        final String type)\n+    {\n+        ++handlerCount;\n+        Handler h = new Handler();\n+        h.start = start;\n+        h.end = end;\n+        h.handler = handler;\n+        h.desc = type;\n+        h.type = type != null ? cw.newClass(type) : 0;\n+        if (lastHandler == null) {\n+            firstHandler = h;\n+        } else {\n+            lastHandler.next = h;\n+        }\n+        lastHandler = h;\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        if (signature != null) {\n+            if (localVarType == null) {\n+                localVarType = new ByteVector();\n+            }\n+            ++localVarTypeCount;\n+            localVarType.putShort(start.position)\n+                    .putShort(end.position - start.position)\n+                    .putShort(cw.newUTF8(name))\n+                    .putShort(cw.newUTF8(signature))\n+                    .putShort(index);\n+        }\n+        if (localVar == null) {\n+            localVar = new ByteVector();\n+        }\n+        ++localVarCount;\n+        localVar.putShort(start.position)\n+                .putShort(end.position - start.position)\n+                .putShort(cw.newUTF8(name))\n+                .putShort(cw.newUTF8(desc))\n+                .putShort(index);\n+        if (compute != NOTHING) {\n+            // updates max locals\n+            char c = desc.charAt(0);\n+            int n = index + (c == 'J' || c == 'D' ? 2 : 1);\n+            if (n > maxLocals) {\n+                maxLocals = n;\n+            }\n+        }\n+    }\n+\n+    public void visitLineNumber(final int line, final Label start) {\n+        if (lineNumber == null) {\n+            lineNumber = new ByteVector();\n+        }\n+        ++lineNumberCount;\n+        lineNumber.putShort(start.position);\n+        lineNumber.putShort(line);\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        if (ClassReader.FRAMES && compute == FRAMES) {\n+            // completes the control flow graph with exception handler blocks\n+            Handler handler = firstHandler;\n+            while (handler != null) {\n+                Label l = handler.start.getFirst();\n+                Label h = handler.handler.getFirst();\n+                Label e = handler.end.getFirst();\n+                // computes the kind of the edges to 'h'\n+                String t = handler.desc == null\n+                        ? \"java/lang/Throwable\"\n+                        : handler.desc;\n+                int kind = Frame.OBJECT | cw.addType(t);\n+                // h is an exception handler\n+                h.status |= Label.TARGET;\n+                // adds 'h' as a successor of labels between 'start' and 'end'\n+                while (l != e) {\n+                    // creates an edge to 'h'\n+                    Edge b = new Edge();\n+                    b.info = kind;\n+                    b.successor = h;\n+                    // adds it to the successors of 'l'\n+                    b.next = l.successors;\n+                    l.successors = b;\n+                    // goes to the next label\n+                    l = l.successor;\n+                }\n+                handler = handler.next;\n+            }\n+\n+            // creates and visits the first (implicit) frame\n+            Frame f = labels.frame;\n+            Type[] args = Type.getArgumentTypes(descriptor);\n+            f.initInputFrame(cw, access, args, this.maxLocals);\n+            visitFrame(f);\n+\n+            /*\n+             * fix point algorithm: mark the first basic block as 'changed'\n+             * (i.e. put it in the 'changed' list) and, while there are changed\n+             * basic blocks, choose one, mark it as unchanged, and update its\n+             * successors (which can be changed in the process).\n+             */\n+            int max = 0;\n+            Label changed = labels;\n+            while (changed != null) {\n+                // removes a basic block from the list of changed basic blocks\n+                Label l = changed;\n+                changed = changed.next;\n+                l.next = null;\n+                f = l.frame;\n+                // a reacheable jump target must be stored in the stack map\n+                if ((l.status & Label.TARGET) != 0) {\n+                    l.status |= Label.STORE;\n+                }\n+                // all visited labels are reacheable, by definition\n+                l.status |= Label.REACHABLE;\n+                // updates the (absolute) maximum stack size\n+                int blockMax = f.inputStack.length + l.outputStackMax;\n+                if (blockMax > max) {\n+                    max = blockMax;\n+                }\n+                // updates the successors of the current basic block\n+                Edge e = l.successors;\n+                while (e != null) {\n+                    Label n = e.successor.getFirst();\n+                    boolean change = f.merge(cw, n.frame, e.info);\n+                    if (change && n.next == null) {\n+                        // if n has changed and is not already in the 'changed'\n+                        // list, adds it to this list\n+                        n.next = changed;\n+                        changed = n;\n+                    }\n+                    e = e.next;\n+                }\n+            }\n+            this.maxStack = max;\n+\n+            // visits all the frames that must be stored in the stack map\n+            Label l = labels;\n+            while (l != null) {\n+                f = l.frame;\n+                if ((l.status & Label.STORE) != 0) {\n+                    visitFrame(f);\n+                }\n+                if ((l.status & Label.REACHABLE) == 0) {\n+                    // finds start and end of dead basic block\n+                    Label k = l.successor;\n+                    int start = l.position;\n+                    int end = (k == null ? code.length : k.position) - 1;\n+                    // if non empty basic block\n+                    if (end >= start) {\n+                        // replaces instructions with NOP ... NOP ATHROW\n+                        for (int i = start; i < end; ++i) {\n+                            code.data[i] = Opcodes.NOP;\n+                        }\n+                        code.data[end] = (byte) Opcodes.ATHROW;\n+                        // emits a frame for this unreachable block\n+                        startFrame(start, 0, 1);\n+                        frame[frameIndex++] = Frame.OBJECT\n+                                | cw.addType(\"java/lang/Throwable\");\n+                        endFrame();\n+                    }\n+                }\n+                l = l.successor;\n+            }\n+        } else if (compute == MAXS) {\n+            // completes the control flow graph with exception handler blocks\n+            Handler handler = firstHandler;\n+            while (handler != null) {\n+                Label l = handler.start;\n+                Label h = handler.handler;\n+                Label e = handler.end;\n+                // adds 'h' as a successor of labels between 'start' and 'end'\n+                while (l != e) {\n+                    // creates an edge to 'h'\n+                    Edge b = new Edge();\n+                    b.info = Edge.EXCEPTION;\n+                    b.successor = h;\n+                    // adds it to the successors of 'l'\n+                    if ((l.status & Label.JSR) == 0) {\n+                        b.next = l.successors;\n+                        l.successors = b;\n+                    } else {\n+                        // if l is a JSR block, adds b after the first two edges\n+                        // to preserve the hypothesis about JSR block successors\n+                        // order (see {@link #visitJumpInsn})\n+                        b.next = l.successors.next.next;\n+                        l.successors.next.next = b;\n+                    }\n+                    // goes to the next label\n+                    l = l.successor;\n+                }\n+                handler = handler.next;\n+            }\n+\n+            if (subroutines > 0) {\n+                // completes the control flow graph with the RET successors\n+                /*\n+                 * first step: finds the subroutines. This step determines, for\n+                 * each basic block, to which subroutine(s) it belongs.\n+                 */\n+                // finds the basic blocks that belong to the \"main\" subroutine\n+                int id = 0;\n+                labels.visitSubroutine(null, 1, subroutines);\n+                // finds the basic blocks that belong to the real subroutines\n+                Label l = labels;\n+                while (l != null) {\n+                    if ((l.status & Label.JSR) != 0) {\n+                        // the subroutine is defined by l's TARGET, not by l\n+                        Label subroutine = l.successors.next.successor;\n+                        // if this subroutine has not been visited yet...\n+                        if ((subroutine.status & Label.VISITED) == 0) {\n+                            // ...assigns it a new id and finds its basic blocks\n+                            id += 1;\n+                            subroutine.visitSubroutine(null, (id / 32L) << 32\n+                                    | (1L << (id % 32)), subroutines);\n+                        }\n+                    }\n+                    l = l.successor;\n+                }\n+                // second step: finds the successors of RET blocks\n+                l = labels;\n+                while (l != null) {\n+                    if ((l.status & Label.JSR) != 0) {\n+                        Label L = labels;\n+                        while (L != null) {\n+                            L.status &= ~Label.VISITED;\n+                            L = L.successor;\n+                        }\n+                        // the subroutine is defined by l's TARGET, not by l\n+                        Label subroutine = l.successors.next.successor;\n+                        subroutine.visitSubroutine(l, 0, subroutines);\n+                    }\n+                    l = l.successor;\n+                }\n+            }\n+\n+            /*\n+             * control flow analysis algorithm: while the block stack is not\n+             * empty, pop a block from this stack, update the max stack size,\n+             * compute the true (non relative) begin stack size of the\n+             * successors of this block, and push these successors onto the\n+             * stack (unless they have already been pushed onto the stack).\n+             * Note: by hypothesis, the {@link Label#inputStackTop} of the\n+             * blocks in the block stack are the true (non relative) beginning\n+             * stack sizes of these blocks.\n+             */\n+            int max = 0;\n+            Label stack = labels;\n+            while (stack != null) {\n+                // pops a block from the stack\n+                Label l = stack;\n+                stack = stack.next;\n+                // computes the true (non relative) max stack size of this block\n+                int start = l.inputStackTop;\n+                int blockMax = start + l.outputStackMax;\n+                // updates the global max stack size\n+                if (blockMax > max) {\n+                    max = blockMax;\n+                }\n+                // analyzes the successors of the block\n+                Edge b = l.successors;\n+                if ((l.status & Label.JSR) != 0) {\n+                    // ignores the first edge of JSR blocks (virtual successor)\n+                    b = b.next;\n+                }\n+                while (b != null) {\n+                    l = b.successor;\n+                    // if this successor has not already been pushed...\n+                    if ((l.status & Label.PUSHED) == 0) {\n+                        // computes its true beginning stack size...\n+                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start\n+                                + b.info;\n+                        // ...and pushes it onto the stack\n+                        l.status |= Label.PUSHED;\n+                        l.next = stack;\n+                        stack = l;\n+                    }\n+                    b = b.next;\n+                }\n+            }\n+            this.maxStack = max;\n+        } else {\n+            this.maxStack = maxStack;\n+            this.maxLocals = maxLocals;\n+        }\n+    }\n+\n+    public void visitEnd() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: control flow analysis algorithm\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Computes the size of the arguments and of the return value of a method.\n+     * \n+     * @param desc the descriptor of a method.\n+     * @return the size of the arguments of the method (plus one for the\n+     *         implicit this argument), argSize, and the size of its return\n+     *         value, retSize, packed into a single int i =\n+     *         <tt>(argSize << 2) | retSize</tt> (argSize is therefore equal\n+     *         to <tt>i >> 2</tt>, and retSize to <tt>i & 0x03</tt>).\n+     */\n+    static int getArgumentsAndReturnSizes(final String desc) {\n+        int n = 1;\n+        int c = 1;\n+        while (true) {\n+            char car = desc.charAt(c++);\n+            if (car == ')') {\n+                car = desc.charAt(c);\n+                return n << 2\n+                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));\n+            } else if (car == 'L') {\n+                while (desc.charAt(c++) != ';') {\n+                }\n+                n += 1;\n+            } else if (car == '[') {\n+                while ((car = desc.charAt(c)) == '[') {\n+                    ++c;\n+                }\n+                if (car == 'D' || car == 'J') {\n+                    n -= 1;\n+                }\n+            } else if (car == 'D' || car == 'J') {\n+                n += 2;\n+            } else {\n+                n += 1;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds a successor to the {@link #currentBlock currentBlock} block.\n+     * \n+     * @param info information about the control flow edge to be added.\n+     * @param successor the successor block to be added to the current block.\n+     */\n+    private void addSuccessor(final int info, final Label successor) {\n+        // creates and initializes an Edge object...\n+        Edge b = new Edge();\n+        b.info = info;\n+        b.successor = successor;\n+        // ...and adds it to the successor list of the currentBlock block\n+        b.next = currentBlock.successors;\n+        currentBlock.successors = b;\n+    }\n+\n+    /**\n+     * Ends the current basic block. This method must be used in the case where\n+     * the current basic block does not have any successor.\n+     */\n+    private void noSuccessor() {\n+        if (compute == FRAMES) {\n+            Label l = new Label();\n+            l.frame = new Frame();\n+            l.frame.owner = l;\n+            l.resolve(this, code.length, code.data);\n+            previousBlock.successor = l;\n+            previousBlock = l;\n+        } else {\n+            currentBlock.outputStackMax = maxStackSize;\n+        }\n+        currentBlock = null;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: stack map frames\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Visits a frame that has been computed from scratch.\n+     * \n+     * @param f the frame that must be visited.\n+     */\n+    private void visitFrame(final Frame f) {\n+        int i, t;\n+        int nTop = 0;\n+        int nLocal = 0;\n+        int nStack = 0;\n+        int[] locals = f.inputLocals;\n+        int[] stacks = f.inputStack;\n+        // computes the number of locals (ignores TOP types that are just after\n+        // a LONG or a DOUBLE, and all trailing TOP types)\n+        for (i = 0; i < locals.length; ++i) {\n+            t = locals[i];\n+            if (t == Frame.TOP) {\n+                ++nTop;\n+            } else {\n+                nLocal += nTop + 1;\n+                nTop = 0;\n+            }\n+            if (t == Frame.LONG || t == Frame.DOUBLE) {\n+                ++i;\n+            }\n+        }\n+        // computes the stack size (ignores TOP types that are just after\n+        // a LONG or a DOUBLE)\n+        for (i = 0; i < stacks.length; ++i) {\n+            t = stacks[i];\n+            ++nStack;\n+            if (t == Frame.LONG || t == Frame.DOUBLE) {\n+                ++i;\n+            }\n+        }\n+        // visits the frame and its content\n+        startFrame(f.owner.position, nLocal, nStack);\n+        for (i = 0; nLocal > 0; ++i, --nLocal) {\n+            t = locals[i];\n+            frame[frameIndex++] = t;\n+            if (t == Frame.LONG || t == Frame.DOUBLE) {\n+                ++i;\n+            }\n+        }\n+        for (i = 0; i < stacks.length; ++i) {\n+            t = stacks[i];\n+            frame[frameIndex++] = t;\n+            if (t == Frame.LONG || t == Frame.DOUBLE) {\n+                ++i;\n+            }\n+        }\n+        endFrame();\n+    }\n+\n+    /**\n+     * Starts the visit of a stack map frame.\n+     * \n+     * @param offset the offset of the instruction to which the frame\n+     *        corresponds.\n+     * @param nLocal the number of local variables in the frame.\n+     * @param nStack the number of stack elements in the frame.\n+     */\n+    private void startFrame(final int offset, final int nLocal, final int nStack)\n+    {\n+        int n = 3 + nLocal + nStack;\n+        if (frame == null || frame.length < n) {\n+            frame = new int[n];\n+        }\n+        frame[0] = offset;\n+        frame[1] = nLocal;\n+        frame[2] = nStack;\n+        frameIndex = 3;\n+    }\n+\n+    /**\n+     * Checks if the visit of the current frame {@link #frame} is finished, and\n+     * if yes, write it in the StackMapTable attribute.\n+     */\n+    private void endFrame() {\n+        if (previousFrame != null) { // do not write the first frame\n+            if (stackMap == null) {\n+                stackMap = new ByteVector();\n+            }\n+            writeFrame();\n+            ++frameCount;\n+        }\n+        previousFrame = frame;\n+        frame = null;\n+    }\n+\n+    /**\n+     * Compress and writes the current frame {@link #frame} in the StackMapTable\n+     * attribute.\n+     */\n+    private void writeFrame() {\n+        int clocalsSize = frame[1];\n+        int cstackSize = frame[2];\n+        if ((cw.version & 0xFFFF) < Opcodes.V1_6) {\n+            stackMap.putShort(frame[0]).putShort(clocalsSize);\n+            writeFrameTypes(3, 3 + clocalsSize);\n+            stackMap.putShort(cstackSize);\n+            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n+            return;\n+        }\n+        int localsSize = previousFrame[1];\n+        int type = FULL_FRAME;\n+        int k = 0;\n+        int delta;\n+        if (frameCount == 0) {\n+            delta = frame[0];\n+        } else {\n+            delta = frame[0] - previousFrame[0] - 1;\n+        }\n+        if (cstackSize == 0) {\n+            k = clocalsSize - localsSize;\n+            switch (k) {\n+                case -3:\n+                case -2:\n+                case -1:\n+                    type = CHOP_FRAME;\n+                    localsSize = clocalsSize;\n+                    break;\n+                case 0:\n+                    type = delta < 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;\n+                    break;\n+                case 1:\n+                case 2:\n+                case 3:\n+                    type = APPEND_FRAME;\n+                    break;\n+            }\n+        } else if (clocalsSize == localsSize && cstackSize == 1) {\n+            type = delta < 63\n+                    ? SAME_LOCALS_1_STACK_ITEM_FRAME\n+                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;\n+        }\n+        if (type != FULL_FRAME) {\n+            // verify if locals are the same\n+            int l = 3;\n+            for (int j = 0; j < localsSize; j++) {\n+                if (frame[l] != previousFrame[l]) {\n+                    type = FULL_FRAME;\n+                    break;\n+                }\n+                l++;\n+            }\n+        }\n+        switch (type) {\n+            case SAME_FRAME:\n+                stackMap.putByte(delta);\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_FRAME:\n+                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);\n+                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n+                break;\n+            case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:\n+                stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)\n+                        .putShort(delta);\n+                writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);\n+                break;\n+            case SAME_FRAME_EXTENDED:\n+                stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);\n+                break;\n+            case CHOP_FRAME:\n+                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n+                break;\n+            case APPEND_FRAME:\n+                stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);\n+                writeFrameTypes(3 + localsSize, 3 + clocalsSize);\n+                break;\n+            // case FULL_FRAME:\n+            default:\n+                stackMap.putByte(FULL_FRAME)\n+                        .putShort(delta)\n+                        .putShort(clocalsSize);\n+                writeFrameTypes(3, 3 + clocalsSize);\n+                stackMap.putShort(cstackSize);\n+                writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);\n+        }\n+    }\n+\n+    /**\n+     * Writes some types of the current frame {@link #frame} into the\n+     * StackMapTableAttribute. This method converts types from the format used\n+     * in {@link Label} to the format used in StackMapTable attributes. In\n+     * particular, it converts type table indexes to constant pool indexes.\n+     * \n+     * @param start index of the first type in {@link #frame} to write.\n+     * @param end index of last type in {@link #frame} to write (exclusive).\n+     */\n+    private void writeFrameTypes(final int start, final int end) {\n+        for (int i = start; i < end; ++i) {\n+            int t = frame[i];\n+            int d = t & Frame.DIM;\n+            if (d == 0) {\n+                int v = t & Frame.BASE_VALUE;\n+                switch (t & Frame.BASE_KIND) {\n+                    case Frame.OBJECT:\n+                        stackMap.putByte(7)\n+                                .putShort(cw.newClass(cw.typeTable[v].strVal1));\n+                        break;\n+                    case Frame.UNINITIALIZED:\n+                        stackMap.putByte(8).putShort(cw.typeTable[v].intVal);\n+                        break;\n+                    default:\n+                        stackMap.putByte(v);\n+                }\n+            } else {\n+                StringBuffer buf = new StringBuffer();\n+                d >>= 28;\n+                while (d-- > 0) {\n+                    buf.append('[');\n+                }\n+                if ((t & Frame.BASE_KIND) == Frame.OBJECT) {\n+                    buf.append('L');\n+                    buf.append(cw.typeTable[t & Frame.BASE_VALUE].strVal1);\n+                    buf.append(';');\n+                } else {\n+                    switch (t & 0xF) {\n+                        case 1:\n+                            buf.append('I');\n+                            break;\n+                        case 2:\n+                            buf.append('F');\n+                            break;\n+                        case 3:\n+                            buf.append('D');\n+                            break;\n+                        case 9:\n+                            buf.append('Z');\n+                            break;\n+                        case 10:\n+                            buf.append('B');\n+                            break;\n+                        case 11:\n+                            buf.append('C');\n+                            break;\n+                        case 12:\n+                            buf.append('S');\n+                            break;\n+                        default:\n+                            buf.append('J');\n+                    }\n+                }\n+                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));\n+            }\n+        }\n+    }\n+\n+    private void writeFrameType(final Object type) {\n+        if (type instanceof String) {\n+            stackMap.putByte(7).putShort(cw.newClass((String) type));\n+        } else if (type instanceof Integer) {\n+            stackMap.putByte(((Integer) type).intValue());\n+        } else {\n+            stackMap.putByte(8).putShort(((Label) type).position);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: dump bytecode array\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the size of the bytecode of this method.\n+     * \n+     * @return the size of the bytecode of this method.\n+     */\n+    final int getSize() {\n+        if (classReaderOffset != 0) {\n+            return 6 + classReaderLength;\n+        }\n+        if (resize) {\n+            // replaces the temporary jump opcodes introduced by Label.resolve.\n+            if (ClassReader.RESIZE) {\n+                resizeInstructions();\n+            } else {\n+                throw new RuntimeException(\"Method code too large!\");\n+            }\n+        }\n+        int size = 8;\n+        if (code.length > 0) {\n+            cw.newUTF8(\"Code\");\n+            size += 18 + code.length + 8 * handlerCount;\n+            if (localVar != null) {\n+                cw.newUTF8(\"LocalVariableTable\");\n+                size += 8 + localVar.length;\n+            }\n+            if (localVarType != null) {\n+                cw.newUTF8(\"LocalVariableTypeTable\");\n+                size += 8 + localVarType.length;\n+            }\n+            if (lineNumber != null) {\n+                cw.newUTF8(\"LineNumberTable\");\n+                size += 8 + lineNumber.length;\n+            }\n+            if (stackMap != null) {\n+                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n+                cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\");\n+                size += 8 + stackMap.length;\n+            }\n+            if (cattrs != null) {\n+                size += cattrs.getSize(cw,\n+                        code.data,\n+                        code.length,\n+                        maxStack,\n+                        maxLocals);\n+            }\n+        }\n+        if (exceptionCount > 0) {\n+            cw.newUTF8(\"Exceptions\");\n+            size += 8 + 2 * exceptionCount;\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (cw.version & 0xffff) < Opcodes.V1_5)\n+        {\n+            cw.newUTF8(\"Synthetic\");\n+            size += 6;\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            cw.newUTF8(\"Deprecated\");\n+            size += 6;\n+        }\n+        if (ClassReader.SIGNATURES && signature != null) {\n+            cw.newUTF8(\"Signature\");\n+            cw.newUTF8(signature);\n+            size += 8;\n+        }\n+        if (ClassReader.ANNOTATIONS && annd != null) {\n+            cw.newUTF8(\"AnnotationDefault\");\n+            size += 6 + annd.length;\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            cw.newUTF8(\"RuntimeVisibleAnnotations\");\n+            size += 8 + anns.getSize();\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            cw.newUTF8(\"RuntimeInvisibleAnnotations\");\n+            size += 8 + ianns.getSize();\n+        }\n+        if (ClassReader.ANNOTATIONS && panns != null) {\n+            cw.newUTF8(\"RuntimeVisibleParameterAnnotations\");\n+            size += 7 + 2 * (panns.length - synthetics);\n+            for (int i = panns.length - 1; i >= synthetics; --i) {\n+                size += panns[i] == null ? 0 : panns[i].getSize();\n+            }\n+        }\n+        if (ClassReader.ANNOTATIONS && ipanns != null) {\n+            cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\");\n+            size += 7 + 2 * (ipanns.length - synthetics);\n+            for (int i = ipanns.length - 1; i >= synthetics; --i) {\n+                size += ipanns[i] == null ? 0 : ipanns[i].getSize();\n+            }\n+        }\n+        if (attrs != null) {\n+            size += attrs.getSize(cw, null, 0, -1, -1);\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Puts the bytecode of this method in the given byte vector.\n+     * \n+     * @param out the byte vector into which the bytecode of this method must be\n+     *        copied.\n+     */\n+    final void put(final ByteVector out) {\n+        out.putShort(access).putShort(name).putShort(desc);\n+        if (classReaderOffset != 0) {\n+            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);\n+            return;\n+        }\n+        int attributeCount = 0;\n+        if (code.length > 0) {\n+            ++attributeCount;\n+        }\n+        if (exceptionCount > 0) {\n+            ++attributeCount;\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (cw.version & 0xffff) < Opcodes.V1_5)\n+        {\n+            ++attributeCount;\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.SIGNATURES && signature != null) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && annd != null) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && panns != null) {\n+            ++attributeCount;\n+        }\n+        if (ClassReader.ANNOTATIONS && ipanns != null) {\n+            ++attributeCount;\n+        }\n+        if (attrs != null) {\n+            attributeCount += attrs.getCount();\n+        }\n+        out.putShort(attributeCount);\n+        if (code.length > 0) {\n+            int size = 12 + code.length + 8 * handlerCount;\n+            if (localVar != null) {\n+                size += 8 + localVar.length;\n+            }\n+            if (localVarType != null) {\n+                size += 8 + localVarType.length;\n+            }\n+            if (lineNumber != null) {\n+                size += 8 + lineNumber.length;\n+            }\n+            if (stackMap != null) {\n+                size += 8 + stackMap.length;\n+            }\n+            if (cattrs != null) {\n+                size += cattrs.getSize(cw,\n+                        code.data,\n+                        code.length,\n+                        maxStack,\n+                        maxLocals);\n+            }\n+            out.putShort(cw.newUTF8(\"Code\")).putInt(size);\n+            out.putShort(maxStack).putShort(maxLocals);\n+            out.putInt(code.length).putByteArray(code.data, 0, code.length);\n+            out.putShort(handlerCount);\n+            if (handlerCount > 0) {\n+                Handler h = firstHandler;\n+                while (h != null) {\n+                    out.putShort(h.start.position)\n+                            .putShort(h.end.position)\n+                            .putShort(h.handler.position)\n+                            .putShort(h.type);\n+                    h = h.next;\n+                }\n+            }\n+            attributeCount = 0;\n+            if (localVar != null) {\n+                ++attributeCount;\n+            }\n+            if (localVarType != null) {\n+                ++attributeCount;\n+            }\n+            if (lineNumber != null) {\n+                ++attributeCount;\n+            }\n+            if (stackMap != null) {\n+                ++attributeCount;\n+            }\n+            if (cattrs != null) {\n+                attributeCount += cattrs.getCount();\n+            }\n+            out.putShort(attributeCount);\n+            if (localVar != null) {\n+                out.putShort(cw.newUTF8(\"LocalVariableTable\"));\n+                out.putInt(localVar.length + 2).putShort(localVarCount);\n+                out.putByteArray(localVar.data, 0, localVar.length);\n+            }\n+            if (localVarType != null) {\n+                out.putShort(cw.newUTF8(\"LocalVariableTypeTable\"));\n+                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);\n+                out.putByteArray(localVarType.data, 0, localVarType.length);\n+            }\n+            if (lineNumber != null) {\n+                out.putShort(cw.newUTF8(\"LineNumberTable\"));\n+                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);\n+                out.putByteArray(lineNumber.data, 0, lineNumber.length);\n+            }\n+            if (stackMap != null) {\n+                boolean zip = (cw.version & 0xFFFF) >= Opcodes.V1_6;\n+                out.putShort(cw.newUTF8(zip ? \"StackMapTable\" : \"StackMap\"));\n+                out.putInt(stackMap.length + 2).putShort(frameCount);\n+                out.putByteArray(stackMap.data, 0, stackMap.length);\n+            }\n+            if (cattrs != null) {\n+                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);\n+            }\n+        }\n+        if (exceptionCount > 0) {\n+            out.putShort(cw.newUTF8(\"Exceptions\"))\n+                    .putInt(2 * exceptionCount + 2);\n+            out.putShort(exceptionCount);\n+            for (int i = 0; i < exceptionCount; ++i) {\n+                out.putShort(exceptions[i]);\n+            }\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0\n+                && (cw.version & 0xffff) < Opcodes.V1_5)\n+        {\n+            out.putShort(cw.newUTF8(\"Synthetic\")).putInt(0);\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            out.putShort(cw.newUTF8(\"Deprecated\")).putInt(0);\n+        }\n+        if (ClassReader.SIGNATURES && signature != null) {\n+            out.putShort(cw.newUTF8(\"Signature\"))\n+                    .putInt(2)\n+                    .putShort(cw.newUTF8(signature));\n+        }\n+        if (ClassReader.ANNOTATIONS && annd != null) {\n+            out.putShort(cw.newUTF8(\"AnnotationDefault\"));\n+            out.putInt(annd.length);\n+            out.putByteArray(annd.data, 0, annd.length);\n+        }\n+        if (ClassReader.ANNOTATIONS && anns != null) {\n+            out.putShort(cw.newUTF8(\"RuntimeVisibleAnnotations\"));\n+            anns.put(out);\n+        }\n+        if (ClassReader.ANNOTATIONS && ianns != null) {\n+            out.putShort(cw.newUTF8(\"RuntimeInvisibleAnnotations\"));\n+            ianns.put(out);\n+        }\n+        if (ClassReader.ANNOTATIONS && panns != null) {\n+            out.putShort(cw.newUTF8(\"RuntimeVisibleParameterAnnotations\"));\n+            AnnotationWriter.put(panns, synthetics, out);\n+        }\n+        if (ClassReader.ANNOTATIONS && ipanns != null) {\n+            out.putShort(cw.newUTF8(\"RuntimeInvisibleParameterAnnotations\"));\n+            AnnotationWriter.put(ipanns, synthetics, out);\n+        }\n+        if (attrs != null) {\n+            attrs.put(cw, null, 0, -1, -1, out);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Resizes and replaces the temporary instructions inserted by\n+     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets\n+     * and instruction addresses consistent. This may require to resize other\n+     * existing instructions, or even to introduce new instructions: for\n+     * example, increasing the size of an instruction by 2 at the middle of a\n+     * method can increases the offset of an IFEQ instruction from 32766 to\n+     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W\n+     * 32765. This, in turn, may require to increase the size of another jump\n+     * instruction, and so on... All these operations are handled automatically\n+     * by this method. <p> <i>This method must be called after all the method\n+     * that is being built has been visited</i>. In particular, the\n+     * {@link Label Label} objects used to construct the method are no longer\n+     * valid after this method has been called.\n+     */\n+    private void resizeInstructions() {\n+        byte[] b = code.data; // bytecode of the method\n+        int u, v, label; // indexes in b\n+        int i, j; // loop indexes\n+        /*\n+         * 1st step: As explained above, resizing an instruction may require to\n+         * resize another one, which may require to resize yet another one, and\n+         * so on. The first step of the algorithm consists in finding all the\n+         * instructions that need to be resized, without modifying the code.\n+         * This is done by the following \"fix point\" algorithm:\n+         * \n+         * Parse the code to find the jump instructions whose offset will need\n+         * more than 2 bytes to be stored (the future offset is computed from\n+         * the current offset and from the number of bytes that will be inserted\n+         * or removed between the source and target instructions). For each such\n+         * instruction, adds an entry in (a copy of) the indexes and sizes\n+         * arrays (if this has not already been done in a previous iteration!).\n+         * \n+         * If at least one entry has been added during the previous step, go\n+         * back to the beginning, otherwise stop.\n+         * \n+         * In fact the real algorithm is complicated by the fact that the size\n+         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their\n+         * position in the bytecode (because of padding). In order to ensure the\n+         * convergence of the algorithm, the number of bytes to be added or\n+         * removed from these instructions is over estimated during the previous\n+         * loop, and computed exactly only after the loop is finished (this\n+         * requires another pass to parse the bytecode of the method).\n+         */\n+        int[] allIndexes = new int[0]; // copy of indexes\n+        int[] allSizes = new int[0]; // copy of sizes\n+        boolean[] resize; // instructions to be resized\n+        int newOffset; // future offset of a jump instruction\n+\n+        resize = new boolean[code.length];\n+\n+        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done\n+        int state = 3;\n+        do {\n+            if (state == 3) {\n+                state = 2;\n+            }\n+            u = 0;\n+            while (u < b.length) {\n+                int opcode = b[u] & 0xFF; // opcode of current instruction\n+                int insert = 0; // bytes to be added after this instruction\n+\n+                switch (ClassWriter.TYPE[opcode]) {\n+                    case ClassWriter.NOARG_INSN:\n+                    case ClassWriter.IMPLVAR_INSN:\n+                        u += 1;\n+                        break;\n+                    case ClassWriter.LABEL_INSN:\n+                        if (opcode > 201) {\n+                            // converts temporary opcodes 202 to 217, 218 and\n+                            // 219 to IFEQ ... JSR (inclusive), IFNULL and\n+                            // IFNONNULL\n+                            opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n+                            label = u + readUnsignedShort(b, u + 1);\n+                        } else {\n+                            label = u + readShort(b, u + 1);\n+                        }\n+                        newOffset = getNewOffset(allIndexes, allSizes, u, label);\n+                        if (newOffset < Short.MIN_VALUE\n+                                || newOffset > Short.MAX_VALUE)\n+                        {\n+                            if (!resize[u]) {\n+                                if (opcode == Opcodes.GOTO\n+                                        || opcode == Opcodes.JSR)\n+                                {\n+                                    // two additional bytes will be required to\n+                                    // replace this GOTO or JSR instruction with\n+                                    // a GOTO_W or a JSR_W\n+                                    insert = 2;\n+                                } else {\n+                                    // five additional bytes will be required to\n+                                    // replace this IFxxx <l> instruction with\n+                                    // IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx\n+                                    // is the \"opposite\" opcode of IFxxx (i.e.,\n+                                    // IFNE for IFEQ) and where <l'> designates\n+                                    // the instruction just after the GOTO_W.\n+                                    insert = 5;\n+                                }\n+                                resize[u] = true;\n+                            }\n+                        }\n+                        u += 3;\n+                        break;\n+                    case ClassWriter.LABELW_INSN:\n+                        u += 5;\n+                        break;\n+                    case ClassWriter.TABL_INSN:\n+                        if (state == 1) {\n+                            // true number of bytes to be added (or removed)\n+                            // from this instruction = (future number of padding\n+                            // bytes - current number of padding byte) -\n+                            // previously over estimated variation =\n+                            // = ((3 - newOffset%4) - (3 - u%4)) - u%4\n+                            // = (-newOffset%4 + u%4) - u%4\n+                            // = -(newOffset & 3)\n+                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n+                            insert = -(newOffset & 3);\n+                        } else if (!resize[u]) {\n+                            // over estimation of the number of bytes to be\n+                            // added to this instruction = 3 - current number\n+                            // of padding bytes = 3 - (3 - u%4) = u%4 = u & 3\n+                            insert = u & 3;\n+                            resize[u] = true;\n+                        }\n+                        // skips instruction\n+                        u = u + 4 - (u & 3);\n+                        u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;\n+                        break;\n+                    case ClassWriter.LOOK_INSN:\n+                        if (state == 1) {\n+                            // like TABL_INSN\n+                            newOffset = getNewOffset(allIndexes, allSizes, 0, u);\n+                            insert = -(newOffset & 3);\n+                        } else if (!resize[u]) {\n+                            // like TABL_INSN\n+                            insert = u & 3;\n+                            resize[u] = true;\n+                        }\n+                        // skips instruction\n+                        u = u + 4 - (u & 3);\n+                        u += 8 * readInt(b, u + 4) + 8;\n+                        break;\n+                    case ClassWriter.WIDE_INSN:\n+                        opcode = b[u + 1] & 0xFF;\n+                        if (opcode == Opcodes.IINC) {\n+                            u += 6;\n+                        } else {\n+                            u += 4;\n+                        }\n+                        break;\n+                    case ClassWriter.VAR_INSN:\n+                    case ClassWriter.SBYTE_INSN:\n+                    case ClassWriter.LDC_INSN:\n+                        u += 2;\n+                        break;\n+                    case ClassWriter.SHORT_INSN:\n+                    case ClassWriter.LDCW_INSN:\n+                    case ClassWriter.FIELDORMETH_INSN:\n+                    case ClassWriter.TYPE_INSN:\n+                    case ClassWriter.IINC_INSN:\n+                        u += 3;\n+                        break;\n+                    case ClassWriter.ITFMETH_INSN:\n+                        u += 5;\n+                        break;\n+                    // case ClassWriter.MANA_INSN:\n+                    default:\n+                        u += 4;\n+                        break;\n+                }\n+                if (insert != 0) {\n+                    // adds a new (u, insert) entry in the allIndexes and\n+                    // allSizes arrays\n+                    int[] newIndexes = new int[allIndexes.length + 1];\n+                    int[] newSizes = new int[allSizes.length + 1];\n+                    System.arraycopy(allIndexes,\n+                            0,\n+                            newIndexes,\n+                            0,\n+                            allIndexes.length);\n+                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);\n+                    newIndexes[allIndexes.length] = u;\n+                    newSizes[allSizes.length] = insert;\n+                    allIndexes = newIndexes;\n+                    allSizes = newSizes;\n+                    if (insert > 0) {\n+                        state = 3;\n+                    }\n+                }\n+            }\n+            if (state < 3) {\n+                --state;\n+            }\n+        } while (state != 0);\n+\n+        // 2nd step:\n+        // copies the bytecode of the method into a new bytevector, updates the\n+        // offsets, and inserts (or removes) bytes as requested.\n+\n+        ByteVector newCode = new ByteVector(code.length);\n+\n+        u = 0;\n+        while (u < code.length) {\n+            int opcode = b[u] & 0xFF;\n+            switch (ClassWriter.TYPE[opcode]) {\n+                case ClassWriter.NOARG_INSN:\n+                case ClassWriter.IMPLVAR_INSN:\n+                    newCode.putByte(opcode);\n+                    u += 1;\n+                    break;\n+                case ClassWriter.LABEL_INSN:\n+                    if (opcode > 201) {\n+                        // changes temporary opcodes 202 to 217 (inclusive), 218\n+                        // and 219 to IFEQ ... JSR (inclusive), IFNULL and\n+                        // IFNONNULL\n+                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;\n+                        label = u + readUnsignedShort(b, u + 1);\n+                    } else {\n+                        label = u + readShort(b, u + 1);\n+                    }\n+                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n+                    if (resize[u]) {\n+                        // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx\n+                        // <l> with IFNOTxxx <l'> GOTO_W <l>, where IFNOTxxx is\n+                        // the \"opposite\" opcode of IFxxx (i.e., IFNE for IFEQ)\n+                        // and where <l'> designates the instruction just after\n+                        // the GOTO_W.\n+                        if (opcode == Opcodes.GOTO) {\n+                            newCode.putByte(200); // GOTO_W\n+                        } else if (opcode == Opcodes.JSR) {\n+                            newCode.putByte(201); // JSR_W\n+                        } else {\n+                            newCode.putByte(opcode <= 166\n+                                    ? ((opcode + 1) ^ 1) - 1\n+                                    : opcode ^ 1);\n+                            newCode.putShort(8); // jump offset\n+                            newCode.putByte(200); // GOTO_W\n+                            // newOffset now computed from start of GOTO_W\n+                            newOffset -= 3;\n+                        }\n+                        newCode.putInt(newOffset);\n+                    } else {\n+                        newCode.putByte(opcode);\n+                        newCode.putShort(newOffset);\n+                    }\n+                    u += 3;\n+                    break;\n+                case ClassWriter.LABELW_INSN:\n+                    label = u + readInt(b, u + 1);\n+                    newOffset = getNewOffset(allIndexes, allSizes, u, label);\n+                    newCode.putByte(opcode);\n+                    newCode.putInt(newOffset);\n+                    u += 5;\n+                    break;\n+                case ClassWriter.TABL_INSN:\n+                    // skips 0 to 3 padding bytes\n+                    v = u;\n+                    u = u + 4 - (v & 3);\n+                    // reads and copies instruction\n+                    newCode.putByte(Opcodes.TABLESWITCH);\n+                    newCode.length += (4 - newCode.length % 4) % 4;\n+                    label = v + readInt(b, u);\n+                    u += 4;\n+                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n+                    newCode.putInt(newOffset);\n+                    j = readInt(b, u);\n+                    u += 4;\n+                    newCode.putInt(j);\n+                    j = readInt(b, u) - j + 1;\n+                    u += 4;\n+                    newCode.putInt(readInt(b, u - 4));\n+                    for (; j > 0; --j) {\n+                        label = v + readInt(b, u);\n+                        u += 4;\n+                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n+                        newCode.putInt(newOffset);\n+                    }\n+                    break;\n+                case ClassWriter.LOOK_INSN:\n+                    // skips 0 to 3 padding bytes\n+                    v = u;\n+                    u = u + 4 - (v & 3);\n+                    // reads and copies instruction\n+                    newCode.putByte(Opcodes.LOOKUPSWITCH);\n+                    newCode.length += (4 - newCode.length % 4) % 4;\n+                    label = v + readInt(b, u);\n+                    u += 4;\n+                    newOffset = getNewOffset(allIndexes, allSizes, v, label);\n+                    newCode.putInt(newOffset);\n+                    j = readInt(b, u);\n+                    u += 4;\n+                    newCode.putInt(j);\n+                    for (; j > 0; --j) {\n+                        newCode.putInt(readInt(b, u));\n+                        u += 4;\n+                        label = v + readInt(b, u);\n+                        u += 4;\n+                        newOffset = getNewOffset(allIndexes, allSizes, v, label);\n+                        newCode.putInt(newOffset);\n+                    }\n+                    break;\n+                case ClassWriter.WIDE_INSN:\n+                    opcode = b[u + 1] & 0xFF;\n+                    if (opcode == Opcodes.IINC) {\n+                        newCode.putByteArray(b, u, 6);\n+                        u += 6;\n+                    } else {\n+                        newCode.putByteArray(b, u, 4);\n+                        u += 4;\n+                    }\n+                    break;\n+                case ClassWriter.VAR_INSN:\n+                case ClassWriter.SBYTE_INSN:\n+                case ClassWriter.LDC_INSN:\n+                    newCode.putByteArray(b, u, 2);\n+                    u += 2;\n+                    break;\n+                case ClassWriter.SHORT_INSN:\n+                case ClassWriter.LDCW_INSN:\n+                case ClassWriter.FIELDORMETH_INSN:\n+                case ClassWriter.TYPE_INSN:\n+                case ClassWriter.IINC_INSN:\n+                    newCode.putByteArray(b, u, 3);\n+                    u += 3;\n+                    break;\n+                case ClassWriter.ITFMETH_INSN:\n+                    newCode.putByteArray(b, u, 5);\n+                    u += 5;\n+                    break;\n+                // case MANA_INSN:\n+                default:\n+                    newCode.putByteArray(b, u, 4);\n+                    u += 4;\n+                    break;\n+            }\n+        }\n+\n+        // recomputes the stack map frames\n+        if (frameCount > 0) {\n+            if (compute == FRAMES) {\n+                frameCount = 0;\n+                stackMap = null;\n+                previousFrame = null;\n+                frame = null;\n+                Frame f = new Frame();\n+                f.owner = labels;\n+                Type[] args = Type.getArgumentTypes(descriptor);\n+                f.initInputFrame(cw, access, args, maxLocals);\n+                visitFrame(f);\n+                Label l = labels;\n+                while (l != null) {\n+                    /*\n+                     * here we need the original label position. getNewOffset\n+                     * must therefore never have been called for this label.\n+                     */\n+                    u = l.position - 3;\n+                    if ((l.status & Label.STORE) != 0 || (u >= 0 && resize[u]))\n+                    {\n+                        getNewOffset(allIndexes, allSizes, l);\n+                        // TODO update offsets in UNINITIALIZED values\n+                        visitFrame(l.frame);\n+                    }\n+                    l = l.successor;\n+                }\n+            } else {\n+                /*\n+                 * Resizing an existing stack map frame table is really hard.\n+                 * Not only the table must be parsed to update the offets, but\n+                 * new frames may be needed for jump instructions that were\n+                 * inserted by this method. And updating the offsets or\n+                 * inserting frames can change the format of the following\n+                 * frames, in case of packed frames. In practice the whole table\n+                 * must be recomputed. For this the frames are marked as\n+                 * potentially invalid. This will cause the whole class to be\n+                 * reread and rewritten with the COMPUTE_FRAMES option (see the\n+                 * ClassWriter.toByteArray method). This is not very efficient\n+                 * but is much easier and requires much less code than any other\n+                 * method I can think of.\n+                 */\n+                cw.invalidFrames = true;\n+            }\n+        }\n+        // updates the exception handler block labels\n+        Handler h = firstHandler;\n+        while (h != null) {\n+            getNewOffset(allIndexes, allSizes, h.start);\n+            getNewOffset(allIndexes, allSizes, h.end);\n+            getNewOffset(allIndexes, allSizes, h.handler);\n+            h = h.next;\n+        }\n+        // updates the instructions addresses in the\n+        // local var and line number tables\n+        for (i = 0; i < 2; ++i) {\n+            ByteVector bv = i == 0 ? localVar : localVarType;\n+            if (bv != null) {\n+                b = bv.data;\n+                u = 0;\n+                while (u < bv.length) {\n+                    label = readUnsignedShort(b, u);\n+                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);\n+                    writeShort(b, u, newOffset);\n+                    label += readUnsignedShort(b, u + 2);\n+                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)\n+                            - newOffset;\n+                    writeShort(b, u + 2, newOffset);\n+                    u += 10;\n+                }\n+            }\n+        }\n+        if (lineNumber != null) {\n+            b = lineNumber.data;\n+            u = 0;\n+            while (u < lineNumber.length) {\n+                writeShort(b, u, getNewOffset(allIndexes,\n+                        allSizes,\n+                        0,\n+                        readUnsignedShort(b, u)));\n+                u += 4;\n+            }\n+        }\n+        // updates the labels of the other attributes\n+        Attribute attr = cattrs;\n+        while (attr != null) {\n+            Label[] labels = attr.getLabels();\n+            if (labels != null) {\n+                for (i = labels.length - 1; i >= 0; --i) {\n+                    getNewOffset(allIndexes, allSizes, labels[i]);\n+                }\n+            }\n+            attr = attr.next;\n+        }\n+\n+        // replaces old bytecodes with new ones\n+        code = newCode;\n+    }\n+\n+    /**\n+     * Reads an unsigned short value in the given byte array.\n+     * \n+     * @param b a byte array.\n+     * @param index the start index of the value to be read.\n+     * @return the read value.\n+     */\n+    static int readUnsignedShort(final byte[] b, final int index) {\n+        return ((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF);\n+    }\n+\n+    /**\n+     * Reads a signed short value in the given byte array.\n+     * \n+     * @param b a byte array.\n+     * @param index the start index of the value to be read.\n+     * @return the read value.\n+     */\n+    static short readShort(final byte[] b, final int index) {\n+        return (short) (((b[index] & 0xFF) << 8) | (b[index + 1] & 0xFF));\n+    }\n+\n+    /**\n+     * Reads a signed int value in the given byte array.\n+     * \n+     * @param b a byte array.\n+     * @param index the start index of the value to be read.\n+     * @return the read value.\n+     */\n+    static int readInt(final byte[] b, final int index) {\n+        return ((b[index] & 0xFF) << 24) | ((b[index + 1] & 0xFF) << 16)\n+                | ((b[index + 2] & 0xFF) << 8) | (b[index + 3] & 0xFF);\n+    }\n+\n+    /**\n+     * Writes a short value in the given byte array.\n+     * \n+     * @param b a byte array.\n+     * @param index where the first byte of the short value must be written.\n+     * @param s the value to be written in the given byte array.\n+     */\n+    static void writeShort(final byte[] b, final int index, final int s) {\n+        b[index] = (byte) (s >>> 8);\n+        b[index + 1] = (byte) s;\n+    }\n+\n+    /**\n+     * Computes the future value of a bytecode offset. <p> Note: it is possible\n+     * to have several entries for the same instruction in the <tt>indexes</tt>\n+     * and <tt>sizes</tt>: two entries (index=a,size=b) and (index=a,size=b')\n+     * are equivalent to a single entry (index=a,size=b+b').\n+     * \n+     * @param indexes current positions of the instructions to be resized. Each\n+     *        instruction must be designated by the index of its <i>last</i>\n+     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n+     *        byte of the <i>next</i> instruction).\n+     * @param sizes the number of bytes to be <i>added</i> to the above\n+     *        instructions. More precisely, for each i < <tt>len</tt>,\n+     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n+     *        instruction designated by <tt>indexes</tt>[i] or, if\n+     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n+     *        bytes of the instruction will be removed (the instruction size\n+     *        <i>must not</i> become negative or null).\n+     * @param begin index of the first byte of the source instruction.\n+     * @param end index of the first byte of the target instruction.\n+     * @return the future value of the given bytecode offset.\n+     */\n+    static int getNewOffset(\n+        final int[] indexes,\n+        final int[] sizes,\n+        final int begin,\n+        final int end)\n+    {\n+        int offset = end - begin;\n+        for (int i = 0; i < indexes.length; ++i) {\n+            if (begin < indexes[i] && indexes[i] <= end) {\n+                // forward jump\n+                offset += sizes[i];\n+            } else if (end < indexes[i] && indexes[i] <= begin) {\n+                // backward jump\n+                offset -= sizes[i];\n+            }\n+        }\n+        return offset;\n+    }\n+\n+    /**\n+     * Updates the offset of the given label.\n+     * \n+     * @param indexes current positions of the instructions to be resized. Each\n+     *        instruction must be designated by the index of its <i>last</i>\n+     *        byte, plus one (or, in other words, by the index of the <i>first</i>\n+     *        byte of the <i>next</i> instruction).\n+     * @param sizes the number of bytes to be <i>added</i> to the above\n+     *        instructions. More precisely, for each i < <tt>len</tt>,\n+     *        <tt>sizes</tt>[i] bytes will be added at the end of the\n+     *        instruction designated by <tt>indexes</tt>[i] or, if\n+     *        <tt>sizes</tt>[i] is negative, the <i>last</i> |<tt>sizes[i]</tt>|\n+     *        bytes of the instruction will be removed (the instruction size\n+     *        <i>must not</i> become negative or null).\n+     * @param label the label whose offset must be updated.\n+     */\n+    static void getNewOffset(\n+        final int[] indexes,\n+        final int[] sizes,\n+        final Label label)\n+    {\n+        if ((label.status & Label.RESIZED) == 0) {\n+            label.position = getNewOffset(indexes, sizes, 0, label.position);\n+            label.status |= Label.RESIZED;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Opcodes.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+/**\n+ * Defines the JVM opcodes, access flags and array type codes. This interface\n+ * does not define all the JVM opcodes because some opcodes are automatically\n+ * handled. For example, the xLOAD and xSTORE opcodes are automatically replaced\n+ * by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n\n+ * opcodes are therefore not defined in this interface. Likewise for LDC,\n+ * automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and\n+ * JSR_W.\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public interface Opcodes {\n+\n+    // versions\n+\n+    int V1_1 = 3 << 16 | 45;\n+    int V1_2 = 0 << 16 | 46;\n+    int V1_3 = 0 << 16 | 47;\n+    int V1_4 = 0 << 16 | 48;\n+    int V1_5 = 0 << 16 | 49;\n+    int V1_6 = 0 << 16 | 50;\n+\n+    // access flags\n+\n+    int ACC_PUBLIC = 0x0001; // class, field, method\n+    int ACC_PRIVATE = 0x0002; // class, field, method\n+    int ACC_PROTECTED = 0x0004; // class, field, method\n+    int ACC_STATIC = 0x0008; // field, method\n+    int ACC_FINAL = 0x0010; // class, field, method\n+    int ACC_SUPER = 0x0020; // class\n+    int ACC_SYNCHRONIZED = 0x0020; // method\n+    int ACC_VOLATILE = 0x0040; // field\n+    int ACC_BRIDGE = 0x0040; // method\n+    int ACC_VARARGS = 0x0080; // method\n+    int ACC_TRANSIENT = 0x0080; // field\n+    int ACC_NATIVE = 0x0100; // method\n+    int ACC_INTERFACE = 0x0200; // class\n+    int ACC_ABSTRACT = 0x0400; // class, method\n+    int ACC_STRICT = 0x0800; // method\n+    int ACC_SYNTHETIC = 0x1000; // class, field, method\n+    int ACC_ANNOTATION = 0x2000; // class\n+    int ACC_ENUM = 0x4000; // class(?) field inner\n+\n+    // ASM specific pseudo access flags\n+\n+    int ACC_DEPRECATED = 131072; // class, field, method\n+\n+    // types for NEWARRAY\n+\n+    int T_BOOLEAN = 4;\n+    int T_CHAR = 5;\n+    int T_FLOAT = 6;\n+    int T_DOUBLE = 7;\n+    int T_BYTE = 8;\n+    int T_SHORT = 9;\n+    int T_INT = 10;\n+    int T_LONG = 11;\n+\n+    // stack map frame types\n+\n+    /**\n+     * Represents an expanded frame. See {@link ClassReader#EXPAND_FRAMES}.\n+     */\n+    int F_NEW = -1;\n+\n+    /**\n+     * Represents a compressed frame with complete frame data.\n+     */\n+    int F_FULL = 0;\n+\n+    /**\n+     * Represents a compressed frame where locals are the same as the locals in\n+     * the previous frame, except that additional 1-3 locals are defined, and\n+     * with an empty stack.\n+     */\n+    int F_APPEND = 1;\n+\n+    /**\n+     * Represents a compressed frame where locals are the same as the locals in\n+     * the previous frame, except that the last 1-3 locals are absent and with\n+     * an empty stack.\n+     */\n+    int F_CHOP = 2;\n+\n+    /**\n+     * Represents a compressed frame with exactly the same locals as the\n+     * previous frame and with an empty stack.\n+     */\n+    int F_SAME = 3;\n+\n+    /**\n+     * Represents a compressed frame with exactly the same locals as the\n+     * previous frame and with a single value on the stack.\n+     */\n+    int F_SAME1 = 4;\n+\n+    Integer TOP = new Integer(0);\n+    Integer INTEGER = new Integer(1);\n+    Integer FLOAT = new Integer(2);\n+    Integer DOUBLE = new Integer(3);\n+    Integer LONG = new Integer(4);\n+    Integer NULL = new Integer(5);\n+    Integer UNINITIALIZED_THIS = new Integer(6);\n+\n+    // opcodes // visit method (- = idem)\n+\n+    int NOP = 0; // visitInsn\n+    int ACONST_NULL = 1; // -\n+    int ICONST_M1 = 2; // -\n+    int ICONST_0 = 3; // -\n+    int ICONST_1 = 4; // -\n+    int ICONST_2 = 5; // -\n+    int ICONST_3 = 6; // -\n+    int ICONST_4 = 7; // -\n+    int ICONST_5 = 8; // -\n+    int LCONST_0 = 9; // -\n+    int LCONST_1 = 10; // -\n+    int FCONST_0 = 11; // -\n+    int FCONST_1 = 12; // -\n+    int FCONST_2 = 13; // -\n+    int DCONST_0 = 14; // -\n+    int DCONST_1 = 15; // -\n+    int BIPUSH = 16; // visitIntInsn\n+    int SIPUSH = 17; // -\n+    int LDC = 18; // visitLdcInsn\n+    // int LDC_W = 19; // -\n+    // int LDC2_W = 20; // -\n+    int ILOAD = 21; // visitVarInsn\n+    int LLOAD = 22; // -\n+    int FLOAD = 23; // -\n+    int DLOAD = 24; // -\n+    int ALOAD = 25; // -\n+    // int ILOAD_0 = 26; // -\n+    // int ILOAD_1 = 27; // -\n+    // int ILOAD_2 = 28; // -\n+    // int ILOAD_3 = 29; // -\n+    // int LLOAD_0 = 30; // -\n+    // int LLOAD_1 = 31; // -\n+    // int LLOAD_2 = 32; // -\n+    // int LLOAD_3 = 33; // -\n+    // int FLOAD_0 = 34; // -\n+    // int FLOAD_1 = 35; // -\n+    // int FLOAD_2 = 36; // -\n+    // int FLOAD_3 = 37; // -\n+    // int DLOAD_0 = 38; // -\n+    // int DLOAD_1 = 39; // -\n+    // int DLOAD_2 = 40; // -\n+    // int DLOAD_3 = 41; // -\n+    // int ALOAD_0 = 42; // -\n+    // int ALOAD_1 = 43; // -\n+    // int ALOAD_2 = 44; // -\n+    // int ALOAD_3 = 45; // -\n+    int IALOAD = 46; // visitInsn\n+    int LALOAD = 47; // -\n+    int FALOAD = 48; // -\n+    int DALOAD = 49; // -\n+    int AALOAD = 50; // -\n+    int BALOAD = 51; // -\n+    int CALOAD = 52; // -\n+    int SALOAD = 53; // -\n+    int ISTORE = 54; // visitVarInsn\n+    int LSTORE = 55; // -\n+    int FSTORE = 56; // -\n+    int DSTORE = 57; // -\n+    int ASTORE = 58; // -\n+    // int ISTORE_0 = 59; // -\n+    // int ISTORE_1 = 60; // -\n+    // int ISTORE_2 = 61; // -\n+    // int ISTORE_3 = 62; // -\n+    // int LSTORE_0 = 63; // -\n+    // int LSTORE_1 = 64; // -\n+    // int LSTORE_2 = 65; // -\n+    // int LSTORE_3 = 66; // -\n+    // int FSTORE_0 = 67; // -\n+    // int FSTORE_1 = 68; // -\n+    // int FSTORE_2 = 69; // -\n+    // int FSTORE_3 = 70; // -\n+    // int DSTORE_0 = 71; // -\n+    // int DSTORE_1 = 72; // -\n+    // int DSTORE_2 = 73; // -\n+    // int DSTORE_3 = 74; // -\n+    // int ASTORE_0 = 75; // -\n+    // int ASTORE_1 = 76; // -\n+    // int ASTORE_2 = 77; // -\n+    // int ASTORE_3 = 78; // -\n+    int IASTORE = 79; // visitInsn\n+    int LASTORE = 80; // -\n+    int FASTORE = 81; // -\n+    int DASTORE = 82; // -\n+    int AASTORE = 83; // -\n+    int BASTORE = 84; // -\n+    int CASTORE = 85; // -\n+    int SASTORE = 86; // -\n+    int POP = 87; // -\n+    int POP2 = 88; // -\n+    int DUP = 89; // -\n+    int DUP_X1 = 90; // -\n+    int DUP_X2 = 91; // -\n+    int DUP2 = 92; // -\n+    int DUP2_X1 = 93; // -\n+    int DUP2_X2 = 94; // -\n+    int SWAP = 95; // -\n+    int IADD = 96; // -\n+    int LADD = 97; // -\n+    int FADD = 98; // -\n+    int DADD = 99; // -\n+    int ISUB = 100; // -\n+    int LSUB = 101; // -\n+    int FSUB = 102; // -\n+    int DSUB = 103; // -\n+    int IMUL = 104; // -\n+    int LMUL = 105; // -\n+    int FMUL = 106; // -\n+    int DMUL = 107; // -\n+    int IDIV = 108; // -\n+    int LDIV = 109; // -\n+    int FDIV = 110; // -\n+    int DDIV = 111; // -\n+    int IREM = 112; // -\n+    int LREM = 113; // -\n+    int FREM = 114; // -\n+    int DREM = 115; // -\n+    int INEG = 116; // -\n+    int LNEG = 117; // -\n+    int FNEG = 118; // -\n+    int DNEG = 119; // -\n+    int ISHL = 120; // -\n+    int LSHL = 121; // -\n+    int ISHR = 122; // -\n+    int LSHR = 123; // -\n+    int IUSHR = 124; // -\n+    int LUSHR = 125; // -\n+    int IAND = 126; // -\n+    int LAND = 127; // -\n+    int IOR = 128; // -\n+    int LOR = 129; // -\n+    int IXOR = 130; // -\n+    int LXOR = 131; // -\n+    int IINC = 132; // visitIincInsn\n+    int I2L = 133; // visitInsn\n+    int I2F = 134; // -\n+    int I2D = 135; // -\n+    int L2I = 136; // -\n+    int L2F = 137; // -\n+    int L2D = 138; // -\n+    int F2I = 139; // -\n+    int F2L = 140; // -\n+    int F2D = 141; // -\n+    int D2I = 142; // -\n+    int D2L = 143; // -\n+    int D2F = 144; // -\n+    int I2B = 145; // -\n+    int I2C = 146; // -\n+    int I2S = 147; // -\n+    int LCMP = 148; // -\n+    int FCMPL = 149; // -\n+    int FCMPG = 150; // -\n+    int DCMPL = 151; // -\n+    int DCMPG = 152; // -\n+    int IFEQ = 153; // visitJumpInsn\n+    int IFNE = 154; // -\n+    int IFLT = 155; // -\n+    int IFGE = 156; // -\n+    int IFGT = 157; // -\n+    int IFLE = 158; // -\n+    int IF_ICMPEQ = 159; // -\n+    int IF_ICMPNE = 160; // -\n+    int IF_ICMPLT = 161; // -\n+    int IF_ICMPGE = 162; // -\n+    int IF_ICMPGT = 163; // -\n+    int IF_ICMPLE = 164; // -\n+    int IF_ACMPEQ = 165; // -\n+    int IF_ACMPNE = 166; // -\n+    int GOTO = 167; // -\n+    int JSR = 168; // -\n+    int RET = 169; // visitVarInsn\n+    int TABLESWITCH = 170; // visiTableSwitchInsn\n+    int LOOKUPSWITCH = 171; // visitLookupSwitch\n+    int IRETURN = 172; // visitInsn\n+    int LRETURN = 173; // -\n+    int FRETURN = 174; // -\n+    int DRETURN = 175; // -\n+    int ARETURN = 176; // -\n+    int RETURN = 177; // -\n+    int GETSTATIC = 178; // visitFieldInsn\n+    int PUTSTATIC = 179; // -\n+    int GETFIELD = 180; // -\n+    int PUTFIELD = 181; // -\n+    int INVOKEVIRTUAL = 182; // visitMethodInsn\n+    int INVOKESPECIAL = 183; // -\n+    int INVOKESTATIC = 184; // -\n+    int INVOKEINTERFACE = 185; // -\n+    // int UNUSED = 186; // NOT VISITED\n+    int NEW = 187; // visitTypeInsn\n+    int NEWARRAY = 188; // visitIntInsn\n+    int ANEWARRAY = 189; // visitTypeInsn\n+    int ARRAYLENGTH = 190; // visitInsn\n+    int ATHROW = 191; // -\n+    int CHECKCAST = 192; // visitTypeInsn\n+    int INSTANCEOF = 193; // -\n+    int MONITORENTER = 194; // visitInsn\n+    int MONITOREXIT = 195; // -\n+    // int WIDE = 196; // NOT VISITED\n+    int MULTIANEWARRAY = 197; // visitMultiANewArrayInsn\n+    int IFNULL = 198; // visitJumpInsn\n+    int IFNONNULL = 199; // -\n+    // int GOTO_W = 200; // -\n+    // int JSR_W = 201; // -\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/Type.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * A Java type. This class can be used to make it easier to manipulate type and\n+ * method descriptors.\n+ * \n+ * @author Eric Bruneton\n+ * @author Chris Nokleberg\n+ */\n+public class Type {\n+\n+    /**\n+     * The sort of the <tt>void</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int VOID = 0;\n+\n+    /**\n+     * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int BOOLEAN = 1;\n+\n+    /**\n+     * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int CHAR = 2;\n+\n+    /**\n+     * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int BYTE = 3;\n+\n+    /**\n+     * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int SHORT = 4;\n+\n+    /**\n+     * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int INT = 5;\n+\n+    /**\n+     * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int FLOAT = 6;\n+\n+    /**\n+     * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int LONG = 7;\n+\n+    /**\n+     * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.\n+     */\n+    public static final int DOUBLE = 8;\n+\n+    /**\n+     * The sort of array reference types. See {@link #getSort getSort}.\n+     */\n+    public static final int ARRAY = 9;\n+\n+    /**\n+     * The sort of object reference type. See {@link #getSort getSort}.\n+     */\n+    public static final int OBJECT = 10;\n+\n+    /**\n+     * The <tt>void</tt> type.\n+     */\n+    public static final Type VOID_TYPE = new Type(VOID);\n+\n+    /**\n+     * The <tt>boolean</tt> type.\n+     */\n+    public static final Type BOOLEAN_TYPE = new Type(BOOLEAN);\n+\n+    /**\n+     * The <tt>char</tt> type.\n+     */\n+    public static final Type CHAR_TYPE = new Type(CHAR);\n+\n+    /**\n+     * The <tt>byte</tt> type.\n+     */\n+    public static final Type BYTE_TYPE = new Type(BYTE);\n+\n+    /**\n+     * The <tt>short</tt> type.\n+     */\n+    public static final Type SHORT_TYPE = new Type(SHORT);\n+\n+    /**\n+     * The <tt>int</tt> type.\n+     */\n+    public static final Type INT_TYPE = new Type(INT);\n+\n+    /**\n+     * The <tt>float</tt> type.\n+     */\n+    public static final Type FLOAT_TYPE = new Type(FLOAT);\n+\n+    /**\n+     * The <tt>long</tt> type.\n+     */\n+    public static final Type LONG_TYPE = new Type(LONG);\n+\n+    /**\n+     * The <tt>double</tt> type.\n+     */\n+    public static final Type DOUBLE_TYPE = new Type(DOUBLE);\n+\n+    // ------------------------------------------------------------------------\n+    // Fields\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The sort of this Java type.\n+     */\n+    private final int sort;\n+\n+    /**\n+     * A buffer containing the internal name of this Java type. This field is\n+     * only used for reference types.\n+     */\n+    private final char[] buf;\n+\n+    /**\n+     * The offset of the internal name of this Java type in {@link #buf buf}.\n+     * This field is only used for reference types.\n+     */\n+    private final int off;\n+\n+    /**\n+     * The length of the internal name of this Java type. This field is only\n+     * used for reference types.\n+     */\n+    private final int len;\n+\n+    // ------------------------------------------------------------------------\n+    // Constructors\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Constructs a primitive type.\n+     * \n+     * @param sort the sort of the primitive type to be constructed.\n+     */\n+    private Type(final int sort) {\n+        this(sort, null, 0, 1);\n+    }\n+\n+    /**\n+     * Constructs a reference type.\n+     * \n+     * @param sort the sort of the reference type to be constructed.\n+     * @param buf a buffer containing the descriptor of the previous type.\n+     * @param off the offset of this descriptor in the previous buffer.\n+     * @param len the length of this descriptor.\n+     */\n+    private Type(final int sort, final char[] buf, final int off, final int len)\n+    {\n+        this.sort = sort;\n+        this.buf = buf;\n+        this.off = off;\n+        this.len = len;\n+    }\n+\n+    /**\n+     * Returns the Java type corresponding to the given type descriptor.\n+     * \n+     * @param typeDescriptor a type descriptor.\n+     * @return the Java type corresponding to the given type descriptor.\n+     */\n+    public static Type getType(final String typeDescriptor) {\n+        return getType(typeDescriptor.toCharArray(), 0);\n+    }\n+\n+    /**\n+     * Returns the Java type corresponding to the given internal name.\n+     * \n+     * @param internalName an internal name.\n+     * @return the Java type corresponding to the given internal name.\n+     */\n+    public static Type getObjectType(final String internalName) {\n+        char[] buf = internalName.toCharArray();\n+        return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\n+    }\n+\n+    /**\n+     * Returns the Java type corresponding to the given class.\n+     * \n+     * @param c a class.\n+     * @return the Java type corresponding to the given class.\n+     */\n+    public static Type getType(final Class c) {\n+        if (c.isPrimitive()) {\n+            if (c == Integer.TYPE) {\n+                return INT_TYPE;\n+            } else if (c == Void.TYPE) {\n+                return VOID_TYPE;\n+            } else if (c == Boolean.TYPE) {\n+                return BOOLEAN_TYPE;\n+            } else if (c == Byte.TYPE) {\n+                return BYTE_TYPE;\n+            } else if (c == Character.TYPE) {\n+                return CHAR_TYPE;\n+            } else if (c == Short.TYPE) {\n+                return SHORT_TYPE;\n+            } else if (c == Double.TYPE) {\n+                return DOUBLE_TYPE;\n+            } else if (c == Float.TYPE) {\n+                return FLOAT_TYPE;\n+            } else /* if (c == Long.TYPE) */{\n+                return LONG_TYPE;\n+            }\n+        } else {\n+            return getType(getDescriptor(c));\n+        }\n+    }\n+\n+    /**\n+     * Returns the Java types corresponding to the argument types of the given\n+     * method descriptor.\n+     * \n+     * @param methodDescriptor a method descriptor.\n+     * @return the Java types corresponding to the argument types of the given\n+     *         method descriptor.\n+     */\n+    public static Type[] getArgumentTypes(final String methodDescriptor) {\n+        char[] buf = methodDescriptor.toCharArray();\n+        int off = 1;\n+        int size = 0;\n+        while (true) {\n+            char car = buf[off++];\n+            if (car == ')') {\n+                break;\n+            } else if (car == 'L') {\n+                while (buf[off++] != ';') {\n+                }\n+                ++size;\n+            } else if (car != '[') {\n+                ++size;\n+            }\n+        }\n+        Type[] args = new Type[size];\n+        off = 1;\n+        size = 0;\n+        while (buf[off] != ')') {\n+            args[size] = getType(buf, off);\n+            off += args[size].len + (args[size].sort == OBJECT ? 2 : 0);\n+            size += 1;\n+        }\n+        return args;\n+    }\n+\n+    /**\n+     * Returns the Java types corresponding to the argument types of the given\n+     * method.\n+     * \n+     * @param method a method.\n+     * @return the Java types corresponding to the argument types of the given\n+     *         method.\n+     */\n+    public static Type[] getArgumentTypes(final Method method) {\n+        Class[] classes = method.getParameterTypes();\n+        Type[] types = new Type[classes.length];\n+        for (int i = classes.length - 1; i >= 0; --i) {\n+            types[i] = getType(classes[i]);\n+        }\n+        return types;\n+    }\n+\n+    /**\n+     * Returns the Java type corresponding to the return type of the given\n+     * method descriptor.\n+     * \n+     * @param methodDescriptor a method descriptor.\n+     * @return the Java type corresponding to the return type of the given\n+     *         method descriptor.\n+     */\n+    public static Type getReturnType(final String methodDescriptor) {\n+        char[] buf = methodDescriptor.toCharArray();\n+        return getType(buf, methodDescriptor.indexOf(')') + 1);\n+    }\n+\n+    /**\n+     * Returns the Java type corresponding to the return type of the given\n+     * method.\n+     * \n+     * @param method a method.\n+     * @return the Java type corresponding to the return type of the given\n+     *         method.\n+     */\n+    public static Type getReturnType(final Method method) {\n+        return getType(method.getReturnType());\n+    }\n+\n+    /**\n+     * Returns the Java type corresponding to the given type descriptor.\n+     * \n+     * @param buf a buffer containing a type descriptor.\n+     * @param off the offset of this descriptor in the previous buffer.\n+     * @return the Java type corresponding to the given type descriptor.\n+     */\n+    private static Type getType(final char[] buf, final int off) {\n+        int len;\n+        switch (buf[off]) {\n+            case 'V':\n+                return VOID_TYPE;\n+            case 'Z':\n+                return BOOLEAN_TYPE;\n+            case 'C':\n+                return CHAR_TYPE;\n+            case 'B':\n+                return BYTE_TYPE;\n+            case 'S':\n+                return SHORT_TYPE;\n+            case 'I':\n+                return INT_TYPE;\n+            case 'F':\n+                return FLOAT_TYPE;\n+            case 'J':\n+                return LONG_TYPE;\n+            case 'D':\n+                return DOUBLE_TYPE;\n+            case '[':\n+                len = 1;\n+                while (buf[off + len] == '[') {\n+                    ++len;\n+                }\n+                if (buf[off + len] == 'L') {\n+                    ++len;\n+                    while (buf[off + len] != ';') {\n+                        ++len;\n+                    }\n+                }\n+                return new Type(ARRAY, buf, off, len + 1);\n+                // case 'L':\n+            default:\n+                len = 1;\n+                while (buf[off + len] != ';') {\n+                    ++len;\n+                }\n+                return new Type(OBJECT, buf, off + 1, len - 1);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Accessors\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the sort of this Java type.\n+     * \n+     * @return {@link #VOID VOID}, {@link #BOOLEAN BOOLEAN},\n+     *         {@link #CHAR CHAR}, {@link #BYTE BYTE}, {@link #SHORT SHORT},\n+     *         {@link #INT INT}, {@link #FLOAT FLOAT}, {@link #LONG LONG},\n+     *         {@link #DOUBLE DOUBLE}, {@link #ARRAY ARRAY} or\n+     *         {@link #OBJECT OBJECT}.\n+     */\n+    public int getSort() {\n+        return sort;\n+    }\n+\n+    /**\n+     * Returns the number of dimensions of this array type. This method should\n+     * only be used for an array type.\n+     * \n+     * @return the number of dimensions of this array type.\n+     */\n+    public int getDimensions() {\n+        int i = 1;\n+        while (buf[off + i] == '[') {\n+            ++i;\n+        }\n+        return i;\n+    }\n+\n+    /**\n+     * Returns the type of the elements of this array type. This method should\n+     * only be used for an array type.\n+     * \n+     * @return Returns the type of the elements of this array type.\n+     */\n+    public Type getElementType() {\n+        return getType(buf, off + getDimensions());\n+    }\n+\n+    /**\n+     * Returns the name of the class corresponding to this type.\n+     * \n+     * @return the fully qualified name of the class corresponding to this type.\n+     */\n+    public String getClassName() {\n+        switch (sort) {\n+            case VOID:\n+                return \"void\";\n+            case BOOLEAN:\n+                return \"boolean\";\n+            case CHAR:\n+                return \"char\";\n+            case BYTE:\n+                return \"byte\";\n+            case SHORT:\n+                return \"short\";\n+            case INT:\n+                return \"int\";\n+            case FLOAT:\n+                return \"float\";\n+            case LONG:\n+                return \"long\";\n+            case DOUBLE:\n+                return \"double\";\n+            case ARRAY:\n+                StringBuffer b = new StringBuffer(getElementType().getClassName());\n+                for (int i = getDimensions(); i > 0; --i) {\n+                    b.append(\"[]\");\n+                }\n+                return b.toString();\n+                // case OBJECT:\n+            default:\n+                return new String(buf, off, len).replace('/', '.');\n+        }\n+    }\n+\n+    /**\n+     * Returns the internal name of the class corresponding to this object or\n+     * array type. The internal name of a class is its fully qualified name (as\n+     * returned by Class.getName(), where '.' are replaced by '/'. This method\n+     * should only be used for an object or array type.\n+     * \n+     * @return the internal name of the class corresponding to this object type.\n+     */\n+    public String getInternalName() {\n+        return new String(buf, off, len);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Conversion to type descriptors\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the descriptor corresponding to this Java type.\n+     * \n+     * @return the descriptor corresponding to this Java type.\n+     */\n+    public String getDescriptor() {\n+        StringBuffer buf = new StringBuffer();\n+        getDescriptor(buf);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Returns the descriptor corresponding to the given argument and return\n+     * types.\n+     * \n+     * @param returnType the return type of the method.\n+     * @param argumentTypes the argument types of the method.\n+     * @return the descriptor corresponding to the given argument and return\n+     *         types.\n+     */\n+    public static String getMethodDescriptor(\n+        final Type returnType,\n+        final Type[] argumentTypes)\n+    {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append('(');\n+        for (int i = 0; i < argumentTypes.length; ++i) {\n+            argumentTypes[i].getDescriptor(buf);\n+        }\n+        buf.append(')');\n+        returnType.getDescriptor(buf);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Appends the descriptor corresponding to this Java type to the given\n+     * string buffer.\n+     * \n+     * @param buf the string buffer to which the descriptor must be appended.\n+     */\n+    private void getDescriptor(final StringBuffer buf) {\n+        switch (sort) {\n+            case VOID:\n+                buf.append('V');\n+                return;\n+            case BOOLEAN:\n+                buf.append('Z');\n+                return;\n+            case CHAR:\n+                buf.append('C');\n+                return;\n+            case BYTE:\n+                buf.append('B');\n+                return;\n+            case SHORT:\n+                buf.append('S');\n+                return;\n+            case INT:\n+                buf.append('I');\n+                return;\n+            case FLOAT:\n+                buf.append('F');\n+                return;\n+            case LONG:\n+                buf.append('J');\n+                return;\n+            case DOUBLE:\n+                buf.append('D');\n+                return;\n+            case ARRAY:\n+                buf.append(this.buf, off, len);\n+                return;\n+                // case OBJECT:\n+            default:\n+                buf.append('L');\n+                buf.append(this.buf, off, len);\n+                buf.append(';');\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Direct conversion from classes to type descriptors,\n+    // without intermediate Type objects\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the internal name of the given class. The internal name of a\n+     * class is its fully qualified name, as returned by Class.getName(), where\n+     * '.' are replaced by '/'.\n+     * \n+     * @param c an object or array class.\n+     * @return the internal name of the given class.\n+     */\n+    public static String getInternalName(final Class c) {\n+        return c.getName().replace('.', '/');\n+    }\n+\n+    /**\n+     * Returns the descriptor corresponding to the given Java type.\n+     * \n+     * @param c an object class, a primitive class or an array class.\n+     * @return the descriptor corresponding to the given class.\n+     */\n+    public static String getDescriptor(final Class c) {\n+        StringBuffer buf = new StringBuffer();\n+        getDescriptor(buf, c);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Returns the descriptor corresponding to the given constructor.\n+     * \n+     * @param c a {@link Constructor Constructor} object.\n+     * @return the descriptor of the given constructor.\n+     */\n+    public static String getConstructorDescriptor(final Constructor c) {\n+        Class[] parameters = c.getParameterTypes();\n+        StringBuffer buf = new StringBuffer();\n+        buf.append('(');\n+        for (int i = 0; i < parameters.length; ++i) {\n+            getDescriptor(buf, parameters[i]);\n+        }\n+        return buf.append(\")V\").toString();\n+    }\n+\n+    /**\n+     * Returns the descriptor corresponding to the given method.\n+     * \n+     * @param m a {@link Method Method} object.\n+     * @return the descriptor of the given method.\n+     */\n+    public static String getMethodDescriptor(final Method m) {\n+        Class[] parameters = m.getParameterTypes();\n+        StringBuffer buf = new StringBuffer();\n+        buf.append('(');\n+        for (int i = 0; i < parameters.length; ++i) {\n+            getDescriptor(buf, parameters[i]);\n+        }\n+        buf.append(')');\n+        getDescriptor(buf, m.getReturnType());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Appends the descriptor of the given class to the given string buffer.\n+     * \n+     * @param buf the string buffer to which the descriptor must be appended.\n+     * @param c the class whose descriptor must be computed.\n+     */\n+    private static void getDescriptor(final StringBuffer buf, final Class c) {\n+        Class d = c;\n+        while (true) {\n+            if (d.isPrimitive()) {\n+                char car;\n+                if (d == Integer.TYPE) {\n+                    car = 'I';\n+                } else if (d == Void.TYPE) {\n+                    car = 'V';\n+                } else if (d == Boolean.TYPE) {\n+                    car = 'Z';\n+                } else if (d == Byte.TYPE) {\n+                    car = 'B';\n+                } else if (d == Character.TYPE) {\n+                    car = 'C';\n+                } else if (d == Short.TYPE) {\n+                    car = 'S';\n+                } else if (d == Double.TYPE) {\n+                    car = 'D';\n+                } else if (d == Float.TYPE) {\n+                    car = 'F';\n+                } else /* if (d == Long.TYPE) */{\n+                    car = 'J';\n+                }\n+                buf.append(car);\n+                return;\n+            } else if (d.isArray()) {\n+                buf.append('[');\n+                d = d.getComponentType();\n+            } else {\n+                buf.append('L');\n+                String name = d.getName();\n+                int len = name.length();\n+                for (int i = 0; i < len; ++i) {\n+                    char car = name.charAt(i);\n+                    buf.append(car == '.' ? '/' : car);\n+                }\n+                buf.append(';');\n+                return;\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Corresponding size and opcodes\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the size of values of this type.\n+     * \n+     * @return the size of values of this type, i.e., 2 for <tt>long</tt> and\n+     *         <tt>double</tt>, and 1 otherwise.\n+     */\n+    public int getSize() {\n+        return sort == LONG || sort == DOUBLE ? 2 : 1;\n+    }\n+\n+    /**\n+     * Returns a JVM instruction opcode adapted to this Java type.\n+     * \n+     * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD,\n+     *        ISTORE, IALOAD, IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL,\n+     *        ISHR, IUSHR, IAND, IOR, IXOR and IRETURN.\n+     * @return an opcode that is similar to the given opcode, but adapted to\n+     *         this Java type. For example, if this type is <tt>float</tt> and\n+     *         <tt>opcode</tt> is IRETURN, this method returns FRETURN.\n+     */\n+    public int getOpcode(final int opcode) {\n+        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\n+            switch (sort) {\n+                case BOOLEAN:\n+                case BYTE:\n+                    return opcode + 5;\n+                case CHAR:\n+                    return opcode + 6;\n+                case SHORT:\n+                    return opcode + 7;\n+                case INT:\n+                    return opcode;\n+                case FLOAT:\n+                    return opcode + 2;\n+                case LONG:\n+                    return opcode + 1;\n+                case DOUBLE:\n+                    return opcode + 3;\n+                    // case ARRAY:\n+                    // case OBJECT:\n+                default:\n+                    return opcode + 4;\n+            }\n+        } else {\n+            switch (sort) {\n+                case VOID:\n+                    return opcode + 5;\n+                case BOOLEAN:\n+                case CHAR:\n+                case BYTE:\n+                case SHORT:\n+                case INT:\n+                    return opcode;\n+                case FLOAT:\n+                    return opcode + 2;\n+                case LONG:\n+                    return opcode + 1;\n+                case DOUBLE:\n+                    return opcode + 3;\n+                    // case ARRAY:\n+                    // case OBJECT:\n+                default:\n+                    return opcode + 4;\n+            }\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Equals, hashCode and toString\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Tests if the given object is equal to this type.\n+     * \n+     * @param o the object to be compared to this type.\n+     * @return <tt>true</tt> if the given object is equal to this type.\n+     */\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (!(o instanceof Type)) {\n+            return false;\n+        }\n+        Type t = (Type) o;\n+        if (sort != t.sort) {\n+            return false;\n+        }\n+        if (sort == OBJECT || sort == ARRAY) {\n+            if (len != t.len) {\n+                return false;\n+            }\n+            for (int i = off, j = t.off, end = i + len; i < end; i++, j++) {\n+                if (buf[i] != t.buf[j]) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a hash code value for this type.\n+     * \n+     * @return a hash code value for this type.\n+     */\n+    public int hashCode() {\n+        int hc = 13 * sort;\n+        if (sort == OBJECT || sort == ARRAY) {\n+            for (int i = off, end = i + len; i < end; i++) {\n+                hc = 17 * (hc + buf[i]);\n+            }\n+        }\n+        return hc;\n+    }\n+\n+    /**\n+     * Returns a string representation of this type.\n+     * \n+     * @return the descriptor of this type.\n+     */\n+    public String toString() {\n+        return getDescriptor();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/signature/SignatureReader.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.signature;\n+\n+/**\n+ * A type signature parser to make a signature visitor visit an existing\n+ * signature.\n+ * \n+ * @author Thomas Hallgren\n+ * @author Eric Bruneton\n+ */\n+public class SignatureReader {\n+\n+    /**\n+     * The signature to be read.\n+     */\n+    private final String signature;\n+\n+    /**\n+     * Constructs a {@link SignatureReader} for the given signature.\n+     * \n+     * @param signature A <i>ClassSignature</i>, <i>MethodTypeSignature</i>,\n+     *        or <i>FieldTypeSignature</i>.\n+     */\n+    public SignatureReader(final String signature) {\n+        this.signature = signature;\n+    }\n+\n+    /**\n+     * Makes the given visitor visit the signature of this\n+     * {@link SignatureReader}. This signature is the one specified in the\n+     * constructor (see {@link #SignatureReader(String) SignatureReader}). This\n+     * method is intended to be called on a {@link SignatureReader} that was\n+     * created using a <i>ClassSignature</i> (such as the\n+     * <code>signature</code> parameter of the\n+     * {@link org.mockito.asm.ClassVisitor#visit ClassVisitor.visit} method)\n+     * or a <i>MethodTypeSignature</i> (such as the <code>signature</code>\n+     * parameter of the\n+     * {@link org.mockito.asm.ClassVisitor#visitMethod ClassVisitor.visitMethod}\n+     * method).\n+     * \n+     * @param v the visitor that must visit this signature.\n+     */\n+    public void accept(final SignatureVisitor v) {\n+        String signature = this.signature;\n+        int len = signature.length();\n+        int pos;\n+        char c;\n+\n+        if (signature.charAt(0) == '<') {\n+            pos = 2;\n+            do {\n+                int end = signature.indexOf(':', pos);\n+                v.visitFormalTypeParameter(signature.substring(pos - 1, end));\n+                pos = end + 1;\n+\n+                c = signature.charAt(pos);\n+                if (c == 'L' || c == '[' || c == 'T') {\n+                    pos = parseType(signature, pos, v.visitClassBound());\n+                }\n+\n+                while ((c = signature.charAt(pos++)) == ':') {\n+                    pos = parseType(signature, pos, v.visitInterfaceBound());\n+                }\n+            } while (c != '>');\n+        } else {\n+            pos = 0;\n+        }\n+\n+        if (signature.charAt(pos) == '(') {\n+            pos++;\n+            while (signature.charAt(pos) != ')') {\n+                pos = parseType(signature, pos, v.visitParameterType());\n+            }\n+            pos = parseType(signature, pos + 1, v.visitReturnType());\n+            while (pos < len) {\n+                pos = parseType(signature, pos + 1, v.visitExceptionType());\n+            }\n+        } else {\n+            pos = parseType(signature, pos, v.visitSuperclass());\n+            while (pos < len) {\n+                pos = parseType(signature, pos, v.visitInterface());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Makes the given visitor visit the signature of this\n+     * {@link SignatureReader}. This signature is the one specified in the\n+     * constructor (see {@link #SignatureReader(String) SignatureReader}). This\n+     * method is intended to be called on a {@link SignatureReader} that was\n+     * created using a <i>FieldTypeSignature</i>, such as the\n+     * <code>signature</code> parameter of the\n+     * {@link org.mockito.asm.ClassVisitor#visitField \n+     * ClassVisitor.visitField} or {@link \n+     * org.mockito.asm.MethodVisitor#visitLocalVariable\n+     * MethodVisitor.visitLocalVariable} methods.\n+     * \n+     * @param v the visitor that must visit this signature.\n+     */\n+    public void acceptType(final SignatureVisitor v) {\n+        parseType(this.signature, 0, v);\n+    }\n+\n+    /**\n+     * Parses a field type signature and makes the given visitor visit it.\n+     * \n+     * @param signature a string containing the signature that must be parsed.\n+     * @param pos index of the first character of the signature to parsed.\n+     * @param v the visitor that must visit this signature.\n+     * @return the index of the first character after the parsed signature.\n+     */\n+    private static int parseType(\n+        final String signature,\n+        int pos,\n+        final SignatureVisitor v)\n+    {\n+        char c;\n+        int start, end;\n+        boolean visited, inner;\n+        String name;\n+\n+        switch (c = signature.charAt(pos++)) {\n+            case 'Z':\n+            case 'C':\n+            case 'B':\n+            case 'S':\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D':\n+            case 'V':\n+                v.visitBaseType(c);\n+                return pos;\n+\n+            case '[':\n+                return parseType(signature, pos, v.visitArrayType());\n+\n+            case 'T':\n+                end = signature.indexOf(';', pos);\n+                v.visitTypeVariable(signature.substring(pos, end));\n+                return end + 1;\n+\n+            default: // case 'L':\n+                start = pos;\n+                visited = false;\n+                inner = false;\n+                for (;;) {\n+                    switch (c = signature.charAt(pos++)) {\n+                        case '.':\n+                        case ';':\n+                            if (!visited) {\n+                                name = signature.substring(start, pos - 1);\n+                                if (inner) {\n+                                    v.visitInnerClassType(name);\n+                                } else {\n+                                    v.visitClassType(name);\n+                                }\n+                            }\n+                            if (c == ';') {\n+                                v.visitEnd();\n+                                return pos;\n+                            }\n+                            start = pos;\n+                            visited = false;\n+                            inner = true;\n+                            break;\n+\n+                        case '<':\n+                            name = signature.substring(start, pos - 1);\n+                            if (inner) {\n+                                v.visitInnerClassType(name);\n+                            } else {\n+                                v.visitClassType(name);\n+                            }\n+                            visited = true;\n+                            top: for (;;) {\n+                                switch (c = signature.charAt(pos)) {\n+                                    case '>':\n+                                        break top;\n+                                    case '*':\n+                                        ++pos;\n+                                        v.visitTypeArgument();\n+                                        break;\n+                                    case '+':\n+                                    case '-':\n+                                        pos = parseType(signature,\n+                                                pos + 1,\n+                                                v.visitTypeArgument(c));\n+                                        break;\n+                                    default:\n+                                        pos = parseType(signature,\n+                                                pos,\n+                                                v.visitTypeArgument('='));\n+                                        break;\n+                                }\n+                            }\n+                    }\n+                }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/signature/SignatureVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.signature;\n+\n+/**\n+ * A visitor to visit a generic signature. The methods of this interface must be\n+ * called in one of the three following orders (the last one is the only valid\n+ * order for a {@link SignatureVisitor} that is returned by a method of this\n+ * interface): <ul> <li><i>ClassSignature</i> = (\n+ * <tt>visitFormalTypeParameter</tt> \n+ *   <tt>visitClassBound</tt>?\n+ * <tt>visitInterfaceBound</tt>* )* ( <tt>visitSuperClass</tt> \n+ *   <tt>visitInterface</tt>* )</li>\n+ * <li><i>MethodSignature</i> = ( <tt>visitFormalTypeParameter</tt> \n+ *   <tt>visitClassBound</tt>?\n+ * <tt>visitInterfaceBound</tt>* )* ( <tt>visitParameterType</tt>*\n+ * <tt>visitReturnType</tt> \n+ *   <tt>visitExceptionType</tt>* )</li> <li><i>TypeSignature</i> =\n+ * <tt>visitBaseType</tt> | <tt>visitTypeVariable</tt> |\n+ * <tt>visitArrayType</tt> | (\n+ * <tt>visitClassType</tt> <tt>visitTypeArgument</tt>* (\n+ * <tt>visitInnerClassType</tt> <tt>visitTypeArgument</tt>* )*\n+ * <tt>visitEnd</tt> ) )</li> </ul>\n+ * \n+ * @author Thomas Hallgren\n+ * @author Eric Bruneton\n+ */\n+public interface SignatureVisitor {\n+\n+    /**\n+     * Wildcard for an \"extends\" type argument.\n+     */\n+    char EXTENDS = '+';\n+\n+    /**\n+     * Wildcard for a \"super\" type argument.\n+     */\n+    char SUPER = '-';\n+\n+    /**\n+     * Wildcard for a normal type argument.\n+     */\n+    char INSTANCEOF = '=';\n+\n+    /**\n+     * Visits a formal type parameter.\n+     * \n+     * @param name the name of the formal parameter.\n+     */\n+    void visitFormalTypeParameter(String name);\n+\n+    /**\n+     * Visits the class bound of the last visited formal type parameter.\n+     * \n+     * @return a non null visitor to visit the signature of the class bound.\n+     */\n+    SignatureVisitor visitClassBound();\n+\n+    /**\n+     * Visits an interface bound of the last visited formal type parameter.\n+     * \n+     * @return a non null visitor to visit the signature of the interface bound.\n+     */\n+    SignatureVisitor visitInterfaceBound();\n+\n+    /**\n+     * Visits the type of the super class.\n+     * \n+     * @return a non null visitor to visit the signature of the super class\n+     *         type.\n+     */\n+    SignatureVisitor visitSuperclass();\n+\n+    /**\n+     * Visits the type of an interface implemented by the class.\n+     * \n+     * @return a non null visitor to visit the signature of the interface type.\n+     */\n+    SignatureVisitor visitInterface();\n+\n+    /**\n+     * Visits the type of a method parameter.\n+     * \n+     * @return a non null visitor to visit the signature of the parameter type.\n+     */\n+    SignatureVisitor visitParameterType();\n+\n+    /**\n+     * Visits the return type of the method.\n+     * \n+     * @return a non null visitor to visit the signature of the return type.\n+     */\n+    SignatureVisitor visitReturnType();\n+\n+    /**\n+     * Visits the type of a method exception.\n+     * \n+     * @return a non null visitor to visit the signature of the exception type.\n+     */\n+    SignatureVisitor visitExceptionType();\n+\n+    /**\n+     * Visits a signature corresponding to a primitive type.\n+     * \n+     * @param descriptor the descriptor of the primitive type, or 'V' for\n+     *        <tt>void</tt>.\n+     */\n+    void visitBaseType(char descriptor);\n+\n+    /**\n+     * Visits a signature corresponding to a type variable.\n+     * \n+     * @param name the name of the type variable.\n+     */\n+    void visitTypeVariable(String name);\n+\n+    /**\n+     * Visits a signature corresponding to an array type.\n+     * \n+     * @return a non null visitor to visit the signature of the array element\n+     *         type.\n+     */\n+    SignatureVisitor visitArrayType();\n+\n+    /**\n+     * Starts the visit of a signature corresponding to a class or interface\n+     * type.\n+     * \n+     * @param name the internal name of the class or interface.\n+     */\n+    void visitClassType(String name);\n+\n+    /**\n+     * Visits an inner class.\n+     * \n+     * @param name the local name of the inner class in its enclosing class.\n+     */\n+    void visitInnerClassType(String name);\n+\n+    /**\n+     * Visits an unbounded type argument of the last visited class or inner\n+     * class type.\n+     */\n+    void visitTypeArgument();\n+\n+    /**\n+     * Visits a type argument of the last visited class or inner class type.\n+     * \n+     * @param wildcard '+', '-' or '='.\n+     * @return a non null visitor to visit the signature of the type argument.\n+     */\n+    SignatureVisitor visitTypeArgument(char wildcard);\n+\n+    /**\n+     * Ends the visit of a signature corresponding to a class or interface type.\n+     */\n+    void visitEnd();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/signature/SignatureWriter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.signature;\n+\n+/**\n+ * A signature visitor that generates signatures in string format.\n+ * \n+ * @author Thomas Hallgren\n+ * @author Eric Bruneton\n+ */\n+public class SignatureWriter implements SignatureVisitor {\n+\n+    /**\n+     * Buffer used to construct the signature.\n+     */\n+    private final StringBuffer buf = new StringBuffer();\n+\n+    /**\n+     * Indicates if the signature contains formal type parameters.\n+     */\n+    private boolean hasFormals;\n+\n+    /**\n+     * Indicates if the signature contains method parameter types.\n+     */\n+    private boolean hasParameters;\n+\n+    /**\n+     * Stack used to keep track of class types that have arguments. Each element\n+     * of this stack is a boolean encoded in one bit. The top of the stack is\n+     * the lowest order bit. Pushing false = *2, pushing true = *2+1, popping =\n+     * /2.\n+     */\n+    private int argumentStack;\n+\n+    /**\n+     * Constructs a new {@link SignatureWriter} object.\n+     */\n+    public SignatureWriter() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the SignatureVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visitFormalTypeParameter(final String name) {\n+        if (!hasFormals) {\n+            hasFormals = true;\n+            buf.append('<');\n+        }\n+        buf.append(name);\n+        buf.append(':');\n+    }\n+\n+    public SignatureVisitor visitClassBound() {\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitInterfaceBound() {\n+        buf.append(':');\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitSuperclass() {\n+        endFormals();\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitInterface() {\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitParameterType() {\n+        endFormals();\n+        if (!hasParameters) {\n+            hasParameters = true;\n+            buf.append('(');\n+        }\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitReturnType() {\n+        endFormals();\n+        if (!hasParameters) {\n+            buf.append('(');\n+        }\n+        buf.append(')');\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitExceptionType() {\n+        buf.append('^');\n+        return this;\n+    }\n+\n+    public void visitBaseType(final char descriptor) {\n+        buf.append(descriptor);\n+    }\n+\n+    public void visitTypeVariable(final String name) {\n+        buf.append('T');\n+        buf.append(name);\n+        buf.append(';');\n+    }\n+\n+    public SignatureVisitor visitArrayType() {\n+        buf.append('[');\n+        return this;\n+    }\n+\n+    public void visitClassType(final String name) {\n+        buf.append('L');\n+        buf.append(name);\n+        argumentStack *= 2;\n+    }\n+\n+    public void visitInnerClassType(final String name) {\n+        endArguments();\n+        buf.append('.');\n+        buf.append(name);\n+        argumentStack *= 2;\n+    }\n+\n+    public void visitTypeArgument() {\n+        if (argumentStack % 2 == 0) {\n+            ++argumentStack;\n+            buf.append('<');\n+        }\n+        buf.append('*');\n+    }\n+\n+    public SignatureVisitor visitTypeArgument(final char wildcard) {\n+        if (argumentStack % 2 == 0) {\n+            ++argumentStack;\n+            buf.append('<');\n+        }\n+        if (wildcard != '=') {\n+            buf.append(wildcard);\n+        }\n+        return this;\n+    }\n+\n+    public void visitEnd() {\n+        endArguments();\n+        buf.append(';');\n+    }\n+\n+    /**\n+     * Returns the signature that was built by this signature writer.\n+     * \n+     * @return the signature that was built by this signature writer.\n+     */\n+    public String toString() {\n+        return buf.toString();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Ends the formal type parameters section of the signature.\n+     */\n+    private void endFormals() {\n+        if (hasFormals) {\n+            hasFormals = false;\n+            buf.append('>');\n+        }\n+    }\n+\n+    /**\n+     * Ends the type arguments of a class or inner class type.\n+     */\n+    private void endArguments() {\n+        if (argumentStack % 2 != 0) {\n+            buf.append('>');\n+        }\n+        argumentStack /= 2;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/AbstractInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a bytecode instruction. <i>An instruction can appear\n+ * at most once in at most one {@link InsnList} at a time</i>.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public abstract class AbstractInsnNode {\n+\n+    /**\n+     * The type of {@link InsnNode} instructions.\n+     */\n+    public static final int INSN = 0;\n+\n+    /**\n+     * The type of {@link IntInsnNode} instructions.\n+     */\n+    public static final int INT_INSN = 1;\n+\n+    /**\n+     * The type of {@link VarInsnNode} instructions.\n+     */\n+    public static final int VAR_INSN = 2;\n+\n+    /**\n+     * The type of {@link TypeInsnNode} instructions.\n+     */\n+    public static final int TYPE_INSN = 3;\n+\n+    /**\n+     * The type of {@link FieldInsnNode} instructions.\n+     */\n+    public static final int FIELD_INSN = 4;\n+\n+    /**\n+     * The type of {@link MethodInsnNode} instructions.\n+     */\n+    public static final int METHOD_INSN = 5;\n+\n+    /**\n+     * The type of {@link JumpInsnNode} instructions.\n+     */\n+    public static final int JUMP_INSN = 6;\n+\n+    /**\n+     * The type of {@link LabelNode} \"instructions\".\n+     */\n+    public static final int LABEL = 7;\n+\n+    /**\n+     * The type of {@link LdcInsnNode} instructions.\n+     */\n+    public static final int LDC_INSN = 8;\n+\n+    /**\n+     * The type of {@link IincInsnNode} instructions.\n+     */\n+    public static final int IINC_INSN = 9;\n+\n+    /**\n+     * The type of {@link TableSwitchInsnNode} instructions.\n+     */\n+    public static final int TABLESWITCH_INSN = 10;\n+\n+    /**\n+     * The type of {@link LookupSwitchInsnNode} instructions.\n+     */\n+    public static final int LOOKUPSWITCH_INSN = 11;\n+\n+    /**\n+     * The type of {@link MultiANewArrayInsnNode} instructions.\n+     */\n+    public static final int MULTIANEWARRAY_INSN = 12;\n+\n+    /**\n+     * The type of {@link FrameNode} \"instructions\".\n+     */\n+    public static final int FRAME = 13;\n+\n+    /**\n+     * The type of {@link LineNumberNode} \"instructions\".\n+     */\n+    public static final int LINE = 14;\n+\n+    /**\n+     * The opcode of this instruction.\n+     */\n+    protected int opcode;\n+\n+    /**\n+     * Previous instruction in the list to which this instruction belongs.\n+     */\n+    AbstractInsnNode prev;\n+\n+    /**\n+     * Next instruction in the list to which this instruction belongs.\n+     */\n+    AbstractInsnNode next;\n+\n+    /**\n+     * Index of this instruction in the list to which it belongs. The value of\n+     * this field is correct only when {@link InsnList#cache} is not null. A\n+     * value of -1 indicates that this instruction does not belong to any\n+     * {@link InsnList}.\n+     */\n+    int index;\n+\n+    /**\n+     * Constructs a new {@link AbstractInsnNode}.\n+     * \n+     * @param opcode the opcode of the instruction to be constructed.\n+     */\n+    protected AbstractInsnNode(final int opcode) {\n+        this.opcode = opcode;\n+        this.index = -1;\n+    }\n+\n+    /**\n+     * Returns the opcode of this instruction.\n+     * \n+     * @return the opcode of this instruction.\n+     */\n+    public int getOpcode() {\n+        return opcode;\n+    }\n+\n+    /**\n+     * Returns the type of this instruction.\n+     * \n+     * @return the type of this instruction, i.e. one the constants defined in\n+     *         this class.\n+     */\n+    public abstract int getType();\n+\n+    /**\n+     * Returns the previous instruction in the list to which this instruction\n+     * belongs, if any.\n+     * \n+     * @return the previous instruction in the list to which this instruction\n+     *         belongs, if any. May be <tt>null</tt>.\n+     */\n+    public AbstractInsnNode getPrevious() {\n+        return prev;\n+    }\n+\n+    /**\n+     * Returns the next instruction in the list to which this instruction\n+     * belongs, if any.\n+     * \n+     * @return the next instruction in the list to which this instruction\n+     *         belongs, if any. May be <tt>null</tt>.\n+     */\n+    public AbstractInsnNode getNext() {\n+        return next;\n+    }\n+\n+    /**\n+     * Makes the given code visitor visit this instruction.\n+     * \n+     * @param cv a code visitor.\n+     */\n+    public abstract void accept(final MethodVisitor cv);\n+\n+    /**\n+     * Returns a copy of this instruction.\n+     * \n+     * @param labels a map from LabelNodes to cloned LabelNodes.\n+     * @return a copy of this instruction. The returned instruction does not\n+     *         belong to any {@link InsnList}.\n+     */\n+    public abstract AbstractInsnNode clone(final Map labels);\n+\n+    /**\n+     * Returns the clone of the given label.\n+     * \n+     * @param label a label.\n+     * @param map a map from LabelNodes to cloned LabelNodes.\n+     * @return the clone of the given label.\n+     */\n+    static LabelNode clone(final LabelNode label, final Map map) {\n+        return (LabelNode) map.get(label);\n+    }\n+\n+    /**\n+     * Returns the clones of the given labels.\n+     * \n+     * @param labels a list of labels.\n+     * @param map a map from LabelNodes to cloned LabelNodes.\n+     * @return the clones of the given labels.\n+     */\n+    static LabelNode[] clone(final List labels, final Map map) {\n+        LabelNode[] clones = new LabelNode[labels.size()];\n+        for (int i = 0; i < clones.length; ++i) {\n+            clones[i] = (LabelNode) map.get(labels.get(i));\n+        }\n+        return clones;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/AnnotationNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+\n+/**\n+ * A node that represents an annotationn.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class AnnotationNode implements AnnotationVisitor {\n+\n+    /**\n+     * The class descriptor of the annotation class.\n+     */\n+    public String desc;\n+\n+    /**\n+     * The name value pairs of this annotation. Each name value pair is stored\n+     * as two consecutive elements in the list. The name is a {@link String},\n+     * and the value may be a {@link Byte}, {@link Boolean}, {@link Character},\n+     * {@link Short}, {@link Integer}, {@link Long}, {@link Float},\n+     * {@link Double}, {@link String} or {@link org.mockito.asm.Type}, or an\n+     * two elements String array (for enumeration values), a\n+     * {@link AnnotationNode}, or a {@link List} of values of one of the\n+     * preceding types. The list may be <tt>null</tt> if there is no name\n+     * value pair.\n+     */\n+    public List values;\n+\n+    /**\n+     * Constructs a new {@link AnnotationNode}.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     */\n+    public AnnotationNode(final String desc) {\n+        this.desc = desc;\n+    }\n+\n+    /**\n+     * Constructs a new {@link AnnotationNode} to visit an array value.\n+     * \n+     * @param values where the visited values must be stored.\n+     */\n+    AnnotationNode(final List values) {\n+        this.values = values;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the AnnotationVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(final String name, final Object value) {\n+        if (values == null) {\n+            values = new ArrayList(this.desc != null ? 2 : 1);\n+        }\n+        if (this.desc != null) {\n+            values.add(name);\n+        }\n+        values.add(value);\n+    }\n+\n+    public void visitEnum(\n+        final String name,\n+        final String desc,\n+        final String value)\n+    {\n+        if (values == null) {\n+            values = new ArrayList(this.desc != null ? 2 : 1);\n+        }\n+        if (this.desc != null) {\n+            values.add(name);\n+        }\n+        values.add(new String[] { desc, value });\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String name,\n+        final String desc)\n+    {\n+        if (values == null) {\n+            values = new ArrayList(this.desc != null ? 2 : 1);\n+        }\n+        if (this.desc != null) {\n+            values.add(name);\n+        }\n+        AnnotationNode annotation = new AnnotationNode(desc);\n+        values.add(annotation);\n+        return annotation;\n+    }\n+\n+    public AnnotationVisitor visitArray(final String name) {\n+        if (values == null) {\n+            values = new ArrayList(this.desc != null ? 2 : 1);\n+        }\n+        if (this.desc != null) {\n+            values.add(name);\n+        }\n+        List array = new ArrayList();\n+        values.add(array);\n+        return new AnnotationNode(array);\n+    }\n+\n+    public void visitEnd() {\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Accept methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Makes the given visitor visit this annotation.\n+     * \n+     * @param av an annotation visitor. Maybe <tt>null</tt>.\n+     */\n+    public void accept(final AnnotationVisitor av) {\n+        if (av != null) {\n+            if (values != null) {\n+                for (int i = 0; i < values.size(); i += 2) {\n+                    String name = (String) values.get(i);\n+                    Object value = values.get(i + 1);\n+                    accept(av, name, value);\n+                }\n+            }\n+            av.visitEnd();\n+        }\n+    }\n+\n+    /**\n+     * Makes the given visitor visit a given annotation value.\n+     * \n+     * @param av an annotation visitor. Maybe <tt>null</tt>.\n+     * @param name the value name.\n+     * @param value the actual value.\n+     */\n+    static void accept(\n+        final AnnotationVisitor av,\n+        final String name,\n+        final Object value)\n+    {\n+        if (av != null) {\n+            if (value instanceof String[]) {\n+                String[] typeconst = (String[]) value;\n+                av.visitEnum(name, typeconst[0], typeconst[1]);\n+            } else if (value instanceof AnnotationNode) {\n+                AnnotationNode an = (AnnotationNode) value;\n+                an.accept(av.visitAnnotation(name, an.desc));\n+            } else if (value instanceof List) {\n+                AnnotationVisitor v = av.visitArray(name);\n+                List array = (List) value;\n+                for (int j = 0; j < array.size(); ++j) {\n+                    accept(v, null, array.get(j));\n+                }\n+                v.visitEnd();\n+            } else {\n+                av.visit(name, value);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/ClassNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.FieldVisitor;\n+import org.mockito.asm.MethodVisitor;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * A node that represents a class.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ClassNode extends MemberNode implements ClassVisitor {\n+\n+    /**\n+     * The class version.\n+     */\n+    public int version;\n+\n+    /**\n+     * The class's access flags (see {@link org.mockito.asm.Opcodes}). This\n+     * field also indicates if the class is deprecated.\n+     */\n+    public int access;\n+\n+    /**\n+     * The internal name of the class (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     */\n+    public String name;\n+\n+    /**\n+     * The signature of the class. Mayt be <tt>null</tt>.\n+     */\n+    public String signature;\n+\n+    /**\n+     * The internal of name of the super class (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}). For\n+     * interfaces, the super class is {@link Object}. May be <tt>null</tt>,\n+     * but only for the {@link Object} class.\n+     */\n+    public String superName;\n+\n+    /**\n+     * The internal names of the class's interfaces (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}). This\n+     * list is a list of {@link String} objects.\n+     */\n+    public List interfaces;\n+\n+    /**\n+     * The name of the source file from which this class was compiled. May be\n+     * <tt>null</tt>.\n+     */\n+    public String sourceFile;\n+\n+    /**\n+     * Debug information to compute the correspondance between source and\n+     * compiled elements of the class. May be <tt>null</tt>.\n+     */\n+    public String sourceDebug;\n+\n+    /**\n+     * The internal name of the enclosing class of the class. May be\n+     * <tt>null</tt>.\n+     */\n+    public String outerClass;\n+\n+    /**\n+     * The name of the method that contains the class, or <tt>null</tt> if the\n+     * class is not enclosed in a method.\n+     */\n+    public String outerMethod;\n+\n+    /**\n+     * The descriptor of the method that contains the class, or <tt>null</tt>\n+     * if the class is not enclosed in a method.\n+     */\n+    public String outerMethodDesc;\n+\n+    /**\n+     * Informations about the inner classes of this class. This list is a list\n+     * of {@link InnerClassNode} objects.\n+     * \n+     * @associates org.mockito.asm.tree.InnerClassNode\n+     */\n+    public List innerClasses;\n+\n+    /**\n+     * The fields of this class. This list is a list of {@link FieldNode}\n+     * objects.\n+     * \n+     * @associates org.mockito.asm.tree.FieldNode\n+     */\n+    public List fields;\n+\n+    /**\n+     * The methods of this class. This list is a list of {@link MethodNode}\n+     * objects.\n+     * \n+     * @associates org.mockito.asm.tree.MethodNode\n+     */\n+    public List methods;\n+\n+    /**\n+     * Constructs a new {@link ClassNode}.\n+     */\n+    public ClassNode() {\n+        this.interfaces = new ArrayList();\n+        this.innerClasses = new ArrayList();\n+        this.fields = new ArrayList();\n+        this.methods = new ArrayList();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the ClassVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(\n+        final int version,\n+        final int access,\n+        final String name,\n+        final String signature,\n+        final String superName,\n+        final String[] interfaces)\n+    {\n+        this.version = version;\n+        this.access = access;\n+        this.name = name;\n+        this.signature = signature;\n+        this.superName = superName;\n+        if (interfaces != null) {\n+            this.interfaces.addAll(Arrays.asList(interfaces));\n+        }\n+    }\n+\n+    public void visitSource(final String file, final String debug) {\n+        sourceFile = file;\n+        sourceDebug = debug;\n+    }\n+\n+    public void visitOuterClass(\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        outerClass = owner;\n+        outerMethod = name;\n+        outerMethodDesc = desc;\n+    }\n+\n+    public void visitInnerClass(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        InnerClassNode icn = new InnerClassNode(name,\n+                outerName,\n+                innerName,\n+                access);\n+        innerClasses.add(icn);\n+    }\n+\n+    public FieldVisitor visitField(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        FieldNode fn = new FieldNode(access, name, desc, signature, value);\n+        fields.add(fn);\n+        return fn;\n+    }\n+\n+    public MethodVisitor visitMethod(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        MethodNode mn = new MethodNode(access,\n+                name,\n+                desc,\n+                signature,\n+                exceptions);\n+        methods.add(mn);\n+        return mn;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Accept method\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Makes the given class visitor visit this class.\n+     * \n+     * @param cv a class visitor.\n+     */\n+    public void accept(final ClassVisitor cv) {\n+        // visits header\n+        String[] interfaces = new String[this.interfaces.size()];\n+        this.interfaces.toArray(interfaces);\n+        cv.visit(version, access, name, signature, superName, interfaces);\n+        // visits source\n+        if (sourceFile != null || sourceDebug != null) {\n+            cv.visitSource(sourceFile, sourceDebug);\n+        }\n+        // visits outer class\n+        if (outerClass != null) {\n+            cv.visitOuterClass(outerClass, outerMethod, outerMethodDesc);\n+        }\n+        // visits attributes\n+        int i, n;\n+        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();\n+        for (i = 0; i < n; ++i) {\n+            AnnotationNode an = (AnnotationNode) visibleAnnotations.get(i);\n+            an.accept(cv.visitAnnotation(an.desc, true));\n+        }\n+        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();\n+        for (i = 0; i < n; ++i) {\n+            AnnotationNode an = (AnnotationNode) invisibleAnnotations.get(i);\n+            an.accept(cv.visitAnnotation(an.desc, false));\n+        }\n+        n = attrs == null ? 0 : attrs.size();\n+        for (i = 0; i < n; ++i) {\n+            cv.visitAttribute((Attribute) attrs.get(i));\n+        }\n+        // visits inner classes\n+        for (i = 0; i < innerClasses.size(); ++i) {\n+            ((InnerClassNode) innerClasses.get(i)).accept(cv);\n+        }\n+        // visits fields\n+        for (i = 0; i < fields.size(); ++i) {\n+            ((FieldNode) fields.get(i)).accept(cv);\n+        }\n+        // visits methods\n+        for (i = 0; i < methods.size(); ++i) {\n+            ((MethodNode) methods.get(i)).accept(cv);\n+        }\n+        // visits end\n+        cv.visitEnd();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/FieldInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a field instruction. A field instruction is an\n+ * instruction that loads or stores the value of a field of an object.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class FieldInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The internal name of the field's owner class (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     */\n+    public String owner;\n+\n+    /**\n+     * The field's name.\n+     */\n+    public String name;\n+\n+    /**\n+     * The field's descriptor (see {@link org.mockito.asm.Type}).\n+     */\n+    public String desc;\n+\n+    /**\n+     * Constructs a new {@link FieldInsnNode}.\n+     * \n+     * @param opcode the opcode of the type instruction to be constructed. This\n+     *        opcode must be GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.\n+     * @param owner the internal name of the field's owner class (see\n+     *        {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     * @param name the field's name.\n+     * @param desc the field's descriptor (see {@link org.mockito.asm.Type}).\n+     */\n+    public FieldInsnNode(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        super(opcode);\n+        this.owner = owner;\n+        this.name = name;\n+        this.desc = desc;\n+    }\n+\n+    /**\n+     * Sets the opcode of this instruction.\n+     * \n+     * @param opcode the new instruction opcode. This opcode must be GETSTATIC,\n+     *        PUTSTATIC, GETFIELD or PUTFIELD.\n+     */\n+    public void setOpcode(final int opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    public int getType() {\n+        return FIELD_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor cv) {\n+        cv.visitFieldInsn(opcode, owner, name, desc);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new FieldInsnNode(opcode, owner, name, desc);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/FieldNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.FieldVisitor;\n+\n+/**\n+ * A node that represents a field.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class FieldNode extends MemberNode implements FieldVisitor {\n+\n+    /**\n+     * The field's access flags (see {@link org.mockito.asm.Opcodes}). This\n+     * field also indicates if the field is synthetic and/or deprecated.\n+     */\n+    public int access;\n+\n+    /**\n+     * The field's name.\n+     */\n+    public String name;\n+\n+    /**\n+     * The field's descriptor (see {@link org.mockito.asm.Type}).\n+     */\n+    public String desc;\n+\n+    /**\n+     * The field's signature. May be <tt>null</tt>.\n+     */\n+    public String signature;\n+\n+    /**\n+     * The field's initial value. This field, which may be <tt>null</tt> if\n+     * the field does not have an initial value, must be an {@link Integer}, a\n+     * {@link Float}, a {@link Long}, a {@link Double} or a {@link String}.\n+     */\n+    public Object value;\n+\n+    /**\n+     * Constructs a new {@link FieldNode}.\n+     * \n+     * @param access the field's access flags (see\n+     *        {@link org.mockito.asm.Opcodes}). This parameter also indicates\n+     *        if the field is synthetic and/or deprecated.\n+     * @param name the field's name.\n+     * @param desc the field's descriptor (see\n+     *        {@link org.mockito.asm.Type Type}).\n+     * @param signature the field's signature.\n+     * @param value the field's initial value. This parameter, which may be\n+     *        <tt>null</tt> if the field does not have an initial value, must\n+     *        be an {@link Integer}, a {@link Float}, a {@link Long}, a\n+     *        {@link Double} or a {@link String}.\n+     */\n+    public FieldNode(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        this.access = access;\n+        this.name = name;\n+        this.desc = desc;\n+        this.signature = signature;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Makes the given class visitor visit this field.\n+     * \n+     * @param cv a class visitor.\n+     */\n+    public void accept(final ClassVisitor cv) {\n+        FieldVisitor fv = cv.visitField(access, name, desc, signature, value);\n+        if (fv == null) {\n+            return;\n+        }\n+        int i, n;\n+        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();\n+        for (i = 0; i < n; ++i) {\n+            AnnotationNode an = (AnnotationNode) visibleAnnotations.get(i);\n+            an.accept(fv.visitAnnotation(an.desc, true));\n+        }\n+        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();\n+        for (i = 0; i < n; ++i) {\n+            AnnotationNode an = (AnnotationNode) invisibleAnnotations.get(i);\n+            an.accept(fv.visitAnnotation(an.desc, false));\n+        }\n+        n = attrs == null ? 0 : attrs.size();\n+        for (i = 0; i < n; ++i) {\n+            fv.visitAttribute((Attribute) attrs.get(i));\n+        }\n+        fv.visitEnd();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/FrameNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+/**\n+ * A node that represents a stack map frame. These nodes are pseudo instruction\n+ * nodes in order to be inserted in an instruction list. In fact these nodes\n+ * must(*) be inserted <i>just before</i> any instruction node <b>i</b> that\n+ * follows an unconditionnal branch instruction such as GOTO or THROW, that is\n+ * the target of a jump instruction, or that starts an exception handler block.\n+ * The stack map frame types must describe the values of the local variables and\n+ * of the operand stack elements <i>just before</i> <b>i</b> is executed. <br>\n+ * <br> (*) this is mandatory only for classes whose version is greater than or\n+ * equal to {@link Opcodes#V1_6 V1_6}.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class FrameNode extends AbstractInsnNode {\n+\n+    /**\n+     * The type of this frame. Must be {@link Opcodes#F_NEW} for expanded\n+     * frames, or {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},\n+     * {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or\n+     * {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for compressed frames.\n+     */\n+    public int type;\n+\n+    /**\n+     * The types of the local variables of this stack map frame. Elements of\n+     * this list can be Integer, String or LabelNode objects (for primitive,\n+     * reference and uninitialized types respectively - see\n+     * {@link MethodVisitor}).\n+     */\n+    public List local;\n+\n+    /**\n+     * The types of the operand stack elements of this stack map frame. Elements\n+     * of this list can be Integer, String or LabelNode objects (for primitive,\n+     * reference and uninitialized types respectively - see\n+     * {@link MethodVisitor}).\n+     */\n+    public List stack;\n+\n+    private FrameNode() {\n+        super(-1);\n+    }\n+\n+    /**\n+     * Constructs a new {@link FrameNode}.\n+     * \n+     * @param type the type of this frame. Must be {@link Opcodes#F_NEW} for\n+     *        expanded frames, or {@link Opcodes#F_FULL},\n+     *        {@link Opcodes#F_APPEND}, {@link Opcodes#F_CHOP},\n+     *        {@link Opcodes#F_SAME} or {@link Opcodes#F_APPEND},\n+     *        {@link Opcodes#F_SAME1} for compressed frames.\n+     * @param nLocal number of local variables of this stack map frame.\n+     * @param local the types of the local variables of this stack map frame.\n+     *        Elements of this list can be Integer, String or LabelNode objects\n+     *        (for primitive, reference and uninitialized types respectively -\n+     *        see {@link MethodVisitor}).\n+     * @param nStack number of operand stack elements of this stack map frame.\n+     * @param stack the types of the operand stack elements of this stack map\n+     *        frame. Elements of this list can be Integer, String or LabelNode\n+     *        objects (for primitive, reference and uninitialized types\n+     *        respectively - see {@link MethodVisitor}).\n+     */\n+    public FrameNode(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        super(-1);\n+        this.type = type;\n+        switch (type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                this.local = asList(nLocal, local);\n+                this.stack = asList(nStack, stack);\n+                break;\n+            case Opcodes.F_APPEND:\n+                this.local = asList(nLocal, local);\n+                break;\n+            case Opcodes.F_CHOP:\n+                this.local = asList(nLocal, local);\n+                break;\n+            case Opcodes.F_SAME:\n+                break;\n+            case Opcodes.F_SAME1:\n+                this.stack = asList(1, stack);\n+                break;\n+        }\n+    }\n+\n+    public int getType() {\n+        return FRAME;\n+    }\n+\n+    /**\n+     * Makes the given visitor visit this stack map frame.\n+     * \n+     * @param mv a method visitor.\n+     */\n+    public void accept(final MethodVisitor mv) {\n+        switch (type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                mv.visitFrame(type,\n+                        local.size(),\n+                        asArray(local),\n+                        stack.size(),\n+                        asArray(stack));\n+                break;\n+            case Opcodes.F_APPEND:\n+                mv.visitFrame(type, local.size(), asArray(local), 0, null);\n+                break;\n+            case Opcodes.F_CHOP:\n+                mv.visitFrame(type, local.size(), asArray(local), 0, null);\n+                break;\n+            case Opcodes.F_SAME:\n+                mv.visitFrame(type, 0, null, 0, null);\n+                break;\n+            case Opcodes.F_SAME1:\n+                mv.visitFrame(type, 0, null, 1, asArray(stack));\n+                break;\n+        }\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        FrameNode clone = new FrameNode();\n+        clone.type = type;\n+        if (local != null) {\n+            clone.local = new ArrayList();\n+            for (int i = 0; i < local.size(); ++i) {\n+                Object l = local.get(i);\n+                if (l instanceof LabelNode) {\n+                    l = labels.get(l);\n+                }\n+                clone.local.add(l);\n+            }\n+        }\n+        if (stack != null) {\n+            clone.stack = new ArrayList();\n+            for (int i = 0; i < stack.size(); ++i) {\n+                Object s = stack.get(i);\n+                if (s instanceof LabelNode) {\n+                    s = labels.get(s);\n+                }\n+                clone.stack.add(s);\n+            }\n+        }\n+        return clone;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+\n+    private static List asList(final int n, final Object[] o) {\n+        return Arrays.asList(o).subList(0, n);\n+    }\n+\n+    private static Object[] asArray(final List l) {\n+        Object[] objs = new Object[l.size()];\n+        for (int i = 0; i < objs.length; ++i) {\n+            Object o = l.get(i);\n+            if (o instanceof LabelNode) {\n+                o = ((LabelNode) o).getLabel();\n+            }\n+            objs[i] = o;\n+        }\n+        return objs;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/IincInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+/**\n+ * A node that represents an IINC instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class IincInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * Index of the local variable to be incremented.\n+     */\n+    public int var;\n+\n+    /**\n+     * Amount to increment the local variable by.\n+     */\n+    public int incr;\n+\n+    /**\n+     * Constructs a new {@link IincInsnNode}.\n+     * \n+     * @param var index of the local variable to be incremented.\n+     * @param incr increment amount to increment the local variable by.\n+     */\n+    public IincInsnNode(final int var, final int incr) {\n+        super(Opcodes.IINC);\n+        this.var = var;\n+        this.incr = incr;\n+    }\n+\n+    public int getType() {\n+        return IINC_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitIincInsn(var, incr);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new IincInsnNode(var, incr);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/InnerClassNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.ClassVisitor;\n+\n+/**\n+ * A node that represents an inner class.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class InnerClassNode {\n+\n+    /**\n+     * The internal name of an inner class (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     */\n+    public String name;\n+\n+    /**\n+     * The internal name of the class to which the inner class belongs (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}). May\n+     * be <tt>null</tt>.\n+     */\n+    public String outerName;\n+\n+    /**\n+     * The (simple) name of the inner class inside its enclosing class. May be\n+     * <tt>null</tt> for anonymous inner classes.\n+     */\n+    public String innerName;\n+\n+    /**\n+     * The access flags of the inner class as originally declared in the\n+     * enclosing class.\n+     */\n+    public int access;\n+\n+    /**\n+     * Constructs a new {@link InnerClassNode}.\n+     * \n+     * @param name the internal name of an inner class (see\n+     *        {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     * @param outerName the internal name of the class to which the inner class\n+     *        belongs (see\n+     *        {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     *        May be <tt>null</tt>.\n+     * @param innerName the (simple) name of the inner class inside its\n+     *        enclosing class. May be <tt>null</tt> for anonymous inner\n+     *        classes.\n+     * @param access the access flags of the inner class as originally declared\n+     *        in the enclosing class.\n+     */\n+    public InnerClassNode(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        this.name = name;\n+        this.outerName = outerName;\n+        this.innerName = innerName;\n+        this.access = access;\n+    }\n+\n+    /**\n+     * Makes the given class visitor visit this inner class.\n+     * \n+     * @param cv a class visitor.\n+     */\n+    public void accept(final ClassVisitor cv) {\n+        cv.visitInnerClass(name, outerName, innerName, access);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/InsnList.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A doubly linked list of {@link AbstractInsnNode} objects. <i>This\n+ * implementation is not thread safe</i>.\n+ */\n+public class InsnList {\n+\n+    /**\n+     * Indicates if preconditions of methods of this class must be checked.\n+     * <i>Checking preconditions causes the {@link #indexOf indexOf},\n+     * {@link #set set}, {@link #insert(AbstractInsnNode, AbstractInsnNode)},\n+     * {@link #insert(AbstractInsnNode, InsnList)}, {@link #remove remove} and\n+     * {@link #clear} methods to execute in O(n) time instead of O(1)</i>.\n+     */\n+    public static boolean check;\n+\n+    /**\n+     * The number of instructions in this list.\n+     */\n+    private int size;\n+\n+    /**\n+     * The first instruction in this list. May be <tt>null</tt>.\n+     */\n+    private AbstractInsnNode first;\n+\n+    /**\n+     * The last instruction in this list. May be <tt>null</tt>.\n+     */\n+    private AbstractInsnNode last;\n+\n+    /**\n+     * A cache of the instructions of this list. This cache is used to improve\n+     * the performance of the {@link #get} method.\n+     */\n+    private AbstractInsnNode[] cache;\n+\n+    /**\n+     * Returns the number of instructions in this list.\n+     * \n+     * @return the number of instructions in this list.\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns the first instruction in this list.\n+     * \n+     * @return the first instruction in this list, or <tt>null</tt> if the\n+     *         list is empty.\n+     */\n+    public AbstractInsnNode getFirst() {\n+        return first;\n+    }\n+\n+    /**\n+     * Returns the last instruction in this list.\n+     * \n+     * @return the last instruction in this list, or <tt>null</tt> if the list\n+     *         is empty.\n+     */\n+    public AbstractInsnNode getLast() {\n+        return last;\n+    }\n+\n+    /**\n+     * Returns the instruction whose index is given. This method builds a cache\n+     * of the instructions in this list to avoid scanning the whole list each\n+     * time it is called. Once the cache is built, this method run in constant\n+     * time. This cache is invalidated by all the methods that modify the list.\n+     * \n+     * @param index the index of the instruction that must be returned.\n+     * @return the instruction whose index is given.\n+     * @throws IndexOutOfBoundsException if (index < 0 || index >= size()).\n+     */\n+    public AbstractInsnNode get(final int index) {\n+        if (index < 0 || index >= size) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+        if (cache == null) {\n+            cache = toArray();\n+        }\n+        return cache[index];\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if the given instruction belongs to this list.\n+     * This method always scans the instructions of this list until it finds the\n+     * given instruction or reaches the end of the list.\n+     * \n+     * @param insn an instruction.\n+     * @return <tt>true</tt> if the given instruction belongs to this list.\n+     */\n+    public boolean contains(final AbstractInsnNode insn) {\n+        AbstractInsnNode i = first;\n+        while (i != null && i != insn) {\n+            i = i.next;\n+        }\n+        return i != null;\n+    }\n+\n+    /**\n+     * Returns the index of the given instruction in this list. This method\n+     * builds a cache of the instruction indexes to avoid scanning the whole\n+     * list each time it is called. Once the cache is built, this method run in\n+     * constant time. The cache is invalidated by all the methods that modify\n+     * the list.\n+     * \n+     * @param insn an instruction <i>of this list</i>.\n+     * @return the index of the given instruction in this list. <i>The result of\n+     *         this method is undefined if the given instruction does not belong\n+     *         to this list</i>. Use {@link #contains contains} to test if an\n+     *         instruction belongs to an instruction list or not.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt> and\n+     *         if insn does not belong to this list.\n+     */\n+    public int indexOf(final AbstractInsnNode insn) {\n+        if (check && !contains(insn)) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (cache == null) {\n+            cache = toArray();\n+        }\n+        return insn.index;\n+    }\n+\n+    /**\n+     * Makes the given visitor visit all of the instructions in this list.\n+     * \n+     * @param mv the method visitor that must visit the instructions.\n+     */\n+    public void accept(final MethodVisitor mv) {\n+        AbstractInsnNode insn = first;\n+        while (insn != null) {\n+            insn.accept(mv);\n+            insn = insn.next;\n+        }\n+    }\n+\n+    /**\n+     * Returns an iterator over the instructions in this list.\n+     * \n+     * @return an iterator over the instructions in this list.\n+     */\n+    public ListIterator iterator() {\n+        return iterator(0);\n+    }\n+\n+    /**\n+     * Returns an iterator over the instructions in this list.\n+     * \n+     * @return an iterator over the instructions in this list.\n+     */\n+    public ListIterator iterator(int index) {\n+        return new InsnListIterator(index);\n+    }\n+    \n+    /**\n+     * Returns an array containing all of the instructions in this list.\n+     * \n+     * @return an array containing all of the instructions in this list.\n+     */\n+    public AbstractInsnNode[] toArray() {\n+        int i = 0;\n+        AbstractInsnNode elem = first;\n+        AbstractInsnNode[] insns = new AbstractInsnNode[size];\n+        while (elem != null) {\n+            insns[i] = elem;\n+            elem.index = i++;\n+            elem = elem.next;\n+        }\n+        return insns;\n+    }\n+\n+    /**\n+     * Replaces an instruction of this list with another instruction.\n+     * \n+     * @param location an instruction <i>of this list</i>.\n+     * @param insn another instruction, <i>which must not belong to any\n+     *        {@link InsnList}</i>.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if i does not belong to this list or if insn belongs to an\n+     *         instruction list.\n+     */\n+    public void set(final AbstractInsnNode location, final AbstractInsnNode insn) {\n+        if (check && !(contains(location) && insn.index == -1)) {\n+            throw new IllegalArgumentException();\n+        }\n+        AbstractInsnNode next = location.next;\n+        insn.next = next;\n+        if (next != null) {\n+            next.prev = insn;\n+        } else {\n+            last = insn;\n+        }\n+        AbstractInsnNode prev = location.prev;\n+        insn.prev = prev;\n+        if (prev != null) {\n+            prev.next = insn;\n+        } else {\n+            first = insn;\n+        }\n+        if (cache != null) {\n+            int index = location.index;\n+            cache[index] = insn;\n+            insn.index = index;\n+        } else {\n+            insn.index = 0; // insn now belongs to an InsnList\n+        }\n+        location.index = -1; // i no longer belongs to an InsnList\n+        location.prev = null;\n+        location.next = null;\n+    }\n+\n+    /**\n+     * Adds the given instruction to the end of this list.\n+     * \n+     * @param insn an instruction, <i>which must not belong to any\n+     *        {@link InsnList}</i>.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if insn belongs to an instruction list.\n+     */\n+    public void add(final AbstractInsnNode insn) {\n+        if (check && insn.index != -1) {\n+            throw new IllegalArgumentException();\n+        }\n+        ++size;\n+        if (last == null) {\n+            first = insn;\n+            last = insn;\n+        } else {\n+            last.next = insn;\n+            insn.prev = last;\n+        }\n+        last = insn;\n+        cache = null;\n+        insn.index = 0; // insn now belongs to an InsnList\n+    }\n+\n+    /**\n+     * Adds the given instructions to the end of this list.\n+     * \n+     * @param insns an instruction list, which is cleared during the process.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if insn == this.\n+     */\n+    public void add(final InsnList insns) {\n+        if (check && insns == this) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (insns.size == 0) {\n+            return;\n+        }\n+        size += insns.size;\n+        if (last == null) {\n+            first = insns.first;\n+            last = insns.last;\n+        } else {\n+            AbstractInsnNode elem = insns.first;\n+            last.next = elem;\n+            elem.prev = last;\n+            last = insns.last;\n+        }\n+        cache = null;\n+        insns.removeAll(false);\n+    }\n+\n+    /**\n+     * Inserts the given instruction at the begining of this list.\n+     * \n+     * @param insn an instruction, <i>which must not belong to any\n+     *        {@link InsnList}</i>.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if insn belongs to an instruction list.\n+     */\n+    public void insert(final AbstractInsnNode insn) {\n+        if (check && insn.index != -1) {\n+            throw new IllegalArgumentException();\n+        }\n+        ++size;\n+        if (first == null) {\n+            first = insn;\n+            last = insn;\n+        } else {\n+            first.prev = insn;\n+            insn.next = first;\n+        }\n+        first = insn;\n+        cache = null;\n+        insn.index = 0; // insn now belongs to an InsnList\n+    }\n+\n+    /**\n+     * Inserts the given instructions at the begining of this list.\n+     * \n+     * @param insns an instruction list, which is cleared during the process.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if insn == this.\n+     */\n+    public void insert(final InsnList insns) {\n+        if (check && insns == this) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (insns.size == 0) {\n+            return;\n+        }\n+        size += insns.size;\n+        if (first == null) {\n+            first = insns.first;\n+            last = insns.last;\n+        } else {\n+            AbstractInsnNode elem = insns.last;\n+            first.prev = elem;\n+            elem.next = first;\n+            first = insns.first;\n+        }\n+        cache = null;\n+        insns.removeAll(false);\n+    }\n+\n+    /**\n+     * Inserts the given instruction after the specified instruction.\n+     * \n+     * @param location an instruction <i>of this list</i> after which insn must be\n+     *        inserted.\n+     * @param insn the instruction to be inserted, <i>which must not belong to\n+     *        any {@link InsnList}</i>.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if i does not belong to this list or if insn belongs to an\n+     *         instruction list.\n+     */\n+    public void insert(final AbstractInsnNode location, final AbstractInsnNode insn) {\n+        if (check && !(contains(location) && insn.index == -1)) {\n+            throw new IllegalArgumentException();\n+        }\n+        ++size;\n+        AbstractInsnNode next = location.next;\n+        if (next == null) {\n+            last = insn;\n+        } else {\n+            next.prev = insn;\n+        }\n+        location.next = insn;\n+        insn.next = next;\n+        insn.prev = location;\n+        cache = null;\n+        insn.index = 0; // insn now belongs to an InsnList\n+    }\n+\n+    /**\n+     * Inserts the given instructions after the specified instruction.\n+     * \n+     * @param location an instruction <i>of this list</i> after which the instructions\n+     *        must be inserted.\n+     * @param insns the instruction list to be inserted, which is cleared during\n+     *        the process.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if i does not belong to this list or if insns == this.\n+     */\n+    public void insert(final AbstractInsnNode location, final InsnList insns) {\n+        if (check && !(contains(location) && insns != this)) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (insns.size == 0) {\n+            return;\n+        }\n+        size += insns.size;\n+        AbstractInsnNode ifirst = insns.first;\n+        AbstractInsnNode ilast = insns.last;\n+        AbstractInsnNode next = location.next;\n+        if (next == null) {\n+            last = ilast;\n+        } else {\n+            next.prev = ilast;\n+        }\n+        location.next = ifirst;\n+        ilast.next = next;\n+        ifirst.prev = location;\n+        cache = null;\n+        insns.removeAll(false);\n+    }\n+    \n+    /**\n+     * Inserts the given instruction before the specified instruction.\n+     * \n+     * @param location an instruction <i>of this list</i> before which insn must be\n+     *        inserted.\n+     * @param insn the instruction to be inserted, <i>which must not belong to\n+     *        any {@link InsnList}</i>.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if i does not belong to this list or if insn belongs to an\n+     *         instruction list.\n+     */\n+    public void insertBefore(final AbstractInsnNode location, final AbstractInsnNode insn) {\n+        if (check && !(contains(location) && insn.index == -1)) {\n+            throw new IllegalArgumentException();\n+        }\n+        ++size;\n+        AbstractInsnNode prev = location.prev;\n+        if (prev == null) {\n+            first = insn;\n+        } else {\n+            prev.next = insn;\n+        }\n+        location.prev = insn;\n+        insn.next = location;\n+        insn.prev = prev;\n+        cache = null;\n+        insn.index = 0; // insn now belongs to an InsnList\n+    }\n+    \n+    /**\n+     * Inserts the given instructions before the specified instruction.\n+     * \n+     * @param location  an instruction <i>of this list</i> before which the instructions\n+     *        must be inserted.\n+     * @param insns the instruction list to be inserted, which is cleared during\n+     *        the process.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if i does not belong to this list or if insns == this.\n+     */\n+    public void insertBefore(final AbstractInsnNode location, final InsnList insns) {\n+        if (check && !(contains(location ) && insns != this)) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (insns.size == 0) {\n+            return;\n+        }\n+        size += insns.size;\n+        AbstractInsnNode ifirst = insns.first;\n+        AbstractInsnNode ilast = insns.last;\n+        AbstractInsnNode prev = location .prev;\n+        if (prev == null) {\n+            first = ifirst;\n+        } else {\n+            prev.next = ifirst;\n+        }\n+        location .prev = ilast;\n+        ilast.next = location ;\n+        ifirst.prev = prev;\n+        cache = null;\n+        insns.removeAll(false);\n+    }\n+    \n+    \n+\n+    /**\n+     * Removes the given instruction from this list.\n+     * \n+     * @param insn the instruction <i>of this list</i> that must be removed.\n+     * @throws IllegalArgumentException if {@link #check} is <tt>true</tt>,\n+     *         and if insn does not belong to this list.\n+     */\n+    public void remove(final AbstractInsnNode insn) {\n+        if (check && !contains(insn)) {\n+            throw new IllegalArgumentException();\n+        }\n+        --size;\n+        AbstractInsnNode next = insn.next;\n+        AbstractInsnNode prev = insn.prev;\n+        if (next == null) {\n+            if (prev == null) {\n+                first = null;\n+                last = null;\n+            } else {\n+                prev.next = null;\n+                last = prev;\n+            }\n+        } else {\n+            if (prev == null) {\n+                first = next;\n+                next.prev = null;\n+            } else {\n+                prev.next = next;\n+                next.prev = prev;\n+            }\n+        }\n+        cache = null;\n+        insn.index = -1; // insn no longer belongs to an InsnList\n+        insn.prev = null;\n+        insn.next = null;\n+    }\n+\n+    /**\n+     * Removes all of the instructions of this list.\n+     * \n+     * @param mark if the instructions must be marked as no longer belonging to\n+     *        any {@link InsnList}.\n+     */\n+    private void removeAll(final boolean mark) {\n+        if (mark) {\n+            AbstractInsnNode insn = first;\n+            while (insn != null) {\n+                AbstractInsnNode next = insn.next;\n+                insn.index = -1; // insn no longer belongs to an InsnList\n+                insn.prev = null;\n+                insn.next = null;\n+                insn = next;\n+            }\n+        }\n+        size = 0;\n+        first = null;\n+        last = null;\n+        cache = null;\n+    }\n+\n+    /**\n+     * Removes all of the instructions of this list.\n+     */\n+    public void clear() {\n+        removeAll(check);\n+    }\n+\n+    /**\n+     * Reset all labels in the instruction list. This method should be called\n+     * before reusing same instructions list between several\n+     * <code>ClassWriter</code>s.\n+     */\n+    public void resetLabels() {\n+        AbstractInsnNode insn = first;\n+        while (insn != null) {\n+            if (insn instanceof LabelNode) {\n+                ((LabelNode) insn).resetLabel();\n+            }\n+            insn = insn.next;\n+        }\n+    }\n+    \n+    private final class InsnListIterator implements ListIterator {\n+        AbstractInsnNode next;\n+        AbstractInsnNode prev;\n+\n+        private InsnListIterator(int index) {\n+            if(index==size()) {\n+                next = null;\n+                prev = getLast();\n+            } else {\n+                next = get(index);\n+                prev = next.prev;\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return next != null;\n+        }\n+\n+        public Object next() {\n+            if (next == null) {\n+                throw new NoSuchElementException();\n+            }\n+            AbstractInsnNode result = next;\n+            prev = result;\n+            next = result.next;\n+            return result;\n+        }\n+\n+        public void remove() {\n+            InsnList.this.remove(prev);\n+            prev = prev.prev;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return prev != null;\n+        }\n+\n+        public Object previous() {\n+            AbstractInsnNode result = prev;\n+            next = result;\n+            prev = result.prev;\n+            return result;\n+        }\n+\n+        public int nextIndex() {\n+            if (next == null) {\n+                return size();\n+            }\n+            if (cache == null) {\n+                cache = toArray();\n+            }\n+            return next.index;\n+        }\n+\n+        public int previousIndex() {\n+            if (prev == null) {\n+                return -1;\n+            }\n+            if (cache == null) {\n+                cache = toArray();\n+            }\n+            return prev.index;\n+        }\n+\n+        public void add(Object o) {\n+            InsnList.this.insertBefore(next, (AbstractInsnNode) o);\n+            prev = (AbstractInsnNode) o;\n+        }\n+\n+        public void set(Object o) {\n+            InsnList.this.set(next.prev, (AbstractInsnNode) o);\n+            prev = (AbstractInsnNode) o;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/InsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a zero operand instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class InsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * Constructs a new {@link InsnNode}.\n+     * \n+     * @param opcode the opcode of the instruction to be constructed. This\n+     *        opcode must be NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1,\n+     *        ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1,\n+     *        FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD, LALOAD,\n+     *        FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IASTORE, LASTORE,\n+     *        FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE, POP, POP2,\n+     *        DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP, IADD, LADD,\n+     *        FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV,\n+     *        LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, INEG, LNEG, FNEG, DNEG,\n+     *        ISHL, LSHL, ISHR, LSHR, IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR,\n+     *        LXOR, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F,\n+     *        I2B, I2C, I2S, LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN,\n+     *        FRETURN, DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW,\n+     *        MONITORENTER, or MONITOREXIT.\n+     */\n+    public InsnNode(final int opcode) {\n+        super(opcode);\n+    }\n+\n+    public int getType() {\n+        return INSN;\n+    }\n+\n+    /**\n+     * Makes the given visitor visit this instruction.\n+     * \n+     * @param mv a method visitor.\n+     */\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitInsn(opcode);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new InsnNode(opcode);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/IntInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents an instruction with a single int operand.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class IntInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The operand of this instruction.\n+     */\n+    public int operand;\n+\n+    /**\n+     * Constructs a new {@link IntInsnNode}.\n+     * \n+     * @param opcode the opcode of the instruction to be constructed. This\n+     *        opcode must be BIPUSH, SIPUSH or NEWARRAY.\n+     * @param operand the operand of the instruction to be constructed.\n+     */\n+    public IntInsnNode(final int opcode, final int operand) {\n+        super(opcode);\n+        this.operand = operand;\n+    }\n+\n+    /**\n+     * Sets the opcode of this instruction.\n+     * \n+     * @param opcode the new instruction opcode. This opcode must be BIPUSH,\n+     *        SIPUSH or NEWARRAY.\n+     */\n+    public void setOpcode(final int opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    public int getType() {\n+        return INT_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitIntInsn(opcode, operand);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new IntInsnNode(opcode, operand);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/JumpInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a jump instruction. A jump instruction is an\n+ * instruction that may jump to another instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class JumpInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The operand of this instruction. This operand is a label that designates\n+     * the instruction to which this instruction may jump.\n+     */\n+    public LabelNode label;\n+\n+    /**\n+     * Constructs a new {@link JumpInsnNode}.\n+     * \n+     * @param opcode the opcode of the type instruction to be constructed. This\n+     *        opcode must be IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,\n+     *        IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ,\n+     *        IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.\n+     * @param label the operand of the instruction to be constructed. This\n+     *        operand is a label that designates the instruction to which the\n+     *        jump instruction may jump.\n+     */\n+    public JumpInsnNode(final int opcode, final LabelNode label) {\n+        super(opcode);\n+        this.label = label;\n+    }\n+\n+    /**\n+     * Sets the opcode of this instruction.\n+     * \n+     * @param opcode the new instruction opcode. This opcode must be IFEQ, IFNE,\n+     *        IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT,\n+     *        IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE, GOTO, JSR,\n+     *        IFNULL or IFNONNULL.\n+     */\n+    public void setOpcode(final int opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    public int getType() {\n+        return JUMP_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitJumpInsn(opcode, label.getLabel());\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new JumpInsnNode(opcode, clone(label, labels));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/LabelNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * An {@link AbstractInsnNode} that encapsulates a {@link Label}.\n+ */\n+public class LabelNode extends AbstractInsnNode {\n+\n+    private Label label;\n+\n+    public LabelNode() {\n+        super(-1);\n+    }\n+\n+    public LabelNode(final Label label) {\n+        super(-1);\n+        this.label = label;\n+    }\n+\n+    public int getType() {\n+        return LABEL;\n+    }\n+\n+    public Label getLabel() {\n+        if (label == null) {\n+            label = new Label();\n+        }\n+        return label;\n+    }\n+\n+    public void accept(final MethodVisitor cv) {\n+        cv.visitLabel(getLabel());\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return (LabelNode) labels.get(this);\n+    }\n+\n+    public void resetLabel() {\n+        label = null;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/LdcInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+/**\n+ * A node that represents an LDC instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class LdcInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The constant to be loaded on the stack. This parameter must be a non null\n+     * {@link Integer}, a {@link Float}, a {@link Long}, a {@link Double}, a\n+     * {@link String} or a {@link org.mockito.asm.Type}.\n+     */\n+    public Object cst;\n+\n+    /**\n+     * Constructs a new {@link LdcInsnNode}.\n+     * \n+     * @param cst the constant to be loaded on the stack. This parameter must be\n+     *        a non null {@link Integer}, a {@link Float}, a {@link Long}, a\n+     *        {@link Double} or a {@link String}.\n+     */\n+    public LdcInsnNode(final Object cst) {\n+        super(Opcodes.LDC);\n+        this.cst = cst;\n+    }\n+\n+    public int getType() {\n+        return LDC_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitLdcInsn(cst);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new LdcInsnNode(cst);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/LineNumberNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a line number declaration. These nodes are pseudo\n+ * instruction nodes in order to be inserted in an instruction list.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class LineNumberNode extends AbstractInsnNode {\n+\n+    /**\n+     * A line number. This number refers to the source file from which the class\n+     * was compiled.\n+     */\n+    public int line;\n+\n+    /**\n+     * The first instruction corresponding to this line number.\n+     */\n+    public LabelNode start;\n+\n+    /**\n+     * Constructs a new {@link LineNumberNode}.\n+     * \n+     * @param line a line number. This number refers to the source file from\n+     *        which the class was compiled.\n+     * @param start the first instruction corresponding to this line number.\n+     */\n+    public LineNumberNode(final int line, final LabelNode start) {\n+        super(-1);\n+        this.line = line;\n+        this.start = start;\n+    }\n+\n+    public int getType() {\n+        return LINE;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitLineNumber(line, start.getLabel());\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new LineNumberNode(line, clone(start, labels));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/LocalVariableNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a local variable declaration.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class LocalVariableNode {\n+\n+    /**\n+     * The name of a local variable.\n+     */\n+    public String name;\n+\n+    /**\n+     * The type descriptor of this local variable.\n+     */\n+    public String desc;\n+\n+    /**\n+     * The signature of this local variable. May be <tt>null</tt>.\n+     */\n+    public String signature;\n+\n+    /**\n+     * The first instruction corresponding to the scope of this local variable\n+     * (inclusive).\n+     */\n+    public LabelNode start;\n+\n+    /**\n+     * The last instruction corresponding to the scope of this local variable\n+     * (exclusive).\n+     */\n+    public LabelNode end;\n+\n+    /**\n+     * The local variable's index.\n+     */\n+    public int index;\n+\n+    /**\n+     * Constructs a new {@link LocalVariableNode}.\n+     * \n+     * @param name the name of a local variable.\n+     * @param desc the type descriptor of this local variable.\n+     * @param signature the signature of this local variable. May be\n+     *        <tt>null</tt>.\n+     * @param start the first instruction corresponding to the scope of this\n+     *        local variable (inclusive).\n+     * @param end the last instruction corresponding to the scope of this local\n+     *        variable (exclusive).\n+     * @param index the local variable's index.\n+     */\n+    public LocalVariableNode(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final LabelNode start,\n+        final LabelNode end,\n+        final int index)\n+    {\n+        this.name = name;\n+        this.desc = desc;\n+        this.signature = signature;\n+        this.start = start;\n+        this.end = end;\n+        this.index = index;\n+    }\n+\n+    /**\n+     * Makes the given visitor visit this local variable declaration.\n+     * \n+     * @param mv a method visitor.\n+     */\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitLocalVariable(name,\n+                desc,\n+                signature,\n+                start.getLabel(),\n+                end.getLabel(),\n+                index);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/LookupSwitchInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+/**\n+ * A node that represents a LOOKUPSWITCH instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class LookupSwitchInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * Beginning of the default handler block.\n+     */\n+    public LabelNode dflt;\n+\n+    /**\n+     * The values of the keys. This list is a list of {@link Integer} objects.\n+     */\n+    public List keys;\n+\n+    /**\n+     * Beginnings of the handler blocks. This list is a list of\n+     * {@link LabelNode} objects.\n+     */\n+    public List labels;\n+\n+    /**\n+     * Constructs a new {@link LookupSwitchInsnNode}.\n+     * \n+     * @param dflt beginning of the default handler block.\n+     * @param keys the values of the keys.\n+     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is\n+     *        the beginning of the handler block for the <tt>keys[i]</tt> key.\n+     */\n+    public LookupSwitchInsnNode(\n+        final LabelNode dflt,\n+        final int[] keys,\n+        final LabelNode[] labels)\n+    {\n+        super(Opcodes.LOOKUPSWITCH);\n+        this.dflt = dflt;\n+        this.keys = new ArrayList(keys == null ? 0 : keys.length);\n+        this.labels = new ArrayList(labels == null ? 0 : labels.length);\n+        if (keys != null) {\n+            for (int i = 0; i < keys.length; ++i) {\n+                this.keys.add(new Integer(keys[i]));\n+            }\n+        }\n+        if (labels != null) {\n+            this.labels.addAll(Arrays.asList(labels));\n+        }\n+    }\n+\n+    public int getType() {\n+        return LOOKUPSWITCH_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        int[] keys = new int[this.keys.size()];\n+        for (int i = 0; i < keys.length; ++i) {\n+            keys[i] = ((Integer) this.keys.get(i)).intValue();\n+        }\n+        Label[] labels = new Label[this.labels.size()];\n+        for (int i = 0; i < labels.length; ++i) {\n+            labels[i] = ((LabelNode) this.labels.get(i)).getLabel();\n+        }\n+        mv.visitLookupSwitchInsn(dflt.getLabel(), keys, labels);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        LookupSwitchInsnNode clone = new LookupSwitchInsnNode(clone(dflt,\n+                labels), null, clone(this.labels, labels));\n+        clone.keys.addAll(keys);\n+        return clone;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/MemberNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+\n+/**\n+ * An abstract class, field or method node.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public abstract class MemberNode {\n+\n+    /**\n+     * The runtime visible annotations of this class, field or method. This list\n+     * is a list of {@link AnnotationNode} objects. May be <tt>null</tt>.\n+     * \n+     * @associates org.mockito.asm.tree.AnnotationNode\n+     * @label visible\n+     */\n+    public List visibleAnnotations;\n+\n+    /**\n+     * The runtime invisible annotations of this class, field or method. This\n+     * list is a list of {@link AnnotationNode} objects. May be <tt>null</tt>.\n+     * \n+     * @associates org.mockito.asm.tree.AnnotationNode\n+     * @label invisible\n+     */\n+    public List invisibleAnnotations;\n+\n+    /**\n+     * The non standard attributes of this class, field or method. This list is\n+     * a list of {@link Attribute} objects. May be <tt>null</tt>.\n+     * \n+     * @associates org.mockito.asm.Attribute\n+     */\n+    public List attrs;\n+\n+    /**\n+     * Constructs a new {@link MemberNode}.\n+     */\n+    protected MemberNode() {\n+    }\n+\n+    /**\n+     * Visits an annotation of this class, field or method.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values.\n+     */\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        AnnotationNode an = new AnnotationNode(desc);\n+        if (visible) {\n+            if (visibleAnnotations == null) {\n+                visibleAnnotations = new ArrayList(1);\n+            }\n+            visibleAnnotations.add(an);\n+        } else {\n+            if (invisibleAnnotations == null) {\n+                invisibleAnnotations = new ArrayList(1);\n+            }\n+            invisibleAnnotations.add(an);\n+        }\n+        return an;\n+    }\n+\n+    /**\n+     * Visits a non standard attribute of this class, field or method.\n+     * \n+     * @param attr an attribute.\n+     */\n+    public void visitAttribute(final Attribute attr) {\n+        if (attrs == null) {\n+            attrs = new ArrayList(1);\n+        }\n+        attrs.add(attr);\n+    }\n+\n+    /**\n+     * Visits the end of this class, field or method.\n+     */\n+    public void visitEnd() {\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/MethodInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a method instruction. A method instruction is an\n+ * instruction that invokes a method.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class MethodInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The internal name of the method's owner class (see\n+     * {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     */\n+    public String owner;\n+\n+    /**\n+     * The method's name.\n+     */\n+    public String name;\n+\n+    /**\n+     * The method's descriptor (see {@link org.mockito.asm.Type}).\n+     */\n+    public String desc;\n+\n+    /**\n+     * Constructs a new {@link MethodInsnNode}.\n+     * \n+     * @param opcode the opcode of the type instruction to be constructed. This\n+     *        opcode must be INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or\n+     *        INVOKEINTERFACE.\n+     * @param owner the internal name of the method's owner class (see\n+     *        {@link org.mockito.asm.Type#getInternalName() getInternalName}).\n+     * @param name the method's name.\n+     * @param desc the method's descriptor (see {@link org.mockito.asm.Type}).\n+     */\n+    public MethodInsnNode(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        super(opcode);\n+        this.owner = owner;\n+        this.name = name;\n+        this.desc = desc;\n+    }\n+\n+    /**\n+     * Sets the opcode of this instruction.\n+     * \n+     * @param opcode the new instruction opcode. This opcode must be\n+     *        INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.\n+     */\n+    public void setOpcode(final int opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    public int getType() {\n+        return METHOD_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitMethodInsn(opcode, owner, name, desc);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new MethodInsnNode(opcode, owner, name, desc);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/MethodNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+/**\n+ * A node that represents a method.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class MethodNode extends MemberNode implements MethodVisitor {\n+\n+    /**\n+     * The method's access flags (see {@link Opcodes}). This field also\n+     * indicates if the method is synthetic and/or deprecated.\n+     */\n+    public int access;\n+\n+    /**\n+     * The method's name.\n+     */\n+    public String name;\n+\n+    /**\n+     * The method's descriptor (see {@link Type}).\n+     */\n+    public String desc;\n+\n+    /**\n+     * The method's signature. May be <tt>null</tt>.\n+     */\n+    public String signature;\n+\n+    /**\n+     * The internal names of the method's exception classes (see\n+     * {@link Type#getInternalName() getInternalName}). This list is a list of\n+     * {@link String} objects.\n+     */\n+    public List exceptions;\n+\n+    /**\n+     * The default value of this annotation interface method. This field must be\n+     * a {@link Byte}, {@link Boolean}, {@link Character}, {@link Short},\n+     * {@link Integer}, {@link Long}, {@link Float}, {@link Double},\n+     * {@link String} or {@link Type}, or an two elements String array (for\n+     * enumeration values), a {@link AnnotationNode}, or a {@link List} of\n+     * values of one of the preceding types. May be <tt>null</tt>.\n+     */\n+    public Object annotationDefault;\n+\n+    /**\n+     * The runtime visible parameter annotations of this method. These lists are\n+     * lists of {@link AnnotationNode} objects. May be <tt>null</tt>.\n+     * \n+     * @associates org.mockito.asm.tree.AnnotationNode\n+     * @label invisible parameters\n+     */\n+    public List[] visibleParameterAnnotations;\n+\n+    /**\n+     * The runtime invisible parameter annotations of this method. These lists\n+     * are lists of {@link AnnotationNode} objects. May be <tt>null</tt>.\n+     * \n+     * @associates org.mockito.asm.tree.AnnotationNode\n+     * @label visible parameters\n+     */\n+    public List[] invisibleParameterAnnotations;\n+\n+    /**\n+     * The instructions of this method. This list is a list of\n+     * {@link AbstractInsnNode} objects.\n+     * \n+     * @associates org.mockito.asm.tree.AbstractInsnNode\n+     * @label instructions\n+     */\n+    public InsnList instructions;\n+\n+    /**\n+     * The try catch blocks of this method. This list is a list of\n+     * {@link TryCatchBlockNode} objects.\n+     * \n+     * @associates org.mockito.asm.tree.TryCatchBlockNode\n+     */\n+    public List tryCatchBlocks;\n+\n+    /**\n+     * The maximum stack size of this method.\n+     */\n+    public int maxStack;\n+\n+    /**\n+     * The maximum number of local variables of this method.\n+     */\n+    public int maxLocals;\n+\n+    /**\n+     * The local variables of this method. This list is a list of\n+     * {@link LocalVariableNode} objects. May be <tt>null</tt>\n+     * \n+     * @associates org.mockito.asm.tree.LocalVariableNode\n+     */\n+    public List localVariables;\n+\n+    /**\n+     * Constructs an unitialized {@link MethodNode}.\n+     */\n+    public MethodNode() {\n+        this.instructions = new InsnList();\n+    }\n+    \n+    /**\n+     * Constructs a new {@link MethodNode}.\n+     * \n+     * @param access the method's access flags (see {@link Opcodes}). This\n+     *        parameter also indicates if the method is synthetic and/or\n+     *        deprecated.\n+     * @param name the method's name.\n+     * @param desc the method's descriptor (see {@link Type}).\n+     * @param signature the method's signature. May be <tt>null</tt>.\n+     * @param exceptions the internal names of the method's exception classes\n+     *        (see {@link Type#getInternalName() getInternalName}). May be\n+     *        <tt>null</tt>.\n+     */\n+    public MethodNode(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        this();\n+        this.access = access;\n+        this.name = name;\n+        this.desc = desc;\n+        this.signature = signature;\n+        this.exceptions = new ArrayList(exceptions == null\n+                ? 0\n+                : exceptions.length);\n+        boolean isAbstract = (access & Opcodes.ACC_ABSTRACT) != 0;\n+        if (!isAbstract) {\n+            this.localVariables = new ArrayList(5);\n+        }\n+        this.tryCatchBlocks = new ArrayList();\n+        if (exceptions != null) {\n+            this.exceptions.addAll(Arrays.asList(exceptions));\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the MethodVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        return new AnnotationNode(new ArrayList(0) {\n+            public boolean add(final Object o) {\n+                annotationDefault = o;\n+                return super.add(o);\n+            }\n+        });\n+    }\n+\n+    public AnnotationVisitor visitParameterAnnotation(\n+        final int parameter,\n+        final String desc,\n+        final boolean visible)\n+    {\n+        AnnotationNode an = new AnnotationNode(desc);\n+        if (visible) {\n+            if (visibleParameterAnnotations == null) {\n+                int params = Type.getArgumentTypes(this.desc).length;\n+                visibleParameterAnnotations = new List[params];\n+            }\n+            if (visibleParameterAnnotations[parameter] == null) {\n+                visibleParameterAnnotations[parameter] = new ArrayList(1);\n+            }\n+            visibleParameterAnnotations[parameter].add(an);\n+        } else {\n+            if (invisibleParameterAnnotations == null) {\n+                int params = Type.getArgumentTypes(this.desc).length;\n+                invisibleParameterAnnotations = new List[params];\n+            }\n+            if (invisibleParameterAnnotations[parameter] == null) {\n+                invisibleParameterAnnotations[parameter] = new ArrayList(1);\n+            }\n+            invisibleParameterAnnotations[parameter].add(an);\n+        }\n+        return an;\n+    }\n+\n+    public void visitCode() {\n+    }\n+\n+    public void visitFrame(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        instructions.add(new FrameNode(type, nLocal, local == null\n+                ? null\n+                : getLabelNodes(local), nStack, stack == null\n+                ? null\n+                : getLabelNodes(stack)));\n+    }\n+\n+    public void visitInsn(final int opcode) {\n+        instructions.add(new InsnNode(opcode));\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        instructions.add(new IntInsnNode(opcode, operand));\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        instructions.add(new VarInsnNode(opcode, var));\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        instructions.add(new TypeInsnNode(opcode, type));\n+    }\n+\n+    public void visitFieldInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        instructions.add(new FieldInsnNode(opcode, owner, name, desc));\n+    }\n+\n+    public void visitMethodInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        instructions.add(new MethodInsnNode(opcode, owner, name, desc));\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        instructions.add(new JumpInsnNode(opcode, getLabelNode(label)));\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        instructions.add(getLabelNode(label));\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        instructions.add(new LdcInsnNode(cst));\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        instructions.add(new IincInsnNode(var, increment));\n+    }\n+\n+    public void visitTableSwitchInsn(\n+        final int min,\n+        final int max,\n+        final Label dflt,\n+        final Label[] labels)\n+    {\n+        instructions.add(new TableSwitchInsnNode(min,\n+                max,\n+                getLabelNode(dflt),\n+                getLabelNodes(labels)));\n+    }\n+\n+    public void visitLookupSwitchInsn(\n+        final Label dflt,\n+        final int[] keys,\n+        final Label[] labels)\n+    {\n+        instructions.add(new LookupSwitchInsnNode(getLabelNode(dflt),\n+                keys,\n+                getLabelNodes(labels)));\n+    }\n+\n+    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n+        instructions.add(new MultiANewArrayInsnNode(desc, dims));\n+    }\n+\n+    public void visitTryCatchBlock(\n+        final Label start,\n+        final Label end,\n+        final Label handler,\n+        final String type)\n+    {\n+        tryCatchBlocks.add(new TryCatchBlockNode(getLabelNode(start),\n+                getLabelNode(end),\n+                getLabelNode(handler),\n+                type));\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        localVariables.add(new LocalVariableNode(name,\n+                desc,\n+                signature,\n+                getLabelNode(start),\n+                getLabelNode(end),\n+                index));\n+    }\n+\n+    public void visitLineNumber(final int line, final Label start) {\n+        instructions.add(new LineNumberNode(line, getLabelNode(start)));\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        this.maxStack = maxStack;\n+        this.maxLocals = maxLocals;\n+    }\n+\n+    /**\n+     * Returns the LabelNode corresponding to the given Label. Creates a new \n+     * LabelNode if necessary. The default implementation of this method uses\n+     * the {@link Label#info} field to store associations between labels and\n+     * label nodes.\n+     * \n+     * @param l a Label.\n+     * @return the LabelNode corresponding to l.\n+     */    \n+    protected LabelNode getLabelNode(final Label l) {\n+        if (!(l.info instanceof LabelNode)) {\n+            l.info = new LabelNode(l);\n+        }\n+        return (LabelNode) l.info;\n+    }\n+\n+    private LabelNode[] getLabelNodes(final Label[] l) {\n+        LabelNode[] nodes = new LabelNode[l.length];\n+        for (int i = 0; i < l.length; ++i) {\n+            nodes[i] = getLabelNode(l[i]);\n+        }\n+        return nodes;\n+    }\n+\n+    private Object[] getLabelNodes(final Object[] objs) {\n+        Object[] nodes = new Object[objs.length];\n+        for (int i = 0; i < objs.length; ++i) {\n+            Object o = objs[i];\n+            if (o instanceof Label) {\n+                o = getLabelNode((Label) o);\n+            }\n+            nodes[i] = o;\n+        }\n+        return nodes;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Accept method\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Makes the given class visitor visit this method.\n+     * \n+     * @param cv a class visitor.\n+     */\n+    public void accept(final ClassVisitor cv) {\n+        String[] exceptions = new String[this.exceptions.size()];\n+        this.exceptions.toArray(exceptions);\n+        MethodVisitor mv = cv.visitMethod(access,\n+                name,\n+                desc,\n+                signature,\n+                exceptions);\n+        if (mv != null) {\n+            accept(mv);\n+        }\n+    }\n+\n+    /**\n+     * Makes the given method visitor visit this method.\n+     * \n+     * @param mv a method visitor.\n+     */\n+    public void accept(final MethodVisitor mv) {\n+        // visits the method attributes\n+        int i, j, n;\n+        if (annotationDefault != null) {\n+            AnnotationVisitor av = mv.visitAnnotationDefault();\n+            AnnotationNode.accept(av, null, annotationDefault);\n+            if (av != null) {\n+                av.visitEnd();\n+            }\n+        }\n+        n = visibleAnnotations == null ? 0 : visibleAnnotations.size();\n+        for (i = 0; i < n; ++i) {\n+            AnnotationNode an = (AnnotationNode) visibleAnnotations.get(i);\n+            an.accept(mv.visitAnnotation(an.desc, true));\n+        }\n+        n = invisibleAnnotations == null ? 0 : invisibleAnnotations.size();\n+        for (i = 0; i < n; ++i) {\n+            AnnotationNode an = (AnnotationNode) invisibleAnnotations.get(i);\n+            an.accept(mv.visitAnnotation(an.desc, false));\n+        }\n+        n = visibleParameterAnnotations == null\n+                ? 0\n+                : visibleParameterAnnotations.length;\n+        for (i = 0; i < n; ++i) {\n+            List l = visibleParameterAnnotations[i];\n+            if (l == null) {\n+                continue;\n+            }\n+            for (j = 0; j < l.size(); ++j) {\n+                AnnotationNode an = (AnnotationNode) l.get(j);\n+                an.accept(mv.visitParameterAnnotation(i, an.desc, true));\n+            }\n+        }\n+        n = invisibleParameterAnnotations == null\n+                ? 0\n+                : invisibleParameterAnnotations.length;\n+        for (i = 0; i < n; ++i) {\n+            List l = invisibleParameterAnnotations[i];\n+            if (l == null) {\n+                continue;\n+            }\n+            for (j = 0; j < l.size(); ++j) {\n+                AnnotationNode an = (AnnotationNode) l.get(j);\n+                an.accept(mv.visitParameterAnnotation(i, an.desc, false));\n+            }\n+        }\n+        n = attrs == null ? 0 : attrs.size();\n+        for (i = 0; i < n; ++i) {\n+            mv.visitAttribute((Attribute) attrs.get(i));\n+        }\n+        // visits the method's code\n+        if (instructions.size() > 0) {\n+            mv.visitCode();\n+            // visits try catch blocks\n+            for (i = 0; i < tryCatchBlocks.size(); ++i) {\n+                ((TryCatchBlockNode) tryCatchBlocks.get(i)).accept(mv);\n+            }\n+            // visits instructions\n+            instructions.accept(mv);\n+            // visits local variables\n+            n = localVariables == null ? 0 : localVariables.size();\n+            for (i = 0; i < n; ++i) {\n+                ((LocalVariableNode) localVariables.get(i)).accept(mv);\n+            }\n+            // visits maxs\n+            mv.visitMaxs(maxStack, maxLocals);\n+        }\n+        mv.visitEnd();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/MultiANewArrayInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+/**\n+ * A node that represents a MULTIANEWARRAY instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class MultiANewArrayInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * An array type descriptor (see {@link org.mockito.asm.Type}).\n+     */\n+    public String desc;\n+\n+    /**\n+     * Number of dimensions of the array to allocate.\n+     */\n+    public int dims;\n+\n+    /**\n+     * Constructs a new {@link MultiANewArrayInsnNode}.\n+     * \n+     * @param desc an array type descriptor (see {@link org.mockito.asm.Type}).\n+     * @param dims number of dimensions of the array to allocate.\n+     */\n+    public MultiANewArrayInsnNode(final String desc, final int dims) {\n+        super(Opcodes.MULTIANEWARRAY);\n+        this.desc = desc;\n+        this.dims = dims;\n+    }\n+\n+    public int getType() {\n+        return MULTIANEWARRAY_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitMultiANewArrayInsn(desc, dims);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new MultiANewArrayInsnNode(desc, dims);\n+    }\n+\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/TableSwitchInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A node that represents a TABLESWITCH instruction.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class TableSwitchInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The minimum key value.\n+     */\n+    public int min;\n+\n+    /**\n+     * The maximum key value.\n+     */\n+    public int max;\n+\n+    /**\n+     * Beginning of the default handler block.\n+     */\n+    public LabelNode dflt;\n+\n+    /**\n+     * Beginnings of the handler blocks. This list is a list of\n+     * {@link LabelNode} objects.\n+     */\n+    public List labels;\n+\n+    /**\n+     * Constructs a new {@link TableSwitchInsnNode}.\n+     * \n+     * @param min the minimum key value.\n+     * @param max the maximum key value.\n+     * @param dflt beginning of the default handler block.\n+     * @param labels beginnings of the handler blocks. <tt>labels[i]</tt> is\n+     *        the beginning of the handler block for the <tt>min + i</tt> key.\n+     */\n+    public TableSwitchInsnNode(\n+        final int min,\n+        final int max,\n+        final LabelNode dflt,\n+        final LabelNode[] labels)\n+    {\n+        super(Opcodes.TABLESWITCH);\n+        this.min = min;\n+        this.max = max;\n+        this.dflt = dflt;\n+        this.labels = new ArrayList();\n+        if (labels != null) {\n+            this.labels.addAll(Arrays.asList(labels));\n+        }\n+    }\n+\n+    public int getType() {\n+        return TABLESWITCH_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        Label[] labels = new Label[this.labels.size()];\n+        for (int i = 0; i < labels.length; ++i) {\n+            labels[i] = ((LabelNode) this.labels.get(i)).getLabel();\n+        }\n+        mv.visitTableSwitchInsn(min, max, dflt.getLabel(), labels);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new TableSwitchInsnNode(min,\n+                max,\n+                clone(dflt, labels),\n+                clone(this.labels, labels));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/TryCatchBlockNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a try catch block.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class TryCatchBlockNode {\n+\n+    /**\n+     * Beginning of the exception handler's scope (inclusive).\n+     */\n+    public LabelNode start;\n+\n+    /**\n+     * End of the exception handler's scope (exclusive).\n+     */\n+    public LabelNode end;\n+\n+    /**\n+     * Beginning of the exception handler's code.\n+     */\n+    public LabelNode handler;\n+\n+    /**\n+     * Internal name of the type of exceptions handled by the handler. May be\n+     * <tt>null</tt> to catch any exceptions (for \"finally\" blocks).\n+     */\n+    public String type;\n+\n+    /**\n+     * Constructs a new {@link TryCatchBlockNode}.\n+     * \n+     * @param start beginning of the exception handler's scope (inclusive).\n+     * @param end end of the exception handler's scope (exclusive).\n+     * @param handler beginning of the exception handler's code.\n+     * @param type internal name of the type of exceptions handled by the\n+     *        handler, or <tt>null</tt> to catch any exceptions (for \"finally\"\n+     *        blocks).\n+     */\n+    public TryCatchBlockNode(\n+        final LabelNode start,\n+        final LabelNode end,\n+        final LabelNode handler,\n+        final String type)\n+    {\n+        this.start = start;\n+        this.end = end;\n+        this.handler = handler;\n+        this.type = type;\n+    }\n+\n+    /**\n+     * Makes the given visitor visit this try catch block.\n+     * \n+     * @param mv a method visitor.\n+     */\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitTryCatchBlock(start.getLabel(), end.getLabel(), handler == null\n+                ? null\n+                : handler.getLabel(), type);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/TypeInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a type instruction. A type instruction is an\n+ * instruction that takes a type descriptor as parameter.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class TypeInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The operand of this instruction. This operand is an internal name (see\n+     * {@link org.mockito.asm.Type}).\n+     */\n+    public String desc;\n+\n+    /**\n+     * Constructs a new {@link TypeInsnNode}.\n+     * \n+     * @param opcode the opcode of the type instruction to be constructed. This\n+     *        opcode must be NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.\n+     * @param desc the operand of the instruction to be constructed. This\n+     *        operand is an internal name (see {@link org.mockito.asm.Type}).\n+     */\n+    public TypeInsnNode(final int opcode, final String desc) {\n+        super(opcode);\n+        this.desc = desc;\n+    }\n+\n+    /**\n+     * Sets the opcode of this instruction.\n+     * \n+     * @param opcode the new instruction opcode. This opcode must be NEW,\n+     *        ANEWARRAY, CHECKCAST or INSTANCEOF.\n+     */\n+    public void setOpcode(final int opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    public int getType() {\n+        return TYPE_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitTypeInsn(opcode, desc);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new TypeInsnNode(opcode, desc);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/VarInsnNode.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree;\n+\n+import java.util.Map;\n+\n+import org.mockito.asm.MethodVisitor;\n+\n+/**\n+ * A node that represents a local variable instruction. A local variable\n+ * instruction is an instruction that loads or stores the value of a local\n+ * variable.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class VarInsnNode extends AbstractInsnNode {\n+\n+    /**\n+     * The operand of this instruction. This operand is the index of a local\n+     * variable.\n+     */\n+    public int var;\n+\n+    /**\n+     * Constructs a new {@link VarInsnNode}.\n+     * \n+     * @param opcode the opcode of the local variable instruction to be\n+     *        constructed. This opcode must be ILOAD, LLOAD, FLOAD, DLOAD,\n+     *        ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.\n+     * @param var the operand of the instruction to be constructed. This operand\n+     *        is the index of a local variable.\n+     */\n+    public VarInsnNode(final int opcode, final int var) {\n+        super(opcode);\n+        this.var = var;\n+    }\n+\n+    /**\n+     * Sets the opcode of this instruction.\n+     * \n+     * @param opcode the new instruction opcode. This opcode must be ILOAD,\n+     *        LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE, ASTORE\n+     *        or RET.\n+     */\n+    public void setOpcode(final int opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    public int getType() {\n+        return VAR_INSN;\n+    }\n+\n+    public void accept(final MethodVisitor mv) {\n+        mv.visitVarInsn(opcode, var);\n+    }\n+\n+    public AbstractInsnNode clone(final Map labels) {\n+        return new VarInsnNode(opcode, var);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/Analyzer.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.AbstractInsnNode;\n+import org.mockito.asm.tree.IincInsnNode;\n+import org.mockito.asm.tree.InsnList;\n+import org.mockito.asm.tree.JumpInsnNode;\n+import org.mockito.asm.tree.LabelNode;\n+import org.mockito.asm.tree.LookupSwitchInsnNode;\n+import org.mockito.asm.tree.MethodNode;\n+import org.mockito.asm.tree.TableSwitchInsnNode;\n+import org.mockito.asm.tree.TryCatchBlockNode;\n+import org.mockito.asm.tree.VarInsnNode;\n+\n+/**\n+ * A semantic bytecode analyzer. <i>This class does not fully check that JSR and\n+ * RET instructions are valid.</i>\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class Analyzer implements Opcodes {\n+\n+    private final Interpreter interpreter;\n+\n+    private int n;\n+\n+    private InsnList insns;\n+\n+    private List[] handlers;\n+\n+    private Frame[] frames;\n+\n+    private Subroutine[] subroutines;\n+\n+    private boolean[] queued;\n+\n+    private int[] queue;\n+\n+    private int top;\n+\n+    /**\n+     * Constructs a new {@link Analyzer}.\n+     * \n+     * @param interpreter the interpreter to be used to symbolically interpret\n+     *        the bytecode instructions.\n+     */\n+    public Analyzer(final Interpreter interpreter) {\n+        this.interpreter = interpreter;\n+    }\n+\n+    /**\n+     * Analyzes the given method.\n+     * \n+     * @param owner the internal name of the class to which the method belongs.\n+     * @param m the method to be analyzed.\n+     * @return the symbolic state of the execution stack frame at each bytecode\n+     *         instruction of the method. The size of the returned array is\n+     *         equal to the number of instructions (and labels) of the method. A\n+     *         given frame is <tt>null</tt> if and only if the corresponding\n+     *         instruction cannot be reached (dead code).\n+     * @throws AnalyzerException if a problem occurs during the analysis.\n+     */\n+    public Frame[] analyze(final String owner, final MethodNode m)\n+            throws AnalyzerException\n+    {\n+        if ((m.access & (ACC_ABSTRACT | ACC_NATIVE)) != 0) {\n+            frames = new Frame[0];\n+            return frames;\n+        }\n+        n = m.instructions.size();\n+        insns = m.instructions;\n+        handlers = new List[n];\n+        frames = new Frame[n];\n+        subroutines = new Subroutine[n];\n+        queued = new boolean[n];\n+        queue = new int[n];\n+        top = 0;\n+\n+        // computes exception handlers for each instruction\n+        for (int i = 0; i < m.tryCatchBlocks.size(); ++i) {\n+            TryCatchBlockNode tcb = (TryCatchBlockNode) m.tryCatchBlocks.get(i);\n+            int begin = insns.indexOf(tcb.start);\n+            int end = insns.indexOf(tcb.end);\n+            for (int j = begin; j < end; ++j) {\n+                List insnHandlers = handlers[j];\n+                if (insnHandlers == null) {\n+                    insnHandlers = new ArrayList();\n+                    handlers[j] = insnHandlers;\n+                }\n+                insnHandlers.add(tcb);\n+            }\n+        }\n+\n+        // computes the subroutine for each instruction:\n+        Subroutine main = new Subroutine(null, m.maxLocals, null);\n+        List subroutineCalls = new ArrayList();\n+        Map subroutineHeads = new HashMap();\n+        findSubroutine(0, main, subroutineCalls);\n+        while (!subroutineCalls.isEmpty()) {\n+            JumpInsnNode jsr = (JumpInsnNode) subroutineCalls.remove(0);\n+            Subroutine sub = (Subroutine) subroutineHeads.get(jsr.label);\n+            if (sub == null) {\n+                sub = new Subroutine(jsr.label, m.maxLocals, jsr);\n+                subroutineHeads.put(jsr.label, sub);\n+                findSubroutine(insns.indexOf(jsr.label), sub, subroutineCalls);\n+            } else {\n+                sub.callers.add(jsr);\n+            }\n+        }\n+        for (int i = 0; i < n; ++i) {\n+            if (subroutines[i] != null && subroutines[i].start == null) {\n+                subroutines[i] = null;\n+            }\n+        }\n+\n+        // initializes the data structures for the control flow analysis\n+        Frame current = newFrame(m.maxLocals, m.maxStack);\n+        Frame handler = newFrame(m.maxLocals, m.maxStack);\n+        Type[] args = Type.getArgumentTypes(m.desc);\n+        int local = 0;\n+        if ((m.access & ACC_STATIC) == 0) {\n+            Type ctype = Type.getObjectType(owner);\n+            current.setLocal(local++, interpreter.newValue(ctype));\n+        }\n+        for (int i = 0; i < args.length; ++i) {\n+            current.setLocal(local++, interpreter.newValue(args[i]));\n+            if (args[i].getSize() == 2) {\n+                current.setLocal(local++, interpreter.newValue(null));\n+            }\n+        }\n+        while (local < m.maxLocals) {\n+            current.setLocal(local++, interpreter.newValue(null));\n+        }\n+        merge(0, current, null);\n+\n+        // control flow analysis\n+        while (top > 0) {\n+            int insn = queue[--top];\n+            Frame f = frames[insn];\n+            Subroutine subroutine = subroutines[insn];\n+            queued[insn] = false;\n+\n+            try {\n+                AbstractInsnNode insnNode = m.instructions.get(insn);\n+                int insnOpcode = insnNode.getOpcode();\n+                int insnType = insnNode.getType();\n+\n+                if (insnType == AbstractInsnNode.LABEL\n+                        || insnType == AbstractInsnNode.LINE\n+                        || insnType == AbstractInsnNode.FRAME)\n+                {\n+                    merge(insn + 1, f, subroutine);\n+                    newControlFlowEdge(insn, insn + 1);\n+                } else {\n+                    current.init(f).execute(insnNode, interpreter);\n+                    subroutine = subroutine == null ? null : subroutine.copy();\n+\n+                    if (insnNode instanceof JumpInsnNode) {\n+                        JumpInsnNode j = (JumpInsnNode) insnNode;\n+                        if (insnOpcode != GOTO && insnOpcode != JSR) {\n+                            merge(insn + 1, current, subroutine);\n+                            newControlFlowEdge(insn, insn + 1);\n+                        }\n+                        int jump = insns.indexOf(j.label);\n+                        if (insnOpcode == JSR) {\n+                            merge(jump, current, new Subroutine(j.label,\n+                                    m.maxLocals,\n+                                    j));\n+                        } else {\n+                            merge(jump, current, subroutine);\n+                        }\n+                        newControlFlowEdge(insn, jump);\n+                    } else if (insnNode instanceof LookupSwitchInsnNode) {\n+                        LookupSwitchInsnNode lsi = (LookupSwitchInsnNode) insnNode;\n+                        int jump = insns.indexOf(lsi.dflt);\n+                        merge(jump, current, subroutine);\n+                        newControlFlowEdge(insn, jump);\n+                        for (int j = 0; j < lsi.labels.size(); ++j) {\n+                            LabelNode label = (LabelNode) lsi.labels.get(j);\n+                            jump = insns.indexOf(label);\n+                            merge(jump, current, subroutine);\n+                            newControlFlowEdge(insn, jump);\n+                        }\n+                    } else if (insnNode instanceof TableSwitchInsnNode) {\n+                        TableSwitchInsnNode tsi = (TableSwitchInsnNode) insnNode;\n+                        int jump = insns.indexOf(tsi.dflt);\n+                        merge(jump, current, subroutine);\n+                        newControlFlowEdge(insn, jump);\n+                        for (int j = 0; j < tsi.labels.size(); ++j) {\n+                            LabelNode label = (LabelNode) tsi.labels.get(j);\n+                            jump = insns.indexOf(label);\n+                            merge(jump, current, subroutine);\n+                            newControlFlowEdge(insn, jump);\n+                        }\n+                    } else if (insnOpcode == RET) {\n+                        if (subroutine == null) {\n+                            throw new AnalyzerException(\"RET instruction outside of a sub routine\");\n+                        }\n+                        for (int i = 0; i < subroutine.callers.size(); ++i) {\n+                            Object caller = subroutine.callers.get(i);\n+                            int call = insns.indexOf((AbstractInsnNode) caller);\n+                            if (frames[call] != null) {\n+                                merge(call + 1,\n+                                        frames[call],\n+                                        current,\n+                                        subroutines[call],\n+                                        subroutine.access);\n+                                newControlFlowEdge(insn, call + 1);\n+                            }\n+                        }\n+                    } else if (insnOpcode != ATHROW\n+                            && (insnOpcode < IRETURN || insnOpcode > RETURN))\n+                    {\n+                        if (subroutine != null) {\n+                            if (insnNode instanceof VarInsnNode) {\n+                                int var = ((VarInsnNode) insnNode).var;\n+                                subroutine.access[var] = true;\n+                                if (insnOpcode == LLOAD || insnOpcode == DLOAD\n+                                        || insnOpcode == LSTORE\n+                                        || insnOpcode == DSTORE)\n+                                {\n+                                    subroutine.access[var + 1] = true;\n+                                }\n+                            } else if (insnNode instanceof IincInsnNode) {\n+                                int var = ((IincInsnNode) insnNode).var;\n+                                subroutine.access[var] = true;\n+                            }\n+                        }\n+                        merge(insn + 1, current, subroutine);\n+                        newControlFlowEdge(insn, insn + 1);\n+                    }\n+                }\n+\n+                List insnHandlers = handlers[insn];\n+                if (insnHandlers != null) {\n+                    for (int i = 0; i < insnHandlers.size(); ++i) {\n+                        TryCatchBlockNode tcb = (TryCatchBlockNode) insnHandlers.get(i);\n+                        Type type;\n+                        if (tcb.type == null) {\n+                            type = Type.getObjectType(\"java/lang/Throwable\");\n+                        } else {\n+                            type = Type.getObjectType(tcb.type);\n+                        }\n+                        int jump = insns.indexOf(tcb.handler);\n+                        if (newControlFlowExceptionEdge(insn, jump)) {\n+                            handler.init(f);\n+                            handler.clearStack();\n+                            handler.push(interpreter.newValue(type));\n+                            merge(jump, handler, subroutine);\n+                        }\n+                    }\n+                }\n+            } catch (AnalyzerException e) {\n+                throw new AnalyzerException(\"Error at instruction \" + insn\n+                        + \": \" + e.getMessage(), e);\n+            } catch (Exception e) {\n+                throw new AnalyzerException(\"Error at instruction \" + insn\n+                        + \": \" + e.getMessage(), e);\n+            }\n+        }\n+\n+        return frames;\n+    }\n+\n+    private void findSubroutine(int insn, final Subroutine sub, final List calls)\n+            throws AnalyzerException\n+    {\n+        while (true) {\n+            if (insn < 0 || insn >= n) {\n+                throw new AnalyzerException(\"Execution can fall off end of the code\");\n+            }\n+            if (subroutines[insn] != null) {\n+                return;\n+            }\n+            subroutines[insn] = sub.copy();\n+            AbstractInsnNode node = insns.get(insn);\n+\n+            // calls findSubroutine recursively on normal successors\n+            if (node instanceof JumpInsnNode) {\n+                if (node.getOpcode() == JSR) {\n+                    // do not follow a JSR, it leads to another subroutine!\n+                    calls.add(node);\n+                } else {\n+                    JumpInsnNode jnode = (JumpInsnNode) node;\n+                    findSubroutine(insns.indexOf(jnode.label), sub, calls);\n+                }\n+            } else if (node instanceof TableSwitchInsnNode) {\n+                TableSwitchInsnNode tsnode = (TableSwitchInsnNode) node;\n+                findSubroutine(insns.indexOf(tsnode.dflt), sub, calls);\n+                for (int i = tsnode.labels.size() - 1; i >= 0; --i) {\n+                    LabelNode l = (LabelNode) tsnode.labels.get(i);\n+                    findSubroutine(insns.indexOf(l), sub, calls);\n+                }\n+            } else if (node instanceof LookupSwitchInsnNode) {\n+                LookupSwitchInsnNode lsnode = (LookupSwitchInsnNode) node;\n+                findSubroutine(insns.indexOf(lsnode.dflt), sub, calls);\n+                for (int i = lsnode.labels.size() - 1; i >= 0; --i) {\n+                    LabelNode l = (LabelNode) lsnode.labels.get(i);\n+                    findSubroutine(insns.indexOf(l), sub, calls);\n+                }\n+            }\n+\n+            // calls findSubroutine recursively on exception handler successors\n+            List insnHandlers = handlers[insn];\n+            if (insnHandlers != null) {\n+                for (int i = 0; i < insnHandlers.size(); ++i) {\n+                    TryCatchBlockNode tcb = (TryCatchBlockNode) insnHandlers.get(i);\n+                    findSubroutine(insns.indexOf(tcb.handler), sub, calls);\n+                }\n+            }\n+\n+            // if insn does not falls through to the next instruction, return.\n+            switch (node.getOpcode()) {\n+                case GOTO:\n+                case RET:\n+                case TABLESWITCH:\n+                case LOOKUPSWITCH:\n+                case IRETURN:\n+                case LRETURN:\n+                case FRETURN:\n+                case DRETURN:\n+                case ARETURN:\n+                case RETURN:\n+                case ATHROW:\n+                    return;\n+            }\n+            insn++;\n+        }\n+    }\n+\n+    /**\n+     * Returns the symbolic stack frame for each instruction of the last\n+     * recently analyzed method.\n+     * \n+     * @return the symbolic state of the execution stack frame at each bytecode\n+     *         instruction of the method. The size of the returned array is\n+     *         equal to the number of instructions (and labels) of the method. A\n+     *         given frame is <tt>null</tt> if the corresponding instruction\n+     *         cannot be reached, or if an error occured during the analysis of\n+     *         the method.\n+     */\n+    public Frame[] getFrames() {\n+        return frames;\n+    }\n+\n+    /**\n+     * Returns the exception handlers for the given instruction.\n+     * \n+     * @param insn the index of an instruction of the last recently analyzed\n+     *        method.\n+     * @return a list of {@link TryCatchBlockNode} objects.\n+     */\n+    public List getHandlers(final int insn) {\n+        return handlers[insn];\n+    }\n+\n+    /**\n+     * Constructs a new frame with the given size.\n+     * \n+     * @param nLocals the maximum number of local variables of the frame.\n+     * @param nStack the maximum stack size of the frame.\n+     * @return the created frame.\n+     */\n+    protected Frame newFrame(final int nLocals, final int nStack) {\n+        return new Frame(nLocals, nStack);\n+    }\n+\n+    /**\n+     * Constructs a new frame that is identical to the given frame.\n+     * \n+     * @param src a frame.\n+     * @return the created frame.\n+     */\n+    protected Frame newFrame(final Frame src) {\n+        return new Frame(src);\n+    }\n+\n+    /**\n+     * Creates a control flow graph edge. The default implementation of this\n+     * method does nothing. It can be overriden in order to construct the\n+     * control flow graph of a method (this method is called by the\n+     * {@link #analyze analyze} method during its visit of the method's code).\n+     * \n+     * @param insn an instruction index.\n+     * @param successor index of a successor instruction.\n+     */\n+    protected void newControlFlowEdge(final int insn, final int successor) {\n+    }\n+\n+    /**\n+     * Creates a control flow graph edge corresponding to an exception handler.\n+     * The default implementation of this method does nothing. It can be\n+     * overriden in order to construct the control flow graph of a method (this\n+     * method is called by the {@link #analyze analyze} method during its visit\n+     * of the method's code).\n+     * \n+     * @param insn an instruction index.\n+     * @param successor index of a successor instruction.\n+     * @return true if this edge must be considered in the data flow analysis\n+     *         performed by this analyzer, or false otherwise. The default\n+     *         implementation of this method always returns true.\n+     */\n+    protected boolean newControlFlowExceptionEdge(\n+        final int insn,\n+        final int successor)\n+    {\n+        return true;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    private void merge(\n+        final int insn,\n+        final Frame frame,\n+        final Subroutine subroutine) throws AnalyzerException\n+    {\n+        Frame oldFrame = frames[insn];\n+        Subroutine oldSubroutine = subroutines[insn];\n+        boolean changes;\n+\n+        if (oldFrame == null) {\n+            frames[insn] = newFrame(frame);\n+            changes = true;\n+        } else {\n+            changes = oldFrame.merge(frame, interpreter);\n+        }\n+\n+        if (oldSubroutine == null) {\n+            if (subroutine != null) {\n+                subroutines[insn] = subroutine.copy();\n+                changes = true;\n+            }\n+        } else {\n+            if (subroutine != null) {\n+                changes |= oldSubroutine.merge(subroutine);\n+            }\n+        }\n+        if (changes && !queued[insn]) {\n+            queued[insn] = true;\n+            queue[top++] = insn;\n+        }\n+    }\n+\n+    private void merge(\n+        final int insn,\n+        final Frame beforeJSR,\n+        final Frame afterRET,\n+        final Subroutine subroutineBeforeJSR,\n+        final boolean[] access) throws AnalyzerException\n+    {\n+        Frame oldFrame = frames[insn];\n+        Subroutine oldSubroutine = subroutines[insn];\n+        boolean changes;\n+\n+        afterRET.merge(beforeJSR, access);\n+\n+        if (oldFrame == null) {\n+            frames[insn] = newFrame(afterRET);\n+            changes = true;\n+        } else {\n+            changes = oldFrame.merge(afterRET, access);\n+        }\n+\n+        if (oldSubroutine != null && subroutineBeforeJSR != null) {\n+            changes |= oldSubroutine.merge(subroutineBeforeJSR);\n+        }\n+        if (changes && !queued[insn]) {\n+            queued[insn] = true;\n+            queue[top++] = insn;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/AnalyzerException.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+/**\n+ * Thrown if a problem occurs during the analysis of a method.\n+ * \n+ * @author Bing Ran\n+ * @author Eric Bruneton\n+ */\n+public class AnalyzerException extends Exception {\n+\n+    public AnalyzerException(final String msg) {\n+        super(msg);\n+    }\n+\n+    public AnalyzerException(final String msg, final Throwable exception) {\n+        super(msg, exception);\n+    }\n+\n+    public AnalyzerException(\n+        final String msg,\n+        final Object expected,\n+        final Value encountered)\n+    {\n+        super((msg == null ? \"Expected \" : msg + \": expected \") + expected\n+                + \", but found \" + encountered);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/BasicInterpreter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.List;\n+\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.AbstractInsnNode;\n+import org.mockito.asm.tree.FieldInsnNode;\n+import org.mockito.asm.tree.IntInsnNode;\n+import org.mockito.asm.tree.LdcInsnNode;\n+import org.mockito.asm.tree.MethodInsnNode;\n+import org.mockito.asm.tree.MultiANewArrayInsnNode;\n+import org.mockito.asm.tree.TypeInsnNode;\n+\n+/**\n+ * An {@link Interpreter} for {@link BasicValue} values.\n+ * \n+ * @author Eric Bruneton\n+ * @author Bing Ran\n+ */\n+public class BasicInterpreter implements Opcodes, Interpreter {\n+\n+    public Value newValue(final Type type) {\n+        if (type == null) {\n+            return BasicValue.UNINITIALIZED_VALUE;\n+        }\n+        switch (type.getSort()) {\n+            case Type.VOID:\n+                return null;\n+            case Type.BOOLEAN:\n+            case Type.CHAR:\n+            case Type.BYTE:\n+            case Type.SHORT:\n+            case Type.INT:\n+                return BasicValue.INT_VALUE;\n+            case Type.FLOAT:\n+                return BasicValue.FLOAT_VALUE;\n+            case Type.LONG:\n+                return BasicValue.LONG_VALUE;\n+            case Type.DOUBLE:\n+                return BasicValue.DOUBLE_VALUE;\n+            case Type.ARRAY:\n+            case Type.OBJECT:\n+                return BasicValue.REFERENCE_VALUE;\n+            default:\n+                throw new Error(\"Internal error\");\n+        }\n+    }\n+\n+    public Value newOperation(final AbstractInsnNode insn) {\n+        switch (insn.getOpcode()) {\n+            case ACONST_NULL:\n+                return newValue(Type.getObjectType(\"null\"));\n+            case ICONST_M1:\n+            case ICONST_0:\n+            case ICONST_1:\n+            case ICONST_2:\n+            case ICONST_3:\n+            case ICONST_4:\n+            case ICONST_5:\n+                return BasicValue.INT_VALUE;\n+            case LCONST_0:\n+            case LCONST_1:\n+                return BasicValue.LONG_VALUE;\n+            case FCONST_0:\n+            case FCONST_1:\n+            case FCONST_2:\n+                return BasicValue.FLOAT_VALUE;\n+            case DCONST_0:\n+            case DCONST_1:\n+                return BasicValue.DOUBLE_VALUE;\n+            case BIPUSH:\n+            case SIPUSH:\n+                return BasicValue.INT_VALUE;\n+            case LDC:\n+                Object cst = ((LdcInsnNode) insn).cst;\n+                if (cst instanceof Integer) {\n+                    return BasicValue.INT_VALUE;\n+                } else if (cst instanceof Float) {\n+                    return BasicValue.FLOAT_VALUE;\n+                } else if (cst instanceof Long) {\n+                    return BasicValue.LONG_VALUE;\n+                } else if (cst instanceof Double) {\n+                    return BasicValue.DOUBLE_VALUE;\n+                } else if (cst instanceof Type) {\n+                    return newValue(Type.getObjectType(\"java/lang/Class\"));\n+                } else {\n+                    return newValue(Type.getType(cst.getClass()));\n+                }\n+            case JSR:\n+                return BasicValue.RETURNADDRESS_VALUE;\n+            case GETSTATIC:\n+                return newValue(Type.getType(((FieldInsnNode) insn).desc));\n+            case NEW:\n+                return newValue(Type.getObjectType(((TypeInsnNode) insn).desc));\n+            default:\n+                throw new Error(\"Internal error.\");\n+        }\n+    }\n+\n+    public Value copyOperation(final AbstractInsnNode insn, final Value value)\n+            throws AnalyzerException\n+    {\n+        return value;\n+    }\n+\n+    public Value unaryOperation(final AbstractInsnNode insn, final Value value)\n+            throws AnalyzerException\n+    {\n+        switch (insn.getOpcode()) {\n+            case INEG:\n+            case IINC:\n+            case L2I:\n+            case F2I:\n+            case D2I:\n+            case I2B:\n+            case I2C:\n+            case I2S:\n+                return BasicValue.INT_VALUE;\n+            case FNEG:\n+            case I2F:\n+            case L2F:\n+            case D2F:\n+                return BasicValue.FLOAT_VALUE;\n+            case LNEG:\n+            case I2L:\n+            case F2L:\n+            case D2L:\n+                return BasicValue.LONG_VALUE;\n+            case DNEG:\n+            case I2D:\n+            case L2D:\n+            case F2D:\n+                return BasicValue.DOUBLE_VALUE;\n+            case IFEQ:\n+            case IFNE:\n+            case IFLT:\n+            case IFGE:\n+            case IFGT:\n+            case IFLE:\n+            case TABLESWITCH:\n+            case LOOKUPSWITCH:\n+            case IRETURN:\n+            case LRETURN:\n+            case FRETURN:\n+            case DRETURN:\n+            case ARETURN:\n+            case PUTSTATIC:\n+                return null;\n+            case GETFIELD:\n+                return newValue(Type.getType(((FieldInsnNode) insn).desc));\n+            case NEWARRAY:\n+                switch (((IntInsnNode) insn).operand) {\n+                    case T_BOOLEAN:\n+                        return newValue(Type.getType(\"[Z\"));\n+                    case T_CHAR:\n+                        return newValue(Type.getType(\"[C\"));\n+                    case T_BYTE:\n+                        return newValue(Type.getType(\"[B\"));\n+                    case T_SHORT:\n+                        return newValue(Type.getType(\"[S\"));\n+                    case T_INT:\n+                        return newValue(Type.getType(\"[I\"));\n+                    case T_FLOAT:\n+                        return newValue(Type.getType(\"[F\"));\n+                    case T_DOUBLE:\n+                        return newValue(Type.getType(\"[D\"));\n+                    case T_LONG:\n+                        return newValue(Type.getType(\"[J\"));\n+                    default:\n+                        throw new AnalyzerException(\"Invalid array type\");\n+                }\n+            case ANEWARRAY:\n+                String desc = ((TypeInsnNode) insn).desc;\n+                return newValue(Type.getType(\"[\" + Type.getObjectType(desc)));\n+            case ARRAYLENGTH:\n+                return BasicValue.INT_VALUE;\n+            case ATHROW:\n+                return null;\n+            case CHECKCAST:\n+                desc = ((TypeInsnNode) insn).desc;\n+                return newValue(Type.getObjectType(desc));\n+            case INSTANCEOF:\n+                return BasicValue.INT_VALUE;\n+            case MONITORENTER:\n+            case MONITOREXIT:\n+            case IFNULL:\n+            case IFNONNULL:\n+                return null;\n+            default:\n+                throw new Error(\"Internal error.\");\n+        }\n+    }\n+\n+    public Value binaryOperation(\n+        final AbstractInsnNode insn,\n+        final Value value1,\n+        final Value value2) throws AnalyzerException\n+    {\n+        switch (insn.getOpcode()) {\n+            case IALOAD:\n+            case BALOAD:\n+            case CALOAD:\n+            case SALOAD:\n+            case IADD:\n+            case ISUB:\n+            case IMUL:\n+            case IDIV:\n+            case IREM:\n+            case ISHL:\n+            case ISHR:\n+            case IUSHR:\n+            case IAND:\n+            case IOR:\n+            case IXOR:\n+                return BasicValue.INT_VALUE;\n+            case FALOAD:\n+            case FADD:\n+            case FSUB:\n+            case FMUL:\n+            case FDIV:\n+            case FREM:\n+                return BasicValue.FLOAT_VALUE;\n+            case LALOAD:\n+            case LADD:\n+            case LSUB:\n+            case LMUL:\n+            case LDIV:\n+            case LREM:\n+            case LSHL:\n+            case LSHR:\n+            case LUSHR:\n+            case LAND:\n+            case LOR:\n+            case LXOR:\n+                return BasicValue.LONG_VALUE;\n+            case DALOAD:\n+            case DADD:\n+            case DSUB:\n+            case DMUL:\n+            case DDIV:\n+            case DREM:\n+                return BasicValue.DOUBLE_VALUE;\n+            case AALOAD:\n+                return BasicValue.REFERENCE_VALUE;\n+            case LCMP:\n+            case FCMPL:\n+            case FCMPG:\n+            case DCMPL:\n+            case DCMPG:\n+                return BasicValue.INT_VALUE;\n+            case IF_ICMPEQ:\n+            case IF_ICMPNE:\n+            case IF_ICMPLT:\n+            case IF_ICMPGE:\n+            case IF_ICMPGT:\n+            case IF_ICMPLE:\n+            case IF_ACMPEQ:\n+            case IF_ACMPNE:\n+            case PUTFIELD:\n+                return null;\n+            default:\n+                throw new Error(\"Internal error.\");\n+        }\n+    }\n+\n+    public Value ternaryOperation(\n+        final AbstractInsnNode insn,\n+        final Value value1,\n+        final Value value2,\n+        final Value value3) throws AnalyzerException\n+    {\n+        return null;\n+    }\n+\n+    public Value naryOperation(final AbstractInsnNode insn, final List values)\n+            throws AnalyzerException\n+    {\n+        if (insn.getOpcode() == MULTIANEWARRAY) {\n+            return newValue(Type.getType(((MultiANewArrayInsnNode) insn).desc));\n+        } else {\n+            return newValue(Type.getReturnType(((MethodInsnNode) insn).desc));\n+        }\n+    }\n+\n+    public Value merge(final Value v, final Value w) {\n+        if (!v.equals(w)) {\n+            return BasicValue.UNINITIALIZED_VALUE;\n+        }\n+        return v;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/BasicValue.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import org.mockito.asm.Type;\n+\n+/**\n+ * A {@link Value} that is represented by its type in a seven types type system.\n+ * This type system distinguishes the UNINITIALZED, INT, FLOAT, LONG, DOUBLE,\n+ * REFERENCE and RETURNADDRESS types.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class BasicValue implements Value {\n+\n+    public static final Value UNINITIALIZED_VALUE = new BasicValue(null);\n+\n+    public static final Value INT_VALUE = new BasicValue(Type.INT_TYPE);\n+\n+    public static final Value FLOAT_VALUE = new BasicValue(Type.FLOAT_TYPE);\n+\n+    public static final Value LONG_VALUE = new BasicValue(Type.LONG_TYPE);\n+\n+    public static final Value DOUBLE_VALUE = new BasicValue(Type.DOUBLE_TYPE);\n+\n+    public static final Value REFERENCE_VALUE = new BasicValue(Type.getObjectType(\"java/lang/Object\"));\n+\n+    public static final Value RETURNADDRESS_VALUE = new BasicValue(null);\n+\n+    private final Type type;\n+\n+    public BasicValue(final Type type) {\n+        this.type = type;\n+    }\n+\n+    public Type getType() {\n+        return type;\n+    }\n+\n+    public int getSize() {\n+        return type == Type.LONG_TYPE || type == Type.DOUBLE_TYPE ? 2 : 1;\n+    }\n+\n+    public boolean isReference() {\n+        return type != null\n+                && (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY);\n+    }\n+\n+    public boolean equals(final Object value) {\n+        if (value == this) {\n+            return true;\n+        } else if (value instanceof BasicValue) {\n+            if (type == null) {\n+                return ((BasicValue) value).type == null;\n+            } else {\n+                return type.equals(((BasicValue) value).type);\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int hashCode() {\n+        return type == null ? 0 : type.hashCode();\n+    }\n+\n+    public String toString() {\n+        if (this == UNINITIALIZED_VALUE) {\n+            return \".\";\n+        } else if (this == RETURNADDRESS_VALUE) {\n+            return \"A\";\n+        } else if (this == REFERENCE_VALUE) {\n+            return \"R\";\n+        } else {\n+            return type.getDescriptor();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/BasicVerifier.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.List;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.AbstractInsnNode;\n+import org.mockito.asm.tree.FieldInsnNode;\n+import org.mockito.asm.tree.MethodInsnNode;\n+\n+/**\n+ * An extended {@link BasicInterpreter} that checks that bytecode instructions\n+ * are correctly used.\n+ * \n+ * @author Eric Bruneton\n+ * @author Bing Ran\n+ */\n+public class BasicVerifier extends BasicInterpreter {\n+\n+    public Value copyOperation(final AbstractInsnNode insn, final Value value)\n+            throws AnalyzerException\n+    {\n+        Value expected;\n+        switch (insn.getOpcode()) {\n+            case ILOAD:\n+            case ISTORE:\n+                expected = BasicValue.INT_VALUE;\n+                break;\n+            case FLOAD:\n+            case FSTORE:\n+                expected = BasicValue.FLOAT_VALUE;\n+                break;\n+            case LLOAD:\n+            case LSTORE:\n+                expected = BasicValue.LONG_VALUE;\n+                break;\n+            case DLOAD:\n+            case DSTORE:\n+                expected = BasicValue.DOUBLE_VALUE;\n+                break;\n+            case ALOAD:\n+                if (!((BasicValue) value).isReference()) {\n+                    throw new AnalyzerException(null,\n+                            \"an object reference\",\n+                            value);\n+                }\n+                return value;\n+            case ASTORE:\n+                if (!((BasicValue) value).isReference()\n+                        && value != BasicValue.RETURNADDRESS_VALUE)\n+                {\n+                    throw new AnalyzerException(null,\n+                            \"an object reference or a return address\",\n+                            value);\n+                }\n+                return value;\n+            default:\n+                return value;\n+        }\n+        // type is necessarily a primitive type here,\n+        // so value must be == to expected value\n+        if (value != expected) {\n+            throw new AnalyzerException(null, expected, value);\n+        }\n+        return value;\n+    }\n+\n+    public Value unaryOperation(final AbstractInsnNode insn, final Value value)\n+            throws AnalyzerException\n+    {\n+        Value expected;\n+        switch (insn.getOpcode()) {\n+            case INEG:\n+            case IINC:\n+            case I2F:\n+            case I2L:\n+            case I2D:\n+            case I2B:\n+            case I2C:\n+            case I2S:\n+            case IFEQ:\n+            case IFNE:\n+            case IFLT:\n+            case IFGE:\n+            case IFGT:\n+            case IFLE:\n+            case TABLESWITCH:\n+            case LOOKUPSWITCH:\n+            case IRETURN:\n+            case NEWARRAY:\n+            case ANEWARRAY:\n+                expected = BasicValue.INT_VALUE;\n+                break;\n+            case FNEG:\n+            case F2I:\n+            case F2L:\n+            case F2D:\n+            case FRETURN:\n+                expected = BasicValue.FLOAT_VALUE;\n+                break;\n+            case LNEG:\n+            case L2I:\n+            case L2F:\n+            case L2D:\n+            case LRETURN:\n+                expected = BasicValue.LONG_VALUE;\n+                break;\n+            case DNEG:\n+            case D2I:\n+            case D2F:\n+            case D2L:\n+            case DRETURN:\n+                expected = BasicValue.DOUBLE_VALUE;\n+                break;\n+            case GETFIELD:\n+                expected = newValue(Type.getObjectType(((FieldInsnNode) insn).owner));\n+                break;\n+            case CHECKCAST:\n+                if (!((BasicValue) value).isReference()) {\n+                    throw new AnalyzerException(null,\n+                            \"an object reference\",\n+                            value);\n+                }\n+                return super.unaryOperation(insn, value);\n+            case ARRAYLENGTH:\n+                if (!isArrayValue(value)) {\n+                    throw new AnalyzerException(null,\n+                            \"an array reference\",\n+                            value);\n+                }\n+                return super.unaryOperation(insn, value);\n+            case ARETURN:\n+            case ATHROW:\n+            case INSTANCEOF:\n+            case MONITORENTER:\n+            case MONITOREXIT:\n+            case IFNULL:\n+            case IFNONNULL:\n+                if (!((BasicValue) value).isReference()) {\n+                    throw new AnalyzerException(null,\n+                            \"an object reference\",\n+                            value);\n+                }\n+                return super.unaryOperation(insn, value);\n+            case PUTSTATIC:\n+                expected = newValue(Type.getType(((FieldInsnNode) insn).desc));\n+                break;\n+            default:\n+                throw new Error(\"Internal error.\");\n+        }\n+        if (!isSubTypeOf(value, expected)) {\n+            throw new AnalyzerException(null, expected, value);\n+        }\n+        return super.unaryOperation(insn, value);\n+    }\n+\n+    public Value binaryOperation(\n+        final AbstractInsnNode insn,\n+        final Value value1,\n+        final Value value2) throws AnalyzerException\n+    {\n+        Value expected1;\n+        Value expected2;\n+        switch (insn.getOpcode()) {\n+            case IALOAD:\n+                expected1 = newValue(Type.getType(\"[I\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case BALOAD:\n+                if (isSubTypeOf(value1, newValue(Type.getType(\"[Z\")))) {\n+                    expected1 = newValue(Type.getType(\"[Z\"));\n+                } else {\n+                    expected1 = newValue(Type.getType(\"[B\"));\n+                }\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case CALOAD:\n+                expected1 = newValue(Type.getType(\"[C\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case SALOAD:\n+                expected1 = newValue(Type.getType(\"[S\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case LALOAD:\n+                expected1 = newValue(Type.getType(\"[J\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case FALOAD:\n+                expected1 = newValue(Type.getType(\"[F\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case DALOAD:\n+                expected1 = newValue(Type.getType(\"[D\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case AALOAD:\n+                expected1 = newValue(Type.getType(\"[Ljava/lang/Object;\"));\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case IADD:\n+            case ISUB:\n+            case IMUL:\n+            case IDIV:\n+            case IREM:\n+            case ISHL:\n+            case ISHR:\n+            case IUSHR:\n+            case IAND:\n+            case IOR:\n+            case IXOR:\n+            case IF_ICMPEQ:\n+            case IF_ICMPNE:\n+            case IF_ICMPLT:\n+            case IF_ICMPGE:\n+            case IF_ICMPGT:\n+            case IF_ICMPLE:\n+                expected1 = BasicValue.INT_VALUE;\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case FADD:\n+            case FSUB:\n+            case FMUL:\n+            case FDIV:\n+            case FREM:\n+            case FCMPL:\n+            case FCMPG:\n+                expected1 = BasicValue.FLOAT_VALUE;\n+                expected2 = BasicValue.FLOAT_VALUE;\n+                break;\n+            case LADD:\n+            case LSUB:\n+            case LMUL:\n+            case LDIV:\n+            case LREM:\n+            case LAND:\n+            case LOR:\n+            case LXOR:\n+            case LCMP:\n+                expected1 = BasicValue.LONG_VALUE;\n+                expected2 = BasicValue.LONG_VALUE;\n+                break;\n+            case LSHL:\n+            case LSHR:\n+            case LUSHR:\n+                expected1 = BasicValue.LONG_VALUE;\n+                expected2 = BasicValue.INT_VALUE;\n+                break;\n+            case DADD:\n+            case DSUB:\n+            case DMUL:\n+            case DDIV:\n+            case DREM:\n+            case DCMPL:\n+            case DCMPG:\n+                expected1 = BasicValue.DOUBLE_VALUE;\n+                expected2 = BasicValue.DOUBLE_VALUE;\n+                break;\n+            case IF_ACMPEQ:\n+            case IF_ACMPNE:\n+                expected1 = BasicValue.REFERENCE_VALUE;\n+                expected2 = BasicValue.REFERENCE_VALUE;\n+                break;\n+            case PUTFIELD:\n+                FieldInsnNode fin = (FieldInsnNode) insn;\n+                expected1 = newValue(Type.getObjectType(fin.owner));\n+                expected2 = newValue(Type.getType(fin.desc));\n+                break;\n+            default:\n+                throw new Error(\"Internal error.\");\n+        }\n+        if (!isSubTypeOf(value1, expected1)) {\n+            throw new AnalyzerException(\"First argument\", expected1, value1);\n+        } else if (!isSubTypeOf(value2, expected2)) {\n+            throw new AnalyzerException(\"Second argument\", expected2, value2);\n+        }\n+        if (insn.getOpcode() == AALOAD) {\n+            return getElementValue(value1);\n+        } else {\n+            return super.binaryOperation(insn, value1, value2);\n+        }\n+    }\n+\n+    public Value ternaryOperation(\n+        final AbstractInsnNode insn,\n+        final Value value1,\n+        final Value value2,\n+        final Value value3) throws AnalyzerException\n+    {\n+        Value expected1;\n+        Value expected3;\n+        switch (insn.getOpcode()) {\n+            case IASTORE:\n+                expected1 = newValue(Type.getType(\"[I\"));\n+                expected3 = BasicValue.INT_VALUE;\n+                break;\n+            case BASTORE:\n+                if (isSubTypeOf(value1, newValue(Type.getType(\"[Z\")))) {\n+                    expected1 = newValue(Type.getType(\"[Z\"));\n+                } else {\n+                    expected1 = newValue(Type.getType(\"[B\"));\n+                }\n+                expected3 = BasicValue.INT_VALUE;\n+                break;\n+            case CASTORE:\n+                expected1 = newValue(Type.getType(\"[C\"));\n+                expected3 = BasicValue.INT_VALUE;\n+                break;\n+            case SASTORE:\n+                expected1 = newValue(Type.getType(\"[S\"));\n+                expected3 = BasicValue.INT_VALUE;\n+                break;\n+            case LASTORE:\n+                expected1 = newValue(Type.getType(\"[J\"));\n+                expected3 = BasicValue.LONG_VALUE;\n+                break;\n+            case FASTORE:\n+                expected1 = newValue(Type.getType(\"[F\"));\n+                expected3 = BasicValue.FLOAT_VALUE;\n+                break;\n+            case DASTORE:\n+                expected1 = newValue(Type.getType(\"[D\"));\n+                expected3 = BasicValue.DOUBLE_VALUE;\n+                break;\n+            case AASTORE:\n+                expected1 = value1;\n+                expected3 = BasicValue.REFERENCE_VALUE;\n+                break;\n+            default:\n+                throw new Error(\"Internal error.\");\n+        }\n+        if (!isSubTypeOf(value1, expected1)) {\n+            throw new AnalyzerException(\"First argument\", \"a \" + expected1\n+                    + \" array reference\", value1);\n+        } else if (value2 != BasicValue.INT_VALUE) {\n+            throw new AnalyzerException(\"Second argument\",\n+                    BasicValue.INT_VALUE,\n+                    value2);\n+        } else if (!isSubTypeOf(value3, expected3)) {\n+            throw new AnalyzerException(\"Third argument\", expected3, value3);\n+        }\n+        return null;\n+    }\n+\n+    public Value naryOperation(final AbstractInsnNode insn, final List values)\n+            throws AnalyzerException\n+    {\n+        int opcode = insn.getOpcode();\n+        if (opcode == MULTIANEWARRAY) {\n+            for (int i = 0; i < values.size(); ++i) {\n+                if (values.get(i) != BasicValue.INT_VALUE) {\n+                    throw new AnalyzerException(null,\n+                            BasicValue.INT_VALUE,\n+                            (Value) values.get(i));\n+                }\n+            }\n+        } else {\n+            int i = 0;\n+            int j = 0;\n+            if (opcode != INVOKESTATIC) {\n+                Type owner = Type.getObjectType(((MethodInsnNode) insn).owner);\n+                if (!isSubTypeOf((Value) values.get(i++), newValue(owner))) {\n+                    throw new AnalyzerException(\"Method owner\",\n+                            newValue(owner),\n+                            (Value) values.get(0));\n+                }\n+            }\n+            Type[] args = Type.getArgumentTypes(((MethodInsnNode) insn).desc);\n+            while (i < values.size()) {\n+                Value expected = newValue(args[j++]);\n+                Value encountered = (Value) values.get(i++);\n+                if (!isSubTypeOf(encountered, expected)) {\n+                    throw new AnalyzerException(\"Argument \" + j,\n+                            expected,\n+                            encountered);\n+                }\n+            }\n+        }\n+        return super.naryOperation(insn, values);\n+    }\n+\n+    protected boolean isArrayValue(final Value value) {\n+        return ((BasicValue) value).isReference();\n+    }\n+\n+    protected Value getElementValue(final Value objectArrayValue)\n+            throws AnalyzerException\n+    {\n+        return BasicValue.REFERENCE_VALUE;\n+    }\n+\n+    protected boolean isSubTypeOf(final Value value, final Value expected) {\n+        return value == expected;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/Frame.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.AbstractInsnNode;\n+import org.mockito.asm.tree.IincInsnNode;\n+import org.mockito.asm.tree.MethodInsnNode;\n+import org.mockito.asm.tree.MultiANewArrayInsnNode;\n+import org.mockito.asm.tree.VarInsnNode;\n+\n+/**\n+ * A symbolic execution stack frame. A stack frame contains a set of local\n+ * variable slots, and an operand stack. Warning: long and double values are\n+ * represented by <i>two</i> slots in local variables, and by <i>one</i> slot\n+ * in the operand stack.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class Frame {\n+\n+    /**\n+     * The local variables and operand stack of this frame.\n+     */\n+    private Value[] values;\n+\n+    /**\n+     * The number of local variables of this frame.\n+     */\n+    private int locals;\n+\n+    /**\n+     * The number of elements in the operand stack.\n+     */\n+    private int top;\n+\n+    /**\n+     * Constructs a new frame with the given size.\n+     * \n+     * @param nLocals the maximum number of local variables of the frame.\n+     * @param nStack the maximum stack size of the frame.\n+     */\n+    public Frame(final int nLocals, final int nStack) {\n+        this.values = new Value[nLocals + nStack];\n+        this.locals = nLocals;\n+    }\n+\n+    /**\n+     * Constructs a new frame that is identical to the given frame.\n+     * \n+     * @param src a frame.\n+     */\n+    public Frame(final Frame src) {\n+        this(src.locals, src.values.length - src.locals);\n+        init(src);\n+    }\n+\n+    /**\n+     * Copies the state of the given frame into this frame.\n+     * \n+     * @param src a frame.\n+     * @return this frame.\n+     */\n+    public Frame init(final Frame src) {\n+        System.arraycopy(src.values, 0, values, 0, values.length);\n+        top = src.top;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the maximum number of local variables of this frame.\n+     * \n+     * @return the maximum number of local variables of this frame.\n+     */\n+    public int getLocals() {\n+        return locals;\n+    }\n+\n+    /**\n+     * Returns the value of the given local variable.\n+     * \n+     * @param i a local variable index.\n+     * @return the value of the given local variable.\n+     * @throws IndexOutOfBoundsException if the variable does not exist.\n+     */\n+    public Value getLocal(final int i) throws IndexOutOfBoundsException {\n+        if (i >= locals) {\n+            throw new IndexOutOfBoundsException(\"Trying to access an inexistant local variable\");\n+        }\n+        return values[i];\n+    }\n+\n+    /**\n+     * Sets the value of the given local variable.\n+     * \n+     * @param i a local variable index.\n+     * @param value the new value of this local variable.\n+     * @throws IndexOutOfBoundsException if the variable does not exist.\n+     */\n+    public void setLocal(final int i, final Value value)\n+            throws IndexOutOfBoundsException\n+    {\n+        if (i >= locals) {\n+            throw new IndexOutOfBoundsException(\"Trying to access an inexistant local variable\");\n+        }\n+        values[i] = value;\n+    }\n+\n+    /**\n+     * Returns the number of values in the operand stack of this frame. Long and\n+     * double values are treated as single values.\n+     * \n+     * @return the number of values in the operand stack of this frame.\n+     */\n+    public int getStackSize() {\n+        return top;\n+    }\n+\n+    /**\n+     * Returns the value of the given operand stack slot.\n+     * \n+     * @param i the index of an operand stack slot.\n+     * @return the value of the given operand stack slot.\n+     * @throws IndexOutOfBoundsException if the operand stack slot does not\n+     *         exist.\n+     */\n+    public Value getStack(final int i) throws IndexOutOfBoundsException {\n+        return values[i + locals];\n+    }\n+\n+    /**\n+     * Clears the operand stack of this frame.\n+     */\n+    public void clearStack() {\n+        top = 0;\n+    }\n+\n+    /**\n+     * Pops a value from the operand stack of this frame.\n+     * \n+     * @return the value that has been popped from the stack.\n+     * @throws IndexOutOfBoundsException if the operand stack is empty.\n+     */\n+    public Value pop() throws IndexOutOfBoundsException {\n+        if (top == 0) {\n+            throw new IndexOutOfBoundsException(\"Cannot pop operand off an empty stack.\");\n+        }\n+        return values[--top + locals];\n+    }\n+\n+    /**\n+     * Pushes a value into the operand stack of this frame.\n+     * \n+     * @param value the value that must be pushed into the stack.\n+     * @throws IndexOutOfBoundsException if the operand stack is full.\n+     */\n+    public void push(final Value value) throws IndexOutOfBoundsException {\n+        if (top + locals >= values.length) {\n+            throw new IndexOutOfBoundsException(\"Insufficient maximum stack size.\");\n+        }\n+        values[top++ + locals] = value;\n+    }\n+\n+    public void execute(\n+        final AbstractInsnNode insn,\n+        final Interpreter interpreter) throws AnalyzerException\n+    {\n+        Value value1, value2, value3, value4;\n+        List values;\n+        int var;\n+\n+        switch (insn.getOpcode()) {\n+            case Opcodes.NOP:\n+                break;\n+            case Opcodes.ACONST_NULL:\n+            case Opcodes.ICONST_M1:\n+            case Opcodes.ICONST_0:\n+            case Opcodes.ICONST_1:\n+            case Opcodes.ICONST_2:\n+            case Opcodes.ICONST_3:\n+            case Opcodes.ICONST_4:\n+            case Opcodes.ICONST_5:\n+            case Opcodes.LCONST_0:\n+            case Opcodes.LCONST_1:\n+            case Opcodes.FCONST_0:\n+            case Opcodes.FCONST_1:\n+            case Opcodes.FCONST_2:\n+            case Opcodes.DCONST_0:\n+            case Opcodes.DCONST_1:\n+            case Opcodes.BIPUSH:\n+            case Opcodes.SIPUSH:\n+            case Opcodes.LDC:\n+                push(interpreter.newOperation(insn));\n+                break;\n+            case Opcodes.ILOAD:\n+            case Opcodes.LLOAD:\n+            case Opcodes.FLOAD:\n+            case Opcodes.DLOAD:\n+            case Opcodes.ALOAD:\n+                push(interpreter.copyOperation(insn,\n+                        getLocal(((VarInsnNode) insn).var)));\n+                break;\n+            case Opcodes.IALOAD:\n+            case Opcodes.LALOAD:\n+            case Opcodes.FALOAD:\n+            case Opcodes.DALOAD:\n+            case Opcodes.AALOAD:\n+            case Opcodes.BALOAD:\n+            case Opcodes.CALOAD:\n+            case Opcodes.SALOAD:\n+                value2 = pop();\n+                value1 = pop();\n+                push(interpreter.binaryOperation(insn, value1, value2));\n+                break;\n+            case Opcodes.ISTORE:\n+            case Opcodes.LSTORE:\n+            case Opcodes.FSTORE:\n+            case Opcodes.DSTORE:\n+            case Opcodes.ASTORE:\n+                value1 = interpreter.copyOperation(insn, pop());\n+                var = ((VarInsnNode) insn).var;\n+                setLocal(var, value1);\n+                if (value1.getSize() == 2) {\n+                    setLocal(var + 1, interpreter.newValue(null));\n+                }\n+                if (var > 0) {\n+                    Value local = getLocal(var - 1);\n+                    if (local != null && local.getSize() == 2) {\n+                        setLocal(var - 1, interpreter.newValue(null));\n+                    }\n+                }\n+                break;\n+            case Opcodes.IASTORE:\n+            case Opcodes.LASTORE:\n+            case Opcodes.FASTORE:\n+            case Opcodes.DASTORE:\n+            case Opcodes.AASTORE:\n+            case Opcodes.BASTORE:\n+            case Opcodes.CASTORE:\n+            case Opcodes.SASTORE:\n+                value3 = pop();\n+                value2 = pop();\n+                value1 = pop();\n+                interpreter.ternaryOperation(insn, value1, value2, value3);\n+                break;\n+            case Opcodes.POP:\n+                if (pop().getSize() == 2) {\n+                    throw new AnalyzerException(\"Illegal use of POP\");\n+                }\n+                break;\n+            case Opcodes.POP2:\n+                if (pop().getSize() == 1) {\n+                    if (pop().getSize() != 1) {\n+                        throw new AnalyzerException(\"Illegal use of POP2\");\n+                    }\n+                }\n+                break;\n+            case Opcodes.DUP:\n+                value1 = pop();\n+                if (value1.getSize() != 1) {\n+                    throw new AnalyzerException(\"Illegal use of DUP\");\n+                }\n+                push(interpreter.copyOperation(insn, value1));\n+                push(interpreter.copyOperation(insn, value1));\n+                break;\n+            case Opcodes.DUP_X1:\n+                value1 = pop();\n+                value2 = pop();\n+                if (value1.getSize() != 1 || value2.getSize() != 1) {\n+                    throw new AnalyzerException(\"Illegal use of DUP_X1\");\n+                }\n+                push(interpreter.copyOperation(insn, value1));\n+                push(interpreter.copyOperation(insn, value2));\n+                push(interpreter.copyOperation(insn, value1));\n+                break;\n+            case Opcodes.DUP_X2:\n+                value1 = pop();\n+                if (value1.getSize() == 1) {\n+                    value2 = pop();\n+                    if (value2.getSize() == 1) {\n+                        value3 = pop();\n+                        if (value3.getSize() == 1) {\n+                            push(interpreter.copyOperation(insn, value1));\n+                            push(interpreter.copyOperation(insn, value3));\n+                            push(interpreter.copyOperation(insn, value2));\n+                            push(interpreter.copyOperation(insn, value1));\n+                            break;\n+                        }\n+                    } else {\n+                        push(interpreter.copyOperation(insn, value1));\n+                        push(interpreter.copyOperation(insn, value2));\n+                        push(interpreter.copyOperation(insn, value1));\n+                        break;\n+                    }\n+                }\n+                throw new AnalyzerException(\"Illegal use of DUP_X2\");\n+            case Opcodes.DUP2:\n+                value1 = pop();\n+                if (value1.getSize() == 1) {\n+                    value2 = pop();\n+                    if (value2.getSize() == 1) {\n+                        push(interpreter.copyOperation(insn, value2));\n+                        push(interpreter.copyOperation(insn, value1));\n+                        push(interpreter.copyOperation(insn, value2));\n+                        push(interpreter.copyOperation(insn, value1));\n+                        break;\n+                    }\n+                } else {\n+                    push(interpreter.copyOperation(insn, value1));\n+                    push(interpreter.copyOperation(insn, value1));\n+                    break;\n+                }\n+                throw new AnalyzerException(\"Illegal use of DUP2\");\n+            case Opcodes.DUP2_X1:\n+                value1 = pop();\n+                if (value1.getSize() == 1) {\n+                    value2 = pop();\n+                    if (value2.getSize() == 1) {\n+                        value3 = pop();\n+                        if (value3.getSize() == 1) {\n+                            push(interpreter.copyOperation(insn, value2));\n+                            push(interpreter.copyOperation(insn, value1));\n+                            push(interpreter.copyOperation(insn, value3));\n+                            push(interpreter.copyOperation(insn, value2));\n+                            push(interpreter.copyOperation(insn, value1));\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    value2 = pop();\n+                    if (value2.getSize() == 1) {\n+                        push(interpreter.copyOperation(insn, value1));\n+                        push(interpreter.copyOperation(insn, value2));\n+                        push(interpreter.copyOperation(insn, value1));\n+                        break;\n+                    }\n+                }\n+                throw new AnalyzerException(\"Illegal use of DUP2_X1\");\n+            case Opcodes.DUP2_X2:\n+                value1 = pop();\n+                if (value1.getSize() == 1) {\n+                    value2 = pop();\n+                    if (value2.getSize() == 1) {\n+                        value3 = pop();\n+                        if (value3.getSize() == 1) {\n+                            value4 = pop();\n+                            if (value4.getSize() == 1) {\n+                                push(interpreter.copyOperation(insn, value2));\n+                                push(interpreter.copyOperation(insn, value1));\n+                                push(interpreter.copyOperation(insn, value4));\n+                                push(interpreter.copyOperation(insn, value3));\n+                                push(interpreter.copyOperation(insn, value2));\n+                                push(interpreter.copyOperation(insn, value1));\n+                                break;\n+                            }\n+                        } else {\n+                            push(interpreter.copyOperation(insn, value2));\n+                            push(interpreter.copyOperation(insn, value1));\n+                            push(interpreter.copyOperation(insn, value3));\n+                            push(interpreter.copyOperation(insn, value2));\n+                            push(interpreter.copyOperation(insn, value1));\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    value2 = pop();\n+                    if (value2.getSize() == 1) {\n+                        value3 = pop();\n+                        if (value3.getSize() == 1) {\n+                            push(interpreter.copyOperation(insn, value1));\n+                            push(interpreter.copyOperation(insn, value3));\n+                            push(interpreter.copyOperation(insn, value2));\n+                            push(interpreter.copyOperation(insn, value1));\n+                            break;\n+                        }\n+                    } else {\n+                        push(interpreter.copyOperation(insn, value1));\n+                        push(interpreter.copyOperation(insn, value2));\n+                        push(interpreter.copyOperation(insn, value1));\n+                        break;\n+                    }\n+                }\n+                throw new AnalyzerException(\"Illegal use of DUP2_X2\");\n+            case Opcodes.SWAP:\n+                value2 = pop();\n+                value1 = pop();\n+                if (value1.getSize() != 1 || value2.getSize() != 1) {\n+                    throw new AnalyzerException(\"Illegal use of SWAP\");\n+                }\n+                push(interpreter.copyOperation(insn, value2));\n+                push(interpreter.copyOperation(insn, value1));\n+                break;\n+            case Opcodes.IADD:\n+            case Opcodes.LADD:\n+            case Opcodes.FADD:\n+            case Opcodes.DADD:\n+            case Opcodes.ISUB:\n+            case Opcodes.LSUB:\n+            case Opcodes.FSUB:\n+            case Opcodes.DSUB:\n+            case Opcodes.IMUL:\n+            case Opcodes.LMUL:\n+            case Opcodes.FMUL:\n+            case Opcodes.DMUL:\n+            case Opcodes.IDIV:\n+            case Opcodes.LDIV:\n+            case Opcodes.FDIV:\n+            case Opcodes.DDIV:\n+            case Opcodes.IREM:\n+            case Opcodes.LREM:\n+            case Opcodes.FREM:\n+            case Opcodes.DREM:\n+                value2 = pop();\n+                value1 = pop();\n+                push(interpreter.binaryOperation(insn, value1, value2));\n+                break;\n+            case Opcodes.INEG:\n+            case Opcodes.LNEG:\n+            case Opcodes.FNEG:\n+            case Opcodes.DNEG:\n+                push(interpreter.unaryOperation(insn, pop()));\n+                break;\n+            case Opcodes.ISHL:\n+            case Opcodes.LSHL:\n+            case Opcodes.ISHR:\n+            case Opcodes.LSHR:\n+            case Opcodes.IUSHR:\n+            case Opcodes.LUSHR:\n+            case Opcodes.IAND:\n+            case Opcodes.LAND:\n+            case Opcodes.IOR:\n+            case Opcodes.LOR:\n+            case Opcodes.IXOR:\n+            case Opcodes.LXOR:\n+                value2 = pop();\n+                value1 = pop();\n+                push(interpreter.binaryOperation(insn, value1, value2));\n+                break;\n+            case Opcodes.IINC:\n+                var = ((IincInsnNode) insn).var;\n+                setLocal(var, interpreter.unaryOperation(insn, getLocal(var)));\n+                break;\n+            case Opcodes.I2L:\n+            case Opcodes.I2F:\n+            case Opcodes.I2D:\n+            case Opcodes.L2I:\n+            case Opcodes.L2F:\n+            case Opcodes.L2D:\n+            case Opcodes.F2I:\n+            case Opcodes.F2L:\n+            case Opcodes.F2D:\n+            case Opcodes.D2I:\n+            case Opcodes.D2L:\n+            case Opcodes.D2F:\n+            case Opcodes.I2B:\n+            case Opcodes.I2C:\n+            case Opcodes.I2S:\n+                push(interpreter.unaryOperation(insn, pop()));\n+                break;\n+            case Opcodes.LCMP:\n+            case Opcodes.FCMPL:\n+            case Opcodes.FCMPG:\n+            case Opcodes.DCMPL:\n+            case Opcodes.DCMPG:\n+                value2 = pop();\n+                value1 = pop();\n+                push(interpreter.binaryOperation(insn, value1, value2));\n+                break;\n+            case Opcodes.IFEQ:\n+            case Opcodes.IFNE:\n+            case Opcodes.IFLT:\n+            case Opcodes.IFGE:\n+            case Opcodes.IFGT:\n+            case Opcodes.IFLE:\n+                interpreter.unaryOperation(insn, pop());\n+                break;\n+            case Opcodes.IF_ICMPEQ:\n+            case Opcodes.IF_ICMPNE:\n+            case Opcodes.IF_ICMPLT:\n+            case Opcodes.IF_ICMPGE:\n+            case Opcodes.IF_ICMPGT:\n+            case Opcodes.IF_ICMPLE:\n+            case Opcodes.IF_ACMPEQ:\n+            case Opcodes.IF_ACMPNE:\n+                value2 = pop();\n+                value1 = pop();\n+                interpreter.binaryOperation(insn, value1, value2);\n+                break;\n+            case Opcodes.GOTO:\n+                break;\n+            case Opcodes.JSR:\n+                push(interpreter.newOperation(insn));\n+                break;\n+            case Opcodes.RET:\n+                break;\n+            case Opcodes.TABLESWITCH:\n+            case Opcodes.LOOKUPSWITCH:\n+            case Opcodes.IRETURN:\n+            case Opcodes.LRETURN:\n+            case Opcodes.FRETURN:\n+            case Opcodes.DRETURN:\n+            case Opcodes.ARETURN:\n+                interpreter.unaryOperation(insn, pop());\n+                break;\n+            case Opcodes.RETURN:\n+                break;\n+            case Opcodes.GETSTATIC:\n+                push(interpreter.newOperation(insn));\n+                break;\n+            case Opcodes.PUTSTATIC:\n+                interpreter.unaryOperation(insn, pop());\n+                break;\n+            case Opcodes.GETFIELD:\n+                push(interpreter.unaryOperation(insn, pop()));\n+                break;\n+            case Opcodes.PUTFIELD:\n+                value2 = pop();\n+                value1 = pop();\n+                interpreter.binaryOperation(insn, value1, value2);\n+                break;\n+            case Opcodes.INVOKEVIRTUAL:\n+            case Opcodes.INVOKESPECIAL:\n+            case Opcodes.INVOKESTATIC:\n+            case Opcodes.INVOKEINTERFACE:\n+                values = new ArrayList();\n+                String desc = ((MethodInsnNode) insn).desc;\n+                for (int i = Type.getArgumentTypes(desc).length; i > 0; --i) {\n+                    values.add(0, pop());\n+                }\n+                if (insn.getOpcode() != Opcodes.INVOKESTATIC) {\n+                    values.add(0, pop());\n+                }\n+                if (Type.getReturnType(desc) == Type.VOID_TYPE) {\n+                    interpreter.naryOperation(insn, values);\n+                } else {\n+                    push(interpreter.naryOperation(insn, values));\n+                }\n+                break;\n+            case Opcodes.NEW:\n+                push(interpreter.newOperation(insn));\n+                break;\n+            case Opcodes.NEWARRAY:\n+            case Opcodes.ANEWARRAY:\n+            case Opcodes.ARRAYLENGTH:\n+                push(interpreter.unaryOperation(insn, pop()));\n+                break;\n+            case Opcodes.ATHROW:\n+                interpreter.unaryOperation(insn, pop());\n+                break;\n+            case Opcodes.CHECKCAST:\n+            case Opcodes.INSTANCEOF:\n+                push(interpreter.unaryOperation(insn, pop()));\n+                break;\n+            case Opcodes.MONITORENTER:\n+            case Opcodes.MONITOREXIT:\n+                interpreter.unaryOperation(insn, pop());\n+                break;\n+            case Opcodes.MULTIANEWARRAY:\n+                values = new ArrayList();\n+                for (int i = ((MultiANewArrayInsnNode) insn).dims; i > 0; --i) {\n+                    values.add(0, pop());\n+                }\n+                push(interpreter.naryOperation(insn, values));\n+                break;\n+            case Opcodes.IFNULL:\n+            case Opcodes.IFNONNULL:\n+                interpreter.unaryOperation(insn, pop());\n+                break;\n+            default:\n+                throw new RuntimeException(\"Illegal opcode\");\n+        }\n+    }\n+\n+    /**\n+     * Merges this frame with the given frame.\n+     * \n+     * @param frame a frame.\n+     * @param interpreter the interpreter used to merge values.\n+     * @return <tt>true</tt> if this frame has been changed as a result of the\n+     *         merge operation, or <tt>false</tt> otherwise.\n+     * @throws AnalyzerException if the frames have incompatible sizes.\n+     */\n+    public boolean merge(final Frame frame, final Interpreter interpreter)\n+            throws AnalyzerException\n+    {\n+        if (top != frame.top) {\n+            throw new AnalyzerException(\"Incompatible stack heights\");\n+        }\n+        boolean changes = false;\n+        for (int i = 0; i < locals + top; ++i) {\n+            Value v = interpreter.merge(values[i], frame.values[i]);\n+            if (v != values[i]) {\n+                values[i] = v;\n+                changes |= true;\n+            }\n+        }\n+        return changes;\n+    }\n+\n+    /**\n+     * Merges this frame with the given frame (case of a RET instruction).\n+     * \n+     * @param frame a frame\n+     * @param access the local variables that have been accessed by the\n+     *        subroutine to which the RET instruction corresponds.\n+     * @return <tt>true</tt> if this frame has been changed as a result of the\n+     *         merge operation, or <tt>false</tt> otherwise.\n+     */\n+    public boolean merge(final Frame frame, final boolean[] access) {\n+        boolean changes = false;\n+        for (int i = 0; i < locals; ++i) {\n+            if (!access[i] && !values[i].equals(frame.values[i])) {\n+                values[i] = frame.values[i];\n+                changes = true;\n+            }\n+        }\n+        return changes;\n+    }\n+\n+    /**\n+     * Returns a string representation of this frame.\n+     * \n+     * @return a string representation of this frame.\n+     */\n+    public String toString() {\n+        StringBuffer b = new StringBuffer();\n+        for (int i = 0; i < getLocals(); ++i) {\n+            b.append(getLocal(i));\n+        }\n+        b.append(' ');\n+        for (int i = 0; i < getStackSize(); ++i) {\n+            b.append(getStack(i).toString());\n+        }\n+        return b.toString();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/Interpreter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.List;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.AbstractInsnNode;\n+\n+/**\n+ * A semantic bytecode interpreter. More precisely, this interpreter only\n+ * manages the computation of values from other values: it does not manage the\n+ * transfer of values to or from the stack, and to or from the local variables.\n+ * This separation allows a generic bytecode {@link Analyzer} to work with\n+ * various semantic interpreters, without needing to duplicate the code to\n+ * simulate the transfer of values.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public interface Interpreter {\n+\n+    /**\n+     * Creates a new value that represents the given type.\n+     * \n+     * Called for method parameters (including <code>this</code>),\n+     * exception handler variable and with <code>null</code> type \n+     * for variables reserved by long and double types.\n+     * \n+     * @param type a primitive or reference type, or <tt>null</tt> to\n+     *        represent an uninitialized value.\n+     * @return a value that represents the given type. The size of the returned\n+     *         value must be equal to the size of the given type.\n+     */\n+    Value newValue(Type type);\n+\n+    /**\n+     * Interprets a bytecode instruction without arguments. This method is\n+     * called for the following opcodes:\n+     * \n+     * ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4,\n+     * ICONST_5, LCONST_0, LCONST_1, FCONST_0, FCONST_1, FCONST_2, DCONST_0,\n+     * DCONST_1, BIPUSH, SIPUSH, LDC, JSR, GETSTATIC, NEW\n+     * \n+     * @param insn the bytecode instruction to be interpreted.\n+     * @return the result of the interpretation of the given instruction.\n+     * @throws AnalyzerException if an error occured during the interpretation.\n+     */\n+    Value newOperation(AbstractInsnNode insn) throws AnalyzerException;\n+\n+    /**\n+     * Interprets a bytecode instruction that moves a value on the stack or to\n+     * or from local variables. This method is called for the following opcodes:\n+     * \n+     * ILOAD, LLOAD, FLOAD, DLOAD, ALOAD, ISTORE, LSTORE, FSTORE, DSTORE,\n+     * ASTORE, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1, DUP2_X2, SWAP\n+     * \n+     * @param insn the bytecode instruction to be interpreted.\n+     * @param value the value that must be moved by the instruction.\n+     * @return the result of the interpretation of the given instruction. The\n+     *         returned value must be <tt>equal</tt> to the given value.\n+     * @throws AnalyzerException if an error occured during the interpretation.\n+     */\n+    Value copyOperation(AbstractInsnNode insn, Value value)\n+            throws AnalyzerException;\n+\n+    /**\n+     * Interprets a bytecode instruction with a single argument. This method is\n+     * called for the following opcodes:\n+     * \n+     * INEG, LNEG, FNEG, DNEG, IINC, I2L, I2F, I2D, L2I, L2F, L2D, F2I, F2L,\n+     * F2D, D2I, D2L, D2F, I2B, I2C, I2S, IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE,\n+     * TABLESWITCH, LOOKUPSWITCH, IRETURN, LRETURN, FRETURN, DRETURN, ARETURN,\n+     * PUTSTATIC, GETFIELD, NEWARRAY, ANEWARRAY, ARRAYLENGTH, ATHROW, CHECKCAST,\n+     * INSTANCEOF, MONITORENTER, MONITOREXIT, IFNULL, IFNONNULL\n+     * \n+     * @param insn the bytecode instruction to be interpreted.\n+     * @param value the argument of the instruction to be interpreted.\n+     * @return the result of the interpretation of the given instruction.\n+     * @throws AnalyzerException if an error occured during the interpretation.\n+     */\n+    Value unaryOperation(AbstractInsnNode insn, Value value)\n+            throws AnalyzerException;\n+\n+    /**\n+     * Interprets a bytecode instruction with two arguments. This method is\n+     * called for the following opcodes:\n+     * \n+     * IALOAD, LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD, IADD,\n+     * LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB, IMUL, LMUL, FMUL, DMUL, IDIV,\n+     * LDIV, FDIV, DDIV, IREM, LREM, FREM, DREM, ISHL, LSHL, ISHR, LSHR, IUSHR,\n+     * LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, LCMP, FCMPL, FCMPG, DCMPL,\n+     * DCMPG, IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE,\n+     * IF_ACMPEQ, IF_ACMPNE, PUTFIELD\n+     * \n+     * @param insn the bytecode instruction to be interpreted.\n+     * @param value1 the first argument of the instruction to be interpreted.\n+     * @param value2 the second argument of the instruction to be interpreted.\n+     * @return the result of the interpretation of the given instruction.\n+     * @throws AnalyzerException if an error occured during the interpretation.\n+     */\n+    Value binaryOperation(AbstractInsnNode insn, Value value1, Value value2)\n+            throws AnalyzerException;\n+\n+    /**\n+     * Interprets a bytecode instruction with three arguments. This method is\n+     * called for the following opcodes:\n+     * \n+     * IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE, SASTORE\n+     * \n+     * @param insn the bytecode instruction to be interpreted.\n+     * @param value1 the first argument of the instruction to be interpreted.\n+     * @param value2 the second argument of the instruction to be interpreted.\n+     * @param value3 the third argument of the instruction to be interpreted.\n+     * @return the result of the interpretation of the given instruction.\n+     * @throws AnalyzerException if an error occured during the interpretation.\n+     */\n+    Value ternaryOperation(\n+        AbstractInsnNode insn,\n+        Value value1,\n+        Value value2,\n+        Value value3) throws AnalyzerException;\n+\n+    /**\n+     * Interprets a bytecode instruction with a variable number of arguments.\n+     * This method is called for the following opcodes:\n+     * \n+     * INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE,\n+     * MULTIANEWARRAY\n+     * \n+     * @param insn the bytecode instruction to be interpreted.\n+     * @param values the arguments of the instruction to be interpreted.\n+     * @return the result of the interpretation of the given instruction.\n+     * @throws AnalyzerException if an error occured during the interpretation.\n+     */\n+    Value naryOperation(AbstractInsnNode insn, List values)\n+            throws AnalyzerException;\n+\n+    /**\n+     * Merges two values. The merge operation must return a value that\n+     * represents both values (for instance, if the two values are two types,\n+     * the merged value must be a common super type of the two types. If the two\n+     * values are integer intervals, the merged value must be an interval that\n+     * contains the previous ones. Likewise for other types of values).\n+     * \n+     * @param v a value.\n+     * @param w another value.\n+     * @return the merged value. If the merged value is equal to <tt>v</tt>,\n+     *         this method <i>must</i> return <tt>v</tt>.\n+     */\n+    Value merge(Value v, Value w);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/SimpleVerifier.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.List;\n+\n+import org.mockito.asm.Type;\n+\n+/**\n+ * An extended {@link BasicVerifier} that performs more precise verifications.\n+ * This verifier computes exact class types, instead of using a single \"object\n+ * reference\" type (as done in the {@link BasicVerifier}).\n+ * \n+ * @author Eric Bruneton\n+ * @author Bing Ran\n+ */\n+public class SimpleVerifier extends BasicVerifier {\n+\n+    /**\n+     * The class that is verified.\n+     */\n+    private final Type currentClass;\n+\n+    /**\n+     * The super class of the class that is verified.\n+     */\n+    private final Type currentSuperClass;\n+\n+    /**\n+     * The interfaces implemented by the class that is verified.\n+     */\n+    private final List currentClassInterfaces;\n+\n+    /**\n+     * If the class that is verified is an interface.\n+     */\n+    private final boolean isInterface;\n+\n+    /**\n+     * Constructs a new {@link SimpleVerifier}.\n+     */\n+    public SimpleVerifier() {\n+        this(null, null, false);\n+    }\n+\n+    /**\n+     * Constructs a new {@link SimpleVerifier} to verify a specific class. This\n+     * class will not be loaded into the JVM since it may be incorrect.\n+     * \n+     * @param currentClass the class that is verified.\n+     * @param currentSuperClass the super class of the class that is verified.\n+     * @param isInterface if the class that is verified is an interface.\n+     */\n+    public SimpleVerifier(\n+        final Type currentClass,\n+        final Type currentSuperClass,\n+        final boolean isInterface)\n+    {\n+        this(currentClass, currentSuperClass, null, isInterface);\n+    }\n+\n+    /**\n+     * Constructs a new {@link SimpleVerifier} to verify a specific class. This\n+     * class will not be loaded into the JVM since it may be incorrect.\n+     * \n+     * @param currentClass the class that is verified.\n+     * @param currentSuperClass the super class of the class that is verified.\n+     * @param currentClassInterfaces the interfaces implemented by the class\n+     *        that is verified.\n+     * @param isInterface if the class that is verified is an interface.\n+     */\n+    public SimpleVerifier(\n+        final Type currentClass,\n+        final Type currentSuperClass,\n+        final List currentClassInterfaces,\n+        final boolean isInterface)\n+    {\n+        this.currentClass = currentClass;\n+        this.currentSuperClass = currentSuperClass;\n+        this.currentClassInterfaces = currentClassInterfaces;\n+        this.isInterface = isInterface;\n+    }\n+\n+    public Value newValue(final Type type) {\n+        if (type == null) {\n+            return BasicValue.UNINITIALIZED_VALUE;\n+        }\n+\n+        boolean isArray = type.getSort() == Type.ARRAY;\n+        if (isArray) {\n+            switch (type.getElementType().getSort()) {\n+                case Type.BOOLEAN:\n+                case Type.CHAR:\n+                case Type.BYTE:\n+                case Type.SHORT:\n+                    return new BasicValue(type);\n+            }\n+        }\n+\n+        Value v = super.newValue(type);\n+        if (v == BasicValue.REFERENCE_VALUE) {\n+            if (isArray) {\n+                v = newValue(type.getElementType());\n+                String desc = ((BasicValue) v).getType().getDescriptor();\n+                for (int i = 0; i < type.getDimensions(); ++i) {\n+                    desc = '[' + desc;\n+                }\n+                v = new BasicValue(Type.getType(desc));\n+            } else {\n+                v = new BasicValue(type);\n+            }\n+        }\n+        return v;\n+    }\n+\n+    protected boolean isArrayValue(final Value value) {\n+        Type t = ((BasicValue) value).getType();\n+        return t != null\n+                && (\"Lnull;\".equals(t.getDescriptor()) || t.getSort() == Type.ARRAY);\n+    }\n+\n+    protected Value getElementValue(final Value objectArrayValue)\n+            throws AnalyzerException\n+    {\n+        Type arrayType = ((BasicValue) objectArrayValue).getType();\n+        if (arrayType != null) {\n+            if (arrayType.getSort() == Type.ARRAY) {\n+                return newValue(Type.getType(arrayType.getDescriptor()\n+                        .substring(1)));\n+            } else if (\"Lnull;\".equals(arrayType.getDescriptor())) {\n+                return objectArrayValue;\n+            }\n+        }\n+        throw new Error(\"Internal error\");\n+    }\n+\n+    protected boolean isSubTypeOf(final Value value, final Value expected) {\n+        Type expectedType = ((BasicValue) expected).getType();\n+        Type type = ((BasicValue) value).getType();\n+        switch (expectedType.getSort()) {\n+            case Type.INT:\n+            case Type.FLOAT:\n+            case Type.LONG:\n+            case Type.DOUBLE:\n+                return type == expectedType;\n+            case Type.ARRAY:\n+            case Type.OBJECT:\n+                if (\"Lnull;\".equals(type.getDescriptor())) {\n+                    return true;\n+                } else if (type.getSort() == Type.OBJECT\n+                        || type.getSort() == Type.ARRAY)\n+                {\n+                    return isAssignableFrom(expectedType, type);\n+                } else {\n+                    return false;\n+                }\n+            default:\n+                throw new Error(\"Internal error\");\n+        }\n+    }\n+\n+    public Value merge(final Value v, final Value w) {\n+        if (!v.equals(w)) {\n+            Type t = ((BasicValue) v).getType();\n+            Type u = ((BasicValue) w).getType();\n+            if (t != null\n+                    && (t.getSort() == Type.OBJECT || t.getSort() == Type.ARRAY))\n+            {\n+                if (u != null\n+                        && (u.getSort() == Type.OBJECT || u.getSort() == Type.ARRAY))\n+                {\n+                    if (\"Lnull;\".equals(t.getDescriptor())) {\n+                        return w;\n+                    }\n+                    if (\"Lnull;\".equals(u.getDescriptor())) {\n+                        return v;\n+                    }\n+                    if (isAssignableFrom(t, u)) {\n+                        return v;\n+                    }\n+                    if (isAssignableFrom(u, t)) {\n+                        return w;\n+                    }\n+                    // TODO case of array classes of the same dimension\n+                    // TODO should we look also for a common super interface?\n+                    // problem: there may be several possible common super\n+                    // interfaces\n+                    do {\n+                        if (t == null || isInterface(t)) {\n+                            return BasicValue.REFERENCE_VALUE;\n+                        }\n+                        t = getSuperClass(t);\n+                        if (isAssignableFrom(t, u)) {\n+                            return newValue(t);\n+                        }\n+                    } while (true);\n+                }\n+            }\n+            return BasicValue.UNINITIALIZED_VALUE;\n+        }\n+        return v;\n+    }\n+\n+    protected boolean isInterface(final Type t) {\n+        if (currentClass != null && t.equals(currentClass)) {\n+            return isInterface;\n+        }\n+        return getClass(t).isInterface();\n+    }\n+\n+    protected Type getSuperClass(final Type t) {\n+        if (currentClass != null && t.equals(currentClass)) {\n+            return currentSuperClass;\n+        }\n+        Class c = getClass(t).getSuperclass();\n+        return c == null ? null : Type.getType(c);\n+    }\n+\n+    protected boolean isAssignableFrom(final Type t, final Type u) {\n+        if (t.equals(u)) {\n+            return true;\n+        }\n+        if (currentClass != null && t.equals(currentClass)) {\n+            if (getSuperClass(u) == null) {\n+                return false;\n+            } else {\n+                return isAssignableFrom(t, getSuperClass(u));\n+            }\n+        }\n+        if (currentClass != null && u.equals(currentClass)) {\n+            if (isAssignableFrom(t, currentSuperClass)) {\n+                return true;\n+            }\n+            if (currentClassInterfaces != null) {\n+                for (int i = 0; i < currentClassInterfaces.size(); ++i) {\n+                    Type v = (Type) currentClassInterfaces.get(i);\n+                    if (isAssignableFrom(t, v)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+        return getClass(t).isAssignableFrom(getClass(u));\n+    }\n+\n+    protected Class getClass(final Type t) {\n+        try {\n+            if (t.getSort() == Type.ARRAY) {\n+                return Class.forName(t.getDescriptor().replace('/', '.'));\n+            }\n+            return Class.forName(t.getClassName());\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e.toString());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/SmallSet.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.AbstractSet;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * A set of at most two elements.\n+ * \n+ * @author Eric Bruneton\n+ */\n+class SmallSet extends AbstractSet implements Iterator {\n+\n+    // if e1 is null, e2 must be null; otherwise e2 must be different from e1\n+\n+    Object e1, e2;\n+\n+    static final Set EMPTY_SET = new SmallSet(null, null);\n+\n+    SmallSet(final Object e1, final Object e2) {\n+        this.e1 = e1;\n+        this.e2 = e2;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    // Implementation of inherited abstract methods\n+    // -------------------------------------------------------------------------\n+\n+    public Iterator iterator() {\n+        return new SmallSet(e1, e2);\n+    }\n+\n+    public int size() {\n+        return e1 == null ? 0 : (e2 == null ? 1 : 2);\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    // Implementation of the Iterator interface\n+    // -------------------------------------------------------------------------\n+\n+    public boolean hasNext() {\n+        return e1 != null;\n+    }\n+\n+    public Object next() {\n+        Object e = e1;\n+        e1 = e2;\n+        e2 = null;\n+        return e;\n+    }\n+\n+    public void remove() {\n+    }\n+\n+    // -------------------------------------------------------------------------\n+    // Utility methods\n+    // -------------------------------------------------------------------------\n+\n+    Set union(final SmallSet s) {\n+        if ((s.e1 == e1 && s.e2 == e2) || (s.e1 == e2 && s.e2 == e1)) {\n+            return this; // if the two sets are equal, return this\n+        }\n+        if (s.e1 == null) {\n+            return this; // if s is empty, return this\n+        }\n+        if (e1 == null) {\n+            return s; // if this is empty, return s\n+        }\n+        if (s.e2 == null) { // s contains exactly one element\n+            if (e2 == null) {\n+                return new SmallSet(e1, s.e1); // necessarily e1 != s.e1\n+            } else if (s.e1 == e1 || s.e1 == e2) { // s is included in this\n+                return this;\n+            }\n+        }\n+        if (e2 == null) { // this contains exactly one element\n+            // if (s.e2 == null) { // cannot happen\n+            // return new SmallSet(e1, s.e1); // necessarily e1 != s.e1\n+            // } else\n+            if (e1 == s.e1 || e1 == s.e2) { // this in included in s\n+                return s;\n+            }\n+        }\n+        // here we know that there are at least 3 distinct elements\n+        HashSet r = new HashSet(4);\n+        r.add(e1);\n+        if (e2 != null) {\n+            r.add(e2);\n+        }\n+        r.add(s.e1);\n+        if (s.e2 != null) {\n+            r.add(s.e2);\n+        }\n+        return r;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/SourceInterpreter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.AbstractInsnNode;\n+import org.mockito.asm.tree.FieldInsnNode;\n+import org.mockito.asm.tree.LdcInsnNode;\n+import org.mockito.asm.tree.MethodInsnNode;\n+\n+/**\n+ * An {@link Interpreter} for {@link SourceValue} values.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class SourceInterpreter implements Opcodes, Interpreter {\n+\n+    public Value newValue(final Type type) {\n+        return new SourceValue(type == null ? 1 : type.getSize());\n+    }\n+\n+    public Value newOperation(final AbstractInsnNode insn) {\n+        int size;\n+        switch (insn.getOpcode()) {\n+            case LCONST_0:\n+            case LCONST_1:\n+            case DCONST_0:\n+            case DCONST_1:\n+                size = 2;\n+                break;\n+            case LDC:\n+                Object cst = ((LdcInsnNode) insn).cst;\n+                size = cst instanceof Long || cst instanceof Double ? 2 : 1;\n+                break;\n+            case GETSTATIC:\n+                size = Type.getType(((FieldInsnNode) insn).desc).getSize();\n+                break;\n+            default:\n+                size = 1;\n+        }\n+        return new SourceValue(size, insn);\n+    }\n+\n+    public Value copyOperation(final AbstractInsnNode insn, final Value value) {\n+        return new SourceValue(value.getSize(), insn);\n+    }\n+\n+    public Value unaryOperation(final AbstractInsnNode insn, final Value value)\n+    {\n+        int size;\n+        switch (insn.getOpcode()) {\n+            case LNEG:\n+            case DNEG:\n+            case I2L:\n+            case I2D:\n+            case L2D:\n+            case F2L:\n+            case F2D:\n+            case D2L:\n+                size = 2;\n+                break;\n+            case GETFIELD:\n+                size = Type.getType(((FieldInsnNode) insn).desc).getSize();\n+                break;\n+            default:\n+                size = 1;\n+        }\n+        return new SourceValue(size, insn);\n+    }\n+\n+    public Value binaryOperation(\n+        final AbstractInsnNode insn,\n+        final Value value1,\n+        final Value value2)\n+    {\n+        int size;\n+        switch (insn.getOpcode()) {\n+            case LALOAD:\n+            case DALOAD:\n+            case LADD:\n+            case DADD:\n+            case LSUB:\n+            case DSUB:\n+            case LMUL:\n+            case DMUL:\n+            case LDIV:\n+            case DDIV:\n+            case LREM:\n+            case DREM:\n+            case LSHL:\n+            case LSHR:\n+            case LUSHR:\n+            case LAND:\n+            case LOR:\n+            case LXOR:\n+                size = 2;\n+                break;\n+            default:\n+                size = 1;\n+        }\n+        return new SourceValue(size, insn);\n+    }\n+\n+    public Value ternaryOperation(\n+        final AbstractInsnNode insn,\n+        final Value value1,\n+        final Value value2,\n+        final Value value3)\n+    {\n+        return new SourceValue(1, insn);\n+    }\n+\n+    public Value naryOperation(final AbstractInsnNode insn, final List values) {\n+        int size;\n+        if (insn.getOpcode() == MULTIANEWARRAY) {\n+            size = 1;\n+        } else {\n+            size = Type.getReturnType(((MethodInsnNode) insn).desc).getSize();\n+        }\n+        return new SourceValue(size, insn);\n+    }\n+\n+    public Value merge(final Value v, final Value w) {\n+        SourceValue dv = (SourceValue) v;\n+        SourceValue dw = (SourceValue) w;\n+        if (dv.insns instanceof SmallSet && dw.insns instanceof SmallSet) {\n+            Set s = ((SmallSet) dv.insns).union((SmallSet) dw.insns);\n+            if (s == dv.insns && dv.size == dw.size) {\n+                return v;\n+            } else {\n+                return new SourceValue(Math.min(dv.size, dw.size), s);\n+            }\n+        }\n+        if (dv.size != dw.size || !dv.insns.containsAll(dw.insns)) {\n+            Set s = new HashSet();\n+            s.addAll(dv.insns);\n+            s.addAll(dw.insns);\n+            return new SourceValue(Math.min(dv.size, dw.size), s);\n+        }\n+        return v;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/SourceValue.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.Set;\n+\n+import org.mockito.asm.tree.AbstractInsnNode;\n+\n+/**\n+ * A {@link Value} that is represented by its type in a two types type system.\n+ * This type system distinguishes the ONEWORD and TWOWORDS types.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class SourceValue implements Value {\n+\n+    /**\n+     * The size of this value.\n+     */\n+    public final int size;\n+\n+    /**\n+     * The instructions that can produce this value. For example, for the Java\n+     * code below, the instructions that can produce the value of <tt>i</tt>\n+     * at line 5 are the txo ISTORE instructions at line 1 and 3:\n+     * \n+     * <pre>\n+     * 1: i = 0;\n+     * 2: if (...) {\n+     * 3:   i = 1;\n+     * 4: }\n+     * 5: return i;\n+     * </pre>\n+     * \n+     * This field is a set of {@link AbstractInsnNode} objects.\n+     */\n+    public final Set insns;\n+\n+    public SourceValue(final int size) {\n+        this(size, SmallSet.EMPTY_SET);\n+    }\n+\n+    public SourceValue(final int size, final AbstractInsnNode insn) {\n+        this.size = size;\n+        this.insns = new SmallSet(insn, null);\n+    }\n+\n+    public SourceValue(final int size, final Set insns) {\n+        this.size = size;\n+        this.insns = insns;\n+    }\n+\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    public boolean equals(final Object value) {\n+        if (!(value instanceof SourceValue)) {\n+        \treturn false;\n+        }\n+        SourceValue v = (SourceValue) value;\n+        return size == v.size && insns.equals(v.insns);\n+    }\n+\n+    public int hashCode() {\n+        return insns.hashCode();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/Subroutine.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mockito.asm.tree.JumpInsnNode;\n+import org.mockito.asm.tree.LabelNode;\n+\n+/**\n+ * A method subroutine (corresponds to a JSR instruction).\n+ * \n+ * @author Eric Bruneton\n+ */\n+class Subroutine {\n+\n+    LabelNode start;\n+\n+    boolean[] access;\n+\n+    List callers;\n+\n+    private Subroutine() {\n+    }\n+\n+    Subroutine(\n+        final LabelNode start,\n+        final int maxLocals,\n+        final JumpInsnNode caller)\n+    {\n+        this.start = start;\n+        this.access = new boolean[maxLocals];\n+        this.callers = new ArrayList();\n+        callers.add(caller);\n+    }\n+\n+    public Subroutine copy() {\n+        Subroutine result = new Subroutine();\n+        result.start = start;\n+        result.access = new boolean[access.length];\n+        System.arraycopy(access, 0, result.access, 0, access.length);\n+        result.callers = new ArrayList(callers);\n+        return result;\n+    }\n+\n+    public boolean merge(final Subroutine subroutine) throws AnalyzerException {\n+        boolean changes = false;\n+        for (int i = 0; i < access.length; ++i) {\n+            if (subroutine.access[i] && !access[i]) {\n+                access[i] = true;\n+                changes = true;\n+            }\n+        }\n+        if (subroutine.start == start) {\n+            for (int i = 0; i < subroutine.callers.size(); ++i) {\n+                Object caller = subroutine.callers.get(i);\n+                if (!callers.contains(caller)) {\n+                    callers.add(caller);\n+                    changes = true;\n+                }\n+            }\n+        }\n+        return changes;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/tree/analysis/Value.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.tree.analysis;\n+\n+/**\n+ * An immutable symbolic value for semantic interpretation of bytecode.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public interface Value {\n+\n+    /**\n+     * Returns the size of this value in words.\n+     * \n+     * @return either 1 or 2.\n+     */\n+    int getSize();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/ASMifiable.java\n+/**\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import java.util.Map;\n+\n+/**\n+ * An attribute that can print the ASM code to create an equivalent attribute.\n+ * \n+ * Implementation should print the ASM code that generates attribute data\n+ * structures for current attribute state.\n+ * \n+ * @author Eugene Kuleshov\n+ */\n+public interface ASMifiable {\n+\n+    /**\n+     * Prints the ASM code to create an attribute equal to this attribute.\n+     * \n+     * @param buf A buffer used for printing Java code.\n+     * @param varName name of the variable in a printed code used to store\n+     *        attribute instance.\n+     * @param labelNames map of label instances to their names.\n+     */\n+    void asmify(StringBuffer buf, String varName, Map labelNames);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/ASMifierAbstractVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Type;\n+\n+import java.util.Map;\n+\n+/**\n+ * An abstract ASMifier visitor.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ASMifierAbstractVisitor extends AbstractVisitor {\n+\n+    /**\n+     * The name of the variable for this visitor in the produced code.\n+     */\n+    protected String name;\n+\n+    /**\n+     * The label names. This map associates String values to Label keys. It is\n+     * used only in ASMifierMethodVisitor.\n+     */\n+    Map labelNames;\n+\n+    /**\n+     * Constructs a new {@link ASMifierAbstractVisitor}.\n+     * \n+     * @param name the name of the variable for this visitor in the produced\n+     *        code.\n+     */\n+    protected ASMifierAbstractVisitor(final String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * Prints the ASM code that generates the given annotation.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values.\n+     */\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\")\n+                .append(\"av0 = \")\n+                .append(name)\n+                .append(\".visitAnnotation(\");\n+        appendConstant(desc);\n+        buf.append(\", \").append(visible).append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);\n+        text.add(av.getText());\n+        text.add(\"}\\n\");\n+        return av;\n+    }\n+\n+    /**\n+     * Prints the ASM code that generates the given attribute.\n+     * \n+     * @param attr an attribute.\n+     */\n+    public void visitAttribute(final Attribute attr) {\n+        buf.setLength(0);\n+        buf.append(\"// ATTRIBUTE \").append(attr.type).append('\\n');\n+        if (attr instanceof ASMifiable) {\n+            buf.append(\"{\\n\");\n+            ((ASMifiable) attr).asmify(buf, \"attr\", labelNames);\n+            buf.append(name).append(\".visitAttribute(attr);\\n\");\n+            buf.append(\"}\\n\");\n+        }\n+        text.add(buf.toString());\n+    }\n+\n+    /**\n+     * Prints the ASM code to end the visit.\n+     */\n+    public void visitEnd() {\n+        buf.setLength(0);\n+        buf.append(name).append(\".visitEnd();\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    /**\n+     * Appends a string representation of the given constant to the given\n+     * buffer.\n+     * \n+     * @param cst an {@link Integer}, {@link Float}, {@link Long},\n+     *        {@link Double} or {@link String} object. May be <tt>null</tt>.\n+     */\n+    void appendConstant(final Object cst) {\n+        appendConstant(buf, cst);\n+    }\n+\n+    /**\n+     * Appends a string representation of the given constant to the given\n+     * buffer.\n+     * \n+     * @param buf a string buffer.\n+     * @param cst an {@link Integer}, {@link Float}, {@link Long},\n+     *        {@link Double} or {@link String} object. May be <tt>null</tt>.\n+     */\n+    static void appendConstant(final StringBuffer buf, final Object cst) {\n+        if (cst == null) {\n+            buf.append(\"null\");\n+        } else if (cst instanceof String) {\n+            appendString(buf, (String) cst);\n+        } else if (cst instanceof Type) {\n+            buf.append(\"Type.getType(\\\"\");\n+            buf.append(((Type) cst).getDescriptor());\n+            buf.append(\"\\\")\");\n+        } else if (cst instanceof Byte) {\n+            buf.append(\"new Byte((byte)\").append(cst).append(')');\n+        } else if (cst instanceof Boolean) {\n+            buf.append(((Boolean) cst).booleanValue() ? \"Boolean.TRUE\" : \"Boolean.FALSE\");\n+        } else if (cst instanceof Short) {\n+            buf.append(\"new Short((short)\").append(cst).append(')');\n+        } else if (cst instanceof Character) {\n+            int c = ((Character) cst).charValue();\n+            buf.append(\"new Character((char)\").append(c).append(')');\n+        } else if (cst instanceof Integer) {\n+            buf.append(\"new Integer(\").append(cst).append(')');\n+        } else if (cst instanceof Float) {\n+            buf.append(\"new Float(\\\"\").append(cst).append(\"\\\")\");\n+        } else if (cst instanceof Long) {\n+            buf.append(\"new Long(\").append(cst).append(\"L)\");\n+        } else if (cst instanceof Double) {\n+            buf.append(\"new Double(\\\"\").append(cst).append(\"\\\")\");\n+        } else if (cst instanceof byte[]) {\n+            byte[] v = (byte[]) cst;\n+            buf.append(\"new byte[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(v[i]);\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof boolean[]) {\n+            boolean[] v = (boolean[]) cst;\n+            buf.append(\"new boolean[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(v[i]);\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof short[]) {\n+            short[] v = (short[]) cst;\n+            buf.append(\"new short[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(\"(short)\").append(v[i]);\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof char[]) {\n+            char[] v = (char[]) cst;\n+            buf.append(\"new char[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\")\n+                        .append(\"(char)\")\n+                        .append((int) v[i]);\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof int[]) {\n+            int[] v = (int[]) cst;\n+            buf.append(\"new int[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(v[i]);\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof long[]) {\n+            long[] v = (long[]) cst;\n+            buf.append(\"new long[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(v[i]).append('L');\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof float[]) {\n+            float[] v = (float[]) cst;\n+            buf.append(\"new float[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(v[i]).append('f');\n+            }\n+            buf.append('}');\n+        } else if (cst instanceof double[]) {\n+            double[] v = (double[]) cst;\n+            buf.append(\"new double[] {\");\n+            for (int i = 0; i < v.length; i++) {\n+                buf.append(i == 0 ? \"\" : \",\").append(v[i]).append('d');\n+            }\n+            buf.append('}');\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/ASMifierAnnotationVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+\n+/**\n+ * An {@link AnnotationVisitor} that prints the ASM code that generates the\n+ * annotations it visits.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ASMifierAnnotationVisitor extends AbstractVisitor implements\n+        AnnotationVisitor\n+{\n+\n+    /**\n+     * Identifier of the annotation visitor variable in the produced code.\n+     */\n+    protected final int id;\n+\n+    /**\n+     * Constructs a new {@link ASMifierAnnotationVisitor}.\n+     * \n+     * @param id identifier of the annotation visitor variable in the produced\n+     *        code.\n+     */\n+    public ASMifierAnnotationVisitor(final int id) {\n+        this.id = id;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the AnnotationVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(final String name, final Object value) {\n+        buf.setLength(0);\n+        buf.append(\"av\").append(id).append(\".visit(\");\n+        ASMifierAbstractVisitor.appendConstant(buf, name);\n+        buf.append(\", \");\n+        ASMifierAbstractVisitor.appendConstant(buf, value);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitEnum(\n+        final String name,\n+        final String desc,\n+        final String value)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"av\").append(id).append(\".visitEnum(\");\n+        ASMifierAbstractVisitor.appendConstant(buf, name);\n+        buf.append(\", \");\n+        ASMifierAbstractVisitor.appendConstant(buf, desc);\n+        buf.append(\", \");\n+        ASMifierAbstractVisitor.appendConstant(buf, value);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\");\n+        buf.append(\"AnnotationVisitor av\").append(id + 1).append(\" = av\");\n+        buf.append(id).append(\".visitAnnotation(\");\n+        ASMifierAbstractVisitor.appendConstant(buf, name);\n+        buf.append(\", \");\n+        ASMifierAbstractVisitor.appendConstant(buf, desc);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(id + 1);\n+        text.add(av.getText());\n+        text.add(\"}\\n\");\n+        return av;\n+    }\n+\n+    public AnnotationVisitor visitArray(final String name) {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\");\n+        buf.append(\"AnnotationVisitor av\").append(id + 1).append(\" = av\");\n+        buf.append(id).append(\".visitArray(\");\n+        ASMifierAbstractVisitor.appendConstant(buf, name);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(id + 1);\n+        text.add(av.getText());\n+        text.add(\"}\\n\");\n+        return av;\n+    }\n+\n+    public void visitEnd() {\n+        buf.setLength(0);\n+        buf.append(\"av\").append(id).append(\".visitEnd();\\n\");\n+        text.add(buf.toString());\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/ASMifierClassVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import java.io.FileInputStream;\n+import java.io.PrintWriter;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.FieldVisitor;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+/**\n+ * A {@link ClassVisitor} that prints the ASM code that generates the classes it\n+ * visits. This class visitor can be used to quickly write ASM code to generate\n+ * some given bytecode: <ul> <li>write the Java source code equivalent to the\n+ * bytecode you want to generate;</li> <li>compile it with <tt>javac</tt>;</li>\n+ * <li>make a {@link ASMifierClassVisitor} visit this compiled class (see the\n+ * {@link #main main} method);</li> <li>edit the generated source code, if\n+ * necessary.</li> </ul> The source code printed when visiting the\n+ * <tt>Hello</tt> class is the following: <p> <blockquote>\n+ * \n+ * <pre>\n+ * import org.mockito.asm.*;\n+ *\n+ * public class HelloDump implements Opcodes {\n+ *\n+ *     public static byte[] dump() throws Exception {\n+ *\n+ *         ClassWriter cw = new ClassWriter(0);\n+ *         FieldVisitor fv;\n+ *         MethodVisitor mv;\n+ *         AnnotationVisitor av0;\n+ *\n+ *         cw.visit(49,\n+ *                 ACC_PUBLIC + ACC_SUPER,\n+ *                 &quot;Hello&quot;,\n+ *                 null,\n+ *                 &quot;java/lang/Object&quot;,\n+ *                 null);\n+ *\n+ *         cw.visitSource(&quot;Hello.java&quot;, null);\n+ *\n+ *         {\n+ *             mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);\n+ *             mv.visitVarInsn(ALOAD, 0);\n+ *             mv.visitMethodInsn(INVOKESPECIAL,\n+ *                     &quot;java/lang/Object&quot;,\n+ *                     &quot;&lt;init&gt;&quot;,\n+ *                     &quot;()V&quot;);\n+ *             mv.visitInsn(RETURN);\n+ *             mv.visitMaxs(1, 1);\n+ *             mv.visitEnd();\n+ *         }\n+ *         {\n+ *             mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,\n+ *                     &quot;main&quot;,\n+ *                     &quot;([Ljava/lang/String;)V&quot;,\n+ *                     null,\n+ *                     null);\n+ *             mv.visitFieldInsn(GETSTATIC,\n+ *                     &quot;java/lang/System&quot;,\n+ *                     &quot;out&quot;,\n+ *                     &quot;Ljava/io/PrintStream;&quot;);\n+ *             mv.visitLdcInsn(&quot;hello&quot;);\n+ *             mv.visitMethodInsn(INVOKEVIRTUAL,\n+ *                     &quot;java/io/PrintStream&quot;,\n+ *                     &quot;println&quot;,\n+ *                     &quot;(Ljava/lang/String;)V&quot;);\n+ *             mv.visitInsn(RETURN);\n+ *             mv.visitMaxs(2, 1);\n+ *             mv.visitEnd();\n+ *         }\n+ *         cw.visitEnd();\n+ *\n+ *         return cw.toByteArray();\n+ *     }\n+ * }\n+ *\n+ * </pre>\n+ * \n+ * </blockquote> where <tt>Hello</tt> is defined by: <p> <blockquote>\n+ * \n+ * <pre>\n+ * public class Hello {\n+ *\n+ *     public static void main(String[] args) {\n+ *         System.out.println(&quot;hello&quot;);\n+ *     }\n+ * }\n+ * </pre>\n+ * \n+ * </blockquote>\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public class ASMifierClassVisitor extends ASMifierAbstractVisitor implements\n+        ClassVisitor\n+{\n+\n+    /**\n+     * Pseudo access flag used to distinguish class access flags.\n+     */\n+    private static final int ACCESS_CLASS = 262144;\n+\n+    /**\n+     * Pseudo access flag used to distinguish field access flags.\n+     */\n+    private static final int ACCESS_FIELD = 524288;\n+\n+    /**\n+     * Pseudo access flag used to distinguish inner class flags.\n+     */\n+    private static final int ACCESS_INNER = 1048576;\n+\n+    /**\n+     * The print writer to be used to print the class.\n+     */\n+    protected final PrintWriter pw;\n+\n+    /**\n+     * Prints the ASM source code to generate the given class to the standard\n+     * output. <p> Usage: ASMifierClassVisitor [-debug] &lt;fully qualified\n+     * class name or class file name&gt;\n+     * \n+     * @param args the command line arguments.\n+     * \n+     * @throws Exception if the class cannot be found, or if an IO exception\n+     *         occurs.\n+     */\n+    public static void main(final String[] args) throws Exception {\n+        int i = 0;\n+        int flags = ClassReader.SKIP_DEBUG;\n+\n+        boolean ok = true;\n+        if (args.length < 1 || args.length > 2) {\n+            ok = false;\n+        }\n+        if (ok && \"-debug\".equals(args[0])) {\n+            i = 1;\n+            flags = 0;\n+            if (args.length != 2) {\n+                ok = false;\n+            }\n+        }\n+        if (!ok) {\n+            System.err.println(\"Prints the ASM code to generate the given class.\");\n+            System.err.println(\"Usage: ASMifierClassVisitor [-debug] \"\n+                    + \"<fully qualified class name or class file name>\");\n+            return;\n+        }\n+        ClassReader cr;\n+        if (args[i].endsWith(\".class\") || args[i].indexOf('\\\\') > -1\n+                || args[i].indexOf('/') > -1)\n+        {\n+            cr = new ClassReader(new FileInputStream(args[i]));\n+        } else {\n+            cr = new ClassReader(args[i]);\n+        }\n+        cr.accept(new ASMifierClassVisitor(new PrintWriter(System.out)),\n+                getDefaultAttributes(),\n+                flags);\n+    }\n+\n+    /**\n+     * Constructs a new {@link ASMifierClassVisitor} object.\n+     * \n+     * @param pw the print writer to be used to print the class.\n+     */\n+    public ASMifierClassVisitor(final PrintWriter pw) {\n+        super(\"cw\");\n+        this.pw = pw;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the ClassVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(\n+        final int version,\n+        final int access,\n+        final String name,\n+        final String signature,\n+        final String superName,\n+        final String[] interfaces)\n+    {\n+        String simpleName;\n+        int n = name.lastIndexOf('/');\n+        if (n == -1) {\n+            simpleName = name;\n+        } else {\n+            text.add(\"package asm.\" + name.substring(0, n).replace('/', '.')\n+                    + \";\\n\");\n+            simpleName = name.substring(n + 1);\n+        }\n+        text.add(\"import java.util.*;\\n\");\n+        text.add(\"import org.mockito.asm.*;\\n\");\n+        text.add(\"import org.mockito.asm.attrs.*;\\n\");\n+        text.add(\"public class \" + simpleName + \"Dump implements Opcodes {\\n\\n\");\n+        text.add(\"public static byte[] dump () throws Exception {\\n\\n\");\n+        text.add(\"ClassWriter cw = new ClassWriter(0);\\n\");\n+        text.add(\"FieldVisitor fv;\\n\");\n+        text.add(\"MethodVisitor mv;\\n\");\n+        text.add(\"AnnotationVisitor av0;\\n\\n\");\n+\n+        buf.setLength(0);\n+        buf.append(\"cw.visit(\");\n+        switch (version) {\n+            case Opcodes.V1_1:\n+                buf.append(\"V1_1\");\n+                break;\n+            case Opcodes.V1_2:\n+                buf.append(\"V1_2\");\n+                break;\n+            case Opcodes.V1_3:\n+                buf.append(\"V1_3\");\n+                break;\n+            case Opcodes.V1_4:\n+                buf.append(\"V1_4\");\n+                break;\n+            case Opcodes.V1_5:\n+                buf.append(\"V1_5\");\n+                break;\n+            case Opcodes.V1_6:\n+                buf.append(\"V1_6\");\n+                break;\n+            default:\n+                buf.append(version);\n+                break;\n+        }\n+        buf.append(\", \");\n+        appendAccess(access | ACCESS_CLASS);\n+        buf.append(\", \");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(signature);\n+        buf.append(\", \");\n+        appendConstant(superName);\n+        buf.append(\", \");\n+        if (interfaces != null && interfaces.length > 0) {\n+            buf.append(\"new String[] {\");\n+            for (int i = 0; i < interfaces.length; ++i) {\n+                buf.append(i == 0 ? \" \" : \", \");\n+                appendConstant(interfaces[i]);\n+            }\n+            buf.append(\" }\");\n+        } else {\n+            buf.append(\"null\");\n+        }\n+        buf.append(\");\\n\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitSource(final String file, final String debug) {\n+        buf.setLength(0);\n+        buf.append(\"cw.visitSource(\");\n+        appendConstant(file);\n+        buf.append(\", \");\n+        appendConstant(debug);\n+        buf.append(\");\\n\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitOuterClass(\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"cw.visitOuterClass(\");\n+        appendConstant(owner);\n+        buf.append(\", \");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(desc);\n+        buf.append(\");\\n\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitInnerClass(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"cw.visitInnerClass(\");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(outerName);\n+        buf.append(\", \");\n+        appendConstant(innerName);\n+        buf.append(\", \");\n+        appendAccess(access | ACCESS_INNER);\n+        buf.append(\");\\n\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public FieldVisitor visitField(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\");\n+        buf.append(\"fv = cw.visitField(\");\n+        appendAccess(access | ACCESS_FIELD);\n+        buf.append(\", \");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(desc);\n+        buf.append(\", \");\n+        appendConstant(signature);\n+        buf.append(\", \");\n+        appendConstant(value);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierFieldVisitor aav = new ASMifierFieldVisitor();\n+        text.add(aav.getText());\n+        text.add(\"}\\n\");\n+        return aav;\n+    }\n+\n+    public MethodVisitor visitMethod(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\");\n+        buf.append(\"mv = cw.visitMethod(\");\n+        appendAccess(access);\n+        buf.append(\", \");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(desc);\n+        buf.append(\", \");\n+        appendConstant(signature);\n+        buf.append(\", \");\n+        if (exceptions != null && exceptions.length > 0) {\n+            buf.append(\"new String[] {\");\n+            for (int i = 0; i < exceptions.length; ++i) {\n+                buf.append(i == 0 ? \" \" : \", \");\n+                appendConstant(exceptions[i]);\n+            }\n+            buf.append(\" }\");\n+        } else {\n+            buf.append(\"null\");\n+        }\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierMethodVisitor acv = createASMifierMethodVisitor();\n+        text.add(acv.getText());\n+        text.add(\"}\\n\");\n+        return acv;\n+    }\n+\n+    protected ASMifierMethodVisitor createASMifierMethodVisitor() {\n+        return new ASMifierMethodVisitor();\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\");\n+        buf.append(\"av0 = cw.visitAnnotation(\");\n+        appendConstant(desc);\n+        buf.append(\", \");\n+        buf.append(visible);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);\n+        text.add(av.getText());\n+        text.add(\"}\\n\");\n+        return av;\n+    }\n+\n+    public void visitEnd() {\n+        text.add(\"cw.visitEnd();\\n\\n\");\n+        text.add(\"return cw.toByteArray();\\n\");\n+        text.add(\"}\\n\");\n+        text.add(\"}\\n\");\n+        printList(pw, text);\n+        pw.flush();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Appends a string representation of the given access modifiers to {@link\n+     * #buf buf}.\n+     * \n+     * @param access some access modifiers.\n+     */\n+    void appendAccess(final int access) {\n+        boolean first = true;\n+        if ((access & Opcodes.ACC_PUBLIC) != 0) {\n+            buf.append(\"ACC_PUBLIC\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_PRIVATE) != 0) {\n+            buf.append(\"ACC_PRIVATE\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_PROTECTED) != 0) {\n+            buf.append(\"ACC_PROTECTED\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_FINAL) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_FINAL\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_STATIC) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_STATIC\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            if ((access & ACCESS_CLASS) == 0) {\n+                buf.append(\"ACC_SYNCHRONIZED\");\n+            } else {\n+                buf.append(\"ACC_SUPER\");\n+            }\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_VOLATILE) != 0\n+                && (access & ACCESS_FIELD) != 0)\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_VOLATILE\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_BRIDGE) != 0 && (access & ACCESS_CLASS) == 0\n+                && (access & ACCESS_FIELD) == 0)\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_BRIDGE\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_VARARGS) != 0 && (access & ACCESS_CLASS) == 0\n+                && (access & ACCESS_FIELD) == 0)\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_VARARGS\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_TRANSIENT) != 0\n+                && (access & ACCESS_FIELD) != 0)\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_TRANSIENT\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_NATIVE) != 0 && (access & ACCESS_CLASS) == 0\n+                && (access & ACCESS_FIELD) == 0)\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_NATIVE\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_ENUM) != 0\n+                && ((access & ACCESS_CLASS) != 0\n+                        || (access & ACCESS_FIELD) != 0 || (access & ACCESS_INNER) != 0))\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_ENUM\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_ANNOTATION) != 0\n+                && (access & ACCESS_CLASS) != 0)\n+        {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_ANNOTATION\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_ABSTRACT) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_ABSTRACT\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_INTERFACE) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_INTERFACE\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_STRICT) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_STRICT\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_SYNTHETIC) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_SYNTHETIC\");\n+            first = false;\n+        }\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            if (!first) {\n+                buf.append(\" + \");\n+            }\n+            buf.append(\"ACC_DEPRECATED\");\n+            first = false;\n+        }\n+        if (first) {\n+            buf.append('0');\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/ASMifierFieldVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.FieldVisitor;\n+\n+/**\n+ * A {@link FieldVisitor} that prints the ASM code that generates the fields it\n+ * visits.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class ASMifierFieldVisitor extends ASMifierAbstractVisitor implements\n+        FieldVisitor\n+{\n+\n+    /**\n+     * Constructs a new {@link ASMifierFieldVisitor}.\n+     */\n+    public ASMifierFieldVisitor() {\n+        super(\"fv\");\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/ASMifierMethodVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+\n+import java.util.HashMap;\n+\n+/**\n+ * A {@link MethodVisitor} that prints the ASM code that generates the methods\n+ * it visits.\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public class ASMifierMethodVisitor extends ASMifierAbstractVisitor implements\n+        MethodVisitor\n+{\n+\n+    /**\n+     * Constructs a new {@link ASMifierMethodVisitor} object.\n+     */\n+    public ASMifierMethodVisitor() {\n+        super(\"mv\");\n+        this.labelNames = new HashMap();\n+    }\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\").append(\"av0 = mv.visitAnnotationDefault();\\n\");\n+        text.add(buf.toString());\n+        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);\n+        text.add(av.getText());\n+        text.add(\"}\\n\");\n+        return av;\n+    }\n+\n+    public AnnotationVisitor visitParameterAnnotation(\n+        final int parameter,\n+        final String desc,\n+        final boolean visible)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"{\\n\")\n+                .append(\"av0 = mv.visitParameterAnnotation(\")\n+                .append(parameter)\n+                .append(\", \");\n+        appendConstant(desc);\n+        buf.append(\", \").append(visible).append(\");\\n\");\n+        text.add(buf.toString());\n+        ASMifierAnnotationVisitor av = new ASMifierAnnotationVisitor(0);\n+        text.add(av.getText());\n+        text.add(\"}\\n\");\n+        return av;\n+    }\n+\n+    public void visitCode() {\n+        text.add(\"mv.visitCode();\\n\");\n+    }\n+\n+    public void visitFrame(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        buf.setLength(0);\n+        switch (type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                declareFrameTypes(nLocal, local);\n+                declareFrameTypes(nStack, stack);\n+                if (type == Opcodes.F_NEW) {\n+                    buf.append(\"mv.visitFrame(Opcodes.F_NEW, \");\n+                } else {\n+                    buf.append(\"mv.visitFrame(Opcodes.F_FULL, \");\n+                }\n+                buf.append(nLocal).append(\", new Object[] {\");\n+                appendFrameTypes(nLocal, local);\n+                buf.append(\"}, \").append(nStack).append(\", new Object[] {\");\n+                appendFrameTypes(nStack, stack);\n+                buf.append('}');\n+                break;\n+            case Opcodes.F_APPEND:\n+                declareFrameTypes(nLocal, local);\n+                buf.append(\"mv.visitFrame(Opcodes.F_APPEND,\")\n+                        .append(nLocal)\n+                        .append(\", new Object[] {\");\n+                appendFrameTypes(nLocal, local);\n+                buf.append(\"}, 0, null\");\n+                break;\n+            case Opcodes.F_CHOP:\n+                buf.append(\"mv.visitFrame(Opcodes.F_CHOP,\")\n+                        .append(nLocal)\n+                        .append(\", null, 0, null\");\n+                break;\n+            case Opcodes.F_SAME:\n+                buf.append(\"mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null\");\n+                break;\n+            case Opcodes.F_SAME1:\n+                declareFrameTypes(1, stack);\n+                buf.append(\"mv.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[] {\");\n+                appendFrameTypes(1, stack);\n+                buf.append('}');\n+                break;\n+        }\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitInsn(final int opcode) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitInsn(\").append(OPCODES[opcode]).append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitIntInsn(\")\n+                .append(OPCODES[opcode])\n+                .append(\", \")\n+                .append(opcode == Opcodes.NEWARRAY\n+                        ? TYPES[operand]\n+                        : Integer.toString(operand))\n+                .append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitVarInsn(\")\n+                .append(OPCODES[opcode])\n+                .append(\", \")\n+                .append(var)\n+                .append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitTypeInsn(\").append(OPCODES[opcode]).append(\", \");\n+        appendConstant(type);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitFieldInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitFieldInsn(\").append(OPCODES[opcode]).append(\", \");\n+        appendConstant(owner);\n+        buf.append(\", \");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(desc);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitMethodInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitMethodInsn(\").append(OPCODES[opcode]).append(\", \");\n+        appendConstant(owner);\n+        buf.append(\", \");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(desc);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        buf.setLength(0);\n+        declareLabel(label);\n+        buf.append(\"mv.visitJumpInsn(\").append(OPCODES[opcode]).append(\", \");\n+        appendLabel(label);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        buf.setLength(0);\n+        declareLabel(label);\n+        buf.append(\"mv.visitLabel(\");\n+        appendLabel(label);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitLdcInsn(\");\n+        appendConstant(cst);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitIincInsn(\")\n+                .append(var)\n+                .append(\", \")\n+                .append(increment)\n+                .append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitTableSwitchInsn(\n+        final int min,\n+        final int max,\n+        final Label dflt,\n+        final Label[] labels)\n+    {\n+        buf.setLength(0);\n+        for (int i = 0; i < labels.length; ++i) {\n+            declareLabel(labels[i]);\n+        }\n+        declareLabel(dflt);\n+\n+        buf.append(\"mv.visitTableSwitchInsn(\")\n+                .append(min)\n+                .append(\", \")\n+                .append(max)\n+                .append(\", \");\n+        appendLabel(dflt);\n+        buf.append(\", new Label[] {\");\n+        for (int i = 0; i < labels.length; ++i) {\n+            buf.append(i == 0 ? \" \" : \", \");\n+            appendLabel(labels[i]);\n+        }\n+        buf.append(\" });\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitLookupSwitchInsn(\n+        final Label dflt,\n+        final int[] keys,\n+        final Label[] labels)\n+    {\n+        buf.setLength(0);\n+        for (int i = 0; i < labels.length; ++i) {\n+            declareLabel(labels[i]);\n+        }\n+        declareLabel(dflt);\n+\n+        buf.append(\"mv.visitLookupSwitchInsn(\");\n+        appendLabel(dflt);\n+        buf.append(\", new int[] {\");\n+        for (int i = 0; i < keys.length; ++i) {\n+            buf.append(i == 0 ? \" \" : \", \").append(keys[i]);\n+        }\n+        buf.append(\" }, new Label[] {\");\n+        for (int i = 0; i < labels.length; ++i) {\n+            buf.append(i == 0 ? \" \" : \", \");\n+            appendLabel(labels[i]);\n+        }\n+        buf.append(\" });\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitMultiANewArrayInsn(\");\n+        appendConstant(desc);\n+        buf.append(\", \").append(dims).append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitTryCatchBlock(\n+        final Label start,\n+        final Label end,\n+        final Label handler,\n+        final String type)\n+    {\n+        buf.setLength(0);\n+        declareLabel(start);\n+        declareLabel(end);\n+        declareLabel(handler);\n+        buf.append(\"mv.visitTryCatchBlock(\");\n+        appendLabel(start);\n+        buf.append(\", \");\n+        appendLabel(end);\n+        buf.append(\", \");\n+        appendLabel(handler);\n+        buf.append(\", \");\n+        appendConstant(type);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitLocalVariable(\");\n+        appendConstant(name);\n+        buf.append(\", \");\n+        appendConstant(desc);\n+        buf.append(\", \");\n+        appendConstant(signature);\n+        buf.append(\", \");\n+        appendLabel(start);\n+        buf.append(\", \");\n+        appendLabel(end);\n+        buf.append(\", \").append(index).append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitLineNumber(final int line, final Label start) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitLineNumber(\").append(line).append(\", \");\n+        appendLabel(start);\n+        buf.append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        buf.setLength(0);\n+        buf.append(\"mv.visitMaxs(\")\n+                .append(maxStack)\n+                .append(\", \")\n+                .append(maxLocals)\n+                .append(\");\\n\");\n+        text.add(buf.toString());\n+    }\n+\n+    private void declareFrameTypes(final int n, final Object[] o) {\n+        for (int i = 0; i < n; ++i) {\n+            if (o[i] instanceof Label) {\n+                declareLabel((Label) o[i]);\n+            }\n+        }\n+    }\n+\n+    private void appendFrameTypes(final int n, final Object[] o) {\n+        for (int i = 0; i < n; ++i) {\n+            if (i > 0) {\n+                buf.append(\", \");\n+            }\n+            if (o[i] instanceof String) {\n+                appendConstant(o[i]);\n+            } else if (o[i] instanceof Integer) {\n+                switch (((Integer) o[i]).intValue()) {\n+                    case 0:\n+                        buf.append(\"Opcodes.TOP\");\n+                        break;\n+                    case 1:\n+                        buf.append(\"Opcodes.INTEGER\");\n+                        break;\n+                    case 2:\n+                        buf.append(\"Opcodes.FLOAT\");\n+                        break;\n+                    case 3:\n+                        buf.append(\"Opcodes.DOUBLE\");\n+                        break;\n+                    case 4:\n+                        buf.append(\"Opcodes.LONG\");\n+                        break;\n+                    case 5:\n+                        buf.append(\"Opcodes.NULL\");\n+                        break;\n+                    case 6:\n+                        buf.append(\"Opcodes.UNINITIALIZED_THIS\");\n+                        break;\n+                }\n+            } else {\n+                appendLabel((Label) o[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Appends a declaration of the given label to {@link #buf buf}. This\n+     * declaration is of the form \"Label lXXX = new Label();\". Does nothing if\n+     * the given label has already been declared.\n+     * \n+     * @param l a label.\n+     */\n+    private void declareLabel(final Label l) {\n+        String name = (String) labelNames.get(l);\n+        if (name == null) {\n+            name = \"l\" + labelNames.size();\n+            labelNames.put(l, name);\n+            buf.append(\"Label \").append(name).append(\" = new Label();\\n\");\n+        }\n+    }\n+\n+    /**\n+     * Appends the name of the given label to {@link #buf buf}. The given label\n+     * <i>must</i> already have a name. One way to ensure this is to always\n+     * call {@link #declareLabel declared} before calling this method.\n+     * \n+     * @param l a label.\n+     */\n+    private void appendLabel(final Label l) {\n+        buf.append((String) labelNames.get(l));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/AbstractVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.mockito.asm.Attribute;\n+\n+/**\n+ * An abstract visitor.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public abstract class AbstractVisitor {\n+\n+    /**\n+     * The names of the Java Virtual Machine opcodes.\n+     */\n+    public static final String[] OPCODES;\n+    /**\n+     * Types for <code>operand</code> parameter of the\n+     * {@link org.mockito.asm.MethodVisitor#visitIntInsn} method when\n+     * <code>opcode</code> is <code>NEWARRAY</code>.\n+     */\n+    public static final String[] TYPES;\n+\n+    static {\n+        String s = \"NOP,ACONST_NULL,ICONST_M1,ICONST_0,ICONST_1,ICONST_2,\"\n+                + \"ICONST_3,ICONST_4,ICONST_5,LCONST_0,LCONST_1,FCONST_0,\"\n+                + \"FCONST_1,FCONST_2,DCONST_0,DCONST_1,BIPUSH,SIPUSH,LDC,,,\"\n+                + \"ILOAD,LLOAD,FLOAD,DLOAD,ALOAD,,,,,,,,,,,,,,,,,,,,,IALOAD,\"\n+                + \"LALOAD,FALOAD,DALOAD,AALOAD,BALOAD,CALOAD,SALOAD,ISTORE,\"\n+                + \"LSTORE,FSTORE,DSTORE,ASTORE,,,,,,,,,,,,,,,,,,,,,IASTORE,\"\n+                + \"LASTORE,FASTORE,DASTORE,AASTORE,BASTORE,CASTORE,SASTORE,POP,\"\n+                + \"POP2,DUP,DUP_X1,DUP_X2,DUP2,DUP2_X1,DUP2_X2,SWAP,IADD,LADD,\"\n+                + \"FADD,DADD,ISUB,LSUB,FSUB,DSUB,IMUL,LMUL,FMUL,DMUL,IDIV,LDIV,\"\n+                + \"FDIV,DDIV,IREM,LREM,FREM,DREM,INEG,LNEG,FNEG,DNEG,ISHL,LSHL,\"\n+                + \"ISHR,LSHR,IUSHR,LUSHR,IAND,LAND,IOR,LOR,IXOR,LXOR,IINC,I2L,\"\n+                + \"I2F,I2D,L2I,L2F,L2D,F2I,F2L,F2D,D2I,D2L,D2F,I2B,I2C,I2S,LCMP,\"\n+                + \"FCMPL,FCMPG,DCMPL,DCMPG,IFEQ,IFNE,IFLT,IFGE,IFGT,IFLE,\"\n+                + \"IF_ICMPEQ,IF_ICMPNE,IF_ICMPLT,IF_ICMPGE,IF_ICMPGT,IF_ICMPLE,\"\n+                + \"IF_ACMPEQ,IF_ACMPNE,GOTO,JSR,RET,TABLESWITCH,LOOKUPSWITCH,\"\n+                + \"IRETURN,LRETURN,FRETURN,DRETURN,ARETURN,RETURN,GETSTATIC,\"\n+                + \"PUTSTATIC,GETFIELD,PUTFIELD,INVOKEVIRTUAL,INVOKESPECIAL,\"\n+                + \"INVOKESTATIC,INVOKEINTERFACE,,NEW,NEWARRAY,ANEWARRAY,\"\n+                + \"ARRAYLENGTH,ATHROW,CHECKCAST,INSTANCEOF,MONITORENTER,\"\n+                + \"MONITOREXIT,,MULTIANEWARRAY,IFNULL,IFNONNULL,\";\n+        OPCODES = new String[200];\n+        int i = 0;\n+        int j = 0;\n+        int l;\n+        while ((l = s.indexOf(',', j)) > 0) {\n+            OPCODES[i++] = j + 1 == l ? null : s.substring(j, l);\n+            j = l + 1;\n+        }\n+\n+        s = \"T_BOOLEAN,T_CHAR,T_FLOAT,T_DOUBLE,T_BYTE,T_SHORT,T_INT,T_LONG,\";\n+        TYPES = new String[12];\n+        j = 0;\n+        i = 4;\n+        while ((l = s.indexOf(',', j)) > 0) {\n+            TYPES[i++] = s.substring(j, l);\n+            j = l + 1;\n+        }\n+    }\n+\n+    /**\n+     * The text to be printed. Since the code of methods is not necessarily\n+     * visited in sequential order, one method after the other, but can be\n+     * interlaced (some instructions from method one, then some instructions\n+     * from method two, then some instructions from method one again...), it is\n+     * not possible to print the visited instructions directly to a sequential\n+     * stream. A class is therefore printed in a two steps process: a string\n+     * tree is constructed during the visit, and printed to a sequential stream\n+     * at the end of the visit. This string tree is stored in this field, as a\n+     * string list that can contain other string lists, which can themselves\n+     * contain other string lists, and so on.\n+     */\n+    public final List text;\n+\n+    /**\n+     * A buffer that can be used to create strings.\n+     */\n+    protected final StringBuffer buf;\n+\n+    /**\n+     * Constructs a new {@link AbstractVisitor}.\n+     */\n+    protected AbstractVisitor() {\n+        this.text = new ArrayList();\n+        this.buf = new StringBuffer();\n+    }\n+\n+    /**\n+     * Returns the text constructed by this visitor.\n+     * \n+     * @return the text constructed by this visitor.\n+     */\n+    public List getText() {\n+        return text;\n+    }\n+\n+    /**\n+     * Prints the text constructed by this visitor.\n+     * \n+     * @param pw the print writer to be used.\n+     */\n+    public void print(final PrintWriter pw) {\n+        printList(pw, text);\n+    }\n+    \n+    /**\n+     * Appends a quoted string to a given buffer.\n+     * \n+     * @param buf the buffer where the string must be added.\n+     * @param s the string to be added.\n+     */\n+    public static void appendString(final StringBuffer buf, final String s) {\n+        buf.append('\\\"');\n+        for (int i = 0; i < s.length(); ++i) {\n+            char c = s.charAt(i);\n+            if (c == '\\n') {\n+                buf.append(\"\\\\n\");\n+            } else if (c == '\\r') {\n+                buf.append(\"\\\\r\");\n+            } else if (c == '\\\\') {\n+                buf.append(\"\\\\\\\\\");\n+            } else if (c == '\"') {\n+                buf.append(\"\\\\\\\"\");\n+            } else if (c < 0x20 || c > 0x7f) {\n+                buf.append(\"\\\\u\");\n+                if (c < 0x10) {\n+                    buf.append(\"000\");\n+                } else if (c < 0x100) {\n+                    buf.append(\"00\");\n+                } else if (c < 0x1000) {\n+                    buf.append('0');\n+                }\n+                buf.append(Integer.toString(c, 16));\n+            } else {\n+                buf.append(c);\n+            }\n+        }\n+        buf.append('\\\"');\n+    }\n+\n+    /**\n+     * Prints the given string tree.\n+     * \n+     * @param pw the writer to be used to print the tree.\n+     * @param l a string tree, i.e., a string list that can contain other string\n+     *        lists, and so on recursively.\n+     */\n+    static void printList(final PrintWriter pw, final List l) {\n+        for (int i = 0; i < l.size(); ++i) {\n+            Object o = l.get(i);\n+            if (o instanceof List) {\n+                printList(pw, (List) o);\n+            } else {\n+                pw.print(o.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the default {@link ASMifiable} prototypes.\n+     * \n+     * @return the default {@link ASMifiable} prototypes.\n+     */\n+    public static Attribute[] getDefaultAttributes() {\n+        return new Attribute[0];\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/CheckAnnotationAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Type;\n+\n+/**\n+ * An {@link AnnotationVisitor} that checks that its methods are properly used.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class CheckAnnotationAdapter implements AnnotationVisitor {\n+\n+    private final AnnotationVisitor av;\n+\n+    private final boolean named;\n+\n+    private boolean end;\n+\n+    public CheckAnnotationAdapter(final AnnotationVisitor av) {\n+        this(av, true);\n+    }\n+\n+    CheckAnnotationAdapter(final AnnotationVisitor av, final boolean named) {\n+        this.av = av;\n+        this.named = named;\n+    }\n+\n+    public void visit(final String name, final Object value) {\n+        checkEnd();\n+        checkName(name);\n+        if (!(value instanceof Byte || value instanceof Boolean\n+                || value instanceof Character || value instanceof Short\n+                || value instanceof Integer || value instanceof Long\n+                || value instanceof Float || value instanceof Double\n+                || value instanceof String || value instanceof Type\n+                || value instanceof byte[] || value instanceof boolean[]\n+                || value instanceof char[] || value instanceof short[]\n+                || value instanceof int[] || value instanceof long[]\n+                || value instanceof float[] || value instanceof double[]))\n+        {\n+            throw new IllegalArgumentException(\"Invalid annotation value\");\n+        }\n+        if (av != null) {\n+            av.visit(name, value);\n+        }\n+    }\n+\n+    public void visitEnum(\n+        final String name,\n+        final String desc,\n+        final String value)\n+    {\n+        checkEnd();\n+        checkName(name);\n+        CheckMethodAdapter.checkDesc(desc, false);\n+        if (value == null) {\n+            throw new IllegalArgumentException(\"Invalid enum value\");\n+        }\n+        if (av != null) {\n+            av.visitEnum(name, desc, value);\n+        }\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String name,\n+        final String desc)\n+    {\n+        checkEnd();\n+        checkName(name);\n+        CheckMethodAdapter.checkDesc(desc, false);\n+        return new CheckAnnotationAdapter(av == null\n+                ? null\n+                : av.visitAnnotation(name, desc));\n+    }\n+\n+    public AnnotationVisitor visitArray(final String name) {\n+        checkEnd();\n+        checkName(name);\n+        return new CheckAnnotationAdapter(av == null\n+                ? null\n+                : av.visitArray(name), false);\n+    }\n+\n+    public void visitEnd() {\n+        checkEnd();\n+        end = true;\n+        if (av != null) {\n+            av.visitEnd();\n+        }\n+    }\n+\n+    private void checkEnd() {\n+        if (end) {\n+            throw new IllegalStateException(\"Cannot call a visit method after visitEnd has been called\");\n+        }\n+    }\n+\n+    private void checkName(final String name) {\n+        if (named && name == null) {\n+            throw new IllegalArgumentException(\"Annotation value name must not be null\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/CheckClassAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import java.io.FileInputStream;\n+import java.io.PrintWriter;\n+import java.util.List;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassAdapter;\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.FieldVisitor;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+import org.mockito.asm.tree.ClassNode;\n+import org.mockito.asm.tree.MethodNode;\n+import org.mockito.asm.tree.TryCatchBlockNode;\n+import org.mockito.asm.tree.analysis.Analyzer;\n+import org.mockito.asm.tree.analysis.Frame;\n+import org.mockito.asm.tree.analysis.SimpleVerifier;\n+\n+/**\n+ * A {@link ClassAdapter} that checks that its methods are properly used. More\n+ * precisely this class adapter checks each method call individually, based\n+ * <i>only</i> on its arguments, but does <i>not</i> check the <i>sequence</i>\n+ * of method calls. For example, the invalid sequence\n+ * <tt>visitField(ACC_PUBLIC, \"i\", \"I\", null)</tt> <tt>visitField(ACC_PUBLIC,\n+ * \"i\", \"D\", null)</tt>\n+ * will <i>not</i> be detected by this class adapter.\n+ * \n+ * <p><code>CheckClassAdapter</code> can be also used to verify bytecode\n+ * transformations in order to make sure transformed bytecode is sane. For\n+ * example:\n+ * \n+ * <pre>\n+ *   InputStream is = ...; // get bytes for the source class\n+ *   ClassReader cr = new ClassReader(is);\n+ *   ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);\n+ *   ClassVisitor cv = new <b>MyClassAdapter</b>(new CheckClassAdapter(cw));\n+ *   cr.accept(cv, 0);\n+ * \n+ *   StringWriter sw = new StringWriter();\n+ *   PrintWriter pw = new PrintWriter(sw);\n+ *   CheckClassAdapter.verify(new ClassReader(cw.toByteArray()), false, pw);\n+ *   assertTrue(sw.toString(), sw.toString().length()==0);\n+ * </pre>\n+ * \n+ * Above code runs transformed bytecode trough the\n+ * <code>CheckClassAdapter</code>. It won't be exactly the same verification\n+ * as JVM does, but it run data flow analysis for the code of each method and\n+ * checks that expectations are met for each method instruction.\n+ * \n+ * <p>If method bytecode has errors, assertion text will show the erroneous\n+ * instruction number and dump of the failed method with information about\n+ * locals and stack slot for each instruction. For example (format is -\n+ * insnNumber locals : stack):\n+ * \n+ * <pre>\n+ * org.mockito.asm.tree.analysis.AnalyzerException: Error at instruction 71: Expected I, but found .\n+ *   at org.mockito.asm.tree.analysis.Analyzer.analyze(Analyzer.java:289)\n+ *   at org.mockito.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:135)\n+ * ...\n+ * remove()V\n+ * 00000 LinkedBlockingQueue$Itr . . . . . . . .  :\n+ *   ICONST_0\n+ * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I\n+ *   ISTORE 2\n+ * 00001 LinkedBlockingQueue$Itr <b>.</b> I . . . . . .  :\n+ * ...\n+ * \n+ * 00071 LinkedBlockingQueue$Itr <b>.</b> I . . . . . .  : \n+ *   ILOAD 1\n+ * 00072 <b>?</b>                \n+ *   INVOKESPECIAL java/lang/Integer.<init> (I)V\n+ * ...\n+ * </pre>\n+ * \n+ * In the above output you can see that variable 1 loaded by\n+ * <code>ILOAD 1</code> instruction at position <code>00071</code> is not\n+ * initialized. You can also see that at the beginning of the method (code\n+ * inserted by the transformation) variable 2 is initialized.\n+ * \n+ * <p>Note that when used like that, <code>CheckClassAdapter.verify()</code>\n+ * can trigger additional class loading, because it is using\n+ * <code>SimpleVerifier</code>.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class CheckClassAdapter extends ClassAdapter {\n+\n+    /**\n+     * <tt>true</tt> if the visit method has been called.\n+     */\n+    private boolean start;\n+\n+    /**\n+     * <tt>true</tt> if the visitSource method has been called.\n+     */\n+    private boolean source;\n+\n+    /**\n+     * <tt>true</tt> if the visitOuterClass method has been called.\n+     */\n+    private boolean outer;\n+\n+    /**\n+     * <tt>true</tt> if the visitEnd method has been called.\n+     */\n+    private boolean end;\n+\n+    /**\n+     * Checks a given class. <p> Usage: CheckClassAdapter &lt;fully qualified\n+     * class name or class file name&gt;\n+     * \n+     * @param args the command line arguments.\n+     * \n+     * @throws Exception if the class cannot be found, or if an IO exception\n+     *         occurs.\n+     */\n+    public static void main(final String[] args) throws Exception {\n+        if (args.length != 1) {\n+            System.err.println(\"Verifies the given class.\");\n+            System.err.println(\"Usage: CheckClassAdapter \"\n+                    + \"<fully qualified class name or class file name>\");\n+            return;\n+        }\n+        ClassReader cr;\n+        if (args[0].endsWith(\".class\")) {\n+            cr = new ClassReader(new FileInputStream(args[0]));\n+        } else {\n+            cr = new ClassReader(args[0]);\n+        }\n+\n+        verify(cr, false, new PrintWriter(System.err));\n+    }\n+\n+    /**\n+     * Checks a given class\n+     * \n+     * @param cr a <code>ClassReader</code> that contains bytecode for the\n+     *        analysis.\n+     * @param dump true if bytecode should be printed out not only when errors\n+     *        are found.\n+     * @param pw write where results going to be printed\n+     */\n+    public static void verify(\n+        final ClassReader cr,\n+        final boolean dump,\n+        final PrintWriter pw)\n+    {\n+        ClassNode cn = new ClassNode();\n+        cr.accept(new CheckClassAdapter(cn), ClassReader.SKIP_DEBUG);\n+\n+        Type syperType = cn.superName == null\n+                ? null\n+                : Type.getObjectType(cn.superName);\n+        List methods = cn.methods;\n+        for (int i = 0; i < methods.size(); ++i) {\n+            MethodNode method = (MethodNode) methods.get(i);\n+            Analyzer a = new Analyzer(new SimpleVerifier(Type.getObjectType(cn.name),\n+                    syperType,\n+                    false));\n+            try {\n+                a.analyze(cn.name, method);\n+                if (!dump) {\n+                    continue;\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace(pw);\n+            }\n+            Frame[] frames = a.getFrames();\n+\n+            TraceMethodVisitor mv = new TraceMethodVisitor();\n+\n+            pw.println(method.name + method.desc);\n+            for (int j = 0; j < method.instructions.size(); ++j) {\n+                method.instructions.get(j).accept(mv);\n+\n+                StringBuffer s = new StringBuffer();\n+                Frame f = frames[j];\n+                if (f == null) {\n+                    s.append('?');\n+                } else {\n+                    for (int k = 0; k < f.getLocals(); ++k) {\n+                        s.append(getShortName(f.getLocal(k).toString()))\n+                                .append(' ');\n+                    }\n+                    s.append(\" : \");\n+                    for (int k = 0; k < f.getStackSize(); ++k) {\n+                        s.append(getShortName(f.getStack(k).toString()))\n+                                .append(' ');\n+                    }\n+                }\n+                while (s.length() < method.maxStack + method.maxLocals + 1) {\n+                    s.append(' ');\n+                }\n+                pw.print(Integer.toString(j + 100000).substring(1));\n+                pw.print(\" \" + s + \" : \" + mv.buf); // mv.text.get(j));\n+            }\n+            for (int j = 0; j < method.tryCatchBlocks.size(); ++j) {\n+                ((TryCatchBlockNode) method.tryCatchBlocks.get(j)).accept(mv);\n+                pw.print(\" \" + mv.buf);\n+            }\n+            pw.println();\n+        }\n+        pw.flush();\n+    }\n+\n+    private static String getShortName(final String name) {\n+        int n = name.lastIndexOf('/');\n+        int k = name.length();\n+        if (name.charAt(k - 1) == ';') {\n+            k--;\n+        }\n+        return n == -1 ? name : name.substring(n + 1, k);\n+    }\n+\n+    /**\n+     * Constructs a new {@link CheckClassAdapter}.\n+     * \n+     * @param cv the class visitor to which this adapter must delegate calls.\n+     */\n+    public CheckClassAdapter(final ClassVisitor cv) {\n+        super(cv);\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the ClassVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(\n+        final int version,\n+        final int access,\n+        final String name,\n+        final String signature,\n+        final String superName,\n+        final String[] interfaces)\n+    {\n+        if (start) {\n+            throw new IllegalStateException(\"visit must be called only once\");\n+        }\n+        start = true;\n+        checkState();\n+        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL\n+                + Opcodes.ACC_SUPER + Opcodes.ACC_INTERFACE\n+                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC\n+                + Opcodes.ACC_ANNOTATION + Opcodes.ACC_ENUM\n+                + Opcodes.ACC_DEPRECATED);\n+        if (name == null || !name.endsWith(\"package-info\")) {\n+            CheckMethodAdapter.checkInternalName(name, \"class name\");\n+        }\n+        if (\"java/lang/Object\".equals(name)) {\n+            if (superName != null) {\n+                throw new IllegalArgumentException(\"The super class name of the Object class must be 'null'\");\n+            }\n+        } else {\n+            CheckMethodAdapter.checkInternalName(superName, \"super class name\");\n+        }\n+        if (signature != null) {\n+            CheckMethodAdapter.checkClassSignature(signature);\n+        }\n+        if ((access & Opcodes.ACC_INTERFACE) != 0) {\n+            if (!\"java/lang/Object\".equals(superName)) {\n+                throw new IllegalArgumentException(\"The super class name of interfaces must be 'java/lang/Object'\");\n+            }\n+        }\n+        if (interfaces != null) {\n+            for (int i = 0; i < interfaces.length; ++i) {\n+                CheckMethodAdapter.checkInternalName(interfaces[i],\n+                        \"interface name at index \" + i);\n+            }\n+        }\n+        cv.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    public void visitSource(final String file, final String debug) {\n+        checkState();\n+        if (source) {\n+            throw new IllegalStateException(\"visitSource can be called only once.\");\n+        }\n+        source = true;\n+        cv.visitSource(file, debug);\n+    }\n+\n+    public void visitOuterClass(\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        checkState();\n+        if (outer) {\n+            throw new IllegalStateException(\"visitOuterClass can be called only once.\");\n+        }\n+        outer = true;\n+        if (owner == null) {\n+            throw new IllegalArgumentException(\"Illegal outer class owner\");\n+        }\n+        if (desc != null) {\n+            CheckMethodAdapter.checkMethodDesc(desc);\n+        }\n+        cv.visitOuterClass(owner, name, desc);\n+    }\n+\n+    public void visitInnerClass(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        checkState();\n+        CheckMethodAdapter.checkInternalName(name, \"class name\");\n+        if (outerName != null) {\n+            CheckMethodAdapter.checkInternalName(outerName, \"outer class name\");\n+        }\n+        if (innerName != null) {\n+            CheckMethodAdapter.checkIdentifier(innerName, \"inner class name\");\n+        }\n+        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE\n+                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC\n+                + Opcodes.ACC_FINAL + Opcodes.ACC_INTERFACE\n+                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_SYNTHETIC\n+                + Opcodes.ACC_ANNOTATION + Opcodes.ACC_ENUM);\n+        cv.visitInnerClass(name, outerName, innerName, access);\n+    }\n+\n+    public FieldVisitor visitField(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        checkState();\n+        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE\n+                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC\n+                + Opcodes.ACC_FINAL + Opcodes.ACC_VOLATILE\n+                + Opcodes.ACC_TRANSIENT + Opcodes.ACC_SYNTHETIC\n+                + Opcodes.ACC_ENUM + Opcodes.ACC_DEPRECATED);\n+        CheckMethodAdapter.checkIdentifier(name, \"field name\");\n+        CheckMethodAdapter.checkDesc(desc, false);\n+        if (signature != null) {\n+            CheckMethodAdapter.checkFieldSignature(signature);\n+        }\n+        if (value != null) {\n+            CheckMethodAdapter.checkConstant(value);\n+        }\n+        FieldVisitor av = cv.visitField(access, name, desc, signature, value);\n+        return new CheckFieldAdapter(av);\n+    }\n+\n+    public MethodVisitor visitMethod(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        checkState();\n+        checkAccess(access, Opcodes.ACC_PUBLIC + Opcodes.ACC_PRIVATE\n+                + Opcodes.ACC_PROTECTED + Opcodes.ACC_STATIC\n+                + Opcodes.ACC_FINAL + Opcodes.ACC_SYNCHRONIZED\n+                + Opcodes.ACC_BRIDGE + Opcodes.ACC_VARARGS + Opcodes.ACC_NATIVE\n+                + Opcodes.ACC_ABSTRACT + Opcodes.ACC_STRICT\n+                + Opcodes.ACC_SYNTHETIC + Opcodes.ACC_DEPRECATED);\n+        CheckMethodAdapter.checkMethodIdentifier(name, \"method name\");\n+        CheckMethodAdapter.checkMethodDesc(desc);\n+        if (signature != null) {\n+            CheckMethodAdapter.checkMethodSignature(signature);\n+        }\n+        if (exceptions != null) {\n+            for (int i = 0; i < exceptions.length; ++i) {\n+                CheckMethodAdapter.checkInternalName(exceptions[i],\n+                        \"exception name at index \" + i);\n+            }\n+        }\n+        return new CheckMethodAdapter(cv.visitMethod(access,\n+                name,\n+                desc,\n+                signature,\n+                exceptions));\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        checkState();\n+        CheckMethodAdapter.checkDesc(desc, false);\n+        return new CheckAnnotationAdapter(cv.visitAnnotation(desc, visible));\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        checkState();\n+        if (attr == null) {\n+            throw new IllegalArgumentException(\"Invalid attribute (must not be null)\");\n+        }\n+        cv.visitAttribute(attr);\n+    }\n+\n+    public void visitEnd() {\n+        checkState();\n+        end = true;\n+        cv.visitEnd();\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Checks that the visit method has been called and that visitEnd has not\n+     * been called.\n+     */\n+    private void checkState() {\n+        if (!start) {\n+            throw new IllegalStateException(\"Cannot visit member before visit has been called.\");\n+        }\n+        if (end) {\n+            throw new IllegalStateException(\"Cannot visit member after visitEnd has been called.\");\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given access flags do not contain invalid flags. This\n+     * method also checks that mutually incompatible flags are not set\n+     * simultaneously.\n+     * \n+     * @param access the access flags to be checked\n+     * @param possibleAccess the valid access flags.\n+     */\n+    static void checkAccess(final int access, final int possibleAccess) {\n+        if ((access & ~possibleAccess) != 0) {\n+            throw new IllegalArgumentException(\"Invalid access flags: \"\n+                    + access);\n+        }\n+        int pub = (access & Opcodes.ACC_PUBLIC) == 0 ? 0 : 1;\n+        int pri = (access & Opcodes.ACC_PRIVATE) == 0 ? 0 : 1;\n+        int pro = (access & Opcodes.ACC_PROTECTED) == 0 ? 0 : 1;\n+        if (pub + pri + pro > 1) {\n+            throw new IllegalArgumentException(\"public private and protected are mutually exclusive: \"\n+                    + access);\n+        }\n+        int fin = (access & Opcodes.ACC_FINAL) == 0 ? 0 : 1;\n+        int abs = (access & Opcodes.ACC_ABSTRACT) == 0 ? 0 : 1;\n+        if (fin + abs > 1) {\n+            throw new IllegalArgumentException(\"final and abstract are mutually exclusive: \"\n+                    + access);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/CheckFieldAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.FieldVisitor;\n+\n+/**\n+ * A {@link FieldVisitor} that checks that its methods are properly used.\n+ */\n+public class CheckFieldAdapter implements FieldVisitor {\n+\n+    private final FieldVisitor fv;\n+\n+    private boolean end;\n+\n+    public CheckFieldAdapter(final FieldVisitor fv) {\n+        this.fv = fv;\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        checkEnd();\n+        CheckMethodAdapter.checkDesc(desc, false);\n+        return new CheckAnnotationAdapter(fv.visitAnnotation(desc, visible));\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        checkEnd();\n+        if (attr == null) {\n+            throw new IllegalArgumentException(\"Invalid attribute (must not be null)\");\n+        }\n+        fv.visitAttribute(attr);\n+    }\n+\n+    public void visitEnd() {\n+        checkEnd();\n+        end = true;\n+        fv.visitEnd();\n+    }\n+\n+    private void checkEnd() {\n+        if (end) {\n+            throw new IllegalStateException(\"Cannot call a visit method after visitEnd has been called\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/CheckMethodAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodAdapter;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * A {@link MethodAdapter} that checks that its methods are properly used. More\n+ * precisely this code adapter checks each instruction individually (i.e., each\n+ * visit method checks some preconditions based <i>only</i> on its arguments -\n+ * such as the fact that the given opcode is correct for a given visit method),\n+ * but does <i>not</i> check the <i>sequence</i> of instructions. For example,\n+ * in a method whose signature is <tt>void m ()</tt>, the invalid instruction\n+ * IRETURN, or the invalid sequence IADD L2I will <i>not</i> be detected by\n+ * this code adapter.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class CheckMethodAdapter extends MethodAdapter {\n+\n+    /**\n+     * <tt>true</tt> if the visitCode method has been called.\n+     */\n+    private boolean startCode;\n+\n+    /**\n+     * <tt>true</tt> if the visitMaxs method has been called.\n+     */\n+    private boolean endCode;\n+\n+    /**\n+     * <tt>true</tt> if the visitEnd method has been called.\n+     */\n+    private boolean endMethod;\n+\n+    /**\n+     * The already visited labels. This map associate Integer values to Label\n+     * keys.\n+     */\n+    private final Map labels;\n+\n+    /**\n+     * Code of the visit method to be used for each opcode.\n+     */\n+    private static final int[] TYPE;\n+\n+    static {\n+        String s = \"BBBBBBBBBBBBBBBBCCIAADDDDDAAAAAAAAAAAAAAAAAAAABBBBBBBBDD\"\n+                + \"DDDAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\"\n+                + \"BBBBBBBBBBBBBBBBBBBJBBBBBBBBBBBBBBBBBBBBHHHHHHHHHHHHHHHHD\"\n+                + \"KLBBBBBBFFFFGGGGAECEBBEEBBAMHHAA\";\n+        TYPE = new int[s.length()];\n+        for (int i = 0; i < TYPE.length; ++i) {\n+            TYPE[i] = s.charAt(i) - 'A' - 1;\n+        }\n+    }\n+\n+    // code to generate the above string\n+    // public static void main (String[] args) {\n+    // int[] TYPE = new int[] {\n+    // 0, //NOP\n+    // 0, //ACONST_NULL\n+    // 0, //ICONST_M1\n+    // 0, //ICONST_0\n+    // 0, //ICONST_1\n+    // 0, //ICONST_2\n+    // 0, //ICONST_3\n+    // 0, //ICONST_4\n+    // 0, //ICONST_5\n+    // 0, //LCONST_0\n+    // 0, //LCONST_1\n+    // 0, //FCONST_0\n+    // 0, //FCONST_1\n+    // 0, //FCONST_2\n+    // 0, //DCONST_0\n+    // 0, //DCONST_1\n+    // 1, //BIPUSH\n+    // 1, //SIPUSH\n+    // 7, //LDC\n+    // -1, //LDC_W\n+    // -1, //LDC2_W\n+    // 2, //ILOAD\n+    // 2, //LLOAD\n+    // 2, //FLOAD\n+    // 2, //DLOAD\n+    // 2, //ALOAD\n+    // -1, //ILOAD_0\n+    // -1, //ILOAD_1\n+    // -1, //ILOAD_2\n+    // -1, //ILOAD_3\n+    // -1, //LLOAD_0\n+    // -1, //LLOAD_1\n+    // -1, //LLOAD_2\n+    // -1, //LLOAD_3\n+    // -1, //FLOAD_0\n+    // -1, //FLOAD_1\n+    // -1, //FLOAD_2\n+    // -1, //FLOAD_3\n+    // -1, //DLOAD_0\n+    // -1, //DLOAD_1\n+    // -1, //DLOAD_2\n+    // -1, //DLOAD_3\n+    // -1, //ALOAD_0\n+    // -1, //ALOAD_1\n+    // -1, //ALOAD_2\n+    // -1, //ALOAD_3\n+    // 0, //IALOAD\n+    // 0, //LALOAD\n+    // 0, //FALOAD\n+    // 0, //DALOAD\n+    // 0, //AALOAD\n+    // 0, //BALOAD\n+    // 0, //CALOAD\n+    // 0, //SALOAD\n+    // 2, //ISTORE\n+    // 2, //LSTORE\n+    // 2, //FSTORE\n+    // 2, //DSTORE\n+    // 2, //ASTORE\n+    // -1, //ISTORE_0\n+    // -1, //ISTORE_1\n+    // -1, //ISTORE_2\n+    // -1, //ISTORE_3\n+    // -1, //LSTORE_0\n+    // -1, //LSTORE_1\n+    // -1, //LSTORE_2\n+    // -1, //LSTORE_3\n+    // -1, //FSTORE_0\n+    // -1, //FSTORE_1\n+    // -1, //FSTORE_2\n+    // -1, //FSTORE_3\n+    // -1, //DSTORE_0\n+    // -1, //DSTORE_1\n+    // -1, //DSTORE_2\n+    // -1, //DSTORE_3\n+    // -1, //ASTORE_0\n+    // -1, //ASTORE_1\n+    // -1, //ASTORE_2\n+    // -1, //ASTORE_3\n+    // 0, //IASTORE\n+    // 0, //LASTORE\n+    // 0, //FASTORE\n+    // 0, //DASTORE\n+    // 0, //AASTORE\n+    // 0, //BASTORE\n+    // 0, //CASTORE\n+    // 0, //SASTORE\n+    // 0, //POP\n+    // 0, //POP2\n+    // 0, //DUP\n+    // 0, //DUP_X1\n+    // 0, //DUP_X2\n+    // 0, //DUP2\n+    // 0, //DUP2_X1\n+    // 0, //DUP2_X2\n+    // 0, //SWAP\n+    // 0, //IADD\n+    // 0, //LADD\n+    // 0, //FADD\n+    // 0, //DADD\n+    // 0, //ISUB\n+    // 0, //LSUB\n+    // 0, //FSUB\n+    // 0, //DSUB\n+    // 0, //IMUL\n+    // 0, //LMUL\n+    // 0, //FMUL\n+    // 0, //DMUL\n+    // 0, //IDIV\n+    // 0, //LDIV\n+    // 0, //FDIV\n+    // 0, //DDIV\n+    // 0, //IREM\n+    // 0, //LREM\n+    // 0, //FREM\n+    // 0, //DREM\n+    // 0, //INEG\n+    // 0, //LNEG\n+    // 0, //FNEG\n+    // 0, //DNEG\n+    // 0, //ISHL\n+    // 0, //LSHL\n+    // 0, //ISHR\n+    // 0, //LSHR\n+    // 0, //IUSHR\n+    // 0, //LUSHR\n+    // 0, //IAND\n+    // 0, //LAND\n+    // 0, //IOR\n+    // 0, //LOR\n+    // 0, //IXOR\n+    // 0, //LXOR\n+    // 8, //IINC\n+    // 0, //I2L\n+    // 0, //I2F\n+    // 0, //I2D\n+    // 0, //L2I\n+    // 0, //L2F\n+    // 0, //L2D\n+    // 0, //F2I\n+    // 0, //F2L\n+    // 0, //F2D\n+    // 0, //D2I\n+    // 0, //D2L\n+    // 0, //D2F\n+    // 0, //I2B\n+    // 0, //I2C\n+    // 0, //I2S\n+    // 0, //LCMP\n+    // 0, //FCMPL\n+    // 0, //FCMPG\n+    // 0, //DCMPL\n+    // 0, //DCMPG\n+    // 6, //IFEQ\n+    // 6, //IFNE\n+    // 6, //IFLT\n+    // 6, //IFGE\n+    // 6, //IFGT\n+    // 6, //IFLE\n+    // 6, //IF_ICMPEQ\n+    // 6, //IF_ICMPNE\n+    // 6, //IF_ICMPLT\n+    // 6, //IF_ICMPGE\n+    // 6, //IF_ICMPGT\n+    // 6, //IF_ICMPLE\n+    // 6, //IF_ACMPEQ\n+    // 6, //IF_ACMPNE\n+    // 6, //GOTO\n+    // 6, //JSR\n+    // 2, //RET\n+    // 9, //TABLESWITCH\n+    // 10, //LOOKUPSWITCH\n+    // 0, //IRETURN\n+    // 0, //LRETURN\n+    // 0, //FRETURN\n+    // 0, //DRETURN\n+    // 0, //ARETURN\n+    // 0, //RETURN\n+    // 4, //GETSTATIC\n+    // 4, //PUTSTATIC\n+    // 4, //GETFIELD\n+    // 4, //PUTFIELD\n+    // 5, //INVOKEVIRTUAL\n+    // 5, //INVOKESPECIAL\n+    // 5, //INVOKESTATIC\n+    // 5, //INVOKEINTERFACE\n+    // -1, //UNUSED\n+    // 3, //NEW\n+    // 1, //NEWARRAY\n+    // 3, //ANEWARRAY\n+    // 0, //ARRAYLENGTH\n+    // 0, //ATHROW\n+    // 3, //CHECKCAST\n+    // 3, //INSTANCEOF\n+    // 0, //MONITORENTER\n+    // 0, //MONITOREXIT\n+    // -1, //WIDE\n+    // 11, //MULTIANEWARRAY\n+    // 6, //IFNULL\n+    // 6, //IFNONNULL\n+    // -1, //GOTO_W\n+    // -1 //JSR_W\n+    // };\n+    // for (int i = 0; i < TYPE.length; ++i) {\n+    // System.out.print((char)(TYPE[i] + 1 + 'A'));\n+    // }\n+    // System.out.println();\n+    // }\n+\n+    /**\n+     * Constructs a new {@link CheckMethodAdapter} object.\n+     * \n+     * @param cv the code visitor to which this adapter must delegate calls.\n+     */\n+    public CheckMethodAdapter(final MethodVisitor cv) {\n+        super(cv);\n+        this.labels = new HashMap();\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        checkEndMethod();\n+        checkDesc(desc, false);\n+        return new CheckAnnotationAdapter(mv.visitAnnotation(desc, visible));\n+    }\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        checkEndMethod();\n+        return new CheckAnnotationAdapter(mv.visitAnnotationDefault(), false);\n+    }\n+\n+    public AnnotationVisitor visitParameterAnnotation(\n+        final int parameter,\n+        final String desc,\n+        final boolean visible)\n+    {\n+        checkEndMethod();\n+        checkDesc(desc, false);\n+        return new CheckAnnotationAdapter(mv.visitParameterAnnotation(parameter,\n+                desc,\n+                visible));\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        checkEndMethod();\n+        if (attr == null) {\n+            throw new IllegalArgumentException(\"Invalid attribute (must not be null)\");\n+        }\n+        mv.visitAttribute(attr);\n+    }\n+\n+    public void visitCode() {\n+        startCode = true;\n+        mv.visitCode();\n+    }\n+\n+    public void visitFrame(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        int mLocal;\n+        int mStack;\n+        switch (type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                mLocal = Integer.MAX_VALUE;\n+                mStack = Integer.MAX_VALUE;\n+                break;\n+\n+            case Opcodes.F_SAME:\n+                mLocal = 0;\n+                mStack = 0;\n+                break;\n+\n+            case Opcodes.F_SAME1:\n+                mLocal = 0;\n+                mStack = 1;\n+                break;\n+\n+            case Opcodes.F_APPEND:\n+            case Opcodes.F_CHOP:\n+                mLocal = 3;\n+                mStack = 0;\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Invalid frame type \" + type);\n+        }\n+\n+        if (nLocal > mLocal) {\n+            throw new IllegalArgumentException(\"Invalid nLocal=\" + nLocal\n+                    + \" for frame type \" + type);\n+        }\n+        if (nStack > mStack) {\n+            throw new IllegalArgumentException(\"Invalid nStack=\" + nStack\n+                    + \" for frame type \" + type);\n+        }\n+\n+        if (type != Opcodes.F_CHOP) {\n+            if (nLocal > 0 && (local == null || local.length < nLocal)) {\n+                throw new IllegalArgumentException(\"Array local[] is shorter than nLocal\");\n+            }\n+            for (int i = 0; i < nLocal; ++i) {\n+                checkFrameValue(local[i]);\n+            }\n+        }\n+        if (nStack > 0 && (stack == null || stack.length < nStack)) {\n+            throw new IllegalArgumentException(\"Array stack[] is shorter than nStack\");\n+        }\n+        for (int i = 0; i < nStack; ++i) {\n+            checkFrameValue(stack[i]);\n+        }\n+\n+        mv.visitFrame(type, nLocal, local, nStack, stack);\n+    }\n+\n+    public void visitInsn(final int opcode) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 0);\n+        mv.visitInsn(opcode);\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 1);\n+        switch (opcode) {\n+            case Opcodes.BIPUSH:\n+                checkSignedByte(operand, \"Invalid operand\");\n+                break;\n+            case Opcodes.SIPUSH:\n+                checkSignedShort(operand, \"Invalid operand\");\n+                break;\n+            // case Constants.NEWARRAY:\n+            default:\n+                if (operand < Opcodes.T_BOOLEAN || operand > Opcodes.T_LONG) {\n+                    throw new IllegalArgumentException(\"Invalid operand (must be an array type code T_...): \"\n+                            + operand);\n+                }\n+        }\n+        mv.visitIntInsn(opcode, operand);\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 2);\n+        checkUnsignedShort(var, \"Invalid variable index\");\n+        mv.visitVarInsn(opcode, var);\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 3);\n+        checkInternalName(type, \"type\");\n+        if (opcode == Opcodes.NEW && type.charAt(0) == '[') {\n+            throw new IllegalArgumentException(\"NEW cannot be used to create arrays: \"\n+                    + type);\n+        }\n+        mv.visitTypeInsn(opcode, type);\n+    }\n+\n+    public void visitFieldInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 4);\n+        checkInternalName(owner, \"owner\");\n+        checkIdentifier(name, \"name\");\n+        checkDesc(desc, false);\n+        mv.visitFieldInsn(opcode, owner, name, desc);\n+    }\n+\n+    public void visitMethodInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 5);\n+        checkMethodIdentifier(name, \"name\");\n+        checkInternalName(owner, \"owner\");\n+        checkMethodDesc(desc);\n+        mv.visitMethodInsn(opcode, owner, name, desc);\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkOpcode(opcode, 6);\n+        checkLabel(label, false, \"label\");\n+        mv.visitJumpInsn(opcode, label);\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkLabel(label, false, \"label\");\n+        if (labels.get(label) != null) {\n+            throw new IllegalArgumentException(\"Already visited label\");\n+        }\n+        labels.put(label, new Integer(labels.size()));\n+        mv.visitLabel(label);\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        checkStartCode();\n+        checkEndCode();\n+        if (!(cst instanceof Type)) {\n+            checkConstant(cst);\n+        }\n+        mv.visitLdcInsn(cst);\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkUnsignedShort(var, \"Invalid variable index\");\n+        checkSignedShort(increment, \"Invalid increment\");\n+        mv.visitIincInsn(var, increment);\n+    }\n+\n+    public void visitTableSwitchInsn(\n+        final int min,\n+        final int max,\n+        final Label dflt,\n+        final Label[] labels)\n+    {\n+        checkStartCode();\n+        checkEndCode();\n+        if (max < min) {\n+            throw new IllegalArgumentException(\"Max = \" + max\n+                    + \" must be greater than or equal to min = \" + min);\n+        }\n+        checkLabel(dflt, false, \"default label\");\n+        if (labels == null || labels.length != max - min + 1) {\n+            throw new IllegalArgumentException(\"There must be max - min + 1 labels\");\n+        }\n+        for (int i = 0; i < labels.length; ++i) {\n+            checkLabel(labels[i], false, \"label at index \" + i);\n+        }\n+        mv.visitTableSwitchInsn(min, max, dflt, labels);\n+    }\n+\n+    public void visitLookupSwitchInsn(\n+        final Label dflt,\n+        final int[] keys,\n+        final Label[] labels)\n+    {\n+        checkEndCode();\n+        checkStartCode();\n+        checkLabel(dflt, false, \"default label\");\n+        if (keys == null || labels == null || keys.length != labels.length) {\n+            throw new IllegalArgumentException(\"There must be the same number of keys and labels\");\n+        }\n+        for (int i = 0; i < labels.length; ++i) {\n+            checkLabel(labels[i], false, \"label at index \" + i);\n+        }\n+        mv.visitLookupSwitchInsn(dflt, keys, labels);\n+    }\n+\n+    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkDesc(desc, false);\n+        if (desc.charAt(0) != '[') {\n+            throw new IllegalArgumentException(\"Invalid descriptor (must be an array type descriptor): \"\n+                    + desc);\n+        }\n+        if (dims < 1) {\n+            throw new IllegalArgumentException(\"Invalid dimensions (must be greater than 0): \"\n+                    + dims);\n+        }\n+        if (dims > desc.lastIndexOf('[') + 1) {\n+            throw new IllegalArgumentException(\"Invalid dimensions (must not be greater than dims(desc)): \"\n+                    + dims);\n+        }\n+        mv.visitMultiANewArrayInsn(desc, dims);\n+    }\n+\n+    public void visitTryCatchBlock(\n+        final Label start,\n+        final Label end,\n+        final Label handler,\n+        final String type)\n+    {\n+        checkStartCode();\n+        checkEndCode();\n+        if (type != null) {\n+            checkInternalName(type, \"type\");\n+        }\n+        mv.visitTryCatchBlock(start, end, handler, type);\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        checkStartCode();\n+        checkEndCode();\n+        checkIdentifier(name, \"name\");\n+        checkDesc(desc, false);\n+        checkLabel(start, true, \"start label\");\n+        checkLabel(end, true, \"end label\");\n+        checkUnsignedShort(index, \"Invalid variable index\");\n+        int s = ((Integer) labels.get(start)).intValue();\n+        int e = ((Integer) labels.get(end)).intValue();\n+        if (e < s) {\n+            throw new IllegalArgumentException(\"Invalid start and end labels (end must be greater than start)\");\n+        }\n+        mv.visitLocalVariable(name, desc, signature, start, end, index);\n+    }\n+\n+    public void visitLineNumber(final int line, final Label start) {\n+        checkStartCode();\n+        checkEndCode();\n+        checkUnsignedShort(line, \"Invalid line number\");\n+        checkLabel(start, true, \"start label\");\n+        mv.visitLineNumber(line, start);\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        checkStartCode();\n+        checkEndCode();\n+        endCode = true;\n+        checkUnsignedShort(maxStack, \"Invalid max stack\");\n+        checkUnsignedShort(maxLocals, \"Invalid max locals\");\n+        mv.visitMaxs(maxStack, maxLocals);\n+    }\n+\n+    public void visitEnd() {\n+        checkEndMethod();\n+        endMethod = true;\n+        mv.visitEnd();\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Checks that the visitCode method has been called.\n+     */\n+    void checkStartCode() {\n+        if (!startCode) {\n+            throw new IllegalStateException(\"Cannot visit instructions before visitCode has been called.\");\n+        }\n+    }\n+\n+    /**\n+     * Checks that the visitMaxs method has not been called.\n+     */\n+    void checkEndCode() {\n+        if (endCode) {\n+            throw new IllegalStateException(\"Cannot visit instructions after visitMaxs has been called.\");\n+        }\n+    }\n+\n+    /**\n+     * Checks that the visitEnd method has not been called.\n+     */\n+    void checkEndMethod() {\n+        if (endMethod) {\n+            throw new IllegalStateException(\"Cannot visit elements after visitEnd has been called.\");\n+        }\n+    }\n+\n+    /**\n+     * Checks a stack frame value.\n+     * \n+     * @param value the value to be checked.\n+     */\n+    static void checkFrameValue(final Object value) {\n+        if (value == Opcodes.TOP || value == Opcodes.INTEGER\n+                || value == Opcodes.FLOAT || value == Opcodes.LONG\n+                || value == Opcodes.DOUBLE || value == Opcodes.NULL\n+                || value == Opcodes.UNINITIALIZED_THIS)\n+        {\n+            return;\n+        }\n+        if (value instanceof String) {\n+            checkInternalName((String) value, \"Invalid stack frame value\");\n+            return;\n+        }\n+        if (!(value instanceof Label)) {\n+            throw new IllegalArgumentException(\"Invalid stack frame value: \"\n+                    + value);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the type of the given opcode is equal to the given type.\n+     * \n+     * @param opcode the opcode to be checked.\n+     * @param type the expected opcode type.\n+     */\n+    static void checkOpcode(final int opcode, final int type) {\n+        if (opcode < 0 || opcode > 199 || TYPE[opcode] != type) {\n+            throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given value is a signed byte.\n+     * \n+     * @param value the value to be checked.\n+     * @param msg an message to be used in case of error.\n+     */\n+    static void checkSignedByte(final int value, final String msg) {\n+        if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n+            throw new IllegalArgumentException(msg\n+                    + \" (must be a signed byte): \" + value);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given value is a signed short.\n+     * \n+     * @param value the value to be checked.\n+     * @param msg an message to be used in case of error.\n+     */\n+    static void checkSignedShort(final int value, final String msg) {\n+        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n+            throw new IllegalArgumentException(msg\n+                    + \" (must be a signed short): \" + value);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given value is an unsigned short.\n+     * \n+     * @param value the value to be checked.\n+     * @param msg an message to be used in case of error.\n+     */\n+    static void checkUnsignedShort(final int value, final String msg) {\n+        if (value < 0 || value > 65535) {\n+            throw new IllegalArgumentException(msg\n+                    + \" (must be an unsigned short): \" + value);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given value is an {@link Integer}, a{@link Float}, a\n+     * {@link Long}, a {@link Double} or a {@link String}.\n+     * \n+     * @param cst the value to be checked.\n+     */\n+    static void checkConstant(final Object cst) {\n+        if (!(cst instanceof Integer) && !(cst instanceof Float)\n+                && !(cst instanceof Long) && !(cst instanceof Double)\n+                && !(cst instanceof String))\n+        {\n+            throw new IllegalArgumentException(\"Invalid constant: \" + cst);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given string is a valid Java identifier.\n+     * \n+     * @param name the string to be checked.\n+     * @param msg a message to be used in case of error.\n+     */\n+    static void checkIdentifier(final String name, final String msg) {\n+        checkIdentifier(name, 0, -1, msg);\n+    }\n+\n+    /**\n+     * Checks that the given substring is a valid Java identifier.\n+     * \n+     * @param name the string to be checked.\n+     * @param start index of the first character of the identifier (inclusive).\n+     * @param end index of the last character of the identifier (exclusive). -1\n+     *        is equivalent to <tt>name.length()</tt> if name is not\n+     *        <tt>null</tt>.\n+     * @param msg a message to be used in case of error.\n+     */\n+    static void checkIdentifier(\n+        final String name,\n+        final int start,\n+        final int end,\n+        final String msg)\n+    {\n+        if (name == null || (end == -1 ? name.length() <= start : end <= start))\n+        {\n+            throw new IllegalArgumentException(\"Invalid \" + msg\n+                    + \" (must not be null or empty)\");\n+        }\n+        if (!Character.isJavaIdentifierStart(name.charAt(start))) {\n+            throw new IllegalArgumentException(\"Invalid \" + msg\n+                    + \" (must be a valid Java identifier): \" + name);\n+        }\n+        int max = end == -1 ? name.length() : end;\n+        for (int i = start + 1; i < max; ++i) {\n+            if (!Character.isJavaIdentifierPart(name.charAt(i))) {\n+                throw new IllegalArgumentException(\"Invalid \" + msg\n+                        + \" (must be a valid Java identifier): \" + name);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given string is a valid Java identifier or is equal to\n+     * '&lt;init&gt;' or '&lt;clinit&gt;'.\n+     * \n+     * @param name the string to be checked.\n+     * @param msg a message to be used in case of error.\n+     */\n+    static void checkMethodIdentifier(final String name, final String msg) {\n+        if (name == null || name.length() == 0) {\n+            throw new IllegalArgumentException(\"Invalid \" + msg\n+                    + \" (must not be null or empty)\");\n+        }\n+        if (\"<init>\".equals(name) || \"<clinit>\".equals(name)) {\n+            return;\n+        }\n+        if (!Character.isJavaIdentifierStart(name.charAt(0))) {\n+            throw new IllegalArgumentException(\"Invalid \"\n+                    + msg\n+                    + \" (must be a '<init>', '<clinit>' or a valid Java identifier): \"\n+                    + name);\n+        }\n+        for (int i = 1; i < name.length(); ++i) {\n+            if (!Character.isJavaIdentifierPart(name.charAt(i))) {\n+                throw new IllegalArgumentException(\"Invalid \"\n+                        + msg\n+                        + \" (must be '<init>' or '<clinit>' or a valid Java identifier): \"\n+                        + name);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given string is a valid internal class name.\n+     * \n+     * @param name the string to be checked.\n+     * @param msg a message to be used in case of error.\n+     */\n+    static void checkInternalName(final String name, final String msg) {\n+        if (name == null || name.length() == 0) {\n+            throw new IllegalArgumentException(\"Invalid \" + msg\n+                    + \" (must not be null or empty)\");\n+        }\n+        if (name.charAt(0) == '[') {\n+            checkDesc(name, false);\n+        } else {\n+            checkInternalName(name, 0, -1, msg);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given substring is a valid internal class name.\n+     * \n+     * @param name the string to be checked.\n+     * @param start index of the first character of the identifier (inclusive).\n+     * @param end index of the last character of the identifier (exclusive). -1\n+     *        is equivalent to <tt>name.length()</tt> if name is not\n+     *        <tt>null</tt>.\n+     * @param msg a message to be used in case of error.\n+     */\n+    static void checkInternalName(\n+        final String name,\n+        final int start,\n+        final int end,\n+        final String msg)\n+    {\n+        int max = end == -1 ? name.length() : end;\n+        try {\n+            int begin = start;\n+            int slash;\n+            do {\n+                slash = name.indexOf('/', begin + 1);\n+                if (slash == -1 || slash > max) {\n+                    slash = max;\n+                }\n+                checkIdentifier(name, begin, slash, null);\n+                begin = slash + 1;\n+            } while (slash != max);\n+        } catch (IllegalArgumentException _) {\n+            throw new IllegalArgumentException(\"Invalid \"\n+                    + msg\n+                    + \" (must be a fully qualified class name in internal form): \"\n+                    + name);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given string is a valid type descriptor.\n+     * \n+     * @param desc the string to be checked.\n+     * @param canBeVoid <tt>true</tt> if <tt>V</tt> can be considered valid.\n+     */\n+    static void checkDesc(final String desc, final boolean canBeVoid) {\n+        int end = checkDesc(desc, 0, canBeVoid);\n+        if (end != desc.length()) {\n+            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n+        }\n+    }\n+\n+    /**\n+     * Checks that a the given substring is a valid type descriptor.\n+     * \n+     * @param desc the string to be checked.\n+     * @param start index of the first character of the identifier (inclusive).\n+     * @param canBeVoid <tt>true</tt> if <tt>V</tt> can be considered valid.\n+     * @return the index of the last character of the type decriptor, plus one.\n+     */\n+    static int checkDesc(\n+        final String desc,\n+        final int start,\n+        final boolean canBeVoid)\n+    {\n+        if (desc == null || start >= desc.length()) {\n+            throw new IllegalArgumentException(\"Invalid type descriptor (must not be null or empty)\");\n+        }\n+        int index;\n+        switch (desc.charAt(start)) {\n+            case 'V':\n+                if (canBeVoid) {\n+                    return start + 1;\n+                } else {\n+                    throw new IllegalArgumentException(\"Invalid descriptor: \"\n+                            + desc);\n+                }\n+            case 'Z':\n+            case 'C':\n+            case 'B':\n+            case 'S':\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D':\n+                return start + 1;\n+            case '[':\n+                index = start + 1;\n+                while (index < desc.length() && desc.charAt(index) == '[') {\n+                    ++index;\n+                }\n+                if (index < desc.length()) {\n+                    return checkDesc(desc, index, false);\n+                } else {\n+                    throw new IllegalArgumentException(\"Invalid descriptor: \"\n+                            + desc);\n+                }\n+            case 'L':\n+                index = desc.indexOf(';', start);\n+                if (index == -1 || index - start < 2) {\n+                    throw new IllegalArgumentException(\"Invalid descriptor: \"\n+                            + desc);\n+                }\n+                try {\n+                    checkInternalName(desc, start + 1, index, null);\n+                } catch (IllegalArgumentException _) {\n+                    throw new IllegalArgumentException(\"Invalid descriptor: \"\n+                            + desc);\n+                }\n+                return index + 1;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid descriptor: \"\n+                        + desc);\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given string is a valid method descriptor.\n+     * \n+     * @param desc the string to be checked.\n+     */\n+    static void checkMethodDesc(final String desc) {\n+        if (desc == null || desc.length() == 0) {\n+            throw new IllegalArgumentException(\"Invalid method descriptor (must not be null or empty)\");\n+        }\n+        if (desc.charAt(0) != '(' || desc.length() < 3) {\n+            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n+        }\n+        int start = 1;\n+        if (desc.charAt(start) != ')') {\n+            do {\n+                if (desc.charAt(start) == 'V') {\n+                    throw new IllegalArgumentException(\"Invalid descriptor: \"\n+                            + desc);\n+                }\n+                start = checkDesc(desc, start, false);\n+            } while (start < desc.length() && desc.charAt(start) != ')');\n+        }\n+        start = checkDesc(desc, start + 1, true);\n+        if (start != desc.length()) {\n+            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n+        }\n+    }\n+\n+    /**\n+     * Checks a class signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     */\n+    static void checkClassSignature(final String signature) {\n+        // ClassSignature:\n+        // FormalTypeParameters? ClassTypeSignature ClassTypeSignature*\n+\n+        int pos = 0;\n+        if (getChar(signature, 0) == '<') {\n+            pos = checkFormalTypeParameters(signature, pos);\n+        }\n+        pos = checkClassTypeSignature(signature, pos);\n+        while (getChar(signature, pos) == 'L') {\n+            pos = checkClassTypeSignature(signature, pos);\n+        }\n+        if (pos != signature.length()) {\n+            throw new IllegalArgumentException(signature + \": error at index \"\n+                    + pos);\n+        }\n+    }\n+\n+    /**\n+     * Checks a method signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     */\n+    static void checkMethodSignature(final String signature) {\n+        // MethodTypeSignature:\n+        // FormalTypeParameters? ( TypeSignature* ) ( TypeSignature | V ) (\n+        // ^ClassTypeSignature | ^TypeVariableSignature )*\n+\n+        int pos = 0;\n+        if (getChar(signature, 0) == '<') {\n+            pos = checkFormalTypeParameters(signature, pos);\n+        }\n+        pos = checkChar('(', signature, pos);\n+        while (\"ZCBSIFJDL[T\".indexOf(getChar(signature, pos)) != -1) {\n+            pos = checkTypeSignature(signature, pos);\n+        }\n+        pos = checkChar(')', signature, pos);\n+        if (getChar(signature, pos) == 'V') {\n+            ++pos;\n+        } else {\n+            pos = checkTypeSignature(signature, pos);\n+        }\n+        while (getChar(signature, pos) == '^') {\n+            ++pos;\n+            if (getChar(signature, pos) == 'L') {\n+                pos = checkClassTypeSignature(signature, pos);\n+            } else {\n+                pos = checkTypeVariableSignature(signature, pos);\n+            }\n+        }\n+        if (pos != signature.length()) {\n+            throw new IllegalArgumentException(signature + \": error at index \"\n+                    + pos);\n+        }\n+    }\n+\n+    /**\n+     * Checks a field signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     */\n+    static void checkFieldSignature(final String signature) {\n+        int pos = checkFieldTypeSignature(signature, 0);\n+        if (pos != signature.length()) {\n+            throw new IllegalArgumentException(signature + \": error at index \"\n+                    + pos);\n+        }\n+    }\n+\n+    /**\n+     * Checks the formal type parameters of a class or method signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkFormalTypeParameters(final String signature, int pos)\n+    {\n+        // FormalTypeParameters:\n+        // < FormalTypeParameter+ >\n+\n+        pos = checkChar('<', signature, pos);\n+        pos = checkFormalTypeParameter(signature, pos);\n+        while (getChar(signature, pos) != '>') {\n+            pos = checkFormalTypeParameter(signature, pos);\n+        }\n+        return pos + 1;\n+    }\n+\n+    /**\n+     * Checks a formal type parameter of a class or method signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkFormalTypeParameter(final String signature, int pos)\n+    {\n+        // FormalTypeParameter:\n+        // Identifier : FieldTypeSignature? (: FieldTypeSignature)*\n+\n+        pos = checkIdentifier(signature, pos);\n+        pos = checkChar(':', signature, pos);\n+        if (\"L[T\".indexOf(getChar(signature, pos)) != -1) {\n+            pos = checkFieldTypeSignature(signature, pos);\n+        }\n+        while (getChar(signature, pos) == ':') {\n+            pos = checkFieldTypeSignature(signature, pos + 1);\n+        }\n+        return pos;\n+    }\n+\n+    /**\n+     * Checks a field type signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkFieldTypeSignature(final String signature, int pos)\n+    {\n+        // FieldTypeSignature:\n+        // ClassTypeSignature | ArrayTypeSignature | TypeVariableSignature\n+        //\n+        // ArrayTypeSignature:\n+        // [ TypeSignature\n+\n+        switch (getChar(signature, pos)) {\n+            case 'L':\n+                return checkClassTypeSignature(signature, pos);\n+            case '[':\n+                return checkTypeSignature(signature, pos + 1);\n+            default:\n+                return checkTypeVariableSignature(signature, pos);\n+        }\n+    }\n+\n+    /**\n+     * Checks a class type signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkClassTypeSignature(final String signature, int pos)\n+    {\n+        // ClassTypeSignature:\n+        // L Identifier ( / Identifier )* TypeArguments? ( . Identifier\n+        // TypeArguments? )* ;\n+\n+        pos = checkChar('L', signature, pos);\n+        pos = checkIdentifier(signature, pos);\n+        while (getChar(signature, pos) == '/') {\n+            pos = checkIdentifier(signature, pos + 1);\n+        }\n+        if (getChar(signature, pos) == '<') {\n+            pos = checkTypeArguments(signature, pos);\n+        }\n+        while (getChar(signature, pos) == '.') {\n+            pos = checkIdentifier(signature, pos + 1);\n+            if (getChar(signature, pos) == '<') {\n+                pos = checkTypeArguments(signature, pos);\n+            }\n+        }\n+        return checkChar(';', signature, pos);\n+    }\n+\n+    /**\n+     * Checks the type arguments in a class type signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkTypeArguments(final String signature, int pos) {\n+        // TypeArguments:\n+        // < TypeArgument+ >\n+\n+        pos = checkChar('<', signature, pos);\n+        pos = checkTypeArgument(signature, pos);\n+        while (getChar(signature, pos) != '>') {\n+            pos = checkTypeArgument(signature, pos);\n+        }\n+        return pos + 1;\n+    }\n+\n+    /**\n+     * Checks a type argument in a class type signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkTypeArgument(final String signature, int pos) {\n+        // TypeArgument:\n+        // * | ( ( + | - )? FieldTypeSignature )\n+\n+        char c = getChar(signature, pos);\n+        if (c == '*') {\n+            return pos + 1;\n+        } else if (c == '+' || c == '-') {\n+            pos++;\n+        }\n+        return checkFieldTypeSignature(signature, pos);\n+    }\n+\n+    /**\n+     * Checks a type variable signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkTypeVariableSignature(\n+        final String signature,\n+        int pos)\n+    {\n+        // TypeVariableSignature:\n+        // T Identifier ;\n+\n+        pos = checkChar('T', signature, pos);\n+        pos = checkIdentifier(signature, pos);\n+        return checkChar(';', signature, pos);\n+    }\n+\n+    /**\n+     * Checks a type signature.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkTypeSignature(final String signature, int pos) {\n+        // TypeSignature:\n+        // Z | C | B | S | I | F | J | D | FieldTypeSignature\n+\n+        switch (getChar(signature, pos)) {\n+            case 'Z':\n+            case 'C':\n+            case 'B':\n+            case 'S':\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D':\n+                return pos + 1;\n+            default:\n+                return checkFieldTypeSignature(signature, pos);\n+        }\n+    }\n+\n+    /**\n+     * Checks an identifier.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkIdentifier(final String signature, int pos) {\n+        if (!Character.isJavaIdentifierStart(getChar(signature, pos))) {\n+            throw new IllegalArgumentException(signature\n+                    + \": identifier expected at index \" + pos);\n+        }\n+        ++pos;\n+        while (Character.isJavaIdentifierPart(getChar(signature, pos))) {\n+            ++pos;\n+        }\n+        return pos;\n+    }\n+\n+    /**\n+     * Checks a single character.\n+     * \n+     * @param signature a string containing the signature that must be checked.\n+     * @param pos index of first character to be checked.\n+     * @return the index of the first character after the checked part.\n+     */\n+    private static int checkChar(final char c, final String signature, int pos)\n+    {\n+        if (getChar(signature, pos) == c) {\n+            return pos + 1;\n+        }\n+        throw new IllegalArgumentException(signature + \": '\" + c\n+                + \"' expected at index \" + pos);\n+    }\n+\n+    /**\n+     * Returns the signature car at the given index.\n+     * \n+     * @param signature a signature.\n+     * @param pos an index in signature.\n+     * @return the character at the given index, or 0 if there is no such\n+     *         character.\n+     */\n+    private static char getChar(final String signature, int pos) {\n+        return pos < signature.length() ? signature.charAt(pos) : (char) 0;\n+    }\n+\n+    /**\n+     * Checks that the given label is not null. This method can also check that\n+     * the label has been visited.\n+     * \n+     * @param label the label to be checked.\n+     * @param checkVisited <tt>true</tt> to check that the label has been\n+     *        visited.\n+     * @param msg a message to be used in case of error.\n+     */\n+    void checkLabel(\n+        final Label label,\n+        final boolean checkVisited,\n+        final String msg)\n+    {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"Invalid \" + msg\n+                    + \" (must not be null)\");\n+        }\n+        if (checkVisited && labels.get(label) == null) {\n+            throw new IllegalArgumentException(\"Invalid \" + msg\n+                    + \" (must be visited first)\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/CheckSignatureAdapter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.signature.SignatureVisitor;\n+\n+/**\n+ * A {@link SignatureVisitor} that checks that its methods are properly used.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class CheckSignatureAdapter implements SignatureVisitor {\n+\n+    /**\n+     * Type to be used to check class signatures. See\n+     * {@link #CheckSignatureAdapter(int, SignatureVisitor) CheckSignatureAdapter}.\n+     */\n+    public static final int CLASS_SIGNATURE = 0;\n+\n+    /**\n+     * Type to be used to check method signatures. See\n+     * {@link #CheckSignatureAdapter(int, SignatureVisitor) CheckSignatureAdapter}.\n+     */\n+    public static final int METHOD_SIGNATURE = 1;\n+\n+    /**\n+     * Type to be used to check type signatures.See\n+     * {@link #CheckSignatureAdapter(int, SignatureVisitor) CheckSignatureAdapter}.\n+     */\n+    public static final int TYPE_SIGNATURE = 2;\n+\n+    private static final int EMPTY = 1;\n+\n+    private static final int FORMAL = 2;\n+\n+    private static final int BOUND = 4;\n+\n+    private static final int SUPER = 8;\n+\n+    private static final int PARAM = 16;\n+\n+    private static final int RETURN = 32;\n+\n+    private static final int SIMPLE_TYPE = 64;\n+\n+    private static final int CLASS_TYPE = 128;\n+\n+    private static final int END = 256;\n+\n+    /**\n+     * Type of the signature to be checked.\n+     */\n+    private final int type;\n+\n+    /**\n+     * State of the automaton used to check the order of method calls.\n+     */\n+    private int state;\n+\n+    /**\n+     * <tt>true</tt> if the checked type signature can be 'V'.\n+     */\n+    private boolean canBeVoid;\n+\n+    /**\n+     * The visitor to which this adapter must delegate calls. May be\n+     * <tt>null</tt>.\n+     */\n+    private final SignatureVisitor sv;\n+\n+    /**\n+     * Creates a new {@link CheckSignatureAdapter} object.\n+     * \n+     * @param type the type of signature to be checked. See\n+     *        {@link #CLASS_SIGNATURE}, {@link #METHOD_SIGNATURE} and\n+     *        {@link #TYPE_SIGNATURE}.\n+     * @param sv the visitor to which this adapter must delegate calls. May be\n+     *        <tt>null</tt>.\n+     */\n+    public CheckSignatureAdapter(final int type, final SignatureVisitor sv) {\n+        this.type = type;\n+        this.state = EMPTY;\n+        this.sv = sv;\n+    }\n+\n+    // class and method signatures\n+\n+    public void visitFormalTypeParameter(final String name) {\n+        if (type == TYPE_SIGNATURE\n+                || (state != EMPTY && state != FORMAL && state != BOUND))\n+        {\n+            throw new IllegalStateException();\n+        }\n+        CheckMethodAdapter.checkIdentifier(name, \"formal type parameter\");\n+        state = FORMAL;\n+        if (sv != null) {\n+            sv.visitFormalTypeParameter(name);\n+        }\n+    }\n+\n+    public SignatureVisitor visitClassBound() {\n+        if (state != FORMAL) {\n+            throw new IllegalStateException();\n+        }\n+        state = BOUND;\n+        SignatureVisitor v = sv == null ? null : sv.visitClassBound();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    public SignatureVisitor visitInterfaceBound() {\n+        if (state != FORMAL && state != BOUND) {\n+            throw new IllegalArgumentException();\n+        }\n+        SignatureVisitor v = sv == null ? null : sv.visitInterfaceBound();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    // class signatures\n+\n+    public SignatureVisitor visitSuperclass() {\n+        if (type != CLASS_SIGNATURE || (state & (EMPTY | FORMAL | BOUND)) == 0)\n+        {\n+            throw new IllegalArgumentException();\n+        }\n+        state = SUPER;\n+        SignatureVisitor v = sv == null ? null : sv.visitSuperclass();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    public SignatureVisitor visitInterface() {\n+        if (state != SUPER) {\n+            throw new IllegalStateException();\n+        }\n+        SignatureVisitor v = sv == null ? null : sv.visitInterface();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    // method signatures\n+\n+    public SignatureVisitor visitParameterType() {\n+        if (type != METHOD_SIGNATURE\n+                || (state & (EMPTY | FORMAL | BOUND | PARAM)) == 0)\n+        {\n+            throw new IllegalArgumentException();\n+        }\n+        state = PARAM;\n+        SignatureVisitor v = sv == null ? null : sv.visitParameterType();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    public SignatureVisitor visitReturnType() {\n+        if (type != METHOD_SIGNATURE\n+                || (state & (EMPTY | FORMAL | BOUND | PARAM)) == 0)\n+        {\n+            throw new IllegalArgumentException();\n+        }\n+        state = RETURN;\n+        SignatureVisitor v = sv == null ? null : sv.visitReturnType();\n+        CheckSignatureAdapter cv = new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+        cv.canBeVoid = true;\n+        return cv;\n+    }\n+\n+    public SignatureVisitor visitExceptionType() {\n+        if (state != RETURN) {\n+            throw new IllegalStateException();\n+        }\n+        SignatureVisitor v = sv == null ? null : sv.visitExceptionType();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    // type signatures\n+\n+    public void visitBaseType(final char descriptor) {\n+        if (type != TYPE_SIGNATURE || state != EMPTY) {\n+            throw new IllegalStateException();\n+        }\n+        if (descriptor == 'V') {\n+            if (!canBeVoid) {\n+                throw new IllegalArgumentException();\n+            }\n+        } else {\n+            if (\"ZCBSIFJD\".indexOf(descriptor) == -1) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+        state = SIMPLE_TYPE;\n+        if (sv != null) {\n+            sv.visitBaseType(descriptor);\n+        }\n+    }\n+\n+    public void visitTypeVariable(final String name) {\n+        if (type != TYPE_SIGNATURE || state != EMPTY) {\n+            throw new IllegalStateException();\n+        }\n+        CheckMethodAdapter.checkIdentifier(name, \"type variable\");\n+        state = SIMPLE_TYPE;\n+        if (sv != null) {\n+            sv.visitTypeVariable(name);\n+        }\n+    }\n+\n+    public SignatureVisitor visitArrayType() {\n+        if (type != TYPE_SIGNATURE || state != EMPTY) {\n+            throw new IllegalStateException();\n+        }\n+        state = SIMPLE_TYPE;\n+        SignatureVisitor v = sv == null ? null : sv.visitArrayType();\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    public void visitClassType(final String name) {\n+        if (type != TYPE_SIGNATURE || state != EMPTY) {\n+            throw new IllegalStateException();\n+        }\n+        CheckMethodAdapter.checkInternalName(name, \"class name\");\n+        state = CLASS_TYPE;\n+        if (sv != null) {\n+            sv.visitClassType(name);\n+        }\n+    }\n+\n+    public void visitInnerClassType(final String name) {\n+        if (state != CLASS_TYPE) {\n+            throw new IllegalStateException();\n+        }\n+        CheckMethodAdapter.checkIdentifier(name, \"inner class name\");\n+        if (sv != null) {\n+            sv.visitInnerClassType(name);\n+        }\n+    }\n+\n+    public void visitTypeArgument() {\n+        if (state != CLASS_TYPE) {\n+            throw new IllegalStateException();\n+        }\n+        if (sv != null) {\n+            sv.visitTypeArgument();\n+        }\n+    }\n+\n+    public SignatureVisitor visitTypeArgument(final char wildcard) {\n+        if (state != CLASS_TYPE) {\n+            throw new IllegalStateException();\n+        }\n+        if (\"+-=\".indexOf(wildcard) == -1) {\n+            throw new IllegalArgumentException();\n+        }\n+        SignatureVisitor v = sv == null ? null : sv.visitTypeArgument(wildcard);\n+        return new CheckSignatureAdapter(TYPE_SIGNATURE, v);\n+    }\n+\n+    public void visitEnd() {\n+        if (state != CLASS_TYPE) {\n+            throw new IllegalStateException();\n+        }\n+        state = END;\n+        if (sv != null) {\n+            sv.visitEnd();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/TraceAbstractVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+\n+/**\n+ * An abstract trace visitor.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public abstract class TraceAbstractVisitor extends AbstractVisitor {\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for internal\n+     * type names in bytecode notation.\n+     */\n+    public static final int INTERNAL_NAME = 0;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for field\n+     * descriptors, formatted in bytecode notation\n+     */\n+    public static final int FIELD_DESCRIPTOR = 1;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for field\n+     * signatures, formatted in bytecode notation\n+     */\n+    public static final int FIELD_SIGNATURE = 2;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for method\n+     * descriptors, formatted in bytecode notation\n+     */\n+    public static final int METHOD_DESCRIPTOR = 3;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for method\n+     * signatures, formatted in bytecode notation\n+     */\n+    public static final int METHOD_SIGNATURE = 4;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for class\n+     * signatures, formatted in bytecode notation\n+     */\n+    public static final int CLASS_SIGNATURE = 5;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for field or\n+     * method return value signatures, formatted in default Java notation\n+     * (non-bytecode)\n+     */\n+    public static final int TYPE_DECLARATION = 6;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for class\n+     * signatures, formatted in default Java notation (non-bytecode)\n+     */\n+    public static final int CLASS_DECLARATION = 7;\n+\n+    /**\n+     * Constant used in {@link #appendDescriptor appendDescriptor} for method\n+     * parameter signatures, formatted in default Java notation (non-bytecode)\n+     */\n+    public static final int PARAMETERS_DECLARATION = 8;\n+\n+    /**\n+     * Tab for class members.\n+     */\n+    protected String tab = \"  \";\n+\n+    /**\n+     * Prints a disassembled view of the given annotation.\n+     * \n+     * @param desc the class descriptor of the annotation class.\n+     * @param visible <tt>true</tt> if the annotation is visible at runtime.\n+     * @return a visitor to visit the annotation values.\n+     */\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab).append('@');\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append('(');\n+        text.add(buf.toString());\n+        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();\n+        text.add(tav.getText());\n+        text.add(visible ? \")\\n\" : \") // invisible\\n\");\n+        return tav;\n+    }\n+\n+    /**\n+     * Prints a disassembled view of the given attribute.\n+     * \n+     * @param attr an attribute.\n+     */\n+    public void visitAttribute(final Attribute attr) {\n+        buf.setLength(0);\n+        buf.append(tab).append(\"ATTRIBUTE \");\n+        appendDescriptor(-1, attr.type);\n+\n+        if (attr instanceof Traceable) {\n+            ((Traceable) attr).trace(buf, null);\n+        } else {\n+            buf.append(\" : unknown\\n\");\n+        }\n+\n+        text.add(buf.toString());\n+    }\n+\n+    /**\n+     * Does nothing.\n+     */\n+    public void visitEnd() {\n+        // does nothing\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    protected TraceAnnotationVisitor createTraceAnnotationVisitor() {\n+        return new TraceAnnotationVisitor();\n+    }\n+\n+    /**\n+     * Appends an internal name, a type descriptor or a type signature to\n+     * {@link #buf buf}.\n+     * \n+     * @param type indicates if desc is an internal name, a field descriptor, a\n+     *        method descriptor, a class signature, ...\n+     * @param desc an internal name, type descriptor, or type signature. May be\n+     *        <tt>null</tt>.\n+     */\n+    protected void appendDescriptor(final int type, final String desc) {\n+        if (type == CLASS_SIGNATURE || type == FIELD_SIGNATURE\n+                || type == METHOD_SIGNATURE)\n+        {\n+            if (desc != null) {\n+                buf.append(\"// signature \").append(desc).append('\\n');\n+            }\n+        } else {\n+            buf.append(desc);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/TraceAnnotationVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Type;\n+\n+/**\n+ * An {@link AnnotationVisitor} that prints a disassembled view of the\n+ * annotations it visits.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class TraceAnnotationVisitor extends TraceAbstractVisitor implements\n+        AnnotationVisitor\n+{\n+\n+    /**\n+     * The {@link AnnotationVisitor} to which this visitor delegates calls. May\n+     * be <tt>null</tt>.\n+     */\n+    protected AnnotationVisitor av;\n+\n+    private int valueNumber = 0;\n+\n+    /**\n+     * Constructs a new {@link TraceAnnotationVisitor}.\n+     */\n+    public TraceAnnotationVisitor() {\n+        // ignore\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the AnnotationVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(final String name, final Object value) {\n+        buf.setLength(0);\n+        appendComa(valueNumber++);\n+\n+        if (name != null) {\n+            buf.append(name).append('=');\n+        }\n+\n+        if (value instanceof String) {\n+            visitString((String) value);\n+        } else if (value instanceof Type) {\n+            visitType((Type) value);\n+        } else if (value instanceof Byte) {\n+            visitByte(((Byte) value).byteValue());\n+        } else if (value instanceof Boolean) {\n+            visitBoolean(((Boolean) value).booleanValue());\n+        } else if (value instanceof Short) {\n+            visitShort(((Short) value).shortValue());\n+        } else if (value instanceof Character) {\n+            visitChar(((Character) value).charValue());\n+        } else if (value instanceof Integer) {\n+            visitInt(((Integer) value).intValue());\n+        } else if (value instanceof Float) {\n+            visitFloat(((Float) value).floatValue());\n+        } else if (value instanceof Long) {\n+            visitLong(((Long) value).longValue());\n+        } else if (value instanceof Double) {\n+            visitDouble(((Double) value).doubleValue());\n+        } else if (value.getClass().isArray()) {\n+            buf.append('{');\n+            if (value instanceof byte[]) {\n+                byte[] v = (byte[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitByte(v[i]);\n+                }\n+            } else if (value instanceof boolean[]) {\n+                boolean[] v = (boolean[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitBoolean(v[i]);\n+                }\n+            } else if (value instanceof short[]) {\n+                short[] v = (short[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitShort(v[i]);\n+                }\n+            } else if (value instanceof char[]) {\n+                char[] v = (char[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitChar(v[i]);\n+                }\n+            } else if (value instanceof int[]) {\n+                int[] v = (int[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitInt(v[i]);\n+                }\n+            } else if (value instanceof long[]) {\n+                long[] v = (long[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitLong(v[i]);\n+                }\n+            } else if (value instanceof float[]) {\n+                float[] v = (float[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitFloat(v[i]);\n+                }\n+            } else if (value instanceof double[]) {\n+                double[] v = (double[]) value;\n+                for (int i = 0; i < v.length; i++) {\n+                    appendComa(i);\n+                    visitDouble(v[i]);\n+                }\n+            }\n+            buf.append('}');\n+        }\n+\n+        text.add(buf.toString());\n+\n+        if (av != null) {\n+            av.visit(name, value);\n+        }\n+    }\n+\n+    private void visitInt(final int value) {\n+        buf.append(value);\n+    }\n+\n+    private void visitLong(final long value) {\n+        buf.append(value).append('L');\n+    }\n+\n+    private void visitFloat(final float value) {\n+        buf.append(value).append('F');\n+    }\n+\n+    private void visitDouble(final double value) {\n+        buf.append(value).append('D');\n+    }\n+\n+    private void visitChar(final char value) {\n+        buf.append(\"(char)\").append((int) value);\n+    }\n+\n+    private void visitShort(final short value) {\n+        buf.append(\"(short)\").append(value);\n+    }\n+\n+    private void visitByte(final byte value) {\n+        buf.append(\"(byte)\").append(value);\n+    }\n+\n+    private void visitBoolean(final boolean value) {\n+        buf.append(value);\n+    }\n+\n+    private void visitString(final String value) {\n+        appendString(buf, value);\n+    }\n+\n+    private void visitType(final Type value) {\n+        buf.append(value.getClassName()).append(\".class\");\n+    }\n+\n+    public void visitEnum(\n+        final String name,\n+        final String desc,\n+        final String value)\n+    {\n+        buf.setLength(0);\n+        appendComa(valueNumber++);\n+        if (name != null) {\n+            buf.append(name).append('=');\n+        }\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append('.').append(value);\n+        text.add(buf.toString());\n+\n+        if (av != null) {\n+            av.visitEnum(name, desc, value);\n+        }\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        appendComa(valueNumber++);\n+        if (name != null) {\n+            buf.append(name).append('=');\n+        }\n+        buf.append('@');\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append('(');\n+        text.add(buf.toString());\n+        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();\n+        text.add(tav.getText());\n+        text.add(\")\");\n+        if (av != null) {\n+            tav.av = av.visitAnnotation(name, desc);\n+        }\n+        return tav;\n+    }\n+\n+    public AnnotationVisitor visitArray(final String name) {\n+        buf.setLength(0);\n+        appendComa(valueNumber++);\n+        if (name != null) {\n+            buf.append(name).append('=');\n+        }\n+        buf.append('{');\n+        text.add(buf.toString());\n+        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();\n+        text.add(tav.getText());\n+        text.add(\"}\");\n+        if (av != null) {\n+            tav.av = av.visitArray(name);\n+        }\n+        return tav;\n+    }\n+\n+    public void visitEnd() {\n+        if (av != null) {\n+            av.visitEnd();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    private void appendComa(final int i) {\n+        if (i != 0) {\n+            buf.append(\", \");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/TraceClassVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import java.io.FileInputStream;\n+import java.io.PrintWriter;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.FieldVisitor;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.signature.SignatureReader;\n+\n+/**\n+ * A {@link ClassVisitor} that prints a disassembled view of the classes it\n+ * visits. This class visitor can be used alone (see the {@link #main main}\n+ * method) to disassemble a class. It can also be used in the middle of class\n+ * visitor chain to trace the class that is visited at a given point in this\n+ * chain. This may be uselful for debugging purposes. <p> The trace printed when\n+ * visiting the <tt>Hello</tt> class is the following: <p> <blockquote>\n+ * \n+ * <pre>\n+ * // class version 49.0 (49)\n+ * // access flags 33\n+ * public class Hello {\n+ *\n+ *  // compiled from: Hello.java\n+ *\n+ *   // access flags 1\n+ *   public &lt;init&gt; ()V\n+ *     ALOAD 0\n+ *     INVOKESPECIAL java/lang/Object &lt;init&gt; ()V\n+ *     RETURN\n+ *     MAXSTACK = 1\n+ *     MAXLOCALS = 1\n+ *\n+ *   // access flags 9\n+ *   public static main ([Ljava/lang/String;)V\n+ *     GETSTATIC java/lang/System out Ljava/io/PrintStream;\n+ *     LDC &quot;hello&quot;\n+ *     INVOKEVIRTUAL java/io/PrintStream println (Ljava/lang/String;)V\n+ *     RETURN\n+ *     MAXSTACK = 2\n+ *     MAXLOCALS = 1\n+ * }\n+ * </pre>\n+ * \n+ * </blockquote> where <tt>Hello</tt> is defined by: <p> <blockquote>\n+ * \n+ * <pre>\n+ * public class Hello {\n+ *\n+ *     public static void main(String[] args) {\n+ *         System.out.println(&quot;hello&quot;);\n+ *     }\n+ * }\n+ * </pre>\n+ * \n+ * </blockquote>\n+ * \n+ * @author Eric Bruneton\n+ * @author Eugene Kuleshov\n+ */\n+public class TraceClassVisitor extends TraceAbstractVisitor implements\n+        ClassVisitor\n+{\n+\n+    /**\n+     * The {@link ClassVisitor} to which this visitor delegates calls. May be\n+     * <tt>null</tt>.\n+     */\n+    protected final ClassVisitor cv;\n+\n+    /**\n+     * The print writer to be used to print the class.\n+     */\n+    protected final PrintWriter pw;\n+\n+    /**\n+     * Prints a disassembled view of the given class to the standard output. <p>\n+     * Usage: TraceClassVisitor [-debug] &lt;fully qualified class name or class\n+     * file name &gt;\n+     * \n+     * @param args the command line arguments.\n+     * \n+     * @throws Exception if the class cannot be found, or if an IO exception\n+     *         occurs.\n+     */\n+    public static void main(final String[] args) throws Exception {\n+        int i = 0;\n+        int flags = ClassReader.SKIP_DEBUG;\n+\n+        boolean ok = true;\n+        if (args.length < 1 || args.length > 2) {\n+            ok = false;\n+        }\n+        if (ok && \"-debug\".equals(args[0])) {\n+            i = 1;\n+            flags = 0;\n+            if (args.length != 2) {\n+                ok = false;\n+            }\n+        }\n+        if (!ok) {\n+            System.err.println(\"Prints a disassembled view of the given class.\");\n+            System.err.println(\"Usage: TraceClassVisitor [-debug] \"\n+                    + \"<fully qualified class name or class file name>\");\n+            return;\n+        }\n+        ClassReader cr;\n+        if (args[i].endsWith(\".class\") || args[i].indexOf('\\\\') > -1\n+                || args[i].indexOf('/') > -1)\n+        {\n+            cr = new ClassReader(new FileInputStream(args[i]));\n+        } else {\n+            cr = new ClassReader(args[i]);\n+        }\n+        cr.accept(new TraceClassVisitor(new PrintWriter(System.out)),\n+                getDefaultAttributes(),\n+                flags);\n+    }\n+\n+    /**\n+     * Constructs a new {@link TraceClassVisitor}.\n+     * \n+     * @param pw the print writer to be used to print the class.\n+     */\n+    public TraceClassVisitor(final PrintWriter pw) {\n+        this(null, pw);\n+    }\n+\n+    /**\n+     * Constructs a new {@link TraceClassVisitor}.\n+     * \n+     * @param cv the {@link ClassVisitor} to which this visitor delegates calls.\n+     *        May be <tt>null</tt>.\n+     * @param pw the print writer to be used to print the class.\n+     */\n+    public TraceClassVisitor(final ClassVisitor cv, final PrintWriter pw) {\n+        this.cv = cv;\n+        this.pw = pw;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the ClassVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public void visit(\n+        final int version,\n+        final int access,\n+        final String name,\n+        final String signature,\n+        final String superName,\n+        final String[] interfaces)\n+    {\n+        int major = version & 0xFFFF;\n+        int minor = version >>> 16;\n+        buf.setLength(0);\n+        buf.append(\"// class version \")\n+                .append(major)\n+                .append('.')\n+                .append(minor)\n+                .append(\" (\")\n+                .append(version)\n+                .append(\")\\n\");\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            buf.append(\"// DEPRECATED\\n\");\n+        }\n+        buf.append(\"// access flags \").append(access).append('\\n');\n+\n+        appendDescriptor(CLASS_SIGNATURE, signature);\n+        if (signature != null) {\n+            TraceSignatureVisitor sv = new TraceSignatureVisitor(access);\n+            SignatureReader r = new SignatureReader(signature);\n+            r.accept(sv);\n+            buf.append(\"// declaration: \")\n+                    .append(name)\n+                    .append(sv.getDeclaration())\n+                    .append('\\n');\n+        }\n+\n+        appendAccess(access & ~Opcodes.ACC_SUPER);\n+        if ((access & Opcodes.ACC_ANNOTATION) != 0) {\n+            buf.append(\"@interface \");\n+        } else if ((access & Opcodes.ACC_INTERFACE) != 0) {\n+            buf.append(\"interface \");\n+        } else if ((access & Opcodes.ACC_ENUM) == 0) {\n+            buf.append(\"class \");\n+        }\n+        appendDescriptor(INTERNAL_NAME, name);\n+\n+        if (superName != null && !\"java/lang/Object\".equals(superName)) {\n+            buf.append(\" extends \");\n+            appendDescriptor(INTERNAL_NAME, superName);\n+            buf.append(' ');\n+        }\n+        if (interfaces != null && interfaces.length > 0) {\n+            buf.append(\" implements \");\n+            for (int i = 0; i < interfaces.length; ++i) {\n+                appendDescriptor(INTERNAL_NAME, interfaces[i]);\n+                buf.append(' ');\n+            }\n+        }\n+        buf.append(\" {\\n\\n\");\n+\n+        text.add(buf.toString());\n+\n+        if (cv != null) {\n+            cv.visit(version, access, name, signature, superName, interfaces);\n+        }\n+    }\n+\n+    public void visitSource(final String file, final String debug) {\n+        buf.setLength(0);\n+        if (file != null) {\n+            buf.append(tab)\n+                    .append(\"// compiled from: \")\n+                    .append(file)\n+                    .append('\\n');\n+        }\n+        if (debug != null) {\n+            buf.append(tab)\n+                    .append(\"// debug info: \")\n+                    .append(debug)\n+                    .append('\\n');\n+        }\n+        if (buf.length() > 0) {\n+            text.add(buf.toString());\n+        }\n+\n+        if (cv != null) {\n+            cv.visitSource(file, debug);\n+        }\n+    }\n+\n+    public void visitOuterClass(\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab).append(\"OUTERCLASS \");\n+        appendDescriptor(INTERNAL_NAME, owner);\n+        buf.append(' ');\n+        if (name != null) {\n+            buf.append(name).append(' ');\n+        }\n+        appendDescriptor(METHOD_DESCRIPTOR, desc);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (cv != null) {\n+            cv.visitOuterClass(owner, name, desc);\n+        }\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        text.add(\"\\n\");\n+        AnnotationVisitor tav = super.visitAnnotation(desc, visible);\n+        if (cv != null) {\n+            ((TraceAnnotationVisitor) tav).av = cv.visitAnnotation(desc,\n+                    visible);\n+        }\n+        return tav;\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        text.add(\"\\n\");\n+        super.visitAttribute(attr);\n+\n+        if (cv != null) {\n+            cv.visitAttribute(attr);\n+        }\n+    }\n+\n+    public void visitInnerClass(\n+        final String name,\n+        final String outerName,\n+        final String innerName,\n+        final int access)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab).append(\"// access flags \");\n+        buf.append(access & ~Opcodes.ACC_SUPER).append('\\n');\n+        buf.append(tab);\n+        appendAccess(access);\n+        buf.append(\"INNERCLASS \");\n+        appendDescriptor(INTERNAL_NAME, name);\n+        buf.append(' ');\n+        appendDescriptor(INTERNAL_NAME, outerName);\n+        buf.append(' ');\n+        appendDescriptor(INTERNAL_NAME, innerName);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (cv != null) {\n+            cv.visitInnerClass(name, outerName, innerName, access);\n+        }\n+    }\n+\n+    public FieldVisitor visitField(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Object value)\n+    {\n+        buf.setLength(0);\n+        buf.append('\\n');\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            buf.append(tab).append(\"// DEPRECATED\\n\");\n+        }\n+        buf.append(tab).append(\"// access flags \").append(access).append('\\n');\n+        if (signature != null) {\n+            buf.append(tab);\n+            appendDescriptor(FIELD_SIGNATURE, signature);\n+\n+            TraceSignatureVisitor sv = new TraceSignatureVisitor(0);\n+            SignatureReader r = new SignatureReader(signature);\n+            r.acceptType(sv);\n+            buf.append(tab)\n+                    .append(\"// declaration: \")\n+                    .append(sv.getDeclaration())\n+                    .append('\\n');\n+        }\n+\n+        buf.append(tab);\n+        appendAccess(access);\n+\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append(' ').append(name);\n+        if (value != null) {\n+            buf.append(\" = \");\n+            if (value instanceof String) {\n+                buf.append('\\\"').append(value).append('\\\"');\n+            } else {\n+                buf.append(value);\n+            }\n+        }\n+\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        TraceFieldVisitor tav = createTraceFieldVisitor();\n+        text.add(tav.getText());\n+\n+        if (cv != null) {\n+            tav.fv = cv.visitField(access, name, desc, signature, value);\n+        }\n+\n+        return tav;\n+    }\n+\n+    public MethodVisitor visitMethod(\n+        final int access,\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final String[] exceptions)\n+    {\n+        buf.setLength(0);\n+        buf.append('\\n');\n+        if ((access & Opcodes.ACC_DEPRECATED) != 0) {\n+            buf.append(tab).append(\"// DEPRECATED\\n\");\n+        }\n+        buf.append(tab).append(\"// access flags \").append(access).append('\\n');\n+\n+        if (signature != null) {\n+            buf.append(tab);\n+            appendDescriptor(METHOD_SIGNATURE, signature);\n+\n+            TraceSignatureVisitor v = new TraceSignatureVisitor(0);\n+            SignatureReader r = new SignatureReader(signature);\n+            r.accept(v);\n+            String genericDecl = v.getDeclaration();\n+            String genericReturn = v.getReturnType();\n+            String genericExceptions = v.getExceptions();\n+\n+            buf.append(tab)\n+                    .append(\"// declaration: \")\n+                    .append(genericReturn)\n+                    .append(' ')\n+                    .append(name)\n+                    .append(genericDecl);\n+            if (genericExceptions != null) {\n+                buf.append(\" throws \").append(genericExceptions);\n+            }\n+            buf.append('\\n');\n+        }\n+\n+        buf.append(tab);\n+        appendAccess(access);\n+        if ((access & Opcodes.ACC_NATIVE) != 0) {\n+            buf.append(\"native \");\n+        }\n+        if ((access & Opcodes.ACC_VARARGS) != 0) {\n+            buf.append(\"varargs \");\n+        }\n+        if ((access & Opcodes.ACC_BRIDGE) != 0) {\n+            buf.append(\"bridge \");\n+        }\n+\n+        buf.append(name);\n+        appendDescriptor(METHOD_DESCRIPTOR, desc);\n+        if (exceptions != null && exceptions.length > 0) {\n+            buf.append(\" throws \");\n+            for (int i = 0; i < exceptions.length; ++i) {\n+                appendDescriptor(INTERNAL_NAME, exceptions[i]);\n+                buf.append(' ');\n+            }\n+        }\n+\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        TraceMethodVisitor tcv = createTraceMethodVisitor();\n+        text.add(tcv.getText());\n+\n+        if (cv != null) {\n+            tcv.mv = cv.visitMethod(access, name, desc, signature, exceptions);\n+        }\n+\n+        return tcv;\n+    }\n+\n+    public void visitEnd() {\n+        text.add(\"}\\n\");\n+\n+        print(pw);\n+        pw.flush();\n+\n+        if (cv != null) {\n+            cv.visitEnd();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    protected TraceFieldVisitor createTraceFieldVisitor() {\n+        return new TraceFieldVisitor();\n+    }\n+\n+    protected TraceMethodVisitor createTraceMethodVisitor() {\n+        return new TraceMethodVisitor();\n+    }\n+\n+    /**\n+     * Appends a string representation of the given access modifiers to {@link\n+     * #buf buf}.\n+     * \n+     * @param access some access modifiers.\n+     */\n+    private void appendAccess(final int access) {\n+        if ((access & Opcodes.ACC_PUBLIC) != 0) {\n+            buf.append(\"public \");\n+        }\n+        if ((access & Opcodes.ACC_PRIVATE) != 0) {\n+            buf.append(\"private \");\n+        }\n+        if ((access & Opcodes.ACC_PROTECTED) != 0) {\n+            buf.append(\"protected \");\n+        }\n+        if ((access & Opcodes.ACC_FINAL) != 0) {\n+            buf.append(\"final \");\n+        }\n+        if ((access & Opcodes.ACC_STATIC) != 0) {\n+            buf.append(\"static \");\n+        }\n+        if ((access & Opcodes.ACC_SYNCHRONIZED) != 0) {\n+            buf.append(\"synchronized \");\n+        }\n+        if ((access & Opcodes.ACC_VOLATILE) != 0) {\n+            buf.append(\"volatile \");\n+        }\n+        if ((access & Opcodes.ACC_TRANSIENT) != 0) {\n+            buf.append(\"transient \");\n+        }\n+        if ((access & Opcodes.ACC_ABSTRACT) != 0) {\n+            buf.append(\"abstract \");\n+        }\n+        if ((access & Opcodes.ACC_STRICT) != 0) {\n+            buf.append(\"strictfp \");\n+        }\n+        if ((access & Opcodes.ACC_ENUM) != 0) {\n+            buf.append(\"enum \");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/TraceFieldVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.FieldVisitor;\n+\n+/**\n+ * A {@link FieldVisitor} that prints a disassembled view of the fields it\n+ * visits.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class TraceFieldVisitor extends TraceAbstractVisitor implements\n+        FieldVisitor\n+{\n+\n+    /**\n+     * The {@link FieldVisitor} to which this visitor delegates calls. May be\n+     * <tt>null</tt>.\n+     */\n+    protected FieldVisitor fv;\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        AnnotationVisitor av = super.visitAnnotation(desc, visible);\n+        if (fv != null) {\n+            ((TraceAnnotationVisitor) av).av = fv.visitAnnotation(desc, visible);\n+        }\n+        return av;\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        super.visitAttribute(attr);\n+\n+        if (fv != null) {\n+            fv.visitAttribute(attr);\n+        }\n+    }\n+\n+    public void visitEnd() {\n+        super.visitEnd();\n+\n+        if (fv != null) {\n+            fv.visitEnd();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/TraceMethodVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+import org.mockito.asm.signature.SignatureReader;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * A {@link MethodVisitor} that prints a disassembled view of the methods it\n+ * visits.\n+ * \n+ * @author Eric Bruneton\n+ */\n+public class TraceMethodVisitor extends TraceAbstractVisitor implements\n+        MethodVisitor\n+{\n+\n+    /**\n+     * The {@link MethodVisitor} to which this visitor delegates calls. May be\n+     * <tt>null</tt>.\n+     */\n+    protected MethodVisitor mv;\n+\n+    /**\n+     * Tab for bytecode instructions.\n+     */\n+    protected String tab2 = \"    \";\n+\n+    /**\n+     * Tab for table and lookup switch instructions.\n+     */\n+    protected String tab3 = \"      \";\n+\n+    /**\n+     * Tab for labels.\n+     */\n+    protected String ltab = \"   \";\n+\n+    /**\n+     * The label names. This map associate String values to Label keys.\n+     */\n+    protected final Map labelNames;\n+\n+    /**\n+     * Constructs a new {@link TraceMethodVisitor}.\n+     */\n+    public TraceMethodVisitor() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructs a new {@link TraceMethodVisitor}.\n+     * \n+     * @param mv the {@link MethodVisitor} to which this visitor delegates\n+     *        calls. May be <tt>null</tt>.\n+     */\n+    public TraceMethodVisitor(final MethodVisitor mv) {\n+        this.labelNames = new HashMap();\n+        this.mv = mv;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Implementation of the MethodVisitor interface\n+    // ------------------------------------------------------------------------\n+\n+    public AnnotationVisitor visitAnnotation(\n+        final String desc,\n+        final boolean visible)\n+    {\n+        AnnotationVisitor av = super.visitAnnotation(desc, visible);\n+        if (mv != null) {\n+            ((TraceAnnotationVisitor) av).av = mv.visitAnnotation(desc, visible);\n+        }\n+        return av;\n+    }\n+\n+    public void visitAttribute(final Attribute attr) {\n+        buf.setLength(0);\n+        buf.append(tab).append(\"ATTRIBUTE \");\n+        appendDescriptor(-1, attr.type);\n+\n+        if (attr instanceof Traceable) {\n+            ((Traceable) attr).trace(buf, labelNames);\n+        } else {\n+            buf.append(\" : unknown\\n\");\n+        }\n+\n+        text.add(buf.toString());\n+        if (mv != null) {\n+            mv.visitAttribute(attr);\n+        }\n+    }\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        text.add(tab2 + \"default=\");\n+        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();\n+        text.add(tav.getText());\n+        text.add(\"\\n\");\n+        if (mv != null) {\n+            tav.av = mv.visitAnnotationDefault();\n+        }\n+        return tav;\n+    }\n+\n+    public AnnotationVisitor visitParameterAnnotation(\n+        final int parameter,\n+        final String desc,\n+        final boolean visible)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append('@');\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append('(');\n+        text.add(buf.toString());\n+        TraceAnnotationVisitor tav = createTraceAnnotationVisitor();\n+        text.add(tav.getText());\n+        text.add(visible ? \") // parameter \" : \") // invisible, parameter \");\n+        text.add(new Integer(parameter));\n+        text.add(\"\\n\");\n+        if (mv != null) {\n+            tav.av = mv.visitParameterAnnotation(parameter, desc, visible);\n+        }\n+        return tav;\n+    }\n+\n+    public void visitCode() {\n+        if (mv != null) {\n+            mv.visitCode();\n+        }\n+    }\n+\n+    public void visitFrame(\n+        final int type,\n+        final int nLocal,\n+        final Object[] local,\n+        final int nStack,\n+        final Object[] stack)\n+    {\n+        buf.setLength(0);\n+        buf.append(ltab);\n+        buf.append(\"FRAME \");\n+        switch (type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                buf.append(\"FULL [\");\n+                appendFrameTypes(nLocal, local);\n+                buf.append(\"] [\");\n+                appendFrameTypes(nStack, stack);\n+                buf.append(']');\n+                break;\n+            case Opcodes.F_APPEND:\n+                buf.append(\"APPEND [\");\n+                appendFrameTypes(nLocal, local);\n+                buf.append(']');\n+                break;\n+            case Opcodes.F_CHOP:\n+                buf.append(\"CHOP \").append(nLocal);\n+                break;\n+            case Opcodes.F_SAME:\n+                buf.append(\"SAME\");\n+                break;\n+            case Opcodes.F_SAME1:\n+                buf.append(\"SAME1 \");\n+                appendFrameTypes(1, stack);\n+                break;\n+        }\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitFrame(type, nLocal, local, nStack, stack);\n+        }\n+    }\n+\n+    public void visitInsn(final int opcode) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(OPCODES[opcode]).append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitInsn(opcode);\n+        }\n+    }\n+\n+    public void visitIntInsn(final int opcode, final int operand) {\n+        buf.setLength(0);\n+        buf.append(tab2)\n+                .append(OPCODES[opcode])\n+                .append(' ')\n+                .append(opcode == Opcodes.NEWARRAY\n+                        ? TYPES[operand]\n+                        : Integer.toString(operand))\n+                .append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitIntInsn(opcode, operand);\n+        }\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        buf.setLength(0);\n+        buf.append(tab2)\n+                .append(OPCODES[opcode])\n+                .append(' ')\n+                .append(var)\n+                .append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitVarInsn(opcode, var);\n+        }\n+    }\n+\n+    public void visitTypeInsn(final int opcode, final String type) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(OPCODES[opcode]).append(' ');\n+        appendDescriptor(INTERNAL_NAME, type);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitTypeInsn(opcode, type);\n+        }\n+    }\n+\n+    public void visitFieldInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append(OPCODES[opcode]).append(' ');\n+        appendDescriptor(INTERNAL_NAME, owner);\n+        buf.append('.').append(name).append(\" : \");\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitFieldInsn(opcode, owner, name, desc);\n+        }\n+    }\n+\n+    public void visitMethodInsn(\n+        final int opcode,\n+        final String owner,\n+        final String name,\n+        final String desc)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append(OPCODES[opcode]).append(' ');\n+        appendDescriptor(INTERNAL_NAME, owner);\n+        buf.append('.').append(name).append(' ');\n+        appendDescriptor(METHOD_DESCRIPTOR, desc);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitMethodInsn(opcode, owner, name, desc);\n+        }\n+    }\n+\n+    public void visitJumpInsn(final int opcode, final Label label) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(OPCODES[opcode]).append(' ');\n+        appendLabel(label);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitJumpInsn(opcode, label);\n+        }\n+    }\n+\n+    public void visitLabel(final Label label) {\n+        buf.setLength(0);\n+        buf.append(ltab);\n+        appendLabel(label);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitLabel(label);\n+        }\n+    }\n+\n+    public void visitLdcInsn(final Object cst) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"LDC \");\n+        if (cst instanceof String) {\n+            AbstractVisitor.appendString(buf, (String) cst);\n+        } else if (cst instanceof Type) {\n+            buf.append(((Type) cst).getDescriptor()).append(\".class\");\n+        } else {\n+            buf.append(cst);\n+        }\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitLdcInsn(cst);\n+        }\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        buf.setLength(0);\n+        buf.append(tab2)\n+                .append(\"IINC \")\n+                .append(var)\n+                .append(' ')\n+                .append(increment)\n+                .append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitIincInsn(var, increment);\n+        }\n+    }\n+\n+    public void visitTableSwitchInsn(\n+        final int min,\n+        final int max,\n+        final Label dflt,\n+        final Label[] labels)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"TABLESWITCH\\n\");\n+        for (int i = 0; i < labels.length; ++i) {\n+            buf.append(tab3).append(min + i).append(\": \");\n+            appendLabel(labels[i]);\n+            buf.append('\\n');\n+        }\n+        buf.append(tab3).append(\"default: \");\n+        appendLabel(dflt);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitTableSwitchInsn(min, max, dflt, labels);\n+        }\n+    }\n+\n+    public void visitLookupSwitchInsn(\n+        final Label dflt,\n+        final int[] keys,\n+        final Label[] labels)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"LOOKUPSWITCH\\n\");\n+        for (int i = 0; i < labels.length; ++i) {\n+            buf.append(tab3).append(keys[i]).append(\": \");\n+            appendLabel(labels[i]);\n+            buf.append('\\n');\n+        }\n+        buf.append(tab3).append(\"default: \");\n+        appendLabel(dflt);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitLookupSwitchInsn(dflt, keys, labels);\n+        }\n+    }\n+\n+    public void visitMultiANewArrayInsn(final String desc, final int dims) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"MULTIANEWARRAY \");\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append(' ').append(dims).append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitMultiANewArrayInsn(desc, dims);\n+        }\n+    }\n+\n+    public void visitTryCatchBlock(\n+        final Label start,\n+        final Label end,\n+        final Label handler,\n+        final String type)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"TRYCATCHBLOCK \");\n+        appendLabel(start);\n+        buf.append(' ');\n+        appendLabel(end);\n+        buf.append(' ');\n+        appendLabel(handler);\n+        buf.append(' ');\n+        appendDescriptor(INTERNAL_NAME, type);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitTryCatchBlock(start, end, handler, type);\n+        }\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"LOCALVARIABLE \").append(name).append(' ');\n+        appendDescriptor(FIELD_DESCRIPTOR, desc);\n+        buf.append(' ');\n+        appendLabel(start);\n+        buf.append(' ');\n+        appendLabel(end);\n+        buf.append(' ').append(index).append('\\n');\n+\n+        if (signature != null) {\n+            buf.append(tab2);\n+            appendDescriptor(FIELD_SIGNATURE, signature);\n+\n+            TraceSignatureVisitor sv = new TraceSignatureVisitor(0);\n+            SignatureReader r = new SignatureReader(signature);\n+            r.acceptType(sv);\n+            buf.append(tab2)\n+                    .append(\"// declaration: \")\n+                    .append(sv.getDeclaration())\n+                    .append('\\n');\n+        }\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitLocalVariable(name, desc, signature, start, end, index);\n+        }\n+    }\n+\n+    public void visitLineNumber(final int line, final Label start) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"LINENUMBER \").append(line).append(' ');\n+        appendLabel(start);\n+        buf.append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitLineNumber(line, start);\n+        }\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"MAXSTACK = \").append(maxStack).append('\\n');\n+        text.add(buf.toString());\n+\n+        buf.setLength(0);\n+        buf.append(tab2).append(\"MAXLOCALS = \").append(maxLocals).append('\\n');\n+        text.add(buf.toString());\n+\n+        if (mv != null) {\n+            mv.visitMaxs(maxStack, maxLocals);\n+        }\n+    }\n+\n+    public void visitEnd() {\n+        super.visitEnd();\n+\n+        if (mv != null) {\n+            mv.visitEnd();\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Utility methods\n+    // ------------------------------------------------------------------------\n+\n+    private void appendFrameTypes(final int n, final Object[] o) {\n+        for (int i = 0; i < n; ++i) {\n+            if (i > 0) {\n+                buf.append(' ');\n+            }\n+            if (o[i] instanceof String) {\n+                String desc = (String) o[i];\n+                if (desc.startsWith(\"[\")) {\n+                    appendDescriptor(FIELD_DESCRIPTOR, desc);\n+                } else {\n+                    appendDescriptor(INTERNAL_NAME, desc);\n+                }\n+            } else if (o[i] instanceof Integer) {\n+                switch (((Integer) o[i]).intValue()) {\n+                    case 0:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"T\");\n+                        break;\n+                    case 1:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"I\");\n+                        break;\n+                    case 2:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"F\");\n+                        break;\n+                    case 3:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"D\");\n+                        break;\n+                    case 4:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"J\");\n+                        break;\n+                    case 5:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"N\");\n+                        break;\n+                    case 6:\n+                        appendDescriptor(FIELD_DESCRIPTOR, \"U\");\n+                        break;\n+                }\n+            } else {\n+                appendLabel((Label) o[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Appends the name of the given label to {@link #buf buf}. Creates a new\n+     * label name if the given label does not yet have one.\n+     * \n+     * @param l a label.\n+     */\n+    protected void appendLabel(final Label l) {\n+        String name = (String) labelNames.get(l);\n+        if (name == null) {\n+            name = \"L\" + labelNames.size();\n+            labelNames.put(l, name);\n+        }\n+        buf.append(name);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/TraceSignatureVisitor.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.signature.SignatureVisitor;\n+\n+/**\n+ * A {@link SignatureVisitor} that prints a disassembled view of the signature\n+ * it visits.\n+ * \n+ * @author Eugene Kuleshov\n+ * @author Eric Bruneton\n+ */\n+public class TraceSignatureVisitor implements SignatureVisitor {\n+\n+    private final StringBuffer declaration;\n+\n+    private boolean isInterface;\n+\n+    private boolean seenFormalParameter;\n+\n+    private boolean seenInterfaceBound;\n+\n+    private boolean seenParameter;\n+\n+    private boolean seenInterface;\n+\n+    private StringBuffer returnType;\n+\n+    private StringBuffer exceptions;\n+\n+    /**\n+     * Stack used to keep track of class types that have arguments. Each element\n+     * of this stack is a boolean encoded in one bit. The top of the stack is\n+     * the lowest order bit. Pushing false = *2, pushing true = *2+1, popping =\n+     * /2.\n+     */\n+    private int argumentStack;\n+\n+    /**\n+     * Stack used to keep track of array class types. Each element of this stack\n+     * is a boolean encoded in one bit. The top of the stack is the lowest order\n+     * bit. Pushing false = *2, pushing true = *2+1, popping = /2.\n+     */\n+    private int arrayStack;\n+\n+    private String separator = \"\";\n+\n+    public TraceSignatureVisitor(final int access) {\n+        isInterface = (access & Opcodes.ACC_INTERFACE) != 0;\n+        this.declaration = new StringBuffer();\n+    }\n+\n+    private TraceSignatureVisitor(final StringBuffer buf) {\n+        this.declaration = buf;\n+    }\n+\n+    public void visitFormalTypeParameter(final String name) {\n+        declaration.append(seenFormalParameter ? \", \" : \"<\").append(name);\n+        seenFormalParameter = true;\n+        seenInterfaceBound = false;\n+    }\n+\n+    public SignatureVisitor visitClassBound() {\n+        separator = \" extends \";\n+        startType();\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitInterfaceBound() {\n+        separator = seenInterfaceBound ? \", \" : \" extends \";\n+        seenInterfaceBound = true;\n+        startType();\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitSuperclass() {\n+        endFormals();\n+        separator = \" extends \";\n+        startType();\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitInterface() {\n+        separator = seenInterface ? \", \" : isInterface\n+                ? \" extends \"\n+                : \" implements \";\n+        seenInterface = true;\n+        startType();\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitParameterType() {\n+        endFormals();\n+        if (seenParameter) {\n+            declaration.append(\", \");\n+        } else {\n+            seenParameter = true;\n+            declaration.append('(');\n+        }\n+        startType();\n+        return this;\n+    }\n+\n+    public SignatureVisitor visitReturnType() {\n+        endFormals();\n+        if (seenParameter) {\n+            seenParameter = false;\n+        } else {\n+            declaration.append('(');\n+        }\n+        declaration.append(')');\n+        returnType = new StringBuffer();\n+        return new TraceSignatureVisitor(returnType);\n+    }\n+\n+    public SignatureVisitor visitExceptionType() {\n+        if (exceptions == null) {\n+            exceptions = new StringBuffer();\n+        } else {\n+            exceptions.append(\", \");\n+        }\n+        // startType();\n+        return new TraceSignatureVisitor(exceptions);\n+    }\n+\n+    public void visitBaseType(final char descriptor) {\n+        switch (descriptor) {\n+            case 'V':\n+                declaration.append(\"void\");\n+                break;\n+            case 'B':\n+                declaration.append(\"byte\");\n+                break;\n+            case 'J':\n+                declaration.append(\"long\");\n+                break;\n+            case 'Z':\n+                declaration.append(\"boolean\");\n+                break;\n+            case 'I':\n+                declaration.append(\"int\");\n+                break;\n+            case 'S':\n+                declaration.append(\"short\");\n+                break;\n+            case 'C':\n+                declaration.append(\"char\");\n+                break;\n+            case 'F':\n+                declaration.append(\"float\");\n+                break;\n+            // case 'D':\n+            default:\n+                declaration.append(\"double\");\n+                break;\n+        }\n+        endType();\n+    }\n+\n+    public void visitTypeVariable(final String name) {\n+        declaration.append(name);\n+        endType();\n+    }\n+\n+    public SignatureVisitor visitArrayType() {\n+        startType();\n+        arrayStack |= 1;\n+        return this;\n+    }\n+\n+    public void visitClassType(final String name) {\n+        if (\"java/lang/Object\".equals(name)) {\n+            // Map<java.lang.Object,java.util.List>\n+            // or\n+            // abstract public V get(Object key); (seen in Dictionary.class)\n+            // should have Object\n+            // but java.lang.String extends java.lang.Object is unnecessary\n+            boolean needObjectClass = argumentStack % 2 != 0 || seenParameter;\n+            if (needObjectClass) {\n+                declaration.append(separator).append(name.replace('/', '.'));\n+            }\n+        } else {\n+            declaration.append(separator).append(name.replace('/', '.'));\n+        }\n+        separator = \"\";\n+        argumentStack *= 2;\n+    }\n+\n+    public void visitInnerClassType(final String name) {\n+        if (argumentStack % 2 != 0) {\n+            declaration.append('>');\n+        }\n+        argumentStack /= 2;\n+        declaration.append('.');\n+        declaration.append(separator).append(name.replace('/', '.'));\n+        separator = \"\";\n+        argumentStack *= 2;\n+    }\n+\n+    public void visitTypeArgument() {\n+        if (argumentStack % 2 == 0) {\n+            ++argumentStack;\n+            declaration.append('<');\n+        } else {\n+            declaration.append(\", \");\n+        }\n+        declaration.append('?');\n+    }\n+\n+    public SignatureVisitor visitTypeArgument(final char tag) {\n+        if (argumentStack % 2 == 0) {\n+            ++argumentStack;\n+            declaration.append('<');\n+        } else {\n+            declaration.append(\", \");\n+        }\n+\n+        if (tag == EXTENDS) {\n+            declaration.append(\"? extends \");\n+        } else if (tag == SUPER) {\n+            declaration.append(\"? super \");\n+        }\n+\n+        startType();\n+        return this;\n+    }\n+\n+    public void visitEnd() {\n+        if (argumentStack % 2 != 0) {\n+            declaration.append('>');\n+        }\n+        argumentStack /= 2;\n+        endType();\n+    }\n+\n+    public String getDeclaration() {\n+        return declaration.toString();\n+    }\n+\n+    public String getReturnType() {\n+        return returnType == null ? null : returnType.toString();\n+    }\n+\n+    public String getExceptions() {\n+        return exceptions == null ? null : exceptions.toString();\n+    }\n+\n+    // -----------------------------------------------\n+\n+    private void endFormals() {\n+        if (seenFormalParameter) {\n+            declaration.append('>');\n+            seenFormalParameter = false;\n+        }\n+    }\n+\n+    private void startType() {\n+        arrayStack *= 2;\n+    }\n+\n+    private void endType() {\n+        if (arrayStack % 2 == 0) {\n+            arrayStack /= 2;\n+        } else {\n+            while (arrayStack % 2 != 0) {\n+                arrayStack /= 2;\n+                declaration.append(\"[]\");\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/asm/util/Traceable.java\n+/**\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2007 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.asm.util;\n+\n+import java.util.Map;\n+\n+/**\n+ * An attribute that can print eadable representation of the attribute.\n+ * \n+ * Implementation should construct readable output from an attribute data\n+ * structures for current attribute state. Such representation could be used in\n+ * unit test assertions.\n+ * \n+ * @author Eugene Kuleshov\n+ */\n+public interface Traceable {\n+\n+    /**\n+     * Build a human readable representation of the attribute.\n+     * \n+     * @param buf A buffer used for printing Java code.\n+     * @param labelNames map of label instances to their names.\n+     */\n+    void trace(StringBuffer buf, Map labelNames);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BeanCopier.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Chris Nokleberg\n+ */\n+abstract public class BeanCopier\n+{\n+    private static final BeanCopierKey KEY_FACTORY =\n+      (BeanCopierKey)KeyFactory.create(BeanCopierKey.class);\n+    private static final Type CONVERTER =\n+      TypeUtils.parseType(\"org.mockito.cglib.core.Converter\");\n+    private static final Type BEAN_COPIER =\n+      TypeUtils.parseType(\"org.mockito.cglib.beans.BeanCopier\");\n+    private static final Signature COPY =\n+      new Signature(\"copy\", Type.VOID_TYPE, new Type[]{ Constants.TYPE_OBJECT, Constants.TYPE_OBJECT, CONVERTER });\n+    private static final Signature CONVERT =\n+      TypeUtils.parseSignature(\"Object convert(Object, Class, Object)\");\n+    \n+    interface BeanCopierKey {\n+        public Object newInstance(String source, String target, boolean useConverter);\n+    }\n+\n+    public static BeanCopier create(Class source, Class target, boolean useConverter) {\n+        Generator gen = new Generator();\n+        gen.setSource(source);\n+        gen.setTarget(target);\n+        gen.setUseConverter(useConverter);\n+        return gen.create();\n+    }\n+\n+    abstract public void copy(Object from, Object to, Converter converter);\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(BeanCopier.class.getName());\n+        private Class source;\n+        private Class target;\n+        private boolean useConverter;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        public void setSource(Class source) {\n+            if(!Modifier.isPublic(source.getModifiers())){ \n+               setNamePrefix(source.getName());\n+            }\n+            this.source = source;\n+        }\n+        \n+        public void setTarget(Class target) {\n+            if(!Modifier.isPublic(target.getModifiers())){ \n+               setNamePrefix(target.getName());\n+            }\n+          \n+            this.target = target;\n+        }\n+\n+        public void setUseConverter(boolean useConverter) {\n+            this.useConverter = useConverter;\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return source.getClassLoader();\n+        }\n+\n+        public BeanCopier create() {\n+            Object key = KEY_FACTORY.newInstance(source.getName(), target.getName(), useConverter);\n+            return (BeanCopier)super.create(key);\n+        }\n+\n+        public void generateClass(ClassVisitor v) {\n+            Type sourceType = Type.getType(source);\n+            Type targetType = Type.getType(target);\n+            ClassEmitter ce = new ClassEmitter(v);\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           BEAN_COPIER,\n+                           null,\n+                           Constants.SOURCE_FILE);\n+\n+            EmitUtils.null_constructor(ce);\n+            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, COPY, null);\n+            PropertyDescriptor[] getters = ReflectUtils.getBeanGetters(source);\n+            PropertyDescriptor[] setters = ReflectUtils.getBeanGetters(target);\n+\n+            Map names = new HashMap();\n+            for (int i = 0; i < getters.length; i++) {\n+                names.put(getters[i].getName(), getters[i]);\n+            }\n+            Local targetLocal = e.make_local();\n+            Local sourceLocal = e.make_local();\n+            if (useConverter) {\n+                e.load_arg(1);\n+                e.checkcast(targetType);\n+                e.store_local(targetLocal);\n+                e.load_arg(0);                \n+                e.checkcast(sourceType);\n+                e.store_local(sourceLocal);\n+            } else {\n+                e.load_arg(1);\n+                e.checkcast(targetType);\n+                e.load_arg(0);\n+                e.checkcast(sourceType);\n+            }\n+            for (int i = 0; i < setters.length; i++) {\n+                PropertyDescriptor setter = setters[i];\n+                PropertyDescriptor getter = (PropertyDescriptor)names.get(setter.getName());\n+                if (getter != null) {\n+                    MethodInfo read = ReflectUtils.getMethodInfo(getter.getReadMethod());\n+                    MethodInfo write = ReflectUtils.getMethodInfo(setter.getWriteMethod());\n+                    if (useConverter) {\n+                        Type setterType = write.getSignature().getArgumentTypes()[0];\n+                        e.load_local(targetLocal);\n+                        e.load_arg(2);\n+                        e.load_local(sourceLocal);\n+                        e.invoke(read);\n+                        e.box(read.getSignature().getReturnType());\n+                        EmitUtils.load_class(e, setterType);\n+                        e.push(write.getSignature().getName());\n+                        e.invoke_interface(CONVERTER, CONVERT);\n+                        e.unbox_or_zero(setterType);\n+                        e.invoke(write);\n+                    } else if (compatible(getter, setter)) {\n+                        e.dup2();\n+                        e.invoke(read);\n+                        e.invoke(write);\n+                    }\n+                }\n+            }\n+            e.return_value();\n+            e.end_method();\n+            ce.end_class();\n+        }\n+\n+        private static boolean compatible(PropertyDescriptor getter, PropertyDescriptor setter) {\n+            // TODO: allow automatic widening conversions?\n+            return setter.getPropertyType().isAssignableFrom(getter.getPropertyType());\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ReflectUtils.newInstance(type);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return instance;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BeanGenerator.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.beans.PropertyDescriptor;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * @author Juozas Baliuka, Chris Nokleberg\n+ */\n+public class BeanGenerator extends AbstractClassGenerator\n+{\n+    private static final Source SOURCE = new Source(BeanGenerator.class.getName());\n+    private static final BeanGeneratorKey KEY_FACTORY =\n+      (BeanGeneratorKey)KeyFactory.create(BeanGeneratorKey.class);\n+    \n+    interface BeanGeneratorKey {\n+        public Object newInstance(String superclass, Map props);\n+    }\n+\n+    private Class superclass;\n+    private Map props = new HashMap();\n+    private boolean classOnly;\n+\n+    public BeanGenerator() {\n+        super(SOURCE);\n+    }\n+\n+    /**\n+     * Set the class which the generated class will extend. The class\n+     * must not be declared as final, and must have a non-private\n+     * no-argument constructor.\n+     * @param superclass class to extend, or null to extend Object\n+     */\n+    public void setSuperclass(Class superclass) {\n+        if (superclass != null && superclass.equals(Object.class)) {\n+            superclass = null;\n+        }\n+        this.superclass = superclass;\n+    }\n+\n+    public void addProperty(String name, Class type) {\n+        if (props.containsKey(name)) {\n+            throw new IllegalArgumentException(\"Duplicate property name \\\"\" + name + \"\\\"\");\n+        }\n+        props.put(name, Type.getType(type));\n+    }\n+\n+    protected ClassLoader getDefaultClassLoader() {\n+        if (superclass != null) {\n+            return superclass.getClassLoader();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Object create() {\n+        classOnly = false;\n+        return createHelper();\n+    }\n+\n+    public Object createClass() {\n+        classOnly = true;\n+        return createHelper();\n+    }\n+\n+    private Object createHelper() {\n+        if (superclass != null) {\n+            setNamePrefix(superclass.getName());\n+        }\n+        String superName = (superclass != null) ? superclass.getName() : \"java.lang.Object\";\n+        Object key = KEY_FACTORY.newInstance(superName, props);\n+        return super.create(key);\n+    }\n+\n+    public void generateClass(ClassVisitor v) throws Exception {\n+        int size = props.size();\n+        String[] names = (String[])props.keySet().toArray(new String[size]);\n+        Type[] types = new Type[size];\n+        for (int i = 0; i < size; i++) {\n+            types[i] = (Type)props.get(names[i]);\n+        }\n+        ClassEmitter ce = new ClassEmitter(v);\n+        ce.begin_class(Constants.V1_2,\n+                       Constants.ACC_PUBLIC,\n+                       getClassName(),\n+                       superclass != null ? Type.getType(superclass) : Constants.TYPE_OBJECT,\n+                       null,\n+                       null);\n+        EmitUtils.null_constructor(ce);\n+        EmitUtils.add_properties(ce, names, types);\n+        ce.end_class();\n+    }\n+\n+    protected Object firstInstance(Class type) {\n+        if (classOnly) {\n+            return type;\n+        } else {\n+            return ReflectUtils.newInstance(type);\n+        }\n+    }\n+\n+    protected Object nextInstance(Object instance) {\n+        Class protoclass = (instance instanceof Class) ? (Class)instance : instance.getClass();\n+        if (classOnly) {\n+            return protoclass;\n+        } else {\n+            return ReflectUtils.newInstance(protoclass);\n+        }\n+    }\n+\n+    public static void addProperties(BeanGenerator gen, Map props) {\n+        for (Iterator it = props.keySet().iterator(); it.hasNext();) {\n+            String name = (String)it.next();\n+            gen.addProperty(name, (Class)props.get(name));\n+        }\n+    }\n+\n+    public static void addProperties(BeanGenerator gen, Class type) {\n+        addProperties(gen, ReflectUtils.getBeanProperties(type));\n+    }\n+\n+    public static void addProperties(BeanGenerator gen, PropertyDescriptor[] descriptors) {\n+        for (int i = 0; i < descriptors.length; i++) {\n+            gen.addProperty(descriptors[i].getName(), descriptors[i].getPropertyType());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BeanMap.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.beans.*;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * A <code>Map</code>-based view of a JavaBean.  The default set of keys is the\n+ * union of all property names (getters or setters). An attempt to set\n+ * a read-only property will be ignored, and write-only properties will\n+ * be returned as <code>null</code>. Removal of objects is not a\n+ * supported (the key set is fixed).\n+ * @author Chris Nokleberg\n+ */\n+abstract public class BeanMap implements Map {\n+    /**\n+     * Limit the properties reflected in the key set of the map\n+     * to readable properties.\n+     * @see BeanMap.Generator#setRequire\n+     */\n+    public static final int REQUIRE_GETTER = 1;\n+\n+    /**\n+     * Limit the properties reflected in the key set of the map\n+     * to writable properties.\n+     * @see BeanMap.Generator#setRequire\n+     */\n+    public static final int REQUIRE_SETTER = 2;\n+    \n+    /**\n+     * Helper method to create a new <code>BeanMap</code>.  For finer\n+     * control over the generated instance, use a new instance of\n+     * <code>BeanMap.Generator</code> instead of this static method.\n+     * @param bean the JavaBean underlying the map\n+     * @return a new <code>BeanMap</code> instance\n+     */\n+    public static BeanMap create(Object bean) {\n+        Generator gen = new Generator();\n+        gen.setBean(bean);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(BeanMap.class.getName());\n+\n+        private static final BeanMapKey KEY_FACTORY =\n+          (BeanMapKey)KeyFactory.create(BeanMapKey.class, KeyFactory.CLASS_BY_NAME);\n+\n+        interface BeanMapKey {\n+            public Object newInstance(Class type, int require);\n+        }\n+        \n+        private Object bean;\n+        private Class beanClass;\n+        private int require;\n+        \n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        /**\n+         * Set the bean that the generated map should reflect. The bean may be swapped\n+         * out for another bean of the same type using {@link #setBean}.\n+         * Calling this method overrides any value previously set using {@link #setBeanClass}.\n+         * You must call either this method or {@link #setBeanClass} before {@link #create}.\n+         * @param bean the initial bean\n+         */\n+        public void setBean(Object bean) {\n+            this.bean = bean;\n+            if (bean != null)\n+                beanClass = bean.getClass();\n+        }\n+\n+        /**\n+         * Set the class of the bean that the generated map should support.\n+         * You must call either this method or {@link #setBeanClass} before {@link #create}.\n+         * @param beanClass the class of the bean\n+         */\n+        public void setBeanClass(Class beanClass) {\n+            this.beanClass = beanClass;\n+        }\n+\n+        /**\n+         * Limit the properties reflected by the generated map.\n+         * @param require any combination of {@link #REQUIRE_GETTER} and\n+         * {@link #REQUIRE_SETTER}; default is zero (any property allowed)\n+         */\n+        public void setRequire(int require) {\n+            this.require = require;\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return beanClass.getClassLoader();\n+        }\n+\n+        /**\n+         * Create a new instance of the <code>BeanMap</code>. An existing\n+         * generated class will be reused if possible.\n+         */\n+        public BeanMap create() {\n+            if (beanClass == null)\n+                throw new IllegalArgumentException(\"Class of bean unknown\");\n+            setNamePrefix(beanClass.getName());\n+            return (BeanMap)super.create(KEY_FACTORY.newInstance(beanClass, require));\n+        }\n+\n+        public void generateClass(ClassVisitor v) throws Exception {\n+            new BeanMapEmitter(v, getClassName(), beanClass, require);\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ((BeanMap)ReflectUtils.newInstance(type)).newInstance(bean);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return ((BeanMap)instance).newInstance(bean);\n+        }\n+    }\n+\n+    /**\n+     * Create a new <code>BeanMap</code> instance using the specified bean.\n+     * This is faster than using the {@link #create} static method.\n+     * @param bean the JavaBean underlying the map\n+     * @return a new <code>BeanMap</code> instance\n+     */\n+    abstract public BeanMap newInstance(Object bean);\n+\n+    /**\n+     * Get the type of a property.\n+     * @param name the name of the JavaBean property\n+     * @return the type of the property, or null if the property does not exist\n+     */\n+    abstract public Class getPropertyType(String name);\n+\n+    protected Object bean;\n+\n+    protected BeanMap() {\n+    }\n+\n+    protected BeanMap(Object bean) {\n+        setBean(bean);\n+    }\n+\n+    public Object get(Object key) {\n+        return get(bean, key);\n+    }\n+\n+    public Object put(Object key, Object value) {\n+        return put(bean, key, value);\n+    }\n+\n+    /**\n+     * Get the property of a bean. This allows a <code>BeanMap</code>\n+     * to be used statically for multiple beans--the bean instance tied to the\n+     * map is ignored and the bean passed to this method is used instead.\n+     * @param bean the bean to query; must be compatible with the type of\n+     * this <code>BeanMap</code>\n+     * @param key must be a String\n+     * @return the current value, or null if there is no matching property\n+     */\n+    abstract public Object get(Object bean, Object key);\n+\n+    /**\n+     * Set the property of a bean. This allows a <code>BeanMap</code>\n+     * to be used statically for multiple beans--the bean instance tied to the\n+     * map is ignored and the bean passed to this method is used instead.\n+     * @param key must be a String\n+     * @return the old value, if there was one, or null\n+     */\n+    abstract public Object put(Object bean, Object key, Object value);\n+\n+    /**\n+     * Change the underlying bean this map should use.\n+     * @param bean the new JavaBean\n+     * @see #getBean\n+     */\n+    public void setBean(Object bean) {\n+        this.bean = bean;\n+    }\n+\n+    /**\n+     * Return the bean currently in use by this map.\n+     * @return the current JavaBean\n+     * @see #setBean\n+     */\n+    public Object getBean() {\n+        return bean;\n+    }\n+\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return keySet().contains(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        for (Iterator it = keySet().iterator(); it.hasNext();) {\n+            Object v = get(it.next());\n+            if (((value == null) && (v == null)) || value.equals(v))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public int size() {\n+        return keySet().size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    public Object remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void putAll(Map t) {\n+        for (Iterator it = t.keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            put(key, t.get(key));\n+        }\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !(o instanceof Map)) {\n+            return false;\n+        }\n+        Map other = (Map)o;\n+        if (size() != other.size()) {\n+            return false;\n+        }\n+        for (Iterator it = keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            if (!other.containsKey(key)) {\n+                return false;\n+            }\n+            Object v1 = get(key);\n+            Object v2 = other.get(key);\n+            if (!((v1 == null) ? v2 == null : v1.equals(v2))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public int hashCode() {\n+        int code = 0;\n+        for (Iterator it = keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            Object value = get(key);\n+            code += ((key == null) ? 0 : key.hashCode()) ^\n+                ((value == null) ? 0 : value.hashCode());\n+        }\n+        return code;\n+    }\n+\n+    // TODO: optimize\n+    public Set entrySet() {\n+        HashMap copy = new HashMap();\n+        for (Iterator it = keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            copy.put(key, get(key));\n+        }\n+        return Collections.unmodifiableMap(copy).entrySet();\n+    }\n+\n+    public Collection values() {\n+        Set keys = keySet();\n+        List values = new ArrayList(keys.size());\n+        for (Iterator it = keys.iterator(); it.hasNext();) {\n+            values.add(get(it.next()));\n+        }\n+        return Collections.unmodifiableCollection(values);\n+    }\n+\n+    /*\n+     * @see java.util.AbstractMap#toString\n+     */\n+    public String toString()\n+    {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('{');\n+        for (Iterator it = keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            sb.append(key);\n+            sb.append('=');\n+            sb.append(get(key));\n+            if (it.hasNext()) {\n+                sb.append(\", \");\n+            }\n+        }\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BeanMapEmitter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.beans.*;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class BeanMapEmitter extends ClassEmitter {\n+    private static final Type BEAN_MAP =\n+      TypeUtils.parseType(\"org.mockito.cglib.beans.BeanMap\");\n+    private static final Type FIXED_KEY_SET =\n+      TypeUtils.parseType(\"org.mockito.cglib.beans.FixedKeySet\");\n+    private static final Signature CSTRUCT_OBJECT =\n+      TypeUtils.parseConstructor(\"Object\");\n+    private static final Signature CSTRUCT_STRING_ARRAY =\n+      TypeUtils.parseConstructor(\"String[]\");\n+    private static final Signature BEAN_MAP_GET =\n+      TypeUtils.parseSignature(\"Object get(Object, Object)\");\n+    private static final Signature BEAN_MAP_PUT =\n+      TypeUtils.parseSignature(\"Object put(Object, Object, Object)\");\n+    private static final Signature KEY_SET =\n+      TypeUtils.parseSignature(\"java.util.Set keySet()\");\n+    private static final Signature NEW_INSTANCE =\n+      new Signature(\"newInstance\", BEAN_MAP, new Type[]{ Constants.TYPE_OBJECT });\n+    private static final Signature GET_PROPERTY_TYPE =\n+      TypeUtils.parseSignature(\"Class getPropertyType(String)\");\n+\n+    public BeanMapEmitter(ClassVisitor v, String className, Class type, int require) {\n+        super(v);\n+\n+        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, BEAN_MAP, null, Constants.SOURCE_FILE);\n+        EmitUtils.null_constructor(this);\n+        EmitUtils.factory_method(this, NEW_INSTANCE);\n+        generateConstructor();\n+            \n+        Map getters = makePropertyMap(ReflectUtils.getBeanGetters(type));\n+        Map setters = makePropertyMap(ReflectUtils.getBeanSetters(type));\n+        Map allProps = new HashMap();\n+        allProps.putAll(getters);\n+        allProps.putAll(setters);\n+\n+        if (require != 0) {\n+            for (Iterator it = allProps.keySet().iterator(); it.hasNext();) {\n+                String name = (String)it.next();\n+                if ((((require & BeanMap.REQUIRE_GETTER) != 0) && !getters.containsKey(name)) ||\n+                    (((require & BeanMap.REQUIRE_SETTER) != 0) && !setters.containsKey(name))) {\n+                    it.remove();\n+                    getters.remove(name);\n+                    setters.remove(name);\n+                }\n+            }\n+        }\n+        generateGet(type, getters);\n+        generatePut(type, setters);\n+\n+        String[] allNames = getNames(allProps);\n+        generateKeySet(allNames);\n+        generateGetPropertyType(allProps, allNames);\n+        end_class();\n+    }\n+\n+    private Map makePropertyMap(PropertyDescriptor[] props) {\n+        Map names = new HashMap();\n+        for (int i = 0; i < props.length; i++) {\n+            names.put(((PropertyDescriptor)props[i]).getName(), props[i]);\n+        }\n+        return names;\n+    }\n+\n+    private String[] getNames(Map propertyMap) {\n+        return (String[])propertyMap.keySet().toArray(new String[propertyMap.size()]);\n+    }\n+\n+    private void generateConstructor() {\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT, null);\n+        e.load_this();\n+        e.load_arg(0);\n+        e.super_invoke_constructor(CSTRUCT_OBJECT);\n+        e.return_value();\n+        e.end_method();\n+    }\n+        \n+    private void generateGet(Class type, final Map getters) {\n+        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, BEAN_MAP_GET, null);\n+        e.load_arg(0);\n+        e.checkcast(Type.getType(type));\n+        e.load_arg(1);\n+        e.checkcast(Constants.TYPE_STRING);\n+        EmitUtils.string_switch(e, getNames(getters), Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                PropertyDescriptor pd = (PropertyDescriptor)getters.get(key);\n+                MethodInfo method = ReflectUtils.getMethodInfo(pd.getReadMethod());\n+                e.invoke(method);\n+                e.box(method.getSignature().getReturnType());\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.aconst_null();\n+                e.return_value();\n+            }\n+        });\n+        e.end_method();\n+    }\n+\n+    private void generatePut(Class type, final Map setters) {\n+        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, BEAN_MAP_PUT, null);\n+        e.load_arg(0);\n+        e.checkcast(Type.getType(type));\n+        e.load_arg(1);\n+        e.checkcast(Constants.TYPE_STRING);\n+        EmitUtils.string_switch(e, getNames(setters), Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                PropertyDescriptor pd = (PropertyDescriptor)setters.get(key);\n+                if (pd.getReadMethod() == null) {\n+                    e.aconst_null();\n+                } else {\n+                    MethodInfo read = ReflectUtils.getMethodInfo(pd.getReadMethod());\n+                    e.dup();\n+                    e.invoke(read);\n+                    e.box(read.getSignature().getReturnType());\n+                }\n+                e.swap(); // move old value behind bean\n+                e.load_arg(2); // new value\n+                MethodInfo write = ReflectUtils.getMethodInfo(pd.getWriteMethod());\n+                e.unbox(write.getSignature().getArgumentTypes()[0]);\n+                e.invoke(write);\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                // fall-through\n+            }\n+        });\n+        e.aconst_null();\n+        e.return_value();\n+        e.end_method();\n+    }\n+            \n+    private void generateKeySet(String[] allNames) {\n+        // static initializer\n+        declare_field(Constants.ACC_STATIC | Constants.ACC_PRIVATE, \"keys\", FIXED_KEY_SET, null);\n+\n+        CodeEmitter e = begin_static();\n+        e.new_instance(FIXED_KEY_SET);\n+        e.dup();\n+        EmitUtils.push_array(e, allNames);\n+        e.invoke_constructor(FIXED_KEY_SET, CSTRUCT_STRING_ARRAY);\n+        e.putfield(\"keys\");\n+        e.return_value();\n+        e.end_method();\n+\n+        // keySet\n+        e = begin_method(Constants.ACC_PUBLIC, KEY_SET, null);\n+        e.load_this();\n+        e.getfield(\"keys\");\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void generateGetPropertyType(final Map allProps, String[] allNames) {\n+        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_TYPE, null);\n+        e.load_arg(0);\n+        EmitUtils.string_switch(e, allNames, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                PropertyDescriptor pd = (PropertyDescriptor)allProps.get(key);\n+                EmitUtils.load_class(e, Type.getType(pd.getPropertyType()));\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.aconst_null();\n+                e.return_value();\n+            }\n+        });\n+        e.end_method();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BulkBean.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * @author Juozas Baliuka\n+ */\n+abstract public class BulkBean\n+{\n+    private static final BulkBeanKey KEY_FACTORY =\n+      (BulkBeanKey)KeyFactory.create(BulkBeanKey.class);\n+    \n+    interface BulkBeanKey {\n+        public Object newInstance(String target, String[] getters, String[] setters, String[] types);\n+    }\n+    \n+    protected Class target;\n+    protected String[] getters, setters;\n+    protected Class[] types;\n+    \n+    protected BulkBean() { }\n+    \n+    abstract public void getPropertyValues(Object bean, Object[] values);\n+    abstract public void setPropertyValues(Object bean, Object[] values);\n+\n+    public Object[] getPropertyValues(Object bean) {\n+        Object[] values = new Object[getters.length];\n+        getPropertyValues(bean, values);\n+        return values;\n+    }\n+    \n+    public Class[] getPropertyTypes() {\n+        return (Class[])types.clone();\n+    }\n+    \n+    public String[] getGetters() {\n+        return (String[])getters.clone();\n+    }\n+    \n+    public String[] getSetters() {\n+        return (String[])setters.clone();\n+    }\n+\n+    public static BulkBean create(Class target, String[] getters, String[] setters, Class[] types) {\n+        Generator gen = new Generator();\n+        gen.setTarget(target);\n+        gen.setGetters(getters);\n+        gen.setSetters(setters);\n+        gen.setTypes(types);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(BulkBean.class.getName());\n+        private Class target;\n+        private String[] getters;\n+        private String[] setters;\n+        private Class[] types;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        public void setTarget(Class target) {\n+            this.target = target;\n+        }\n+\n+        public void setGetters(String[] getters) {\n+            this.getters = getters;\n+        }\n+\n+        public void setSetters(String[] setters) {\n+            this.setters = setters;\n+        }\n+\n+        public void setTypes(Class[] types) {\n+            this.types = types;\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return target.getClassLoader();\n+        }\n+\n+        public BulkBean create() {\n+            setNamePrefix(target.getName());\n+            String targetClassName = target.getName();\n+            String[] typeClassNames = ReflectUtils.getNames(types);\n+            Object key = KEY_FACTORY.newInstance(targetClassName, getters, setters, typeClassNames);\n+            return (BulkBean)super.create(key);\n+        }\n+\n+        public void generateClass(ClassVisitor v) throws Exception {\n+            new BulkBeanEmitter(v, getClassName(), target, getters, setters, types);\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            BulkBean instance = (BulkBean)ReflectUtils.newInstance(type);\n+            instance.target = target;\n+                    \n+            int length = getters.length;\n+            instance.getters = new String[length];\n+            System.arraycopy(getters, 0, instance.getters, 0, length);\n+                    \n+            instance.setters = new String[length];\n+            System.arraycopy(setters, 0, instance.setters, 0, length);\n+                    \n+            instance.types = new Class[types.length];\n+            System.arraycopy(types, 0, instance.types, 0, types.length);\n+\n+            return instance;\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return instance;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BulkBeanEmitter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+    \n+class BulkBeanEmitter extends ClassEmitter {\n+    private static final Signature GET_PROPERTY_VALUES =\n+      TypeUtils.parseSignature(\"void getPropertyValues(Object, Object[])\");\n+    private static final Signature SET_PROPERTY_VALUES =\n+      TypeUtils.parseSignature(\"void setPropertyValues(Object, Object[])\");\n+    private static final Signature CSTRUCT_EXCEPTION =\n+      TypeUtils.parseConstructor(\"Throwable, int\");\n+    private static final Type BULK_BEAN =\n+      TypeUtils.parseType(\"org.mockito.cglib.beans.BulkBean\");\n+    private static final Type BULK_BEAN_EXCEPTION =\n+      TypeUtils.parseType(\"org.mockito.cglib.beans.BulkBeanException\");\n+        \n+    public BulkBeanEmitter(ClassVisitor v,\n+                           String className,\n+                           Class target,\n+                           String[] getterNames,\n+                           String[] setterNames,\n+                           Class[] types) {\n+        super(v);\n+\n+        Method[] getters = new Method[getterNames.length];\n+        Method[] setters = new Method[setterNames.length];\n+        validate(target, getterNames, setterNames, types, getters, setters);\n+\n+        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, BULK_BEAN, null, Constants.SOURCE_FILE);\n+        EmitUtils.null_constructor(this);\n+        generateGet(target, getters);\n+        generateSet(target, setters);\n+        end_class();\n+    }\n+\n+    private void generateGet(final Class target, final Method[] getters) {\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, GET_PROPERTY_VALUES, null);\n+        if (getters.length >= 0) {\n+            e.load_arg(0);\n+            e.checkcast(Type.getType(target));\n+            Local bean = e.make_local();\n+            e.store_local(bean);\n+            for (int i = 0; i < getters.length; i++) {\n+                if (getters[i] != null) {\n+                    MethodInfo getter = ReflectUtils.getMethodInfo(getters[i]);\n+                    e.load_arg(1);\n+                    e.push(i);\n+                    e.load_local(bean);\n+                    e.invoke(getter);\n+                    e.box(getter.getSignature().getReturnType());\n+                    e.aastore();\n+                }\n+            }\n+        }\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void generateSet(final Class target, final Method[] setters) {\n+        // setPropertyValues\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SET_PROPERTY_VALUES, null);\n+        if (setters.length > 0) {\n+            Local index = e.make_local(Type.INT_TYPE);\n+            e.push(0);\n+            e.store_local(index);\n+            e.load_arg(0);\n+            e.checkcast(Type.getType(target));\n+            e.load_arg(1);\n+            Block handler = e.begin_block();\n+            int lastIndex = 0;\n+            for (int i = 0; i < setters.length; i++) {\n+                if (setters[i] != null) {\n+                    MethodInfo setter = ReflectUtils.getMethodInfo(setters[i]);\n+                    int diff = i - lastIndex;\n+                    if (diff > 0) {\n+                        e.iinc(index, diff);\n+                        lastIndex = i;\n+                    }\n+                    e.dup2();\n+                    e.aaload(i);\n+                    e.unbox(setter.getSignature().getArgumentTypes()[0]);\n+                    e.invoke(setter);\n+                }\n+            }\n+            handler.end();\n+            e.return_value();\n+            e.catch_exception(handler, Constants.TYPE_THROWABLE);\n+            e.new_instance(BULK_BEAN_EXCEPTION);\n+            e.dup_x1();\n+            e.swap();\n+            e.load_local(index);\n+            e.invoke_constructor(BULK_BEAN_EXCEPTION, CSTRUCT_EXCEPTION);\n+            e.athrow();\n+        } else {\n+            e.return_value();\n+        }\n+        e.end_method();\n+    }\n+    \n+    private static void validate(Class target,\n+                                 String[] getters,\n+                                 String[] setters,\n+                                 Class[] types,\n+                                 Method[] getters_out,\n+                                 Method[] setters_out) {\n+        int i = -1;\n+        if (setters.length != types.length || getters.length != types.length) {\n+            throw new BulkBeanException(\"accessor array length must be equal type array length\", i);\n+        }\n+        try {\n+            for (i = 0; i < types.length; i++) {\n+                if (getters[i] != null) {\n+                    Method method = ReflectUtils.findDeclaredMethod(target, getters[i], null);\n+                    if (method.getReturnType() != types[i]) {\n+                        throw new BulkBeanException(\"Specified type \" + types[i] +\n+                                                    \" does not match declared type \" + method.getReturnType(), i);\n+                    }\n+                    if (Modifier.isPrivate(method.getModifiers())) {\n+                        throw new BulkBeanException(\"Property is private\", i);\n+                    }\n+                    getters_out[i] = method;\n+                }\n+                if (setters[i] != null) {\n+                    Method method = ReflectUtils.findDeclaredMethod(target, setters[i], new Class[]{ types[i] });\n+                    if (Modifier.isPrivate(method.getModifiers()) ){\n+                        throw new BulkBeanException(\"Property is private\", i);\n+                    }\n+                    setters_out[i] = method;\n+                }\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new BulkBeanException(\"Cannot find specified property\", i);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/BulkBeanException.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import org.mockito.cglib.core.CodeGenerationException;\n+\n+public class BulkBeanException extends RuntimeException\n+{\n+    private int index;\n+    private Throwable cause;\n+    \n+    public BulkBeanException(String message, int index) {\n+        super(message);\n+        this.index = index;\n+    }\n+\n+    public BulkBeanException(Throwable cause, int index) {\n+        super(cause.getMessage());\n+        this.index = index;\n+        this.cause = cause;\n+    }\n+\n+    public int getIndex() {\n+        return index;\n+    }\n+    \n+    public Throwable getCause() {\n+        return cause;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/FixedKeySet.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.util.*;\n+\n+public /* need it for class loading  */ class FixedKeySet extends AbstractSet {\n+    private Set set;\n+    private int size;\n+\n+    public FixedKeySet(String[] keys) {\n+        size = keys.length;\n+        set = Collections.unmodifiableSet(new HashSet(Arrays.asList(keys)));\n+    }\n+\n+    public Iterator iterator() {\n+        return set.iterator();\n+    }\n+\n+    public int size() {\n+        return size;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/beans/ImmutableBean.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.beans;\n+\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Method;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * @author Chris Nokleberg\n+ */\n+public class ImmutableBean\n+{\n+    private static final Type ILLEGAL_STATE_EXCEPTION =\n+      TypeUtils.parseType(\"IllegalStateException\");\n+    private static final Signature CSTRUCT_OBJECT =\n+      TypeUtils.parseConstructor(\"Object\");\n+    private static final Class[] OBJECT_CLASSES = { Object.class };\n+    private static final String FIELD_NAME = \"CGLIB$RWBean\";\n+\n+    private ImmutableBean() {\n+    }\n+\n+    public static Object create(Object bean) {\n+        Generator gen = new Generator();\n+        gen.setBean(bean);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(ImmutableBean.class.getName());\n+        private Object bean;\n+        private Class target;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        public void setBean(Object bean) {\n+            this.bean = bean;\n+            target = bean.getClass();\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return target.getClassLoader();\n+        }\n+\n+        public Object create() {\n+            String name = target.getName();\n+            setNamePrefix(name);\n+            return super.create(name);\n+        }\n+\n+        public void generateClass(ClassVisitor v) {\n+            Type targetType = Type.getType(target);\n+            ClassEmitter ce = new ClassEmitter(v);\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           targetType,\n+                           null,\n+                           Constants.SOURCE_FILE);\n+\n+            ce.declare_field(Constants.ACC_FINAL | Constants.ACC_PRIVATE, FIELD_NAME, targetType, null);\n+\n+            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT, null);\n+            e.load_this();\n+            e.super_invoke_constructor();\n+            e.load_this();\n+            e.load_arg(0);\n+            e.checkcast(targetType);\n+            e.putfield(FIELD_NAME);\n+            e.return_value();\n+            e.end_method();\n+\n+            PropertyDescriptor[] descriptors = ReflectUtils.getBeanProperties(target);\n+            Method[] getters = ReflectUtils.getPropertyMethods(descriptors, true, false);\n+            Method[] setters = ReflectUtils.getPropertyMethods(descriptors, false, true);\n+\n+            for (int i = 0; i < getters.length; i++) {\n+                MethodInfo getter = ReflectUtils.getMethodInfo(getters[i]);\n+                e = EmitUtils.begin_method(ce, getter, Constants.ACC_PUBLIC);\n+                e.load_this();\n+                e.getfield(FIELD_NAME);\n+                e.invoke(getter);\n+                e.return_value();\n+                e.end_method();\n+            }\n+\n+            for (int i = 0; i < setters.length; i++) {\n+                MethodInfo setter = ReflectUtils.getMethodInfo(setters[i]);\n+                e = EmitUtils.begin_method(ce, setter, Constants.ACC_PUBLIC);\n+                e.throw_exception(ILLEGAL_STATE_EXCEPTION, \"Bean is immutable\");\n+                e.end_method();\n+            }\n+\n+            ce.end_class();\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ReflectUtils.newInstance(type, OBJECT_CLASSES, new Object[]{ bean });\n+        }\n+\n+        // TODO: optimize\n+        protected Object nextInstance(Object instance) {\n+            return firstInstance(instance.getClass());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/AbstractClassGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.lang.ref.*;\n+\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.ClassWriter;\n+import org.mockito.asm.Type;\n+\n+/**\n+ * Abstract class for all code-generating CGLIB utilities.\n+ * In addition to caching generated classes for performance, it provides hooks for\n+ * customizing the <code>ClassLoader</code>, name of the generated class, and transformations\n+ * applied before generation.\n+ */\n+abstract public class AbstractClassGenerator\n+implements ClassGenerator\n+{\n+    private static final Object NAME_KEY = new Object();\n+    private static final ThreadLocal CURRENT = new ThreadLocal();\n+\n+    private GeneratorStrategy strategy = DefaultGeneratorStrategy.INSTANCE;\n+    private NamingPolicy namingPolicy = DefaultNamingPolicy.INSTANCE;\n+    private Source source;\n+    private ClassLoader classLoader;\n+    private String namePrefix;\n+    private Object key;\n+    private boolean useCache = true;\n+    private String className;\n+    private boolean attemptLoad;\n+\n+    protected static class Source {\n+        String name;\n+        Map cache = new WeakHashMap();\n+        public Source(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    protected AbstractClassGenerator(Source source) {\n+        this.source = source;\n+    }\n+\n+    protected void setNamePrefix(String namePrefix) {\n+        this.namePrefix = namePrefix;\n+    }\n+\n+    final protected String getClassName() {\n+        if (className == null)\n+            className = getClassName(getClassLoader());\n+        return className;\n+    }\n+\n+    private String getClassName(final ClassLoader loader) {\n+        final Set nameCache = getClassNameCache(loader);\n+        return namingPolicy.getClassName(namePrefix, source.name, key, new Predicate() {\n+            public boolean evaluate(Object arg) {\n+                return nameCache.contains(arg);\n+            }\n+        });\n+    }\n+\n+    private Set getClassNameCache(ClassLoader loader) {\n+        return (Set)((Map)source.cache.get(loader)).get(NAME_KEY);\n+    }\n+\n+    /**\n+     * Set the <code>ClassLoader</code> in which the class will be generated.\n+     * Concrete subclasses of <code>AbstractClassGenerator</code> (such as <code>Enhancer</code>)\n+     * will try to choose an appropriate default if this is unset.\n+     * <p>\n+     * Classes are cached per-<code>ClassLoader</code> using a <code>WeakHashMap</code>, to allow\n+     * the generated classes to be removed when the associated loader is garbage collected.\n+     * @param classLoader the loader to generate the new class with, or null to use the default\n+     */\n+    public void setClassLoader(ClassLoader classLoader) {\n+        this.classLoader = classLoader;\n+    }\n+\n+    /**\n+     * Override the default naming policy.\n+     * @see DefaultNamingPolicy\n+     * @param namingPolicy the custom policy, or null to use the default\n+     */\n+    public void setNamingPolicy(NamingPolicy namingPolicy) {\n+        if (namingPolicy == null)\n+            namingPolicy = DefaultNamingPolicy.INSTANCE;\n+        this.namingPolicy = namingPolicy;\n+    }\n+\n+    /**\n+     * @see #setNamingPolicy\n+     */\n+    public NamingPolicy getNamingPolicy() {\n+        return namingPolicy;\n+    }\n+\n+    /**\n+     * Whether use and update the static cache of generated classes\n+     * for a class with the same properties. Default is <code>true</code>.\n+     */\n+    public void setUseCache(boolean useCache) {\n+        this.useCache = useCache;\n+    }\n+\n+    /**\n+     * @see #setUseCache\n+     */\n+    public boolean getUseCache() {\n+        return useCache;\n+    }\n+\n+    /**\n+     * If set, CGLIB will attempt to load classes from the specified\n+     * <code>ClassLoader</code> before generating them. Because generated\n+     * class names are not guaranteed to be unique, the default is <code>false</code>.\n+     */\n+    public void setAttemptLoad(boolean attemptLoad) {\n+        this.attemptLoad = attemptLoad;\n+    }\n+\n+    public boolean getAttemptLoad() {\n+        return attemptLoad;\n+    }\n+    \n+    /**\n+     * Set the strategy to use to create the bytecode from this generator.\n+     * By default an instance of {@see DefaultGeneratorStrategy} is used.\n+     */\n+    public void setStrategy(GeneratorStrategy strategy) {\n+        if (strategy == null)\n+            strategy = DefaultGeneratorStrategy.INSTANCE;\n+        this.strategy = strategy;\n+    }\n+\n+    /**\n+     * @see #setStrategy\n+     */\n+    public GeneratorStrategy getStrategy() {\n+        return strategy;\n+    }\n+\n+    /**\n+     * Used internally by CGLIB. Returns the <code>AbstractClassGenerator</code>\n+     * that is being used to generate a class in the current thread.\n+     */\n+    public static AbstractClassGenerator getCurrent() {\n+        return (AbstractClassGenerator)CURRENT.get();\n+    }\n+\n+    public ClassLoader getClassLoader() {\n+        ClassLoader t = classLoader;\n+        if (t == null) {\n+            t = getDefaultClassLoader();\n+        }\n+        if (t == null) {\n+            t = getClass().getClassLoader();\n+        }\n+        if (t == null) {\n+            t = Thread.currentThread().getContextClassLoader();\n+        }\n+        if (t == null) {\n+            throw new IllegalStateException(\"Cannot determine classloader\");\n+        }\n+        return t;\n+    }\n+\n+    abstract protected ClassLoader getDefaultClassLoader();\n+\n+    protected Object create(Object key) {\n+        try {\n+        \tClass gen = null;\n+        \t\n+            synchronized (source) {\n+                ClassLoader loader = getClassLoader();\n+                Map cache2 = null;\n+                cache2 = (Map)source.cache.get(loader);\n+                if (cache2 == null) {\n+                    cache2 = new HashMap();\n+                    cache2.put(NAME_KEY, new HashSet());\n+                    source.cache.put(loader, cache2);\n+                } else if (useCache) {\n+                    Reference ref = (Reference)cache2.get(key);\n+                    gen = (Class) (( ref == null ) ? null : ref.get()); \n+                }\n+                if (gen == null) {\n+                    Object save = CURRENT.get();\n+                    CURRENT.set(this);\n+                    try {\n+                        this.key = key;\n+                        \n+                        if (attemptLoad) {\n+                            try {\n+                                gen = loader.loadClass(getClassName());\n+                            } catch (ClassNotFoundException e) {\n+                                // ignore\n+                            }\n+                        }\n+                        if (gen == null) {\n+                            byte[] b = strategy.generate(this);\n+                            String className = ClassNameReader.getClassName(new ClassReader(b));\n+                            getClassNameCache(loader).add(className);\n+                            gen = ReflectUtils.defineClass(className, b, loader);\n+                        }\n+                       \n+                        if (useCache) {\n+                            cache2.put(key, new WeakReference(gen));\n+                        }\n+                        return firstInstance(gen);\n+                    } finally {\n+                        CURRENT.set(save);\n+                    }\n+                }\n+            }\n+            return firstInstance(gen);\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Error e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+\n+    abstract protected Object firstInstance(Class type) throws Exception;\n+    abstract protected Object nextInstance(Object instance) throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Block.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Label;\n+\n+public class Block\n+{\n+    private CodeEmitter e;\n+    private Label start;\n+    private Label end;\n+\n+    public Block(CodeEmitter e) {\n+        this.e = e;\n+        start = e.mark();\n+    }\n+\n+    public CodeEmitter getCodeEmitter() {\n+        return e;\n+    }\n+\n+    public void end() {\n+        if (end != null) {\n+            throw new IllegalStateException(\"end of label already set\");\n+        }\n+        end = e.mark();\n+    }\n+    \n+    public Label getStart() {\n+        return start;\n+    }\n+\n+    public Label getEnd() {\n+        return end;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ClassEmitter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.mockito.asm.*;\n+\n+/**\n+ * @author Juozas Baliuka, Chris Nokleberg\n+ */\n+public class ClassEmitter extends ClassAdapter {\n+    private ClassInfo classInfo;\n+    private Map fieldInfo;\n+\n+    private static int hookCounter;\n+    private MethodVisitor rawStaticInit;\n+    private CodeEmitter staticInit;\n+    private CodeEmitter staticHook;\n+    private Signature staticHookSig;\n+\n+    public ClassEmitter(ClassVisitor cv) {\n+        super(null);\n+        setTarget(cv);\n+    }\n+\n+    public ClassEmitter() {\n+        super(null);\n+    }\n+\n+    public void setTarget(ClassVisitor cv) {\n+        this.cv = cv;\n+        fieldInfo = new HashMap();\n+\n+        // just to be safe\n+        staticInit = staticHook = null;\n+        staticHookSig = null;\n+    }\n+\n+    synchronized private static int getNextHook() {\n+        return ++hookCounter;\n+    }\n+\n+    public ClassInfo getClassInfo() {\n+        return classInfo;\n+    }\n+\n+    public void begin_class(int version, final int access, String className, final Type superType, final Type[] interfaces, String source) {\n+        final Type classType = Type.getType(\"L\" + className.replace('.', '/') + \";\");\n+        classInfo = new ClassInfo() {\n+            public Type getType() {\n+                return classType;\n+            }\n+            public Type getSuperType() {\n+                return (superType != null) ? superType : Constants.TYPE_OBJECT;\n+            }\n+            public Type[] getInterfaces() {\n+                return interfaces;\n+            }\n+            public int getModifiers() {\n+                return access;\n+            }\n+        };\n+        cv.visit(version,\n+                 access,\n+                 classInfo.getType().getInternalName(),\n+                 null,\n+                 classInfo.getSuperType().getInternalName(),\n+                 TypeUtils.toInternalNames(interfaces));\n+        if (source != null)\n+            cv.visitSource(source, null);\n+        init();\n+    }\n+\n+    public CodeEmitter getStaticHook() {\n+         if (TypeUtils.isInterface(getAccess())) {\n+             throw new IllegalStateException(\"static hook is invalid for this class\");\n+         }\n+         if (staticHook == null) {\n+             staticHookSig = new Signature(\"CGLIB$STATICHOOK\" + getNextHook(), \"()V\");\n+             staticHook = begin_method(Constants.ACC_STATIC,\n+                                       staticHookSig,\n+                                       null);\n+             if (staticInit != null) {\n+                 staticInit.invoke_static_this(staticHookSig);\n+             }\n+         }\n+         return staticHook;\n+    }\n+\n+    protected void init() {\n+    }\n+\n+    public int getAccess() {\n+        return classInfo.getModifiers();\n+    }\n+\n+    public Type getClassType() {\n+        return classInfo.getType();\n+    }\n+\n+    public Type getSuperType() {\n+        return classInfo.getSuperType();\n+    }\n+\n+    public void end_class() {\n+        if (staticHook != null && staticInit == null) {\n+            // force creation of static init\n+            begin_static();\n+        }\n+        if (staticInit != null) {\n+            staticHook.return_value();\n+            staticHook.end_method();\n+            rawStaticInit.visitInsn(Constants.RETURN);\n+            rawStaticInit.visitMaxs(0, 0);\n+            staticInit = staticHook = null;\n+            staticHookSig = null;\n+        }\n+        cv.visitEnd();\n+    }\n+\n+    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n+        if (classInfo == null)\n+            throw new IllegalStateException(\"classInfo is null! \" + this);\n+        MethodVisitor v = cv.visitMethod(access,\n+                                         sig.getName(),\n+                                         sig.getDescriptor(),\n+                                         null,\n+                                         TypeUtils.toInternalNames(exceptions));\n+        if (sig.equals(Constants.SIG_STATIC) && !TypeUtils.isInterface(getAccess())) {\n+            rawStaticInit = v;\n+            MethodVisitor wrapped = new MethodAdapter(v) {\n+                public void visitMaxs(int maxStack, int maxLocals) {\n+                    // ignore\n+                }\n+                public void visitInsn(int insn) {\n+                    if (insn != Constants.RETURN) {\n+                        super.visitInsn(insn);\n+                    }\n+                }\n+            };\n+            staticInit = new CodeEmitter(this, wrapped, access, sig, exceptions);\n+            if (staticHook == null) {\n+                // force static hook creation\n+                getStaticHook();\n+            } else {\n+                staticInit.invoke_static_this(staticHookSig);\n+            }\n+            return staticInit;\n+        } else if (sig.equals(staticHookSig)) {\n+            return new CodeEmitter(this, v, access, sig, exceptions) {\n+                public boolean isStaticHook() {\n+                    return true;\n+                }\n+            };\n+        } else {\n+            return new CodeEmitter(this, v, access, sig, exceptions);\n+        }\n+    }\n+\n+    public CodeEmitter begin_static() {\n+        return begin_method(Constants.ACC_STATIC, Constants.SIG_STATIC, null);\n+    }\n+\n+    public void declare_field(int access, String name, Type type, Object value) {\n+        FieldInfo existing = (FieldInfo)fieldInfo.get(name);\n+        FieldInfo info = new FieldInfo(access, name, type, value);\n+        if (existing != null) {\n+            if (!info.equals(existing)) {\n+                throw new IllegalArgumentException(\"Field \\\"\" + name + \"\\\" has been declared differently\");\n+            }\n+        } else {\n+            fieldInfo.put(name, info);\n+            cv.visitField(access, name, type.getDescriptor(), null, value);\n+        }\n+    }\n+\n+    // TODO: make public?\n+    boolean isFieldDeclared(String name) {\n+        return fieldInfo.get(name) != null;\n+    }\n+\n+    FieldInfo getFieldInfo(String name) {\n+        FieldInfo field = (FieldInfo)fieldInfo.get(name);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Field \" + name + \" is not declared in \" + getClassType().getClassName());\n+        }\n+        return field;\n+    }\n+    \n+    static class FieldInfo {\n+        int access;\n+        String name;\n+        Type type;\n+        Object value;\n+        \n+        public FieldInfo(int access, String name, Type type, Object value) {\n+            this.access = access;\n+            this.name = name;\n+            this.type = type;\n+            this.value = value;\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == null)\n+                return false;\n+            if (!(o instanceof FieldInfo))\n+                return false;\n+            FieldInfo other = (FieldInfo)o;\n+            if (access != other.access ||\n+                !name.equals(other.name) ||\n+                !type.equals(other.type)) {\n+                return false;\n+            }\n+            if ((value == null) ^ (other.value == null))\n+                return false;\n+            if (value != null && !value.equals(other.value))\n+                return false;\n+            return true;\n+        }\n+\n+        public int hashCode() {\n+            return access ^ name.hashCode() ^ type.hashCode() ^ ((value == null) ? 0 : value.hashCode());\n+        }\n+    }\n+\n+    public void visit(int version,\n+                      int access,\n+                      String name,\n+                      String signature,\n+                      String superName,\n+                      String[] interfaces) {\n+        begin_class(version,\n+                    access,\n+                    name.replace('/', '.'),\n+                    TypeUtils.fromInternalName(superName),\n+                    TypeUtils.fromInternalNames(interfaces),\n+                    null); // TODO\n+    }\n+    \n+    public void visitEnd() {\n+        end_class();\n+    }\n+    \n+    public FieldVisitor visitField(int access,\n+                                   String name,\n+                                   String desc,\n+                                   String signature,\n+                                   Object value) {\n+        declare_field(access, name, Type.getType(desc), value);\n+        return null; // TODO\n+    }\n+    \n+    public MethodVisitor visitMethod(int access,\n+                                     String name,\n+                                     String desc,\n+                                     String signature,\n+                                     String[] exceptions) {\n+        return begin_method(access,\n+                            new Signature(name, desc),\n+                            TypeUtils.fromInternalNames(exceptions));        \n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ClassGenerator.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.ClassVisitor;\n+\n+public interface ClassGenerator {\n+    void generateClass(ClassVisitor v) throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ClassInfo.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Type;\n+\n+abstract public class ClassInfo {\n+\n+    protected ClassInfo() {\n+    }\n+\n+    abstract public Type getType();\n+    abstract public Type getSuperType();\n+    abstract public Type[] getInterfaces();\n+    abstract public int getModifiers();\n+\n+    public boolean equals(Object o) {\n+        if (o == null)\n+            return false;\n+        if (!(o instanceof ClassInfo))\n+            return false;\n+        return getType().equals(((ClassInfo)o).getType());\n+    }\n+\n+    public int hashCode() {\n+        return getType().hashCode();\n+    }\n+\n+    public String toString() {\n+        // TODO: include modifiers, superType, interfaces\n+        return getType().getClassName();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ClassNameReader.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.ClassAdapter;\n+import org.mockito.asm.ClassReader;\n+\n+import java.util.*;\n+\n+// TODO: optimize (ClassReader buffers entire class before accept)\n+public class ClassNameReader {\n+    private ClassNameReader() {\n+    }\n+\n+    private static final EarlyExitException EARLY_EXIT = new EarlyExitException();\n+    private static class EarlyExitException extends RuntimeException { }\n+    \n+    public static String getClassName(ClassReader r) {\n+    \n+        return getClassInfo(r)[0];\n+      \n+    }\n+    \n+    public static String[] getClassInfo(ClassReader r) {\n+        final List array = new ArrayList();\n+        try {\n+            r.accept(new ClassAdapter(null) {\n+                public void visit(int version,\n+                                  int access,\n+                                  String name,\n+                                  String signature,\n+                                  String superName,\n+                                  String[] interfaces) {\n+                    array.add( name.replace('/', '.') );\n+                    if(superName != null){\n+                      array.add( superName.replace('/', '.') );\n+                    }\n+                    for(int i = 0; i < interfaces.length; i++  ){\n+                       array.add( interfaces[i].replace('/', '.') );\n+                    }\n+                    \n+                    throw EARLY_EXIT;\n+                }\n+            }, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);\n+        } catch (EarlyExitException e) { }\n+        \n+        return (String[])array.toArray( new String[]{} );\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ClassesKey.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+public class ClassesKey {\n+    private static final Key FACTORY = (Key)KeyFactory.create(Key.class, KeyFactory.OBJECT_BY_CLASS);\n+    \n+    interface Key {\n+        Object newInstance(Object[] array);\n+    }\n+\n+    private ClassesKey() {\n+    }\n+\n+    public static Object create(Object[] array) {\n+        return FACTORY.newInstance(array);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/CodeEmitter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.mockito.asm.*;\n+\n+/**\n+ * @author Juozas Baliuka, Chris Nokleberg\n+ */\n+public class CodeEmitter extends LocalVariablesSorter {\n+    private static final Signature BOOLEAN_VALUE =\n+      TypeUtils.parseSignature(\"boolean booleanValue()\");\n+    private static final Signature CHAR_VALUE =\n+      TypeUtils.parseSignature(\"char charValue()\");\n+    private static final Signature LONG_VALUE =\n+      TypeUtils.parseSignature(\"long longValue()\");\n+    private static final Signature DOUBLE_VALUE =\n+      TypeUtils.parseSignature(\"double doubleValue()\");\n+    private static final Signature FLOAT_VALUE =\n+      TypeUtils.parseSignature(\"float floatValue()\");\n+    private static final Signature INT_VALUE =\n+      TypeUtils.parseSignature(\"int intValue()\");\n+    private static final Signature CSTRUCT_NULL =\n+      TypeUtils.parseConstructor(\"\");\n+    private static final Signature CSTRUCT_STRING =\n+      TypeUtils.parseConstructor(\"String\");\n+\n+    public static final int ADD = Constants.IADD;\n+    public static final int MUL = Constants.IMUL;\n+    public static final int XOR = Constants.IXOR;\n+    public static final int USHR = Constants.IUSHR;\n+    public static final int SUB = Constants.ISUB;\n+    public static final int DIV = Constants.IDIV;\n+    public static final int NEG = Constants.INEG;\n+    public static final int REM = Constants.IREM;\n+    public static final int AND = Constants.IAND;\n+    public static final int OR = Constants.IOR;\n+\n+    public static final int GT = Constants.IFGT;\n+    public static final int LT = Constants.IFLT;\n+    public static final int GE = Constants.IFGE;\n+    public static final int LE = Constants.IFLE;\n+    public static final int NE = Constants.IFNE;\n+    public static final int EQ = Constants.IFEQ;\n+\n+    private ClassEmitter ce;\n+    private State state;\n+\n+    private static class State\n+    extends MethodInfo\n+    {\n+        ClassInfo classInfo;\n+        int access;\n+        Signature sig;\n+        Type[] argumentTypes;\n+        int localOffset;\n+        Type[] exceptionTypes;\n+\n+        State(ClassInfo classInfo, int access, Signature sig, Type[] exceptionTypes) {\n+            this.classInfo = classInfo;\n+            this.access = access;\n+            this.sig = sig;\n+            this.exceptionTypes = exceptionTypes;\n+            localOffset = TypeUtils.isStatic(access) ? 0 : 1;\n+            argumentTypes = sig.getArgumentTypes();\n+        }\n+\n+        public ClassInfo getClassInfo() {\n+            return classInfo;\n+        }\n+\n+        public int getModifiers() {\n+            return access;\n+        }\n+\n+        public Signature getSignature() {\n+            return sig;\n+        }\n+\n+        public Type[] getExceptionTypes() {\n+            return exceptionTypes;\n+        }\n+\n+        public Attribute getAttribute() {\n+            // TODO\n+            return null;\n+        }\n+    }\n+\n+    CodeEmitter(ClassEmitter ce, MethodVisitor mv, int access, Signature sig, Type[] exceptionTypes) {\n+        super(access, sig.getDescriptor(), mv);\n+        this.ce = ce;\n+        state = new State(ce.getClassInfo(), access, sig, exceptionTypes);\n+    }\n+\n+    public CodeEmitter(CodeEmitter wrap) {\n+        super(wrap);\n+        this.ce = wrap.ce;\n+        this.state = wrap.state;\n+    }\n+\n+    public boolean isStaticHook() {\n+        return false;\n+    }\n+\n+    public Signature getSignature() {\n+        return state.sig;\n+    }\n+\n+    public Type getReturnType() {\n+        return state.sig.getReturnType();\n+    }\n+\n+    public MethodInfo getMethodInfo() {\n+        return state;\n+    }\n+\n+    public ClassEmitter getClassEmitter() {\n+        return ce;\n+    }\n+\n+    public void end_method() {\n+        visitMaxs(0, 0);\n+    }\n+\n+    public Block begin_block() {\n+        return new Block(this);\n+    }\n+\n+    public void catch_exception(Block block, Type exception) {\n+        if (block.getEnd() == null) {\n+            throw new IllegalStateException(\"end of block is unset\");\n+        }\n+        mv.visitTryCatchBlock(block.getStart(),\n+                              block.getEnd(),\n+                              mark(),\n+                              exception.getInternalName());\n+    }\n+\n+    public void goTo(Label label) { mv.visitJumpInsn(Constants.GOTO, label); }\n+    public void ifnull(Label label) { mv.visitJumpInsn(Constants.IFNULL, label); }\n+    public void ifnonnull(Label label) { mv.visitJumpInsn(Constants.IFNONNULL, label); }\n+\n+    public void if_jump(int mode, Label label) {\n+        mv.visitJumpInsn(mode, label);\n+    }\n+\n+    public void if_icmp(int mode, Label label) {\n+        if_cmp(Type.INT_TYPE, mode, label);\n+    }\n+\n+    public void if_cmp(Type type, int mode, Label label) {\n+        int intOp = -1;\n+        int jumpmode = mode;\n+        switch (mode) {\n+        case GE: jumpmode = LT; break;\n+        case LE: jumpmode = GT; break;\n+        }\n+        switch (type.getSort()) {\n+        case Type.LONG:\n+            mv.visitInsn(Constants.LCMP);\n+            break;\n+        case Type.DOUBLE:\n+            mv.visitInsn(Constants.DCMPG);\n+            break;\n+        case Type.FLOAT:\n+            mv.visitInsn(Constants.FCMPG);\n+            break;\n+        case Type.ARRAY:\n+        case Type.OBJECT:\n+            switch (mode) {\n+            case EQ:\n+                mv.visitJumpInsn(Constants.IF_ACMPEQ, label);\n+                return;\n+            case NE:\n+                mv.visitJumpInsn(Constants.IF_ACMPNE, label);\n+                return;\n+            }\n+            throw new IllegalArgumentException(\"Bad comparison for type \" + type);\n+        default:\n+            switch (mode) {\n+            case EQ: intOp = Constants.IF_ICMPEQ; break;\n+            case NE: intOp = Constants.IF_ICMPNE; break;\n+            case GE: swap(); /* fall through */\n+            case LT: intOp = Constants.IF_ICMPLT; break;\n+            case LE: swap(); /* fall through */\n+            case GT: intOp = Constants.IF_ICMPGT; break;\n+            }\n+            mv.visitJumpInsn(intOp, label);\n+            return;\n+        }\n+        if_jump(jumpmode, label);\n+    }\n+\n+    public void pop() { mv.visitInsn(Constants.POP); }\n+    public void pop2() { mv.visitInsn(Constants.POP2); }\n+    public void dup() { mv.visitInsn(Constants.DUP); }\n+    public void dup2() { mv.visitInsn(Constants.DUP2); }\n+    public void dup_x1() { mv.visitInsn(Constants.DUP_X1); }\n+    public void dup_x2() { mv.visitInsn(Constants.DUP_X2); }\n+    public void dup2_x1() { mv.visitInsn(Constants.DUP2_X1); }\n+    public void dup2_x2() { mv.visitInsn(Constants.DUP2_X2); }\n+    public void swap() { mv.visitInsn(Constants.SWAP); }\n+    public void aconst_null() { mv.visitInsn(Constants.ACONST_NULL); }\n+\n+    public void swap(Type prev, Type type) {\n+        if (type.getSize() == 1) {\n+            if (prev.getSize() == 1) {\n+                swap(); // same as dup_x1(), pop();\n+            } else {\n+                dup_x2();\n+                pop();\n+            }\n+        } else {\n+            if (prev.getSize() == 1) {\n+                dup2_x1();\n+                pop2();\n+            } else {\n+                dup2_x2();\n+                pop2();\n+            }\n+        }\n+    }\n+\n+    public void monitorenter() { mv.visitInsn(Constants.MONITORENTER); }\n+    public void monitorexit() { mv.visitInsn(Constants.MONITOREXIT); }\n+\n+    public void math(int op, Type type) { mv.visitInsn(type.getOpcode(op)); }\n+\n+    public void array_load(Type type) { mv.visitInsn(type.getOpcode(Constants.IALOAD)); }\n+    public void array_store(Type type) { mv.visitInsn(type.getOpcode(Constants.IASTORE)); }\n+\n+    /**\n+     * Casts from one primitive numeric type to another\n+     */\n+    public void cast_numeric(Type from, Type to) {\n+        if (from != to) {\n+            if (from == Type.DOUBLE_TYPE) {\n+                if (to == Type.FLOAT_TYPE) {\n+                    mv.visitInsn(Constants.D2F);\n+                } else if (to == Type.LONG_TYPE) {\n+                    mv.visitInsn(Constants.D2L);\n+                } else {\n+                    mv.visitInsn(Constants.D2I);\n+                    cast_numeric(Type.INT_TYPE, to);\n+                }\n+            } else if (from == Type.FLOAT_TYPE) {\n+                if (to == Type.DOUBLE_TYPE) {\n+                    mv.visitInsn(Constants.F2D);\n+                } else if (to == Type.LONG_TYPE) {\n+                    mv.visitInsn(Constants.F2L);\n+                } else {\n+                    mv.visitInsn(Constants.F2I);\n+                    cast_numeric(Type.INT_TYPE, to);\n+                }\n+            } else if (from == Type.LONG_TYPE) {\n+                if (to == Type.DOUBLE_TYPE) {\n+                    mv.visitInsn(Constants.L2D);\n+                } else if (to == Type.FLOAT_TYPE) {\n+                    mv.visitInsn(Constants.L2F);\n+                } else {\n+                    mv.visitInsn(Constants.L2I);\n+                    cast_numeric(Type.INT_TYPE, to);\n+                }\n+            } else {\n+                if (to == Type.BYTE_TYPE) {\n+                    mv.visitInsn(Constants.I2B);\n+                } else if (to == Type.CHAR_TYPE) {\n+                    mv.visitInsn(Constants.I2C);\n+                } else if (to == Type.DOUBLE_TYPE) {\n+                    mv.visitInsn(Constants.I2D);\n+                } else if (to == Type.FLOAT_TYPE) {\n+                    mv.visitInsn(Constants.I2F);\n+                } else if (to == Type.LONG_TYPE) {\n+                    mv.visitInsn(Constants.I2L);\n+                } else if (to == Type.SHORT_TYPE) {\n+                    mv.visitInsn(Constants.I2S);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void push(int i) {\n+        if (i < -1) {\n+            mv.visitLdcInsn(new Integer(i));\n+        } else if (i <= 5) {\n+            mv.visitInsn(TypeUtils.ICONST(i));\n+        } else if (i <= Byte.MAX_VALUE) {\n+            mv.visitIntInsn(Constants.BIPUSH, i);\n+        } else if (i <= Short.MAX_VALUE) {\n+            mv.visitIntInsn(Constants.SIPUSH, i);\n+        } else {\n+            mv.visitLdcInsn(new Integer(i));\n+        }\n+    }\n+    \n+    public void push(long value) {\n+        if (value == 0L || value == 1L) {\n+            mv.visitInsn(TypeUtils.LCONST(value));\n+        } else {\n+            mv.visitLdcInsn(new Long(value));\n+        }\n+    }\n+    \n+    public void push(float value) {\n+        if (value == 0f || value == 1f || value == 2f) {\n+            mv.visitInsn(TypeUtils.FCONST(value));\n+        } else {\n+            mv.visitLdcInsn(new Float(value));\n+        }\n+    }\n+    public void push(double value) {\n+        if (value == 0d || value == 1d) {\n+            mv.visitInsn(TypeUtils.DCONST(value));\n+        } else {\n+            mv.visitLdcInsn(new Double(value));\n+        }\n+    }\n+    \n+    public void push(String value) {\n+        mv.visitLdcInsn(value);\n+    }\n+\n+    public void newarray() {\n+        newarray(Constants.TYPE_OBJECT);\n+    }\n+\n+    public void newarray(Type type) {\n+        if (TypeUtils.isPrimitive(type)) {\n+            mv.visitIntInsn(Constants.NEWARRAY, TypeUtils.NEWARRAY(type));\n+        } else {\n+            emit_type(Constants.ANEWARRAY, type);\n+        }\n+    }\n+    \n+    public void arraylength() {\n+        mv.visitInsn(Constants.ARRAYLENGTH);\n+    }\n+    \n+    public void load_this() {\n+        if (TypeUtils.isStatic(state.access)) {\n+            throw new IllegalStateException(\"no 'this' pointer within static method\");\n+        }\n+        mv.visitVarInsn(Constants.ALOAD, 0);\n+    }\n+    \n+    /**\n+     * Pushes all of the arguments of the current method onto the stack.\n+     */\n+    public void load_args() {\n+        load_args(0, state.argumentTypes.length);\n+    }\n+\n+    /**\n+     * Pushes the specified argument of the current method onto the stack.\n+     * @param index the zero-based index into the argument list\n+     */\n+    public void load_arg(int index) {\n+        load_local(state.argumentTypes[index],\n+                   state.localOffset + skipArgs(index));\n+    }\n+\n+    // zero-based (see load_this)\n+    public void load_args(int fromArg, int count) {\n+        int pos = state.localOffset + skipArgs(fromArg);\n+        for (int i = 0; i < count; i++) {\n+            Type t = state.argumentTypes[fromArg + i];\n+            load_local(t, pos);\n+            pos += t.getSize();\n+        }\n+    }\n+    \n+    private int skipArgs(int numArgs) {\n+        int amount = 0;\n+        for (int i = 0; i < numArgs; i++) {\n+            amount += state.argumentTypes[i].getSize();\n+        }\n+        return amount;\n+    }\n+\n+    private void load_local(Type t, int pos) {\n+        // TODO: make t == null ok?\n+        mv.visitVarInsn(t.getOpcode(Constants.ILOAD), pos);\n+    }\n+\n+    private void store_local(Type t, int pos) {\n+        // TODO: make t == null ok?\n+        mv.visitVarInsn(t.getOpcode(Constants.ISTORE), pos);\n+    }\n+    \n+    public void iinc(Local local, int amount) {\n+        mv.visitIincInsn(local.getIndex(), amount);\n+    }\n+    \n+    public void store_local(Local local) {\n+        store_local(local.getType(), local.getIndex());\n+    }\n+    \n+    public void load_local(Local local) {\n+        load_local(local.getType(), local.getIndex());\n+    }\n+\n+    public void return_value() {\n+        mv.visitInsn(state.sig.getReturnType().getOpcode(Constants.IRETURN));\n+    }\n+\n+    public void getfield(String name) {\n+        ClassEmitter.FieldInfo info = ce.getFieldInfo(name);\n+        int opcode = TypeUtils.isStatic(info.access) ? Constants.GETSTATIC : Constants.GETFIELD;\n+        emit_field(opcode, ce.getClassType(), name, info.type);\n+    }\n+    \n+    public void putfield(String name) {\n+        ClassEmitter.FieldInfo info = ce.getFieldInfo(name);\n+        int opcode = TypeUtils.isStatic(info.access) ? Constants.PUTSTATIC : Constants.PUTFIELD;\n+        emit_field(opcode, ce.getClassType(), name, info.type);\n+    }\n+\n+    public void super_getfield(String name, Type type) {\n+        emit_field(Constants.GETFIELD, ce.getSuperType(), name, type);\n+    }\n+    \n+    public void super_putfield(String name, Type type) {\n+        emit_field(Constants.PUTFIELD, ce.getSuperType(), name, type);\n+    }\n+\n+    public void super_getstatic(String name, Type type) {\n+        emit_field(Constants.GETSTATIC, ce.getSuperType(), name, type);\n+    }\n+    \n+    public void super_putstatic(String name, Type type) {\n+        emit_field(Constants.PUTSTATIC, ce.getSuperType(), name, type);\n+    }\n+\n+    public void getfield(Type owner, String name, Type type) {\n+        emit_field(Constants.GETFIELD, owner, name, type);\n+    }\n+    \n+    public void putfield(Type owner, String name, Type type) {\n+        emit_field(Constants.PUTFIELD, owner, name, type);\n+    }\n+\n+    public void getstatic(Type owner, String name, Type type) {\n+        emit_field(Constants.GETSTATIC, owner, name, type);\n+    }\n+    \n+    public void putstatic(Type owner, String name, Type type) {\n+        emit_field(Constants.PUTSTATIC, owner, name, type);\n+    }\n+\n+    // package-protected for EmitUtils, try to fix\n+    void emit_field(int opcode, Type ctype, String name, Type ftype) {\n+        mv.visitFieldInsn(opcode,\n+                          ctype.getInternalName(),\n+                          name,\n+                          ftype.getDescriptor());\n+    }\n+\n+    public void super_invoke() {\n+        super_invoke(state.sig);\n+    }\n+\n+    public void super_invoke(Signature sig) {\n+        emit_invoke(Constants.INVOKESPECIAL, ce.getSuperType(), sig);\n+    }\n+\n+    public void invoke_constructor(Type type) {\n+        invoke_constructor(type, CSTRUCT_NULL);\n+    }\n+\n+    public void super_invoke_constructor() {\n+        invoke_constructor(ce.getSuperType());\n+    }\n+    \n+    public void invoke_constructor_this() {\n+        invoke_constructor(ce.getClassType());\n+    }\n+\n+    private void emit_invoke(int opcode, Type type, Signature sig) {\n+        if (sig.getName().equals(Constants.CONSTRUCTOR_NAME) &&\n+            ((opcode == Constants.INVOKEVIRTUAL) ||\n+             (opcode == Constants.INVOKESTATIC))) {\n+            // TODO: error\n+        }\n+        mv.visitMethodInsn(opcode,\n+                           type.getInternalName(),\n+                           sig.getName(),\n+                           sig.getDescriptor());\n+    }\n+    \n+    public void invoke_interface(Type owner, Signature sig) {\n+        emit_invoke(Constants.INVOKEINTERFACE, owner, sig);\n+    }\n+\n+    public void invoke_virtual(Type owner, Signature sig) {\n+        emit_invoke(Constants.INVOKEVIRTUAL, owner, sig);\n+    }\n+\n+    public void invoke_static(Type owner, Signature sig) {\n+        emit_invoke(Constants.INVOKESTATIC, owner, sig);\n+    }\n+\n+    public void invoke_virtual_this(Signature sig) {\n+        invoke_virtual(ce.getClassType(), sig);\n+    }\n+\n+    public void invoke_static_this(Signature sig) {\n+        invoke_static(ce.getClassType(), sig);\n+    }\n+\n+    public void invoke_constructor(Type type, Signature sig) {\n+        emit_invoke(Constants.INVOKESPECIAL, type, sig);\n+    }\n+\n+    public void invoke_constructor_this(Signature sig) {\n+        invoke_constructor(ce.getClassType(), sig);\n+    }\n+\n+    public void super_invoke_constructor(Signature sig) {\n+        invoke_constructor(ce.getSuperType(), sig);\n+    }\n+    \n+    public void new_instance_this() {\n+        new_instance(ce.getClassType());\n+    }\n+\n+    public void new_instance(Type type) {\n+        emit_type(Constants.NEW, type);\n+    }\n+\n+    private void emit_type(int opcode, Type type) {\n+        String desc;\n+        if (TypeUtils.isArray(type)) {\n+            desc = type.getDescriptor();\n+        } else {\n+            desc = type.getInternalName();\n+        }\n+        mv.visitTypeInsn(opcode, desc);\n+    }\n+\n+    public void aaload(int index) {\n+        push(index);\n+        aaload();\n+    }\n+\n+    public void aaload() { mv.visitInsn(Constants.AALOAD); }\n+    public void aastore() { mv.visitInsn(Constants.AASTORE); }\n+    public void athrow() { mv.visitInsn(Constants.ATHROW); }\n+\n+    public Label make_label() {\n+        return new Label();\n+    }\n+    \n+    public Local make_local() {\n+        return make_local(Constants.TYPE_OBJECT);\n+    }\n+    \n+    public Local make_local(Type type) {\n+        return new Local(newLocal(type.getSize()), type);\n+    }\n+\n+    public void checkcast_this() {\n+        checkcast(ce.getClassType());\n+    }\n+    \n+    public void checkcast(Type type) {\n+        if (!type.equals(Constants.TYPE_OBJECT)) {\n+            emit_type(Constants.CHECKCAST, type);\n+        }\n+    }\n+\n+    public void instance_of(Type type) {\n+        emit_type(Constants.INSTANCEOF, type);\n+    }\n+    \n+    public void instance_of_this() {\n+        instance_of(ce.getClassType());\n+    }\n+\n+    public void process_switch(int[] keys, ProcessSwitchCallback callback) {\n+        float density;\n+        if (keys.length == 0) {\n+            density = 0;\n+        } else {\n+            density = (float)keys.length / (keys[keys.length - 1] - keys[0] + 1);\n+        }\n+        process_switch(keys, callback, density >= 0.5f);\n+    }\n+\n+    public void process_switch(int[] keys, ProcessSwitchCallback callback, boolean useTable) {\n+        if (!isSorted(keys))\n+            throw new IllegalArgumentException(\"keys to switch must be sorted ascending\");\n+        Label def = make_label();\n+        Label end = make_label();\n+\n+        try {\n+            if (keys.length > 0) {\n+                int len = keys.length;\n+                int min = keys[0];\n+                int max = keys[len - 1];\n+                int range = max - min + 1;\n+\n+                if (useTable) {\n+                    Label[] labels = new Label[range];\n+                    Arrays.fill(labels, def);\n+                    for (int i = 0; i < len; i++) {\n+                        labels[keys[i] - min] = make_label();\n+                    }\n+                    mv.visitTableSwitchInsn(min, max, def, labels);\n+                    for (int i = 0; i < range; i++) {\n+                        Label label = labels[i];\n+                        if (label != def) {\n+                            mark(label);\n+                            callback.processCase(i + min, end);\n+                        }\n+                    }\n+                } else {\n+                    Label[] labels = new Label[len];\n+                    for (int i = 0; i < len; i++) {\n+                        labels[i] = make_label();\n+                    }\n+                    mv.visitLookupSwitchInsn(def, keys, labels);\n+                    for (int i = 0; i < len; i++) {\n+                        mark(labels[i]);\n+                        callback.processCase(keys[i], end);\n+                    }\n+                }\n+            }\n+\n+            mark(def);\n+            callback.processDefault();\n+            mark(end);\n+\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Error e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+\n+    private static boolean isSorted(int[] keys) {\n+        for (int i = 1; i < keys.length; i++) {\n+            if (keys[i] < keys[i - 1])\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    public void mark(Label label) {\n+        mv.visitLabel(label);\n+    }\n+\n+    Label mark() {\n+        Label label = make_label();\n+        mv.visitLabel(label);\n+        return label;\n+    }\n+\n+    public void push(boolean value) {\n+        push(value ? 1 : 0);\n+    }\n+\n+    /**\n+     * Toggles the integer on the top of the stack from 1 to 0 or vice versa\n+     */\n+    public void not() {\n+        push(1);\n+        math(XOR, Type.INT_TYPE);\n+    }\n+\n+    public void throw_exception(Type type, String msg) {\n+        new_instance(type);\n+        dup();\n+        push(msg);\n+        invoke_constructor(type, CSTRUCT_STRING);\n+        athrow();\n+    }\n+\n+    /**\n+     * If the argument is a primitive class, replaces the primitive value\n+     * on the top of the stack with the wrapped (Object) equivalent. For\n+     * example, char -> Character.\n+     * If the class is Void, a null is pushed onto the stack instead.\n+     * @param type the class indicating the current type of the top stack value\n+     */\n+    public void box(Type type) {\n+        if (TypeUtils.isPrimitive(type)) {\n+            if (type == Type.VOID_TYPE) {\n+                aconst_null();\n+            } else {\n+                Type boxed = TypeUtils.getBoxedType(type);\n+                new_instance(boxed);\n+                if (type.getSize() == 2) {\n+                    // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n+                    dup_x2();\n+                    dup_x2();\n+                    pop();\n+                } else {\n+                    // p -> po -> opo -> oop -> o\n+                    dup_x1();\n+                    swap();\n+                }\n+                invoke_constructor(boxed, new Signature(Constants.CONSTRUCTOR_NAME, Type.VOID_TYPE, new Type[]{ type }));\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * If the argument is a primitive class, replaces the object\n+     * on the top of the stack with the unwrapped (primitive)\n+     * equivalent. For example, Character -> char.\n+     * @param type the class indicating the desired type of the top stack value\n+     * @return true if the value was unboxed\n+     */\n+    public void unbox(Type type) {\n+        Type t = Constants.TYPE_NUMBER;\n+        Signature sig = null;\n+        switch (type.getSort()) {\n+        case Type.VOID:\n+            return;\n+        case Type.CHAR:\n+            t = Constants.TYPE_CHARACTER;\n+            sig = CHAR_VALUE;\n+            break;\n+        case Type.BOOLEAN:\n+            t = Constants.TYPE_BOOLEAN;\n+            sig = BOOLEAN_VALUE;\n+            break;\n+        case Type.DOUBLE:\n+            sig = DOUBLE_VALUE;\n+            break;\n+        case Type.FLOAT:\n+            sig = FLOAT_VALUE;\n+            break;\n+        case Type.LONG:\n+            sig = LONG_VALUE;\n+            break;\n+        case Type.INT:\n+        case Type.SHORT:\n+        case Type.BYTE:\n+            sig = INT_VALUE;\n+        }\n+\n+        if (sig == null) {\n+            checkcast(type);\n+        } else {\n+            checkcast(t);\n+            invoke_virtual(t, sig);\n+        }\n+    }\n+\n+    /**\n+     * Allocates and fills an Object[] array with the arguments to the\n+     * current method. Primitive values are inserted as their boxed\n+     * (Object) equivalents.\n+     */\n+    public void create_arg_array() {\n+        /* generates:\n+           Object[] args = new Object[]{ arg1, new Integer(arg2) };\n+         */\n+\n+        push(state.argumentTypes.length);\n+        newarray();\n+        for (int i = 0; i < state.argumentTypes.length; i++) {\n+            dup();\n+            push(i);\n+            load_arg(i);\n+            box(state.argumentTypes[i]);\n+            aastore();\n+        }\n+    }\n+\n+\n+    /**\n+     * Pushes a zero onto the stack if the argument is a primitive class, or a null otherwise.\n+     */\n+    public void zero_or_null(Type type) {\n+        if (TypeUtils.isPrimitive(type)) {\n+            switch (type.getSort()) {\n+            case Type.DOUBLE:\n+                push(0d);\n+                break;\n+            case Type.LONG:\n+                push(0L);\n+                break;\n+            case Type.FLOAT:\n+                push(0f);\n+                break;\n+            case Type.VOID:\n+                aconst_null();\n+            default:\n+                push(0);\n+            }\n+        } else {\n+            aconst_null();\n+        }\n+    }\n+\n+    /**\n+     * Unboxes the object on the top of the stack. If the object is null, the\n+     * unboxed primitive value becomes zero.\n+     */\n+    public void unbox_or_zero(Type type) {\n+        if (TypeUtils.isPrimitive(type)) {\n+            if (type != Type.VOID_TYPE) {\n+                Label nonNull = make_label();\n+                Label end = make_label();\n+                dup();\n+                ifnonnull(nonNull);\n+                pop();\n+                zero_or_null(type);\n+                goTo(end);\n+                mark(nonNull);\n+                unbox(type);\n+                mark(end);\n+            }\n+        } else {\n+            checkcast(type);\n+        }\n+    }\n+\n+    public void visitMaxs(int maxStack, int maxLocals) {\n+        if (!TypeUtils.isAbstract(state.access)) {\n+            mv.visitMaxs(0, 0);\n+        }\n+    }\n+\n+    public void invoke(MethodInfo method, Type virtualType) {\n+        ClassInfo classInfo = method.getClassInfo();\n+        Type type = classInfo.getType();\n+        Signature sig = method.getSignature();\n+        if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {\n+            invoke_constructor(type, sig);\n+        } else if (TypeUtils.isInterface(classInfo.getModifiers())) {\n+            invoke_interface(type, sig);\n+        } else if (TypeUtils.isStatic(method.getModifiers())) {\n+            invoke_static(type, sig);\n+        } else {\n+            invoke_virtual(virtualType, sig);\n+        }\n+    }\n+\n+    public void invoke(MethodInfo method) {\n+        invoke(method, method.getClassInfo().getType());\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/CodeGenerationException.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+/**\n+ * @version $Id: CodeGenerationException.java,v 1.3 2004/06/24 21:15:21 herbyderby Exp $\n+ */\n+public class CodeGenerationException extends RuntimeException {\n+    private Throwable cause;\n+\n+    public CodeGenerationException(Throwable cause) {\n+        super(cause.getClass().getName() + \"-->\" + cause.getMessage());\n+        this.cause = cause;\n+    }\n+\n+    public Throwable getCause() {\n+        return cause;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/CollectionUtils.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.util.*;\n+import java.lang.reflect.Array;\n+\n+/**\n+ * @author Chris Nokleberg\n+ * @version $Id: CollectionUtils.java,v 1.7 2004/06/24 21:15:21 herbyderby Exp $\n+ */\n+public class CollectionUtils {\n+    private CollectionUtils() { }\n+\n+    public static Map bucket(Collection c, Transformer t) {\n+        Map buckets = new HashMap();\n+        for (Iterator it = c.iterator(); it.hasNext();) {\n+            Object value = (Object)it.next();\n+            Object key = t.transform(value);\n+            List bucket = (List)buckets.get(key);\n+            if (bucket == null) {\n+                buckets.put(key, bucket = new LinkedList());\n+            }\n+            bucket.add(value);\n+        }\n+        return buckets;\n+    }\n+\n+    public static void reverse(Map source, Map target) {\n+        for (Iterator it = source.keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            target.put(source.get(key), key);\n+        }\n+    }\n+\n+    public static Collection filter(Collection c, Predicate p) {\n+        Iterator it = c.iterator();\n+        while (it.hasNext()) {\n+            if (!p.evaluate(it.next())) {\n+                it.remove();\n+            }\n+        }\n+        return c;\n+    }\n+\n+    public static List transform(Collection c, Transformer t) {\n+        List result = new ArrayList(c.size());\n+        for (Iterator it = c.iterator(); it.hasNext();) {\n+            result.add(t.transform(it.next()));\n+        }\n+        return result;\n+    }\n+\n+    public static Map getIndexMap(List list) {\n+        Map indexes = new HashMap();\n+        int index = 0;\n+        for (Iterator it = list.iterator(); it.hasNext();) {\n+            indexes.put(it.next(), new Integer(index++));\n+        }\n+        return indexes;\n+    }\n+}    \n+    \n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Constants.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Type;\n+\n+/**\n+ * @author Juozas Baliuka <a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt</a>\n+ * @version $Id: Constants.java,v 1.21 2006/03/05 02:43:19 herbyderby Exp $\n+ */\n+public interface Constants extends org.mockito.asm.Opcodes {\n+    public static final Class[] EMPTY_CLASS_ARRAY = {};\n+    public static final Type[] TYPES_EMPTY = {};\n+\n+    public static final Signature SIG_STATIC =\n+      TypeUtils.parseSignature(\"void <clinit>()\");\n+    \n+    public static final Type TYPE_OBJECT_ARRAY = TypeUtils.parseType(\"Object[]\");\n+    public static final Type TYPE_CLASS_ARRAY = TypeUtils.parseType(\"Class[]\");\n+    public static final Type TYPE_STRING_ARRAY = TypeUtils.parseType(\"String[]\");\n+\n+    public static final Type TYPE_OBJECT = TypeUtils.parseType(\"Object\");\n+    public static final Type TYPE_CLASS = TypeUtils.parseType(\"Class\");\n+    public static final Type TYPE_CLASS_LOADER = TypeUtils.parseType(\"ClassLoader\");\n+    public static final Type TYPE_CHARACTER = TypeUtils.parseType(\"Character\");\n+    public static final Type TYPE_BOOLEAN = TypeUtils.parseType(\"Boolean\");\n+    public static final Type TYPE_DOUBLE = TypeUtils.parseType(\"Double\");\n+    public static final Type TYPE_FLOAT = TypeUtils.parseType(\"Float\");\n+    public static final Type TYPE_LONG = TypeUtils.parseType(\"Long\");\n+    public static final Type TYPE_INTEGER = TypeUtils.parseType(\"Integer\");\n+    public static final Type TYPE_SHORT = TypeUtils.parseType(\"Short\");\n+    public static final Type TYPE_BYTE = TypeUtils.parseType(\"Byte\");\n+    public static final Type TYPE_NUMBER = TypeUtils.parseType(\"Number\");\n+    public static final Type TYPE_STRING = TypeUtils.parseType(\"String\");\n+    public static final Type TYPE_THROWABLE = TypeUtils.parseType(\"Throwable\");\n+    public static final Type TYPE_BIG_INTEGER = TypeUtils.parseType(\"java.math.BigInteger\");\n+    public static final Type TYPE_BIG_DECIMAL = TypeUtils.parseType(\"java.math.BigDecimal\");\n+    public static final Type TYPE_STRING_BUFFER = TypeUtils.parseType(\"StringBuffer\");\n+    public static final Type TYPE_RUNTIME_EXCEPTION = TypeUtils.parseType(\"RuntimeException\");\n+    public static final Type TYPE_ERROR = TypeUtils.parseType(\"Error\");\n+    public static final Type TYPE_SYSTEM = TypeUtils.parseType(\"System\");\n+    public static final Type TYPE_SIGNATURE = TypeUtils.parseType(\"org.mockito.cglib.core.Signature\");\n+    \n+    public static final String CONSTRUCTOR_NAME = \"<init>\";\n+    public static final String STATIC_NAME = \"<clinit>\";\n+    public static final String SOURCE_FILE = \"<generated>\";\n+    public static final String SUID_FIELD_NAME = \"serialVersionUID\";\n+\n+    public static final int PRIVATE_FINAL_STATIC = ACC_PRIVATE | ACC_FINAL | ACC_STATIC;\n+\n+    public static final int SWITCH_STYLE_TRIE = 0;\n+    public static final int SWITCH_STYLE_HASH = 1;\n+    public static final int SWITCH_STYLE_HASHONLY = 2;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Converter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+public interface Converter {\n+    Object convert(Object value, Class target, Object context);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Customizer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Type;\n+\n+public interface Customizer {\n+    void customize(CodeEmitter e, Type type);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/DebuggingClassWriter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassWriter;\n+import org.mockito.asm.util.TraceClassVisitor;\n+\n+import java.io.*;\n+\n+public class DebuggingClassWriter extends ClassWriter {\n+    \n+    public static final String DEBUG_LOCATION_PROPERTY = \"cglib.debugLocation\";\n+    \n+    private static String debugLocation;\n+    private static boolean traceEnabled;\n+    \n+    private String className;\n+    private String superName;\n+    \n+    static {\n+        debugLocation = System.getProperty(DEBUG_LOCATION_PROPERTY);\n+        if (debugLocation != null) {\n+            System.err.println(\"CGLIB debugging enabled, writing to '\" + debugLocation + \"'\");\n+            try {\n+                Class.forName(\"org.mockito.asm.util.TraceClassVisitor\");\n+                traceEnabled = true;\n+            } catch (Throwable ignore) {\n+            }\n+        }\n+    }\n+    \n+    public DebuggingClassWriter(int flags) {\n+        super(flags);\n+    }\n+\n+    public void visit(int version,\n+                      int access,\n+                      String name,\n+                      String signature,\n+                      String superName,\n+                      String[] interfaces) {\n+        className = name.replace('/', '.');\n+        this.superName = superName.replace('/', '.');\n+        super.visit(version, access, name, signature, superName, interfaces);\n+    }\n+    \n+    public String getClassName() {\n+        return className;\n+    }\n+    \n+    public String getSuperName() {\n+        return superName;\n+    }\n+    \n+    public byte[] toByteArray() {\n+        \n+      return (byte[]) java.security.AccessController.doPrivileged(\n+        new java.security.PrivilegedAction() {\n+            public Object run() {\n+                \n+                \n+                byte[] b = DebuggingClassWriter.super.toByteArray();\n+                if (debugLocation != null) {\n+                    String dirs = className.replace('.', File.separatorChar);\n+                    try {\n+                        new File(debugLocation + File.separatorChar + dirs).getParentFile().mkdirs();\n+                        \n+                        File file = new File(new File(debugLocation), dirs + \".class\");\n+                        OutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n+                        try {\n+                            out.write(b);\n+                        } finally {\n+                            out.close();\n+                        }\n+                        \n+                        if (traceEnabled) {\n+                            file = new File(new File(debugLocation), dirs + \".asm\");\n+                            out = new BufferedOutputStream(new FileOutputStream(file));\n+                            try {\n+                                ClassReader cr = new ClassReader(b);\n+                                PrintWriter pw = new PrintWriter(new OutputStreamWriter(out));\n+                                TraceClassVisitor tcv = new TraceClassVisitor(null, pw);\n+                                cr.accept(tcv, 0);\n+                                pw.flush();\n+                            } finally {\n+                                out.close();\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        throw new CodeGenerationException(e);\n+                    }\n+                }\n+                return b;\n+             }  \n+            });\n+            \n+        }\n+    }\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/DefaultGeneratorStrategy.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.ClassWriter;\n+\n+public class DefaultGeneratorStrategy implements GeneratorStrategy {\n+    public static final DefaultGeneratorStrategy INSTANCE = new DefaultGeneratorStrategy();\n+    \n+    public byte[] generate(ClassGenerator cg) throws Exception {\n+        ClassWriter cw = getClassWriter();\n+        transform(cg).generateClass(cw);\n+        return transform(cw.toByteArray());\n+    }\n+\n+    protected ClassWriter getClassWriter() throws Exception {\n+      return new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);\n+    }\n+\n+    protected byte[] transform(byte[] b) throws Exception {\n+        return b;\n+    }\n+\n+    protected ClassGenerator transform(ClassGenerator cg) throws Exception {\n+        return cg;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/DefaultNamingPolicy.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.util.Set;\n+\n+/**\n+ * The default policy used by {@link AbstractClassGenerator}.\n+ * Generates names such as\n+ * <p><code>org.mockito.cglib.Foo$$EnhancerByCGLIB$$38272841</code><p>\n+ * This is composed of a prefix based on the name of the superclass, a fixed\n+ * string incorporating the CGLIB class responsible for generation, and a\n+ * hashcode derived from the parameters used to create the object. If the same\n+ * name has been previously been used in the same <code>ClassLoader</code>, a\n+ * suffix is added to ensure uniqueness.\n+ */\n+public class DefaultNamingPolicy implements NamingPolicy {\n+    public static final DefaultNamingPolicy INSTANCE = new DefaultNamingPolicy();\n+    \n+    public String getClassName(String prefix, String source, Object key, Predicate names) {\n+        if (prefix == null) {\n+            prefix = \"org.mockito.cglib.empty.Object\";\n+        } else if (prefix.startsWith(\"java\")) {\n+            prefix = \"$\" + prefix;\n+        }\n+        String base =\n+            prefix + \"$$\" + \n+            source.substring(source.lastIndexOf('.') + 1) +\n+            getTag() + \"$$\" +\n+            Integer.toHexString(key.hashCode());\n+        String attempt = base;\n+        int index = 2;\n+        while (names.evaluate(attempt))\n+            attempt = base + \"_\" + index++;\n+        return attempt;\n+    }\n+\n+    /**\n+     * Returns a string which is incorporated into every generated class name.\n+     * By default returns \"ByCGLIB\"\n+     */\n+    protected String getTag() {\n+        return \"ByCGLIB\";\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/DuplicatesPredicate.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+public class DuplicatesPredicate implements Predicate {\n+    private Set unique = new HashSet();\n+\n+    public boolean evaluate(Object arg) {\n+        return unique.add(MethodWrapper.create((Method)arg));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/EmitUtils.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+\n+public class EmitUtils {\n+    private static final Signature CSTRUCT_NULL =\n+      TypeUtils.parseConstructor(\"\");\n+    private static final Signature CSTRUCT_THROWABLE =\n+      TypeUtils.parseConstructor(\"Throwable\");\n+\n+    private static final Signature GET_NAME =\n+      TypeUtils.parseSignature(\"String getName()\");\n+    private static final Signature HASH_CODE =\n+      TypeUtils.parseSignature(\"int hashCode()\");\n+    private static final Signature EQUALS =\n+      TypeUtils.parseSignature(\"boolean equals(Object)\");\n+    private static final Signature STRING_LENGTH =\n+      TypeUtils.parseSignature(\"int length()\");\n+    private static final Signature STRING_CHAR_AT =\n+      TypeUtils.parseSignature(\"char charAt(int)\");\n+    private static final Signature FOR_NAME =\n+      TypeUtils.parseSignature(\"Class forName(String)\");\n+    private static final Signature DOUBLE_TO_LONG_BITS =\n+      TypeUtils.parseSignature(\"long doubleToLongBits(double)\");\n+    private static final Signature FLOAT_TO_INT_BITS =\n+      TypeUtils.parseSignature(\"int floatToIntBits(float)\");\n+    private static final Signature TO_STRING =\n+      TypeUtils.parseSignature(\"String toString()\");\n+    private static final Signature APPEND_STRING =\n+      TypeUtils.parseSignature(\"StringBuffer append(String)\");\n+    private static final Signature APPEND_INT =\n+      TypeUtils.parseSignature(\"StringBuffer append(int)\");\n+    private static final Signature APPEND_DOUBLE =\n+      TypeUtils.parseSignature(\"StringBuffer append(double)\");\n+    private static final Signature APPEND_FLOAT =\n+      TypeUtils.parseSignature(\"StringBuffer append(float)\");\n+    private static final Signature APPEND_CHAR =\n+      TypeUtils.parseSignature(\"StringBuffer append(char)\");\n+    private static final Signature APPEND_LONG =\n+      TypeUtils.parseSignature(\"StringBuffer append(long)\");\n+    private static final Signature APPEND_BOOLEAN =\n+      TypeUtils.parseSignature(\"StringBuffer append(boolean)\");\n+    private static final Signature LENGTH =\n+      TypeUtils.parseSignature(\"int length()\");\n+    private static final Signature SET_LENGTH =\n+      TypeUtils.parseSignature(\"void setLength(int)\");\n+    private static final Signature GET_DECLARED_METHOD =\n+      TypeUtils.parseSignature(\"java.lang.reflect.Method getDeclaredMethod(String, Class[])\");\n+     \n+    \n+\n+    public static final ArrayDelimiters DEFAULT_DELIMITERS = new ArrayDelimiters(\"{\", \", \", \"}\");\n+\n+    private EmitUtils() {\n+    }\n+\n+    public static void factory_method(ClassEmitter ce, Signature sig) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, sig, null);\n+        e.new_instance_this();\n+        e.dup();\n+        e.load_args();\n+        e.invoke_constructor_this(TypeUtils.parseConstructor(sig.getArgumentTypes()));\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    public static void null_constructor(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, CSTRUCT_NULL, null);\n+        e.load_this();\n+        e.super_invoke_constructor();\n+        e.return_value();\n+        e.end_method();\n+    }\n+    \n+    /**\n+     * Process an array on the stack. Assumes the top item on the stack\n+     * is an array of the specified type. For each element in the array,\n+     * puts the element on the stack and triggers the callback.\n+     * @param type the type of the array (type.isArray() must be true)\n+     * @param callback the callback triggered for each element\n+     */\n+    public static void process_array(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n+        Type componentType = TypeUtils.getComponentType(type);\n+        Local array = e.make_local();\n+        Local loopvar = e.make_local(Type.INT_TYPE);\n+        Label loopbody = e.make_label();\n+        Label checkloop = e.make_label();\n+        e.store_local(array);\n+        e.push(0);\n+        e.store_local(loopvar);\n+        e.goTo(checkloop);\n+        \n+        e.mark(loopbody);\n+        e.load_local(array);\n+        e.load_local(loopvar);\n+        e.array_load(componentType);\n+        callback.processElement(componentType);\n+        e.iinc(loopvar, 1);\n+        \n+        e.mark(checkloop);\n+        e.load_local(loopvar);\n+        e.load_local(array);\n+        e.arraylength();\n+        e.if_icmp(e.LT, loopbody);\n+    }\n+    \n+    /**\n+     * Process two arrays on the stack in parallel. Assumes the top two items on the stack\n+     * are arrays of the specified class. The arrays must be the same length. For each pair\n+     * of elements in the arrays, puts the pair on the stack and triggers the callback.\n+     * @param type the type of the arrays (type.isArray() must be true)\n+     * @param callback the callback triggered for each pair of elements\n+     */\n+    public static void process_arrays(CodeEmitter e, Type type, ProcessArrayCallback callback) {\n+        Type componentType = TypeUtils.getComponentType(type);\n+        Local array1 = e.make_local();\n+        Local array2 = e.make_local();\n+        Local loopvar = e.make_local(Type.INT_TYPE);\n+        Label loopbody = e.make_label();\n+        Label checkloop = e.make_label();\n+        e.store_local(array1);\n+        e.store_local(array2);\n+        e.push(0);\n+        e.store_local(loopvar);\n+        e.goTo(checkloop);\n+        \n+        e.mark(loopbody);\n+        e.load_local(array1);\n+        e.load_local(loopvar);\n+        e.array_load(componentType);\n+        e.load_local(array2);\n+        e.load_local(loopvar);\n+        e.array_load(componentType);\n+        callback.processElement(componentType);\n+        e.iinc(loopvar, 1);\n+        \n+        e.mark(checkloop);\n+        e.load_local(loopvar);\n+        e.load_local(array1);\n+        e.arraylength();\n+        e.if_icmp(e.LT, loopbody);\n+    }\n+    \n+    public static void string_switch(CodeEmitter e, String[] strings, int switchStyle, ObjectSwitchCallback callback) {\n+        try {\n+            switch (switchStyle) {\n+            case Constants.SWITCH_STYLE_TRIE:\n+                string_switch_trie(e, strings, callback);\n+                break;\n+            case Constants.SWITCH_STYLE_HASH:\n+                string_switch_hash(e, strings, callback, false);\n+                break;\n+            case Constants.SWITCH_STYLE_HASHONLY:\n+                string_switch_hash(e, strings, callback, true);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"unknown switch style \" + switchStyle);\n+            }\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (Error ex) {\n+            throw ex;\n+        } catch (Exception ex) {\n+            throw new CodeGenerationException(ex);\n+        }\n+    }\n+\n+    private static void string_switch_trie(final CodeEmitter e,\n+                                           String[] strings,\n+                                           final ObjectSwitchCallback callback) throws Exception {\n+        final Label def = e.make_label();\n+        final Label end = e.make_label();\n+        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), new Transformer() {\n+            public Object transform(Object value) {\n+                return new Integer(((String)value).length());\n+            }\n+        });\n+        e.dup();\n+        e.invoke_virtual(Constants.TYPE_STRING, STRING_LENGTH);\n+        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n+                public void processCase(int key, Label ignore_end) throws Exception {\n+                    List bucket = (List)buckets.get(new Integer(key));\n+                    stringSwitchHelper(e, bucket, callback, def, end, 0);\n+                }\n+                public void processDefault() {\n+                    e.goTo(def);\n+                }\n+            });\n+        e.mark(def);\n+        e.pop();\n+        callback.processDefault();\n+        e.mark(end);\n+    }\n+\n+    private static void stringSwitchHelper(final CodeEmitter e,\n+                                           List strings,\n+                                           final ObjectSwitchCallback callback,\n+                                           final Label def,\n+                                           final Label end,\n+                                           final int index) throws Exception {\n+        final int len = ((String)strings.get(0)).length();\n+        final Map buckets = CollectionUtils.bucket(strings, new Transformer() {\n+            public Object transform(Object value) {\n+                return new Integer(((String)value).charAt(index));\n+            }\n+        });\n+        e.dup();\n+        e.push(index);\n+        e.invoke_virtual(Constants.TYPE_STRING, STRING_CHAR_AT);\n+        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n+                public void processCase(int key, Label ignore_end) throws Exception {\n+                    List bucket = (List)buckets.get(new Integer(key));\n+                    if (index + 1 == len) {\n+                        e.pop();\n+                        callback.processCase(bucket.get(0), end);\n+                    } else {\n+                        stringSwitchHelper(e, bucket, callback, def, end, index + 1);\n+                    }\n+                }\n+                public void processDefault() {\n+                    e.goTo(def);\n+                }\n+            });\n+    }        \n+\n+    static int[] getSwitchKeys(Map buckets) {\n+        int[] keys = new int[buckets.size()];\n+        int index = 0;\n+        for (Iterator it = buckets.keySet().iterator(); it.hasNext();) {\n+            keys[index++] = ((Integer)it.next()).intValue();\n+        }\n+        Arrays.sort(keys);\n+        return keys;\n+    }\n+\n+    private static void string_switch_hash(final CodeEmitter e,\n+                                           final String[] strings,\n+                                           final ObjectSwitchCallback callback,\n+                                           final boolean skipEquals) throws Exception {\n+        final Map buckets = CollectionUtils.bucket(Arrays.asList(strings), new Transformer() {\n+            public Object transform(Object value) {\n+                return new Integer(value.hashCode());\n+            }\n+        });\n+        final Label def = e.make_label();\n+        final Label end = e.make_label();\n+        e.dup();\n+        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n+        e.process_switch(getSwitchKeys(buckets), new ProcessSwitchCallback() {\n+            public void processCase(int key, Label ignore_end) throws Exception {\n+                List bucket = (List)buckets.get(new Integer(key));\n+                Label next = null;\n+                if (skipEquals && bucket.size() == 1) {\n+                    if (skipEquals)\n+                        e.pop();\n+                    callback.processCase((String)bucket.get(0), end);\n+                } else {\n+                    for (Iterator it = bucket.iterator(); it.hasNext();) {\n+                        String string = (String)it.next();\n+                        if (next != null) {\n+                            e.mark(next);\n+                        }\n+                        if (it.hasNext()) {\n+                            e.dup();\n+                        }\n+                        e.push(string);\n+                        e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n+                        if (it.hasNext()) {\n+                            e.if_jump(e.EQ, next = e.make_label());\n+                            e.pop();\n+                        } else {\n+                            e.if_jump(e.EQ, def);\n+                        }\n+                        callback.processCase(string, end);\n+                    }\n+                }\n+            }\n+            public void processDefault() {\n+                e.pop();\n+            }\n+        });\n+        e.mark(def);\n+        callback.processDefault();\n+        e.mark(end);\n+    }\n+\n+    public static void load_class_this(CodeEmitter e) {\n+        load_class_helper(e, e.getClassEmitter().getClassType());\n+    }\n+    \n+    public static void load_class(CodeEmitter e, Type type) {\n+        if (TypeUtils.isPrimitive(type)) {\n+            if (type == Type.VOID_TYPE) {\n+                throw new IllegalArgumentException(\"cannot load void type\");\n+            }\n+            e.getstatic(TypeUtils.getBoxedType(type), \"TYPE\", Constants.TYPE_CLASS);\n+        } else {\n+            load_class_helper(e, type);\n+        }\n+    }\n+\n+    private static void load_class_helper(CodeEmitter e, final Type type) {\n+        if (e.isStaticHook()) {\n+            // have to fall back on non-optimized load\n+            e.push(TypeUtils.emulateClassGetName(type));\n+            e.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n+        } else {\n+            ClassEmitter ce = e.getClassEmitter();\n+            String typeName = TypeUtils.emulateClassGetName(type);\n+\n+            // TODO: can end up with duplicated field names when using chained transformers; incorporate static hook # somehow\n+            String fieldName = \"CGLIB$load_class$\" + TypeUtils.escapeType(typeName);\n+            if (!ce.isFieldDeclared(fieldName)) {\n+                ce.declare_field(Constants.PRIVATE_FINAL_STATIC, fieldName, Constants.TYPE_CLASS, null);\n+                CodeEmitter hook = ce.getStaticHook();\n+                hook.push(typeName);\n+                hook.invoke_static(Constants.TYPE_CLASS, FOR_NAME);\n+                hook.putstatic(ce.getClassType(), fieldName, Constants.TYPE_CLASS);\n+            }\n+            e.getfield(fieldName);\n+        }\n+    }\n+\n+    public static void push_array(CodeEmitter e, Object[] array) {\n+        e.push(array.length);\n+        e.newarray(Type.getType(remapComponentType(array.getClass().getComponentType())));\n+        for (int i = 0; i < array.length; i++) {\n+            e.dup();\n+            e.push(i);\n+            push_object(e, array[i]);\n+            e.aastore();\n+        }\n+    }\n+\n+    private static Class remapComponentType(Class componentType) {\n+        if (componentType.equals(Type.class))\n+            return Class.class;\n+        return componentType;\n+    }\n+    \n+    public static void push_object(CodeEmitter e, Object obj) {\n+        if (obj == null) {\n+            e.aconst_null();\n+        } else {\n+            Class type = obj.getClass();\n+            if (type.isArray()) {\n+                push_array(e, (Object[])obj);\n+            } else if (obj instanceof String) {\n+                e.push((String)obj);\n+            } else if (obj instanceof Type) {\n+                load_class(e, (Type)obj);\n+            } else if (obj instanceof Class) {\n+                load_class(e, Type.getType((Class)obj));\n+            } else if (obj instanceof BigInteger) {\n+                e.new_instance(Constants.TYPE_BIG_INTEGER);\n+                e.dup();\n+                e.push(obj.toString());\n+                e.invoke_constructor(Constants.TYPE_BIG_INTEGER);\n+            } else if (obj instanceof BigDecimal) {\n+                e.new_instance(Constants.TYPE_BIG_DECIMAL);\n+                e.dup();\n+                e.push(obj.toString());\n+                e.invoke_constructor(Constants.TYPE_BIG_DECIMAL);\n+            } else {\n+                throw new IllegalArgumentException(\"unknown type: \" + obj.getClass());\n+            }\n+        }\n+    }\n+\n+    public static void hash_code(CodeEmitter e, Type type, int multiplier, Customizer customizer) {\n+        if (TypeUtils.isArray(type)) {\n+            hash_array(e, type, multiplier, customizer);\n+        } else {\n+            e.swap(Type.INT_TYPE, type);\n+            e.push(multiplier);\n+            e.math(e.MUL, Type.INT_TYPE);\n+            e.swap(type, Type.INT_TYPE);\n+            if (TypeUtils.isPrimitive(type)) {\n+                hash_primitive(e, type);\n+            } else {\n+                hash_object(e, type, customizer);\n+            }\n+            e.math(e.ADD, Type.INT_TYPE);\n+        }\n+    }\n+\n+    private static void hash_array(final CodeEmitter e, Type type, final int multiplier, final Customizer customizer) {\n+        Label skip = e.make_label();\n+        Label end = e.make_label();\n+        e.dup();\n+        e.ifnull(skip);\n+        EmitUtils.process_array(e, type, new ProcessArrayCallback() {\n+            public void processElement(Type type) {\n+                hash_code(e, type, multiplier, customizer);\n+            }\n+        });\n+        e.goTo(end);\n+        e.mark(skip);\n+        e.pop();\n+        e.mark(end);\n+    }\n+\n+    private static void hash_object(CodeEmitter e, Type type, Customizer customizer) {\n+        // (f == null) ? 0 : f.hashCode();\n+        Label skip = e.make_label();\n+        Label end = e.make_label();\n+        e.dup();\n+        e.ifnull(skip);\n+        if (customizer != null) {\n+            customizer.customize(e, type);\n+        }\n+        e.invoke_virtual(Constants.TYPE_OBJECT, HASH_CODE);\n+        e.goTo(end);\n+        e.mark(skip);\n+        e.pop();\n+        e.push(0);\n+        e.mark(end);\n+    }\n+\n+    private static void hash_primitive(CodeEmitter e, Type type) {\n+        switch (type.getSort()) {\n+        case Type.BOOLEAN:\n+            // f ? 0 : 1\n+            e.push(1);\n+            e.math(e.XOR, Type.INT_TYPE);\n+            break;\n+        case Type.FLOAT:\n+            // Float.floatToIntBits(f)\n+            e.invoke_static(Constants.TYPE_FLOAT, FLOAT_TO_INT_BITS);\n+            break;\n+        case Type.DOUBLE:\n+            // Double.doubleToLongBits(f), hash_code(Long.TYPE)\n+            e.invoke_static(Constants.TYPE_DOUBLE, DOUBLE_TO_LONG_BITS);\n+            // fall through\n+        case Type.LONG:\n+            hash_long(e);\n+        }\n+    }\n+\n+    private static void hash_long(CodeEmitter e) {\n+        // (int)(f ^ (f >>> 32))\n+        e.dup2();\n+        e.push(32);\n+        e.math(e.USHR, Type.LONG_TYPE);\n+        e.math(e.XOR, Type.LONG_TYPE);\n+        e.cast_numeric(Type.LONG_TYPE, Type.INT_TYPE);\n+    }\n+\n+//     public static void not_equals(CodeEmitter e, Type type, Label notEquals) {\n+//         not_equals(e, type, notEquals, null);\n+//     }\n+    \n+    /**\n+     * Branches to the specified label if the top two items on the stack\n+     * are not equal. The items must both be of the specified\n+     * class. Equality is determined by comparing primitive values\n+     * directly and by invoking the <code>equals</code> method for\n+     * Objects. Arrays are recursively processed in the same manner.\n+     */\n+    public static void not_equals(final CodeEmitter e, Type type, final Label notEquals, final Customizer customizer) {\n+        (new ProcessArrayCallback() {\n+            public void processElement(Type type) {\n+                not_equals_helper(e, type, notEquals, customizer, this);\n+            }\n+        }).processElement(type);\n+    }\n+    \n+    private static void not_equals_helper(CodeEmitter e,\n+                                          Type type,\n+                                          Label notEquals,\n+                                          Customizer customizer,\n+                                          ProcessArrayCallback callback) {\n+        if (TypeUtils.isPrimitive(type)) {\n+            e.if_cmp(type, e.NE, notEquals);\n+        } else {\n+            Label end = e.make_label();\n+            nullcmp(e, notEquals, end);\n+            if (TypeUtils.isArray(type)) {\n+                Label checkContents = e.make_label();\n+                e.dup2();\n+                e.arraylength();\n+                e.swap();\n+                e.arraylength();\n+                e.if_icmp(e.EQ, checkContents);\n+                e.pop2();\n+                e.goTo(notEquals);\n+                e.mark(checkContents);\n+                EmitUtils.process_arrays(e, type, callback);\n+            } else {\n+                if (customizer != null) {\n+                    customizer.customize(e, type);\n+                    e.swap();\n+                    customizer.customize(e, type);\n+                }\n+                e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n+                e.if_jump(e.EQ, notEquals);\n+            }\n+            e.mark(end);\n+        }\n+    }\n+\n+    /**\n+     * If both objects on the top of the stack are non-null, does nothing.\n+     * If one is null, or both are null, both are popped off and execution\n+     * branches to the respective label.\n+     * @param oneNull label to branch to if only one of the objects is null\n+     * @param bothNull label to branch to if both of the objects are null\n+     */\n+    private static void nullcmp(CodeEmitter e, Label oneNull, Label bothNull) {\n+        e.dup2();\n+        Label nonNull = e.make_label();\n+        Label oneNullHelper = e.make_label();\n+        Label end = e.make_label();\n+        e.ifnonnull(nonNull);\n+        e.ifnonnull(oneNullHelper);\n+        e.pop2();\n+        e.goTo(bothNull);\n+        \n+        e.mark(nonNull);\n+        e.ifnull(oneNullHelper);\n+        e.goTo(end);\n+        \n+        e.mark(oneNullHelper);\n+        e.pop2();\n+        e.goTo(oneNull);\n+        \n+        e.mark(end);\n+    }\n+\n+    /*\n+    public static void to_string(CodeEmitter e,\n+                                 Type type,\n+                                 ArrayDelimiters delims,\n+                                 Customizer customizer) {\n+        e.new_instance(Constants.TYPE_STRING_BUFFER);\n+        e.dup();\n+        e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n+        e.swap();\n+        append_string(e, type, delims, customizer);\n+        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n+    }\n+    */\n+\n+    public static void append_string(final CodeEmitter e,\n+                                     Type type,\n+                                     final ArrayDelimiters delims,\n+                                     final Customizer customizer) {\n+        final ArrayDelimiters d = (delims != null) ? delims : DEFAULT_DELIMITERS;\n+        ProcessArrayCallback callback = new ProcessArrayCallback() {\n+            public void processElement(Type type) {\n+                append_string_helper(e, type, d, customizer, this);\n+                e.push(d.inside);\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n+            }\n+        };\n+        append_string_helper(e, type, d, customizer, callback);\n+    }\n+\n+    private static void append_string_helper(CodeEmitter e,\n+                                             Type type,\n+                                             ArrayDelimiters delims,\n+                                             Customizer customizer,\n+                                             ProcessArrayCallback callback) {\n+        Label skip = e.make_label();\n+        Label end = e.make_label();\n+        if (TypeUtils.isPrimitive(type)) {\n+            switch (type.getSort()) {\n+            case Type.INT:\n+            case Type.SHORT:\n+            case Type.BYTE:\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_INT);\n+                break;\n+            case Type.DOUBLE:\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_DOUBLE);\n+                break;\n+            case Type.FLOAT:\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_FLOAT);\n+                break;\n+            case Type.LONG:\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_LONG);\n+                break;\n+            case Type.BOOLEAN:\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_BOOLEAN);\n+                break;\n+            case Type.CHAR:\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_CHAR);\n+                break;\n+            }\n+        } else if (TypeUtils.isArray(type)) {\n+            e.dup();\n+            e.ifnull(skip);\n+            e.swap();\n+            if (delims != null && delims.before != null && !\"\".equals(delims.before)) {\n+                e.push(delims.before);\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n+                e.swap();\n+            }\n+            EmitUtils.process_array(e, type, callback);\n+            shrinkStringBuffer(e, 2);\n+            if (delims != null && delims.after != null && !\"\".equals(delims.after)) {\n+                e.push(delims.after);\n+                e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n+            }\n+        } else {\n+            e.dup();\n+            e.ifnull(skip);\n+            if (customizer != null) {\n+                customizer.customize(e, type);\n+            }\n+            e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n+            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n+        }\n+        e.goTo(end);\n+        e.mark(skip);\n+        e.pop();\n+        e.push(\"null\");\n+        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n+        e.mark(end);\n+    }\n+\n+    private static void shrinkStringBuffer(CodeEmitter e, int amt) {\n+        e.dup();\n+        e.dup();\n+        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, LENGTH);\n+        e.push(amt);\n+        e.math(e.SUB, Type.INT_TYPE);\n+        e.invoke_virtual(Constants.TYPE_STRING_BUFFER, SET_LENGTH);\n+    }\n+\n+    public static class ArrayDelimiters {\n+        private String before;\n+        private String inside;\n+        private String after;\n+            \n+        public ArrayDelimiters(String before, String inside, String after) {\n+            this.before = before;\n+            this.inside = inside;\n+            this.after = after;\n+        }\n+    }\n+\n+    public static void load_method(CodeEmitter e, MethodInfo method) {\n+        load_class(e, method.getClassInfo().getType());\n+        e.push(method.getSignature().getName());\n+        push_object(e, method.getSignature().getArgumentTypes());\n+        e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHOD);\n+    }\n+\n+    private interface ParameterTyper {\n+        Type[] getParameterTypes(MethodInfo member);\n+    }\n+\n+    public static void method_switch(CodeEmitter e,\n+                                     List methods,\n+                                     ObjectSwitchCallback callback) {\n+        member_switch_helper(e, methods, callback, true);\n+    }\n+\n+    public static void constructor_switch(CodeEmitter e,\n+                                          List constructors,\n+                                          ObjectSwitchCallback callback) {\n+        member_switch_helper(e, constructors, callback, false);\n+    }\n+\n+    private static void member_switch_helper(final CodeEmitter e,\n+                                             List members,\n+                                             final ObjectSwitchCallback callback,\n+                                             boolean useName) {\n+        try {\n+            final Map cache = new HashMap();\n+            final ParameterTyper cached = new ParameterTyper() {\n+                    public Type[] getParameterTypes(MethodInfo member) {\n+                        Type[] types = (Type[])cache.get(member);\n+                        if (types == null) {\n+                            cache.put(member, types = member.getSignature().getArgumentTypes());\n+                        }\n+                        return types;\n+                    }\n+                };\n+            final Label def = e.make_label();\n+            final Label end = e.make_label();\n+            if (useName) {\n+                e.swap();\n+                final Map buckets = CollectionUtils.bucket(members, new Transformer() {\n+                        public Object transform(Object value) {\n+                            return ((MethodInfo)value).getSignature().getName();\n+                        }\n+                    });\n+                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n+                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+                        public void processCase(Object key, Label dontUseEnd) throws Exception {\n+                            member_helper_size(e, (List)buckets.get(key), callback, cached, def, end);\n+                        }\n+                        public void processDefault() throws Exception {\n+                            e.goTo(def);\n+                        }\n+                    });\n+            } else {\n+                member_helper_size(e, members, callback, cached, def, end);\n+            }\n+            e.mark(def);\n+            e.pop();\n+            callback.processDefault();\n+            e.mark(end);\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (Error ex) {\n+            throw ex;\n+        } catch (Exception ex) {\n+            throw new CodeGenerationException(ex);\n+        }\n+    }\n+\n+    private static void member_helper_size(final CodeEmitter e,\n+                                           List members,\n+                                           final ObjectSwitchCallback callback,\n+                                           final ParameterTyper typer,\n+                                           final Label def,\n+                                           final Label end) throws Exception {\n+        final Map buckets = CollectionUtils.bucket(members, new Transformer() {\n+            public Object transform(Object value) {\n+                return new Integer(typer.getParameterTypes((MethodInfo)value).length);\n+            }\n+        });\n+        e.dup();\n+        e.arraylength();\n+        e.process_switch(EmitUtils.getSwitchKeys(buckets), new ProcessSwitchCallback() {\n+            public void processCase(int key, Label dontUseEnd) throws Exception {\n+                List bucket = (List)buckets.get(new Integer(key));\n+                member_helper_type(e, bucket, callback, typer, def, end, new BitSet());\n+            }\n+            public void processDefault() throws Exception {\n+                e.goTo(def);\n+            }\n+        });\n+    }\n+\n+    private static void member_helper_type(final CodeEmitter e,\n+                                           List members,\n+                                           final ObjectSwitchCallback callback,\n+                                           final ParameterTyper typer,\n+                                           final Label def,\n+                                           final Label end,\n+                                           final BitSet checked) throws Exception {\n+        if (members.size() == 1) {\n+            MethodInfo member = (MethodInfo)members.get(0);\n+            Type[] types = typer.getParameterTypes(member);\n+            // need to check classes that have not already been checked via switches\n+            for (int i = 0; i < types.length; i++) {\n+                if (checked == null || !checked.get(i)) {\n+                    e.dup();\n+                    e.aaload(i);\n+                    e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n+                    e.push(TypeUtils.emulateClassGetName(types[i]));\n+                    e.invoke_virtual(Constants.TYPE_OBJECT, EQUALS);\n+                    e.if_jump(e.EQ, def);\n+                }\n+            }\n+            e.pop();\n+            callback.processCase(member, end);\n+        } else {\n+            // choose the index that has the best chance of uniquely identifying member\n+            Type[] example = typer.getParameterTypes((MethodInfo)members.get(0));\n+            Map buckets = null;\n+            int index = -1;\n+            for (int i = 0; i < example.length; i++) {\n+                final int j = i;\n+                Map test = CollectionUtils.bucket(members, new Transformer() {\n+                    public Object transform(Object value) {\n+                        return TypeUtils.emulateClassGetName(typer.getParameterTypes((MethodInfo)value)[j]);\n+                    }\n+                });\n+                if (buckets == null || test.size() > buckets.size()) {\n+                    buckets = test;\n+                    index = i;\n+                }\n+            }\n+            if (buckets == null || buckets.size() == 1) {\n+                // TODO: switch by returnType\n+                // must have two methods with same name, types, and different return types\n+                e.goTo(def);\n+            } else {\n+                checked.set(index);\n+\n+                e.dup();\n+                e.aaload(index);\n+                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n+\n+                final Map fbuckets = buckets;\n+                String[] names = (String[])buckets.keySet().toArray(new String[buckets.size()]);\n+                EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+                    public void processCase(Object key, Label dontUseEnd) throws Exception {\n+                        member_helper_type(e, (List)fbuckets.get(key), callback, typer, def, end, checked);\n+                    }\n+                    public void processDefault() throws Exception {\n+                        e.goTo(def);\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public static void wrap_throwable(Block block, Type wrapper) {\n+        CodeEmitter e = block.getCodeEmitter();\n+        e.catch_exception(block, Constants.TYPE_THROWABLE);\n+        e.new_instance(wrapper);\n+        e.dup_x1();\n+        e.swap();\n+        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n+        e.athrow();\n+    }\n+\n+    public static void add_properties(ClassEmitter ce, String[] names, Type[] types) {\n+        for (int i = 0; i < names.length; i++) {\n+            String fieldName = \"$cglib_prop_\" + names[i];\n+            ce.declare_field(Constants.ACC_PRIVATE, fieldName, types[i], null);\n+            EmitUtils.add_property(ce, names[i], types[i], fieldName);\n+        }\n+    }\n+\n+    public static void add_property(ClassEmitter ce, String name, Type type, String fieldName) {\n+        String property = TypeUtils.upperFirst(name);\n+        CodeEmitter e;\n+        e = ce.begin_method(Constants.ACC_PUBLIC,\n+                            new Signature(\"get\" + property,\n+                                          type,\n+                                          Constants.TYPES_EMPTY),\n+                            null);\n+        e.load_this();\n+        e.getfield(fieldName);\n+        e.return_value();\n+        e.end_method();\n+\n+        e = ce.begin_method(Constants.ACC_PUBLIC,\n+                            new Signature(\"set\" + property,\n+                                          Type.VOID_TYPE,\n+                                          new Type[]{ type }),\n+                            null);\n+        e.load_this();\n+        e.load_arg(0);\n+        e.putfield(fieldName);\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    /* generates:\n+       } catch (RuntimeException e) {\n+         throw e;\n+       } catch (Error e) {\n+         throw e;\n+       } catch (<DeclaredException> e) {\n+         throw e;\n+       } catch (Throwable e) {\n+         throw new <Wrapper>(e);\n+       }\n+    */\n+    public static void wrap_undeclared_throwable(CodeEmitter e, Block handler, Type[] exceptions, Type wrapper) {\n+        Set set = (exceptions == null) ? Collections.EMPTY_SET : new HashSet(Arrays.asList(exceptions));\n+\n+        if (set.contains(Constants.TYPE_THROWABLE))\n+            return;\n+\n+        boolean needThrow = exceptions != null;\n+        if (!set.contains(Constants.TYPE_RUNTIME_EXCEPTION)) {\n+            e.catch_exception(handler, Constants.TYPE_RUNTIME_EXCEPTION);\n+            needThrow = true;\n+        }\n+        if (!set.contains(Constants.TYPE_ERROR)) {\n+            e.catch_exception(handler, Constants.TYPE_ERROR);\n+            needThrow = true;\n+        }\n+        if (exceptions != null) {\n+            for (int i = 0; i < exceptions.length; i++) {\n+                e.catch_exception(handler, exceptions[i]);\n+            }\n+        }\n+        if (needThrow) {\n+            e.athrow();\n+        }\n+        // e -> eo -> oeo -> ooe -> o\n+        e.catch_exception(handler, Constants.TYPE_THROWABLE);\n+        e.new_instance(wrapper);\n+        e.dup_x1();\n+        e.swap();\n+        e.invoke_constructor(wrapper, CSTRUCT_THROWABLE);\n+        e.athrow();\n+    }\n+\n+    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method) {\n+        return begin_method(e, method, method.getModifiers());\n+    }\n+\n+    public static CodeEmitter begin_method(ClassEmitter e, MethodInfo method, int access) {\n+        return e.begin_method(access,\n+                              method.getSignature(),\n+                              method.getExceptionTypes());\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/GeneratorStrategy.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+/**\n+ * The <code>GeneratorStrategy</code. is responsible for taking a\n+ * {@link ClassGenerator} and producing a byte array containing the\n+ * data for the generated <code>Class</code>.  By providing your\n+ * own strategy you may examine or modify the generated class before\n+ * it is loaded. Typically this will be accomplished by subclassing\n+ * {@link DefaultGeneratorStrategy} and overriding the appropriate\n+ * protected method.\n+ * @see AbstractClassGenerator#setStrategy\n+ */\n+public interface GeneratorStrategy {\n+    /**\n+     * Generate the class.\n+     * @param cg a class generator on which you can call {@link ClassGenerator#generateClass}\n+     * @return a byte array containing the bits of a valid Class\n+     */\n+    byte[] generate(ClassGenerator cg) throws Exception;\n+\n+    /**\n+     * The <code>GeneratorStrategy</code> in use does not currently, but may\n+     * in the future, affect the caching of classes generated by {@link\n+     * AbstractClassGenerator}, so this is a reminder that you should\n+     * correctly implement <code>equals</code> and <code>hashCode</code>\n+     * to avoid generating too many classes.\n+     */\n+    boolean equals(Object o);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/KeyFactory.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.mockito.cglib.core;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+\n+/**\n+ * Generates classes to handle multi-valued keys, for use in things such as Maps and Sets.\n+ * Code for <code>equals</code> and <code>hashCode</code> methods follow the\n+ * the rules laid out in <i>Effective Java</i> by Joshua Bloch. \n+ * <p>\n+ * To generate a <code>KeyFactory</code>, you need to supply an interface which\n+ * describes the structure of the key. The interface should have a\n+ * single method named <code>newInstance</code>, which returns an\n+ * <code>Object</code>. The arguments array can be\n+ * <i>anything</i>--Objects, primitive values, or single or\n+ * multi-dimension arrays of either. For example:\n+ * <p><pre>\n+ *     private interface IntStringKey {\n+ *         public Object newInstance(int i, String s);\n+ *     }\n+ * </pre><p>\n+ * Once you have made a <code>KeyFactory</code>, you generate a new key by calling\n+ * the <code>newInstance</code> method defined by your interface.\n+ * <p><pre>\n+ *     IntStringKey factory = (IntStringKey)KeyFactory.create(IntStringKey.class);\n+ *     Object key1 = factory.newInstance(4, \"Hello\");\n+ *     Object key2 = factory.newInstance(4, \"World\");\n+ * </pre><p>\n+ * <b>Note:</b>\n+ * <code>hashCode</code> equality between two keys <code>key1</code> and <code>key2</code> is only guaranteed if\n+ * <code>key1.equals(key2)</code> <i>and</i> the keys were produced by the same factory.\n+ *\n+ * @version $Id: KeyFactory.java,v 1.26 2006/03/05 02:43:19 herbyderby Exp $\n+ */\n+abstract public class KeyFactory {\n+    private static final Signature GET_NAME =\n+      TypeUtils.parseSignature(\"String getName()\");\n+    private static final Signature GET_CLASS =\n+      TypeUtils.parseSignature(\"Class getClass()\");\n+    private static final Signature HASH_CODE =\n+      TypeUtils.parseSignature(\"int hashCode()\");\n+    private static final Signature EQUALS =\n+      TypeUtils.parseSignature(\"boolean equals(Object)\");\n+    private static final Signature TO_STRING =\n+      TypeUtils.parseSignature(\"String toString()\");\n+    private static final Signature APPEND_STRING =\n+      TypeUtils.parseSignature(\"StringBuffer append(String)\");\n+    private static final Type KEY_FACTORY =\n+      TypeUtils.parseType(\"org.mockito.cglib.core.KeyFactory\");\n+    \n+    //generated numbers: \n+    private final static int PRIMES[] = {\n+               11,         73,        179,       331,\n+              521,        787,       1213,      1823,\n+             2609,       3691,       5189,      7247,\n+            10037,      13931,      19289,     26627,\n+            36683,      50441,      69403,     95401,\n+           131129,     180179,     247501,    340057,\n+           467063,     641371,     880603,   1209107,\n+          1660097,    2279161,    3129011,   4295723,\n+          5897291,    8095873,   11114263,  15257791,\n+         20946017,   28754629,   39474179,  54189869,\n+         74391461,  102123817,  140194277, 192456917,\n+        264202273,  362693231,  497900099, 683510293,\n+        938313161, 1288102441, 1768288259  };\n+    \n+\n+    public static final Customizer CLASS_BY_NAME = new Customizer() {\n+        public void customize(CodeEmitter e, Type type) {\n+            if (type.equals(Constants.TYPE_CLASS)) {\n+                e.invoke_virtual(Constants.TYPE_CLASS, GET_NAME);\n+            }\n+        }\n+    };\n+\n+    public static final Customizer OBJECT_BY_CLASS = new Customizer() {\n+        public void customize(CodeEmitter e, Type type) {\n+            e.invoke_virtual(Constants.TYPE_OBJECT, GET_CLASS);\n+        }\n+    };\n+\n+    protected KeyFactory() {\n+    }\n+\n+    public static KeyFactory create(Class keyInterface) {\n+        return create(keyInterface, null);\n+    }\n+\n+    public static KeyFactory create(Class keyInterface, Customizer customizer) {\n+        return create(keyInterface.getClassLoader(), keyInterface,  customizer);\n+    }\n+\n+    public static KeyFactory create(ClassLoader loader, Class keyInterface, Customizer customizer) {\n+        Generator gen = new Generator();\n+        gen.setInterface(keyInterface);\n+        gen.setCustomizer(customizer);\n+        gen.setClassLoader(loader);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(KeyFactory.class.getName());\n+        private Class keyInterface;\n+        private Customizer customizer;\n+        private int constant;\n+        private int multiplier;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return keyInterface.getClassLoader();\n+        }\n+\n+        public void setCustomizer(Customizer customizer) {\n+            this.customizer = customizer;\n+        }\n+\n+        public void setInterface(Class keyInterface) {\n+            this.keyInterface = keyInterface;\n+        }\n+\n+        public KeyFactory create() {\n+            setNamePrefix(keyInterface.getName());\n+            return (KeyFactory)super.create(keyInterface.getName());\n+        }\n+\n+        public void setHashConstant(int constant) {\n+            this.constant = constant;\n+        }\n+\n+        public void setHashMultiplier(int multiplier) {\n+            this.multiplier = multiplier;\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ReflectUtils.newInstance(type);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return instance;\n+        }\n+\n+        public void generateClass(ClassVisitor v) {\n+            ClassEmitter ce = new ClassEmitter(v);\n+            \n+            Method newInstance = ReflectUtils.findNewInstance(keyInterface);\n+            if (!newInstance.getReturnType().equals(Object.class)) {\n+                throw new IllegalArgumentException(\"newInstance method must return Object\");\n+            }\n+\n+            Type[] parameterTypes = TypeUtils.getTypes(newInstance.getParameterTypes());\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           KEY_FACTORY,\n+                           new Type[]{ Type.getType(keyInterface) },\n+                           Constants.SOURCE_FILE);\n+            EmitUtils.null_constructor(ce);\n+            EmitUtils.factory_method(ce, ReflectUtils.getSignature(newInstance));\n+\n+            int seed = 0;\n+            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,\n+                                            TypeUtils.parseConstructor(parameterTypes),\n+                                            null);\n+            e.load_this();\n+            e.super_invoke_constructor();\n+            e.load_this();\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                seed += parameterTypes[i].hashCode();\n+                ce.declare_field(Constants.ACC_PRIVATE | Constants.ACC_FINAL,\n+                                 getFieldName(i),\n+                                 parameterTypes[i],\n+                                 null);\n+                e.dup();\n+                e.load_arg(i);\n+                e.putfield(getFieldName(i));\n+            }\n+            e.return_value();\n+            e.end_method();\n+            \n+            // hash code\n+            e = ce.begin_method(Constants.ACC_PUBLIC, HASH_CODE, null);\n+            int hc = (constant != 0) ? constant : PRIMES[(int)(Math.abs(seed) % PRIMES.length)];\n+            int hm = (multiplier != 0) ? multiplier : PRIMES[(int)(Math.abs(seed * 13) % PRIMES.length)];\n+            e.push(hc);\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                e.load_this();\n+                e.getfield(getFieldName(i));\n+                EmitUtils.hash_code(e, parameterTypes[i], hm, customizer);\n+            }\n+            e.return_value();\n+            e.end_method();\n+\n+            // equals\n+            e = ce.begin_method(Constants.ACC_PUBLIC, EQUALS, null);\n+            Label fail = e.make_label();\n+            e.load_arg(0);\n+            e.instance_of_this();\n+            e.if_jump(e.EQ, fail);\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                e.load_this();\n+                e.getfield(getFieldName(i));\n+                e.load_arg(0);\n+                e.checkcast_this();\n+                e.getfield(getFieldName(i));\n+                EmitUtils.not_equals(e, parameterTypes[i], fail, customizer);\n+            }\n+            e.push(1);\n+            e.return_value();\n+            e.mark(fail);\n+            e.push(0);\n+            e.return_value();\n+            e.end_method();\n+\n+            // toString\n+            e = ce.begin_method(Constants.ACC_PUBLIC, TO_STRING, null);\n+            e.new_instance(Constants.TYPE_STRING_BUFFER);\n+            e.dup();\n+            e.invoke_constructor(Constants.TYPE_STRING_BUFFER);\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                if (i > 0) {\n+                    e.push(\", \");\n+                    e.invoke_virtual(Constants.TYPE_STRING_BUFFER, APPEND_STRING);\n+                }\n+                e.load_this();\n+                e.getfield(getFieldName(i));\n+                EmitUtils.append_string(e, parameterTypes[i], EmitUtils.DEFAULT_DELIMITERS, customizer);\n+            }\n+            e.invoke_virtual(Constants.TYPE_STRING_BUFFER, TO_STRING);\n+            e.return_value();\n+            e.end_method();\n+\n+            ce.end_class();\n+        }\n+\n+        private String getFieldName(int arg) {\n+            return \"FIELD_\" + arg;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Local.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Type;\n+\n+public class Local\n+{\n+    private Type type;\n+    private int index;\n+    \n+    public Local(int index, Type type) {\n+        this.type = type;\n+        this.index = index;\n+    }\n+    \n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    public Type getType() {\n+        return type;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/LocalVariablesSorter.java\n+/***\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2005 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodAdapter;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Opcodes;\n+import org.mockito.asm.Type;\n+\n+/**\n+ * A {@link MethodAdapter} that renumbers local variables in their order of\n+ * appearance. This adapter allows one to easily add new local variables to a\n+ * method.\n+ * \n+ * @author Chris Nokleberg\n+ * @author Eric Bruneton\n+ */\n+public class LocalVariablesSorter extends MethodAdapter {\n+\n+    /**\n+     * Mapping from old to new local variable indexes. A local variable at index\n+     * i of size 1 is remapped to 'mapping[2*i]', while a local variable at\n+     * index i of size 2 is remapped to 'mapping[2*i+1]'.\n+     */\n+    private static class State\n+    {\n+        int[] mapping = new int[40];        \n+        int nextLocal;\n+    }\n+\n+    protected final int firstLocal;\n+    private final State state;\n+\n+    public LocalVariablesSorter(\n+        final int access,\n+        final String desc,\n+        final MethodVisitor mv)\n+    {\n+        super(mv);\n+        state = new State();\n+        Type[] args = Type.getArgumentTypes(desc);\n+        state.nextLocal = ((Opcodes.ACC_STATIC & access) != 0) ? 0 : 1;\n+        for (int i = 0; i < args.length; i++) {\n+            state.nextLocal += args[i].getSize();\n+        }\n+        firstLocal = state.nextLocal;\n+    }\n+\n+    public LocalVariablesSorter(LocalVariablesSorter lvs) {\n+        super(lvs.mv);\n+        state = lvs.state;\n+        firstLocal = lvs.firstLocal;\n+    }\n+\n+    public void visitVarInsn(final int opcode, final int var) {\n+        int size;\n+        switch (opcode) {\n+            case Opcodes.LLOAD:\n+            case Opcodes.LSTORE:\n+            case Opcodes.DLOAD:\n+            case Opcodes.DSTORE:\n+                size = 2;\n+                break;\n+            default:\n+                size = 1;\n+        }\n+        mv.visitVarInsn(opcode, remap(var, size));\n+    }\n+\n+    public void visitIincInsn(final int var, final int increment) {\n+        mv.visitIincInsn(remap(var, 1), increment);\n+    }\n+\n+    public void visitMaxs(final int maxStack, final int maxLocals) {\n+        mv.visitMaxs(maxStack, state.nextLocal);\n+    }\n+\n+    public void visitLocalVariable(\n+        final String name,\n+        final String desc,\n+        final String signature,\n+        final Label start,\n+        final Label end,\n+        final int index)\n+    {\n+        mv.visitLocalVariable(name, desc, signature, start, end, remap(index));\n+    }\n+\n+    // -------------\n+\n+    protected int newLocal(final int size) {\n+        int var = state.nextLocal;\n+        state.nextLocal += size;\n+        return var;\n+    }\n+\n+    private int remap(final int var, final int size) {\n+        if (var < firstLocal) {\n+            return var;\n+        }\n+        int key = 2 * var + size - 1;\n+        int length = state.mapping.length;\n+        if (key >= length) {\n+            int[] newMapping = new int[Math.max(2 * length, key + 1)];\n+            System.arraycopy(state.mapping, 0, newMapping, 0, length);\n+            state.mapping = newMapping;\n+        }\n+        int value = state.mapping[key];\n+        if (value == 0) {\n+            value = state.nextLocal + 1;\n+            state.mapping[key] = value;\n+            state.nextLocal += size;\n+        }\n+        return value - 1;\n+    }\n+\n+    private int remap(final int var) {\n+        if (var < firstLocal) {\n+            return var;\n+        }\n+        int key = 2 * var;\n+        int value = key < state.mapping.length ? state.mapping[key] : 0;\n+        if (value == 0) {\n+            value = key + 1 < state.mapping.length ? state.mapping[key + 1] : 0;\n+        }\n+        if (value == 0) {\n+            throw new IllegalStateException(\"Unknown local variable \" + var);\n+        }\n+        return value - 1;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/MethodInfo.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Type;\n+\n+abstract public class MethodInfo {\n+\n+    protected MethodInfo() {\n+    }\n+    \n+    abstract public ClassInfo getClassInfo();\n+    abstract public int getModifiers();\n+    abstract public Signature getSignature();\n+    abstract public Type[] getExceptionTypes();\n+\n+    public boolean equals(Object o) {\n+        if (o == null)\n+            return false;\n+        if (!(o instanceof MethodInfo))\n+            return false;\n+        return getSignature().equals(((MethodInfo)o).getSignature());\n+    }\n+\n+    public int hashCode() {\n+        return getSignature().hashCode();\n+    }\n+\n+    public String toString() {\n+        // TODO: include modifiers, exceptions\n+        return getSignature().toString();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/MethodInfoTransformer.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.lang.reflect.*;\n+\n+public class MethodInfoTransformer implements Transformer\n+{\n+    private static final MethodInfoTransformer INSTANCE = new MethodInfoTransformer();\n+\n+    public static MethodInfoTransformer getInstance() {\n+        return INSTANCE;\n+    }\n+    \n+    public Object transform(Object value) {\n+        if (value instanceof Method) {\n+            return ReflectUtils.getMethodInfo((Method)value);\n+        } else if (value instanceof Constructor) {\n+            return ReflectUtils.getMethodInfo((Constructor)value);\n+        } else {\n+            throw new IllegalArgumentException(\"cannot get method info for \" + value);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/MethodWrapper.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+public class MethodWrapper {\n+    private static final MethodWrapperKey KEY_FACTORY =\n+      (MethodWrapperKey)KeyFactory.create(MethodWrapperKey.class);\n+\n+    /** Internal interface, only public due to ClassLoader issues. */\n+    public interface MethodWrapperKey {\n+        public Object newInstance(String name, String[] parameterTypes, String returnType);\n+    }\n+    \n+    private MethodWrapper() {\n+    }\n+\n+    public static Object create(Method method) {\n+        return KEY_FACTORY.newInstance(method.getName(),\n+                                       ReflectUtils.getNames(method.getParameterTypes()),\n+                                       method.getReturnType().getName());\n+    }\n+\n+    public static Set createSet(Collection methods) {\n+        Set set = new HashSet();\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            set.add(create((Method)it.next()));\n+        }\n+        return set;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/NamingPolicy.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.util.Set;\n+\n+/**\n+ * Customize the generated class name for {@link AbstractClassGenerator}-based utilities.\n+ */\n+public interface NamingPolicy {\n+    /**\n+     * Choose a name for a generated class.\n+     * @param prefix a dotted-name chosen by the generating class (possibly to put the generated class in a particular package)\n+     * @param source the fully-qualified class name of the generating class (for example \"org.mockito.cglib.Enhancer\")\n+     * @param key A key object representing the state of the parameters; for caching to work properly, equal keys should result\n+     * in the same generated class name. The default policy incorporates <code>key.hashCode()</code> into the class name.\n+     * @param names a predicate that returns true if the given classname has already been used in the same ClassLoader.\n+     * @return the fully-qualified class name\n+     */\n+    String getClassName(String prefix, String source, Object key, Predicate names);\n+\n+    /**\n+     * The <code>NamingPolicy</code> in use does not currently, but may\n+     * in the future, affect the caching of classes generated by {@link\n+     * AbstractClassGenerator}, so this is a reminder that you should\n+     * correctly implement <code>equals</code> and <code>hashCode</code>\n+     * to avoid generating too many classes.\n+     */\n+    boolean equals(Object o);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ObjectSwitchCallback.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Label;\n+\n+public interface ObjectSwitchCallback {\n+    void processCase(Object key, Label end) throws Exception;\n+    void processDefault() throws Exception;\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Predicate.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+public interface Predicate {\n+    boolean evaluate(Object arg);\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ProcessArrayCallback.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Type;\n+\n+public interface ProcessArrayCallback {\n+    void processElement(Type type);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ProcessSwitchCallback.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Label;\n+\n+public interface ProcessSwitchCallback {\n+    void processCase(int key, Label end) throws Exception;\n+    void processDefault() throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/ReflectUtils.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.beans.*;\n+import java.lang.reflect.*;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.ProtectionDomain;\n+import java.util.*;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Type;\n+\n+/**\n+ * @version $Id: ReflectUtils.java,v 1.29 2006/02/28 00:30:51 herbyderby Exp $\n+ */\n+public class ReflectUtils {\n+    private ReflectUtils() { }\n+    \n+    private static final Map primitives = new HashMap(8);\n+    private static final Map transforms = new HashMap(8);\n+    private static final ClassLoader defaultLoader = ReflectUtils.class.getClassLoader();\n+    private static Method DEFINE_CLASS;\n+    private static final ProtectionDomain PROTECTION_DOMAIN;\n+    \n+    static {\n+        PROTECTION_DOMAIN = (ProtectionDomain)AccessController.doPrivileged(new PrivilegedAction() {\n+            public Object run() {\n+                return ReflectUtils.class.getProtectionDomain();\n+            }\n+        });\n+        \n+        AccessController.doPrivileged(new PrivilegedAction() {\n+            public Object run() {\n+                try {\n+                    Class loader = Class.forName(\"java.lang.ClassLoader\"); // JVM crash w/o this\n+                    DEFINE_CLASS = loader.getDeclaredMethod(\"defineClass\",\n+                                                            new Class[]{ String.class,\n+                                                                         byte[].class,\n+                                                                         Integer.TYPE,\n+                                                                         Integer.TYPE,\n+                                                                         ProtectionDomain.class });\n+                    DEFINE_CLASS.setAccessible(true);\n+                } catch (ClassNotFoundException e) {\n+                    throw new CodeGenerationException(e);\n+                } catch (NoSuchMethodException e) {\n+                    throw new CodeGenerationException(e);\n+                }\n+                return null;\n+            }\n+        });\n+    }\n+        \n+    private static final String[] CGLIB_PACKAGES = {\n+        \"java.lang\",\n+    };\n+        \n+    static {\n+        primitives.put(\"byte\", Byte.TYPE);\n+        primitives.put(\"char\", Character.TYPE);\n+        primitives.put(\"double\", Double.TYPE);\n+        primitives.put(\"float\", Float.TYPE);\n+        primitives.put(\"int\", Integer.TYPE);\n+        primitives.put(\"long\", Long.TYPE);\n+        primitives.put(\"short\", Short.TYPE);\n+        primitives.put(\"boolean\", Boolean.TYPE);\n+            \n+        transforms.put(\"byte\", \"B\");\n+        transforms.put(\"char\", \"C\");\n+        transforms.put(\"double\", \"D\");\n+        transforms.put(\"float\", \"F\");\n+        transforms.put(\"int\", \"I\");\n+        transforms.put(\"long\", \"J\");\n+        transforms.put(\"short\", \"S\");\n+        transforms.put(\"boolean\", \"Z\");\n+    }\n+        \n+    public static Type[] getExceptionTypes(Member member) {\n+        if (member instanceof Method) {\n+            return TypeUtils.getTypes(((Method)member).getExceptionTypes());\n+        } else if (member instanceof Constructor) {\n+            return TypeUtils.getTypes(((Constructor)member).getExceptionTypes());\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot get exception types of a field\");\n+        }\n+    }\n+        \n+    public static Signature getSignature(Member member) {\n+        if (member instanceof Method) {\n+            return new Signature(member.getName(), Type.getMethodDescriptor((Method)member));\n+        } else if (member instanceof Constructor) {\n+            Type[] types = TypeUtils.getTypes(((Constructor)member).getParameterTypes());\n+            return new Signature(Constants.CONSTRUCTOR_NAME,\n+                                 Type.getMethodDescriptor(Type.VOID_TYPE, types));\n+                \n+        } else {\n+            throw new IllegalArgumentException(\"Cannot get signature of a field\");\n+        }\n+    }\n+        \n+    public static Constructor findConstructor(String desc) {\n+        return findConstructor(desc, defaultLoader);\n+    }\n+        \n+    public static Constructor findConstructor(String desc, ClassLoader loader) {\n+        try {\n+            int lparen = desc.indexOf('(');\n+            String className = desc.substring(0, lparen).trim();\n+            return getClass(className, loader).getConstructor(parseTypes(desc, loader));\n+        } catch (ClassNotFoundException e) {\n+            throw new CodeGenerationException(e);\n+        } catch (NoSuchMethodException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+        \n+    public static Method findMethod(String desc) {\n+        return findMethod(desc, defaultLoader);\n+    }\n+        \n+    public static Method findMethod(String desc, ClassLoader loader) {\n+        try {\n+            int lparen = desc.indexOf('(');\n+            int dot = desc.lastIndexOf('.', lparen);\n+            String className = desc.substring(0, dot).trim();\n+            String methodName = desc.substring(dot + 1, lparen).trim();\n+            return getClass(className, loader).getDeclaredMethod(methodName, parseTypes(desc, loader));\n+        } catch (ClassNotFoundException e) {\n+            throw new CodeGenerationException(e);\n+        } catch (NoSuchMethodException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+        \n+    private static Class[] parseTypes(String desc, ClassLoader loader) throws ClassNotFoundException {\n+        int lparen = desc.indexOf('(');\n+        int rparen = desc.indexOf(')', lparen);\n+        List params = new ArrayList();\n+        int start = lparen + 1;\n+        for (;;) {\n+            int comma = desc.indexOf(',', start);\n+            if (comma < 0) {\n+                break;\n+            }\n+            params.add(desc.substring(start, comma).trim());\n+            start = comma + 1;\n+        }\n+        if (start < rparen) {\n+            params.add(desc.substring(start, rparen).trim());\n+        }\n+        Class[] types = new Class[params.size()];\n+        for (int i = 0; i < types.length; i++) {\n+            types[i] = getClass((String)params.get(i), loader);\n+        }\n+        return types;\n+    }\n+        \n+    private static Class getClass(String className, ClassLoader loader) throws ClassNotFoundException {\n+        return getClass(className, loader, CGLIB_PACKAGES);\n+    }\n+        \n+    private static Class getClass(String className, ClassLoader loader, String[] packages) throws ClassNotFoundException {\n+        String save = className;\n+        int dimensions = 0;\n+        int index = 0;\n+        while ((index = className.indexOf(\"[]\", index) + 1) > 0) {\n+            dimensions++;\n+        }\n+        StringBuffer brackets = new StringBuffer(className.length() - dimensions);\n+        for (int i = 0; i < dimensions; i++) {\n+            brackets.append('[');\n+        }\n+        className = className.substring(0, className.length() - 2 * dimensions);\n+            \n+        String prefix = (dimensions > 0) ? brackets + \"L\" : \"\";\n+        String suffix = (dimensions > 0) ? \";\" : \"\";\n+        try {\n+            return Class.forName(prefix + className + suffix, false, loader);\n+        } catch (ClassNotFoundException ignore) { }\n+        for (int i = 0; i < packages.length; i++) {\n+            try {\n+                return Class.forName(prefix + packages[i] + '.' + className + suffix, false, loader);\n+            } catch (ClassNotFoundException ignore) { }\n+        }\n+        if (dimensions == 0) {\n+            Class c = (Class)primitives.get(className);\n+            if (c != null) {\n+                return c;\n+            }\n+        } else {\n+            String transform = (String)transforms.get(className);\n+            if (transform != null) {\n+                try {\n+                    return Class.forName(brackets + transform, false, loader);\n+                } catch (ClassNotFoundException ignore) { }\n+            }\n+        }\n+        throw new ClassNotFoundException(save);\n+    }\n+        \n+        \n+    public static Object newInstance(Class type) {\n+        return newInstance(type, Constants.EMPTY_CLASS_ARRAY, null);\n+    }\n+        \n+    public static Object newInstance(Class type, Class[] parameterTypes, Object[] args) {\n+        return newInstance(getConstructor(type, parameterTypes), args);\n+    }\n+        \n+    public static Object newInstance(final Constructor cstruct, final Object[] args) {\n+            \n+        boolean flag = cstruct.isAccessible();\n+        try {\n+            cstruct.setAccessible(true);\n+            Object result = cstruct.newInstance(args);\n+            return result;\n+        } catch (InstantiationException e) {\n+            throw new CodeGenerationException(e);\n+        } catch (IllegalAccessException e) {\n+            throw new CodeGenerationException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new CodeGenerationException(e.getTargetException());\n+        } finally {\n+            cstruct.setAccessible(flag);\n+        }\n+                \n+    }\n+        \n+    public static Constructor getConstructor(Class type, Class[] parameterTypes) {\n+        try {\n+            Constructor constructor = type.getDeclaredConstructor(parameterTypes);\n+            constructor.setAccessible(true);\n+            return constructor;\n+        } catch (NoSuchMethodException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+\n+    public static String[] getNames(Class[] classes)\n+    {\n+        if (classes == null)\n+            return null;\n+        String[] names = new String[classes.length];\n+        for (int i = 0; i < names.length; i++) {\n+            names[i] = classes[i].getName();\n+        }\n+        return names;\n+    }\n+        \n+    public static Class[] getClasses(Object[] objects) {\n+        Class[] classes = new Class[objects.length];\n+        for (int i = 0; i < objects.length; i++) {\n+            classes[i] = objects[i].getClass();\n+        }\n+        return classes;\n+    }\n+        \n+    public static Method findNewInstance(Class iface) {\n+        Method m = findInterfaceMethod(iface);\n+        if (!m.getName().equals(\"newInstance\")) {\n+            throw new IllegalArgumentException(iface + \" missing newInstance method\");\n+        }\n+        return m;\n+    }\n+\n+    public static Method[] getPropertyMethods(PropertyDescriptor[] properties, boolean read, boolean write) {\n+        Set methods = new HashSet();\n+        for (int i = 0; i < properties.length; i++) {\n+            PropertyDescriptor pd = properties[i];\n+            if (read) {\n+                methods.add(pd.getReadMethod());\n+            }\n+            if (write) {\n+                methods.add(pd.getWriteMethod());\n+            }\n+        }\n+        methods.remove(null);\n+        return (Method[])methods.toArray(new Method[methods.size()]);\n+    }\n+        \n+    public static PropertyDescriptor[] getBeanProperties(Class type) {\n+        return getPropertiesHelper(type, true, true);\n+    }\n+        \n+    public static PropertyDescriptor[] getBeanGetters(Class type) {\n+        return getPropertiesHelper(type, true, false);\n+    }\n+        \n+    public static PropertyDescriptor[] getBeanSetters(Class type) {\n+        return getPropertiesHelper(type, false, true);\n+    }\n+        \n+    private static PropertyDescriptor[] getPropertiesHelper(Class type, boolean read, boolean write) {\n+        try {\n+            BeanInfo info = Introspector.getBeanInfo(type, Object.class);\n+            PropertyDescriptor[] all = info.getPropertyDescriptors();\n+            if (read && write) {\n+                return all;\n+            }\n+            List properties = new ArrayList(all.length);\n+            for (int i = 0; i < all.length; i++) {\n+                PropertyDescriptor pd = all[i];\n+                if ((read && pd.getReadMethod() != null) ||\n+                    (write && pd.getWriteMethod() != null)) {\n+                    properties.add(pd);\n+                }\n+            }\n+            return (PropertyDescriptor[])properties.toArray(new PropertyDescriptor[properties.size()]);\n+        } catch (IntrospectionException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+        \n+        \n+        \n+    public static Method findDeclaredMethod(final Class type,\n+                                            final String methodName, final Class[] parameterTypes)\n+    throws NoSuchMethodException {\n+                        \n+        Class cl = type;\n+        while (cl != null) {\n+            try {\n+                return cl.getDeclaredMethod(methodName, parameterTypes);\n+            } catch (NoSuchMethodException e) {\n+                cl = cl.getSuperclass();\n+            }\n+        }\n+        throw new NoSuchMethodException(methodName);\n+            \n+    }\n+        \n+    public static List addAllMethods(final Class type, final List list) {\n+            \n+            \n+        list.addAll(java.util.Arrays.asList(type.getDeclaredMethods()));\n+        Class superclass = type.getSuperclass();\n+        if (superclass != null) {\n+            addAllMethods(superclass, list);\n+        }\n+        Class[] interfaces = type.getInterfaces();\n+        for (int i = 0; i < interfaces.length; i++) {\n+            addAllMethods(interfaces[i], list);\n+        }\n+            \n+        return list;\n+    }\n+        \n+    public static List addAllInterfaces(Class type, List list) {\n+        Class superclass = type.getSuperclass();\n+        if (superclass != null) {\n+            list.addAll(Arrays.asList(type.getInterfaces()));\n+            addAllInterfaces(superclass, list);\n+        }\n+        return list;\n+    }\n+        \n+        \n+    public static Method findInterfaceMethod(Class iface) {\n+        if (!iface.isInterface()) {\n+            throw new IllegalArgumentException(iface + \" is not an interface\");\n+        }\n+        Method[] methods = iface.getDeclaredMethods();\n+        if (methods.length != 1) {\n+            throw new IllegalArgumentException(\"expecting exactly 1 method in \" + iface);\n+        }\n+        return methods[0];\n+    }\n+        \n+    public static Class defineClass(String className, byte[] b, ClassLoader loader) throws Exception {\n+        Object[] args = new Object[]{className, b, new Integer(0), new Integer(b.length), PROTECTION_DOMAIN };\n+        return (Class)DEFINE_CLASS.invoke(loader, args);\n+    }\n+        \n+    public static int findPackageProtected(Class[] classes) {\n+        for (int i = 0; i < classes.length; i++) {\n+            if (!Modifier.isPublic(classes[i].getModifiers())) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    public static MethodInfo getMethodInfo(final Member member, final int modifiers) {\n+        final Signature sig = getSignature(member);\n+        return new MethodInfo() {\n+            private ClassInfo ci;\n+            public ClassInfo getClassInfo() {\n+                if (ci == null)\n+                    ci = ReflectUtils.getClassInfo(member.getDeclaringClass());\n+                return ci;\n+            }\n+            public int getModifiers() {\n+                return modifiers;\n+            }\n+            public Signature getSignature() {\n+                return sig;\n+            }\n+            public Type[] getExceptionTypes() {\n+                return ReflectUtils.getExceptionTypes(member);\n+            }\n+            public Attribute getAttribute() {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    public static MethodInfo getMethodInfo(Member member) {\n+        return getMethodInfo(member, member.getModifiers());\n+    }\n+\n+    public static ClassInfo getClassInfo(final Class clazz) {\n+        final Type type = Type.getType(clazz);\n+        final Type sc = (clazz.getSuperclass() == null) ? null : Type.getType(clazz.getSuperclass());\n+        return new ClassInfo() {\n+            public Type getType() {\n+                return type;\n+            }\n+            public Type getSuperType() {\n+                return sc;\n+            }\n+            public Type[] getInterfaces() {\n+                return TypeUtils.getTypes(clazz.getInterfaces());\n+            }\n+            public int getModifiers() {\n+                return clazz.getModifiers();\n+            }\n+        };\n+    }\n+\n+    // used by MethodInterceptorGenerated generated code\n+    public static Method[] findMethods(String[] namesAndDescriptors, Method[] methods)\n+    {\n+        Map map = new HashMap();\n+        for (int i = 0; i < methods.length; i++) {\n+            Method method = methods[i];\n+            map.put(method.getName() + Type.getMethodDescriptor(method), method);\n+        }\n+        Method[] result = new Method[namesAndDescriptors.length / 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (Method)map.get(namesAndDescriptors[i * 2] + namesAndDescriptors[i * 2 + 1]);\n+            if (result[i] == null) {\n+                // TODO: error?\n+            }\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/RejectModifierPredicate.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.lang.reflect.*;\n+\n+public class RejectModifierPredicate implements Predicate {\n+    private int rejectMask;\n+\n+    public RejectModifierPredicate(int rejectMask) {\n+        this.rejectMask = rejectMask;\n+    }\n+\n+    public boolean evaluate(Object arg) {\n+        return (((Member)arg).getModifiers() & rejectMask) == 0;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Signature.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import org.mockito.asm.Type;\n+\n+/**\n+ * A representation of a method signature, containing the method name,\n+ * return type, and parameter types.\n+ */\n+public class Signature {\n+    private String name;\n+    private String desc;\n+\n+    public Signature(String name, String desc) {\n+        // TODO: better error checking\n+        if (name.indexOf('(') >= 0) {\n+            throw new IllegalArgumentException(\"Name '\" + name + \"' is invalid\");\n+        }\n+        this.name = name;\n+        this.desc = desc;\n+    }\n+\n+    public Signature(String name, Type returnType, Type[] argumentTypes) {\n+        this(name, Type.getMethodDescriptor(returnType, argumentTypes));\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getDescriptor() {\n+        return desc;\n+    }\n+\n+    public Type getReturnType() {\n+        return Type.getReturnType(desc);\n+    }\n+\n+    public Type[] getArgumentTypes() {\n+        return Type.getArgumentTypes(desc);\n+    }\n+\n+    public String toString() {\n+        return name + desc;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null)\n+            return false;\n+        if (!(o instanceof Signature))\n+            return false;\n+        Signature other = (Signature)o;\n+        return name.equals(other.name) && desc.equals(other.desc);\n+    }\n+\n+    public int hashCode() {\n+        return name.hashCode() ^ desc.hashCode();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/TinyBitSet.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+public class TinyBitSet {\n+    private static int[] T = new int[256];\n+    private int value = 0;\n+\n+    private static int gcount(int x) {\n+        int c = 0;\n+        while (x != 0) {\n+            c++;\n+            x &= (x - 1);\n+        }\n+        return c;\n+    }\n+\n+    static {\n+        for(int j = 0; j < 256; j++) {\n+            T[j] = gcount(j);\n+        }\n+    }\n+\n+    private static int topbit(int i) {\n+        int j;\n+        for (j = 0; i != 0; i ^= j) {\n+            j = i & -i;\n+        }\n+        return j;\n+    }\n+\n+    private static int log2(int i) {\n+        int j = 0;\n+        for (j = 0; i != 0; i >>= 1) {\n+            j++;\n+        }\n+        return j;\n+    }\n+    \n+    public int length() {\n+        return log2(topbit(value));\n+    }\n+\n+    public int cardinality() {\n+        int w = value;\n+        int c = 0;\n+        while (w != 0) {\n+            c += T[w & 255];\n+            w >>= 8;\n+        }\n+        return c;\n+    }\n+\n+    public boolean get(int index) {\n+        return (value & (1 << index)) != 0;\n+    }\n+\n+    public void set(int index) {\n+        value |= (1 << index);\n+    }\n+\n+    public void clear(int index) {\n+        value &= ~(1 << index);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/Transformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+public interface Transformer {\n+    Object transform(Object value);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/TypeUtils.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Type;\n+\n+public class TypeUtils {\n+    private static final Map transforms = new HashMap();\n+    private static final Map rtransforms = new HashMap();\n+\n+    private TypeUtils() {\n+    }\n+\n+    static {\n+        transforms.put(\"void\", \"V\");\n+        transforms.put(\"byte\", \"B\");\n+        transforms.put(\"char\", \"C\");\n+        transforms.put(\"double\", \"D\");\n+        transforms.put(\"float\", \"F\");\n+        transforms.put(\"int\", \"I\");\n+        transforms.put(\"long\", \"J\");\n+        transforms.put(\"short\", \"S\");\n+        transforms.put(\"boolean\", \"Z\");\n+\n+        CollectionUtils.reverse(transforms, rtransforms);\n+    }\n+\n+    public static Type getType(String className) {\n+        return Type.getType(\"L\" + className.replace('.', '/') + \";\");\n+    }\n+\n+    public static boolean isFinal(int access) {\n+        return (Constants.ACC_FINAL & access) != 0;\n+    }\n+\n+    public static boolean isStatic(int access) {\n+        return (Constants.ACC_STATIC & access) != 0;\n+    }\n+\n+    public static boolean isProtected(int access) {\n+        return (Constants.ACC_PROTECTED & access) != 0;\n+    }\n+\n+    public static boolean isPublic(int access) {\n+        return (Constants.ACC_PUBLIC & access) != 0;\n+    }\n+\n+    public static boolean isAbstract(int access) {\n+        return (Constants.ACC_ABSTRACT & access) != 0;\n+    }\n+    \n+    public static boolean isInterface(int access) {\n+        return (Constants.ACC_INTERFACE & access) != 0;\n+    }\n+\n+    public static boolean isPrivate(int access) {\n+        return (Constants.ACC_PRIVATE & access) != 0;\n+    }\n+    \n+    public static boolean isSynthetic(int access) {\n+        return (Constants.ACC_SYNTHETIC & access) != 0;\n+    }\n+    \n+    // getPackage returns null on JDK 1.2\n+    public static String getPackageName(Type type) {\n+        return getPackageName(getClassName(type));\n+    }\n+\n+    public static String getPackageName(String className) {\n+        int idx = className.lastIndexOf('.');\n+        return (idx < 0) ? \"\" : className.substring(0, idx);\n+    }\n+    \n+    public static String upperFirst(String s) {\n+        if (s == null || s.length() == 0) {\n+            return s;\n+        }\n+        return Character.toUpperCase(s.charAt(0)) + s.substring(1);\n+    }\n+\n+    public static String getClassName(Type type) {\n+        if (isPrimitive(type)) {\n+            return (String)rtransforms.get(type.getDescriptor());\n+        } else if (isArray(type)) {\n+            return getClassName(getComponentType(type)) + \"[]\";\n+        } else {\n+            return type.getClassName();\n+        }\n+    }\n+\n+    public static Type[] add(Type[] types, Type extra) {\n+        if (types == null) {\n+            return new Type[]{ extra };\n+        } else {\n+            List list = Arrays.asList(types);\n+            if (list.contains(extra)) {\n+                return types;\n+            }\n+            Type[] copy = new Type[types.length + 1];\n+            System.arraycopy(types, 0, copy, 0, types.length);\n+            copy[types.length] = extra;\n+            return copy;\n+        }\n+    }\n+\n+    public static Type[] add(Type[] t1, Type[] t2) {\n+        // TODO: set semantics?\n+        Type[] all = new Type[t1.length + t2.length];\n+        System.arraycopy(t1, 0, all, 0, t1.length);\n+        System.arraycopy(t2, 0, all, t1.length, t2.length);\n+        return all;\n+    }\n+\n+    public static Type fromInternalName(String name) {\n+        // TODO; primitives?\n+        return Type.getType(\"L\" + name + \";\");\n+    }\n+\n+    public static Type[] fromInternalNames(String[] names) {\n+        if (names == null) {\n+            return null;\n+        }\n+        Type[] types = new Type[names.length];\n+        for (int i = 0; i < names.length; i++) {\n+            types[i] = fromInternalName(names[i]);\n+        }\n+        return types;\n+    }\n+\n+    public static int getStackSize(Type[] types) {\n+        int size = 0;\n+        for (int i = 0; i < types.length; i++) {\n+            size += types[i].getSize();\n+        }\n+        return size;\n+    }\n+\n+    public static String[] toInternalNames(Type[] types) {\n+        if (types == null) {\n+            return null;\n+        }\n+        String[] names = new String[types.length];\n+        for (int i = 0; i < types.length; i++) {\n+            names[i] = types[i].getInternalName();\n+        }\n+        return names;\n+    }\n+\n+    public static Signature parseSignature(String s) {\n+        int space = s.indexOf(' ');\n+        int lparen = s.indexOf('(', space);\n+        int rparen = s.indexOf(')', lparen);\n+        String returnType = s.substring(0, space);\n+        String methodName = s.substring(space + 1, lparen);\n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        for (Iterator it = parseTypes(s, lparen + 1, rparen).iterator(); it.hasNext();) {\n+            sb.append(it.next());\n+        }\n+        sb.append(')');\n+        sb.append(map(returnType));\n+        return new Signature(methodName, sb.toString());\n+    }\n+\n+    public static Type parseType(String s) {\n+        return Type.getType(map(s));\n+    }\n+\n+    public static Type[] parseTypes(String s) {\n+        List names = parseTypes(s, 0, s.length());\n+        Type[] types = new Type[names.size()];\n+        for (int i = 0; i < types.length; i++) {\n+            types[i] = Type.getType((String)names.get(i));\n+        }\n+        return types;\n+    }\n+\n+    public static Signature parseConstructor(Type[] types) {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(\"(\");\n+        for (int i = 0; i < types.length; i++) {\n+            sb.append(types[i].getDescriptor());\n+        }\n+        sb.append(\")\");\n+        sb.append(\"V\");\n+        return new Signature(Constants.CONSTRUCTOR_NAME, sb.toString());\n+    }\n+\n+    public static Signature parseConstructor(String sig) {\n+        return parseSignature(\"void <init>(\" + sig + \")\"); // TODO\n+    }\n+\n+    private static List parseTypes(String s, int mark, int end) {\n+        List types = new ArrayList(5);\n+        for (;;) {\n+            int next = s.indexOf(',', mark);\n+            if (next < 0) {\n+                break;\n+            }\n+            types.add(map(s.substring(mark, next).trim()));\n+            mark = next + 1;\n+        }\n+        types.add(map(s.substring(mark, end).trim()));\n+        return types;\n+    }\n+\n+    private static String map(String type) {\n+        if (type.equals(\"\")) {\n+            return type;\n+        }\n+        String t = (String)transforms.get(type);\n+        if (t != null) {\n+            return t;\n+        } else if (type.indexOf('.') < 0) {\n+            return map(\"java.lang.\" + type);\n+        } else {\n+            StringBuffer sb = new StringBuffer();\n+            int index = 0;\n+            while ((index = type.indexOf(\"[]\", index) + 1) > 0) {\n+                sb.append('[');\n+            }\n+            type = type.substring(0, type.length() - sb.length() * 2);\n+            sb.append('L').append(type.replace('.', '/')).append(';');\n+            return sb.toString();\n+        }\n+    }\n+\n+    public static Type getBoxedType(Type type) {\n+        switch (type.getSort()) {\n+        case Type.CHAR:\n+            return Constants.TYPE_CHARACTER;\n+        case Type.BOOLEAN:\n+            return Constants.TYPE_BOOLEAN;\n+        case Type.DOUBLE:\n+            return Constants.TYPE_DOUBLE;\n+        case Type.FLOAT:\n+            return Constants.TYPE_FLOAT;\n+        case Type.LONG:\n+            return Constants.TYPE_LONG;\n+        case Type.INT:\n+            return Constants.TYPE_INTEGER;\n+        case Type.SHORT:\n+            return Constants.TYPE_SHORT;\n+        case Type.BYTE:\n+            return Constants.TYPE_BYTE;\n+        default:\n+            return type;\n+        }\n+    }\n+\n+    public static Type getUnboxedType(Type type) {\n+        if (Constants.TYPE_INTEGER.equals(type)) {\n+            return Type.INT_TYPE;\n+        } else if (Constants.TYPE_BOOLEAN.equals(type)) {\n+            return Type.BOOLEAN_TYPE;\n+        } else if (Constants.TYPE_DOUBLE.equals(type)) {\n+            return Type.DOUBLE_TYPE;\n+        } else if (Constants.TYPE_LONG.equals(type)) {\n+            return Type.LONG_TYPE;\n+        } else if (Constants.TYPE_CHARACTER.equals(type)) {\n+            return Type.CHAR_TYPE;\n+        } else if (Constants.TYPE_BYTE.equals(type)) {\n+            return Type.BYTE_TYPE;\n+        } else if (Constants.TYPE_FLOAT.equals(type)) {\n+            return Type.FLOAT_TYPE;\n+        } else if (Constants.TYPE_SHORT.equals(type)) {\n+            return Type.SHORT_TYPE;\n+        } else {\n+            return type;\n+        }\n+    }\n+\n+    public static boolean isArray(Type type) {\n+        return type.getSort() == Type.ARRAY;\n+    }\n+\n+    public static Type getComponentType(Type type) {\n+        if (!isArray(type)) {\n+            throw new IllegalArgumentException(\"Type \" + type + \" is not an array\");\n+        }\n+        return Type.getType(type.getDescriptor().substring(1));\n+    }\n+\n+    public static boolean isPrimitive(Type type) {\n+        switch (type.getSort()) {\n+        case Type.ARRAY:\n+        case Type.OBJECT:\n+            return false;\n+        default:\n+            return true;\n+        }\n+    }\n+\n+    public static String emulateClassGetName(Type type) {\n+        if (isArray(type)) {\n+            return type.getDescriptor().replace('/', '.');\n+        } else {\n+            return getClassName(type);\n+        }\n+    }\n+\n+    public static boolean isConstructor(MethodInfo method) {\n+        return method.getSignature().getName().equals(Constants.CONSTRUCTOR_NAME);\n+    }\n+\n+    public static Type[] getTypes(Class[] classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+        Type[] types = new Type[classes.length];\n+        for (int i = 0; i < classes.length; i++) {\n+            types[i] = Type.getType(classes[i]);\n+        }\n+        return types;\n+    }\n+\n+    public static int ICONST(int value) {\n+        switch (value) {\n+        case -1: return Constants.ICONST_M1;\n+        case 0: return Constants.ICONST_0;\n+        case 1: return Constants.ICONST_1;\n+        case 2: return Constants.ICONST_2;\n+        case 3: return Constants.ICONST_3;\n+        case 4: return Constants.ICONST_4;\n+        case 5: return Constants.ICONST_5;\n+        }\n+        return -1; // error\n+    }\n+\n+    public static int LCONST(long value) {\n+        if (value == 0L) {\n+            return Constants.LCONST_0;\n+        } else if (value == 1L) {\n+            return Constants.LCONST_1;\n+        } else {\n+            return -1; // error\n+        }\n+    }\n+\n+    public static int FCONST(float value) {\n+        if (value == 0f) {\n+            return Constants.FCONST_0;\n+        } else if (value == 1f) {\n+            return Constants.FCONST_1;\n+        } else if (value == 2f) {\n+            return Constants.FCONST_2;\n+        } else {\n+            return -1; // error\n+        }\n+    }\n+\n+    public static int DCONST(double value) {\n+        if (value == 0d) {\n+            return Constants.DCONST_0;\n+        } else if (value == 1d) {\n+            return Constants.DCONST_1;\n+        } else {\n+            return -1; // error\n+        }\n+    }\n+\n+    public static int NEWARRAY(Type type) {\n+        switch (type.getSort()) {\n+        case Type.BYTE:\n+            return Constants.T_BYTE;\n+        case Type.CHAR:\n+            return Constants.T_CHAR;\n+        case Type.DOUBLE:\n+            return Constants.T_DOUBLE;\n+        case Type.FLOAT:\n+            return Constants.T_FLOAT;\n+        case Type.INT:\n+            return Constants.T_INT;\n+        case Type.LONG:\n+            return Constants.T_LONG;\n+        case Type.SHORT:\n+            return Constants.T_SHORT;\n+        case Type.BOOLEAN:\n+            return Constants.T_BOOLEAN;\n+        default:\n+            return -1; // error\n+        }\n+    }\n+\n+    public static String escapeType(String s) {\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = 0, len = s.length(); i < len; i++) {\n+            char c = s.charAt(i);\n+            switch (c) {\n+            case '$': sb.append(\"$24\"); break;\n+            case '.': sb.append(\"$2E\"); break;\n+            case '[': sb.append(\"$5B\"); break;\n+            case ';': sb.append(\"$3B\"); break;\n+            case '(': sb.append(\"$28\"); break;\n+            case ')': sb.append(\"$29\"); break;\n+            case '/': sb.append(\"$2F\"); break;\n+            default:\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/core/VisibilityPredicate.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.core;\n+\n+import java.lang.reflect.*;\n+\n+import org.mockito.asm.Type;\n+\n+public class VisibilityPredicate implements Predicate {\n+    private boolean protectedOk;\n+    private String pkg;\n+\n+    public VisibilityPredicate(Class source, boolean protectedOk) {\n+        this.protectedOk = protectedOk;\n+        pkg = TypeUtils.getPackageName(Type.getType(source));\n+    }\n+\n+    public boolean evaluate(Object arg) {\n+        int mod = (arg instanceof Member) ? ((Member)arg).getModifiers() : ((Integer)arg).intValue();\n+        if (Modifier.isPrivate(mod)) {\n+            return false;\n+        } else if (Modifier.isPublic(mod)) {\n+            return true;\n+        } else if (Modifier.isProtected(mod)) {\n+            return protectedOk;\n+        } else {\n+            return pkg.equals(TypeUtils.getPackageName(Type.getType(((Member)arg).getDeclaringClass())));\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Callback.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * All callback interfaces used by {@link Enhancer} extend this interface.\n+ * @see MethodInterceptor\n+ * @see NoOp\n+ * @see LazyLoader\n+ * @see Dispatcher\n+ * @see InvocationHandler\n+ * @see FixedValue\n+ */\n+public interface Callback\n+{\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackFilter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Map methods of subclasses generated by {@link Enhancer} to a particular\n+ * callback. The type of the callbacks chosen for each method affects\n+ * the bytecode generated for that method in the subclass, and cannot\n+ * change for the life of the class.\n+ */\n+public interface CallbackFilter {\n+    /**\n+     * Map a method to a callback.\n+     * @param method the intercepted method\n+     * @return the index into the array of callbacks (as specified by {@link Enhancer#setCallbacks}) to use for the method, \n+     */\n+    int accept(Method method);\n+\n+    /**\n+     * The <code>CallbackFilter</code> in use affects which cached class\n+     * the <code>Enhancer</code> will use, so this is a reminder that\n+     * you should correctly implement <code>equals</code> and\n+     * <code>hashCode</code> for custom <code>CallbackFilter</code>\n+     * implementations in order to improve performance.\n+    */\n+    boolean equals(Object o);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.util.List;\n+\n+import org.mockito.cglib.core.*;\n+\n+interface CallbackGenerator\n+{\n+    void generate(ClassEmitter ce, Context context, List methods) throws Exception;\n+    void generateStatic(CodeEmitter e, Context context, List methods) throws Exception;\n+\n+    interface Context\n+    {\n+        ClassLoader getClassLoader();\n+        CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method);\n+        int getOriginalModifiers(MethodInfo method);\n+        int getIndex(MethodInfo method);\n+        void emitCallback(CodeEmitter ce, int index);\n+        Signature getImplSignature(MethodInfo method);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackHelper.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.cglib.core.ReflectUtils;\n+\n+/**\n+ * @version $Id: CallbackHelper.java,v 1.2 2004/06/24 21:15:20 herbyderby Exp $\n+ */\n+abstract public class CallbackHelper\n+implements CallbackFilter\n+{\n+    private Map methodMap = new HashMap();\n+    private List callbacks = new ArrayList();\n+    \n+    public CallbackHelper(Class superclass, Class[] interfaces)\n+    {\n+        List methods = new ArrayList();\n+        Enhancer.getMethods(superclass, interfaces, methods);\n+        Map indexes = new HashMap();\n+        for (int i = 0, size = methods.size(); i < size; i++) {\n+            Method method = (Method)methods.get(i);\n+            Object callback = getCallback(method);\n+            if (callback == null)\n+                throw new IllegalStateException(\"getCallback cannot return null\");\n+            boolean isCallback = callback instanceof Callback;\n+            if (!(isCallback || (callback instanceof Class)))\n+                throw new IllegalStateException(\"getCallback must return a Callback or a Class\");\n+            if (i > 0 && ((callbacks.get(i - 1) instanceof Callback) ^ isCallback))\n+                throw new IllegalStateException(\"getCallback must return a Callback or a Class consistently for every Method\");\n+            Integer index = (Integer)indexes.get(callback);\n+            if (index == null) {\n+                index = new Integer(callbacks.size());\n+                indexes.put(callback, index);\n+            }\n+            methodMap.put(method, index);\n+            callbacks.add(callback);\n+        }\n+    }\n+\n+    abstract protected Object getCallback(Method method);\n+\n+    public Callback[] getCallbacks()\n+    {\n+        if (callbacks.size() == 0)\n+            return new Callback[0];\n+        if (callbacks.get(0) instanceof Callback) {\n+            return (Callback[])callbacks.toArray(new Callback[callbacks.size()]);\n+        } else {\n+            throw new IllegalStateException(\"getCallback returned classes, not callbacks; call getCallbackTypes instead\");\n+        }\n+    }\n+\n+    public Class[] getCallbackTypes()\n+    {\n+        if (callbacks.size() == 0)\n+            return new Class[0];\n+        if (callbacks.get(0) instanceof Callback) {\n+            return ReflectUtils.getClasses(getCallbacks());\n+        } else {\n+            return (Class[])callbacks.toArray(new Class[callbacks.size()]);\n+        }\n+    }\n+\n+    public int accept(Method method)\n+    {\n+        return ((Integer)methodMap.get(method)).intValue();\n+    }\n+\n+    public int hashCode()\n+    {\n+        return methodMap.hashCode();\n+    }\n+    \n+    public boolean equals(Object o)\n+    {\n+        if (o == null)\n+            return false;\n+        if (!(o instanceof CallbackHelper))\n+            return false;\n+        return methodMap.equals(((CallbackHelper)o).methodMap);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/CallbackInfo.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import org.mockito.asm.Type;\n+\n+class CallbackInfo\n+{\n+    public static Type[] determineTypes(Class[] callbackTypes) {\n+        Type[] types = new Type[callbackTypes.length];\n+        for (int i = 0; i < types.length; i++) {\n+            types[i] = determineType(callbackTypes[i]);\n+        }\n+        return types;\n+    }\n+\n+    public static Type[] determineTypes(Callback[] callbacks) {\n+        Type[] types = new Type[callbacks.length];\n+        for (int i = 0; i < types.length; i++) {\n+            types[i] = determineType(callbacks[i]);\n+        }\n+        return types;\n+    }\n+\n+    public static CallbackGenerator[] getGenerators(Type[] callbackTypes) {\n+        CallbackGenerator[] generators = new CallbackGenerator[callbackTypes.length];\n+        for (int i = 0; i < generators.length; i++) {\n+            generators[i] = getGenerator(callbackTypes[i]);\n+        }\n+        return generators;\n+    }\n+\n+    //////////////////// PRIVATE ////////////////////\n+\n+    private Class cls;\n+    private CallbackGenerator generator;\n+    private Type type;\n+    \n+    private static final CallbackInfo[] CALLBACKS = {\n+        new CallbackInfo(NoOp.class, NoOpGenerator.INSTANCE),\n+        new CallbackInfo(MethodInterceptor.class, MethodInterceptorGenerator.INSTANCE),\n+        new CallbackInfo(InvocationHandler.class, InvocationHandlerGenerator.INSTANCE),\n+        new CallbackInfo(LazyLoader.class, LazyLoaderGenerator.INSTANCE),\n+        new CallbackInfo(Dispatcher.class, DispatcherGenerator.INSTANCE),\n+        new CallbackInfo(FixedValue.class, FixedValueGenerator.INSTANCE),\n+        new CallbackInfo(ProxyRefDispatcher.class, DispatcherGenerator.PROXY_REF_INSTANCE),\n+    };\n+\n+    private CallbackInfo(Class cls, CallbackGenerator generator) {\n+        this.cls = cls;\n+        this.generator = generator;\n+        type = Type.getType(cls);\n+    }\n+\n+    private static Type determineType(Callback callback) {\n+        if (callback == null) {\n+            throw new IllegalStateException(\"Callback is null\");\n+        }\n+        return determineType(callback.getClass());\n+    }\n+\n+    private static Type determineType(Class callbackType) {\n+        Class cur = null;\n+        for (int i = 0; i < CALLBACKS.length; i++) {\n+            CallbackInfo info = CALLBACKS[i];\n+            if (info.cls.isAssignableFrom(callbackType)) {\n+                if (cur != null) {\n+                    throw new IllegalStateException(\"Callback implements both \" + cur + \" and \" + info.cls);\n+                }\n+                cur = info.cls;\n+            }\n+        }\n+        if (cur == null) {\n+            throw new IllegalStateException(\"Unknown callback type \" + callbackType);\n+        }\n+        return Type.getType(cur);\n+    }\n+\n+    private static CallbackGenerator getGenerator(Type callbackType) {\n+        for (int i = 0; i < CALLBACKS.length; i++) {\n+            CallbackInfo info = CALLBACKS[i];\n+            if (info.type.equals(callbackType)) {\n+                return info.generator;\n+            }\n+        }\n+        throw new IllegalStateException(\"Unknown callback type \" + callbackType);\n+    }\n+}\n+    \n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Dispatcher.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * Dispatching {@link Enhancer} callback. This is identical to the\n+ * {@link LazyLoader} interface but needs to be separate so that <code>Enhancer</code>\n+ * knows which type of code to generate.\n+ */\n+public interface Dispatcher extends Callback {\n+    /**\n+     * Return the object which the original method invocation should\n+     * be dispatched. This method is called for <b>every</b> method invocation.\n+     * @return an object that can invoke the method\n+     */\n+    Object loadObject() throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/DispatcherGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class DispatcherGenerator implements CallbackGenerator {\n+    public static final DispatcherGenerator INSTANCE =\n+      new DispatcherGenerator(false);\n+    public static final DispatcherGenerator PROXY_REF_INSTANCE =\n+      new DispatcherGenerator(true);\n+\n+    private static final Type DISPATCHER =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.Dispatcher\");\n+    private static final Type PROXY_REF_DISPATCHER =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.ProxyRefDispatcher\");\n+    private static final Signature LOAD_OBJECT =\n+      TypeUtils.parseSignature(\"Object loadObject()\");\n+    private static final Signature PROXY_REF_LOAD_OBJECT =\n+      TypeUtils.parseSignature(\"Object loadObject(Object)\");\n+\n+    private boolean proxyRef;\n+\n+    private DispatcherGenerator(boolean proxyRef) {\n+        this.proxyRef = proxyRef;\n+    }\n+\n+    public void generate(ClassEmitter ce, Context context, List methods) {\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            if (!TypeUtils.isProtected(method.getModifiers())) {\n+                CodeEmitter e = context.beginMethod(ce, method);\n+                context.emitCallback(e, context.getIndex(method));\n+                if (proxyRef) {\n+                    e.load_this();\n+                    e.invoke_interface(PROXY_REF_DISPATCHER, PROXY_REF_LOAD_OBJECT);\n+                } else {\n+                    e.invoke_interface(DISPATCHER, LOAD_OBJECT);\n+                }\n+                e.checkcast(method.getClassInfo().getType());\n+                e.load_args();\n+                e.invoke(method);\n+                e.return_value();\n+                e.end_method();\n+            }\n+        }\n+    }\n+\n+    public void generateStatic(CodeEmitter e, Context context, List methods) { }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Enhancer.java\n+/*\n+ * Copyright 2002,2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * Generates dynamic subclasses to enable method interception. This\n+ * class started as a substitute for the standard Dynamic Proxy support\n+ * included with JDK 1.3, but one that allowed the proxies to extend a\n+ * concrete base class, in addition to implementing interfaces. The dynamically\n+ * generated subclasses override the non-final methods of the superclass and\n+ * have hooks which callback to user-defined interceptor\n+ * implementations.\n+ * <p>\n+ * The original and most general callback type is the {@link MethodInterceptor}, which\n+ * in AOP terms enables \"around advice\"--that is, you can invoke custom code both before\n+ * and after the invocation of the \"super\" method. In addition you can modify the\n+ * arguments before calling the super method, or not call it at all.\n+ * <p>\n+ * Although <code>MethodInterceptor</code> is generic enough to meet any\n+ * interception need, it is often overkill. For simplicity and performance, additional\n+ * specialized callback types, such as {@link LazyLoader} are also available.\n+ * Often a single callback will be used per enhanced class, but you can control\n+ * which callback is used on a per-method basis with a {@link CallbackFilter}.\n+ * <p>\n+ * The most common uses of this class are embodied in the static helper methods. For\n+ * advanced needs, such as customizing the <code>ClassLoader</code> to use, you should create\n+ * a new instance of <code>Enhancer</code>. Other classes within CGLIB follow a similar pattern.\n+ * <p>\n+ * All enhanced objects implement the {@link Factory} interface, unless {@link #setUseFactory} is\n+ * used to explicitly disable this feature. The <code>Factory</code> interface provides an API\n+ * to change the callbacks of an existing object, as well as a faster and easier way to create\n+ * new instances of the same type.\n+ * <p>\n+ * For an almost drop-in replacement for\n+ * <code>java.lang.reflect.Proxy</code>, see the {@link Proxy} class.\n+ */\n+public class Enhancer extends AbstractClassGenerator\n+{\n+    private static final CallbackFilter ALL_ZERO = new CallbackFilter(){\n+        public int accept(Method method) {\n+            return 0;\n+        }\n+    };\n+\n+    private static final Source SOURCE = new Source(Enhancer.class.getName());\n+    private static final EnhancerKey KEY_FACTORY =\n+      (EnhancerKey)KeyFactory.create(EnhancerKey.class);\n+\n+    private static final String BOUND_FIELD = \"CGLIB$BOUND\";\n+    private static final String THREAD_CALLBACKS_FIELD = \"CGLIB$THREAD_CALLBACKS\";\n+    private static final String STATIC_CALLBACKS_FIELD = \"CGLIB$STATIC_CALLBACKS\";\n+    private static final String SET_THREAD_CALLBACKS_NAME = \"CGLIB$SET_THREAD_CALLBACKS\";\n+    private static final String SET_STATIC_CALLBACKS_NAME = \"CGLIB$SET_STATIC_CALLBACKS\";\n+    private static final String CONSTRUCTED_FIELD = \"CGLIB$CONSTRUCTED\";\n+\n+    private static final Type FACTORY =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.Factory\");\n+    private static final Type ILLEGAL_STATE_EXCEPTION =\n+      TypeUtils.parseType(\"IllegalStateException\");\n+    private static final Type ILLEGAL_ARGUMENT_EXCEPTION =\n+      TypeUtils.parseType(\"IllegalArgumentException\");\n+    private static final Type THREAD_LOCAL =\n+      TypeUtils.parseType(\"ThreadLocal\");\n+    private static final Type CALLBACK =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.Callback\");\n+    private static final Type CALLBACK_ARRAY =\n+      Type.getType(Callback[].class);\n+    private static final Signature CSTRUCT_NULL =\n+      TypeUtils.parseConstructor(\"\");\n+    private static final Signature SET_THREAD_CALLBACKS =\n+      new Signature(SET_THREAD_CALLBACKS_NAME, Type.VOID_TYPE, new Type[]{ CALLBACK_ARRAY });\n+    private static final Signature SET_STATIC_CALLBACKS =\n+      new Signature(SET_STATIC_CALLBACKS_NAME, Type.VOID_TYPE, new Type[]{ CALLBACK_ARRAY });\n+    private static final Signature NEW_INSTANCE =\n+      new Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[]{ CALLBACK_ARRAY });\n+    private static final Signature MULTIARG_NEW_INSTANCE =\n+      new Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[]{\n+          Constants.TYPE_CLASS_ARRAY,\n+          Constants.TYPE_OBJECT_ARRAY,\n+          CALLBACK_ARRAY,\n+      });\n+    private static final Signature SINGLE_NEW_INSTANCE =\n+      new Signature(\"newInstance\", Constants.TYPE_OBJECT, new Type[]{ CALLBACK });\n+    private static final Signature SET_CALLBACK =\n+      new Signature(\"setCallback\", Type.VOID_TYPE, new Type[]{ Type.INT_TYPE, CALLBACK });\n+    private static final Signature GET_CALLBACK =\n+      new Signature(\"getCallback\", CALLBACK, new Type[]{ Type.INT_TYPE });\n+    private static final Signature SET_CALLBACKS =\n+      new Signature(\"setCallbacks\", Type.VOID_TYPE, new Type[]{ CALLBACK_ARRAY });\n+    private static final Signature GET_CALLBACKS =\n+      new Signature(\"getCallbacks\", CALLBACK_ARRAY, new Type[0]);\n+    private static final Signature THREAD_LOCAL_GET =\n+      TypeUtils.parseSignature(\"Object get()\");\n+    private static final Signature THREAD_LOCAL_SET =\n+      TypeUtils.parseSignature(\"void set(Object)\");\n+    private static final Signature BIND_CALLBACKS =\n+      TypeUtils.parseSignature(\"void CGLIB$BIND_CALLBACKS(Object)\");\n+\n+    /** Internal interface, only public due to ClassLoader issues. */\n+    public interface EnhancerKey {\n+        public Object newInstance(String type,\n+                                  String[] interfaces,\n+                                  CallbackFilter filter,\n+                                  Type[] callbackTypes,\n+                                  boolean useFactory,\n+                                  boolean interceptDuringConstruction,\n+                                  Long serialVersionUID);\n+    }\n+\n+    private Class[] interfaces;\n+    private CallbackFilter filter;\n+    private Callback[] callbacks;\n+    private Type[] callbackTypes;\n+    private boolean classOnly;\n+    private Class superclass;\n+    private Class[] argumentTypes;\n+    private Object[] arguments;\n+    private boolean useFactory = true;\n+    private Long serialVersionUID;\n+    private boolean interceptDuringConstruction = true;\n+\n+    /**\n+     * Create a new <code>Enhancer</code>. A new <code>Enhancer</code>\n+     * object should be used for each generated object, and should not\n+     * be shared across threads. To create additional instances of a\n+     * generated class, use the <code>Factory</code> interface.\n+     * @see Factory\n+     */\n+    public Enhancer() {\n+        super(SOURCE);\n+    }\n+\n+    /**\n+     * Set the class which the generated class will extend. As a convenience,\n+     * if the supplied superclass is actually an interface, <code>setInterfaces</code>\n+     * will be called with the appropriate argument instead.\n+     * A non-interface argument must not be declared as final, and must have an\n+     * accessible constructor.\n+     * @param superclass class to extend or interface to implement\n+     * @see #setInterfaces(Class[])\n+     */\n+    public void setSuperclass(Class superclass) {\n+        if (superclass != null && superclass.isInterface()) {\n+            setInterfaces(new Class[]{ superclass });\n+        } else if (superclass != null && superclass.equals(Object.class)) {\n+            // affects choice of ClassLoader\n+            this.superclass = null;\n+        } else {\n+            this.superclass = superclass;\n+        }\n+    }\n+\n+    /**\n+     * Set the interfaces to implement. The <code>Factory</code> interface will\n+     * always be implemented regardless of what is specified here.\n+     * @param interfaces array of interfaces to implement, or null\n+     * @see Factory\n+     */\n+    public void setInterfaces(Class[] interfaces) {\n+        this.interfaces = interfaces;\n+    }\n+\n+    /**\n+     * Set the {@link CallbackFilter} used to map the generated class' methods\n+     * to a particular callback index.\n+     * New object instances will always use the same mapping, but may use different\n+     * actual callback objects.\n+     * @param filter the callback filter to use when generating a new class\n+     * @see #setCallbacks\n+     */\n+    public void setCallbackFilter(CallbackFilter filter) {\n+        this.filter = filter;\n+    }\n+\n+\n+    /**\n+     * Set the single {@link Callback} to use.\n+     * Ignored if you use {@link #createClass}.\n+     * @param callback the callback to use for all methods\n+     * @see #setCallbacks\n+     */\n+    public void setCallback(final Callback callback) {\n+        setCallbacks(new Callback[]{ callback });\n+    }\n+\n+    /**\n+     * Set the array of callbacks to use.\n+     * Ignored if you use {@link #createClass}.\n+     * You must use a {@link CallbackFilter} to specify the index into this\n+     * array for each method in the proxied class.\n+     * @param callbacks the callback array\n+     * @see #setCallbackFilter\n+     * @see #setCallback\n+     */\n+    public void setCallbacks(Callback[] callbacks) {\n+        if (callbacks != null && callbacks.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty\");\n+        }\n+        this.callbacks = callbacks;\n+    }\n+\n+    /**\n+     * Set whether the enhanced object instances should implement\n+     * the {@link Factory} interface.\n+     * This was added for tools that need for proxies to be more\n+     * indistinguishable from their targets. Also, in some cases it may\n+     * be necessary to disable the <code>Factory</code> interface to\n+     * prevent code from changing the underlying callbacks.\n+     * @param useFactory whether to implement <code>Factory</code>; default is <code>true</code>\n+     */\n+    public void setUseFactory(boolean useFactory) {\n+        this.useFactory = useFactory;\n+    }\n+\n+    /**\n+     * Set whether methods called from within the proxy's constructer\n+     * will be intercepted. The default value is true. Unintercepted methods\n+     * will call the method of the proxy's base class, if it exists.\n+     * @param interceptDuringConstruction whether to intercept methods called from the constructor\n+     */\n+    public void setInterceptDuringConstruction(boolean interceptDuringConstruction) {\n+        this.interceptDuringConstruction = interceptDuringConstruction;\n+    }\n+\n+    /**\n+     * Set the single type of {@link Callback} to use.\n+     * This may be used instead of {@link #setCallback} when calling\n+     * {@link #createClass}, since it may not be possible to have\n+     * an array of actual callback instances.\n+     * @param callbackType the type of callback to use for all methods\n+     * @see #setCallbackTypes\n+     */     \n+    public void setCallbackType(Class callbackType) {\n+        setCallbackTypes(new Class[]{ callbackType });\n+    }\n+    \n+    /**\n+     * Set the array of callback types to use.\n+     * This may be used instead of {@link #setCallbacks} when calling\n+     * {@link #createClass}, since it may not be possible to have\n+     * an array of actual callback instances.\n+     * You must use a {@link CallbackFilter} to specify the index into this\n+     * array for each method in the proxied class.\n+     * @param callbackTypes the array of callback types\n+     */\n+    public void setCallbackTypes(Class[] callbackTypes) {\n+        if (callbackTypes != null && callbackTypes.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty\");\n+        }\n+        this.callbackTypes = CallbackInfo.determineTypes(callbackTypes);\n+    }\n+\n+    /**\n+     * Generate a new class if necessary and uses the specified\n+     * callbacks (if any) to create a new object instance.\n+     * Uses the no-arg constructor of the superclass.\n+     * @return a new instance\n+     */\n+    public Object create() {\n+        classOnly = false;\n+        argumentTypes = null;\n+        return createHelper();\n+    }\n+\n+    /**\n+     * Generate a new class if necessary and uses the specified\n+     * callbacks (if any) to create a new object instance.\n+     * Uses the constructor of the superclass matching the <code>argumentTypes</code>\n+     * parameter, with the given arguments.\n+     * @param argumentTypes constructor signature\n+     * @param arguments compatible wrapped arguments to pass to constructor\n+     * @return a new instance\n+     */\n+    public Object create(Class[] argumentTypes, Object[] arguments) {\n+        classOnly = false;\n+        if (argumentTypes == null || arguments == null || argumentTypes.length != arguments.length) {\n+            throw new IllegalArgumentException(\"Arguments must be non-null and of equal length\");\n+        }\n+        this.argumentTypes = argumentTypes;\n+        this.arguments = arguments;\n+        return createHelper();\n+    }\n+\n+    /**\n+     * Generate a new class if necessary and return it without creating a new instance.\n+     * This ignores any callbacks that have been set.\n+     * To create a new instance you will have to use reflection, and methods\n+     * called during the constructor will not be intercepted. To avoid this problem,\n+     * use the multi-arg <code>create</code> method.\n+     * @see #create(Class[], Object[])\n+     */\n+    public Class createClass() {\n+        classOnly = true;\n+        return (Class)createHelper();\n+    }\n+\n+    /**\n+     * Insert a static serialVersionUID field into the generated class.\n+     * @param sUID the field value, or null to avoid generating field.\n+     */\n+    public void setSerialVersionUID(Long sUID) {\n+        serialVersionUID = sUID;\n+    }\n+\n+    private void validate() {\n+        if (classOnly ^ (callbacks == null)) {\n+            if (classOnly) {\n+                throw new IllegalStateException(\"createClass does not accept callbacks\");\n+            } else {\n+                throw new IllegalStateException(\"Callbacks are required\");\n+            }\n+        }\n+        if (classOnly && (callbackTypes == null)) {\n+            throw new IllegalStateException(\"Callback types are required\");\n+        }\n+        if (callbacks != null && callbackTypes != null) {\n+            if (callbacks.length != callbackTypes.length) {\n+                throw new IllegalStateException(\"Lengths of callback and callback types array must be the same\");\n+            }\n+            Type[] check = CallbackInfo.determineTypes(callbacks);\n+            for (int i = 0; i < check.length; i++) {\n+                if (!check[i].equals(callbackTypes[i])) {\n+                    throw new IllegalStateException(\"Callback \" + check[i] + \" is not assignable to \" + callbackTypes[i]);\n+                }\n+            }\n+        } else if (callbacks != null) {\n+            callbackTypes = CallbackInfo.determineTypes(callbacks);\n+        }\n+        if (filter == null) {\n+            if (callbackTypes.length > 1) {\n+                throw new IllegalStateException(\"Multiple callback types possible but no filter specified\");\n+            }\n+            filter = ALL_ZERO;\n+        }\n+        if (interfaces != null) {\n+            for (int i = 0; i < interfaces.length; i++) {\n+                if (interfaces[i] == null) {\n+                    throw new IllegalStateException(\"Interfaces cannot be null\");\n+                }\n+                if (!interfaces[i].isInterface()) {\n+                    throw new IllegalStateException(interfaces[i] + \" is not an interface\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private Object createHelper() {\n+        validate();\n+        if (superclass != null) {\n+            setNamePrefix(superclass.getName());\n+        } else if (interfaces != null) {\n+            setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());\n+        }\n+        return super.create(KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,\n+                                                    ReflectUtils.getNames(interfaces),\n+                                                    filter,\n+                                                    callbackTypes,\n+                                                    useFactory,\n+                                                    interceptDuringConstruction,\n+                                                    serialVersionUID));\n+    }\n+\n+    protected ClassLoader getDefaultClassLoader() {\n+        if (superclass != null) {\n+            return superclass.getClassLoader();\n+        } else if (interfaces != null) {\n+            return interfaces[0].getClassLoader();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private Signature rename(Signature sig, int index) {\n+        return new Signature(\"CGLIB$\" + sig.getName() + \"$\" + index,\n+                             sig.getDescriptor());\n+    }\n+    \n+    /**\n+     * Finds all of the methods that will be extended by an\n+     * Enhancer-generated class using the specified superclass and\n+     * interfaces. This can be useful in building a list of Callback\n+     * objects. The methods are added to the end of the given list.  Due\n+     * to the subclassing nature of the classes generated by Enhancer,\n+     * the methods are guaranteed to be non-static, non-final, and\n+     * non-private. Each method signature will only occur once, even if\n+     * it occurs in multiple classes.\n+     * @param superclass the class that will be extended, or null\n+     * @param interfaces the list of interfaces that will be implemented, or null\n+     * @param methods the list into which to copy the applicable methods\n+     */\n+    public static void getMethods(Class superclass, Class[] interfaces, List methods)\n+    {\n+        getMethods(superclass, interfaces, methods, null, null);\n+    }\n+\n+    private static void getMethods(Class superclass, Class[] interfaces, List methods, List interfaceMethods, Set forcePublic)\n+    {\n+        ReflectUtils.addAllMethods(superclass, methods);\n+        List target = (interfaceMethods != null) ? interfaceMethods : methods;\n+        if (interfaces != null) {\n+            for (int i = 0; i < interfaces.length; i++) {\n+                if (interfaces[i] != Factory.class) {\n+                    ReflectUtils.addAllMethods(interfaces[i], target);\n+                }\n+            }\n+        }\n+        if (interfaceMethods != null) {\n+            if (forcePublic != null) {\n+                forcePublic.addAll(MethodWrapper.createSet(interfaceMethods));\n+            }\n+            methods.addAll(interfaceMethods);\n+        }\n+        CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC));\n+        CollectionUtils.filter(methods, new VisibilityPredicate(superclass, true));\n+        CollectionUtils.filter(methods, new DuplicatesPredicate());\n+        CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_FINAL));\n+    }\n+\n+    public void generateClass(ClassVisitor v) throws Exception {\n+        Class sc = (superclass == null) ? Object.class : superclass;\n+\n+        if (TypeUtils.isFinal(sc.getModifiers()))\n+            throw new IllegalArgumentException(\"Cannot subclass final class \" + sc);\n+        List constructors = new ArrayList(Arrays.asList(sc.getDeclaredConstructors()));\n+        filterConstructors(sc, constructors);\n+\n+        // Order is very important: must add superclass, then\n+        // its superclass chain, then each interface and\n+        // its superinterfaces.\n+        List actualMethods = new ArrayList();\n+        List interfaceMethods = new ArrayList();\n+        final Set forcePublic = new HashSet();\n+        getMethods(sc, interfaces, actualMethods, interfaceMethods, forcePublic);\n+\n+        List methods = CollectionUtils.transform(actualMethods, new Transformer() {\n+            public Object transform(Object value) {\n+                Method method = (Method)value;\n+                int modifiers = Constants.ACC_FINAL\n+                    | (method.getModifiers()\n+                       & ~Constants.ACC_ABSTRACT\n+                       & ~Constants.ACC_NATIVE\n+                       & ~Constants.ACC_SYNCHRONIZED);\n+                if (forcePublic.contains(MethodWrapper.create(method))) {\n+                    modifiers = (modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;\n+                }\n+                return ReflectUtils.getMethodInfo(method, modifiers);\n+            }\n+        });\n+\n+        ClassEmitter e = new ClassEmitter(v);\n+        e.begin_class(Constants.V1_2,\n+                      Constants.ACC_PUBLIC,\n+                      getClassName(),\n+                      Type.getType(sc),\n+                      (useFactory ?\n+                       TypeUtils.add(TypeUtils.getTypes(interfaces), FACTORY) :\n+                       TypeUtils.getTypes(interfaces)),\n+                      Constants.SOURCE_FILE);\n+        List constructorInfo = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n+\n+        e.declare_field(Constants.ACC_PRIVATE, BOUND_FIELD, Type.BOOLEAN_TYPE, null);\n+        if (!interceptDuringConstruction) {\n+            e.declare_field(Constants.ACC_PRIVATE, CONSTRUCTED_FIELD, Type.BOOLEAN_TYPE, null);\n+        }\n+        e.declare_field(Constants.PRIVATE_FINAL_STATIC, THREAD_CALLBACKS_FIELD, THREAD_LOCAL, null);\n+        e.declare_field(Constants.PRIVATE_FINAL_STATIC, STATIC_CALLBACKS_FIELD, CALLBACK_ARRAY, null);\n+        if (serialVersionUID != null) {\n+            e.declare_field(Constants.PRIVATE_FINAL_STATIC, Constants.SUID_FIELD_NAME, Type.LONG_TYPE, serialVersionUID);\n+        }\n+\n+        for (int i = 0; i < callbackTypes.length; i++) {\n+            e.declare_field(Constants.ACC_PRIVATE, getCallbackField(i), callbackTypes[i], null);\n+        }\n+\n+        emitMethods(e, methods, actualMethods);\n+        emitConstructors(e, constructorInfo);\n+        emitSetThreadCallbacks(e);\n+        emitSetStaticCallbacks(e);\n+        emitBindCallbacks(e);\n+\n+        if (useFactory) {\n+            int[] keys = getCallbackKeys();\n+            emitNewInstanceCallbacks(e);\n+            emitNewInstanceCallback(e);\n+            emitNewInstanceMultiarg(e, constructorInfo);\n+            emitGetCallback(e, keys);\n+            emitSetCallback(e, keys);\n+            emitGetCallbacks(e);\n+            emitSetCallbacks(e);\n+        }\n+\n+        e.end_class();\n+    }\n+\n+    /**\n+     * Filter the list of constructors from the superclass. The\n+     * constructors which remain will be included in the generated\n+     * class. The default implementation is to filter out all private\n+     * constructors, but subclasses may extend Enhancer to override this\n+     * behavior.\n+     * @param sc the superclass\n+     * @param constructors the list of all declared constructors from the superclass\n+     * @throws IllegalArgumentException if there are no non-private constructors\n+     */\n+    protected void filterConstructors(Class sc, List constructors) {\n+        CollectionUtils.filter(constructors, new VisibilityPredicate(sc, true));\n+        if (constructors.size() == 0)\n+            throw new IllegalArgumentException(\"No visible constructors in \" + sc);\n+    }\n+\n+    protected Object firstInstance(Class type) throws Exception {\n+        if (classOnly) {\n+            return type;\n+        } else {\n+            return createUsingReflection(type);\n+        }\n+    }\n+\n+    protected Object nextInstance(Object instance) {\n+        Class protoclass = (instance instanceof Class) ? (Class)instance : instance.getClass();\n+        if (classOnly) {\n+            return protoclass;\n+        } else if (instance instanceof Factory) {\n+            if (argumentTypes != null) {\n+                return ((Factory)instance).newInstance(argumentTypes, arguments, callbacks);\n+            } else {\n+                return ((Factory)instance).newInstance(callbacks);\n+            }\n+        } else {\n+            return createUsingReflection(protoclass);\n+        }\n+    }\n+\n+    /**\n+     * Call this method to register the {@link Callback} array to use before\n+     * creating a new instance of the generated class via reflection. If you are using\n+     * an instance of <code>Enhancer</code> or the {@link Factory} interface to create\n+     * new instances, this method is unnecessary. Its primary use is for when you want to\n+     * cache and reuse a generated class yourself, and the generated class does\n+     * <i>not</i> implement the {@link Factory} interface.\n+     * <p>\n+     * Note that this method only registers the callbacks on the current thread.\n+     * If you want to register callbacks for instances created by multiple threads,\n+     * use {@link #registerStaticCallbacks}.\n+     * <p>\n+     * The registered callbacks are overwritten and subsequently cleared\n+     * when calling any of the <code>create</code> methods (such as\n+     * {@link #create}), or any {@link Factory} <code>newInstance</code> method.\n+     * Otherwise they are <i>not</i> cleared, and you should be careful to set them\n+     * back to <code>null</code> after creating new instances via reflection if\n+     * memory leakage is a concern.\n+     * @param generatedClass a class previously created by {@link Enhancer}\n+     * @param callbacks the array of callbacks to use when instances of the generated\n+     * class are created\n+     * @see #setUseFactory\n+     */\n+    public static void registerCallbacks(Class generatedClass, Callback[] callbacks) {\n+        setThreadCallbacks(generatedClass, callbacks);\n+    }\n+\n+    /**\n+     * Similar to {@link #registerCallbacks}, but suitable for use\n+     * when multiple threads will be creating instances of the generated class.\n+     * The thread-level callbacks will always override the static callbacks.\n+     * Static callbacks are never cleared.\n+     * @param generatedClass a class previously created by {@link Enhancer}\n+     * @param callbacks the array of callbacks to use when instances of the generated\n+     * class are created\n+     */\n+    public static void registerStaticCallbacks(Class generatedClass, Callback[] callbacks) {\n+        setCallbacksHelper(generatedClass, callbacks, SET_STATIC_CALLBACKS_NAME);\n+    }\n+\n+    /**\n+     * Determine if a class was generated using <code>Enhancer</code>.\n+     * @param type any class\n+     * @return whether the class was generated  using <code>Enhancer</code>\n+     */\n+    public static boolean isEnhanced(Class type) {\n+        try {\n+            getCallbacksSetter(type, SET_THREAD_CALLBACKS_NAME);\n+            return true;\n+        } catch (NoSuchMethodException e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void setThreadCallbacks(Class type, Callback[] callbacks) {\n+        setCallbacksHelper(type, callbacks, SET_THREAD_CALLBACKS_NAME);\n+    }\n+\n+    private static void setCallbacksHelper(Class type, Callback[] callbacks, String methodName) {\n+        // TODO: optimize\n+        try {\n+            Method setter = getCallbacksSetter(type, methodName);\n+            setter.invoke(null, new Object[]{ callbacks });\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(type + \" is not an enhanced class\");\n+        } catch (IllegalAccessException e) {\n+            throw new CodeGenerationException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+\n+    private static Method getCallbacksSetter(Class type, String methodName) throws NoSuchMethodException {\n+        return type.getDeclaredMethod(methodName, new Class[]{ Callback[].class });\n+    }\n+\n+    private Object createUsingReflection(Class type) {\n+        setThreadCallbacks(type, callbacks);\n+        try{\n+        \n+        if (argumentTypes != null) {\n+        \t\n+             return ReflectUtils.newInstance(type, argumentTypes, arguments);\n+             \n+        } else {\n+        \t\n+            return ReflectUtils.newInstance(type);\n+            \n+        }\n+        }finally{\n+         // clear thread callbacks to allow them to be gc'd\n+         setThreadCallbacks(type, null);\n+        }\n+    }\n+\n+    /**\n+     * Helper method to create an intercepted object.\n+     * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n+     * instead of this static method.\n+     * @param type class to extend or interface to implement\n+     * @param callback the callback to use for all methods\n+     */\n+    public static Object create(Class type, Callback callback) {\n+        Enhancer e = new Enhancer();\n+        e.setSuperclass(type);\n+        e.setCallback(callback);\n+        return e.create();\n+    }\n+\n+    /**\n+     * Helper method to create an intercepted object.\n+     * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n+     * instead of this static method.\n+     * @param type class to extend or interface to implement\n+     * @param interfaces array of interfaces to implement, or null\n+     * @param callback the callback to use for all methods\n+     */\n+    public static Object create(Class superclass, Class interfaces[], Callback callback) {\n+        Enhancer e = new Enhancer();\n+        e.setSuperclass(superclass);\n+        e.setInterfaces(interfaces);\n+        e.setCallback(callback);\n+        return e.create();\n+    }\n+\n+    /**\n+     * Helper method to create an intercepted object.\n+     * For finer control over the generated instance, use a new instance of <code>Enhancer</code>\n+     * instead of this static method.\n+     * @param type class to extend or interface to implement\n+     * @param interfaces array of interfaces to implement, or null\n+     * @param filter the callback filter to use when generating a new class\n+     * @param callbacks callback implementations to use for the enhanced object\n+     */\n+    public static Object create(Class superclass, Class[] interfaces, CallbackFilter filter, Callback[] callbacks) {\n+        Enhancer e = new Enhancer();\n+        e.setSuperclass(superclass);\n+        e.setInterfaces(interfaces);\n+        e.setCallbackFilter(filter);\n+        e.setCallbacks(callbacks);\n+        return e.create();\n+    }\n+\n+    private void emitConstructors(ClassEmitter ce, List constructors) {\n+        boolean seenNull = false;\n+        for (Iterator it = constructors.iterator(); it.hasNext();) {\n+            MethodInfo constructor = (MethodInfo)it.next();\n+            CodeEmitter e = EmitUtils.begin_method(ce, constructor, Constants.ACC_PUBLIC);\n+            e.load_this();\n+            e.dup();\n+            e.load_args();\n+            Signature sig = constructor.getSignature();\n+            seenNull = seenNull || sig.getDescriptor().equals(\"()V\");\n+            e.super_invoke_constructor(sig);\n+            e.invoke_static_this(BIND_CALLBACKS);\n+            if (!interceptDuringConstruction) {\n+                e.load_this();\n+                e.push(1);\n+                e.putfield(CONSTRUCTED_FIELD);\n+            }\n+            e.return_value();\n+            e.end_method();\n+        }\n+        if (!classOnly && !seenNull && arguments == null)\n+            throw new IllegalArgumentException(\"Superclass has no null constructors but no arguments were given\");\n+    }\n+\n+    private int[] getCallbackKeys() {\n+        int[] keys = new int[callbackTypes.length];\n+        for (int i = 0; i < callbackTypes.length; i++) {\n+            keys[i] = i;\n+        }\n+        return keys;\n+    }\n+\n+    private void emitGetCallback(ClassEmitter ce, int[] keys) {\n+        final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACK, null);\n+        e.load_this();\n+        e.invoke_static_this(BIND_CALLBACKS);\n+        e.load_this();\n+        e.load_arg(0);\n+        e.process_switch(keys, new ProcessSwitchCallback() {\n+            public void processCase(int key, Label end) {\n+                e.getfield(getCallbackField(key));\n+                e.goTo(end);\n+            }\n+            public void processDefault() {\n+                e.pop(); // stack height\n+                e.aconst_null();\n+            }\n+        });\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void emitSetCallback(ClassEmitter ce, int[] keys) {\n+        final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACK, null);\n+        e.load_arg(0);\n+        e.process_switch(keys, new ProcessSwitchCallback() {\n+            public void processCase(int key, Label end) {\n+                e.load_this();\n+                e.load_arg(1);\n+                e.checkcast(callbackTypes[key]);\n+                e.putfield(getCallbackField(key));\n+                e.goTo(end);\n+            }\n+            public void processDefault() {\n+                // TODO: error?\n+            }\n+        });\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void emitSetCallbacks(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SET_CALLBACKS, null);\n+        e.load_this();\n+        e.load_arg(0);\n+        for (int i = 0; i < callbackTypes.length; i++) {\n+            e.dup2();\n+            e.aaload(i);\n+            e.checkcast(callbackTypes[i]);\n+            e.putfield(getCallbackField(i));\n+        }\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void emitGetCallbacks(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, GET_CALLBACKS, null);\n+        e.load_this();\n+        e.invoke_static_this(BIND_CALLBACKS);\n+        e.load_this();\n+        e.push(callbackTypes.length);\n+        e.newarray(CALLBACK);\n+        for (int i = 0; i < callbackTypes.length; i++) {\n+            e.dup();\n+            e.push(i);\n+            e.load_this();\n+            e.getfield(getCallbackField(i));\n+            e.aastore();\n+        }\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void emitNewInstanceCallbacks(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\n+        e.load_arg(0);\n+        e.invoke_static_this(SET_THREAD_CALLBACKS);\n+        emitCommonNewInstance(e);\n+    }\n+\n+    private void emitCommonNewInstance(CodeEmitter e) {\n+        e.new_instance_this();\n+        e.dup();\n+        e.invoke_constructor_this();\n+        e.aconst_null();\n+        e.invoke_static_this(SET_THREAD_CALLBACKS);\n+        e.return_value();\n+        e.end_method();\n+    }\n+    \n+    private void emitNewInstanceCallback(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, SINGLE_NEW_INSTANCE, null);\n+        switch (callbackTypes.length) {\n+        case 0:\n+            // TODO: make sure Callback is null\n+            break;\n+        case 1:\n+            // for now just make a new array; TODO: optimize\n+            e.push(1);\n+            e.newarray(CALLBACK);\n+            e.dup();\n+            e.push(0);\n+            e.load_arg(0);\n+            e.aastore();\n+            e.invoke_static_this(SET_THREAD_CALLBACKS);\n+            break;\n+        default:\n+            e.throw_exception(ILLEGAL_STATE_EXCEPTION, \"More than one callback object required\");\n+        }\n+        emitCommonNewInstance(e);\n+    }\n+\n+    private void emitNewInstanceMultiarg(ClassEmitter ce, List constructors) {\n+        final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, MULTIARG_NEW_INSTANCE, null);\n+        e.load_arg(2);\n+        e.invoke_static_this(SET_THREAD_CALLBACKS);\n+        e.new_instance_this();\n+        e.dup();\n+        e.load_arg(0);\n+        EmitUtils.constructor_switch(e, constructors, new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                MethodInfo constructor = (MethodInfo)key;\n+                Type types[] = constructor.getSignature().getArgumentTypes();\n+                for (int i = 0; i < types.length; i++) {\n+                    e.load_arg(1);\n+                    e.push(i);\n+                    e.aaload();\n+                    e.unbox(types[i]);\n+                }\n+                e.invoke_constructor_this(constructor.getSignature());\n+                e.goTo(end);\n+            }\n+            public void processDefault() {\n+                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Constructor not found\");\n+            }\n+        });\n+        e.aconst_null();\n+        e.invoke_static_this(SET_THREAD_CALLBACKS);\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void emitMethods(final ClassEmitter ce, List methods, List actualMethods) {\n+        CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes);\n+\n+        Map groups = new HashMap();\n+        final Map indexes = new HashMap();\n+        final Map originalModifiers = new HashMap();\n+        final Map positions = CollectionUtils.getIndexMap(methods);\n+\n+        Iterator it1 = methods.iterator();\n+        Iterator it2 = (actualMethods != null) ? actualMethods.iterator() : null;\n+\n+        while (it1.hasNext()) {\n+            MethodInfo method = (MethodInfo)it1.next();\n+            Method actualMethod = (it2 != null) ? (Method)it2.next() : null;\n+            int index = filter.accept(actualMethod);\n+            if (index >= callbackTypes.length) {\n+                throw new IllegalArgumentException(\"Callback filter returned an index that is too large: \" + index);\n+            }\n+            originalModifiers.put(method, new Integer((actualMethod != null) ? actualMethod.getModifiers() : method.getModifiers()));\n+            indexes.put(method, new Integer(index));\n+            List group = (List)groups.get(generators[index]);\n+            if (group == null) {\n+                groups.put(generators[index], group = new ArrayList(methods.size()));\n+            }\n+            group.add(method);\n+        }\n+\n+        Set seenGen = new HashSet();\n+        CodeEmitter se = ce.getStaticHook();\n+        se.new_instance(THREAD_LOCAL);\n+        se.dup();\n+        se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL);\n+        se.putfield(THREAD_CALLBACKS_FIELD);\n+\n+        final Object[] state = new Object[1];\n+        CallbackGenerator.Context context = new CallbackGenerator.Context() {\n+            public ClassLoader getClassLoader() {\n+                return Enhancer.this.getClassLoader();\n+            }\n+            public int getOriginalModifiers(MethodInfo method) {\n+                return ((Integer)originalModifiers.get(method)).intValue();\n+            }\n+            public int getIndex(MethodInfo method) {\n+                return ((Integer)indexes.get(method)).intValue();\n+            }\n+            public void emitCallback(CodeEmitter e, int index) {\n+                emitCurrentCallback(e, index);\n+            }\n+            public Signature getImplSignature(MethodInfo method) {\n+                return rename(method.getSignature(), ((Integer)positions.get(method)).intValue());\n+            }\n+            public CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method) {\n+                CodeEmitter e = EmitUtils.begin_method(ce, method);\n+                if (!interceptDuringConstruction &&\n+                    !TypeUtils.isAbstract(method.getModifiers())) {\n+                    Label constructed = e.make_label();\n+                    e.load_this();\n+                    e.getfield(CONSTRUCTED_FIELD);\n+                    e.if_jump(e.NE, constructed);\n+                    e.load_this();\n+                    e.load_args();\n+                    e.super_invoke();\n+                    e.return_value();\n+                    e.mark(constructed);\n+                }\n+                return e;\n+            }\n+        };\n+        for (int i = 0; i < callbackTypes.length; i++) {\n+            CallbackGenerator gen = generators[i];\n+            if (!seenGen.contains(gen)) {\n+                seenGen.add(gen);\n+                final List fmethods = (List)groups.get(gen);\n+                if (fmethods != null) {\n+                    try {\n+                        gen.generate(ce, context, fmethods);\n+                        gen.generateStatic(se, context, fmethods);\n+                    } catch (RuntimeException x) {\n+                        throw x;\n+                    } catch (Exception x) {\n+                        throw new CodeGenerationException(x);\n+                    }\n+                }\n+            }\n+        }\n+        se.return_value();\n+        se.end_method();\n+    }\n+\n+    private void emitSetThreadCallbacks(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC,\n+                                        SET_THREAD_CALLBACKS,\n+                                        null);\n+        e.getfield(THREAD_CALLBACKS_FIELD);\n+        e.load_arg(0);\n+        e.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_SET);\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void emitSetStaticCallbacks(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC,\n+                                        SET_STATIC_CALLBACKS,\n+                                        null);\n+        e.load_arg(0);\n+        e.putfield(STATIC_CALLBACKS_FIELD);\n+        e.return_value();\n+        e.end_method();\n+    }\n+    \n+    private void emitCurrentCallback(CodeEmitter e, int index) {\n+        e.load_this();\n+        e.getfield(getCallbackField(index));\n+        e.dup();\n+        Label end = e.make_label();\n+        e.ifnonnull(end);\n+        e.pop(); // stack height\n+        e.load_this();\n+        e.invoke_static_this(BIND_CALLBACKS);\n+        e.load_this();\n+        e.getfield(getCallbackField(index));\n+        e.mark(end);\n+    }\n+\n+    private void emitBindCallbacks(ClassEmitter ce) {\n+        CodeEmitter e = ce.begin_method(Constants.PRIVATE_FINAL_STATIC,\n+                                        BIND_CALLBACKS,\n+                                        null);\n+        Local me = e.make_local();\n+        e.load_arg(0);\n+        e.checkcast_this();\n+        e.store_local(me);\n+\n+        Label end = e.make_label();\n+        e.load_local(me);\n+        e.getfield(BOUND_FIELD);\n+        e.if_jump(e.NE, end);\n+        e.load_local(me);\n+        e.push(1);\n+        e.putfield(BOUND_FIELD);\n+\n+        e.getfield(THREAD_CALLBACKS_FIELD);\n+        e.invoke_virtual(THREAD_LOCAL, THREAD_LOCAL_GET);\n+        e.dup();\n+        Label found_callback = e.make_label();\n+        e.ifnonnull(found_callback);\n+        e.pop();\n+\n+        e.getfield(STATIC_CALLBACKS_FIELD);\n+        e.dup();\n+        e.ifnonnull(found_callback);\n+        e.pop();\n+        e.goTo(end);\n+\n+        e.mark(found_callback);\n+        e.checkcast(CALLBACK_ARRAY);\n+        e.load_local(me);\n+        e.swap();\n+        for (int i = callbackTypes.length - 1; i >= 0; i--) {\n+            if (i != 0) {\n+                e.dup2();\n+            }\n+            e.aaload(i);\n+            e.checkcast(callbackTypes[i]);\n+            e.putfield(getCallbackField(i));\n+        }\n+\n+        e.mark(end);\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private static String getCallbackField(int index) {\n+        return \"CGLIB$CALLBACK_\" + index;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Factory.java\n+/*\n+ * Copyright 2002,2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * All enhanced instances returned by the {@link Enhancer} class implement this interface.\n+ * Using this interface for new instances is faster than going through the <code>Enhancer</code>\n+ * interface or using reflection. In addition, to intercept methods called during\n+ * object construction you <b>must</b> use these methods instead of reflection.\n+ * @author Juozas Baliuka <a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt</a>\n+ * @version $Id: Factory.java,v 1.13 2004/06/24 21:15:20 herbyderby Exp $\n+ */\n+public interface Factory {\n+    /**\n+     * Creates new instance of the same type, using the no-arg constructor.\n+     * The class of this object must have been created using a single Callback type.\n+     * If multiple callbacks are required an exception will be thrown.\n+     * @param callback the new interceptor to use\n+     * @return new instance of the same type\n+     */     \n+    Object newInstance(Callback callback);\n+    \n+    /**\n+     * Creates new instance of the same type, using the no-arg constructor.\n+     * @param callbacks the new callbacks(s) to use\n+     * @return new instance of the same type\n+     */     \n+    Object newInstance(Callback[] callbacks);\n+\n+    /**\n+     * Creates a new instance of the same type, using the constructor\n+     * matching the given signature.\n+     * @param types the constructor argument types\n+     * @param args the constructor arguments\n+     * @param callbacks the new interceptor(s) to use\n+     * @return new instance of the same type\n+     */\n+    Object newInstance(Class[] types, Object[] args, Callback[] callbacks);\n+\n+    /**\n+     * Return the <code>Callback</code> implementation at the specified index.\n+     * @param index the callback index\n+     * @return the callback implementation\n+     */\n+    Callback getCallback(int index);\n+\n+    /**\n+     * Set the callback for this object for the given type.\n+     * @param index the callback index to replace\n+     * @param callback the new callback\n+     */\n+    void setCallback(int index, Callback callback);\n+\n+    /**\n+     * Replace all of the callbacks for this object at once.\n+     * @param callbacks the new callbacks(s) to use\n+     */\n+    void setCallbacks(Callback[] callbacks);\n+\n+    /**\n+     * Get the current set of callbacks for ths object.\n+     * @return a new array instance\n+     */     \n+    Callback[] getCallbacks();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/FixedValue.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * {@link Enhancer} callback that simply returns the value to return\n+ * from the proxied method. No information about what method\n+ * is being called is available to the callback, and the type of\n+ * the returned object must be compatible with the return type of\n+ * the proxied method. This makes this callback primarily useful\n+ * for forcing a particular method (through the use of a {@link CallbackFilter}\n+ * to return a fixed value with little overhead.\n+ */\n+public interface FixedValue extends Callback {\n+    /**\n+     * Return the object which the original method invocation should\n+     * return. This method is called for <b>every</b> method invocation.\n+     * @return an object matching the type of the return value for every\n+     * method this callback is mapped to\n+     */\n+    Object loadObject() throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/FixedValueGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class FixedValueGenerator implements CallbackGenerator {\n+    public static final FixedValueGenerator INSTANCE = new FixedValueGenerator();\n+    private static final Type FIXED_VALUE =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.FixedValue\");\n+    private static final Signature LOAD_OBJECT =\n+      TypeUtils.parseSignature(\"Object loadObject()\");\n+\n+    public void generate(ClassEmitter ce, Context context, List methods) {\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            CodeEmitter e = context.beginMethod(ce, method);\n+            context.emitCallback(e, context.getIndex(method));\n+            e.invoke_interface(FIXED_VALUE, LOAD_OBJECT);\n+            e.unbox_or_zero(e.getReturnType());\n+            e.return_value();\n+            e.end_method();\n+        }\n+    }\n+\n+    public void generateStatic(CodeEmitter e, Context context, List methods) { }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/InterfaceMaker.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * Generates new interfaces at runtime.\n+ * By passing a generated interface to the Enhancer's list of interfaces to\n+ * implement, you can make your enhanced classes handle an arbitrary set\n+ * of method signatures.\n+ * @author Chris Nokleberg\n+ * @version $Id: InterfaceMaker.java,v 1.4 2006/03/05 02:43:19 herbyderby Exp $\n+ */\n+public class InterfaceMaker extends AbstractClassGenerator\n+{\n+    private static final Source SOURCE = new Source(InterfaceMaker.class.getName());\n+    private Map signatures = new HashMap();\n+\n+    /**\n+     * Create a new <code>InterfaceMaker</code>. A new <code>InterfaceMaker</code>\n+     * object should be used for each generated interface, and should not\n+     * be shared across threads.\n+     */\n+    public InterfaceMaker() {\n+        super(SOURCE);\n+    }\n+\n+    /**\n+     * Add a method signature to the interface.\n+     * @param sig the method signature to add to the interface\n+     * @param exceptions an array of exception types to declare for the method\n+     */\n+    public void add(Signature sig, Type[] exceptions) {\n+        signatures.put(sig, exceptions);\n+    }\n+\n+    /**\n+     * Add a method signature to the interface. The method modifiers are ignored,\n+     * since interface methods are by definition abstract and public.\n+     * @param method the method to add to the interface\n+     */\n+    public void add(Method method) {\n+        add(ReflectUtils.getSignature(method),\n+            ReflectUtils.getExceptionTypes(method));\n+    }\n+\n+    /**\n+     * Add all the public methods in the specified class.\n+     * Methods from superclasses are included, except for methods declared in the base\n+     * Object class (e.g. <code>getClass</code>, <code>equals</code>, <code>hashCode</code>).\n+     * @param class the class containing the methods to add to the interface\n+     */\n+    public void add(Class clazz) {\n+        Method[] methods = clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            Method m = methods[i];\n+            if (!m.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\n+                add(m);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an interface using the current set of method signatures.\n+     */\n+    public Class create() {\n+        setUseCache(false);\n+        return (Class)super.create(this);\n+    }\n+\n+    protected ClassLoader getDefaultClassLoader() {\n+        return null;\n+    }\n+    \n+    protected Object firstInstance(Class type) {\n+        return type;\n+    }\n+\n+    protected Object nextInstance(Object instance) {\n+        throw new IllegalStateException(\"InterfaceMaker does not cache\");\n+    }\n+\n+    public void generateClass(ClassVisitor v) throws Exception {\n+        ClassEmitter ce = new ClassEmitter(v);\n+        ce.begin_class(Constants.V1_2,\n+                       Constants.ACC_PUBLIC | Constants.ACC_INTERFACE,\n+                       getClassName(),\n+                       null,\n+                       null,\n+                       Constants.SOURCE_FILE);\n+        for (Iterator it = signatures.keySet().iterator(); it.hasNext();) {\n+            Signature sig = (Signature)it.next();\n+            Type[] exceptions = (Type[])signatures.get(sig);\n+            ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_ABSTRACT,\n+                            sig,\n+                            exceptions).end_method();\n+        }\n+        ce.end_class();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/InvocationHandler.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * {@link java.lang.reflect.InvocationHandler} replacement (unavailable under JDK 1.2).\n+ * This callback type is primarily for use by the {@link Proxy} class but\n+ * may be used with {@link Enhancer} as well.\n+ * @author Neeme Praks <a href=\"mailto:neeme@apache.org\">neeme@apache.org</a>\n+ * @version $Id: InvocationHandler.java,v 1.3 2004/06/24 21:15:20 herbyderby Exp $\n+ */\n+public interface InvocationHandler\n+extends Callback\n+{\n+    /**\n+     * @see java.lang.reflect.InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object)\n+     */\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;\n+\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/InvocationHandlerGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class InvocationHandlerGenerator\n+implements CallbackGenerator\n+{\n+    public static final InvocationHandlerGenerator INSTANCE = new InvocationHandlerGenerator();\n+\n+    private static final Type INVOCATION_HANDLER =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.InvocationHandler\");\n+    private static final Type UNDECLARED_THROWABLE_EXCEPTION =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.UndeclaredThrowableException\");\n+    private static final Type METHOD =\n+      TypeUtils.parseType(\"java.lang.reflect.Method\");\n+    private static final Signature INVOKE =\n+      TypeUtils.parseSignature(\"Object invoke(Object, java.lang.reflect.Method, Object[])\");\n+\n+    public void generate(ClassEmitter ce, Context context, List methods) {\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            Signature impl = context.getImplSignature(method);\n+            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, impl.getName(), METHOD, null);\n+\n+            CodeEmitter e = context.beginMethod(ce, method);\n+            Block handler = e.begin_block();\n+            context.emitCallback(e, context.getIndex(method));\n+            e.load_this();\n+            e.getfield(impl.getName());\n+            e.create_arg_array();\n+            e.invoke_interface(INVOCATION_HANDLER, INVOKE);\n+            e.unbox(method.getSignature().getReturnType());\n+            e.return_value();\n+            handler.end();\n+            EmitUtils.wrap_undeclared_throwable(e, handler, method.getExceptionTypes(), UNDECLARED_THROWABLE_EXCEPTION);\n+            e.end_method();\n+        }\n+    }\n+\n+    public void generateStatic(CodeEmitter e, Context context, List methods) {\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            EmitUtils.load_method(e, method);\n+            e.putfield(context.getImplSignature(method).getName());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/LazyLoader.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * Lazy-loading {@link Enhancer} callback.\n+ */\n+public interface LazyLoader extends Callback {\n+    /**\n+     * Return the object which the original method invocation should be\n+     * dispatched. Called as soon as the first lazily-loaded method in\n+     * the enhanced instance is invoked. The same object is then used\n+     * for every future method call to the proxy instance.\n+     * @return an object that can invoke the method\n+     */\n+    Object loadObject() throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/LazyLoaderGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class LazyLoaderGenerator implements CallbackGenerator {\n+    public static final LazyLoaderGenerator INSTANCE = new LazyLoaderGenerator();\n+\n+    private static final Signature LOAD_OBJECT = \n+      TypeUtils.parseSignature(\"Object loadObject()\");\n+    private static final Type LAZY_LOADER =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.LazyLoader\");\n+\n+    public void generate(ClassEmitter ce, Context context, List methods) {\n+        Set indexes = new HashSet();\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            if (TypeUtils.isProtected(method.getModifiers())) {\n+                // ignore protected methods\n+            } else {\n+                int index = context.getIndex(method);\n+                indexes.add(new Integer(index));\n+                CodeEmitter e = context.beginMethod(ce, method);\n+                e.load_this();\n+                e.dup();\n+                e.invoke_virtual_this(loadMethod(index));\n+                e.checkcast(method.getClassInfo().getType());\n+                e.load_args();\n+                e.invoke(method);\n+                e.return_value();\n+                e.end_method();\n+            }\n+        }\n+\n+        for (Iterator it = indexes.iterator(); it.hasNext();) {\n+            int index = ((Integer)it.next()).intValue();\n+\n+            String delegate = \"CGLIB$LAZY_LOADER_\" + index;\n+            ce.declare_field(Constants.ACC_PRIVATE, delegate, Constants.TYPE_OBJECT, null);\n+\n+            CodeEmitter e = ce.begin_method(Constants.ACC_PRIVATE |\n+                                            Constants.ACC_SYNCHRONIZED |\n+                                            Constants.ACC_FINAL,\n+                                            loadMethod(index),\n+                                            null);\n+            e.load_this();\n+            e.getfield(delegate);\n+            e.dup();\n+            Label end = e.make_label();\n+            e.ifnonnull(end);\n+            e.pop();\n+            e.load_this();\n+            context.emitCallback(e, index);\n+            e.invoke_interface(LAZY_LOADER, LOAD_OBJECT);\n+            e.dup_x1();\n+            e.putfield(delegate);\n+            e.mark(end);\n+            e.return_value();\n+            e.end_method();\n+            \n+        }\n+    }\n+\n+    private Signature loadMethod(int index) {\n+        return new Signature(\"CGLIB$LOAD_PRIVATE_\" + index,\n+                             Constants.TYPE_OBJECT,\n+                             Constants.TYPES_EMPTY);\n+    }\n+\n+    public void generateStatic(CodeEmitter e, Context context, List methods) { }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/MethodInterceptor.java\n+/*\n+ * Copyright 2002,2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * General-purpose {@link Enhancer} callback which provides for \"around advice\".\n+ * @author Juozas Baliuka <a href=\"mailto:baliuka@mwm.lt\">baliuka@mwm.lt</a>\n+ * @version $Id: MethodInterceptor.java,v 1.8 2004/06/24 21:15:20 herbyderby Exp $\n+ */\n+public interface MethodInterceptor\n+extends Callback\n+{\n+    /**\n+     * All generated proxied methods call this method instead of the original method.\n+     * The original method may either be invoked by normal reflection using the Method object,\n+     * or by using the MethodProxy (faster).\n+     * @param obj \"this\", the enhanced object\n+     * @param method intercepted Method\n+     * @param args argument array; primitive types are wrapped\n+     * @param proxy used to invoke super (non-intercepted method); may be called\n+     * as many times as needed\n+     * @throws Throwable any exception may be thrown; if so, super method will not be invoked\n+     * @return any value compatible with the signature of the proxied method. Method returning void will ignore this value.\n+     * @see MethodProxy\n+     */    \n+    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,\n+                               MethodProxy proxy) throws Throwable;\n+\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/MethodInterceptorGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class MethodInterceptorGenerator\n+implements CallbackGenerator\n+{\n+    public static final MethodInterceptorGenerator INSTANCE = new MethodInterceptorGenerator();\n+\n+    static final String EMPTY_ARGS_NAME = \"CGLIB$emptyArgs\";\n+    static final String FIND_PROXY_NAME = \"CGLIB$findMethodProxy\";\n+    static final Class[] FIND_PROXY_TYPES = { Signature.class };\n+\n+    private static final Type ABSTRACT_METHOD_ERROR =\n+      TypeUtils.parseType(\"AbstractMethodError\");\n+    private static final Type METHOD =\n+      TypeUtils.parseType(\"java.lang.reflect.Method\");\n+    private static final Type REFLECT_UTILS =\n+      TypeUtils.parseType(\"org.mockito.cglib.core.ReflectUtils\");\n+    private static final Type METHOD_PROXY =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.MethodProxy\");\n+    private static final Type METHOD_INTERCEPTOR =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.MethodInterceptor\");\n+    private static final Signature GET_DECLARED_METHODS =\n+      TypeUtils.parseSignature(\"java.lang.reflect.Method[] getDeclaredMethods()\");\n+    private static final Signature GET_DECLARING_CLASS =\n+      TypeUtils.parseSignature(\"Class getDeclaringClass()\");\n+    private static final Signature FIND_METHODS =\n+      TypeUtils.parseSignature(\"java.lang.reflect.Method[] findMethods(String[], java.lang.reflect.Method[])\");\n+    private static final Signature MAKE_PROXY =\n+      new Signature(\"create\", METHOD_PROXY, new Type[]{\n+          Constants.TYPE_CLASS,\n+          Constants.TYPE_CLASS,\n+          Constants.TYPE_STRING,\n+          Constants.TYPE_STRING,\n+          Constants.TYPE_STRING\n+      });\n+    private static final Signature INTERCEPT =\n+      new Signature(\"intercept\", Constants.TYPE_OBJECT, new Type[]{\n+          Constants.TYPE_OBJECT,\n+          METHOD,\n+          Constants.TYPE_OBJECT_ARRAY,\n+          METHOD_PROXY\n+      });\n+    private static final Signature FIND_PROXY =\n+      new Signature(FIND_PROXY_NAME, METHOD_PROXY, new Type[]{ Constants.TYPE_SIGNATURE });\n+    private static final Signature TO_STRING =\n+      TypeUtils.parseSignature(\"String toString()\");\n+    private static final Transformer METHOD_TO_CLASS = new Transformer(){\n+        public Object transform(Object value) {\n+            return ((MethodInfo)value).getClassInfo();\n+        }\n+    };\n+    private static final Signature CSTRUCT_SIGNATURE =\n+        TypeUtils.parseConstructor(\"String, String\");\n+\n+    private String getMethodField(Signature impl) {\n+        return impl.getName() + \"$Method\";\n+    }\n+    private String getMethodProxyField(Signature impl) {\n+        return impl.getName() + \"$Proxy\";\n+    }\n+\n+    public void generate(ClassEmitter ce, Context context, List methods) {\n+        Map sigMap = new HashMap();\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            Signature sig = method.getSignature();\n+            Signature impl = context.getImplSignature(method);\n+\n+            String methodField = getMethodField(impl);\n+            String methodProxyField = getMethodProxyField(impl);\n+\n+            sigMap.put(sig.toString(), methodProxyField);\n+            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, methodField, METHOD, null);\n+            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, methodProxyField, METHOD_PROXY, null);\n+            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, EMPTY_ARGS_NAME, Constants.TYPE_OBJECT_ARRAY, null);\n+            CodeEmitter e;\n+\n+            // access method\n+            e = ce.begin_method(Constants.ACC_FINAL,\n+                                impl,\n+                                method.getExceptionTypes());\n+            superHelper(e, method);\n+            e.return_value();\n+            e.end_method();\n+\n+            // around method\n+            e = context.beginMethod(ce, method);\n+            Label nullInterceptor = e.make_label();\n+            context.emitCallback(e, context.getIndex(method));\n+            e.dup();\n+            e.ifnull(nullInterceptor);\n+\n+            e.load_this();\n+            e.getfield(methodField);\n+            \n+            if (sig.getArgumentTypes().length == 0) {\n+                e.getfield(EMPTY_ARGS_NAME);\n+            } else {\n+                e.create_arg_array();\n+            }\n+            \n+            e.getfield(methodProxyField);\n+            e.invoke_interface(METHOD_INTERCEPTOR, INTERCEPT);\n+            e.unbox_or_zero(sig.getReturnType());\n+            e.return_value();\n+\n+            e.mark(nullInterceptor);\n+            superHelper(e, method);\n+            e.return_value();\n+            e.end_method();\n+        }\n+        generateFindProxy(ce, sigMap);\n+    }\n+\n+    private static void superHelper(CodeEmitter e, MethodInfo method)\n+    {\n+        if (TypeUtils.isAbstract(method.getModifiers())) {\n+            e.throw_exception(ABSTRACT_METHOD_ERROR, method.toString() + \" is abstract\" );\n+        } else {\n+            e.load_this();\n+            e.load_args();\n+            e.super_invoke(method.getSignature());\n+        }\n+    }\n+\n+    public void generateStatic(CodeEmitter e, Context context, List methods) throws Exception {\n+        /* generates:\n+           static {\n+             Class thisClass = Class.forName(\"NameOfThisClass\");\n+             Class cls = Class.forName(\"java.lang.Object\");\n+             String[] sigs = new String[]{ \"toString\", \"()Ljava/lang/String;\", ... };\n+             Method[] methods = cls.getDeclaredMethods();\n+             methods = ReflectUtils.findMethods(sigs, methods);\n+             METHOD_0 = methods[0];\n+             CGLIB$ACCESS_0 = MethodProxy.create(cls, thisClass, \"()Ljava/lang/String;\", \"toString\", \"CGLIB$ACCESS_0\");\n+             ...\n+           }\n+        */\n+\n+        e.push(0);\n+        e.newarray();\n+        e.putfield(EMPTY_ARGS_NAME);\n+\n+        Local thisclass = e.make_local();\n+        Local declaringclass = e.make_local();\n+        EmitUtils.load_class_this(e);\n+        e.store_local(thisclass);\n+        \n+        Map methodsByClass = CollectionUtils.bucket(methods, METHOD_TO_CLASS);\n+        for (Iterator i = methodsByClass.keySet().iterator(); i.hasNext();) {\n+            ClassInfo classInfo = (ClassInfo)i.next();\n+\n+            List classMethods = (List)methodsByClass.get(classInfo);\n+            e.push(2 * classMethods.size());\n+            e.newarray(Constants.TYPE_STRING);\n+            for (int index = 0; index < classMethods.size(); index++) {\n+                MethodInfo method = (MethodInfo)classMethods.get(index);\n+                Signature sig = method.getSignature();\n+                e.dup();\n+                e.push(2 * index);\n+                e.push(sig.getName());\n+                e.aastore();\n+                e.dup();\n+                e.push(2 * index + 1);\n+                e.push(sig.getDescriptor());\n+                e.aastore();\n+            }\n+            \n+            EmitUtils.load_class(e, classInfo.getType());\n+            e.dup();\n+            e.store_local(declaringclass);\n+            e.invoke_virtual(Constants.TYPE_CLASS, GET_DECLARED_METHODS);\n+            e.invoke_static(REFLECT_UTILS, FIND_METHODS);\n+\n+            for (int index = 0; index < classMethods.size(); index++) {\n+                MethodInfo method = (MethodInfo)classMethods.get(index);\n+                Signature sig = method.getSignature();\n+                Signature impl = context.getImplSignature(method);\n+                e.dup();\n+                e.push(index);\n+                e.array_load(METHOD);\n+                e.putfield(getMethodField(impl));\n+\n+                e.load_local(declaringclass);\n+                e.load_local(thisclass);\n+                e.push(sig.getDescriptor());\n+                e.push(sig.getName());\n+                e.push(impl.getName());\n+                e.invoke_static(METHOD_PROXY, MAKE_PROXY);\n+                e.putfield(getMethodProxyField(impl));\n+            }\n+            e.pop();\n+        }\n+    }\n+\n+    public void generateFindProxy(ClassEmitter ce, final Map sigMap) {\n+        final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC | Constants.ACC_STATIC,\n+                                              FIND_PROXY,\n+                                              null);\n+        e.load_arg(0);\n+        e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n+        ObjectSwitchCallback callback = new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                e.getfield((String)sigMap.get(key));\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.aconst_null();\n+                e.return_value();\n+            }\n+        };\n+        EmitUtils.string_switch(e,\n+                                (String[])sigMap.keySet().toArray(new String[0]),\n+                                Constants.SWITCH_STYLE_HASH,\n+                                callback);\n+        e.end_method();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/MethodProxy.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.mockito.cglib.core.AbstractClassGenerator;\n+import org.mockito.cglib.core.CodeGenerationException;\n+import org.mockito.cglib.core.GeneratorStrategy;\n+import org.mockito.cglib.core.NamingPolicy;\n+import org.mockito.cglib.core.Signature;\n+import org.mockito.cglib.reflect.FastClass;\n+\n+\n+/**\n+ * Classes generated by {@link Enhancer} pass this object to the\n+ * registered {@link MethodInterceptor} objects when an intercepted method is invoked. It can\n+ * be used to either invoke the original method, or call the same method on a different\n+ * object of the same type.\n+ * @version $Id: MethodProxy.java,v 1.14 2008/05/26 04:05:50 herbyderby Exp $\n+ */\n+public class MethodProxy {\n+    private Signature sig1;\n+    private Signature sig2;\n+    private CreateInfo createInfo;\n+    \n+    private final Object initLock = new Object();\n+    private volatile FastClassInfo fastClassInfo;\n+    \n+    /**\n+     * For internal use by {@link Enhancer} only; see the {@link org.mockito.cglib.reflect.FastMethod} class\n+     * for similar functionality.\n+     */\n+    public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {\n+        MethodProxy proxy = new MethodProxy();\n+        proxy.sig1 = new Signature(name1, desc);\n+        proxy.sig2 = new Signature(name2, desc);\n+        proxy.createInfo = new CreateInfo(c1, c2);\n+        return proxy;\n+    }\n+\n+    private void init()\n+    {\n+        /* \n+         * Using a volatile invariant allows us to initialize the FastClass and\n+         * method index pairs atomically.\n+         * \n+         * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this \n+         * code could allow fastClassInfo to be instantiated more than once, which\n+         * appears to be benign.\n+         */\n+        if (fastClassInfo == null)\n+        {\n+            synchronized (initLock)\n+            {\n+                if (fastClassInfo == null)\n+                {\n+                    CreateInfo ci = createInfo;\n+\n+                    FastClassInfo fci = new FastClassInfo();\n+                    fci.f1 = helper(ci, ci.c1);\n+                    fci.f2 = helper(ci, ci.c2);\n+                    fci.i1 = fci.f1.getIndex(sig1);\n+                    fci.i2 = fci.f2.getIndex(sig2);\n+                    fastClassInfo = fci;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class FastClassInfo\n+    {\n+        FastClass f1;\n+        FastClass f2;\n+        int i1;\n+        int i2;\n+    }\n+\n+    private static class CreateInfo\n+    {\n+        Class c1;\n+        Class c2;\n+        NamingPolicy namingPolicy;\n+        GeneratorStrategy strategy;\n+        boolean attemptLoad;\n+        \n+        public CreateInfo(Class c1, Class c2)\n+        {\n+            this.c1 = c1;\n+            this.c2 = c2;\n+            AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();\n+            if (fromEnhancer != null) {\n+                namingPolicy = fromEnhancer.getNamingPolicy();\n+                strategy = fromEnhancer.getStrategy();\n+                attemptLoad = fromEnhancer.getAttemptLoad();\n+            }\n+        }\n+    }\n+\n+    private static FastClass helper(CreateInfo ci, Class type) {\n+        FastClass.Generator g = new FastClass.Generator();\n+        g.setType(type);\n+        g.setClassLoader(ci.c2.getClassLoader());\n+        g.setNamingPolicy(ci.namingPolicy);\n+        g.setStrategy(ci.strategy);\n+        g.setAttemptLoad(ci.attemptLoad);\n+        return g.create();\n+    }\n+\n+    private MethodProxy() {\n+    }\n+\n+    /**\n+     * Return the signature of the proxied method.\n+     */\n+    public Signature getSignature() {\n+        return sig1;\n+    }\n+\n+    /**\n+     * Return the name of the synthetic method created by CGLIB which is\n+     * used by {@link #invokeSuper} to invoke the superclass\n+     * (non-intercepted) method implementation. The parameter types are\n+     * the same as the proxied method.\n+     */\n+    public String getSuperName() {\n+        return sig2.getName();\n+    }\n+\n+    /**\n+     * Return the {@link org.mockito.cglib.reflect.FastClass} method index\n+     * for the method used by {@link #invokeSuper}. This index uniquely\n+     * identifies the method within the generated proxy, and therefore\n+     * can be useful to reference external metadata.\n+     * @see #getSuperName\n+     */\n+    public int getSuperIndex() {\n+        init();\n+        return fastClassInfo.i2;\n+    }\n+\n+    /**\n+     * Return the <code>MethodProxy</code> used when intercepting the method\n+     * matching the given signature.\n+     * @param type the class generated by Enhancer\n+     * @param sig the signature to match\n+     * @return the MethodProxy instance, or null if no applicable matching method is found\n+     * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor\n+     */\n+    public static MethodProxy find(Class type, Signature sig) {\n+        try {\n+            Method m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME,\n+                                              MethodInterceptorGenerator.FIND_PROXY_TYPES);\n+            return (MethodProxy)m.invoke(null, new Object[]{ sig });\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(\"Class \" + type + \" does not use a MethodInterceptor\");\n+        } catch (IllegalAccessException e) {\n+            throw new CodeGenerationException(e);\n+        } catch (InvocationTargetException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Invoke the original method, on a different object of the same type.\n+     * @param obj the compatible object; recursion will result if you use the object passed as the first\n+     * argument to the MethodInterceptor (usually not what you want)\n+     * @param args the arguments passed to the intercepted method; you may substitute a different\n+     * argument array as long as the types are compatible\n+     * @see MethodInterceptor#intercept\n+     * @throws Throwable the bare exceptions thrown by the called method are passed through\n+     * without wrapping in an <code>InvocationTargetException</code>\n+     */\n+    public Object invoke(Object obj, Object[] args) throws Throwable {\n+        try {\n+            init();\n+            FastClassInfo fci = fastClassInfo;\n+            return fci.f1.invoke(fci.i1, obj, args);\n+        } catch (InvocationTargetException e) {\n+            throw e.getTargetException();\n+        } catch (IllegalArgumentException e) {\n+            if (fastClassInfo.i1 < 0)\n+                throw new IllegalArgumentException(\"Protected method: \" + sig1);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * Invoke the original (super) method on the specified object.\n+     * @param obj the enhanced object, must be the object passed as the first\n+     * argument to the MethodInterceptor\n+     * @param args the arguments passed to the intercepted method; you may substitute a different\n+     * argument array as long as the types are compatible\n+     * @see MethodInterceptor#intercept\n+     * @throws Throwable the bare exceptions thrown by the called method are passed through\n+     * without wrapping in an <code>InvocationTargetException</code>\n+     */\n+    public Object invokeSuper(Object obj, Object[] args) throws Throwable {\n+        try {\n+            init();\n+            FastClassInfo fci = fastClassInfo;\n+            return fci.f2.invoke(fci.i2, obj, args);\n+        } catch (InvocationTargetException e) {\n+            throw e.getTargetException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Mixin.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.*;\n+\n+\n+\n+/**\n+ * <code>Mixin</code> allows\n+ * multiple objects to be combined into a single larger object. The\n+ * methods in the generated object simply call the original methods in the\n+ * underlying \"delegate\" objects.\n+ * @author Chris Nokleberg\n+ * @version $Id: Mixin.java,v 1.7 2005/09/27 11:42:27 baliuka Exp $\n+ */\n+abstract public class Mixin {\n+    private static final MixinKey KEY_FACTORY =\n+      (MixinKey)KeyFactory.create(MixinKey.class, KeyFactory.CLASS_BY_NAME);\n+    private static final Map ROUTE_CACHE = Collections.synchronizedMap(new HashMap());\n+\n+    public static final int STYLE_INTERFACES = 0;\n+    public static final int STYLE_BEANS = 1;\n+    public static final int STYLE_EVERYTHING = 2;\n+\n+    interface MixinKey {\n+        public Object newInstance(int style, String[] classes, int[] route);\n+    }\n+\n+    abstract public Mixin newInstance(Object[] delegates);\n+\n+    /**\n+     * Helper method to create an interface mixin. For finer control over the\n+     * generated instance, use a new instance of <code>Mixin</code>\n+     * instead of this static method.\n+     * TODO\n+     */\n+    public static Mixin create(Object[] delegates) {\n+        Generator gen = new Generator();\n+        gen.setDelegates(delegates);\n+        return gen.create();\n+    }\n+\n+    /**\n+     * Helper method to create an interface mixin. For finer control over the\n+     * generated instance, use a new instance of <code>Mixin</code>\n+     * instead of this static method.\n+     * TODO\n+     */\n+    public static Mixin create(Class[] interfaces, Object[] delegates) {\n+        Generator gen = new Generator();\n+        gen.setClasses(interfaces);\n+        gen.setDelegates(delegates);\n+        return gen.create();\n+    }\n+\n+    \n+    public static Mixin createBean(Object[] beans) {\n+    \n+        return createBean(null, beans);\n+    \n+    }\n+    /**\n+     * Helper method to create a bean mixin. For finer control over the\n+     * generated instance, use a new instance of <code>Mixin</code>\n+     * instead of this static method.\n+     * TODO\n+     */\n+    public static Mixin createBean(ClassLoader loader,Object[] beans) {\n+        Generator gen = new Generator();\n+        gen.setStyle(STYLE_BEANS);\n+        gen.setDelegates(beans);\n+        gen.setClassLoader(loader);\n+        return gen.create();\n+    }\n+    \n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(Mixin.class.getName());\n+\n+        private Class[] classes;\n+        private Object[] delegates;\n+        private int style = STYLE_INTERFACES;\n+        \n+        private int[] route;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return classes[0].getClassLoader(); // is this right?\n+        }\n+\n+        public void setStyle(int style) {\n+            switch (style) {\n+            case STYLE_INTERFACES:\n+            case STYLE_BEANS:\n+            case STYLE_EVERYTHING:\n+                this.style = style;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown mixin style: \" + style);\n+            }\n+        }\n+\n+        public void setClasses(Class[] classes) {\n+            this.classes = classes;\n+        }\n+\n+        public void setDelegates(Object[] delegates) {\n+            this.delegates = delegates;\n+        }\n+\n+        public Mixin create() {\n+            if (classes == null && delegates == null) {\n+                throw new IllegalStateException(\"Either classes or delegates must be set\");\n+            }\n+            switch (style) {\n+            case STYLE_INTERFACES:\n+                if (classes == null) {\n+                    Route r = route(delegates);\n+                    classes = r.classes;\n+                    route = r.route;\n+                }\n+                break;\n+            case STYLE_BEANS:\n+                // fall-through\n+            case STYLE_EVERYTHING:\n+                if (classes == null) {\n+                    classes = ReflectUtils.getClasses(delegates);\n+                } else {\n+                    if (delegates != null) {\n+                        Class[] temp = ReflectUtils.getClasses(delegates);\n+                        if (classes.length != temp.length) {\n+                            throw new IllegalStateException(\"Specified classes are incompatible with delegates\");\n+                        }\n+                        for (int i = 0; i < classes.length; i++) {\n+                            if (!classes[i].isAssignableFrom(temp[i])) {\n+                                throw new IllegalStateException(\"Specified class \" + classes[i] + \" is incompatible with delegate class \" + temp[i] + \" (index \" + i + \")\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            setNamePrefix(classes[ReflectUtils.findPackageProtected(classes)].getName());\n+            \n+            return (Mixin)super.create(KEY_FACTORY.newInstance(style, ReflectUtils.getNames( classes ), route));\n+        }\n+\n+        public void generateClass(ClassVisitor v) {\n+            switch (style) {\n+            case STYLE_INTERFACES:\n+                new MixinEmitter(v, getClassName(), classes, route);\n+                break;\n+            case STYLE_BEANS:\n+                new MixinBeanEmitter(v, getClassName(), classes);\n+                break;\n+            case STYLE_EVERYTHING:\n+                new MixinEverythingEmitter(v, getClassName(), classes);\n+                break;\n+            }\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ((Mixin)ReflectUtils.newInstance(type)).newInstance(delegates);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return ((Mixin)instance).newInstance(delegates);\n+        }\n+    }\n+\n+    public static Class[] getClasses(Object[] delegates) {\n+        return (Class[])route(delegates).classes.clone();\n+    }\n+\n+//     public static int[] getRoute(Object[] delegates) {\n+//         return (int[])route(delegates).route.clone();\n+//     }\n+        \n+    private static Route route(Object[] delegates) {\n+        Object key = ClassesKey.create(delegates);\n+        Route route = (Route)ROUTE_CACHE.get(key);\n+        if (route == null) {\n+            ROUTE_CACHE.put(key, route = new Route(delegates));\n+        }\n+        return route;\n+    }\n+\n+    private static class Route\n+    {\n+        private Class[] classes;\n+        private int[] route;\n+\n+        Route(Object[] delegates) {\n+            Map map = new HashMap();\n+            ArrayList collect = new ArrayList();\n+            for (int i = 0; i < delegates.length; i++) {\n+                Class delegate = delegates[i].getClass();\n+                collect.clear();\n+                ReflectUtils.addAllInterfaces(delegate, collect);\n+                for (Iterator it = collect.iterator(); it.hasNext();) {\n+                    Class iface = (Class)it.next();\n+                    if (!map.containsKey(iface)) {\n+                        map.put(iface, new Integer(i));\n+                    }\n+                }\n+            }\n+            classes = new Class[map.size()];\n+            route = new int[map.size()];\n+            int index = 0;\n+            for (Iterator it = map.keySet().iterator(); it.hasNext();) {\n+                Class key = (Class)it.next();\n+                classes[index] = key;\n+                route[index] = ((Integer)map.get(key)).intValue();\n+                index++;\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/MixinBeanEmitter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.ReflectUtils;\n+\n+/**\n+ * @author Chris Nokleberg\n+ * @version $Id: MixinBeanEmitter.java,v 1.2 2004/06/24 21:15:20 herbyderby Exp $\n+ */\n+class MixinBeanEmitter extends MixinEmitter {\n+    public MixinBeanEmitter(ClassVisitor v, String className, Class[] classes) {\n+        super(v, className, classes, null);\n+    }\n+\n+    protected Class[] getInterfaces(Class[] classes) {\n+        return null;\n+    }\n+\n+    protected Method[] getMethods(Class type) {\n+        return ReflectUtils.getPropertyMethods(ReflectUtils.getBeanProperties(type), true, true);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/MixinEmitter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * @author Chris Nokleberg\n+ * @version $Id: MixinEmitter.java,v 1.9 2006/08/27 21:04:37 herbyderby Exp $\n+ */\n+class MixinEmitter extends ClassEmitter {\n+    private static final String FIELD_NAME = \"CGLIB$DELEGATES\";\n+    private static final Signature CSTRUCT_OBJECT_ARRAY =\n+      TypeUtils.parseConstructor(\"Object[]\");\n+    private static final Type MIXIN =\n+      TypeUtils.parseType(\"org.mockito.cglib.proxy.Mixin\");\n+    private static final Signature NEW_INSTANCE =\n+      new Signature(\"newInstance\", MIXIN, new Type[]{ Constants.TYPE_OBJECT_ARRAY });\n+\n+    public MixinEmitter(ClassVisitor v, String className, Class[] classes, int[] route) {\n+        super(v);\n+\n+        begin_class(Constants.V1_2,\n+                    Constants.ACC_PUBLIC,\n+                    className,\n+                    MIXIN,\n+                    TypeUtils.getTypes(getInterfaces(classes)),\n+                    Constants.SOURCE_FILE);\n+        EmitUtils.null_constructor(this);\n+        EmitUtils.factory_method(this, NEW_INSTANCE);\n+\n+        declare_field(Constants.ACC_PRIVATE, FIELD_NAME, Constants.TYPE_OBJECT_ARRAY, null);\n+\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT_ARRAY, null);\n+        e.load_this();\n+        e.super_invoke_constructor();\n+        e.load_this();\n+        e.load_arg(0);\n+        e.putfield(FIELD_NAME);\n+        e.return_value();\n+        e.end_method();\n+\n+        Set unique = new HashSet();\n+        for (int i = 0; i < classes.length; i++) {\n+            Method[] methods = getMethods(classes[i]);\n+            for (int j = 0; j < methods.length; j++) {\n+                if (unique.add(MethodWrapper.create(methods[j]))) {\n+                    MethodInfo method = ReflectUtils.getMethodInfo(methods[j]);\n+                    e = EmitUtils.begin_method(this, method, Constants.ACC_PUBLIC);\n+                    e.load_this();\n+                    e.getfield(FIELD_NAME);\n+                    e.aaload((route != null) ? route[i] : i);\n+                    e.checkcast(method.getClassInfo().getType());\n+                    e.load_args();\n+                    e.invoke(method);\n+                    e.return_value();\n+                    e.end_method();\n+                }\n+            }\n+        }\n+\n+        end_class();\n+    }\n+\n+    protected Class[] getInterfaces(Class[] classes) {\n+        return classes;\n+    }\n+\n+    protected Method[] getMethods(Class type) {\n+        return type.getMethods();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/MixinEverythingEmitter.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.CollectionUtils;\n+import org.mockito.cglib.core.ReflectUtils;\n+import org.mockito.cglib.core.RejectModifierPredicate;\n+\n+/**\n+ * @author Chris Nokleberg\n+ * @version $Id: MixinEverythingEmitter.java,v 1.3 2004/06/24 21:15:19 herbyderby Exp $\n+ */\n+class MixinEverythingEmitter extends MixinEmitter {\n+\n+    public MixinEverythingEmitter(ClassVisitor v, String className, Class[] classes) {\n+        super(v, className, classes, null);\n+    }\n+\n+    protected Class[] getInterfaces(Class[] classes) {\n+        List list = new ArrayList();\n+        for (int i = 0; i < classes.length; i++) {\n+            ReflectUtils.addAllInterfaces(classes[i], list);\n+        }\n+        return (Class[])list.toArray(new Class[list.size()]);\n+    }\n+\n+    protected Method[] getMethods(Class type) {\n+        List methods = new ArrayList(Arrays.asList(type.getMethods()));\n+        CollectionUtils.filter(methods, new RejectModifierPredicate(Modifier.FINAL | Modifier.STATIC));\n+        return (Method[])methods.toArray(new Method[methods.size()]);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/NoOp.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * Methods using this {@link Enhancer} callback will delegate directly to the\n+ * default (super) implementation in the base class.\n+ */\n+public interface NoOp extends Callback\n+{\n+    /**\n+     * A thread-safe singleton instance of the <code>NoOp</code> callback.\n+     */\n+    public static final NoOp INSTANCE = new NoOp() { };\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/NoOpGenerator.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.mockito.cglib.core.*;\n+\n+class NoOpGenerator\n+implements CallbackGenerator\n+{\n+    public static final NoOpGenerator INSTANCE = new NoOpGenerator();\n+\n+    public void generate(ClassEmitter ce, Context context, List methods) {\n+        for (Iterator it = methods.iterator(); it.hasNext();) {\n+            MethodInfo method = (MethodInfo)it.next();\n+            if (TypeUtils.isProtected(context.getOriginalModifiers(method)) &&\n+                TypeUtils.isPublic(method.getModifiers())) {\n+                CodeEmitter e = EmitUtils.begin_method(ce, method);\n+                e.load_this();\n+                e.load_args();\n+                e.super_invoke();\n+                e.return_value();\n+                e.end_method();\n+            }\n+        }\n+    }\n+    \n+    public void generateStatic(CodeEmitter e, Context context, List methods) { }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/Proxy.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Member;\n+\n+import org.mockito.cglib.core.CodeGenerationException;\n+\n+/**\n+ * This class is meant to be used as replacement for\n+ * <code>java.lang.reflect.Proxy</code> under JDK 1.2. There are some known\n+ * subtle differences:\n+ * <ul>\n+ * <li>The exceptions returned by invoking <code>getExceptionTypes</code>\n+ * on the <code>Method</code> passed to the <code>invoke</code> method\n+ * <b>are</b> the exact set that can be thrown without resulting in an\n+ * <code>UndeclaredThrowableException</code> being thrown.\n+ * <li>{@link UndeclaredThrowableException} is used instead\n+ * of <code>java.lang.reflect.UndeclaredThrowableException</code>.\n+ * </ul>\n+ * <p>\n+ * @version $Id: Proxy.java,v 1.6 2004/06/24 21:15:19 herbyderby Exp $\n+ */\n+public class Proxy implements Serializable {\n+    protected InvocationHandler h;\n+\n+    private static final CallbackFilter BAD_OBJECT_METHOD_FILTER = new CallbackFilter() {\n+        public int accept(Method method) {\n+            if (method.getDeclaringClass().getName().equals(\"java.lang.Object\")) {\n+                String name = method.getName();\n+                if (!(name.equals(\"hashCode\") ||\n+                      name.equals(\"equals\") ||\n+                      name.equals(\"toString\"))) {\n+                    return 1;\n+                }\n+            }\n+            return 0;\n+        }\n+    };\n+\n+    protected Proxy(InvocationHandler h) {\n+        Enhancer.registerCallbacks(getClass(), new Callback[]{ h, null });\n+        this.h = h;\n+    }\n+\n+    // private for security of isProxyClass\n+    private static class ProxyImpl extends Proxy {\n+        protected ProxyImpl(InvocationHandler h) {\n+            super(h);\n+        }\n+    }\n+\n+    public static InvocationHandler getInvocationHandler(Object proxy) {\n+        if (!(proxy instanceof ProxyImpl)) {\n+            throw new IllegalArgumentException(\"Object is not a proxy\");\n+        }\n+        return ((Proxy)proxy).h;\n+    }\n+\n+    public static Class getProxyClass(ClassLoader loader, Class[] interfaces) {\n+        Enhancer e = new Enhancer();\n+        e.setSuperclass(ProxyImpl.class);\n+        e.setInterfaces(interfaces);\n+        e.setCallbackTypes(new Class[]{\n+            InvocationHandler.class,\n+            NoOp.class,\n+        });\n+        e.setCallbackFilter(BAD_OBJECT_METHOD_FILTER);\n+        e.setUseFactory(false);\n+        return e.createClass();\n+    }\n+\n+    public static boolean isProxyClass(Class cl) {\n+        return cl.getSuperclass().equals(ProxyImpl.class);\n+    }\n+\n+    public static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) {\n+        try {\n+            Class clazz = getProxyClass(loader, interfaces);\n+            return clazz.getConstructor(new Class[]{ InvocationHandler.class }).newInstance(new Object[]{ h });\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/ProxyRefDispatcher.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.proxy;\n+\n+/**\n+ * Dispatching {@link Enhancer} callback. This is the same as the\n+ * {@link Dispatcher} except for the addition of an argument\n+ * which references the proxy object.\n+ */\n+public interface ProxyRefDispatcher extends Callback {\n+    /**\n+     * Return the object which the original method invocation should\n+     * be dispatched. This method is called for <b>every</b> method invocation.\n+     * @param proxy a reference to the proxy (generated) object\n+     * @return an object that can invoke the method\n+     */\n+    Object loadObject(Object proxy) throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/proxy/UndeclaredThrowableException.java\n+/*\n+ * Copyright 2002,2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.mockito.cglib.proxy;\n+\n+import org.mockito.cglib.core.CodeGenerationException;\n+\n+/**\n+ * Used by {@link Proxy} as a replacement for <code>java.lang.reflect.UndeclaredThrowableException</code>.\n+ * @author Juozas Baliuka\n+ */\n+public class UndeclaredThrowableException extends CodeGenerationException {\n+    /**\n+     * Creates a new instance of <code>UndeclaredThrowableException</code> without detail message.\n+     */\n+    public UndeclaredThrowableException(Throwable t) {\n+        super(t);\n+    }\n+    \n+    public Throwable getUndeclaredThrowable() {\n+        return getCause();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/ConstructorDelegate.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * @author Chris Nokleberg\n+ * @version $Id: ConstructorDelegate.java,v 1.20 2006/03/05 02:43:19 herbyderby Exp $\n+ */\n+abstract public class ConstructorDelegate {\n+    private static final ConstructorKey KEY_FACTORY =\n+      (ConstructorKey)KeyFactory.create(ConstructorKey.class, KeyFactory.CLASS_BY_NAME);\n+    \n+    interface ConstructorKey {\n+        public Object newInstance(String declaring, String iface);\n+    }\n+\n+    protected ConstructorDelegate() {\n+    }\n+\n+    public static ConstructorDelegate create(Class targetClass, Class iface) {\n+        Generator gen = new Generator();\n+        gen.setTargetClass(targetClass);\n+        gen.setInterface(iface);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(ConstructorDelegate.class.getName());\n+        private static final Type CONSTRUCTOR_DELEGATE =\n+          TypeUtils.parseType(\"org.mockito.cglib.reflect.ConstructorDelegate\");\n+\n+        private Class iface;\n+        private Class targetClass;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        public void setInterface(Class iface) {\n+            this.iface = iface;\n+        }\n+\n+        public void setTargetClass(Class targetClass) {\n+            this.targetClass = targetClass;\n+        }\n+\n+        public ConstructorDelegate create() {\n+            setNamePrefix(targetClass.getName());\n+            Object key = KEY_FACTORY.newInstance(iface.getName(), targetClass.getName());\n+            return (ConstructorDelegate)super.create(key);\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return targetClass.getClassLoader();\n+        }\n+\n+        public void generateClass(ClassVisitor v) {\n+            setNamePrefix(targetClass.getName());\n+\n+            final Method newInstance = ReflectUtils.findNewInstance(iface);\n+            if (!newInstance.getReturnType().isAssignableFrom(targetClass)) {\n+                throw new IllegalArgumentException(\"incompatible return type\");\n+            }\n+            final Constructor constructor;\n+            try {\n+                constructor = targetClass.getDeclaredConstructor(newInstance.getParameterTypes());\n+            } catch (NoSuchMethodException e) {\n+                throw new IllegalArgumentException(\"interface does not match any known constructor\");\n+            }\n+\n+            ClassEmitter ce = new ClassEmitter(v);\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           CONSTRUCTOR_DELEGATE,\n+                           new Type[]{ Type.getType(iface) },\n+                           Constants.SOURCE_FILE);\n+            Type declaring = Type.getType(constructor.getDeclaringClass());\n+            EmitUtils.null_constructor(ce);\n+            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC,\n+                                            ReflectUtils.getSignature(newInstance),\n+                                            ReflectUtils.getExceptionTypes(newInstance));\n+            e.new_instance(declaring);\n+            e.dup();\n+            e.load_args();\n+            e.invoke_constructor(declaring, ReflectUtils.getSignature(constructor));\n+            e.return_value();\n+            e.end_method();\n+            ce.end_class();\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ReflectUtils.newInstance(type);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return instance;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/FastClass.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+abstract public class FastClass\n+{\n+    private Class type;\n+\n+    protected FastClass() {\n+        throw new Error(\"Using the FastClass empty constructor--please report to the cglib-devel mailing list\");\n+    }\n+\n+    protected FastClass(Class type) {\n+        this.type = type;\n+    }\n+\n+    public static FastClass create(Class type) {\n+    \n+        return create(type.getClassLoader(),type);\n+        \n+    }\n+    public static FastClass create(ClassLoader loader, Class type) {\n+        Generator gen = new Generator();\n+        gen.setType(type);\n+        gen.setClassLoader(loader);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator\n+    {\n+        private static final Source SOURCE = new Source(FastClass.class.getName());\n+        private Class type;\n+        \n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        public void setType(Class type) {\n+            this.type = type;\n+        }\n+        \n+        public FastClass create() {\n+            setNamePrefix(type.getName());\n+            return (FastClass)super.create(type.getName());\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return type.getClassLoader();\n+        }\n+\n+        public void generateClass(ClassVisitor v) throws Exception {\n+            new FastClassEmitter(v, getClassName(), type);\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ReflectUtils.newInstance(type,\n+                                            new Class[]{ Class.class },\n+                                            new Object[]{ this.type });\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return instance;\n+        }\n+    }\n+    \n+    public Object invoke(String name, Class[] parameterTypes, Object obj, Object[] args) throws InvocationTargetException {\n+        return invoke(getIndex(name, parameterTypes), obj, args);\n+    }\n+\n+    public Object newInstance() throws InvocationTargetException {\n+        return newInstance(getIndex(Constants.EMPTY_CLASS_ARRAY), null);\n+    }\n+\n+    public Object newInstance(Class[] parameterTypes, Object[] args) throws InvocationTargetException {\n+        return newInstance(getIndex(parameterTypes), args);\n+    }\n+    \n+    public FastMethod getMethod(Method method) {\n+        return new FastMethod(this, method);\n+    }\n+\n+    public FastConstructor getConstructor(Constructor constructor) {\n+        return new FastConstructor(this, constructor);\n+    }\n+\n+    public FastMethod getMethod(String name, Class[] parameterTypes) {\n+        try {\n+            return getMethod(type.getMethod(name, parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            throw new NoSuchMethodError(e.getMessage());\n+        }\n+    }\n+\n+    public FastConstructor getConstructor(Class[] parameterTypes) {\n+        try {\n+            return getConstructor(type.getConstructor(parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            throw new NoSuchMethodError(e.getMessage());\n+        }\n+    }\n+\n+    public String getName() {\n+        return type.getName();\n+    }\n+\n+    public Class getJavaClass() {\n+        return type;\n+    }\n+\n+    public String toString() {\n+        return type.toString();\n+    }\n+\n+    public int hashCode() {\n+        return type.hashCode();\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !(o instanceof FastClass)) {\n+            return false;\n+        }\n+        return type.equals(((FastClass)o).type);\n+    }\n+\n+    /**\n+     * Return the index of the matching method. The index may be used\n+     * later to invoke the method with less overhead. If more than one\n+     * method matches (i.e. they differ by return type only), one is\n+     * chosen arbitrarily.\n+     * @see #invoke(int, Object, Object[])\n+     * @param name the method name\n+     * @param parameterTypes the parameter array\n+     * @return the index, or <code>-1</code> if none is found.\n+     */\n+    abstract public int getIndex(String name, Class[] parameterTypes);\n+\n+    /**\n+     * Return the index of the matching constructor. The index may be used\n+     * later to create a new instance with less overhead.\n+     * @see #newInstance(int, Object[])\n+     * @param parameterTypes the parameter array\n+     * @return the constructor index, or <code>-1</code> if none is found.\n+     */\n+    abstract public int getIndex(Class[] parameterTypes);\n+\n+    /**\n+     * Invoke the method with the specified index.\n+     * @see getIndex(name, Class[])\n+     * @param index the method index\n+     * @param obj the object the underlying method is invoked from\n+     * @param args the arguments used for the method call\n+     * @throws java.lang.reflect.InvocationTargetException if the underlying method throws an exception\n+     */\n+    abstract public Object invoke(int index, Object obj, Object[] args) throws InvocationTargetException;\n+\n+    /**\n+     * Create a new instance using the specified constructor index and arguments.\n+     * @see getIndex(Class[])\n+     * @param index the constructor index\n+     * @param args the arguments passed to the constructor\n+     * @throws java.lang.reflect.InvocationTargetException if the constructor throws an exception\n+     */\n+    abstract public Object newInstance(int index, Object[] args) throws InvocationTargetException;\n+\n+    abstract public int getIndex(Signature sig);\n+\n+    /**\n+     * Returns the maximum method index for this class.\n+     */\n+    abstract public int getMaxIndex();\n+\n+    protected static String getSignatureWithoutReturnType(String name, Class[] parameterTypes) {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(name);\n+        sb.append('(');\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            sb.append(Type.getDescriptor(parameterTypes[i]));\n+        }\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/FastClassEmitter.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+    \n+class FastClassEmitter extends ClassEmitter {\n+    private static final Signature CSTRUCT_CLASS =\n+      TypeUtils.parseConstructor(\"Class\");\n+    private static final Signature METHOD_GET_INDEX =\n+      TypeUtils.parseSignature(\"int getIndex(String, Class[])\");\n+    private static final Signature SIGNATURE_GET_INDEX =\n+      new Signature(\"getIndex\", Type.INT_TYPE, new Type[]{ Constants.TYPE_SIGNATURE });\n+    private static final Signature TO_STRING =\n+      TypeUtils.parseSignature(\"String toString()\");\n+    private static final Signature CONSTRUCTOR_GET_INDEX =\n+      TypeUtils.parseSignature(\"int getIndex(Class[])\");\n+    private static final Signature INVOKE =\n+      TypeUtils.parseSignature(\"Object invoke(int, Object, Object[])\");\n+    private static final Signature NEW_INSTANCE =\n+      TypeUtils.parseSignature(\"Object newInstance(int, Object[])\");\n+    private static final Signature GET_MAX_INDEX =\n+      TypeUtils.parseSignature(\"int getMaxIndex()\");\n+    private static final Signature GET_SIGNATURE_WITHOUT_RETURN_TYPE =\n+      TypeUtils.parseSignature(\"String getSignatureWithoutReturnType(String, Class[])\");\n+    private static final Type FAST_CLASS =\n+      TypeUtils.parseType(\"org.mockito.cglib.reflect.FastClass\");\n+    private static final Type ILLEGAL_ARGUMENT_EXCEPTION =\n+      TypeUtils.parseType(\"IllegalArgumentException\");\n+    private static final Type INVOCATION_TARGET_EXCEPTION =\n+      TypeUtils.parseType(\"java.lang.reflect.InvocationTargetException\");\n+    private static final Type[] INVOCATION_TARGET_EXCEPTION_ARRAY = { INVOCATION_TARGET_EXCEPTION };\n+    \n+    public FastClassEmitter(ClassVisitor v, String className, Class type) {\n+        super(v);\n+\n+        Type base = Type.getType(type);\n+        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, FAST_CLASS, null, Constants.SOURCE_FILE);\n+\n+        // constructor\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_CLASS, null);\n+        e.load_this();\n+        e.load_args();\n+        e.super_invoke_constructor(CSTRUCT_CLASS);\n+        e.return_value();\n+        e.end_method();\n+\n+        VisibilityPredicate vp = new VisibilityPredicate(type, false);\n+        List methods = ReflectUtils.addAllMethods(type, new ArrayList());\n+        CollectionUtils.filter(methods, vp);\n+        CollectionUtils.filter(methods, new DuplicatesPredicate());\n+        List constructors = new ArrayList(Arrays.asList(type.getDeclaredConstructors()));\n+        CollectionUtils.filter(constructors, vp);\n+        \n+        // getIndex(String)\n+        emitIndexBySignature(methods);\n+\n+        // getIndex(String, Class[])\n+        emitIndexByClassArray(methods);\n+        \n+        // getIndex(Class[])\n+        e = begin_method(Constants.ACC_PUBLIC, CONSTRUCTOR_GET_INDEX, null);\n+        e.load_args();\n+        List info = CollectionUtils.transform(constructors, MethodInfoTransformer.getInstance());\n+        EmitUtils.constructor_switch(e, info, new GetIndexCallback(e, info));\n+        e.end_method();\n+\n+        // invoke(int, Object, Object[])\n+        e = begin_method(Constants.ACC_PUBLIC, INVOKE, INVOCATION_TARGET_EXCEPTION_ARRAY);\n+        e.load_arg(1);\n+        e.checkcast(base);\n+        e.load_arg(0);\n+        invokeSwitchHelper(e, methods, 2, base);\n+        e.end_method();\n+\n+        // newInstance(int, Object[])\n+        e = begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, INVOCATION_TARGET_EXCEPTION_ARRAY);\n+        e.new_instance(base);\n+        e.dup();\n+        e.load_arg(0);\n+        invokeSwitchHelper(e, constructors, 1, base);\n+        e.end_method();\n+\n+        // getMaxIndex()\n+        e = begin_method(Constants.ACC_PUBLIC, GET_MAX_INDEX, null);\n+        e.push(methods.size() - 1);\n+        e.return_value();\n+        e.end_method();\n+\n+        end_class();\n+    }\n+\n+    // TODO: support constructor indices (\"<init>\")\n+    private void emitIndexBySignature(List methods) {\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SIGNATURE_GET_INDEX, null);\n+        List signatures = CollectionUtils.transform(methods, new Transformer() {\n+            public Object transform(Object obj) {\n+                return ReflectUtils.getSignature((Method)obj).toString();\n+            }\n+        });\n+        e.load_arg(0);\n+        e.invoke_virtual(Constants.TYPE_OBJECT, TO_STRING);\n+        signatureSwitchHelper(e, signatures);\n+        e.end_method();\n+    }\n+\n+    private static final int TOO_MANY_METHODS = 100; // TODO\n+    private void emitIndexByClassArray(List methods) {\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, METHOD_GET_INDEX, null);\n+        if (methods.size() > TOO_MANY_METHODS) {\n+            // hack for big classes\n+            List signatures = CollectionUtils.transform(methods, new Transformer() {\n+                public Object transform(Object obj) {\n+                    String s = ReflectUtils.getSignature((Method)obj).toString();\n+                    return s.substring(0, s.lastIndexOf(')') + 1);\n+                }\n+            });\n+            e.load_args();\n+            e.invoke_static(FAST_CLASS, GET_SIGNATURE_WITHOUT_RETURN_TYPE);\n+            signatureSwitchHelper(e, signatures);\n+        } else {\n+            e.load_args();\n+            List info = CollectionUtils.transform(methods, MethodInfoTransformer.getInstance());\n+            EmitUtils.method_switch(e, info, new GetIndexCallback(e, info));\n+        }\n+        e.end_method();\n+    }\n+\n+    private void signatureSwitchHelper(final CodeEmitter e, final List signatures) {\n+        ObjectSwitchCallback callback = new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                // TODO: remove linear indexOf\n+                e.push(signatures.indexOf(key));\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.push(-1);\n+                e.return_value();\n+            }\n+        };\n+        EmitUtils.string_switch(e,\n+                                (String[])signatures.toArray(new String[signatures.size()]),\n+                                Constants.SWITCH_STYLE_HASH,\n+                                callback);\n+    }\n+\n+    private static void invokeSwitchHelper(final CodeEmitter e, List members, final int arg, final Type base) {\n+        final List info = CollectionUtils.transform(members, MethodInfoTransformer.getInstance());        \n+        final Label illegalArg = e.make_label();\n+        Block block = e.begin_block();\n+        e.process_switch(getIntRange(info.size()), new ProcessSwitchCallback() {\n+            public void processCase(int key, Label end) {\n+                MethodInfo method = (MethodInfo)info.get(key);\n+                Type[] types = method.getSignature().getArgumentTypes();\n+                for (int i = 0; i < types.length; i++) {\n+                    e.load_arg(arg);\n+                    e.aaload(i);\n+                    e.unbox(types[i]);\n+                }\n+                // TODO: change method lookup process so MethodInfo will already reference base\n+                // instead of superclass when superclass method is inaccessible\n+                e.invoke(method, base);\n+                if (!TypeUtils.isConstructor(method)) {\n+                    e.box(method.getSignature().getReturnType());\n+                }\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.goTo(illegalArg);\n+            }\n+        });\n+        block.end();\n+        EmitUtils.wrap_throwable(block, INVOCATION_TARGET_EXCEPTION);\n+        e.mark(illegalArg);\n+        e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Cannot find matching method/constructor\");\n+    }\n+\n+    private static class GetIndexCallback implements ObjectSwitchCallback {\n+        private CodeEmitter e;\n+        private Map indexes = new HashMap();\n+\n+        public GetIndexCallback(CodeEmitter e, List methods) {\n+            this.e = e;\n+            int index = 0;\n+            for (Iterator it = methods.iterator(); it.hasNext();) {\n+                indexes.put(it.next(), new Integer(index++));\n+            }\n+        }\n+            \n+        public void processCase(Object key, Label end) {\n+            e.push(((Integer)indexes.get(key)).intValue());\n+            e.return_value();\n+        }\n+        \n+        public void processDefault() {\n+            e.push(-1);\n+            e.return_value();\n+        }\n+    }\n+    \n+    private static int[] getIntRange(int length) {\n+        int[] range = new int[length];\n+        for (int i = 0; i < length; i++) {\n+            range[i] = i;\n+        }\n+        return range;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/FastConstructor.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class FastConstructor extends FastMember\n+{\n+    FastConstructor(FastClass fc, Constructor constructor) {\n+        super(fc, constructor, fc.getIndex(constructor.getParameterTypes()));\n+    }\n+\n+    public Class[] getParameterTypes() {\n+        return ((Constructor)member).getParameterTypes();\n+    }\n+\n+    public Class[] getExceptionTypes() {\n+        return ((Constructor)member).getExceptionTypes();\n+    }\n+\n+    public Object newInstance() throws InvocationTargetException {\n+        return fc.newInstance(index, null);\n+    }\n+\n+    public Object newInstance(Object[] args) throws InvocationTargetException {\n+        return fc.newInstance(index, args);\n+    }\n+\n+    public Constructor getJavaConstructor() {\n+        return (Constructor)member;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/FastMember.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.Member;\n+\n+abstract public class FastMember\n+{\n+    protected FastClass fc;\n+    protected Member member;\n+    protected int index;\n+\n+    protected FastMember(FastClass fc, Member member, int index) {\n+        this.fc = fc;\n+        this.member = member;\n+        this.index = index;\n+    }\n+\n+    abstract public Class[] getParameterTypes();\n+    abstract public Class[] getExceptionTypes();\n+\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    public String getName() {\n+        return member.getName();\n+    }\n+\n+    public Class getDeclaringClass() {\n+        return fc.getJavaClass();\n+    }\n+\n+    public int getModifiers() {\n+        return member.getModifiers();\n+    }\n+\n+    public String toString() {\n+        return member.toString();\n+    }\n+\n+    public int hashCode() {\n+        return member.hashCode();\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !(o instanceof FastMember)) {\n+            return false;\n+        }\n+        return member.equals(((FastMember)o).member);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/FastMethod.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class FastMethod extends FastMember\n+{\n+    FastMethod(FastClass fc, Method method) {\n+        super(fc, method, helper(fc, method));\n+    }\n+\n+    private static int helper(FastClass fc, Method method) {\n+        int index = fc.getIndex(method.getName(), method.getParameterTypes());\n+        if (index < 0) {\n+            Class[] types = method.getParameterTypes();\n+            System.err.println(\"hash=\" + method.getName().hashCode() + \" size=\" + types.length);\n+            for (int i = 0; i < types.length; i++) {\n+                System.err.println(\"  types[\" + i + \"]=\" + types[i].getName());\n+            }\n+            throw new IllegalArgumentException(\"Cannot find method \" + method);\n+        }\n+        return index;\n+    }\n+\n+    public Class getReturnType() {\n+        return ((Method)member).getReturnType();\n+    }\n+\n+    public Class[] getParameterTypes() {\n+        return ((Method)member).getParameterTypes();\n+    }\n+\n+    public Class[] getExceptionTypes() {\n+        return ((Method)member).getExceptionTypes();\n+    }\n+\n+    public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+        return fc.invoke(index, obj, args);\n+    }\n+\n+    public Method getJavaMethod() {\n+        return (Method)member;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/MethodDelegate.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.*;\n+import org.mockito.cglib.core.*;\n+\n+// TODO: don't require exact match for return type\n+\n+/**\n+ * <b>DOCUMENTATION FROM APACHE AVALON DELEGATE CLASS</b>\n+ *\n+ * <p>\n+ * Delegates are a typesafe pointer to another method.  Since Java does not\n+ * have language support for such a construct, this utility will construct\n+ * a proxy that forwards method calls to any method with the same signature.\n+ * This utility is inspired in part by the C# delegate mechanism.  We\n+ * implemented it in a Java-centric manner.\n+ * </p>\n+ *\n+ * <h2>Delegate</h2>\n+ * <p>\n+ *   Any interface with one method can become the interface for a delegate.\n+ *   Consider the example below:\n+ * </p>\n+ *\n+ * <pre>\n+ *   public interface MainDelegate {\n+ *       int main(String[] args);\n+ *   }\n+ * </pre>\n+ *\n+ * <p>\n+ *   The interface above is an example of an interface that can become a\n+ *   delegate.  It has only one method, and the interface is public.  In\n+ *   order to create a delegate for that method, all we have to do is\n+ *   call <code>MethodDelegate.create(this, \"alternateMain\", MainDelegate.class)</code>.\n+ *   The following program will show how to use it:\n+ * </p>\n+ *\n+ * <pre>\n+ *   public class Main {\n+ *       public static int main( String[] args ) {\n+ *           Main newMain = new Main();\n+ *           MainDelegate start = (MainDelegate)\n+ *               MethodDelegate.create(newMain, \"alternateMain\", MainDelegate.class);\n+ *           return start.main( args );\n+ *       }\n+ *\n+ *       public int alternateMain( String[] args ) {\n+ *           for (int i = 0; i < args.length; i++) {\n+ *               System.out.println( args[i] );\n+ *           }\n+ *           return args.length;\n+ *       }\n+ *   }\n+ * </pre>\n+ *\n+ * <p>\n+ *   By themselves, delegates don't do much.  Their true power lies in the fact that\n+ *   they can be treated like objects, and passed to other methods.  In fact that is\n+ *   one of the key building blocks of building Intelligent Agents which in tern are\n+ *   the foundation of artificial intelligence.  In the above program, we could have\n+ *   easily created the delegate to match the static <code>main</code> method by\n+ *   substituting the delegate creation call with this:\n+ *   <code>MethodDelegate.createStatic(getClass(), \"main\", MainDelegate.class)</code>.\n+ * </p>\n+ * <p>\n+ *   Another key use for Delegates is to register event listeners.  It is much easier\n+ *   to have all the code for your events separated out into methods instead of individual\n+ *   classes.  One of the ways Java gets around that is to create anonymous classes.\n+ *   They are particularly troublesome because many Debuggers do not know what to do\n+ *   with them.  Anonymous classes tend to duplicate alot of code as well.  We can\n+ *   use any interface with one declared method to forward events to any method that\n+ *   matches the signature (although the method name can be different).\n+ * </p>\n+ *\n+ * <h3>Equality</h3>\n+ *  The criteria that we use to test if two delegates are equal are:\n+ *   <ul>\n+ *     <li>\n+ *       They both refer to the same instance.  That is, the <code>instance</code>\n+ *       parameter passed to the newDelegate method was the same for both. The\n+ *       instances are compared with the identity equality operator, <code>==</code>.\n+ *     </li>\n+ *     <li>They refer to the same method as resolved by <code>Method.equals</code>.</li>\n+ *   </ul>\n+ *\n+ * @version $Id: MethodDelegate.java,v 1.25 2006/03/05 02:43:19 herbyderby Exp $\n+ */\n+abstract public class MethodDelegate {\n+    private static final MethodDelegateKey KEY_FACTORY =\n+      (MethodDelegateKey)KeyFactory.create(MethodDelegateKey.class, KeyFactory.CLASS_BY_NAME);\n+\n+    protected Object target;\n+    protected String eqMethod;\n+\n+    interface MethodDelegateKey {\n+        Object newInstance(Class delegateClass, String methodName, Class iface);\n+    }\n+\n+    public static MethodDelegate createStatic(Class targetClass, String methodName, Class iface) {\n+        Generator gen = new Generator();\n+        gen.setTargetClass(targetClass);\n+        gen.setMethodName(methodName);\n+        gen.setInterface(iface);\n+        return gen.create();\n+    }\n+\n+    public static MethodDelegate create(Object target, String methodName, Class iface) {\n+        Generator gen = new Generator();\n+        gen.setTarget(target);\n+        gen.setMethodName(methodName);\n+        gen.setInterface(iface);\n+        return gen.create();\n+    }\n+\n+    public boolean equals(Object obj) {\n+        MethodDelegate other = (MethodDelegate)obj;\n+        return target == other.target && eqMethod.equals(other.eqMethod);\n+    }\n+\n+    public int hashCode() {\n+        return target.hashCode() ^ eqMethod.hashCode();\n+    }\n+\n+    public Object getTarget() {\n+        return target;\n+    }\n+\n+    abstract public MethodDelegate newInstance(Object target);\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(MethodDelegate.class.getName());\n+        private static final Type METHOD_DELEGATE =\n+          TypeUtils.parseType(\"org.mockito.cglib.reflect.MethodDelegate\");\n+        private static final Signature NEW_INSTANCE =\n+          new Signature(\"newInstance\", METHOD_DELEGATE, new Type[]{ Constants.TYPE_OBJECT });\n+        \n+        private Object target;\n+        private Class targetClass;\n+        private String methodName;\n+        private Class iface;\n+        \n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        public void setTarget(Object target) {\n+            this.target = target;\n+            this.targetClass = target.getClass();\n+        }\n+\n+        public void setTargetClass(Class targetClass) {\n+            this.targetClass = targetClass;\n+        }\n+\n+        public void setMethodName(String methodName) {\n+            this.methodName = methodName;\n+        }\n+\n+        public void setInterface(Class iface) {\n+            this.iface = iface;\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return targetClass.getClassLoader();\n+        }\n+\n+        public MethodDelegate create() {\n+            setNamePrefix(targetClass.getName());\n+            Object key = KEY_FACTORY.newInstance(targetClass, methodName, iface);\n+            return (MethodDelegate)super.create(key);\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return ((MethodDelegate)ReflectUtils.newInstance(type)).newInstance(target);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return ((MethodDelegate)instance).newInstance(target);\n+        }\n+\n+        public void generateClass(ClassVisitor v) throws NoSuchMethodException {\n+            Method proxy = ReflectUtils.findInterfaceMethod(iface);\n+            final Method method = targetClass.getMethod(methodName, proxy.getParameterTypes());\n+            if (!proxy.getReturnType().isAssignableFrom(method.getReturnType())) {\n+                throw new IllegalArgumentException(\"incompatible return types\");\n+            }\n+\n+            MethodInfo methodInfo = ReflectUtils.getMethodInfo(method);\n+\n+            boolean isStatic = TypeUtils.isStatic(methodInfo.getModifiers());\n+            if ((target == null) ^ isStatic) {\n+                throw new IllegalArgumentException(\"Static method \" + (isStatic ? \"not \" : \"\") + \"expected\");\n+            }\n+\n+            ClassEmitter ce = new ClassEmitter(v);\n+            CodeEmitter e;\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           METHOD_DELEGATE,\n+                           new Type[]{ Type.getType(iface) },\n+                           Constants.SOURCE_FILE);\n+            ce.declare_field(Constants.PRIVATE_FINAL_STATIC, \"eqMethod\", Constants.TYPE_STRING, null);\n+            EmitUtils.null_constructor(ce);\n+\n+            // generate proxied method\n+            MethodInfo proxied = ReflectUtils.getMethodInfo(iface.getDeclaredMethods()[0]);\n+            e = EmitUtils.begin_method(ce, proxied, Constants.ACC_PUBLIC);\n+            e.load_this();\n+            e.super_getfield(\"target\", Constants.TYPE_OBJECT);\n+            e.checkcast(methodInfo.getClassInfo().getType());\n+            e.load_args();\n+            e.invoke(methodInfo);\n+            e.return_value();\n+            e.end_method();\n+\n+            // newInstance\n+            e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\n+            e.new_instance_this();\n+            e.dup();\n+            e.dup2();\n+            e.invoke_constructor_this();\n+            e.getfield(\"eqMethod\");\n+            e.super_putfield(\"eqMethod\", Constants.TYPE_STRING);\n+            e.load_arg(0);\n+            e.super_putfield(\"target\", Constants.TYPE_OBJECT);\n+            e.return_value();\n+            e.end_method();\n+\n+            // static initializer\n+            e = ce.begin_static();\n+            e.push(methodInfo.getSignature().toString());\n+            e.putfield(\"eqMethod\");\n+            e.return_value();\n+            e.end_method();\n+            \n+            ce.end_class();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/reflect/MulticastDelegate.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.reflect;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+abstract public class MulticastDelegate implements Cloneable {\n+    protected Object[] targets = {};\n+\n+    protected MulticastDelegate() {\n+    }\n+\n+    public List getTargets() {\n+        return new ArrayList(Arrays.asList(targets));\n+    }\n+\n+    abstract public MulticastDelegate add(Object target);\n+\n+    protected MulticastDelegate addHelper(Object target) {\n+        MulticastDelegate copy = newInstance();\n+        copy.targets = new Object[targets.length + 1];\n+        System.arraycopy(targets, 0, copy.targets, 0, targets.length);\n+        copy.targets[targets.length] = target;\n+        return copy;\n+    }\n+\n+    public MulticastDelegate remove(Object target) {\n+        for (int i = targets.length - 1; i >= 0; i--) { \n+            if (targets[i].equals(target)) {\n+                MulticastDelegate copy = newInstance();\n+                copy.targets = new Object[targets.length - 1];\n+                System.arraycopy(targets, 0, copy.targets, 0, i);\n+                System.arraycopy(targets, i + 1, copy.targets, i, targets.length - i - 1);\n+                return copy;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    abstract public MulticastDelegate newInstance();\n+\n+    public static MulticastDelegate create(Class iface) {\n+        Generator gen = new Generator();\n+        gen.setInterface(iface);\n+        return gen.create();\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(MulticastDelegate.class.getName());\n+        private static final Type MULTICAST_DELEGATE =\n+          TypeUtils.parseType(\"org.mockito.cglib.reflect.MulticastDelegate\");\n+        private static final Signature NEW_INSTANCE =\n+          new Signature(\"newInstance\", MULTICAST_DELEGATE, new Type[0]);\n+        private static final Signature ADD_DELEGATE =\n+          new Signature(\"add\", MULTICAST_DELEGATE, new Type[]{ Constants.TYPE_OBJECT });\n+        private static final Signature ADD_HELPER =\n+          new Signature(\"addHelper\", MULTICAST_DELEGATE, new Type[]{ Constants.TYPE_OBJECT });\n+\n+        private Class iface;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return iface.getClassLoader();\n+        }\n+\n+        public void setInterface(Class iface) {\n+            this.iface = iface;\n+        }\n+\n+        public MulticastDelegate create() {\n+            setNamePrefix(MulticastDelegate.class.getName());\n+            return (MulticastDelegate)super.create(iface.getName());\n+        }\n+\n+        public void generateClass(ClassVisitor cv) {\n+            final MethodInfo method = ReflectUtils.getMethodInfo(ReflectUtils.findInterfaceMethod(iface));\n+            \n+            ClassEmitter ce = new ClassEmitter(cv);\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           MULTICAST_DELEGATE,\n+                           new Type[]{ Type.getType(iface) },\n+                           Constants.SOURCE_FILE);\n+            EmitUtils.null_constructor(ce);\n+\n+            // generate proxied method\n+            emitProxy(ce, method);\n+\n+            // newInstance\n+            CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, NEW_INSTANCE, null);\n+            e.new_instance_this();\n+            e.dup();\n+            e.invoke_constructor_this();\n+            e.return_value();\n+            e.end_method();\n+\n+            // add\n+            e = ce.begin_method(Constants.ACC_PUBLIC, ADD_DELEGATE, null);\n+            e.load_this();\n+            e.load_arg(0);\n+            e.checkcast(Type.getType(iface));\n+            e.invoke_virtual_this(ADD_HELPER);\n+            e.return_value();\n+            e.end_method();\n+\n+            ce.end_class();\n+        }\n+\n+        private void emitProxy(ClassEmitter ce, final MethodInfo method) {\n+            final CodeEmitter e = EmitUtils.begin_method(ce, method, Constants.ACC_PUBLIC);\n+            Type returnType = method.getSignature().getReturnType();\n+            final boolean returns = returnType != Type.VOID_TYPE;\n+            Local result = null;\n+            if (returns) {\n+                result = e.make_local(returnType);\n+                e.zero_or_null(returnType);\n+                e.store_local(result);\n+            }\n+            e.load_this();\n+            e.super_getfield(\"targets\", Constants.TYPE_OBJECT_ARRAY);\n+            final Local result2 = result;\n+            EmitUtils.process_array(e, Constants.TYPE_OBJECT_ARRAY, new ProcessArrayCallback() {\n+                public void processElement(Type type) {\n+                    e.checkcast(Type.getType(iface));\n+                    e.load_args();\n+                    e.invoke(method);\n+                    if (returns) {\n+                        e.store_local(result2);\n+                    }\n+                }\n+            });\n+            if (returns) {\n+                e.load_local(result);\n+            }\n+            e.return_value();\n+            e.end_method();\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            // make a new instance in case first object is used with a long list of targets\n+            return ((MulticastDelegate)ReflectUtils.newInstance(type)).newInstance();\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return ((MulticastDelegate)instance).newInstance();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/AbstractClassFilterTransformer.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.*;\n+\n+abstract public class AbstractClassFilterTransformer extends AbstractClassTransformer {\n+    private ClassTransformer pass;\n+    private ClassVisitor target;\n+\n+    public void setTarget(ClassVisitor target) {\n+        super.setTarget(target);\n+        pass.setTarget(target);\n+    }\n+\n+    protected AbstractClassFilterTransformer(ClassTransformer pass) {\n+        this.pass = pass;\n+    }\n+\n+    abstract protected boolean accept(int version, int access, String name, String signature, String superName, String[] interfaces);\n+\n+    public void visit(int version,\n+                      int access,\n+                      String name,\n+                      String signature,\n+                      String superName,\n+                      String[] interfaces) {\n+        target = accept(version, access, name, signature, superName, interfaces) ? pass : cv;\n+        target.visit(version, access, name, signature, superName, interfaces);\n+    }\n+    \n+    public void visitSource(String source, String debug) {\n+        target.visitSource(source, debug);\n+    }\n+    \n+    public void visitOuterClass(String owner, String name, String desc) {\n+        target.visitOuterClass(owner, name, desc);\n+    }\n+    \n+    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n+        return target.visitAnnotation(desc, visible);\n+    }\n+    \n+    public void visitAttribute(Attribute attr) {\n+        target.visitAttribute(attr);\n+    }\n+    \n+    public void visitInnerClass(String name, String outerName, String innerName, int access) {\n+        target.visitInnerClass(name, outerName, innerName, access);\n+    }\n+\n+    public FieldVisitor visitField(int access,\n+                                   String name,\n+                                   String desc,\n+                                   String signature,\n+                                   Object value) {\n+        return target.visitField(access, name, desc, signature, value);\n+    }\n+    \n+    public MethodVisitor visitMethod(int access,\n+                                     String name,\n+                                     String desc,\n+                                     String signature,\n+                                     String[] exceptions) {\n+        return target.visitMethod(access, name, desc, signature, exceptions);\n+    }\n+\n+    public void visitEnd() {\n+        target.visitEnd();\n+        target = null; // just to be safe\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/AbstractClassLoader.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassWriter;\n+import org.mockito.asm.util.*;\n+import org.mockito.cglib.core.ClassGenerator;\n+import org.mockito.cglib.core.CodeGenerationException;\n+import org.mockito.cglib.core.DebuggingClassWriter;\n+\n+import java.io.IOException;\n+\n+abstract public class AbstractClassLoader extends ClassLoader {\n+    private ClassFilter filter;\n+    private ClassLoader classPath;\n+    private static java.security.ProtectionDomain DOMAIN ;\n+    \n+    static{\n+        \n+        DOMAIN = (java.security.ProtectionDomain)\n+        java.security.AccessController.doPrivileged(\n+          new java.security.PrivilegedAction() {\n+            public Object run() {\n+               return AbstractClassLoader.class.getProtectionDomain();\n+            }\n+        }); \n+     }\n+    \n+    protected AbstractClassLoader(ClassLoader parent, ClassLoader classPath, ClassFilter filter) {\n+        super(parent);\n+        this.filter = filter;\n+        this.classPath = classPath;\n+    }\n+\n+    public Class loadClass(String name) throws ClassNotFoundException {\n+        \n+        Class loaded = findLoadedClass(name);\n+        \n+        if( loaded != null ){\n+            if( loaded.getClassLoader() == this ){\n+               return loaded;\n+            }//else reload with this class loader\n+        }\n+        \n+        if (!filter.accept(name)) {\n+            return super.loadClass(name);\n+        }\n+        ClassReader r;\n+        try {\n+            \n+           java.io.InputStream is = classPath.getResourceAsStream( \n+                       name.replace('.','/') + \".class\"\n+                  ); \n+           \n+           if (is == null) {\n+               \n+              throw new ClassNotFoundException(name);\n+              \n+           }\n+           try { \n+               \n+              r = new ClassReader(is);\n+            \n+           } finally {\n+               \n+              is.close();\n+             \n+           }\n+        } catch (IOException e) {\n+            throw new ClassNotFoundException(name + \":\" + e.getMessage());\n+        }\n+\n+        try {\n+            ClassWriter w =  new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);\n+            getGenerator(r).generateClass(w);\n+            byte[] b = w.toByteArray();\n+            Class c = super.defineClass(name, b, 0, b.length, DOMAIN);\n+            postProcess(c);\n+            return c;\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Error e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+\n+    protected ClassGenerator getGenerator(ClassReader r) {\n+        return new ClassReaderGenerator(r, attributes(), getFlags());\n+    }\n+\n+    protected int getFlags() {\n+        return 0;\n+    }\n+    \n+    protected Attribute[] attributes() {\n+        return null;\n+    }\n+\n+    protected void postProcess(Class c) {\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/AbstractClassTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.ClassAdapter;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.CodeGenerationException;\n+\n+abstract public class AbstractClassTransformer extends ClassAdapter implements ClassTransformer {\n+    protected AbstractClassTransformer() {\n+        super(null);\n+    }\n+\n+    public void setTarget(ClassVisitor target) {\n+        cv = target;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/AbstractProcessTask.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import java.io.File;\n+import java.util.*;\n+import org.apache.tools.ant.BuildException;\n+import org.apache.tools.ant.DirectoryScanner;\n+import org.apache.tools.ant.Project;\n+import org.apache.tools.ant.Task;\n+import org.apache.tools.ant.types.FileSet;\n+\n+abstract public class AbstractProcessTask extends Task {\n+    private Vector filesets = new Vector();\n+\n+    public void addFileset(FileSet set) {\n+        filesets.addElement(set);\n+    }\n+    \n+    protected Collection getFiles() {\n+        Map fileMap = new HashMap();\n+        Project p = getProject();\n+        for (int i = 0; i < filesets.size(); i++) {\n+            FileSet fs = (FileSet)filesets.elementAt(i);\n+            DirectoryScanner ds = fs.getDirectoryScanner(p);\n+            String[] srcFiles = ds.getIncludedFiles();\n+            File dir = fs.getDir(p);\n+            for (int j = 0; j < srcFiles.length; j++) {\n+                 File src = new File(dir, srcFiles[j]);\n+                 fileMap.put(src.getAbsolutePath(), src);\n+            }\n+        }\n+        return fileMap.values();\n+    }\n+\n+    \n+    \n+    public void execute() throws BuildException {\n+        beforeExecute();\n+        for (Iterator it = getFiles().iterator(); it.hasNext();) {\n+            try {\n+                processFile((File)it.next());\n+            } catch (Exception e) {\n+                 throw new BuildException(e);\n+            }\n+        }\n+    }\n+\n+    protected void beforeExecute() throws BuildException { }\n+    abstract protected void processFile(File file) throws Exception;\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/AbstractTransformTask.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import java.io.*;\n+import java.net.MalformedURLException;\n+import java.util.*;\n+import java.util.zip.*;\n+\n+import org.apache.tools.ant.*;\n+import org.mockito.asm.*;\n+import org.mockito.cglib.core.*;\n+\n+abstract public class AbstractTransformTask extends AbstractProcessTask {\n+    private static final int ZIP_MAGIC = 0x504B0304;\n+\n+    private static final int CLASS_MAGIC = 0xCAFEBABE;\n+\n+    private boolean verbose;\n+\n+    public void setVerbose(boolean verbose) {\n+        this.verbose = verbose;\n+    }\n+\n+    /**\n+     * returns transformation for source class\n+     * \n+     * @param classInfo\n+     *            class information \n+     *            class name := classInfo[ 0 ] \n+     *            super class  name := classInfo[ 1 ]\n+     *            interfaces := classInfo[ >1 ]\n+     */\n+    abstract protected ClassTransformer getClassTransformer(String[] classInfo);\n+\n+    protected Attribute[] attributes() {\n+        return null;\n+    }\n+\n+    protected void processFile(File file) throws Exception {\n+\n+        if (isClassFile(file)) {\n+\n+            processClassFile(file);\n+\n+        } else if (isJarFile(file)) {\n+\n+            processJarFile(file);\n+\n+        } else {\n+            \n+            log(\"ignoring \" + file.toURL(), Project.MSG_WARN);\n+            \n+        }\n+    }\n+\n+    /**\n+     * @param file\n+     * @throws Exception\n+     * @throws FileNotFoundException\n+     * @throws IOException\n+     * @throws MalformedURLException\n+     */\n+    private void processClassFile(File file) throws Exception,\n+            FileNotFoundException, IOException, MalformedURLException {\n+\n+        ClassReader reader = getClassReader(file);\n+        String name[] = ClassNameReader.getClassInfo(reader);\n+        ClassWriter w = new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);\n+        ClassTransformer t = getClassTransformer(name);\n+        if (t != null) {\n+\n+            if (verbose) {\n+                log(\"processing \" + file.toURL());\n+            }\n+            new TransformingClassGenerator(new ClassReaderGenerator(\n+                    getClassReader(file), attributes(), getFlags()), t)\n+                    .generateClass(w);\n+            FileOutputStream fos = new FileOutputStream(file);\n+            try {\n+                fos.write(w.toByteArray());\n+            } finally {\n+                fos.close();\n+            }\n+\n+        }\n+\n+    }\n+\n+    protected int getFlags() {\n+        return 0;\n+    }\n+\n+    private static ClassReader getClassReader(File file) throws Exception {\n+        InputStream in = new BufferedInputStream(new FileInputStream(file));\n+        try {\n+            ClassReader r = new ClassReader(in);\n+            return r;\n+        } finally {\n+            in.close();\n+        }\n+\n+    }\n+\n+    protected boolean isClassFile(File file) throws IOException {\n+\n+        return checkMagic(file, CLASS_MAGIC);\n+\n+    }\n+\n+    protected void processJarFile(File file) throws Exception {\n+\n+        if (verbose) {\n+            log(\"processing \" + file.toURL());\n+        }\n+        \n+        File tempFile = File.createTempFile(file.getName(), null, new File(file\n+                .getAbsoluteFile().getParent()));\n+        try{\n+            \n+            ZipInputStream zip = new ZipInputStream(new FileInputStream(file));\n+            try {\n+                FileOutputStream fout = new FileOutputStream(tempFile, false);\n+                try{\n+                 ZipOutputStream out = new ZipOutputStream(fout);\n+                                \n+                    ZipEntry entry;\n+                    while ((entry = zip.getNextEntry()) != null) {\n+                        \n+                        \n+                        byte bytes[] = getBytes(zip);\n+                        \n+                        if (!entry.isDirectory()) {\n+                            \n+                            DataInputStream din = new DataInputStream(\n+                                              new ByteArrayInputStream(bytes)\n+                                            );\n+                            \n+                            if (din.readInt() == CLASS_MAGIC) {\n+                                \n+                                bytes = process(bytes);\n+                                                        \n+                            } else {\n+                                if (verbose) {\n+                                 log(\"ignoring \" + entry.toString());\n+                                }\n+                            }\n+                        }\n+                       \n+                        ZipEntry outEntry = new ZipEntry(entry.getName());\n+                        outEntry.setMethod(entry.getMethod());\n+                        outEntry.setComment(entry.getComment());\n+                        outEntry.setSize(bytes.length);\n+                        \n+                        \n+                        if(outEntry.getMethod() == ZipEntry.STORED){\n+                            CRC32 crc = new CRC32();\n+                            crc.update(bytes);\n+                            outEntry.setCrc( crc.getValue() );\n+                            outEntry.setCompressedSize(bytes.length);\n+                        }\n+                        out.putNextEntry(outEntry);\n+                        out.write(bytes);\n+                        out.closeEntry();\n+                        zip.closeEntry();\n+                        \n+                    }\n+                    out.close(); \n+                }finally{\n+                 fout.close();    \n+                } \n+            } finally {\n+                zip.close();\n+            }\n+            \n+            \n+            if(file.delete()){\n+                \n+                File newFile = new File(tempFile.getAbsolutePath());\n+                \n+                if(!newFile.renameTo(file)){\n+                    throw new IOException(\"can not rename \" + tempFile + \" to \" + file);   \n+                }\n+                \n+            }else{\n+                throw new IOException(\"can not delete \" + file);\n+            }\n+            \n+        }finally{\n+            \n+            tempFile.delete();\n+            \n+        }\n+        \n+    }\n+\n+    /**\n+     * @param bytes\n+     * @return\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    private byte[] process(byte[] bytes) throws Exception {\n+\n+        ClassReader reader = new ClassReader(new ByteArrayInputStream(bytes));\n+        String name[] = ClassNameReader.getClassInfo(reader);\n+        ClassWriter w = new DebuggingClassWriter(ClassWriter.COMPUTE_MAXS);\n+        ClassTransformer t = getClassTransformer(name);\n+        if (t != null) {\n+            if (verbose) {\n+                log(\"processing \" + name[0]);\n+            }\n+            new TransformingClassGenerator(new ClassReaderGenerator(\n+                    new ClassReader(new ByteArrayInputStream(bytes)),\n+                    attributes(), getFlags()), t).generateClass(w);\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            out.write(w.toByteArray());\n+            return out.toByteArray();\n+        }\n+        return bytes;\n+    }\n+\n+    /**\n+     * @param zip\n+     * @return\n+     * @throws IOException\n+     */\n+    private byte[] getBytes(ZipInputStream zip) throws IOException {\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        InputStream in = new BufferedInputStream(zip);\n+        int b;\n+        while ((b = in.read()) != -1) {\n+            bout.write(b);\n+        }\n+        return bout.toByteArray();\n+    }\n+\n+    private boolean checkMagic(File file, long magic) throws IOException {\n+        DataInputStream in = new DataInputStream(new FileInputStream(file));\n+        try {\n+            int m = in.readInt();\n+            return magic == m; \n+        } finally {\n+            in.close();\n+        }\n+    }\n+\n+    protected boolean isJarFile(File file) throws IOException {\n+        return checkMagic(file, ZIP_MAGIC);\n+    }\n+\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/AnnotationVisitorTee.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+\n+public class AnnotationVisitorTee implements AnnotationVisitor {\n+    private AnnotationVisitor av1, av2;\n+\n+    public static AnnotationVisitor getInstance(AnnotationVisitor av1, AnnotationVisitor av2) {\n+        if (av1 == null)\n+            return av2;\n+        if (av2 == null)\n+            return av1;\n+        return new AnnotationVisitorTee(av1, av2);\n+    }\n+\n+    public AnnotationVisitorTee(AnnotationVisitor av1, AnnotationVisitor av2) {\n+        this.av1 = av1;\n+        this.av2 = av2;\n+    }\n+\n+    public void visit(String name, Object value) {\n+        av2.visit(name, value);\n+        av2.visit(name, value);\n+    }\n+    \n+    public void visitEnum(String name, String desc, String value) {\n+        av1.visitEnum(name, desc, value);\n+        av2.visitEnum(name, desc, value);\n+    }\n+    \n+    public AnnotationVisitor visitAnnotation(String name, String desc) {\n+        return getInstance(av1.visitAnnotation(name, desc),\n+                           av2.visitAnnotation(name, desc));\n+    }\n+    \n+    public AnnotationVisitor visitArray(String name) {\n+        return getInstance(av1.visitArray(name), av2.visitArray(name));\n+    }\n+    \n+    public void visitEnd() {\n+        av1.visitEnd();\n+        av2.visitEnd();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassEmitterTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.cglib.core.ClassEmitter;\n+\n+abstract public class ClassEmitterTransformer extends ClassEmitter implements ClassTransformer {\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassFilter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.mockito.cglib.transform;\n+\n+/**\n+ *\n+ * @author  baliuka\n+ */\n+public interface ClassFilter {\n+    \n+    boolean accept(String className);\n+    \n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassFilterTransformer.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.*;\n+\n+public class ClassFilterTransformer extends AbstractClassFilterTransformer {\n+    private ClassFilter filter;\n+\n+    public ClassFilterTransformer(ClassFilter filter, ClassTransformer pass) {\n+        super(pass);\n+        this.filter = filter;\n+    }\n+\n+    protected boolean accept(int version, int access, String name, String signature, String superName, String[] interfaces) {\n+        return filter.accept(name.replace('/', '.'));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassReaderGenerator.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassReader;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.ClassGenerator;\n+\n+public class ClassReaderGenerator implements ClassGenerator {\n+    private final ClassReader r;\n+    private final Attribute[] attrs;\n+    private final int flags;\n+    \n+    public ClassReaderGenerator(ClassReader r, int flags) {\n+        this(r, null, flags);\n+    }\n+\n+    public ClassReaderGenerator(ClassReader r, Attribute[] attrs, int flags) {\n+        this.r = r;\n+        this.attrs = (attrs != null) ? attrs : new Attribute[0];\n+        this.flags = flags;\n+    }\n+    \n+    public void generateClass(ClassVisitor v) {\n+        r.accept(v, attrs, flags);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.ClassVisitor;\n+\n+public interface ClassTransformer extends ClassVisitor {\n+    public void setTarget(ClassVisitor target);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassTransformerChain.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.*;\n+\n+public class ClassTransformerChain extends AbstractClassTransformer {\n+    private ClassTransformer[] chain;\n+    \n+    public ClassTransformerChain(ClassTransformer[] chain) {\n+        this.chain = (ClassTransformer[])chain.clone();\n+    }\n+\n+    public void setTarget(ClassVisitor v) {\n+        super.setTarget(chain[0]);\n+        ClassVisitor next = v;\n+        for (int i = chain.length - 1; i >= 0; i--) {\n+            chain[i].setTarget(next);\n+            next = chain[i];\n+        }\n+    }\n+\n+    public MethodVisitor visitMethod(int access,\n+                                     String name,\n+                                     String desc,\n+                                     String signature,\n+                                     String[] exceptions) {\n+        return cv.visitMethod(access, name, desc, signature, exceptions);\n+    }\n+\n+    public String toString() {\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(\"ClassTransformerChain{\");\n+        for (int i = 0; i < chain.length; i++) {\n+            if (i > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(chain[i].toString());\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassTransformerFactory.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+public interface ClassTransformerFactory {\n+    ClassTransformer newInstance();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassTransformerTee.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.ClassAdapter;\n+import org.mockito.asm.ClassVisitor;\n+\n+public class ClassTransformerTee extends ClassAdapter implements ClassTransformer {\n+    private ClassVisitor branch;\n+    \n+    public ClassTransformerTee(ClassVisitor branch) {\n+        super(null);\n+        this.branch = branch;\n+    }\n+    \n+    public void setTarget(ClassVisitor target) { \n+        cv = new ClassVisitorTee(branch, target);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/ClassVisitorTee.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.*;\n+\n+public class ClassVisitorTee implements ClassVisitor {\n+    private ClassVisitor cv1, cv2;\n+    \n+    public ClassVisitorTee(ClassVisitor cv1, ClassVisitor cv2) {\n+        this.cv1 = cv1;\n+        this.cv2 = cv2;\n+    }\n+\n+    public void visit(int version,\n+                      int access,\n+                      String name,\n+                      String signature,\n+                      String superName,\n+                      String[] interfaces) {\n+        cv1.visit(version, access, name, signature, superName, interfaces);\n+        cv2.visit(version, access, name, signature, superName, interfaces);\n+    }\n+\n+    public void visitEnd() {\n+        cv1.visitEnd();\n+        cv2.visitEnd();\n+        cv1 = cv2 = null;\n+    }\n+\n+    public void visitInnerClass(String name, String outerName, String innerName, int access) {\n+        cv1.visitInnerClass(name, outerName, innerName, access);\n+        cv2.visitInnerClass(name, outerName, innerName, access);\n+    }\n+\n+    public FieldVisitor visitField(int access,\n+                                   String name,\n+                                   String desc,\n+                                   String signature,\n+                                   Object value) {\n+        FieldVisitor fv1 = cv1.visitField(access, name, desc, signature, value);\n+        FieldVisitor fv2 = cv2.visitField(access, name, desc, signature, value);\n+        if (fv1 == null)\n+            return fv2;\n+        if (fv2 == null)\n+            return fv1;\n+        return new FieldVisitorTee(fv1, fv2);\n+    }\n+\n+\n+    public MethodVisitor visitMethod(int access,\n+                                     String name,\n+                                     String desc,\n+                                     String signature,\n+                                     String[] exceptions) {\n+        MethodVisitor mv1 = cv1.visitMethod(access, name, desc, signature, exceptions);\n+        MethodVisitor mv2 = cv2.visitMethod(access, name, desc, signature, exceptions);\n+        if (mv1 == null)\n+            return mv2;\n+        if (mv2 == null)\n+            return mv1;\n+        return new MethodVisitorTee(mv1, mv2);\n+    }\n+\n+    public void visitSource(String source, String debug) {\n+        cv1.visitSource(source, debug);\n+        cv2.visitSource(source, debug);\n+    }\n+\n+    public void visitOuterClass(String owner, String name, String desc) {\n+        cv1.visitOuterClass(owner, name, desc);\n+        cv2.visitOuterClass(owner, name, desc);\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n+        return AnnotationVisitorTee.getInstance(cv1.visitAnnotation(desc, visible),\n+                                                cv2.visitAnnotation(desc, visible));\n+    }\n+    \n+    public void visitAttribute(Attribute attrs) {\n+        cv1.visitAttribute(attrs);\n+        cv2.visitAttribute(attrs);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/FieldVisitorTee.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.AnnotationVisitor;\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.FieldVisitor;\n+\n+public class FieldVisitorTee implements FieldVisitor {\n+    private FieldVisitor fv1, fv2;\n+    \n+    public FieldVisitorTee(FieldVisitor fv1, FieldVisitor fv2) {\n+        this.fv1 = fv1;\n+        this.fv2 = fv2;\n+    }\n+\n+    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n+        return AnnotationVisitorTee.getInstance(fv1.visitAnnotation(desc, visible),\n+                                                fv2.visitAnnotation(desc, visible));\n+    }\n+    \n+    public void visitAttribute(Attribute attr) {\n+        fv1.visitAttribute(attr);\n+        fv2.visitAttribute(attr);\n+    }\n+\n+    public void visitEnd() {\n+        fv1.visitEnd();\n+        fv2.visitEnd();\n+    }\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/MethodFilter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.Attribute;\n+\n+public interface MethodFilter {\n+    // TODO: pass class name too?\n+    boolean accept(int access, String name, String desc, String signature, String[] exceptions);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/MethodFilterTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.*;\n+\n+public class MethodFilterTransformer extends AbstractClassTransformer {\n+    private MethodFilter filter;\n+    private ClassTransformer pass;\n+    private ClassVisitor direct;\n+    \n+    public MethodFilterTransformer(MethodFilter filter, ClassTransformer pass) {\n+        this.filter = filter;\n+        this.pass = pass;\n+        super.setTarget(pass);\n+    }\n+\n+    public MethodVisitor visitMethod(int access,\n+                                     String name,\n+                                     String desc,\n+                                     String signature,\n+                                     String[] exceptions) {\n+        return (filter.accept(access, name, desc, signature, exceptions) ? pass : direct).visitMethod(access, name, desc, signature, exceptions);\n+    }\n+    \n+    public void setTarget(ClassVisitor target) {\n+        pass.setTarget(target);\n+        direct = target;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/MethodVisitorTee.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.*;\n+\n+public class MethodVisitorTee implements MethodVisitor {\n+    private final MethodVisitor mv1;\n+    private final MethodVisitor mv2;\n+    \n+    public MethodVisitorTee(MethodVisitor mv1, MethodVisitor mv2) {\n+        this.mv1 = mv1;\n+        this.mv2 = mv2;\n+    }\n+\n+    public void visitFrame(int type, int nLocal, Object[] local, int nStack, Object[] stack) {\n+        mv1.visitFrame(type, nLocal, local, nStack, stack);\n+        mv2.visitFrame(type, nLocal, local, nStack, stack);\n+    }\n+\n+    public AnnotationVisitor visitAnnotationDefault() {\n+        return AnnotationVisitorTee.getInstance(mv1.visitAnnotationDefault(),\n+                                                mv2.visitAnnotationDefault());\n+    }\n+    \n+    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n+        return AnnotationVisitorTee.getInstance(mv1.visitAnnotation(desc, visible),\n+                                                mv2.visitAnnotation(desc, visible));\n+    }\n+    \n+    public AnnotationVisitor visitParameterAnnotation(int parameter,\n+                                                      String desc,\n+                                                      boolean visible) {\n+        return AnnotationVisitorTee.getInstance(mv1.visitParameterAnnotation(parameter, desc, visible),\n+                                                mv2.visitParameterAnnotation(parameter, desc, visible));\n+    }\n+\n+    public void visitAttribute(Attribute attr) {\n+        mv1.visitAttribute(attr);\n+        mv2.visitAttribute(attr);\n+    }\n+    \n+    public void visitCode() {\n+        mv1.visitCode();\n+        mv2.visitCode();\n+    }\n+    \n+    public void visitInsn(int opcode) {\n+        mv1.visitInsn(opcode);\n+        mv2.visitInsn(opcode);\n+    }\n+    \n+    public void visitIntInsn(int opcode, int operand) {\n+        mv1.visitIntInsn(opcode, operand);\n+        mv2.visitIntInsn(opcode, operand);\n+    }\n+    \n+    public void visitVarInsn(int opcode, int var) {\n+        mv1.visitVarInsn(opcode, var);\n+        mv2.visitVarInsn(opcode, var);\n+    }\n+    \n+    public void visitTypeInsn(int opcode, String desc) {\n+        mv1.visitTypeInsn(opcode, desc);\n+        mv2.visitTypeInsn(opcode, desc);\n+    }\n+    \n+    public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n+        mv1.visitFieldInsn(opcode, owner, name, desc);\n+        mv2.visitFieldInsn(opcode, owner, name, desc);\n+    }\n+    \n+    public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+        mv1.visitMethodInsn(opcode, owner, name, desc);\n+        mv2.visitMethodInsn(opcode, owner, name, desc);\n+    }\n+    \n+    public void visitJumpInsn(int opcode, Label label) {\n+        mv1.visitJumpInsn(opcode, label);\n+        mv2.visitJumpInsn(opcode, label);\n+    }\n+    \n+    public void visitLabel(Label label) {\n+        mv1.visitLabel(label);\n+        mv2.visitLabel(label);\n+    }\n+    \n+    public void visitLdcInsn(Object cst) {\n+        mv1.visitLdcInsn(cst);\n+        mv2.visitLdcInsn(cst);\n+    }\n+    \n+    public void visitIincInsn(int var, int increment) {\n+        mv1.visitIincInsn(var, increment);\n+        mv2.visitIincInsn(var, increment);\n+    }\n+    \n+    public void visitTableSwitchInsn(int min, int max, Label dflt, Label labels[]) {\n+        mv1.visitTableSwitchInsn(min, max, dflt, labels);\n+        mv2.visitTableSwitchInsn(min, max, dflt, labels);\n+    }\n+    \n+    public void visitLookupSwitchInsn(Label dflt, int keys[], Label labels[]) {\n+        mv1.visitLookupSwitchInsn(dflt, keys, labels);\n+        mv2.visitLookupSwitchInsn(dflt, keys, labels);\n+    }\n+    \n+    public void visitMultiANewArrayInsn(String desc, int dims) {\n+        mv1.visitMultiANewArrayInsn(desc, dims);\n+        mv2.visitMultiANewArrayInsn(desc, dims);\n+    }\n+    \n+    public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n+        mv1.visitTryCatchBlock(start, end, handler, type);\n+        mv2.visitTryCatchBlock(start, end, handler, type);\n+    }\n+    \n+    public void visitLocalVariable(String name, String desc, String signature, Label start, Label end, int index) {\n+        mv1.visitLocalVariable(name, desc, signature, start, end, index);\n+        mv2.visitLocalVariable(name, desc, signature, start, end, index);\n+    }\n+    \n+    public void visitLineNumber(int line, Label start) {\n+        mv1.visitLineNumber(line, start);\n+        mv2.visitLineNumber(line, start);\n+    }\n+    \n+    public void visitMaxs(int maxStack, int maxLocals) {\n+        mv1.visitMaxs(maxStack, maxLocals);\n+        mv2.visitMaxs(maxStack, maxLocals);\n+    }\n+    \n+    public void visitEnd() {\n+        mv1.visitEnd();\n+        mv2.visitEnd();\n+    }\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/TransformingClassGenerator.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.ClassGenerator;\n+import org.mockito.cglib.core.Transformer;\n+\n+public class TransformingClassGenerator implements ClassGenerator {\n+    private ClassGenerator gen;\n+    private ClassTransformer t;\n+    \n+    public TransformingClassGenerator(ClassGenerator gen, ClassTransformer t) {\n+        this.gen = gen;\n+        this.t = t;\n+    }\n+    \n+    public void generateClass(ClassVisitor v) throws Exception {\n+        t.setTarget(v);\n+        gen.generateClass(t);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/TransformingClassLoader.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.*;\n+import org.mockito.cglib.core.ClassGenerator;\n+\n+public class TransformingClassLoader extends AbstractClassLoader {\n+    private ClassTransformerFactory t;\n+    \n+    public TransformingClassLoader(ClassLoader parent, ClassFilter filter, ClassTransformerFactory t) {\n+        super(parent, parent, filter);\n+        this.t = t;\n+    }\n+\n+    protected ClassGenerator getGenerator(ClassReader r) {\n+        ClassTransformer t2 = (ClassTransformer)t.newInstance();\n+        return new TransformingClassGenerator(super.getGenerator(r), t2);\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/AbstractInterceptFieldCallback.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+/**\n+ * @author Chris Nokleberg\n+ */\n+public class AbstractInterceptFieldCallback implements InterceptFieldCallback {\n+    \n+    public int writeInt(Object obj, String name, int oldValue, int newValue) { return newValue; }\n+    public char writeChar(Object obj, String name, char oldValue, char newValue) { return newValue; }\n+    public byte writeByte(Object obj, String name, byte oldValue, byte newValue) { return newValue; }\n+    public boolean writeBoolean(Object obj, String name, boolean oldValue, boolean newValue) { return newValue; }\n+    public short writeShort(Object obj, String name, short oldValue, short newValue) { return newValue; }\n+    public float writeFloat(Object obj, String name, float oldValue, float newValue) { return newValue; }\n+    public double writeDouble(Object obj, String name, double oldValue, double newValue) { return newValue; }\n+    public long writeLong(Object obj, String name, long oldValue, long newValue) { return newValue; }\n+    public Object writeObject(Object obj, String name, Object oldValue, Object newValue) { return newValue; }\n+\n+    public int readInt(Object obj, String name, int oldValue) { return oldValue; }\n+    public char readChar(Object obj, String name, char oldValue) { return oldValue; }\n+    public byte readByte(Object obj, String name, byte oldValue) { return oldValue; }\n+    public boolean readBoolean(Object obj, String name, boolean oldValue) { return oldValue; }\n+    public short readShort(Object obj, String name, short oldValue) { return oldValue; }\n+    public float readFloat(Object obj, String name, float oldValue) { return oldValue; }\n+    public double readDouble(Object obj, String name, double oldValue) { return oldValue; }\n+    public long readLong(Object obj, String name, long oldValue) { return oldValue; }\n+    public Object readObject(Object obj, String name, Object oldValue) { return oldValue; }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/AccessFieldTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+public class AccessFieldTransformer extends ClassEmitterTransformer {\n+    private Callback callback;\n+\n+    public AccessFieldTransformer(Callback callback) {\n+        this.callback = callback;\n+    }\n+\n+    public interface Callback {\n+        String getPropertyName(Type owner, String fieldName);\n+    }\n+\n+    public void declare_field(int access, final String name, Type type, Object value) {\n+        super.declare_field(access, name, type, value);\n+\n+        String property = TypeUtils.upperFirst(callback.getPropertyName(getClassType(), name));\n+        if (property != null) {\n+            CodeEmitter e;\n+            e = begin_method(Constants.ACC_PUBLIC,\n+                             new Signature(\"get\" + property,\n+                                           type,\n+                                           Constants.TYPES_EMPTY),\n+                             null);\n+            e.load_this();\n+            e.getfield(name);\n+            e.return_value();\n+            e.end_method();\n+\n+            e = begin_method(Constants.ACC_PUBLIC,\n+                             new Signature(\"set\" + property,\n+                                           Type.VOID_TYPE,\n+                                           new Type[]{ type }),\n+                             null);\n+            e.load_this();\n+            e.load_arg(0);\n+            e.putfield(name);\n+            e.return_value();\n+            e.end_method();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/AddDelegateTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+/**\n+ * @author Juozas Baliuka\n+ */\n+public class AddDelegateTransformer extends ClassEmitterTransformer {\n+    private static final String DELEGATE = \"$CGLIB_DELEGATE\";\n+    private static final Signature CSTRUCT_OBJECT =\n+      TypeUtils.parseSignature(\"void <init>(Object)\");\n+    \n+    private Class[] delegateIf;\n+    private Class delegateImpl;\n+    private Type delegateType;\n+    \n+    /** Creates a new instance of AddDelegateTransformer */\n+    public AddDelegateTransformer(Class delegateIf[], Class delegateImpl) {\n+        try {\n+            delegateImpl.getConstructor(new Class[]{ Object.class });\n+            this.delegateIf = delegateIf;\n+            this.delegateImpl = delegateImpl;\n+            delegateType = Type.getType(delegateImpl);\n+        } catch (NoSuchMethodException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+    }\n+    \n+    public void begin_class(int version, int access, String className, Type superType, Type[] interfaces, String sourceFile) {\n+        \n+        if(!TypeUtils.isInterface(access)){\n+            \n+        Type[] all = TypeUtils.add(interfaces, TypeUtils.getTypes(delegateIf));\n+        super.begin_class(version, access, className, superType, all, sourceFile);\n+        \n+        declare_field(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT,\n+                      DELEGATE,\n+                      delegateType,\n+                      null);\n+        for (int i = 0; i < delegateIf.length; i++) {\n+            Method[] methods = delegateIf[i].getMethods();\n+            for (int j = 0; j < methods.length; j++) {\n+                if (Modifier.isAbstract(methods[j].getModifiers())) {\n+                    addDelegate(methods[j]);\n+                }\n+            }\n+        }\n+        }else{\n+           super.begin_class(version, access, className, superType, interfaces, sourceFile);\n+        }\n+    }\n+\n+    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n+        final CodeEmitter e = super.begin_method(access, sig, exceptions);\n+        if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {\n+            return new CodeEmitter(e) {\n+                private boolean transformInit = true;\n+                public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n+                    super.visitMethodInsn(opcode, owner, name, desc);\n+                    if (transformInit && opcode == Constants.INVOKESPECIAL) {\n+                        load_this();\n+                        new_instance(delegateType);\n+                        dup();\n+                        load_this();\n+                        invoke_constructor(delegateType, CSTRUCT_OBJECT);\n+                        putfield(DELEGATE);\n+                        transformInit = false;\n+                    }\n+                }\n+            };\n+        }\n+        return e;\n+    }\n+\n+    private void addDelegate(Method m) {\n+        Method delegate;\n+        try {\n+            delegate = delegateImpl.getMethod(m.getName(), m.getParameterTypes());\n+            if (!delegate.getReturnType().getName().equals(m.getReturnType().getName())){\n+                throw new IllegalArgumentException(\"Invalid delegate signature \" + delegate);\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new CodeGenerationException(e);\n+        }\n+\n+        final Signature sig = ReflectUtils.getSignature(m);\n+        Type[] exceptions = TypeUtils.getTypes(m.getExceptionTypes());\n+        CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, sig, exceptions);\n+        e.load_this();\n+        e.getfield(DELEGATE);\n+        e.load_args();\n+        e.invoke_virtual(delegateType, sig);\n+        e.return_value();\n+        e.end_method();\n+    }\n+}\n+\n+\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/AddInitTransformer.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import java.lang.reflect.Method;\n+\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.CodeEmitter;\n+import org.mockito.cglib.core.Constants;\n+import org.mockito.cglib.core.MethodInfo;\n+import org.mockito.cglib.core.ReflectUtils;\n+import org.mockito.cglib.core.Signature;\n+import org.mockito.cglib.transform.ClassEmitterTransformer;\n+\n+/**\n+ * @author\tMark Hobson\n+ */\n+public class AddInitTransformer extends ClassEmitterTransformer {\n+    private MethodInfo info;\n+    \n+    public AddInitTransformer(Method method) {\n+        info = ReflectUtils.getMethodInfo(method);\n+        \n+        Type[] types = info.getSignature().getArgumentTypes();\n+        if (types.length != 1 ||\n+        !types[0].equals(Constants.TYPE_OBJECT) ||\n+        !info.getSignature().getReturnType().equals(Type.VOID_TYPE)) {\n+            throw new IllegalArgumentException(method + \" illegal signature\");\n+        }\n+    }\n+    \n+    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n+        final CodeEmitter emitter = super.begin_method(access, sig, exceptions);\n+        if (sig.getName().equals(Constants.CONSTRUCTOR_NAME)) {\n+            return new CodeEmitter(emitter) {\n+                public void visitInsn(int opcode) {\n+                    if (opcode == Constants.RETURN) {\n+                        load_this();\n+                        invoke(info);\n+                    }\n+                    super.visitInsn(opcode);\n+                }\n+            };\n+        }\n+        return emitter;\n+    }\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/AddPropertyTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+public class AddPropertyTransformer extends ClassEmitterTransformer {\n+    private final String[] names;\n+    private final Type[] types;\n+\n+    public AddPropertyTransformer(Map props) {\n+        int size = props.size();\n+        names = (String[])props.keySet().toArray(new String[size]);\n+        types = new Type[size];\n+        for (int i = 0; i < size; i++) {\n+            types[i] = (Type)props.get(names[i]);\n+        }\n+    }\n+\n+    public AddPropertyTransformer(String[] names, Type[] types) {\n+        this.names = names;\n+        this.types = types;\n+    }\n+\n+    public void end_class() {\n+        if (!TypeUtils.isAbstract(getAccess())) {\n+            EmitUtils.add_properties(this, names, types);\n+        }\n+        super.end_class();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/AddStaticInitTransformer.java\n+/*\n+ * Copyright 2003,2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+/**\n+ * @author Juozas Baliuka, Chris Nokleberg\n+ */\n+public class AddStaticInitTransformer extends ClassEmitterTransformer {\n+    private MethodInfo info;\n+\n+    public AddStaticInitTransformer(Method classInit) {\n+        info = ReflectUtils.getMethodInfo(classInit);\n+        if (!TypeUtils.isStatic(info.getModifiers())) {\n+            throw new IllegalArgumentException(classInit + \" is not static\");\n+        }\n+        Type[] types = info.getSignature().getArgumentTypes();\n+        if (types.length != 1 ||\n+            !types[0].equals(Constants.TYPE_CLASS) ||\n+            !info.getSignature().getReturnType().equals(Type.VOID_TYPE)) {\n+            throw new IllegalArgumentException(classInit + \" illegal signature\");\n+        }\n+    }\n+\n+    protected void init() {\n+        if (!TypeUtils.isInterface(getAccess())) {\n+            CodeEmitter e = getStaticHook();\n+            EmitUtils.load_class_this(e);\n+            e.invoke(info);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/FieldProvider.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+public interface FieldProvider {\n+    \n+    String[] getFieldNames();\n+    \n+    Class[]  getFieldTypes();\n+    \n+    void setField(int index, Object value);\n+    \n+    Object getField(int index);\n+    \n+    \n+    void setField(String name, Object value);\n+    \n+    Object getField(String name);\n+    \n+    \n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/FieldProviderTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+public class FieldProviderTransformer extends ClassEmitterTransformer {\n+    \n+    private static final String FIELD_NAMES = \"CGLIB$FIELD_NAMES\";\n+    private static final String FIELD_TYPES = \"CGLIB$FIELD_TYPES\";\n+    \n+    private static final Type FIELD_PROVIDER =\n+      TypeUtils.parseType(\"org.mockito.cglib.transform.impl.FieldProvider\");\n+    private static final Type ILLEGAL_ARGUMENT_EXCEPTION =\n+      TypeUtils.parseType(\"IllegalArgumentException\");\n+    private static final Signature PROVIDER_GET =\n+      TypeUtils.parseSignature(\"Object getField(String)\");\n+    private static final Signature PROVIDER_SET =\n+      TypeUtils.parseSignature(\"void setField(String, Object)\");\n+    private static final Signature PROVIDER_SET_BY_INDEX =\n+      TypeUtils.parseSignature(\"void setField(int, Object)\");\n+    private static final Signature PROVIDER_GET_BY_INDEX =\n+      TypeUtils.parseSignature(\"Object getField(int)\");\n+    private static final Signature PROVIDER_GET_TYPES =\n+      TypeUtils.parseSignature(\"Class[] getFieldTypes()\");\n+    private static final Signature PROVIDER_GET_NAMES =\n+      TypeUtils.parseSignature(\"String[] getFieldNames()\");\n+    \n+    private int access;\n+    private Map fields;\n+    \n+    public void begin_class(int version, int access, String className, Type superType, Type[] interfaces, String sourceFile) {\n+        if (!TypeUtils.isAbstract(access)) {\n+            interfaces = TypeUtils.add(interfaces, FIELD_PROVIDER);\n+        }\n+        this.access = access;\n+        fields = new HashMap();\n+        super.begin_class(version, access, className, superType, interfaces, sourceFile);\n+    }\n+\n+    public void declare_field(int access, String name, Type type, Object value) {\n+        super.declare_field(access, name, type, value);\n+        \n+        if (!TypeUtils.isStatic(access)) {\n+            fields.put(name, type);\n+        }\n+    }\n+\n+    public void end_class() {\n+        if (!TypeUtils.isInterface(access)) {  \n+            try {\n+                generate();\n+            } catch (RuntimeException e) {\n+                throw e;\n+            } catch (Exception e) {\n+                throw new CodeGenerationException(e);\n+            }\n+        }\n+        super.end_class();\n+    }\n+\n+    private void generate() throws Exception {\n+        final String[] names = (String[])fields.keySet().toArray(new String[fields.size()]);\n+\n+        int indexes[] = new int[names.length];\n+        for (int i = 0; i < indexes.length; i++) {\n+            indexes[i] = i;\n+        }\n+        \n+        super.declare_field(Constants.PRIVATE_FINAL_STATIC, FIELD_NAMES, Constants.TYPE_STRING_ARRAY, null);\n+        super.declare_field(Constants.PRIVATE_FINAL_STATIC, FIELD_TYPES, Constants.TYPE_CLASS_ARRAY, null);\n+\n+        // use separate methods here because each process switch inner class needs a final CodeEmitter\n+        initFieldProvider(names);\n+        getNames();\n+        getTypes();\n+        getField(names);\n+        setField(names);\n+        setByIndex(names, indexes);\n+        getByIndex(names, indexes);\n+    }\n+\n+    private void initFieldProvider(String[] names) {\n+        CodeEmitter e = getStaticHook();\n+        EmitUtils.push_object(e, names);\n+        e.putstatic(getClassType(), FIELD_NAMES, Constants.TYPE_STRING_ARRAY);\n+        \n+        e.push(names.length);\n+        e.newarray(Constants.TYPE_CLASS);\n+        e.dup();\n+        for(int i = 0; i < names.length; i++ ){ \n+            e.dup();\n+            e.push(i);\n+            Type type = (Type)fields.get(names[i]);\n+            EmitUtils.load_class(e, type);\n+            e.aastore();\n+        }\n+        e.putstatic(getClassType(), FIELD_TYPES, Constants.TYPE_CLASS_ARRAY);\n+    }\n+\n+    private void getNames() {\n+        CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, PROVIDER_GET_NAMES, null);\n+        e.getstatic(getClassType(), FIELD_NAMES, Constants.TYPE_STRING_ARRAY);\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void getTypes() {\n+        CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, PROVIDER_GET_TYPES, null);\n+        e.getstatic(getClassType(), FIELD_TYPES, Constants.TYPE_CLASS_ARRAY);\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void setByIndex(final String[] names, final int[] indexes) throws Exception {\n+        final CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, PROVIDER_SET_BY_INDEX, null);\n+        e.load_this();\n+        e.load_arg(1);\n+        e.load_arg(0);\n+        e.process_switch(indexes, new ProcessSwitchCallback() {\n+            public void processCase(int key, Label end) throws Exception {\n+                Type type = (Type)fields.get(names[key]);\n+                e.unbox(type);\n+                e.putfield(names[key]);\n+                e.return_value();\n+            }\n+            public void processDefault() throws Exception {\n+                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field index\");         \n+            }\n+        });\n+        e.end_method();\n+    }\n+\n+    private void getByIndex(final String[] names, final int[] indexes) throws Exception {\n+        final CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC, PROVIDER_GET_BY_INDEX, null);\n+        e.load_this();\n+        e.load_arg(0);\n+        e.process_switch(indexes, new ProcessSwitchCallback() {\n+            public void processCase(int key, Label end) throws Exception {\n+                Type type = (Type)fields.get(names[key]);\n+                e.getfield(names[key]);\n+                e.box(type);\n+                e.return_value();\n+            }\n+            public void processDefault() throws Exception {\n+                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field index\");         \n+            }\n+        });\n+        e.end_method();\n+    }\n+\n+    // TODO: if this is used to enhance class files SWITCH_STYLE_TRIE should be used\n+    // to avoid JVM hashcode implementation incompatibilities\n+    private void getField(String[] names) throws Exception {\n+        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_GET, null);\n+        e.load_this();\n+        e.load_arg(0);\n+        EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                Type type = (Type)fields.get(key);\n+                e.getfield((String)key);\n+                e.box(type);\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\n+            }\n+        });\n+        e.end_method();\n+    }\n+\n+    private void setField(String[] names) throws Exception {\n+        final CodeEmitter e = begin_method(Constants.ACC_PUBLIC, PROVIDER_SET, null);\n+        e.load_this();\n+        e.load_arg(1);\n+        e.load_arg(0);\n+        EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() {\n+            public void processCase(Object key, Label end) {\n+                Type type = (Type)fields.get(key);\n+                e.unbox(type);\n+                e.putfield((String)key);\n+                e.return_value();\n+            }\n+            public void processDefault() {\n+                e.throw_exception(ILLEGAL_ARGUMENT_EXCEPTION, \"Unknown field name\");\n+            }\n+        });\n+        e.end_method();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/InterceptFieldCallback.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+/**\n+ * @author Juozas Baliuka\n+ */\n+public interface InterceptFieldCallback {\n+    \n+    int writeInt(Object obj, String name, int oldValue, int newValue);\n+    char writeChar(Object obj, String name, char oldValue, char newValue);\n+    byte writeByte(Object obj, String name, byte oldValue, byte newValue);\n+    boolean writeBoolean(Object obj, String name, boolean oldValue, boolean newValue);\n+    short writeShort(Object obj, String name, short oldValue, short newValue);\n+    float writeFloat(Object obj, String name, float oldValue, float newValue);\n+    double writeDouble(Object obj, String name, double oldValue, double newValue);\n+    long writeLong(Object obj, String name, long oldValue, long newValue);\n+    Object writeObject(Object obj, String name, Object oldValue, Object newValue);\n+\n+    int readInt(Object obj, String name, int oldValue);\n+    char readChar(Object obj, String name, char oldValue);\n+    byte readByte(Object obj, String name, byte oldValue);\n+    boolean readBoolean(Object obj, String name, boolean oldValue);\n+    short readShort(Object obj, String name, short oldValue);\n+    float readFloat(Object obj, String name, float oldValue);\n+    double readDouble(Object obj, String name, double oldValue);\n+    long readLong(Object obj, String name, long oldValue);\n+    Object readObject(Object obj, String name, Object oldValue);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/InterceptFieldEnabled.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+public interface InterceptFieldEnabled {\n+    void setInterceptFieldCallback(InterceptFieldCallback callback);\n+    InterceptFieldCallback getInterceptFieldCallback();\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/InterceptFieldFilter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import org.mockito.asm.Type;\n+\n+public interface InterceptFieldFilter {\n+    boolean acceptRead(Type owner, String name);\n+    boolean acceptWrite(Type owner, String name);\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/InterceptFieldTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.MethodAdapter;\n+import org.mockito.asm.MethodVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+/**\n+ * @author Juozas Baliuka, Chris Nokleberg\n+ */\n+public class InterceptFieldTransformer extends ClassEmitterTransformer {\n+    private static final String CALLBACK_FIELD = \"$CGLIB_READ_WRITE_CALLBACK\";\n+    private static final Type CALLBACK =\n+      TypeUtils.parseType(\"org.mockito.cglib.transform.impl.InterceptFieldCallback\");\n+    private static final Type ENABLED =\n+      TypeUtils.parseType(\"org.mockito.cglib.transform.impl.InterceptFieldEnabled\");\n+    private static final Signature ENABLED_SET =\n+      new Signature(\"setInterceptFieldCallback\", Type.VOID_TYPE, new Type[]{ CALLBACK });\n+    private static final Signature ENABLED_GET =\n+      new Signature(\"getInterceptFieldCallback\", CALLBACK, new Type[0]);\n+\n+    private InterceptFieldFilter filter;\n+    \n+    public InterceptFieldTransformer(InterceptFieldFilter filter) {\n+        this.filter = filter;\n+    }\n+    \n+    public void begin_class(int version, int access, String className, Type superType, Type[] interfaces, String sourceFile) {\n+        if (!TypeUtils.isInterface(access)) {\n+            super.begin_class(version, access, className, superType, TypeUtils.add(interfaces, ENABLED), sourceFile);\n+                    \n+            super.declare_field(Constants.ACC_PRIVATE | Constants.ACC_TRANSIENT,\n+                                CALLBACK_FIELD,\n+                                CALLBACK,\n+                                null);\n+\n+            CodeEmitter e;\n+            e = super.begin_method(Constants.ACC_PUBLIC, ENABLED_GET, null);\n+            e.load_this();\n+            e.getfield(CALLBACK_FIELD);\n+            e.return_value();\n+            e.end_method();\n+                \n+            e = super.begin_method(Constants.ACC_PUBLIC, ENABLED_SET, null);\n+            e.load_this();\n+            e.load_arg(0);\n+            e.putfield(CALLBACK_FIELD);\n+            e.return_value();\n+            e.end_method();\n+        } else {\n+            super.begin_class(version, access, className, superType, interfaces, sourceFile);\n+        }\n+    }\n+\n+    public void declare_field(int access, String name, Type type, Object value) {\n+        super.declare_field(access, name, type, value);\n+        if (!TypeUtils.isStatic(access)) {\n+            if (filter.acceptRead(getClassType(), name)) {\n+                addReadMethod(name, type);\n+            }\n+            if (filter.acceptWrite(getClassType(), name)) {\n+                addWriteMethod(name, type);\n+            }\n+        }\n+    }\n+\n+    private void addReadMethod(String name, Type type) {\n+        CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC,\n+                                           readMethodSig(name, type.getDescriptor()),\n+                                           null);\n+        e.load_this();\n+        e.getfield(name);\n+        e.load_this();\n+        e.invoke_interface(ENABLED,ENABLED_GET);\n+        Label intercept = e.make_label();\n+        e.ifnonnull(intercept);\n+        e.return_value();\n+\n+        e.mark(intercept);\n+        Local result = e.make_local(type);\n+        e.store_local(result);\n+        e.load_this();\n+        e.invoke_interface(ENABLED,ENABLED_GET);\n+        e.load_this();\n+        e.push(name);\n+        e.load_local(result);\n+        e.invoke_interface(CALLBACK, readCallbackSig(type));\n+        if (!TypeUtils.isPrimitive(type)) {\n+            e.checkcast(type);\n+        }\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void addWriteMethod(String name, Type type) {\n+        CodeEmitter e = super.begin_method(Constants.ACC_PUBLIC,\n+                                           writeMethodSig(name, type.getDescriptor()),\n+                                           null);\n+        e.load_this();\n+        e.dup();\n+        e.invoke_interface(ENABLED,ENABLED_GET);\n+        Label skip = e.make_label();\n+        e.ifnull(skip);\n+\n+        e.load_this();\n+        e.invoke_interface(ENABLED,ENABLED_GET);\n+        e.load_this();\n+        e.push(name);\n+        e.load_this();\n+        e.getfield(name);\n+        e.load_arg(0);\n+        e.invoke_interface(CALLBACK, writeCallbackSig(type));\n+        if (!TypeUtils.isPrimitive(type)) {\n+            e.checkcast(type);\n+        }\n+        Label go = e.make_label();\n+        e.goTo(go);\n+        e.mark(skip);\n+        e.load_arg(0);\n+        e.mark(go);\n+        e.putfield(name);\n+        e.return_value();\n+        e.end_method();\n+    }\n+                \n+    public CodeEmitter begin_method(int access, Signature sig, Type[] exceptions) {\n+        return new CodeEmitter(super.begin_method(access, sig, exceptions)) {\n+            public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n+                Type towner = TypeUtils.fromInternalName(owner);\n+                switch (opcode) {\n+                case Constants.GETFIELD:\n+                    if (filter.acceptRead(towner, name)) {\n+                        helper(towner, readMethodSig(name, desc));\n+                        return;\n+                    }\n+                    break;\n+                case Constants.PUTFIELD:\n+                    if (filter.acceptWrite(towner, name)) {\n+                        helper(towner, writeMethodSig(name, desc));\n+                        return;\n+                    }\n+                    break;\n+                }\n+                super.visitFieldInsn(opcode, owner, name, desc);\n+            }\n+\n+            private void helper(Type owner, Signature sig) {\n+                invoke_virtual(owner, sig);\n+            }\n+        };\n+    }\n+\n+    private static Signature readMethodSig(String name, String desc) {\n+        return new Signature(\"$cglib_read_\" + name, \"()\" + desc);\n+    }\n+\n+    private static Signature writeMethodSig(String name, String desc) {\n+        return new Signature(\"$cglib_write_\" + name, \"(\" + desc + \")V\");\n+    }\n+\n+    private static Signature readCallbackSig(Type type) {\n+        Type remap = remap(type);\n+        return new Signature(\"read\" + callbackName(remap),\n+                             remap,\n+                             new Type[]{ Constants.TYPE_OBJECT,\n+                                         Constants.TYPE_STRING,\n+                                         remap });\n+    }\n+\n+    private static Signature writeCallbackSig(Type type) {\n+        Type remap = remap(type);\n+        return new Signature(\"write\" + callbackName(remap),\n+                             remap,\n+                             new Type[]{ Constants.TYPE_OBJECT,\n+                                         Constants.TYPE_STRING,\n+                                         remap,\n+                                         remap });\n+    }\n+\n+    private static Type remap(Type type) {\n+        switch (type.getSort()) {\n+        case Type.OBJECT:\n+        case Type.ARRAY:\n+            return Constants.TYPE_OBJECT;\n+        default:\n+            return type;\n+        }\n+    }\n+\n+    private static String callbackName(Type type) {\n+        return (type == Constants.TYPE_OBJECT) ?\n+            \"Object\" :\n+            TypeUtils.upperFirst(TypeUtils.getClassName(type));\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/UndeclaredThrowableStrategy.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+/**\n+ * A {@link GeneratorStrategy} suitable for use with {@link org.mockito.cglib.Enhancer} which\n+ * causes all undeclared exceptions thrown from within a proxied method to be wrapped\n+ * in an alternative exception of your choice.\n+ */\n+public class UndeclaredThrowableStrategy extends DefaultGeneratorStrategy {\n+    private ClassTransformer t;\n+\n+    /**\n+     * Create a new instance of this strategy.\n+     * @param wrapper a class which extends either directly or\n+     * indirectly from <code>Throwable</code> and which has at least one\n+     * constructor that takes a single argument of type\n+     * <code>Throwable</code>, for example\n+     * <code>java.lang.reflect.UndeclaredThrowableException.class</code>\n+     */\n+    public UndeclaredThrowableStrategy(Class wrapper) {\n+        t = new UndeclaredThrowableTransformer(wrapper);\n+        t = new MethodFilterTransformer(TRANSFORM_FILTER, t);\n+    }\n+    \n+    private static final MethodFilter TRANSFORM_FILTER = new MethodFilter() {\n+        public boolean accept(int access, String name, String desc, String signature, String[] exceptions) {\n+            return !TypeUtils.isPrivate(access) && name.indexOf('$') < 0;\n+        }\n+    };\n+\n+    protected ClassGenerator transform(ClassGenerator cg) throws Exception {\n+        return new TransformingClassGenerator(cg, t);\n+    }\n+}\n+\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/transform/impl/UndeclaredThrowableTransformer.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.transform.impl;\n+\n+import java.lang.reflect.Constructor;\n+\n+import org.mockito.asm.Attribute;\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+import org.mockito.cglib.transform.*;\n+\n+public class UndeclaredThrowableTransformer extends ClassEmitterTransformer {\n+    private Type wrapper;\n+\n+    public UndeclaredThrowableTransformer(Class wrapper) {\n+        this.wrapper = Type.getType(wrapper);\n+        boolean found = false;\n+        Constructor[] cstructs = wrapper.getConstructors();\n+        for (int i = 0; i < cstructs.length; i++) {\n+            Class[] types = cstructs[i].getParameterTypes();\n+            if (types.length == 1 && types[0].equals(Throwable.class)) {\n+                found = true;\n+                break;\n+            }\n+        }\n+        if (!found)\n+            throw new IllegalArgumentException(wrapper + \" does not have a single-arg constructor that takes a Throwable\");\n+    }\n+\n+    public CodeEmitter begin_method(int access, final Signature sig, final Type[] exceptions) {\n+        CodeEmitter e = super.begin_method(access, sig, exceptions);\n+        if (TypeUtils.isAbstract(access) || sig.equals(Constants.SIG_STATIC)) {\n+            return e;\n+        }\n+        return new CodeEmitter(e) {\n+            private Block handler;\n+            /* init */ {\n+                handler = begin_block();\n+            }\n+            public void visitMaxs(int maxStack, int maxLocals) {\n+                handler.end();\n+                EmitUtils.wrap_undeclared_throwable(this, handler, exceptions, wrapper);\n+                super.visitMaxs(maxStack, maxLocals);\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/util/ParallelSorter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.util;\n+\n+import java.lang.reflect.*;\n+import java.util.Comparator;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * For the efficient sorting of multiple arrays in parallel.\n+ * <p>\n+ * Given two arrays of equal length and varying types, the standard\n+ * technique for sorting them in parallel is to create a new temporary\n+ * object for each row, store the objects in a temporary array, sort the\n+ * array using a custom comparator, and the extract the original values\n+ * back into their respective arrays. This is wasteful in both time and\n+ * memory.\n+ * <p>\n+ * This class generates bytecode customized to the particular set of\n+ * arrays you need to sort, in such a way that both arrays are sorted\n+ * in-place, simultaneously.\n+ * <p>\n+ * Two sorting algorithms are provided.\n+ * Quicksort is best when you only need to sort by a single column, as\n+ * it requires very few comparisons and swaps. Mergesort is best used\n+ * when sorting multiple columns, as it is a \"stable\" sort--that is, it\n+ * does not affect the relative order of equal objects from previous sorts.\n+ * <p>\n+ * The mergesort algorithm here is an \"in-place\" variant, which while\n+ * slower, does not require a temporary array.\n+ *\n+ * @author Chris Nokleberg\n+ */\n+abstract public class ParallelSorter extends SorterTemplate {\n+    protected Object[] a;\n+    private Comparer comparer;\n+    \n+    protected ParallelSorter() {\n+    }\n+\n+    abstract public ParallelSorter newInstance(Object[] arrays);\n+\n+    /**\n+     * Create a new ParallelSorter object for a set of arrays. You may\n+     * sort the arrays multiple times via the same ParallelSorter object.\n+     * @param arrays An array of arrays to sort. The arrays may be a mix\n+     * of primitive and non-primitive types, but should all be the same\n+     * length.\n+     * @param loader ClassLoader for generated class, uses \"current\" if null\n+     */\n+    public static ParallelSorter create(Object[] arrays) {\n+        Generator gen = new Generator();\n+        gen.setArrays(arrays);\n+        return gen.create();\n+    }\n+\n+    private int len() {\n+        return ((Object[])a[0]).length;\n+    }\n+\n+    /**\n+     * Sort the arrays using the quicksort algorithm.\n+     * @param index array (column) to sort by\n+     */\n+    public void quickSort(int index) {\n+        quickSort(index, 0, len(), null);\n+    }\n+\n+    /**\n+     * Sort the arrays using the quicksort algorithm.\n+     * @param index array (column) to sort by\n+     * @param lo starting array index (row), inclusive\n+     * @param hi ending array index (row), exclusive\n+     */\n+    public void quickSort(int index, int lo, int hi) {\n+        quickSort(index, lo, hi, null);\n+    }\n+\n+    /**\n+     * Sort the arrays using the quicksort algorithm.\n+     * @param index array (column) to sort by\n+     * @param cmp Comparator to use if the specified column is non-primitive\n+     */\n+    public void quickSort(int index, Comparator cmp) {\n+        quickSort(index, 0, len(), cmp);\n+    }\n+\n+    /**\n+     * Sort the arrays using the quicksort algorithm.\n+     * @param index array (column) to sort by\n+     * @param lo starting array index (row), inclusive\n+     * @param hi ending array index (row), exclusive\n+     * @param cmp Comparator to use if the specified column is non-primitive\n+     */\n+    public void quickSort(int index, int lo, int hi, Comparator cmp) {\n+        chooseComparer(index, cmp);\n+        super.quickSort(lo, hi - 1);\n+    }\n+\n+    /**\n+     * @param index array (column) to sort by\n+     */\n+    public void mergeSort(int index) {\n+        mergeSort(index, 0, len(), null);\n+    }\n+\n+    /**\n+     * Sort the arrays using an in-place merge sort.\n+     * @param index array (column) to sort by\n+     * @param lo starting array index (row), inclusive\n+     * @param hi ending array index (row), exclusive\n+     */\n+    public void mergeSort(int index, int lo, int hi) {\n+        mergeSort(index, lo, hi, null);\n+    }\n+\n+    /**\n+     * Sort the arrays using an in-place merge sort.\n+     * @param index array (column) to sort by\n+     * @param lo starting array index (row), inclusive\n+     * @param hi ending array index (row), exclusive\n+     */\n+    public void mergeSort(int index, Comparator cmp) {\n+        mergeSort(index, 0, len(), cmp);\n+    }\n+\n+    /**\n+     * Sort the arrays using an in-place merge sort.\n+     * @param index array (column) to sort by\n+     * @param lo starting array index (row), inclusive\n+     * @param hi ending array index (row), exclusive\n+     * @param cmp Comparator to use if the specified column is non-primitive\n+     */\n+    public void mergeSort(int index, int lo, int hi, Comparator cmp) {\n+        chooseComparer(index, cmp);\n+        super.mergeSort(lo, hi - 1);\n+    }\n+    \n+    private void chooseComparer(int index, Comparator cmp) {\n+        Object array = a[index];\n+        Class type = array.getClass().getComponentType();\n+        if (type.equals(Integer.TYPE)) {\n+            comparer = new IntComparer((int[])array);\n+        } else if (type.equals(Long.TYPE)) {\n+            comparer = new LongComparer((long[])array);\n+        } else if (type.equals(Double.TYPE)) {\n+            comparer = new DoubleComparer((double[])array);\n+        } else if (type.equals(Float.TYPE)) {\n+            comparer = new FloatComparer((float[])array);\n+        } else if (type.equals(Short.TYPE)) {\n+            comparer = new ShortComparer((short[])array);\n+        } else if (type.equals(Byte.TYPE)) {\n+            comparer = new ByteComparer((byte[])array);\n+        } else if (cmp != null) {\n+            comparer = new ComparatorComparer((Object[])array, cmp);\n+        } else {\n+            comparer = new ObjectComparer((Object[])array);\n+        } \n+    }\n+\n+    protected int compare(int i, int j) {\n+        return comparer.compare(i, j);\n+    }\n+\n+    interface Comparer {\n+        int compare(int i, int j);\n+    }\n+\n+    static class ComparatorComparer implements Comparer {\n+        private Object[] a;\n+        private Comparator cmp;\n+\n+        public ComparatorComparer(Object[] a, Comparator cmp) {\n+            this.a = a;\n+            this.cmp = cmp;\n+        }\n+\n+        public int compare(int i, int j) {\n+            return cmp.compare(a[i], a[j]);\n+        }\n+    }\n+    \n+    static class ObjectComparer implements Comparer {\n+        private Object[] a;\n+        public ObjectComparer(Object[] a) { this.a = a; }\n+        public int compare(int i, int j) {\n+            return ((Comparable)a[i]).compareTo(a[j]);\n+        }\n+    }\n+\n+    static class IntComparer implements Comparer {\n+        private int[] a;\n+        public IntComparer(int[] a) { this.a = a; }\n+        public int compare(int i, int j) { return a[i] - a[j]; }\n+    }\n+\n+    static class LongComparer implements Comparer {\n+        private long[] a;\n+        public LongComparer(long[] a) { this.a = a; }\n+        public int compare(int i, int j) {\n+            long vi = a[i];\n+            long vj = a[j];\n+            return (vi == vj) ? 0 : (vi > vj) ? 1 : -1;\n+        }\n+    }\n+\n+    static class FloatComparer implements Comparer {\n+        private float[] a;\n+        public FloatComparer(float[] a) { this.a = a; }\n+        public int compare(int i, int j) {\n+            float vi = a[i];\n+            float vj = a[j];\n+            return (vi == vj) ? 0 : (vi > vj) ? 1 : -1;\n+        }\n+    }\n+    \n+    static class DoubleComparer implements Comparer {\n+        private double[] a;\n+        public DoubleComparer(double[] a) { this.a = a; }\n+        public int compare(int i, int j) {\n+            double vi = a[i];\n+            double vj = a[j];\n+            return (vi == vj) ? 0 : (vi > vj) ? 1 : -1;\n+        }\n+    }\n+\n+    static class ShortComparer implements Comparer {\n+        private short[] a;\n+        public ShortComparer(short[] a) { this.a = a; }\n+        public int compare(int i, int j) { return a[i] - a[j]; }\n+    }\n+\n+    static class ByteComparer implements Comparer {\n+        private byte[] a;\n+        public ByteComparer(byte[] a) { this.a = a; }\n+        public int compare(int i, int j) { return a[i] - a[j]; }\n+    }\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(ParallelSorter.class.getName());\n+\n+        private Object[] arrays;\n+\n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return null; // TODO\n+        }\n+\n+        public void setArrays(Object[] arrays) {\n+            this.arrays = arrays;\n+        }\n+\n+        public ParallelSorter create() {\n+            return (ParallelSorter)super.create(ClassesKey.create(arrays));\n+        }\n+\n+        public void generateClass(ClassVisitor v) throws Exception {\n+            if (arrays.length == 0) {\n+                throw new IllegalArgumentException(\"No arrays specified to sort\");\n+            }\n+            for (int i = 0; i < arrays.length; i++) {\n+                if (!arrays[i].getClass().isArray()) {\n+                    throw new IllegalArgumentException(arrays[i].getClass() + \" is not an array\");\n+                }\n+            }\n+            new ParallelSorterEmitter(v, getClassName(), arrays);\n+        }\n+        \n+        protected Object firstInstance(Class type) {\n+            return ((ParallelSorter)ReflectUtils.newInstance(type)).newInstance(arrays);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return ((ParallelSorter)instance).newInstance(arrays);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/util/ParallelSorterEmitter.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.util;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+class ParallelSorterEmitter extends ClassEmitter {\n+    private static final Type PARALLEL_SORTER =\n+      TypeUtils.parseType(\"org.mockito.cglib.util.ParallelSorter\");\n+    private static final Signature CSTRUCT_OBJECT_ARRAY =\n+      TypeUtils.parseConstructor(\"Object[]\");\n+    private static final Signature NEW_INSTANCE =\n+      new Signature(\"newInstance\", PARALLEL_SORTER, new Type[]{ Constants.TYPE_OBJECT_ARRAY });\n+    private static final Signature SWAP =\n+      TypeUtils.parseSignature(\"void swap(int, int)\");\n+\n+    public ParallelSorterEmitter(ClassVisitor v, String className, Object[] arrays) {\n+        super(v);\n+        begin_class(Constants.V1_2, Constants.ACC_PUBLIC, className, PARALLEL_SORTER, null, Constants.SOURCE_FILE);\n+        EmitUtils.null_constructor(this);\n+        EmitUtils.factory_method(this, NEW_INSTANCE);\n+        generateConstructor(arrays);\n+        generateSwap(arrays);\n+        end_class();\n+    }\n+\n+    private String getFieldName(int index) {\n+        return \"FIELD_\" + index;\n+    }\n+\n+    private void generateConstructor(Object[] arrays) {\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, CSTRUCT_OBJECT_ARRAY, null);\n+        e.load_this();\n+        e.super_invoke_constructor();\n+        e.load_this();\n+        e.load_arg(0);\n+        e.super_putfield(\"a\", Constants.TYPE_OBJECT_ARRAY);\n+        for (int i = 0; i < arrays.length; i++) {\n+            Type type = Type.getType(arrays[i].getClass());\n+            declare_field(Constants.ACC_PRIVATE, getFieldName(i), type, null);\n+            e.load_this();\n+            e.load_arg(0);\n+            e.push(i);\n+            e.aaload();\n+            e.checkcast(type);\n+            e.putfield(getFieldName(i));\n+        }\n+        e.return_value();\n+        e.end_method();\n+    }\n+\n+    private void generateSwap(final Object[] arrays) {\n+        CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SWAP, null);\n+        for (int i = 0; i < arrays.length; i++) {\n+            Type type = Type.getType(arrays[i].getClass());\n+            Type component = TypeUtils.getComponentType(type);\n+            Local T = e.make_local(type);\n+\n+            e.load_this();\n+            e.getfield(getFieldName(i));\n+            e.store_local(T);\n+\n+            e.load_local(T);\n+            e.load_arg(0);\n+\n+            e.load_local(T);\n+            e.load_arg(1);\n+            e.array_load(component);\n+                \n+            e.load_local(T);\n+            e.load_arg(1);\n+\n+            e.load_local(T);\n+            e.load_arg(0);\n+            e.array_load(component);\n+\n+            e.array_store(component);\n+            e.array_store(component);\n+        }\n+        e.return_value();\n+        e.end_method();\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/util/SorterTemplate.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.util;\n+\n+import java.util.*;\n+\n+abstract class SorterTemplate {\n+    private static final int MERGESORT_THRESHOLD = 12;\n+    private static final int QUICKSORT_THRESHOLD = 7;\n+\n+    abstract protected void swap(int i, int j);\n+    abstract protected int compare(int i, int j);\n+\n+    protected void quickSort(int lo, int hi) {\n+        quickSortHelper(lo, hi);\n+        insertionSort(lo, hi);\n+    }\n+\n+    private void quickSortHelper(int lo, int hi) {\n+        for (;;) {\n+            int diff = hi - lo;\n+            if (diff <= QUICKSORT_THRESHOLD) {\n+                break;\n+            }\n+            int i = (hi + lo) / 2;\n+            if (compare(lo, i) > 0) {\n+                swap(lo, i);\n+            }\n+            if (compare(lo, hi) > 0) {\n+                swap(lo, hi);\n+            }\n+            if (compare(i, hi) > 0) {\n+                swap(i, hi);\n+            }\n+            int j = hi - 1;\n+            swap(i, j);\n+            i = lo;\n+            int v = j;\n+            for (;;) {\n+                while (compare(++i, v) < 0) {\n+                    /* nothing */;\n+                }\n+                while (compare(--j, v) > 0) {\n+                    /* nothing */;\n+                }\n+                if (j < i) {\n+                    break;\n+                }\n+                swap(i, j);\n+            }\n+            swap(i, hi - 1);\n+            if (j - lo <= hi - i + 1) {\n+                quickSortHelper(lo, j);\n+                lo = i + 1;\n+            } else {\n+                quickSortHelper(i + 1, hi);\n+                hi = j;\n+            }\n+        }\n+    }\n+    \n+    private void insertionSort(int lo, int hi) {\n+        for (int i = lo + 1 ; i <= hi; i++) {\n+            for (int j = i; j > lo; j--) {\n+                if (compare(j - 1, j) > 0) {\n+                    swap(j - 1, j);\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void mergeSort(int lo, int hi) {\n+        int diff = hi - lo;\n+        if (diff <= MERGESORT_THRESHOLD) {\n+            insertionSort(lo, hi);\n+            return;\n+        }\n+        int mid = lo + diff / 2;\n+        mergeSort(lo, mid);\n+        mergeSort(mid, hi);\n+        merge(lo, mid, hi, mid - lo, hi - mid);\n+    }\n+\n+    private void merge(int lo, int pivot, int hi, int len1, int len2) {\n+        if (len1 == 0 || len2 == 0) {\n+            return;\n+        }\n+        if (len1 + len2 == 2) {\n+            if (compare(pivot, lo) < 0) {\n+                swap(pivot, lo);\n+            }\n+            return;\n+        }\n+        int first_cut, second_cut;\n+        int len11, len22;\n+        if (len1 > len2) {\n+            len11 = len1 / 2;\n+            first_cut = lo + len11;\n+            second_cut = lower(pivot, hi, first_cut);\n+            len22 = second_cut - pivot;\n+        } else {\n+            len22 = len2 / 2;\n+            second_cut = pivot + len22;\n+            first_cut = upper(lo, pivot, second_cut);\n+            len11 = first_cut - lo;\n+        }\n+        rotate(first_cut, pivot, second_cut);\n+        int new_mid = first_cut + len22;\n+        merge(lo, first_cut, new_mid, len11, len22);\n+        merge(new_mid, second_cut, hi, len1 - len11, len2 - len22);\n+    }\n+\n+    private void rotate(int lo, int mid, int hi) {\n+        int lot = lo;\n+        int hit = mid - 1;\n+        while (lot < hit) {\n+            swap(lot++, hit--);\n+        }\n+        lot = mid; hit = hi - 1;\n+        while (lot < hit) {\n+            swap(lot++, hit--);\n+        }\n+        lot = lo; hit = hi - 1;\n+        while (lot < hit) {\n+            swap(lot++, hit--);\n+        }\n+    }\n+\n+    private int lower(int lo, int hi, int val) {\n+        int len = hi - lo;\n+        while (len > 0) {\n+            int half = len / 2;\n+            int mid= lo + half;\n+            if (compare(mid, val) < 0) {\n+                lo = mid + 1;\n+                len = len - half -1;\n+            } else {\n+                len = half;\n+            }\n+        }\n+        return lo;\n+    }\n+\n+    private int upper(int lo, int hi, int val) {\n+        int len = hi - lo;\n+        while (len > 0) {\n+            int half = len / 2;\n+            int mid = lo + half;\n+            if (compare(val, mid) < 0) {\n+                len = half;\n+            } else {\n+                lo = mid + 1;\n+                len = len - half -1;\n+            }\n+        }\n+        return lo;\n+    }\n+}\n--- /dev/null\n+++ b/cglib-and-asm/src/org/mockito/cglib/util/StringSwitcher.java\n+/*\n+ * Copyright 2003 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.mockito.cglib.util;\n+\n+import java.util.*;\n+\n+import org.mockito.asm.ClassVisitor;\n+import org.mockito.asm.Label;\n+import org.mockito.asm.Type;\n+import org.mockito.cglib.core.*;\n+\n+/**\n+ * This class implements a simple String->int mapping for a fixed set of keys.\n+ */\n+abstract public class StringSwitcher {\n+    private static final Type STRING_SWITCHER =\n+      TypeUtils.parseType(\"org.mockito.cglib.util.StringSwitcher\");\n+    private static final Signature INT_VALUE =\n+      TypeUtils.parseSignature(\"int intValue(String)\");\n+    private static final StringSwitcherKey KEY_FACTORY =\n+      (StringSwitcherKey)KeyFactory.create(StringSwitcherKey.class);\n+\n+    interface StringSwitcherKey {\n+        public Object newInstance(String[] strings, int[] ints, boolean fixedInput);\n+    }\n+\n+    /**\n+     * Helper method to create a StringSwitcher.\n+     * For finer control over the generated instance, use a new instance of StringSwitcher.Generator\n+     * instead of this static method.\n+     * @param strings the array of String keys; must be the same length as the value array\n+     * @param ints the array of integer results; must be the same length as the key array\n+     * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\n+     * the result will be undefined, and the resulting code will be faster\n+     */\n+    public static StringSwitcher create(String[] strings, int[] ints, boolean fixedInput) {\n+        Generator gen = new Generator();\n+        gen.setStrings(strings);\n+        gen.setInts(ints);\n+        gen.setFixedInput(fixedInput);\n+        return gen.create();\n+    }\n+\n+    protected StringSwitcher() {\n+    }\n+\n+    /**\n+     * Return the integer associated with the given key.\n+     * @param s the key\n+     * @return the associated integer value, or <code>-1</code> if the key is unknown (unless\n+     * <code>fixedInput</code> was specified when this <code>StringSwitcher</code> was created,\n+     * in which case the return value for an unknown key is undefined)\n+     */\n+    abstract public int intValue(String s);\n+\n+    public static class Generator extends AbstractClassGenerator {\n+        private static final Source SOURCE = new Source(StringSwitcher.class.getName());\n+\n+        private String[] strings;\n+        private int[] ints;\n+        private boolean fixedInput;\n+        \n+        public Generator() {\n+            super(SOURCE);\n+        }\n+\n+        /**\n+         * Set the array of recognized Strings.\n+         * @param strings the array of String keys; must be the same length as the value array\n+         * @see #setInts\n+         */\n+        public void setStrings(String[] strings) {\n+            this.strings = strings;\n+        }\n+\n+        /**\n+         * Set the array of integer results.\n+         * @param ints the array of integer results; must be the same length as the key array\n+         * @see #setStrings\n+         */\n+        public void setInts(int[] ints) {\n+            this.ints = ints;\n+        }\n+\n+        /**\n+         * Configure how unknown String keys will be handled.\n+         * @param fixedInput if false, an unknown key will be returned from {@link #intValue} as <code>-1</code>; if true,\n+         * the result will be undefined, and the resulting code will be faster\n+         */\n+        public void setFixedInput(boolean fixedInput) {\n+            this.fixedInput = fixedInput;\n+        }\n+\n+        protected ClassLoader getDefaultClassLoader() {\n+            return getClass().getClassLoader();\n+        }\n+\n+        /**\n+         * Generate the <code>StringSwitcher</code>.\n+         */\n+        public StringSwitcher create() {\n+            setNamePrefix(StringSwitcher.class.getName());\n+            Object key = KEY_FACTORY.newInstance(strings, ints, fixedInput);\n+            return (StringSwitcher)super.create(key);\n+        }\n+\n+        public void generateClass(ClassVisitor v) throws Exception {\n+            ClassEmitter ce = new ClassEmitter(v);\n+            ce.begin_class(Constants.V1_2,\n+                           Constants.ACC_PUBLIC,\n+                           getClassName(),\n+                           STRING_SWITCHER,\n+                           null,\n+                           Constants.SOURCE_FILE);\n+            EmitUtils.null_constructor(ce);\n+            final CodeEmitter e = ce.begin_method(Constants.ACC_PUBLIC, INT_VALUE, null);\n+            e.load_arg(0);\n+            final List stringList = Arrays.asList(strings);\n+            int style = fixedInput ? Constants.SWITCH_STYLE_HASHONLY : Constants.SWITCH_STYLE_HASH;\n+            EmitUtils.string_switch(e, strings, style, new ObjectSwitchCallback() {\n+                public void processCase(Object key, Label end) {\n+                    e.push(ints[stringList.indexOf(key)]);\n+                    e.return_value();\n+                }\n+                public void processDefault() {\n+                    e.push(-1);\n+                    e.return_value();\n+                }\n+            });\n+            e.end_method();\n+            ce.end_class();\n+        }\n+\n+        protected Object firstInstance(Class type) {\n+            return (StringSwitcher)ReflectUtils.newInstance(type);\n+        }\n+\n+        protected Object nextInstance(Object instance) {\n+            return instance;\n+        }\n+    }\n+}", "timestamp": 1242305012, "metainfo": ""}