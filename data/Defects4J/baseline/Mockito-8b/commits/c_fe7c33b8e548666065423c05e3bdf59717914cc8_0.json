{"sha": "fe7c33b8e548666065423c05e3bdf59717914cc8", "log": "renamed a class and added a TODO  --HG-- rename : src/org/mockito/internal/invocation/MockitoMethod.java => src/org/mockito/internal/invocation/SerializableMethod.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401667", "commit": "\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n         cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n         \n         FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n-        MockitoMethod mockitoMethod = new MockitoMethod(method);\n-        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n+        SerializableMethod serializableMethod = new SerializableMethod(method);\n+        Invocation invocation = new Invocation(proxy, serializableMethod, args, SequenceNumber.next(), realMethod);\n         return mockHandler.handle(invocation);\n     }\n     \n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     private static final int MAX_LINE_LENGTH = 45;\n     private final int sequenceNumber;\n     private final Object mock;\n-    private final MockitoMethod method;\n+    private final SerializableMethod method;\n     private final Object[] arguments;\n     private final Object[] rawArguments;\n \n \n     final RealMethod realMethod;\n \n-    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n-        this.method = mockitoMethod;\n+    public Invocation(Object mock, SerializableMethod serializableMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n+        this.method = serializableMethod;\n         this.mock = mock;\n         this.realMethod = realMethod;\n-        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n+        this.arguments = expandVarArgs(serializableMethod.isVarArgs(), args);\n         this.rawArguments = args;\n         this.sequenceNumber = sequenceNumber;\n         this.location = new Location();\n         return mock;\n     }\n \n-    public MockitoMethod getMethod() {\n+    public SerializableMethod getMethod() {\n         return method;\n     }\n \n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n         this(invocation, Collections.<Matcher>emptyList());\n     }\n \n-    public MockitoMethod getMethod() {\n+    public SerializableMethod getMethod() {\n         return invocation.getMethod();\n     }\n     \n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/SerializableMethod.java\n+package org.mockito.internal.invocation;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+public class SerializableMethod implements Serializable {\n+\n+    private static final long serialVersionUID = 6005610965006048445L;\n+    private Class<?> declaringClass;\n+    private String methodName;\n+    private Class<?>[] parameterTypes;\n+    private Class<?> returnType;\n+    private Class<?>[] exceptionTypes;\n+    private boolean isVarArgs;\n+\n+    public SerializableMethod(Method method) {\n+        declaringClass = method.getDeclaringClass();\n+        methodName = method.getName();\n+        parameterTypes = method.getParameterTypes();\n+        returnType = method.getReturnType();\n+        exceptionTypes = method.getExceptionTypes();\n+        isVarArgs = method.isVarArgs();\n+    }\n+\n+    public String getName() {\n+        return methodName;\n+    }\n+\n+    public Class<?> getReturnType() {\n+        return returnType;\n+    }\n+\n+    public Class<?>[] getParameterTypes() {\n+        return parameterTypes;\n+    }\n+\n+    public Class<?>[] getExceptionTypes() {\n+        return exceptionTypes;\n+    }\n+\n+    public boolean isVarArgs() {\n+        return isVarArgs;\n+    }\n+    \n+    public boolean isDeclaredOnInterface() {\n+        return declaringClass.isInterface();\n+    }    \n+\n+    @Override\n+    public int hashCode() {\n+        throw new RuntimeException(\"hashCode() not implemented\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        SerializableMethod other = (SerializableMethod) obj;\n+        if (declaringClass == null) {\n+            if (other.declaringClass != null)\n+                return false;\n+        } else if (!declaringClass.equals(other.declaringClass))\n+            return false;\n+        if (methodName == null) {\n+            if (other.methodName != null)\n+                return false;\n+        } else if (!methodName.equals(other.methodName))\n+            return false;\n+        if (!Arrays.equals(parameterTypes, other.parameterTypes))\n+            return false;\n+        if (returnType == null) {\n+            if (other.returnType != null)\n+                return false;\n+        } else if (!returnType.equals(other.returnType))\n+            return false;\n+        return true;\n+    }\n+}\n--- a/src/org/mockito/internal/util/ObjectMethodsGuru.java\n+++ b/src/org/mockito/internal/util/ObjectMethodsGuru.java\n import java.io.Serializable;\n import java.lang.reflect.Method;\n \n-import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n \n public class ObjectMethodsGuru implements Serializable {\n \n     private static final long serialVersionUID = -1286718569065470494L;\n \n     public boolean isToString(Method method) {\n-        return isToString(new MockitoMethod(method));\n+        return isToString(new SerializableMethod(method));\n     }\n \n-    public boolean isToString(MockitoMethod method) {\n+    public boolean isToString(SerializableMethod method) {\n         return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n                 && method.getName().equals(\"toString\");\n     }\n--- a/src/org/mockito/invocation/InvocationOnMock.java\n+++ b/src/org/mockito/invocation/InvocationOnMock.java\n package org.mockito.invocation;\n \n import java.io.Serializable;\n-import java.lang.reflect.Method;\n \n-import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n \n /**\n  * An invocation on a mock\n      * \n      * @return method\n      */\n-    MockitoMethod getMethod();\n+    //TODO: this has to return java.reflect.method in order to keep the interface consistent\n+    SerializableMethod getMethod();\n \n     /**\n      * returns arguments passed to the method\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n             }\n         }\n         \n-        Invocation i = new Invocation(mock, new MockitoMethod(method), args, sequenceNumber, null);\n+        Invocation i = new Invocation(mock, new SerializableMethod(method), args, sequenceNumber, null);\n         if (verified) {\n             i.markVerified();\n         }\n--- a/test/org/mockito/internal/invocation/SerializableMockitoMethodTest.java\n+++ b/test/org/mockito/internal/invocation/SerializableMockitoMethodTest.java\n \n public class SerializableMockitoMethodTest extends TestBase {\n \n-    private MockitoMethod mockMethod;\n+    private SerializableMethod mockMethod;\n     private Method toStringMethod;\n     private Class<?>[] args;\n \n     public void createMethodToTestWith() throws SecurityException, NoSuchMethodException {\n         args = new Class<?>[0];\n         toStringMethod = this.getClass().getMethod(\"toString\", args);\n-        mockMethod = new MockitoMethod(toStringMethod);\n+        mockMethod = new SerializableMethod(toStringMethod);\n     }\n     \n     @Test\n     \n     @Test\n     public void shouldBeEqualForTwoInstances() throws Exception {\n-        assertTrue(new MockitoMethod(toStringMethod).equals(mockMethod));\n+        assertTrue(new SerializableMethod(toStringMethod).equals(mockMethod));\n     }\n     \n     @Test\n     public void shouldNotBeEqualForSameMethodFromTwoDifferentClasses() throws Exception {\n         Method testBaseToStringMethod = String.class.getMethod(\"toString\", args);\n-        assertFalse(new MockitoMethod(testBaseToStringMethod).equals(mockMethod));\n+        assertFalse(new SerializableMethod(testBaseToStringMethod).equals(mockMethod));\n     }\n     \n     //TODO: add tests for generated equals() method\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n-        return new Invocation(new Object(), new MockitoMethod(type.getMethod(methodName,\n+        return new Invocation(new Object(), new SerializableMethod(type.getMethod(methodName,\n                 new Class[0])), args, 1, null);\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {\n-        return new Invocation(new Object(), new MockitoMethod(type.getMethod(methodName,\n+        return new Invocation(new Object(), new SerializableMethod(type.getMethod(methodName,\n                 new Class[0])), new Object[0], 1, realMethod);\n     }\n ", "timestamp": 1257712225, "metainfo": ""}