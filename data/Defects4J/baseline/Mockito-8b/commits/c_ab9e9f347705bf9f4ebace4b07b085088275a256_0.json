{"sha": "ab9e9f347705bf9f4ebace4b07b085088275a256", "log": "Issue 230 Adds more deep stubs support for generic classes   - metadata support extended beypond interfaces  - cleans up a bit generics metadata", "commit": "\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n package org.mockito.internal.util.reflection;\n \n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import org.mockito.Incubating;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.Checks;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.*;\n-import java.util.*;\n \n \n /**\n  * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n  */\n @Incubating\n-public abstract class GenericMetadataSupport implements Serializable {\n-\n+public abstract class GenericMetadataSupport {\n \n     // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n         for (int i = 0; i < actualTypeArguments.length; i++) {\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n-            SerializableTypeVariable serializableTypeVariable = new SerializableTypeVariable(typeParameter);\n \n             if (actualTypeArgument instanceof WildcardType) {\n-                contextualActualTypeParameters.put(serializableTypeVariable, boundsOf((WildcardType) actualTypeArgument));\n-            } else if (actualTypeArgument instanceof ParameterizedType) {\n-                contextualActualTypeParameters.put(serializableTypeVariable, new SerializableParameterizedType((ParameterizedType) actualTypeArgument));\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n             } else {\n-                contextualActualTypeParameters.put(serializableTypeVariable, actualTypeArgument);\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n-        for (TypeVariable typeParameter : typeParameters) {\n-            contextualActualTypeParameters.put(new SerializableTypeVariable(typeParameter), boundsOf(typeParameter));\n-            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        for (TypeVariable typeVariable : typeParameters) {\n+            registerTypeVariableIfNotPresent(typeVariable);\n+        }\n+    }\n+\n+    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n+        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n+            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n+            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n         }\n     }\n \n         if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n             return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n         }\n-        return new SerializableBoundedType(new TypeVarBoundedType(typeParameter));\n+        return new TypeVarBoundedType(typeParameter);\n     }\n \n     /**\n             return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n         }\n \n-        return new SerializableBoundedType(wildCardBoundedType);\n+        return wildCardBoundedType;\n     }\n \n \n      */\n     public Class<?>[] rawExtraInterfaces() {\n         return new Class[0];\n+    }\n+\n+    /**\n+     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n+     */\n+    public boolean hasRawExtraInterfaces() {\n+        return rawExtraInterfaces().length > 0;\n     }\n \n \n \n             Type actualType = getActualTypeArgumentFor(typeParameter);\n \n-            actualTypeArguments.put(new SerializableTypeVariable(typeParameter), actualType);\n+            actualTypeArguments.put(typeParameter, actualType);\n             // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n         }\n \n      * the class and its ancestors and interfaces.\n      */\n     private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n-        private Class<?> clazz;\n+        private final Class<?> clazz;\n \n         public FromClassGenericMetadataSupport(Class<?> clazz) {\n             this.clazz = clazz;\n-            readActualTypeParametersOnDeclaringClass();\n-        }\n-\n-        private void readActualTypeParametersOnDeclaringClass() {\n+\n+            for (Class currentExploredClass = clazz;\n+                 currentExploredClass != null && currentExploredClass != Object.class;\n+                 currentExploredClass = superClassOf(currentExploredClass)\n+                ) {\n+                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n+            }\n+        }\n+\n+        private Class superClassOf(Class currentExploredClass) {\n+            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n+            if (genericSuperclass instanceof ParameterizedType) {\n+                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n+                return (Class) rawType;\n+            }\n+            return (Class) genericSuperclass;\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n             registerTypeParametersOn(clazz.getTypeParameters());\n             registerTypeVariablesOn(clazz.getGenericSuperclass());\n             for (Type genericInterface : clazz.getGenericInterfaces()) {\n         }\n     }\n \n+\n     /**\n      * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n      *\n      * Instead use {@link ParameterizedReturnType}.\n      */\n     private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n-        private ParameterizedType parameterizedType;\n+        private final ParameterizedType parameterizedType;\n \n         public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n             this.parameterizedType = parameterizedType;\n         private final TypeVariable[] typeParameters;\n \n         public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n-            this.parameterizedType = new SerializableParameterizedType(parameterizedType);\n-            this.typeParameters = fromArray(typeParameters);\n+            this.parameterizedType = parameterizedType;\n+            this.typeParameters = typeParameters;\n             this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n \n             readTypeParameters();\n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class TypeVarBoundedType implements BoundedType, Serializable {\n-        private TypeVariable typeVariable;\n+    public static class TypeVarBoundedType implements BoundedType {\n+        private final TypeVariable typeVariable;\n \n \n         public TypeVarBoundedType(TypeVariable typeVariable) {\n-            this.typeVariable = new SerializableTypeVariable(typeVariable);\n+            this.typeVariable = typeVariable;\n         }\n \n         /**\n \n         @Override\n         public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound());\n-            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n-            sb.append('}');\n-            return sb.toString();\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n         }\n \n         public TypeVariable typeVariable() {\n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class WildCardBoundedType implements BoundedType, Serializable {\n-        private WildcardType wildcard;\n+    public static class WildCardBoundedType implements BoundedType {\n+        private final WildcardType wildcard;\n \n \n         public WildCardBoundedType(WildcardType wildcard) {\n \n         @Override\n         public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound());\n-            sb.append(\", interfaceBounds=[]}\");\n-            return sb.toString();\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n         }\n \n         public WildcardType wildCard() {\n         }\n     }\n \n-    private static class SerializableBound implements Type, Serializable {\n-\n-        private Class classBound;\n-\n-        private SerializableParameterizedType serializableParameterizedType;\n-\n-        public SerializableBound(Type type){\n-            if(type instanceof Class){\n-                classBound = (Class) type;\n-            } else if(type instanceof ParameterizedType) {\n-                serializableParameterizedType = new SerializableParameterizedType((ParameterizedType) type);\n-            }\n-        }\n-\n-    }\n-\n-\n-    private static class SerializableTypeVariable implements TypeVariable, Serializable {\n-\n-        private Class genericDeclaration;\n-        private String name;\n-        private SerializableBound[] bounds;\n-\n-        public SerializableTypeVariable(TypeVariable typeVariable){\n-            this.genericDeclaration = (Class) typeVariable.getGenericDeclaration();\n-            this.name = typeVariable.getName();\n-            this.bounds = convertToSerializableArray(typeVariable);\n-        }\n-\n-        @Override\n-        public Type[] getBounds() {\n-            return bounds;\n-        }\n-\n-        @Override\n-        public GenericDeclaration getGenericDeclaration() {\n-            return genericDeclaration;\n-        }\n-\n-        @Override\n-        public String getName() {\n-            return name;\n-        }\n-\n-    }\n-\n-    private static SerializableBound[] convertToSerializableArray(TypeVariable typeVariable) {\n-        SerializableBound[] bounds = new SerializableBound[typeVariable.getBounds().length];\n-        for (int i = 0; i < typeVariable.getBounds().length; i++) {\n-            bounds[i] =  new SerializableBound(typeVariable.getBounds()[i]);\n-        }\n-        return bounds;\n-    }\n-    private static SerializableBound[] convertToSerializableArray(BoundedType boundedType) {\n-        SerializableBound[] bounds = new SerializableBound[boundedType.interfaceBounds().length];\n-        for (int i = 0; i < boundedType.interfaceBounds().length; i++) {\n-            bounds[i] =  new SerializableBound(boundedType.interfaceBounds()[i]);\n-        }\n-        return bounds;\n-    }\n-\n-    private static <T> Class[] fromArrayToArrayOfClass(T[] objects) {\n-        Class[] elements = new Class[objects.length];\n-        for (int i = 0; i < objects.length; i++) {\n-            elements[i] = objects[i].getClass();\n-        }\n-        return elements;\n-    }\n-\n-    private static SerializableTypeVariable[] fromArray(TypeVariable[] typeVariables){\n-        SerializableTypeVariable[] serializableTypeVariables = new SerializableTypeVariable[typeVariables.length];\n-        for (int i = 0; i < typeVariables.length; i++) {\n-            serializableTypeVariables[i] = new SerializableTypeVariable(typeVariables[i]);\n-        }\n-        return serializableTypeVariables;\n-    }\n-\n-    private static class SerializableParameterizedType implements ParameterizedType, Serializable {\n-\n-        private final Class[] actualTypeArguments;\n-\n-        private final Class rawType;\n-\n-        private final Class ownerType;\n-\n-        public SerializableParameterizedType(ParameterizedType parameterizedType){\n-            actualTypeArguments = fromArrayToArrayOfClass(parameterizedType.getActualTypeArguments());\n-            rawType = (Class) parameterizedType.getRawType();\n-            ownerType = (Class) parameterizedType.getOwnerType();\n-        }\n-\n-        @Override\n-        public Type[] getActualTypeArguments() {\n-            return actualTypeArguments;\n-        }\n-\n-        @Override\n-        public Type getRawType() {\n-            return rawType;\n-        }\n-\n-        @Override\n-        public Type getOwnerType() {\n-            return ownerType;\n-        }\n-    }\n-\n-    private static class SerializableBoundedType implements BoundedType, Serializable {\n-\n-        private final SerializableBound firstBound;\n-\n-        private final SerializableBound[] interfaceBounds;\n-\n-        private SerializableBoundedType(BoundedType boundedType) {\n-            this.firstBound = new SerializableBound(boundedType.firstBound());\n-            this.interfaceBounds = convertToSerializableArray(boundedType);\n-        }\n-\n-        @Override\n-        public Type firstBound() {\n-            return firstBound;\n-        }\n-\n-        @Override\n-        public Type[] interfaceBounds() {\n-            return interfaceBounds;\n-        }\n-    }\n-\n }\n \n \n--- a/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n         <O extends K> O typeVar_with_type_params();\n     }\n \n+    static class StringList extends ArrayList<String> { }\n+\n+\n     @Test\n     public void can_get_raw_type_from_Class() throws Exception {\n         assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n         assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n         assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+        assertThat(inferFrom(StringList.class).rawType()).isEqualTo(StringList.class);\n     }\n \n \n         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+        assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType()).isEqualTo(ArrayList.class);\n     }\n \n     @Test\n         assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n         assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n         assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();\n     }\n \n     @Test\n         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n         assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n         assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(StringList.class).resolveGenericReturnType(firstNamedMethod(\"iterator\", StringList.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Iterator.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(String.class);\n     }\n \n     @Test", "timestamp": 1394497230, "metainfo": ""}