{"sha": "8ba3b5f3420f721ee86d0acf068c555276cdffda", "log": "exception messages, more tests tuned pmd xpath  --HG-- rename : test/org/mockito/usage/NiceMessagesOnRuntimeExceptions.java => test/org/mockito/usage/NiceMessagesOnInvalidUsageTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4082", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n     private static void assertMocksNotEmpty(Object[] mocks) {\n         if (mocks.length == 0) {\n-            throw Exceptions.mocksHaveToBePassedAsArguments();\n+            Exceptions.mocksHaveToBePassedAsArguments();\n         }\n     }\n \n         return MockUtil.getControl(mock);\n     }\n \n-    public static Strictly strictOrderVerifier(Object ... mocks) {\n+    public static Strictly createStrictOrderVerifier(Object ... mocks) {\n+        if (mocks.length == 0) {\n+            Exceptions.mocksHaveToBePassedWhenCreatingStrictly();\n+        }\n         StrictOrderVerifier strictOrderVerifier = new StrictOrderVerifier();\n         for (Object mock : mocks) {\n             MockUtil.validateMock(mock);\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n \n public class Exceptions {\n \n-    public static MockitoException mocksHaveToBePassedAsArguments() {\n+    public static void mocksHaveToBePassedAsArguments() {\n         throw new MockitoException(\n-                    \"\\n\" +\n-                    \"Method requires arguments.\" +\n-                    \"\\n\" +\n-                    \"Pass mocks that should be verified.\");\n+                \"\\n\" +\n+                \"Method requires arguments.\" +\n+                \"\\n\" +\n+                \"Pass mocks that should be verified.\");\n+    }\n+\n+    public static void strictlyRequiresFamiliarMock() {\n+        throw new MockitoException(\n+                \"\\n\" +\n+                \"Strictly can only verify mocks that were passed in during creation of Strictly. E.g:\" +\n+                \"\\n\" +\n+                \"strictly = createStrictOrderVerifier(mockOne)\" +\n+                \"\\n\" +\n+                \"so strictly can only verify mockOne\");\n+    }\n+\n+    public static void mocksHaveToBePassedWhenCreatingStrictly() {\n+        throw new MockitoException(\n+                \"\\n\" +\n+                \"Method requires arguments.\" +\n+                \"\\n\" +\n+                \"Pass mocks that require strict order verification.\");\n     }\n }\n--- a/src/org/mockito/internal/StrictOrderVerifier.java\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n import java.util.*;\n \n import org.mockito.*;\n+import org.mockito.exceptions.Exceptions;\n \n public class StrictOrderVerifier implements Strictly {\n     \n     public <T> T verify(T mock) {\n         return this.verify(mock, 1);\n     }\n-    \n     //TODO get rid of interface with int\n     public <T> T verify(T mock, int expectedNumberOfInvocations) {\n-        return Mockito.verify(mock, VerifyingMode.inOrder(expectedNumberOfInvocations, mocksToBeVerifiedInOrder));\n+        return this.verify(mock, VerifyingMode.inOrder(expectedNumberOfInvocations, mocksToBeVerifiedInOrder));\n     }\n     \n     public <T> T verify(T mock, VerifyingMode verifyingMode) {\n+        if (!mocksToBeVerifiedInOrder.contains(mock)) {\n+            Exceptions.strictlyRequiresFamiliarMock();\n+        }\n         return Mockito.verify(mock, VerifyingMode.inOrder(verifyingMode.expectedCount(), mocksToBeVerifiedInOrder));\n     }\n \n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n     \n     @Test(expected=NotAMockException.class)\n     public void shouldValidateMockWhenGettingStrictVerifier() {\n-        Mockito.strictOrderVerifier(notMock);\n+        Mockito.createStrictOrderVerifier(notMock);\n     }\n     \n     @Test\n--- /dev/null\n+++ b/test/org/mockito/usage/NiceMessagesOnInvalidUsageTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.MockitoException;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class NiceMessagesOnInvalidUsageTest {\n+    \n+    @Test\n+    public void shouldPrintThatRequiresArgumentsWhenVerifyingNoMoreInteractions() {\n+        try {\n+            verifyNoMoreInteractions();\n+            fail();\n+        }\n+        catch (MockitoException e) {\n+            String expected = \n+                    \"\\n\" +\n+                    \"Method requires arguments.\" +\n+                    \"\\n\" +\n+                    \"Pass mocks that should be verified.\";\n+            assertEquals(expected, e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintThatRequiresArgumentsWhenVerifyingZeroInteractions() {\n+        try {\n+            verifyZeroInteractions();\n+            fail();\n+        }\n+        catch (MockitoException e) {\n+            String expected = \n+                    \"\\n\" +\n+                    \"Method requires arguments.\" +\n+                    \"\\n\" +\n+                    \"Pass mocks that should be verified.\";\n+            assertEquals(expected, e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintThatStrictlyCannotBeCreatedWithoutMocks() {\n+        try {\n+            createStrictOrderVerifier();\n+            fail();\n+        } catch (MockitoException e) {\n+            String expected =  \n+                \"\\n\" +\n+                \"Method requires arguments.\" +\n+                \"\\n\" +\n+                \"Pass mocks that require strict order verification.\";\n+            assertEquals(expected, e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintThatStrictlyCannotVerifyUnfamilarMocks() {\n+        List mockOne = mock(List.class);\n+        List mockTwo = mock(List.class);\n+        Strictly strictly = createStrictOrderVerifier(mockOne);\n+        try {\n+            strictly.verify(mockTwo).clear();\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- a/test/org/mockito/usage/StackTrackeFilteringTest.java\n+++ b/test/org/mockito/usage/StackTrackeFilteringTest.java\n import static org.mockito.Mockito.*;\n \n import org.junit.*;\n-import org.mockito.Mockito;\n+import org.mockito.*;\n import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n \n import static org.mockito.util.ExtraMatchers.*;\n \n     \n     private IMethods mock;\n \n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n     @Before\n     public void setup() {\n+        resetState();\n         mock = Mockito.mock(IMethods.class);\n     }\n     \n             assertEquals(\"checkForUnfinishedVerification\", unfilteredStackTrace[0].getMethodName());\n         }\n     }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyVerifying() {\n+        Strictly strictly = createStrictOrderVerifier(mock);\n+        mock.oneArg(true);\n+        mock.oneArg(false);\n+        try {\n+            strictly.verify(mock).oneArg(false); \n+            fail();\n+        } catch (StrictVerificationError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n+            \n+            StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n+            assertEquals(\"checkOrderOfInvocations\", unfilteredStackTrace[0].getMethodName());\n+        }\n+    }\n }\n--- a/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n  */\n package org.mockito.usage.verification;\n \n-import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n \n+import static org.junit.Assert.*;\n import org.junit.*;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.MockitoException;\n+import org.mockito.exceptions.*;\n import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         mockThree.simpleMethod(3);\n         mockThree.simpleMethod(4);\n \n-        strictly = strictOrderVerifier(mockOne, mockThree);\n+        strictly = createStrictOrderVerifier(mockOne, mockThree);\n     }\n     \n     @Test\n     public void shouldMixVerifyingInOrderAndNormalVerification() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowOrdinarilyVerifyingStrictlyControlledMock() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowRedundantVerifications() {\n         verify(mockOne, atLeastOnce()).simpleMethod(1);\n         verify(mockTwo).simpleMethod(2);\n         verify(mockThree).simpleMethod(3);\n         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n     }\n     \n-    @Ignore\n     @Test\n+    public void shouldFailOnNoMoreInteractions() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationAssertionError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractionsOnStrictlyControlledMock() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationAssertionError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrder() {\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        try {\n+            strictly.verify(mockThree).simpleMethod(3);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrderForLastInvocationIsTooEarly() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            strictly.verify(mockThree).simpleMethod(4);\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n     public void shouldScreamWhenNotStrictMockPassedToStrictly() {\n-        //TODO move to some nice messages exceptions test?\n-        try {\n-            strictly.verify(mockTwo, atLeastOnce()).simpleMethod(1);\n-            fail();\n-        } catch(MockitoException e) {\n-            String expected = \"some meaningful message\";\n-            assertEquals(expected, e.getMessage());\n-        }\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(1);\n     } \n }\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n         mockTwo = mock(IMethods.class);\n         mockThree = mock(IMethods.class);\n         \n-        strictly = strictOrderVerifier(mockOne, mockTwo, mockThree);\n+        strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n \n         mockOne.simpleMethod(1);\n         mockTwo.simpleMethod(2);", "timestamp": 1196210903, "metainfo": ""}