{"sha": "344bbe373e920b53c61190527cbd59bec2a582ae", "log": "Issue 84: method invocations are not recorded when using stubOnly() feature (transplanted from cf5df0109dc0a0cd9eec3b3458ffd3dd96d1b930)  --HG-- rename : test/org/mockito/internal/verification/RegisteredInvocationsTest.java => test/org/mockito/internal/verification/RegisteredInvocationsAllTest.java extra : transplant_source : %CF%5D%F0%10%9D%C0%A0%CD%9E%EC%3B4X%FF%D3%DD%96%D1%B90", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         ));\n     }\n \n+    public void stubPassedToVerify() {\n+        throw new NotAMockException(join(\n+                \"Argument passed to verify() is only a stub (not a full-blown mock)!\",\n+                \"If you intend to verify invocations on a mock, don't use stubOnly() in its MockSettings.\"\n+        ));\n+    }\n+\n     public void reportNoSubMatchersFound(String additionalMatcherName) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"No matchers found for additional matcher \" + additionalMatcherName,\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n         return serializable;\n     }\n \n-    public MockSettings stubOnly() {\n+    public MockSettingsImpl stubOnly() {\n         this.stubOnly = true;\n         return this;\n     }\n--- a/src/org/mockito/internal/handler/MockHandlerImpl.java\n+++ b/src/org/mockito/internal/handler/MockHandlerImpl.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.handler;\n-\n-import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.*;\n-import org.mockito.internal.verification.MockAwareVerificationMode;\n-import org.mockito.internal.verification.VerificationDataImpl;\n-import org.mockito.invocation.Invocation;\n-import org.mockito.mock.MockCreationSettings;\n-import org.mockito.stubbing.Answer;\n-import org.mockito.stubbing.VoidMethodStubbable;\n-import org.mockito.verification.VerificationMode;\n-\n-import java.util.List;\n-\n-/**\n- * Invocation handler set on mock objects.\n- * \n- * @param <T>\n- *            type of mock object to handle\n- */\n-class MockHandlerImpl<T> implements InternalMockHandler<T> {\n-\n-    private static final long serialVersionUID = -2917871070982574165L;\n-\n-    InvocationContainerImpl invocationContainerImpl;\n-    MatchersBinder matchersBinder = new MatchersBinder();\n-    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n-\n-    private final MockCreationSettings mockSettings;\n-\n-    public MockHandlerImpl(MockCreationSettings mockSettings) {\n-        this.mockSettings = mockSettings;\n-        this.mockingProgress = new ThreadSafeMockingProgress();\n-        this.matchersBinder = new MatchersBinder();\n-        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n-    }\n-\n-    public Object handle(Invocation invocation) throws Throwable {\n-\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n-            // stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n-                    mockingProgress.getArgumentMatcherStorage(),\n-                    invocation\n-            );\n-            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n-            return null;\n-        }\n-        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n-\n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n-                mockingProgress.getArgumentMatcherStorage(),\n-                invocation\n-        );\n-\n-        mockingProgress.validateState();\n-\n-        // if verificationMode is not null then someone is doing verify()\n-        if (verificationMode != null) {\n-            // We need to check if verification was started on the correct mock\n-            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            // TODO: can I avoid this cast here?\n-            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n-                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n-                verificationMode.verify(data);\n-                return null;\n-            } else {\n-                // this means there is an invocation on a different mock. Re-adding verification mode\n-                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-                mockingProgress.verificationStarted(verificationMode);\n-            }\n-        }\n-\n-        // prepare invocation for stubbing\n-        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n-        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n-\n-        // look for existing answer for this invocation\n-        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n-\n-        if (stubbedInvocation != null) {\n-            stubbedInvocation.captureArgumentsFrom(invocation);\n-            return stubbedInvocation.answer(invocation);\n-        } else {\n-             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n-\n-            // redo setting invocation for potential stubbing in case of partial\n-            // mocks / spies.\n-            // Without it, the real method inside 'when' might have delegated\n-            // to other self method and overwrite the intended stubbed method\n-            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n-            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n-            return ret;\n-        }\n-\t}\n-\n-    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n-        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n-    }\n-\n-    public MockCreationSettings getMockSettings() {\n-        return mockSettings;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void setAnswersForStubbing(List<Answer> answers) {\n-        invocationContainerImpl.setAnswersForStubbing(answers);\n-    }\n-\n-    public InvocationContainer getInvocationContainer() {\n-        return invocationContainerImpl;\n-    }\n-}\n-\n+package org.mockito.internal.handler;\n+\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.verification.MockAwareVerificationMode;\n+import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+import org.mockito.exceptions.Reporter;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n+ */\n+class MockHandlerImpl<T> implements InternalMockHandler<T> {\n+\n+    private static final long serialVersionUID = -2917871070982574165L;\n+\n+    InvocationContainerImpl invocationContainerImpl;\n+    MatchersBinder matchersBinder = new MatchersBinder();\n+    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+\n+    private final MockCreationSettings mockSettings;\n+\n+    public MockHandlerImpl(MockCreationSettings mockSettings) {\n+        this.mockSettings = mockSettings;\n+        this.mockingProgress = new ThreadSafeMockingProgress();\n+        this.matchersBinder = new MatchersBinder();\n+        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress, mockSettings);\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n+            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+            return null;\n+        }\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n+\n+        mockingProgress.validateState();\n+\n+        // if verificationMode is not null then someone is doing verify()\n+        if (verificationMode != null) {\n+            // We need to check if verification was started on the correct mock\n+            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+            // TODO: can I avoid this cast here?\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = createVerificationData(invocationContainerImpl, invocationMatcher);\n+                verificationMode.verify(data);\n+                return null;\n+            } else {\n+                // this means there is an invocation on a different mock. Re-adding verification mode\n+                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+                mockingProgress.verificationStarted(verificationMode);\n+            }\n+        }\n+\n+        // prepare invocation for stubbing\n+        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+        // look for existing answer for this invocation\n+        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+        if (stubbedInvocation != null) {\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n+        } else {\n+             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n+        }\n+\t}\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n+    }\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        invocationContainerImpl.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return invocationContainerImpl;\n+    }\n+\n+    private VerificationDataImpl createVerificationData(InvocationContainerImpl invocationContainerImpl, InvocationMatcher invocationMatcher) {\n+        if (mockSettings.isStubOnly()) {\n+            new Reporter().stubPassedToVerify();     // this throws an exception\n+        }\n+\n+        return new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+    }\n+}\n+\n--- a/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n+++ b/src/org/mockito/internal/stubbing/InvocationContainerImpl.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.stubbing;\n-\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.StubInfoImpl;\n-import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.stubbing.answers.AnswersValidator;\n-import org.mockito.internal.verification.RegisteredInvocations;\n-import org.mockito.invocation.Invocation;\n-import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-@SuppressWarnings(\"unchecked\")\n-public class InvocationContainerImpl implements InvocationContainer, Serializable {\n-\n-    private static final long serialVersionUID = -5334301962749537176L;\n-    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n-    private final MockingProgress mockingProgress;\n-    private final List<Answer> answersForStubbing = new ArrayList<Answer>();\n-    private final RegisteredInvocations registeredInvocations = new RegisteredInvocations();\n-\n-    private InvocationMatcher invocationForStubbing;\n-\n-    public InvocationContainerImpl(MockingProgress mockingProgress) {\n-        this.mockingProgress = mockingProgress;\n-    }\n-\n-    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n-        registeredInvocations.add(invocation.getInvocation());\n-        this.invocationForStubbing = invocation;\n-    }\n-\n-    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n-        this.invocationForStubbing = invocationMatcher;\n-    }\n-\n-    public void addAnswer(Answer answer) {\n-        registeredInvocations.removeLast();\n-        addAnswer(answer, false);\n-    }\n-\n-    public void addConsecutiveAnswer(Answer answer) {\n-        addAnswer(answer, true);\n-    }\n-\n-    public void addAnswer(Answer answer, boolean isConsecutive) {\n-        Invocation invocation = invocationForStubbing.getInvocation();\n-        mockingProgress.stubbingCompleted(invocation);\n-        AnswersValidator answersValidator = new AnswersValidator();\n-        answersValidator.validate(answer, invocation);\n-\n-        synchronized (stubbed) {\n-            if (isConsecutive) {\n-                stubbed.getFirst().addAnswer(answer);\n-            } else {\n-                stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-            }\n-        }\n-    }\n-\n-    Object answerTo(Invocation invocation) throws Throwable {\n-        return findAnswerFor(invocation).answer(invocation);\n-    }\n-\n-    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n-        synchronized (stubbed) {\n-            for (StubbedInvocationMatcher s : stubbed) {\n-                if (s.matches(invocation)) {\n-                    s.markStubUsed(invocation);\n-                    invocation.markStubbed(new StubInfoImpl(s));\n-                    return s;\n-                }\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    public void addAnswerForVoidMethod(Answer answer) {\n-        answersForStubbing.add(answer);\n-    }\n-\n-    public void setAnswersForStubbing(List<Answer> answers) {\n-        answersForStubbing.addAll(answers);\n-    }\n-\n-    public boolean hasAnswersForStubbing() {\n-        return !answersForStubbing.isEmpty();\n-    }\n-\n-    public boolean hasInvocationForPotentialStubbing() {\n-        return !registeredInvocations.isEmpty();\n-    }\n-\n-    public void setMethodForStubbing(InvocationMatcher invocation) {\n-        invocationForStubbing = invocation;\n-        assert hasAnswersForStubbing();\n-        for (int i = 0; i < answersForStubbing.size(); i++) {\n-            addAnswer(answersForStubbing.get(i), i != 0);\n-        }\n-        answersForStubbing.clear();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"invocationForStubbing: \" + invocationForStubbing;\n-    }\n-\n-    public List<Invocation> getInvocations() {\n-        return registeredInvocations.getAll();\n-    }\n-\n-    public List<StubbedInvocationMatcher> getStubbedInvocations() {\n-        return stubbed;\n-    }\n-\n-    public Object invokedMock() {\n-        return invocationForStubbing.getInvocation().getMock();\n-    }\n-    \n-    public InvocationMatcher getInvocationForStubbing() {\n-    \treturn invocationForStubbing;\n-    }\n-}\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.StubInfoImpl;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.stubbing.answers.AnswersValidator;\n+import org.mockito.internal.verification.RegisteredInvocations;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import org.mockito.internal.verification.RegisteredInvocationsAll;\n+import org.mockito.internal.verification.RegisteredInvocationsStubOnly;\n+import org.mockito.mock.MockCreationSettings;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationContainerImpl implements InvocationContainer, Serializable {\n+\n+    private static final long serialVersionUID = -5334301962749537177L;\n+    private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n+    private final MockingProgress mockingProgress;\n+    private final List<Answer> answersForStubbing = new ArrayList<Answer>();\n+    private final RegisteredInvocations registeredInvocations;\n+\n+    private InvocationMatcher invocationForStubbing;\n+\n+    public InvocationContainerImpl(MockingProgress mockingProgress, MockCreationSettings mockSettings) {\n+        this.mockingProgress = mockingProgress;\n+        this.registeredInvocations = createRegisteredInvocations(mockSettings);\n+    }\n+\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+        registeredInvocations.add(invocation.getInvocation());\n+        this.invocationForStubbing = invocation;\n+    }\n+\n+    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n+        this.invocationForStubbing = invocationMatcher;\n+    }\n+\n+    public void addAnswer(Answer answer) {\n+        registeredInvocations.removeLast();\n+        addAnswer(answer, false);\n+    }\n+\n+    public void addConsecutiveAnswer(Answer answer) {\n+        addAnswer(answer, true);\n+    }\n+\n+    public void addAnswer(Answer answer, boolean isConsecutive) {\n+        Invocation invocation = invocationForStubbing.getInvocation();\n+        mockingProgress.stubbingCompleted(invocation);\n+        AnswersValidator answersValidator = new AnswersValidator();\n+        answersValidator.validate(answer, invocation);\n+\n+        synchronized (stubbed) {\n+            if (isConsecutive) {\n+                stubbed.getFirst().addAnswer(answer);\n+            } else {\n+                stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+            }\n+        }\n+    }\n+\n+    Object answerTo(Invocation invocation) throws Throwable {\n+        return findAnswerFor(invocation).answer(invocation);\n+    }\n+\n+    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n+        synchronized (stubbed) {\n+            for (StubbedInvocationMatcher s : stubbed) {\n+                if (s.matches(invocation)) {\n+                    s.markStubUsed(invocation);\n+                    invocation.markStubbed(new StubInfoImpl(s));\n+                    return s;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public void addAnswerForVoidMethod(Answer answer) {\n+        answersForStubbing.add(answer);\n+    }\n+\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        answersForStubbing.addAll(answers);\n+    }\n+\n+    public boolean hasAnswersForStubbing() {\n+        return !answersForStubbing.isEmpty();\n+    }\n+\n+    public boolean hasInvocationForPotentialStubbing() {\n+        return !registeredInvocations.isEmpty();\n+    }\n+\n+    public void setMethodForStubbing(InvocationMatcher invocation) {\n+        invocationForStubbing = invocation;\n+        assert hasAnswersForStubbing();\n+        for (int i = 0; i < answersForStubbing.size(); i++) {\n+            addAnswer(answersForStubbing.get(i), i != 0);\n+        }\n+        answersForStubbing.clear();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"invocationForStubbing: \" + invocationForStubbing;\n+    }\n+\n+    public List<Invocation> getInvocations() {\n+        return registeredInvocations.getAll();\n+    }\n+\n+    public List<StubbedInvocationMatcher> getStubbedInvocations() {\n+        return stubbed;\n+    }\n+\n+    public Object invokedMock() {\n+        return invocationForStubbing.getInvocation().getMock();\n+    }\n+    \n+    public InvocationMatcher getInvocationForStubbing() {\n+    \treturn invocationForStubbing;\n+    }\n+\n+    private RegisteredInvocations createRegisteredInvocations(MockCreationSettings mockSettings) {\n+        return mockSettings.isStubOnly()\n+          ? new RegisteredInvocationsStubOnly()\n+          : new RegisteredInvocationsAll();\n+    }\n+}\n--- a/src/org/mockito/internal/verification/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/verification/RegisteredInvocations.java\n import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.invocation.Invocation;\n \n-import java.io.Serializable;\n-import java.util.LinkedList;\n import java.util.List;\n \n \n-public class RegisteredInvocations implements Serializable {\n+public interface RegisteredInvocations {\n \n-    private static final long serialVersionUID = -2674402327380736290L;\n-    private final LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n+    void add(Invocation invocation);\n \n-    public void add(Invocation invocation) {\n-        synchronized (invocations) {\n-            invocations.add(invocation);\n-        }\n-    }\n+    void removeLast();\n \n-    public void removeLast() {\n-        //TODO: add specific test for synchronization of this block (it is tested by InvocationContainerImplTest at the moment)\n-        synchronized (invocations) {\n-            if (! invocations.isEmpty()) {\n-                invocations.removeLast();\n-            }\n-        }\n-    }\n+    List<Invocation> getAll();\n \n-    public List<Invocation> getAll() {\n-    \tList<Invocation> copiedList;\n-    \tsynchronized (invocations) {\n-\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n-\t\t}\n+    boolean isEmpty();\n \n-        return ListUtil.filter(copiedList, new RemoveToString());\n-    }\n-\n-    public boolean isEmpty() {\n-        synchronized (invocations) {\n-            return invocations.isEmpty();\n-        }\n-    }\n-\n-    private static class RemoveToString implements Filter<Invocation> {\n-        public boolean isOut(Invocation invocation) {\n-            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/RegisteredInvocationsAll.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+import org.mockito.invocation.Invocation;\n+\n+import java.io.Serializable;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+//TODO rename to DefaultRegisteredInvocations\n+public class RegisteredInvocationsAll implements RegisteredInvocations, Serializable {\n+\n+    private static final long serialVersionUID = -2674402327380736290L;\n+    private final LinkedList<Invocation> invocations = new LinkedList<Invocation>();\n+\n+    public void add(Invocation invocation) {\n+        synchronized (invocations) {\n+            invocations.add(invocation);\n+        }\n+    }\n+\n+    public void removeLast() {\n+        //TODO: add specific test for synchronization of this block (it is tested by InvocationContainerImplTest at the moment)\n+        synchronized (invocations) {\n+            if (! invocations.isEmpty()) {\n+                invocations.removeLast();\n+            }\n+        }\n+    }\n+\n+    public List<Invocation> getAll() {\n+    \tList<Invocation> copiedList;\n+    \tsynchronized (invocations) {\n+\t\t\tcopiedList = new LinkedList<Invocation>(invocations) ;\n+\t\t}\n+\n+        return ListUtil.filter(copiedList, new RemoveToString());\n+    }\n+\n+    public boolean isEmpty() {\n+        synchronized (invocations) {\n+            return invocations.isEmpty();\n+        }\n+    }\n+\n+    private static class RemoveToString implements Filter<Invocation> {\n+        public boolean isOut(Invocation invocation) {\n+            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/RegisteredInvocationsStubOnly.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.invocation.Invocation;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.List;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n+\n+//TODO this should be EmptyRegisteredInvocation, e.g. it should not store anything\n+public class RegisteredInvocationsStubOnly implements RegisteredInvocations, Serializable {\n+\n+    private static final long serialVersionUID = -2674402327380736235L;\n+\n+    private final ThreadLocal<Invocation> lastInvocation = new ThreadLocal<Invocation>();\n+\n+    public void add(Invocation invocation) {\n+        this.lastInvocation.set(invocation);\n+    }\n+\n+    public void removeLast() {\n+        this.lastInvocation.remove();\n+    }\n+\n+    public List<Invocation> getAll() {\n+        if (this.lastInvocation.get() == null) {\n+            return Collections.emptyList();\n+        }\n+\n+    \tList<Invocation> copiedList = Collections.singletonList(this.lastInvocation.get());\n+        return ListUtil.filter(copiedList, new RemoveToString());\n+    }\n+\n+    public boolean isEmpty() {\n+        return (this.lastInvocation.get() == null);\n+    }\n+\n+    private static class RemoveToString implements Filter<Invocation> {\n+        public boolean isOut(Invocation invocation) {\n+            return new ObjectMethodsGuru().isToString(invocation.getMethod());\n+        }\n+    }\n+\n+}\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.concurrentmockito;\n-\n-import org.junit.Test;\n-import org.junit.runner.JUnitCore;\n-import org.junit.runner.Result;\n-import org.junit.runner.notification.Failure;\n-import org.mockito.MockitoTest;\n-import org.mockito.exceptions.ReporterTest;\n-import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n-import org.mockito.exceptions.base.MockitoExceptionTest;\n-import org.mockito.internal.AllInvocationsFinderTest;\n-import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n-import org.mockito.internal.handler.MockHandlerImplTest;\n-import org.mockito.internal.invocation.InvocationImplTest;\n-import org.mockito.internal.invocation.InvocationMatcherTest;\n-import org.mockito.internal.invocation.InvocationsFinderTest;\n-import org.mockito.internal.matchers.ComparableMatchersTest;\n-import org.mockito.internal.matchers.EqualsTest;\n-import org.mockito.internal.matchers.MatchersToStringTest;\n-import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.TimesTest;\n-import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n-import org.mockito.internal.util.MockUtilTest;\n-import org.mockito.internal.util.collections.ListUtilTest;\n-import org.mockito.internal.verification.RegisteredInvocationsTest;\n-import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n-import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n-import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n-import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n-import org.mockitousage.basicapi.ReplacingObjectMethodsTest;\n-import org.mockitousage.basicapi.ResetTest;\n-import org.mockitousage.basicapi.UsingVarargsTest;\n-import org.mockitousage.examples.use.ExampleTest;\n-import org.mockitousage.matchers.CustomMatchersTest;\n-import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n-import org.mockitousage.matchers.MatchersTest;\n-import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n-import org.mockitousage.misuse.InvalidUsageTest;\n-import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n-import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n-import org.mockitousage.stacktrace.ClickableStackTracesTest;\n-import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n-import org.mockitousage.stacktrace.StackTraceFilteringTest;\n-import org.mockitousage.stubbing.BasicStubbingTest;\n-import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n-import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n-import org.mockitousage.verification.*;\n-import org.mockitoutil.TestBase;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n-    \n-    private static class AllTestsRunner extends Thread {\n-        \n-        private boolean failed;\n-\n-        public void run() {\n-            Result result = JUnitCore.runClasses(\n-                    EqualsTest.class,\n-                    ListUtilTest.class,\n-                    MockingProgressImplTest.class,\n-                    TimesTest.class,\n-                    MockHandlerImplTest.class,\n-                    AllInvocationsFinderTest.class,\n-                    ReturnsEmptyValuesTest.class,\n-                    NumberOfInvocationsCheckerTest.class,\n-                    RegisteredInvocationsTest.class,\n-                    MissingInvocationCheckerTest.class,\n-                    NumberOfInvocationsInOrderCheckerTest.class,\n-                    MissingInvocationInOrderCheckerTest.class,\n-                    ClassImposterizerTest.class,\n-                    InvocationMatcherTest.class,\n-                    InvocationsFinderTest.class,\n-                    InvocationImplTest.class,\n-                    MockitoTest.class,\n-                    MockUtilTest.class,\n-                    ReporterTest.class,\n-                    MockitoAssertionErrorTest.class,\n-                    MockitoExceptionTest.class,\n-                    StackTraceFilteringTest.class,\n-                    BridgeMethodPuzzleTest.class,\n-                    OverloadingPuzzleTest.class,\n-                    InvalidUsageTest.class,\n-                    UsingVarargsTest.class,\n-                    CustomMatchersTest.class,\n-                    ComparableMatchersTest.class,\n-                    InvalidUseOfMatchersTest.class,\n-                    MatchersTest.class,\n-                    MatchersToStringTest.class,\n-                    VerificationAndStubbingUsingMatchersTest.class,\n-                    BasicStubbingTest.class,\n-                    ReturningDefaultValuesTest.class,\n-                    StubbingWithThrowablesTest.class,\n-                    AtMostXVerificationTest.class,\n-                    BasicVerificationTest.class,\n-                    ExactNumberOfTimesVerificationTest.class,\n-                    VerificationInOrderTest.class,\n-                    NoMoreInteractionsVerificationTest.class,\n-                    SelectedMocksInOrderVerificationTest.class,\n-                    VerificationOnMultipleMocksUsingMatchersTest.class,\n-                    VerificationUsingMatchersTest.class,\n-                    RelaxedVerificationInOrderTest.class,\n-                    DescriptiveMessagesWhenVerificationFailsTest.class,\n-                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n-                    BasicVerificationInOrderTest.class,\n-                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n-                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n-                    InvalidStateDetectionTest.class,\n-                    ReplacingObjectMethodsTest.class,\n-                    ClickableStackTracesTest.class,\n-                    ExampleTest.class,\n-                    PointingStackTraceToActualInvocationTest.class,\n-                    VerificationInOrderFromMultipleThreadsTest.class,\n-                    ResetTest.class\n-                );\n-                \n-                if (!result.wasSuccessful()) {\n-                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n-                    List<Failure> failures = result.getFailures();\n-                    System.err.println(failures.size());\n-                    for (Failure failure : failures) {\n-                        System.err.println(failure.getTrace());\n-                        failed = true;\n-                    }\n-                }\n-        }\n-\n-        public boolean isFailed() {\n-            return failed;\n-        }\n-    }\n-    \n-    @Test\n-    public void shouldRunInMultipleThreads() throws Exception {\n-        //this test ALWAYS fails if there is a single failing unit\n-        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(3));\n-    }\n-    \n-    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n-        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n-        for (int i = 1; i <= numberOfThreads; i++) {\n-            threads.add(new AllTestsRunner());\n-        }\n-\n-        for (Thread t : threads) {\n-            t.start();\n-        }\n-\n-        boolean failed = false;\n-        for (AllTestsRunner t : threads) {\n-            t.join();\n-            failed = failed ? true : t.isFailed();\n-        }\n-        \n-        return failed;\n-    }\n-    \n-    public static void main(String[] args) throws Exception {\n-        int numberOfThreads = 20; \n-        long before = System.currentTimeMillis();\n-        runInMultipleThreads(numberOfThreads);\n-        long after = System.currentTimeMillis();\n-        long executionTime = (after-before)/1000;\n-        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n-    }\n+package org.concurrentmockito;\n+\n+import org.junit.Test;\n+import org.junit.runner.JUnitCore;\n+import org.junit.runner.Result;\n+import org.junit.runner.notification.Failure;\n+import org.mockito.MockitoTest;\n+import org.mockito.exceptions.ReporterTest;\n+import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n+import org.mockito.exceptions.base.MockitoExceptionTest;\n+import org.mockito.internal.AllInvocationsFinderTest;\n+import org.mockito.internal.InvalidStateDetectionTest;\n+import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.handler.MockHandlerImplTest;\n+import org.mockito.internal.invocation.InvocationImplTest;\n+import org.mockito.internal.invocation.InvocationMatcherTest;\n+import org.mockito.internal.invocation.InvocationsFinderTest;\n+import org.mockito.internal.matchers.ComparableMatchersTest;\n+import org.mockito.internal.matchers.EqualsTest;\n+import org.mockito.internal.matchers.MatchersToStringTest;\n+import org.mockito.internal.progress.MockingProgressImplTest;\n+import org.mockito.internal.progress.TimesTest;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n+import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.util.collections.ListUtilTest;\n+import org.mockito.internal.verification.RegisteredInvocationsAllTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;\n+import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest;\n+import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest;\n+import org.mockitousage.basicapi.ReplacingObjectMethodsTest;\n+import org.mockitousage.basicapi.ResetTest;\n+import org.mockitousage.basicapi.UsingVarargsTest;\n+import org.mockitousage.examples.use.ExampleTest;\n+import org.mockitousage.matchers.CustomMatchersTest;\n+import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n+import org.mockitousage.matchers.MatchersTest;\n+import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n+import org.mockitousage.misuse.InvalidUsageTest;\n+import org.mockitousage.puzzlers.BridgeMethodPuzzleTest;\n+import org.mockitousage.puzzlers.OverloadingPuzzleTest;\n+import org.mockitousage.stacktrace.ClickableStackTracesTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n+import org.mockitousage.stacktrace.StackTraceFilteringTest;\n+import org.mockitousage.stubbing.BasicStubbingTest;\n+import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n+import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n+import org.mockitousage.verification.*;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n+    \n+    private static class AllTestsRunner extends Thread {\n+        \n+        private boolean failed;\n+\n+        public void run() {\n+            Result result = JUnitCore.runClasses(\n+                    EqualsTest.class,\n+                    ListUtilTest.class,\n+                    MockingProgressImplTest.class,\n+                    TimesTest.class,\n+                    MockHandlerImplTest.class,\n+                    AllInvocationsFinderTest.class,\n+                    ReturnsEmptyValuesTest.class,\n+                    NumberOfInvocationsCheckerTest.class,\n+                    RegisteredInvocationsAllTest.class,\n+                    MissingInvocationCheckerTest.class,\n+                    NumberOfInvocationsInOrderCheckerTest.class,\n+                    MissingInvocationInOrderCheckerTest.class,\n+                    ClassImposterizerTest.class,\n+                    InvocationMatcherTest.class,\n+                    InvocationsFinderTest.class,\n+                    InvocationImplTest.class,\n+                    MockitoTest.class,\n+                    MockUtilTest.class,\n+                    ReporterTest.class,\n+                    MockitoAssertionErrorTest.class,\n+                    MockitoExceptionTest.class,\n+                    StackTraceFilteringTest.class,\n+                    BridgeMethodPuzzleTest.class,\n+                    OverloadingPuzzleTest.class,\n+                    InvalidUsageTest.class,\n+                    UsingVarargsTest.class,\n+                    CustomMatchersTest.class,\n+                    ComparableMatchersTest.class,\n+                    InvalidUseOfMatchersTest.class,\n+                    MatchersTest.class,\n+                    MatchersToStringTest.class,\n+                    VerificationAndStubbingUsingMatchersTest.class,\n+                    BasicStubbingTest.class,\n+                    ReturningDefaultValuesTest.class,\n+                    StubbingWithThrowablesTest.class,\n+                    AtMostXVerificationTest.class,\n+                    BasicVerificationTest.class,\n+                    ExactNumberOfTimesVerificationTest.class,\n+                    VerificationInOrderTest.class,\n+                    NoMoreInteractionsVerificationTest.class,\n+                    SelectedMocksInOrderVerificationTest.class,\n+                    VerificationOnMultipleMocksUsingMatchersTest.class,\n+                    VerificationUsingMatchersTest.class,\n+                    RelaxedVerificationInOrderTest.class,\n+                    DescriptiveMessagesWhenVerificationFailsTest.class,\n+                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n+                    BasicVerificationInOrderTest.class,\n+                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n+                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n+                    InvalidStateDetectionTest.class,\n+                    ReplacingObjectMethodsTest.class,\n+                    ClickableStackTracesTest.class,\n+                    ExampleTest.class,\n+                    PointingStackTraceToActualInvocationTest.class,\n+                    VerificationInOrderFromMultipleThreadsTest.class,\n+                    ResetTest.class\n+                );\n+                \n+                if (!result.wasSuccessful()) {\n+                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n+                    List<Failure> failures = result.getFailures();\n+                    System.err.println(failures.size());\n+                    for (Failure failure : failures) {\n+                        System.err.println(failure.getTrace());\n+                        failed = true;\n+                    }\n+                }\n+        }\n+\n+        public boolean isFailed() {\n+            return failed;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRunInMultipleThreads() throws Exception {\n+        //this test ALWAYS fails if there is a single failing unit\n+        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(3));\n+    }\n+    \n+    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n+        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n+        for (int i = 1; i <= numberOfThreads; i++) {\n+            threads.add(new AllTestsRunner());\n+        }\n+\n+        for (Thread t : threads) {\n+            t.start();\n+        }\n+\n+        boolean failed = false;\n+        for (AllTestsRunner t : threads) {\n+            t.join();\n+            failed = failed ? true : t.isFailed();\n+        }\n+        \n+        return failed;\n+    }\n+    \n+    public static void main(String[] args) throws Exception {\n+        int numberOfThreads = 20; \n+        long before = System.currentTimeMillis();\n+        runInMultipleThreads(numberOfThreads);\n+        long after = System.currentTimeMillis();\n+        long executionTime = (after-before)/1000;\n+        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n+    }\n }\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n import org.mockito.invocation.Invocation;\n \n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.mock.MockCreationSettings;\n+\n import java.util.LinkedList;\n import java.util.concurrent.CountDownLatch;\n \n  */\n public class InvocationContainerImplTest {\n \n-    InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress());\n+    InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());\n+    InvocationContainerImpl containerStubOnly =\n+      new InvocationContainerImpl(new ThreadSafeMockingProgress(), (MockCreationSettings) new MockSettingsImpl().stubOnly());\n     Invocation invocation = new InvocationBuilder().toInvocation();\n     LinkedList<Throwable> exceptions = new LinkedList<Throwable>();\n \n     @Test\n+    public void should_be_thread_safe() throws Throwable {\n+        doShouldBeThreadSafe(container);\n+    }\n+\n+    @Test\n+    public void should_be_thread_safe_stub_only() throws Throwable {\n+        doShouldBeThreadSafe(containerStubOnly);\n+    }\n+\n     //works 50% of the time\n-    public void shouldBeThreadSafe() throws Throwable {\n+    private void doShouldBeThreadSafe(final InvocationContainerImpl c) throws Throwable {\n         //given\n         Thread[] t = new Thread[200];\n         final CountDownLatch starter = new CountDownLatch(200);\n                     } catch (InterruptedException e) {\n                         throw new RuntimeException(e);\n                     }\n-                    container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n-                    container.addAnswer(new Returns(\"foo\"));\n-                    container.findAnswerFor(invocation);\n+                    c.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+                    c.addAnswer(new Returns(\"foo\"));\n+                    c.findAnswerFor(invocation);\n                 }\n             };\n             t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n     }\n \n     @Test\n-    public void shouldReturnInvokedMock() throws Exception {\n+    public void should_return_invoked_mock() throws Exception {\n         container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n \n         assertEquals(invocation.getMock(), container.invokedMock());\n+    }\n+\n+    @Test\n+    public void should_return_invoked_mock_stub_only() throws Exception {\n+        containerStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+\n+        assertEquals(invocation.getMock(), containerStubOnly.invokedMock());\n     }\n \n     @Test\n         container.addAnswer(new ReturnsEmptyValues());\n         assertFalse(container.hasInvocationForPotentialStubbing());\n     }\n+\n+    @Test\n+    public void should_tell_if_has_invocation_for_potential_stubbing_stub_only() throws Exception {\n+        containerStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        assertTrue(containerStubOnly.hasInvocationForPotentialStubbing());\n+\n+        containerStubOnly.addAnswer(new ReturnsEmptyValues());\n+        assertFalse(containerStubOnly.hasInvocationForPotentialStubbing());\n+    }\n }\n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.answers.Returns;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n import org.mockitoutil.TestBase;\n \n+//TODO this is InvocationContainerImpl test\n public class MockitoStubberTest extends TestBase{\n \n     private InvocationContainerImpl invocationContainerImpl;\n+    private InvocationContainerImpl invocationContainerImplStubOnly;\n     private MockingProgress state;\n     private Invocation simpleMethod;\n \n     @Before\n     public void setup() {\n         state = new MockingProgressImpl();\n-        \n-        invocationContainerImpl = new InvocationContainerImpl(state);\n+\n+        invocationContainerImpl = new InvocationContainerImpl(state, new MockSettingsImpl());\n         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n-        \n+\n+        invocationContainerImplStubOnly =\n+          new InvocationContainerImpl(state, new MockSettingsImpl().stubOnly());\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+\n         simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n     }\n \n     @Test\n-    public void shouldFinishStubbingWhenWrongThrowableIsSet() throws Exception {\n+    public void should_finish_stubbing_when_wrong_throwable_is_set() throws Exception {\n         state.stubbingStarted();\n         try {\n             invocationContainerImpl.addAnswer(new ThrowsException(new Exception()));\n             state.validateState();\n         }\n     }\n-    \n+\n     @Test\n-    public void shouldFinishStubbingOnAddingReturnValue() throws Exception {\n+    public void should_finish_stubbing_on_adding_return_value() throws Exception {\n         state.stubbingStarted();\n         invocationContainerImpl.addAnswer(new Returns(\"test\"));\n         state.validateState();\n     }\n-    \n+\n     @Test\n-    public void shouldGetResultsForMethods() throws Throwable {\n+    public void should_get_results_for_methods() throws Throwable {\n         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n         invocationContainerImpl.addAnswer(new Returns(\"simpleMethod\"));\n-        \n+\n         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n         invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));\n-        \n+\n         assertEquals(\"simpleMethod\", invocationContainerImpl.answerTo(simpleMethod));\n-        \n+\n         try {\n             invocationContainerImpl.answerTo(differentMethod);\n             fail();\n         } catch (MyException e) {}\n     }\n-    \n+\n     @Test\n-    public void shouldAddThrowableForVoidMethod() throws Throwable {\n+    public void should_get_results_for_methods_stub_only() throws Throwable {\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        invocationContainerImplStubOnly.addAnswer(new Returns(\"simpleMethod\"));\n+\n+        Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n+        invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        invocationContainerImplStubOnly.addAnswer(new ThrowsException(new MyException()));\n+\n+        assertEquals(\"simpleMethod\", invocationContainerImplStubOnly.answerTo(simpleMethod));\n+\n+        try {\n+            invocationContainerImplStubOnly.answerTo(differentMethod);\n+            fail();\n+        } catch (MyException e) {}\n+    }\n+\n+    @Test\n+    public void should_add_throwable_for_void_method() throws Throwable {\n         invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new MyException()));\n         invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));\n-        \n+\n         try {\n             invocationContainerImpl.answerTo(simpleMethod);\n             fail();\n         } catch (MyException e) {}\n     }\n-    \n+\n     @Test\n-    public void shouldValidateThrowableForVoidMethod() throws Throwable {\n+    public void should_validate_throwable_for_void_method() throws Throwable {\n         invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new Exception()));\n-        \n+\n         try {\n             invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));\n             fail();\n         } catch (MockitoException e) {}\n     }\n-    \n+\n     @Test\n-    public void shouldValidateThrowable() throws Throwable {\n+    public void should_validate_throwable() throws Throwable {\n         try {\n             invocationContainerImpl.addAnswer(new ThrowsException(null));\n             fail();\n         } catch (MockitoException e) {}\n     }\n-    \n-    @SuppressWarnings(\"serial\") \n+\n+    @SuppressWarnings(\"serial\")\n     class MyException extends RuntimeException {};\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/RegisteredInvocationsAllTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.invocation.Invocation;\n+import org.mockitoutil.TestBase;\n+\n+public class RegisteredInvocationsAllTest extends TestBase {\n+    \n+    private RegisteredInvocationsAll invocations;\n+    \n+    @Before\n+    public void setup() {\n+        invocations = new RegisteredInvocationsAll();\n+    }\n+    \n+    @Test\n+    public void should_not_return_to_string_method() throws Exception {\n+        Invocation toString = new InvocationBuilder().method(\"toString\").toInvocation();\n+        Invocation simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+        \n+        invocations.add(toString);\n+        invocations.add(simpleMethod);\n+        \n+        assertTrue(invocations.getAll().contains(simpleMethod));\n+        assertFalse(invocations.getAll().contains(toString));\n+    }\n+}\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n \n import static org.mockito.Matchers.isA;\n import static org.mockito.Mockito.*;\n+import org.mockito.exceptions.misusing.NotAMockException;\n \n public class BasicStubbingTest extends TestBase {\n \n     }\n     \n     @Test\n-    public void shouldEvaluateLatestStubbingFirst() throws Exception {\n+    public void should_evaluate_latest_stubbing_first() throws Exception {\n         when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n         when(mock.objectReturningMethod(200)).thenReturn(200);\n         \n     }\n     \n     @Test\n-    public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n+    public void should_stubbing_be_treated_as_interaction() throws Exception {\n         when(mock.booleanReturningMethod()).thenReturn(true);\n         \n         mock.booleanReturningMethod();\n     }\n     \n     @Test\n-    public void shouldAllowStubbingToString() throws Exception {\n+    public void should_allow_stubbing_to_string() throws Exception {\n         IMethods mockTwo = mock(IMethods.class);\n         when(mockTwo.toString()).thenReturn(\"test\");\n         \n     }\n     \n     @Test\n-    public void shouldStubbingNotBeTreatedAsInteraction() {\n+    public void should_stubbing_not_be_treated_as_interaction() {\n         when(mock.simpleMethod(\"one\")).thenThrow(new RuntimeException());\n         doThrow(new RuntimeException()).when(mock).simpleMethod(\"two\");\n         \n     }\n \n     @Test\n-    public void unfinishedStubbingCleansUpTheState() {\n+    public void unfinished_stubbing_cleans_up_the_state() {\n         reset(mock);\n         try {\n             when(\"\").thenReturn(\"\");\n     }\n     \n     @Test\n-    public void shouldToStringMockName() {\n+    public void should_to_string_mock_name() {\n         IMethods mock = mock(IMethods.class, \"mockie\");\n         IMethods mockTwo = mock(IMethods.class);\n         \n     }\n     \n     @Test\n-    public void shouldAllowMockingWhenToStringIsFinal() throws Exception {\n+    public void should_allow_mocking_when_to_string_is_final() throws Exception {\n         mock(Foo.class);\n     }\n+\n+    @Test\n+    public void test_stub_only_not_verifiable() throws Exception {\n+        IMethods localMock = mock(IMethods.class, withSettings().stubOnly());\n+\n+        when(localMock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n+        when(localMock.objectReturningMethod(200)).thenReturn(200);\n+\n+        assertEquals(200, localMock.objectReturningMethod(200));\n+        assertEquals(100, localMock.objectReturningMethod(666));\n+        assertEquals(\"default behavior should return null\", null, localMock.objectReturningMethod(\"blah\"));\n+\n+        try {\n+            verify(localMock, atLeastOnce()).objectReturningMethod(eq(200));\n+            fail();\n+            //TODO this should be more specific exception\n+        } catch (NotAMockException e) {}\n+\n+    }\n+\n }", "timestamp": 1346611078, "metainfo": ""}