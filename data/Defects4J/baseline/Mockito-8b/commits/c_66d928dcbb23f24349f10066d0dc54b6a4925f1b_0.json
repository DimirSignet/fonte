{"sha": "66d928dcbb23f24349f10066d0dc54b6a4925f1b", "log": "Finally, implemented the feature that shows verbose types in some corner cases (e.g. method takes long but the user just uses eq(100) instead eq(100L)). Previously, Mockito didn't print verbose args and the user could see \"arguments are different, wanted: foo(100) but got: foo(100)\". Now the user on the occasion will see \"arguments are different, wanted: foo((Integer) 100) but got: foo((Long) 100)\"  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401474", "commit": "\n--- a/src/org/mockito/internal/matchers/MatchersPrinter.java\n+++ b/src/org/mockito/internal/matchers/MatchersPrinter.java\n \n     private List<SelfDescribing> applyPrintSettings(List<Matcher> matchers, PrintSettings printSettings) {\n         List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing>();\n+        int i = 0;\n         for (final Matcher matcher : matchers) {\n-            if (matcher instanceof CanPrintArgumentVerbosely && printSettings.printsVerbosely(matcher)) {\n+            if (matcher instanceof CanPrintArgumentVerbosely && printSettings.printsVerbosely(i)) {\n                 withPrintSettings.add(((CanPrintArgumentVerbosely) matcher).getVerboseSelfDescribing());\n             } else {\n                 withPrintSettings.add(matcher);\n             }\n+            i++;\n         }\n         return withPrintSettings;\n     }\n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.hamcrest.Matcher;\n-\n @SuppressWarnings(\"unchecked\")\n public class PrintSettings {\n \n     private boolean multiline;\n-    private List<Matcher> verboseMatchers = new LinkedList<Matcher>();\n+    private List<Integer> verboseMatchers = new LinkedList<Integer>();\n \n     public void setMultiline(boolean multiline) {\n         this.multiline = multiline;\n         return multiline;\n     }\n \n-    public static PrintSettings verboseMatchers(Matcher ... verboselyPrinted) {\n+    public static PrintSettings verboseMatchers(Integer ... verboselyPrinted) {\n         PrintSettings settings = new PrintSettings();\n         settings.setMatchersToBePrintedVerbosely(verboselyPrinted);\n         return settings;\n     }\n \n-    public boolean printsVerbosely(Matcher matcher) {\n-        for (Matcher m : verboseMatchers) {\n-            if (m == matcher) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    public boolean printsVerbosely(int argumentIndex) {\n+        return verboseMatchers.contains(argumentIndex);\n     }\n \n-    public void setMatchersToBePrintedVerbosely(Matcher[] toBePrintedVerbosely) {\n+    public void setMatchersToBePrintedVerbosely(Integer[] toBePrintedVerbosely) {\n         this.verboseMatchers = Arrays.asList(toBePrintedVerbosely);\n     }\n }\n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n  */\n package org.mockito.internal.reporting;\n \n-import org.hamcrest.Matcher;\n \n /**\n  * Makes sure both wanted and actual are printed consistently (single line or multiline)\n     private final String wanted;\n     private final String actual;\n \n-    public SmartPrinter(PrintingFriendlyInocation wanted, PrintingFriendlyInocation actual, Matcher ... toBePrintedVerbosely) {\n+    public SmartPrinter(PrintingFriendlyInocation wanted, PrintingFriendlyInocation actual, Integer ... toBePrintedVerbosely) {\n         PrintSettings printSettings = new PrintSettings();\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n         printSettings.setMatchersToBePrintedVerbosely(toBePrintedVerbosely);\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n      * @param arguments\n      * @return\n      */\n-    public Matcher[] getSuspiciouslyNotMatchingArgs(List<Matcher> matchers, Object[] arguments) {\n+    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n         if (matchers.size() != arguments.length) {\n-            return new Matcher[0];\n+            return new Integer[0];\n         }\n         \n-        List<Matcher> suspicious = new LinkedList<Matcher>();\n+        List<Integer> suspicious = new LinkedList<Integer>();\n         int i = 0;\n         for (Matcher m : matchers) {\n             if (!safelyMatches(m, arguments[i]) && toStringEquals(m, arguments[i])) {\n-                suspicious.add(m);\n+                suspicious.add(i);\n             }\n             i++;\n         }\n-        return suspicious.toArray(new Matcher[0]);\n+        return suspicious.toArray(new Integer[0]);\n     }\n \n     private boolean safelyMatches(Matcher m, Object arg) {\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n             Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n             if (similar != null) {\n                 ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n-                Matcher[] toBePrintedVerbosely = argumentMatchingTool.getSuspiciouslyNotMatchingArgs(wanted.getMatchers(), similar.getArguments());\n+                Integer[] toBePrintedVerbosely = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n                 SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, toBePrintedVerbosely);\n                 reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n             } else {\n--- a/test/org/mockito/internal/matchers/MatchersPrinterTest.java\n+++ b/test/org/mockito/internal/matchers/MatchersPrinterTest.java\n \n     @Test\n     public void shouldPrintVerboselyOnlyMarkedMatchers() {\n-        //given\n-        Equals verboselyPrinted = new Equals(2);\n         //when\n-        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), verboselyPrinted), PrintSettings.verboseMatchers(verboselyPrinted));\n+        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(1));\n         //then\n         assertEquals(\"(1, (Integer) 2);\", line);\n     }\n \n     @Test\n     public void shouldGetVerboseArgumentsInBlock() {\n-        //given\n-        Equals verboselyPrinted = new Equals(1L);\n-        Equals verboselyPrintedTwo = new Equals(2);\n         //when\n-        String line = printer.getArgumentsBlock((List) Arrays.asList(verboselyPrinted, verboselyPrintedTwo), PrintSettings.verboseMatchers(verboselyPrinted, verboselyPrintedTwo));\n+        String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(0, 1));\n         //then\n         assertEquals(\"(\\n    (Long) 1,\\n    (Integer) 2\\n);\", line);\n     }\n \n     @Test\n     public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose() {\n-        //given\n-        Equals verboselyPrinted = new Equals(1L);\n         //when\n-        String line = printer.getArgumentsLine((List) Arrays.asList(verboselyPrinted, NotNull.NOT_NULL), PrintSettings.verboseMatchers(verboselyPrinted));\n+        String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL), PrintSettings.verboseMatchers(0));\n         //then\n         assertEquals(\"((Long) 1, notNull());\", line);\n     }\n--- a/test/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java\n+++ b/test/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java\n import org.hamcrest.Matcher;\n import org.junit.Test;\n import org.mockito.internal.matchers.Equals;\n+import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n-public class ArgumentMatchingToolTest {\n+public class ArgumentMatchingToolTest extends TestBase {\n \n     private ArgumentMatchingTool tool = new ArgumentMatchingTool();\n \n         List<Matcher> matchers = (List) Arrays.asList(new Equals(1));\n \n         //when\n-        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10, 20});\n+        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});\n         \n         //then\n         assertEquals(0, suspicious.length);\n         List<Matcher> matchers = (List) Arrays.asList(new Equals(10), new Equals(20));\n         \n         //when\n-        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10, 20});\n+        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});\n         \n         //then\n         assertEquals(0, suspicious.length);\n         \n         //when\n         List<Matcher> matchers = (List) Arrays.asList(new Equals(10), matcherInt20);\n-        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10, longPretendingAnInt});\n+        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, longPretendingAnInt});\n         \n         //then\n         assertEquals(1, suspicious.length);\n-        assertEquals(matcherInt20, suspicious[0]);\n+        assertEquals(new Integer(1), suspicious[0]);\n     }\n     \n     @Test\n             }});\n         \n         //when\n-        Matcher[] suspicious = tool.getSuspiciouslyNotMatchingArgs(matchers, new Object[] {10});\n+        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10});\n         \n         //then\n         assertEquals(0, suspicious.length);\n--- a/test/org/mockitousage/bugs/EqWithIntsDoesntCopeWithLongsTest.java\n+++ b/test/org/mockitousage/bugs/EqWithIntsDoesntCopeWithLongsTest.java\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n import org.mockitoutil.TestBase;\n \n-@Ignore\n public class EqWithIntsDoesntCopeWithLongsTest extends TestBase {\n \n     class Boo {\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n             //then\n-            assertContains(\"withLongAndInt((Integer) 100,  200)\", e.getMessage());\n-            assertContains(\"withLongAndInt((Long) 100,  200)\", e.getMessage());\n+            assertContains(\"withLongAndInt((Integer) 100, 200)\", e.getMessage());\n+            assertContains(\"withLongAndInt((Long) 100, 200)\", e.getMessage());\n         }\n     }\n     \n             fail();\n         } catch (ArgumentsAreDifferent e) {\n             //then\n-            assertContains(\"withLongAndInt((Integer) 100,  200)\", e.getMessage());\n-            assertContains(\"withLongAndInt((Long) 100,  <any>)\", e.getMessage());\n+            assertContains(\"withLongAndInt((Long) 100, 200)\", e.getMessage());\n+            assertContains(\"withLongAndInt((Integer) 100, <any>)\", e.getMessage());\n         }\n     }\n }", "timestamp": 1244238645, "metainfo": ""}