{"sha": "a7751c2763da93f0dece68d6da388e36d137647d", "log": "Changed the vargars behavior of argument captor. I prefer if the captor handles the varargs seamlessly, e.g. without any extra methods. The change needs some refactoring and documentation. The previous implementation was nice and had nice coverage - we might want to put that back if our users request extra methods for retrieving varg values from the captor.", "commit": "\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n package org.mockito;\n \n import org.mockito.internal.matchers.CapturingMatcher;\n-import org.mockito.internal.matchers.VarargCapturingMatcher;\n import org.mockito.internal.progress.HandyReturnValues;\n \n import java.util.List;\n     HandyReturnValues handyReturnValues = new HandyReturnValues();\n \n     private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();\n-    private final VarargCapturingMatcher<T> varargCapturingMatcher = new VarargCapturingMatcher<T>();\n     private final Class<T> clazz;\n \n     /**\n     }\n \n     /**\n-     * Use it to capture the variable arguments. This method <b>must be used inside of verification</b>.\n-     * <p>\n-     * Internally, this method registers a special implementation of an {@link ArgumentMatcher}.\n-     * This argument matcher stores the variable arguments values so that you can use it later to perform assertions.\n-     * <p>\n-     * See examples in javadoc for {@link ArgumentCaptor} class.\n-     *\n-     * @return null or default values\n-     */\n-    public T captureVararg() {\n-        Mockito.argThat(varargCapturingMatcher);\n-        return handyReturnValues.returnFor(clazz);\n-    }\n-\n-\n-    /**\n      * Returns the captured value of the argument.\n      * <p>\n      * If the method was called multiple times then it returns the latest captured value.\n      */\n     public T getValue() {\n         return this.capturingMatcher.getLastValue();\n-    }\n-\n-    /**\n-     * Returns the captured value of the variable arguments.\n-     * <p>\n-     * If the method was called multiple times then it returns the latest captured variable arguments.\n-     * <p>\n-     * See examples in javadoc for {@link ArgumentCaptor} class.\n-     *\n-     * @return captured varargs\n-     */\n-    public List<T> getVarargsValues() {\n-        return this.varargCapturingMatcher.getLastVarargs();\n     }\n \n     /**\n     }\n \n     /**\n-     * Returns all captured variable arguments. Use it in case the verified method was called multiple times.\n-     * <p>\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   ArgumentCaptor&lt;Person&gt; peopleFornamesCaptor = ArgumentCaptor.forClass(String.class);\n-     *   verify(mock, times(2)).doSomething(peopleFornamesCaptor.captureVarargs());\n-     *\n-     *   List&lt;String&gt; peopleFornames = peopleFornamesCaptor.getAllVarargs();\n-     *   assertThat(peopleFornames.get(0)).contains(\"John\", \"Carl\");\n-     *   assertThat(peopleFornames.get(1)).contains(\"Janes\", \"Eloise\", \"Lois\");\n-     * </code></pre>\n-     * See more examples in javadoc for {@link ArgumentCaptor} class.\n-     *\n-     * @return all captured varargs\n-     */\n-    public List<List<T>> getAllVarargsValues() {\n-        return this.varargCapturingMatcher.getAllVarargs();\n-    }\n-\n-    /**\n      * Build a new <code>ArgumentCaptor</code>.\n      * <p>\n      * Note that an <code>ArgumentCaptor</code> <b>*don't do any type checks*</b>, it is only there to avoid casting\n--- a/src/org/mockito/internal/invocation/ArgumentsComparator.java\n+++ b/src/org/mockito/internal/invocation/ArgumentsComparator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import org.hamcrest.Matcher;\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n  */\n \n package org.mockito.internal.invocation;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.Method;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.invocation.DescribedInvocation;\n import org.mockito.invocation.Invocation;\n import org.mockito.invocation.Location;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcher implements DescribedInvocation, CapturesArgumensFromInvocation, Serializable {\n     public void captureArgumentsFrom(Invocation invocation) {\n         for (int position = 0; position < matchers.size(); position++) {\n             Matcher m = matchers.get(position);\n-            if (m instanceof CapturesArguments && invocation.getArguments().length > position) {\n+            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                 if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n+                    Object array = invocation.getRawArguments()[position];\n+                    for (int i = 0; i < Array.getLength(array); i++) {\n+                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n+                    }\n+                    //since we've captured all varargs already, it does not make sense to process other matchers.\n+                    return;\n+                } else {\n                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n-                } else {\n-                    ((CapturesArguments) m).captureFrom(invocation.getArguments()[position]);\n                 }\n             }\n         }\n--- a/src/org/mockito/internal/matchers/CapturingMatcher.java\n+++ b/src/org/mockito/internal/matchers/CapturingMatcher.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.matchers;\n+\n+import org.hamcrest.Description;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.exceptions.Reporter;\n \n import java.io.Serializable;\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.hamcrest.Description;\n-import org.mockito.ArgumentMatcher;\n-import org.mockito.exceptions.Reporter;\n-\n @SuppressWarnings(\"unchecked\")\n-public class CapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, Serializable {\n+public class CapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {\n     \n     private static final long serialVersionUID = 4274067078639307295L;\n     private LinkedList<Object> arguments = new LinkedList<Object>();\n--- a/test/org/mockito/ArgumentCaptorTest.java\n+++ b/test/org/mockito/ArgumentCaptorTest.java\n         \n         //when\n         Object returned = argumentCaptor.capture();\n-        Object returned_for_vararg = argumentCaptor.captureVararg();\n \n         //then\n         assertEquals(expected, returned);\n-        assertEquals(expected, returned_for_vararg);\n     }\n \n     private HandyReturnValues will_return(final Object expected) {\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n  */\n \n package org.mockito.internal.invocation;\n-\n-import static java.util.Arrays.*;\n-\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n \n import org.fest.assertions.Assertions;\n import org.hamcrest.Matcher;\n import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Arrays.asList;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcherTest extends TestBase {\n         //given\n         mock.mixedVarargs(1, \"a\", \"b\");\n         Invocation invocation = getLastInvocation();\n-        VarargCapturingMatcher varargCapturingMatcher = new VarargCapturingMatcher();\n-        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(varargCapturingMatcher)));\n+        CapturingMatcher m = new CapturingMatcher();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));\n \n         //when\n         invocationMatcher.captureArgumentsFrom(invocation);\n \n         //then\n-        Assertions.assertThat(varargCapturingMatcher.getLastVarargs()).containsExactly(\"a\", \"b\");\n+        Assertions.assertThat(m.getAllValues()).containsExactly(\"a\", \"b\");\n     }\n \n     @Test  // like using several time the captor in the vararg\n--- a/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n+++ b/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n  */\n \n package org.mockitousage.matchers;\n-\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n-import java.util.List;\n \n import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import java.util.List;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.*;\n+\n public class CapturingArgumentsTest extends TestBase {\n \n     @Mock IMethods mock;\n         mock.varargsbyte((byte) 1, (byte) 2);\n \n         // then\n-        verify(mock).varargsbyte(argumentCaptor.captureVararg());\n-        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly((byte) 1, (byte) 2);\n+        verify(mock).varargsbyte(argumentCaptor.capture());\n+        assertEquals((byte) 2, (byte) argumentCaptor.getValue());\n+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);\n     }\n \n     @Test\n         mock.varargsbyte((byte) 1, (byte) 2);\n \n         // then\n-        verify(mock).varargsbyte(argumentCaptor.captureVararg());\n-        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly((byte) 1, (byte) 2);\n+        verify(mock).varargsbyte(argumentCaptor.capture());\n+        assertEquals((byte) 2, (byte) argumentCaptor.getValue());\n+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);\n     }\n \n     @Test\n         mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n \n         // then\n-        verify(mock).mixedVarargs(any(), argumentCaptor.captureVararg());\n-        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly(\"a\", \"b\", \"c\");\n+        verify(mock).mixedVarargs(any(), argumentCaptor.capture());\n+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\", \"b\", \"c\");\n     }\n \n     @Test\n         mock.mixedVarargs(42, \"again ?!\");\n \n         // then\n-        verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.captureVararg());\n-        List<List<String>> allVarargsValues = argumentCaptor.getAllVarargsValues();\n-        Assertions.assertThat(allVarargsValues.get(0)).containsExactly(\"a\", \"b\", \"c\");\n-        Assertions.assertThat(allVarargsValues.get(1)).containsExactly(\"again ?!\");\n+        verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.capture());\n+\n+        List<String> allVarargsValues = argumentCaptor.getAllValues();\n+        Assertions.assertThat(allVarargsValues).containsExactly(\"a\", \"b\", \"c\", \"again ?!\");\n     }\n \n     @Test\n         mock.simpleMethod(\"a\", 2);\n \n         // then\n-        verify(mock).simpleMethod(argumentCaptor.captureVararg(), eq(2));\n-        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly(\"a\");\n-    }\n-\n-\n-    @Test\n-    public void can_capture_vararg_using_standard_capturing_API() throws Exception {\n+        verify(mock).simpleMethod(argumentCaptor.capture(), eq(2));\n+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\");\n+    }\n+\n+    @Test\n+    public void captures_correclty_when_captor_used_multiple_times() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class);\n         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n         mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n \n         // then\n+        // this is only for backwards compatibility. It does not make sense in real to do so.\n         verify(mock).mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture(), argumentCaptor.capture());\n         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\", \"b\", \"c\");\n     }", "timestamp": 1365369631, "metainfo": ""}