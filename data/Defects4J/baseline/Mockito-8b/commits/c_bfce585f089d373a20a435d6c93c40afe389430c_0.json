{"sha": "bfce585f089d373a20a435d6c93c40afe389430c", "log": "Healthy refactoring. Removed cause based clickable stack traces. Removed stackTrace based locations.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401303", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import static org.mockito.exceptions.Pluralizer.*;\n import static org.mockito.internal.util.StringJoiner.*;\n \n-import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n         ));\n     }    \n \n-    public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, HasStackTrace actualStackTrace) {\n+    public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, Location actualLocation) {\n         String message = join(\"Argument(s) are different! Wanted:\", \n                 wanted.toString(),\n                 \"-> at \" + new Location(),\n                 \"Actual invocation has different arguments:\",\n                 actual.toString(),\n-                \"-> at \" + actualStackTrace.getStackTrace()[0],\n+                \"-> at \" + actualLocation,\n                 \"\"\n                 );\n         \n         ));\n     }\n     \n-    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, HasStackTrace previousStackTrace) {\n+    //TODO merge location into PrintableInvocation?\n+    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, Location previousLocation) {\n         throw new VerificationInOrderFailure(join(\n                     \"Verification in order failure\",\n                     \"Wanted but not invoked:\",\n                     \"-> at \" + new Location(),\n                     \"Wanted anywhere AFTER following interaction:\",\n                     previous.toString(),\n-                    \"-> at \" + previousStackTrace.getStackTrace()[0],\n+                    \"-> at \" + previousLocation,\n                     \"\"\n         ));\n     }\n \n-    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+    public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new TooManyActualInvocations(message);\n     }\n \n     private String createTooManyInvocationsMessage(int wantedCount, int actualCount, PrintableInvocation wanted,\n-            HasStackTrace firstUndesired) {\n+            Location firstUndesired) {\n         return join(\n                 wanted.toString(),\n                 \"Wanted \" + Pluralizer.pluralize(wantedCount) + \":\",\n                 \"-> at \" + new Location(),\n                 \"But was \" + pluralize(actualCount) + \". Undesired invocation:\",\n-                \"-> at \" + firstUndesired.getStackTrace()[0],\n+                \"-> at \" + firstUndesired,\n                 \"\"\n         );\n     }\n     \n-    public void neverWantedButInvoked(PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+    public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n         throw new NeverWantedButInvoked(join(\n                 wanted.toString(),\n                 \"Never wanted here:\",\n                 \"-> at \" + new Location(),\n                 \"But invoked here:\",\n-                \"-> at \" + firstUndesired.getStackTrace()[0],\n+                \"-> at \" + firstUndesired,\n                 \"\"\n         ));\n     }    \n     \n-    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+    public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n     }\n \n     private String createTooLittleInvocationsMessage(Discrepancy discrepancy, PrintableInvocation wanted,\n-            HasStackTrace lastActualStackTrace) {\n+            Location lastActualInvocation) {\n         String ending = \n-            (lastActualStackTrace != null)? \"-> at \" + lastActualStackTrace.getStackTrace()[0] + \"\\n\" : \"\\n\";\n+            (lastActualInvocation != null)? \"-> at \" + lastActualInvocation + \"\\n\" : \"\\n\";\n             \n             String message = join(\n                     wanted.toString(),\n             return message;\n     }\n    \n-    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, HasStackTrace lastActualStackTrace) {\n-        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualStackTrace);\n+    public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n         \n         throw new TooLittleActualInvocations(message);\n     }\n     \n-    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, HasStackTrace lastActualStackTrace) {\n-        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualStackTrace);\n+    public void tooLittleActualInvocationsInOrder(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n+        String message = createTooLittleInvocationsMessage(discrepancy, wanted, lastActualLocation);\n         \n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n                 ));\n     }\n     \n-    public void noMoreInteractionsWanted(PrintableInvocation undesired, HasStackTrace actualInvocationStackTrace) {\n+    public void noMoreInteractionsWanted(PrintableInvocation undesired, Location actualLocation) {\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 \"-> at \" + new Location(),\n                 \"But found this interaction:\",\n-                \"-> at \" + actualInvocationStackTrace.getStackTrace()[0],\n+                \"-> at \" + actualLocation,\n                 \"\"\n                 ));\n     }\n--- a/src/org/mockito/exceptions/base/MockitoAssertionError.java\n+++ b/src/org/mockito/exceptions/base/MockitoAssertionError.java\n  */\n package org.mockito.exceptions.base;\n \n-import java.util.Arrays;\n \n \n-public class MockitoAssertionError extends AssertionError implements HasStackTrace {\n+public class MockitoAssertionError extends AssertionError {\n \n     private static final long serialVersionUID = 1L;\n     private StackTraceElement[] unfilteredStackTrace;\n         StackTraceFilter filter = new StackTraceFilter();\n         filter.filterStackTrace(this);\n     }\n-    \n-    public MockitoAssertionError(String message, Throwable cause) {\n-        this(message);\n-\n-        if (cause != null) {\n-            this.initCause(cause);\n-            CommonStackTraceRemover remover = new CommonStackTraceRemover();\n-            remover.remove(this, Arrays.asList(cause.getStackTrace()));\n-        }\n-    }\n \n     public StackTraceElement[] getUnfilteredStackTrace() {\n         return unfilteredStackTrace;\n--- a/src/org/mockito/exceptions/base/MockitoException.java\n+++ b/src/org/mockito/exceptions/base/MockitoException.java\n package org.mockito.exceptions.base;\n \n \n-public class MockitoException extends RuntimeException implements HasStackTrace {\n+public class MockitoException extends RuntimeException {\n \n     private static final long serialVersionUID = 1L;\n \n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n         return fromMockObject || fromOrgMockito && !isRunner;\n     }\n \n-    public void filterStackTrace(HasStackTrace hasStackTrace) {\n+    public void filterStackTrace(Throwable hasStackTrace) {\n         StackTraceElement[] filtered = filterStackTrace(hasStackTrace.getStackTrace());\n         hasStackTrace.setStackTrace(filtered);\n     }\n--- a/src/org/mockito/exceptions/verification/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/ArgumentsAreDifferent.java\n \n     private static final long serialVersionUID = 1L;\n \n-    public ArgumentsAreDifferent(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-    \n     public ArgumentsAreDifferent(String message) {\n         super(message);\n     }\n--- a/src/org/mockito/exceptions/verification/TooLittleActualInvocations.java\n+++ b/src/org/mockito/exceptions/verification/TooLittleActualInvocations.java\n     public TooLittleActualInvocations(String message) {\n         super(message);\n     }\n-    \n-    public TooLittleActualInvocations(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n }\n--- a/src/org/mockito/exceptions/verification/TooManyActualInvocations.java\n+++ b/src/org/mockito/exceptions/verification/TooManyActualInvocations.java\n \n     private static final long serialVersionUID = 1L;\n \n-    public TooManyActualInvocations(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-    \n     public TooManyActualInvocations(String message) {\n         super(message);\n     }\n--- a/src/org/mockito/exceptions/verification/VerificationInOrderFailure.java\n+++ b/src/org/mockito/exceptions/verification/VerificationInOrderFailure.java\n \n     private static final long serialVersionUID = 1L;\n \n-    public VerificationInOrderFailure(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-\n     public VerificationInOrderFailure(String message) {\n         super(message);\n     }\n--- a/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n \n import junit.framework.ComparisonFailure;\n \n-import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.StackTraceFilter;\n \n \n-public class ArgumentsAreDifferent extends ComparisonFailure implements HasStackTrace {\n+public class ArgumentsAreDifferent extends ComparisonFailure {\n     \n     private static final long serialVersionUID = 1L;\n     private final String message;\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n     public String toString() {\n         return this.firstTraceElement.toString();\n     }\n-\n-    //TODO this needs to refactored - I don't want to talk to StackTraceElements any more\n-    public StackTraceElement[] getStackTrace() {\n-        return new StackTraceElement[] {firstTraceElement};\n-    }\n }\n--- a/src/org/mockito/internal/debugging/WarningsPrinter.java\n+++ b/src/org/mockito/internal/debugging/WarningsPrinter.java\n             logger.log(join(\n                 \"[Mockito] Warning - this method was not stubbed:\",\n                 i,\n-                i.getInvocation().getStackTrace().getStackTrace()[0],\n+                i.getInvocation().getLocation(),\n                 \"\"));\n         }\n     }\n             logger.log(join(\n                 \"[Mockito] Warning - this stub was not used:\",\n                 i,\n-                i.getStackTrace().getStackTrace()[0],\n+                i.getLocation(),\n                 \"\"));\n         }\n     }\n                             \"[Mockito] Warning - stubbed method called with different arguments.\",\n                             \"Stubbed this way:\",\n                             unused,\n-                            unused.getStackTrace().getStackTrace()[0],\n+                            unused.getLocation(),\n                             \"\",\n                             \"But called with different arguments:\",\n                             unstubbed,\n-                            unstubbed.getInvocation().getStackTrace().getStackTrace()[0],\n+                            unstubbed.getInvocation().getLocation(),\n                             \"\"));\n                     \n                     unusedIterator.remove();\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.hamcrest.Matcher;\n import org.hamcrest.StringDescription;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n-    private final HasStackTrace stackTrace;\n+    private final Location location;\n \n     private boolean verified;\n     private boolean verifiedInOrder;\n         this.method = method;\n         this.arguments = expandVarArgs(method.isVarArgs(), args);\n         this.sequenceNumber = sequenceNumber;\n-        this.stackTrace = new HasStackTrace() {\n-            \n-            private Location location = new Location();\n-            \n-            public StackTraceElement[] getStackTrace() {\n-                return location.getStackTrace();\n-            }\n-\n-            public void setStackTrace(StackTraceElement[] stackTrace) {\n-                throw new RuntimeException(\"Setting stack trace is not supported\");\n-            }\n-        };\n+        this.location = new Location();\n     }\n \n     //expands array varArgs that are given by runtime (1, [a, b]) into true varArgs (1, a, b);\n         return verifiedInOrder;\n     }\n     \n-    public HasStackTrace getStackTrace() {\n-        return stackTrace;\n-    }\n-\n     public boolean equals(Object o) {\n         if (o == null || !o.getClass().equals(this.getClass())) {\n             return false;\n     public boolean returnsPrimitive() {\n         return method.getReturnType().isPrimitive();\n     }\n+\n+    public Location getLocation() {\n+        return location;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n \n         return null;\n     }\n \n-    public HasStackTrace getLastStackTrace(List<Invocation> invocations) {\n+    //TODO rename\n+    public Location getLastStackTrace(List<Invocation> invocations) {\n         if (invocations.isEmpty()) {\n             return null;\n         } else {\n             Invocation last = invocations.get(invocations.size() - 1);\n-            return last.getStackTrace();\n+            return last.getLocation();\n         }\n     }\n     \n--- a/src/org/mockito/internal/stubbing/ThrowsException.java\n+++ b/src/org/mockito/internal/stubbing/ThrowsException.java\n  */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.exceptions.base.HasStackTraceThrowableWrapper;\n import org.mockito.exceptions.base.StackTraceFilter;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         Throwable filtered = throwable.fillInStackTrace();\n-        filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));\n+        filter.filterStackTrace(filtered);\n         throw filtered;\n     }\n \n--- a/src/org/mockito/internal/verification/NoMoreInteractions.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractions.java\n         Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n         \n         if (unverified != null) {\n-            new Reporter().noMoreInteractionsWanted(unverified, unverified.getStackTrace());\n+            new Reporter().noMoreInteractionsWanted(unverified, unverified.getLocation());\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n-            reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastInvocation);        \n+            Location lastLocation = finder.getLastStackTrace(actualInvocations);\n+            reporter.tooLittleActualInvocations(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);        \n         }\n         \n         for (Invocation i : actualInvocations) {\n--- a/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/AtLeastXNumberOfInvocationsInOrderChecker.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n-            reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastInvocation);\n+            Location lastLocation = finder.getLastStackTrace(chunk);\n+            reporter.tooLittleActualInvocationsInOrder(new AtLeastDiscrepancy(wantedCount, actualCount), wanted, lastLocation);\n         }\n         \n         for (Invocation i : chunk) {\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n     private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n         if (similar != null) {\n             SyncingPrinter syncingPrinter = new SyncingPrinter(wanted, similar);\n-            reporter.argumentsAreDifferent(syncingPrinter.getWanted(), syncingPrinter.getActual(), similar.getStackTrace());\n+            reporter.argumentsAreDifferent(syncingPrinter.getWanted(), syncingPrinter.getActual(), similar.getLocation());\n         } else {\n             reporter.wantedButNotInvoked(wanted);\n         }\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n         if (previousInOrder == null) {\n             reporter.wantedButNotInvoked(wanted);\n         } else {\n-            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getStackTrace());\n+            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getLocation());\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         \n         int actualCount = actualInvocations.size();\n         if (wantedCount > actualCount) {\n-            HasStackTrace lastInvocation = finder.getLastStackTrace(actualInvocations);\n+            Location lastInvocation = finder.getLastStackTrace(actualInvocations);\n             reporter.tooLittleActualInvocations(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount == 0 && actualCount > 0) {\n-            HasStackTrace firstUndesired = actualInvocations.get(wantedCount).getStackTrace();\n+            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n             reporter.neverWantedButInvoked(wanted, firstUndesired); \n         } else if (wantedCount < actualCount) {\n-            HasStackTrace firstUndesired = actualInvocations.get(wantedCount).getStackTrace();\n+            Location firstUndesired = actualInvocations.get(wantedCount).getLocation();\n             reporter.tooManyActualInvocations(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n--- a/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/NumberOfInvocationsInOrderChecker.java\n \n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n         int actualCount = chunk.size();\n         \n         if (wantedCount > actualCount) {\n-            HasStackTrace lastInvocation = finder.getLastStackTrace(chunk);\n+            Location lastInvocation = finder.getLastStackTrace(chunk);\n             reporter.tooLittleActualInvocationsInOrder(new Discrepancy(wantedCount, actualCount), wanted, lastInvocation);\n         } else if (wantedCount < actualCount) {\n-            HasStackTrace firstUndesired = chunk.get(wantedCount).getStackTrace();\n+            Location firstUndesired = chunk.get(wantedCount).getLocation();\n             reporter.tooManyActualInvocationsInOrder(wantedCount, actualCount, wanted, firstUndesired);\n         }\n         \n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.exceptions.ReporterTest;\n import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n import org.mockito.exceptions.base.MockitoExceptionTest;\n-import org.mockito.exceptions.base.StackTraceRemoverTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.MockHandlerTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n                     MockUtilTest.class,\n                     ReporterTest.class,\n                     MockitoAssertionErrorTest.class,\n-                    StackTraceRemoverTest.class,\n                     MockitoExceptionTest.class,\n                     StackTraceFilteringTest.class,\n                     BridgeMethodPuzzleTest.class,\n--- a/test/org/mockito/exceptions/base/MockitoAssertionErrorTest.java\n+++ b/test/org/mockito/exceptions/base/MockitoAssertionErrorTest.java\n             assertEquals(\"throwIt\", e.getUnfilteredStackTrace()[0].getMethodName());\n         }\n     }\n-    \n-    @Test\n-    public void shouldNotInitCauseWhenCauseIsNull() {\n-        new MockitoAssertionError(\"test\", null);\n-    }\n }\n--- a/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n+++ b/test/org/mockito/exceptions/base/StackTraceFilterTest.java\n \n     @Test\n     public void testShouldFilterOutCglibGarbage() {\n-        HasStackTrace trace = new TraceBuilder().classes(\n+        Throwable t = new TraceBuilder().classes(\n             \"MockitoExampleTest\",\n             \"List$$EnhancerByMockitoWithCGLIB$$2c406024\", \n             \"MethodInterceptorFilter\"\n-        ).toTrace();\n+        ).toThrowable();\n         \n-        filter.filterStackTrace(trace);\n+        filter.filterStackTrace(t);\n         \n-        assertThat(trace, hasOnlyThoseClassesInStackTrace(\"MockitoExampleTest\"));\n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"MockitoExampleTest\"));\n     }\n     \n     @Test\n     public void testShouldFilterOutMockitoPackage() {\n-        HasStackTrace trace = new TraceBuilder().classes(\n+        Throwable t = new TraceBuilder().classes(\n             \"org.test.MockitoSampleTest\",\n             \"org.test.TestSupport\",\n             \"org.mockito.Mockito\", \n             \"org.test.TestSupport\",\n             \"org.mockito.Mockito\"\n-        ).toTrace();\n+        ).toThrowable();\n             \n-        filter.filterStackTrace(trace);\n+        filter.filterStackTrace(t);\n         \n-        assertThat(trace, hasOnlyThoseClassesInStackTrace(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n+        assertThat(t, hasOnlyThoseClassesInStackTrace(\"org.test.TestSupport\", \"org.test.MockitoSampleTest\"));\n     }\n }\n--- a/test/org/mockito/exceptions/base/TraceBuilder.java\n+++ b/test/org/mockito/exceptions/base/TraceBuilder.java\n     private String[] methods = {};\n     private String[] classes = {};\n \n-    public HasStackTrace toTrace() {\n+    public Throwable toThrowable() {\n         List<StackTraceElement> trace = toTraceList();\n-        return new HasStackTraceStub(trace.toArray(new StackTraceElement[methods.length]));\n+        RuntimeException exception = new RuntimeException();\n+        exception.setStackTrace(trace.toArray(new StackTraceElement[0]));\n+        return exception;\n     }\n \n     public List<StackTraceElement> toTraceList() {\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldGetLastStackTrace() throws Exception {\n-        HasStackTrace last = finder.getLastStackTrace(invocations);\n-        assertSame(differentMethodInvocation.getStackTrace(), last);\n+        Location last = finder.getLastStackTrace(invocations);\n+        assertSame(differentMethodInvocation.getLocation(), last);\n         \n         assertNull(finder.getLastStackTrace(Collections.<Invocation>emptyList()));\n     } \n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         checker.check(invocations, wanted);\n         \n         assertEquals(wanted, reporterStub.wanted);\n-        assertNull(reporterStub.actualInvocationStackTrace);\n+        assertNull(reporterStub.actualLocation);\n     }\n     \n     @Test\n         assertNotNull(reporterStub.wanted);\n         assertNotNull(reporterStub.actual);\n         \n-        assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n+        assertSame(actualInvocation.getLocation(), reporterStub.actualLocation);\n     }\n     \n     class ReporterStub extends Reporter {\n         private PrintableInvocation wanted;\n         private PrintableInvocation actual;\n-        private HasStackTrace actualInvocationStackTrace;\n+        private Location actualLocation;\n         @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n             this.wanted = wanted;\n         }\n         \n-        @Override public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, HasStackTrace actualInvocationStackTrace) {\n+        @Override public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, Location actualLocation) {\n                     this.wanted = wanted;\n                     this.actual = actual;\n-                    this.actualInvocationStackTrace = actualInvocationStackTrace;\n+                    this.actualLocation = actualLocation;\n         }\n     }\n }\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         \n         assertEquals(wanted, reporterStub.wanted);\n         assertEquals(previous, reporterStub.previous);\n-        assertSame(previous.getStackTrace(), reporterStub.previousStackTrace);\n+        assertSame(previous.getLocation(), reporterStub.previousLocation);\n     }\n     \n     class ReporterStub extends Reporter {\n         private PrintableInvocation wanted;\n         private PrintableInvocation previous;\n-        private HasStackTrace previousStackTrace;\n+        private Location previousLocation;\n         \n-        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, HasStackTrace previousStackTrace) {\n+        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, Location previousStackTrace) {\n             this.wanted = wanted;\n             this.previous = previous;\n-            this.previousStackTrace = previousStackTrace;\n+            this.previousLocation = previousStackTrace;\n         }\n         \n         @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n--- a/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/NumberOfInvocationsCheckerTest.java\n import org.mockito.exceptions.Discrepancy;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.HasStackTrace;\n+import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         \n         checker.check(invocations, wanted, 100);\n         \n-        assertSame(second.getStackTrace(), reporterStub.stackTrace);\n+        assertSame(second.getLocation(), reporterStub.location);\n     }\n     \n     @Test\n         \n         checker.check(invocations, wanted, 100);\n         \n-        assertNull(reporterStub.stackTrace);\n+        assertNull(reporterStub.location);\n     }\n     \n     @Test\n         \n         checker.check(invocations, wanted, 2);\n         \n-        assertSame(third.getStackTrace(), reporterStub.stackTrace);\n+        assertSame(third.getLocation(), reporterStub.location);\n     }\n     \n     @Test\n         checker.check(invocations, wanted, 0);\n         \n         assertEquals(wanted, reporterStub.wanted);\n-        assertEquals(invocation.getStackTrace(), reporterStub.stackTrace);\n+        assertEquals(invocation.getLocation(), reporterStub.location);\n     }\n     \n     @Test\n         private int wantedCount;\n         private int actualCount;\n         private PrintableInvocation wanted;\n-        private HasStackTrace stackTrace;\n-        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, HasStackTrace lastActualInvocationStackTrace) {\n+        private Location location;\n+        @Override public void tooLittleActualInvocations(Discrepancy discrepancy, PrintableInvocation wanted, Location lastActualLocation) {\n                     this.wantedCount = discrepancy.getWantedCount();\n                     this.actualCount = discrepancy.getActualCount();\n                     this.wanted = wanted;\n-                    this.stackTrace = lastActualInvocationStackTrace;\n+                    this.location = lastActualLocation;\n         }\n         \n-        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+        @Override public void tooManyActualInvocations(int wantedCount, int actualCount, PrintableInvocation wanted, Location firstUndesired) {\n                     this.wantedCount = wantedCount;\n                     this.actualCount = actualCount;\n                     this.wanted = wanted;\n-                    this.stackTrace = firstUndesired;\n+                    this.location = firstUndesired;\n         }\n         \n         @Override\n-        public void neverWantedButInvoked(PrintableInvocation wanted, HasStackTrace firstUndesired) {\n+        public void neverWantedButInvoked(PrintableInvocation wanted, Location firstUndesired) {\n             this.wanted = wanted;\n-            this.stackTrace = firstUndesired;\n+            this.location = firstUndesired;\n         }\n     }\n }\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n  */\n package org.mockitousage;\n \n-import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n \n import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.Mockito;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n public class PlaygroundTest extends TestBase {\n \n     @Mock IMethods mock;\n+    @Mock DummyException mock2;\n+    \n+    class DummyException extends RuntimeException {\n+        public String otherMethod() {\n+            return \"\";\n+        }\n+    }\n \n     @Test\n-    public void testSomething() {\n-        anyString();\n-    }\n-    \n-    @Test\n     public void testGetLastUpdates() {\n-        mock = Mockito.mock(IMethods.class);\n+        when(mock.simpleMethod()).thenThrow(mock2);\n         mock.simpleMethod();\n     }\n }\n--- a/test/org/mockitousage/stacktrace/ClickableStackTracesTest.java\n+++ b/test/org/mockitousage/stacktrace/ClickableStackTracesTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n             assertThat(e, messageContains(\"verifyTheMock(\"));\n         }\n     }\n-\n-    @Test\n-    public void shouldShowActualAndExpected1() {\n-        callMethodOnMock(\"foo\");\n-        try {\n-            verifyTheMock(2, \"foo\");\n-            fail();\n-        } catch (TooLittleActualInvocations e) {\n-            assertThat(e, messageContains(\"callMethodOnMock(\"));\n-            assertThat(e, messageContains(\"verifyTheMock(\"));\n-        }\n-    }\n }\n--- a/test/org/mockitoutil/ExtraMatchers.java\n+++ b/test/org/mockitoutil/ExtraMatchers.java\n import java.util.Collections;\n import java.util.List;\n \n-import org.mockito.exceptions.base.HasStackTrace;\n-\n @SuppressWarnings(\"unchecked\")\n public class ExtraMatchers {\n \n         return hasMethodInStackTraceAt(0, method);\n     }\n     \n-    public static <T> Assertor hasOnlyThoseMethodsInStackTrace(final String ... methods) {\n-        return new Assertor() {\n-            public void assertValue(Object traceElements) {\n-                final List<StackTraceElement> trace;\n-                if (traceElements instanceof List) {\n-                    trace = (List<StackTraceElement>) traceElements;\n-                } else if (traceElements instanceof HasStackTrace) {\n-                    trace = Arrays.asList(((HasStackTrace) traceElements).getStackTrace());\n-                } else {\n-                    throw new RuntimeException(\"this matcher cannot deal with object provided: \" + traceElements);\n-                }\n-                \n-                assertEquals(methods.length, trace.size());\n-                    \n-                for (int i = 0; i < trace.size(); i++) {\n-                    assertEquals(methods[i], trace.get(i).getMethodName());\n-                }\n-            }\n-        };\n-    }\n-    \n-    public static <T> Assertor<HasStackTrace> hasOnlyThoseClassesInStackTrace(final String ... classes) {\n-        return new Assertor<HasStackTrace>() {\n-            public void assertValue(HasStackTrace traceElements) {\n+    public static <T> Assertor<Throwable> hasOnlyThoseClassesInStackTrace(final String ... classes) {\n+        return new Assertor<Throwable>() {\n+            public void assertValue(Throwable traceElements) {\n                 StackTraceElement[] trace = traceElements.getStackTrace();\n                 \n                 assertEquals(\"Number of classes does not match\",", "timestamp": 1239135185, "metainfo": ""}