{"sha": "eb9a52b8906b510c12f0d5aeb49ab1178228726c", "log": "- in order to implement issue 126 - Consider cloning parameters -- added 2 functional cases for cloning arguments -- created Answer called CloningArguments to verify parameters that can change after mock calls -- added LenientCopyTool.copyToRealObject with current copyTo not working for two objects with smae class (expected mock for 'to' object)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401748", "commit": "\n--- a/src/org/mockito/internal/util/reflection/LenientCopyTool.java\n+++ b/src/org/mockito/internal/util/reflection/LenientCopyTool.java\n     FieldCopier fieldCopier = new FieldCopier();\n \n     public <T> void copyToMock(T from, T mock) {\n-        Class clazz = from.getClass();\n-        Class mockSuperClass = mock.getClass().getSuperclass();\n-        assert mockSuperClass == clazz \n-            : \"Classes must have the same type: class of the object from: \" + clazz + \", mock super class: \" + mockSuperClass;\n+        copy(from, mock, from.getClass(), mock.getClass().getSuperclass());\n+    }\n \n-        while (clazz != Object.class) {\n-            copyValues(from, mock, clazz);\n-            clazz = clazz.getSuperclass();\n+    public <T> void copyToRealObject(T from, T to) {\n+        copy(from, to, from.getClass(), to.getClass());\n+    }\n+\n+    private <T> void copy(T from, T to, Class fromClazz, Class toClass) {\n+        assert toClass == fromClazz \n+            : \"Classes must have the same type: class of the object from: \" + fromClazz + \", mock super class: \" + toClass;\n+\n+        while (fromClazz != Object.class) {\n+            copyValues(from, to, fromClazz);\n+            fromClazz = fromClazz.getSuperclass();\n         }\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/stubbing/ClonesArguments.java\n+package org.mockito.stubbing;\n+\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n+import org.mockito.internal.util.reflection.LenientCopyTool;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.objenesis.ObjenesisHelper;\n+\n+public class ClonesArguments implements Answer<Object> {\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        Object[] arguments = invocation.getArguments();\n+        for (int i = 0; i < arguments.length; i++) {\n+            Object from = arguments[i];\n+            Object newInstance = ObjenesisHelper.newInstance(from.getClass());\n+            new LenientCopyTool().copyToRealObject(from, newInstance);\n+            arguments[i] = newInstance;\n+        }\n+        return new ReturnsEmptyValues().answer(invocation);\n+    }\n+}\n--- a/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n+++ b/test/org/mockito/internal/util/reflection/LenientCopyToolTest.java\n     }\n     \n     static class SomeObject extends InheritMe {\n-        @SuppressWarnings(\"unused\") \n-        // required because static fields needs to be excluded from copying \n+        @SuppressWarnings(\"unused\")\n         private static int staticField = -100;\n         private int privateField = -100;\n         private transient int privateTransientField = -100;\n         //then\n         verify(tool.fieldCopier, atLeast(3)).copyValue(any(), any(), any(Field.class));\n     }\n+    \n+    @Test\n+    public void shouldBeAbleToCopyFromRealObjectToRealObject() throws Exception {\n+        \n+        // given\n+        from.defaultField = \"defaultField\";\n+        from.instancePublicField = new SomeOtherObject();\n+        from.privateField = 1;\n+        from.privateTransientField = 2;\n+        from.protectedField = \"protectedField\";\n+        from.protectedInherited = \"protectedInherited\";\n+        to = new SomeObject(0);\n+        \n+        // when\n+        tool.copyToRealObject(from, to);\n+        \n+        // then\n+        assertEquals(from.defaultField, to.defaultField);\n+        assertEquals(from.instancePublicField, to.instancePublicField);\n+        assertEquals(from.privateField, to.privateField);\n+        assertEquals(from.privateTransientField, to.privateTransientField);\n+        assertEquals(from.protectedField, to.protectedField);\n+        assertEquals(from.protectedInherited, to.protectedInherited);\n+        \n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/CloningParameterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.stubbing.ClonesArguments;\n+import org.mockitoutil.TestBase;\n+\n+public class CloningParameterTest extends TestBase {\n+\n+    @Test\n+    public void shouldVerifyEvenIfArgumentsWereMutated() throws Exception {\n+\n+        // given\n+        EmailSender emailSender = mock(EmailSender.class, new ClonesArguments());\n+\n+        // when\n+        businessLogic(emailSender);\n+\n+        // then\n+        verify(emailSender).sendEmail(1, new Person(\"Wes\"));\n+    }\n+\n+    private void businessLogic(EmailSender emailSender) {\n+        Person person = new Person(\"Wes\");\n+        emailSender.sendEmail(1, person);\n+        person.emailSent();\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultValueWithCloningAnswer() throws Exception {\n+\n+        // given\n+        EmailSender emailSender = mock(EmailSender.class, new ClonesArguments());\n+        when(emailSender.getAllEmails(new Person(\"Wes\"))).thenAnswer(new ClonesArguments());\n+\n+        // when\n+        List<?> emails = emailSender.getAllEmails(new Person(\"Wes\"));\n+\n+        // then\n+        assertNotNull(emails);\n+    }\n+\n+    public class Person {\n+\n+        private final String name;\n+        private boolean emailSent;\n+\n+        public Person(String name) {\n+            this.name = name;\n+        }\n+\n+        public void emailSent() {\n+            emailSent = true;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getOuterType().hashCode();\n+            result = prime * result + (emailSent ? 1231 : 1237);\n+            result = prime * result + ((name == null) ? 0 : name.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Person other = (Person) obj;\n+            if (!getOuterType().equals(other.getOuterType()))\n+                return false;\n+            if (emailSent != other.emailSent)\n+                return false;\n+            if (name == null) {\n+                if (other.name != null)\n+                    return false;\n+            } else if (!name.equals(other.name))\n+                return false;\n+            return true;\n+        }\n+\n+        private CloningParameterTest getOuterType() {\n+            return CloningParameterTest.this;\n+        }\n+\n+    }\n+\n+    public interface EmailSender {\n+\n+        void sendEmail(int i, Person person);\n+\n+        List<?> getAllEmails(Person person);\n+\n+    }\n+}", "timestamp": 1258555280, "metainfo": ""}