{"sha": "2280719d768e3b1500bdb654a5c5b94ec913031b", "log": "added test  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40187", "commit": "\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n     public <T> T verify(T mock) {\n         return this.verify(mock, 1);\n     }\n-    //TODO VerificationMode should be interfaced so that 'ongoing' bit is hidden\n     //TODO get rid of interface with int\n     public <T> T verify(T mock, int wantedNumberOfInvocations) {\n         return this.verify(mock, VerificationMode.strict(wantedNumberOfInvocations, mocksToBeVerifiedSrictly));\n--- /dev/null\n+++ b/src/org/mockito/exceptions/parents/HasStackTraceThrowableWrapper.java\n+package org.mockito.exceptions.parents;\n+\n+public class HasStackTraceThrowableWrapper implements HasStackTrace {\n+\n+    private final Throwable throwable;\n+\n+    public HasStackTraceThrowableWrapper(Throwable throwable) {\n+        this.throwable = throwable;\n+    }\n+    \n+    public StackTraceElement[] getStackTrace() {\n+        return throwable.getStackTrace();\n+    }\n+\n+    public void setStackTrace(StackTraceElement[] stackTrace) {\n+        throwable.setStackTrace(stackTrace);\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/IAnswer.java\n+++ b/src/org/mockito/internal/stubbing/IAnswer.java\n  * @param <T> the type to return.\n  */\n public interface IAnswer<T> {\n+\n     /**\n-     * is called to answer an expected call. \n-     * The answer may be to return a value, or to throw an exception.\n-     * The arguments of the call for which the answer is generated \n-     * are available via getCurrentArguments() - be careful\n-     * here, using the arguments is not refactoring-safe.\n-     * \n      * @return the value to be returned\n      * @throws Throwable the throwable to be thrown\n      */\n--- a/src/org/mockito/internal/stubbing/Result.java\n+++ b/src/org/mockito/internal/stubbing/Result.java\n  */\n package org.mockito.internal.stubbing;\n \n-import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.exceptions.parents.HasStackTraceThrowableWrapper;\n import org.mockito.exceptions.parents.StackTraceFilter;\n \n @SuppressWarnings(\"unchecked\")\n         this.value = value;\n     }\n \n-    public static Result createThrowResult(final Throwable throwable) {\n+    public static Result createThrowResult(final Throwable throwable, final StackTraceFilter filter) {\n         return new Result(new IAnswer<Object>() {\n             public Object answer() throws Throwable {\n-                StackTraceFilter filter = new StackTraceFilter();\n-                final Throwable filtered = throwable.fillInStackTrace();\n-                \n-                //TODO unit test?\n-                filter.filterStackTrace(new HasStackTrace() {\n-                    public StackTraceElement[] getStackTrace() {\n-                        return filtered.getStackTrace();\n-                    }\n-                    public void setStackTrace(StackTraceElement[] stackTrace) {\n-                        filtered.setStackTrace(stackTrace);\n-                    }\n-                });\n-                \n+                Throwable filtered = throwable.fillInStackTrace();\n+                filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));\n                 throw filtered;\n             }\n         });\n     }\n     public static Result createReturnResult(final Object value) {\n-\n         return new Result(new IAnswer<Object>() {\n             public Object answer() throws Throwable {\n                 return value;\n         });\n     }\n \n-    public static Result createAnswerResult(IAnswer answer) {\n-        return new Result(answer);\n-    }\n-\n     public Object answer() throws Throwable {\n         return value.answer();\n     }\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n \n import org.mockito.internal.invocation.InvocationMatcher;\n \n+@SuppressWarnings(\"unchecked\")\n public class StubbedInvocationMatcher extends InvocationMatcher {\n \n-    private final Result result;\n+    private final IAnswer result;\n     \n-    public StubbedInvocationMatcher(InvocationMatcher invocation, Result result) {\n+    public StubbedInvocationMatcher(InvocationMatcher invocation, IAnswer result) {\n         super(invocation.getInvocation(), invocation.getMatchers());\n         this.result = result;\n     }\n \n-    public Result getResult() {\n-        return result;\n+    public Object answer() throws Throwable {\n+        return result.answer();\n     }\n     \n     @Override\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n import java.util.LinkedList;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.parents.StackTraceFilter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n     public void addThrowable(Throwable throwable) {\n         mockingProgress.stubbingCompleted();\n         validateThrowable(throwable);\n-        addResult(Result.createThrowResult(throwable));\n+        addResult(Result.createThrowResult(throwable, new StackTraceFilter()));\n     }\n \n     private void addResult(Result result) {\n     public Object resultFor(Invocation wanted) throws Throwable {\n         for (StubbedInvocationMatcher s : stubbed) {\n             if (s.matches(wanted)) {\n-                return s.getResult().answer();\n+                return s.answer();\n             }\n         }\n \n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n package org.mockito.internal.verification;\n \n import java.util.LinkedList;\n+import static org.mockito.internal.progress.VerificationMode.*;\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n     \n     public void verifyNoMoreInteractions() {\n         //TODO refactor to have single verify method\n-        //TODO VerificationMode.times(0) should be explicit\n-        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(VerificationMode.times(0)));\n+        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(times(0)));\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n     \n     public void verifyZeroInteractions() {\n         //TODO VerificationMode.times(0) should be explicit\n-        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(VerificationMode.times(0)));\n+        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(times(0)));\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/ResultTest.java\n+package org.mockito.internal.stubbing;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.exceptions.parents.StackTraceFilter;\n+\n+public class ResultTest {\n+\n+    @Test\n+    public void shouldCreateReturnResult() throws Throwable {\n+        Result result = Result.createReturnResult(\"lol\");\n+        assertEquals(\"lol\", result.answer());\n+    }\n+    \n+    @Test(expected=RuntimeException.class)\n+    public void shouldCreateThrowResult() throws Throwable {\n+        Result.createThrowResult(new RuntimeException(), new StackTraceFilter()).answer();\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceWhenCreatingThrowResult() throws Throwable {\n+        StackTraceFilterStub filterStub = new StackTraceFilterStub();\n+        Result result = Result.createThrowResult(new RuntimeException(), filterStub);\n+        try {\n+            result.answer(); \n+            fail();\n+        } catch (RuntimeException e) {\n+            assertTrue(Arrays.equals(filterStub.hasStackTrace.getStackTrace(), e.getStackTrace()));\n+            assertThat(\"should fill in stack trace\", e, hasFirstMethodInStackTrace(\"answer\"));\n+        }\n+    }\n+    \n+    class StackTraceFilterStub extends StackTraceFilter {\n+        HasStackTrace hasStackTrace;\n+        @Override public void filterStackTrace(HasStackTrace hasStackTrace) {\n+            this.hasStackTrace = hasStackTrace;\n+        }\n+    }\n+}", "timestamp": 1197649028, "metainfo": ""}