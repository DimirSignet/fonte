{"sha": "eaea9467f546f37fbeb16b128808d791a7836eb9", "log": "Merge pull request #5 from bric3/master  Enable Mockito mock serialization/deserialization across classloader/JVM", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n         throw new MockitoException(join(\n                 \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n-                \" do not implement Serializable.\",\n+                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                 \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                 \"\",\n                 \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n--- a/src/org/mockito/exceptions/base/MockitoException.java\n+++ b/src/org/mockito/exceptions/base/MockitoException.java\n import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n \n \n+/**\n+ * Raised by mockito to emit an error either due to Mockito, or due to the User.\n+ *\n+ * <p>\n+ *     The stack trace is filtered from mockito calls if you are using {@link #getStackTrace()}.\n+ *     For debugging purpose though you can still access the full stacktrace using {@link #getUnfilteredStackTrace()}.\n+ *     However note that other calls related to the stackTrace will refer to the filter stacktrace.\n+ * </p>\n+ *\n+ */\n public class MockitoException extends RuntimeException {\n \n     private static final long serialVersionUID = 1L;\n \n     private StackTraceElement[] unfilteredStackTrace;\n-    \n+\n+    // TODO lazy filtered stacktrace initialization\n     public MockitoException(String message, Throwable t) {\n         super(message, t);\n         filterStackTrace();\n--- /dev/null\n+++ b/src/org/mockito/exceptions/base/MockitoSerializationIssue.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.exceptions.base;\n+\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n+\n+import java.io.ObjectStreamException;\n+\n+/**\n+ * Raised by mockito to emit an error either due to Mockito, or due to the User.\n+ *\n+ * <p>\n+ *     The stack trace is filtered from mockito calls if you are using {@link #getStackTrace()}.\n+ *     For debugging purpose though you can still access the full stacktrace using {@link #getUnfilteredStackTrace()}.\n+ *     However note that other calls related to the stackTrace will refer to the filter stacktrace.\n+ * </p>\n+ *\n+ * @since 1.9.6\n+ */\n+public class MockitoSerializationIssue extends ObjectStreamException {\n+\n+    private StackTraceElement[] unfilteredStackTrace;\n+\n+    public MockitoSerializationIssue(String message, Exception cause) {\n+        super(message);\n+        initCause(cause);\n+        filterStackTrace();\n+    }\n+\n+    @Override\n+    public StackTraceElement[] getStackTrace() {\n+        filterStackTrace();\n+        return super.getStackTrace();\n+    }\n+\n+    private void filterStackTrace() {\n+        unfilteredStackTrace = super.getStackTrace();\n+\n+        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n+        filter.filter(this);\n+    }\n+\n+    public StackTraceElement[] getUnfilteredStackTrace() {\n+        return unfilteredStackTrace;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.creation;\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoSerializationIssue;\n+import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+\n+import java.io.*;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n+\n+/**\n+ * This is responsible for serializing a mock, it is enabled if the mock is implementing\n+ * {@link Serializable}.\n+ *\n+ * <p>\n+ *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},\n+ *     if the mock settings is set to be serializable it will add the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable} interface.\n+ *     This interface defines a the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n+ *     whose signature match the one that is looked by the standard Java serialization.\n+ * </p>\n+ *\n+ * <p>\n+ *     Then in the {@link MethodInterceptorFilter} of mockito, if the <code>writeReplace</code> method is called,\n+ *     it will use the custom implementation of this class {@link #writeReplace(Object)}. This method has a specific\n+ *     knowledge on how to serialize a mockito mock that is based on CGLIB.\n+ * </p>\n+ *\n+ * <p><strong>Only one instance per mock! See {@link MethodInterceptorFilter}</strong></p>\n+ *\n+ * TODO use a proper way to add the interface\n+ * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n+ * TODO check the class is mockable in the deserialization side\n+ *\n+ * @see CglibMockMaker\n+ * @see MethodInterceptorFilter\n+ * @author Brice Dutheil\n+ * @since 1.9.6\n+ */\n+@Incubating\n+public class AcrossJVMSerializationFeature implements Serializable {\n+    private static final long serialVersionUID = 7411152578314420778L;\n+    private static final String MOCKITO_PROXY_MARKER = \"MockitoProxyMarker\";\n+    private boolean instanceLocalCurrentlySerializingFlag = false;\n+    private Lock mutex = new ReentrantLock();\n+\n+    public boolean isWriteReplace(Method method) {\n+        return  method.getReturnType() == Object.class\n+                && method.getParameterTypes().length == 0\n+                && method.getName().equals(\"writeReplace\");\n+    }\n+\n+\n+    /**\n+     * Custom implementation of the <code>writeReplace</code> method for serialization.\n+     *\n+     * Here's how it's working and why :\n+     * <ol>\n+     *     <li>\n+     *         <p>When first entering in this method, it's because some is serializing the mock, with some code like :\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     objectOutputStream.writeObject(mock);\n+     * </code></pre>\n+     *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and\n+     *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.\n+     *         At this point, the code will return an {@link AcrossJVMMockSerializationProxy}.</p>\n+     *     </li>\n+     *     <li>\n+     *         <p>Now, in the constructor {@link AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n+     *         the mock is being serialized in a custom way (using {@link MockitoMockObjectOutputStream}) to a\n+     *         byte array. So basically it means the code is performing double nested serialization of the passed\n+     *         <code>mockitoMock</code>.</p>\n+     *\n+     *         <p>However the <code>ObjectOutputStream</code> will still detect the custom\n+     *         <code>writeReplace</code> and execute it.\n+     *         <em>(For that matter disabling replacement via {@link ObjectOutputStream#enableReplaceObject(boolean)}\n+     *         doesn't disable the <code>writeReplace</code> call, but just just toggle replacement in the\n+     *         written stream, <strong><code>writeReplace</code> is always called by\n+     *         <code>ObjectOutputStream</code></strong>.)</em></p>\n+     *\n+     *         <p>In order to avoid this recursion, obviously leading to a {@link StackOverflowError}, this method is using\n+     *         a flag that marks the mock as already being replaced, and then shouldn't replace itself again.\n+     *         <strong>This flag is local to this class</strong>, which means the flag of this class unfortunately needs\n+     *         to be protected against concurrent access, hence the reentrant lock.</p>\n+     *     </li>\n+     * </ol>\n+     *\n+     *\n+     * @param mockitoMock The Mockito mock to be serialized.\n+     * @return A wrapper ({@link AcrossJVMMockSerializationProxy}) to be serialized by the calling ObjectOutputStream.\n+     * @throws ObjectStreamException\n+     */\n+    public Object writeReplace(Object mockitoMock) throws ObjectStreamException {\n+        try {\n+            // reentrant lock for critical section. could it be improved ?\n+            mutex.lock();\n+            // mark started flag // per thread, not per instance\n+            // temporary loosy hack to avoid stackoverflow\n+            if(mockIsCurrentlyBeingReplaced()) {\n+                return mockitoMock;\n+            }\n+            mockReplacementStarted();\n+\n+            return new AcrossJVMMockSerializationProxy(mockitoMock);\n+        } catch (IOException ioe) {\n+            MockUtil mockUtil = new MockUtil();\n+            MockName mockName = mockUtil.getMockName(mockitoMock);\n+            String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();\n+            throw new MockitoSerializationIssue(join(\n+                    \"The mock '\" + mockName + \"' of type '\" + mockedType + \"'\",\n+                    \"The Java Standard Serialization reported an '\" + ioe.getClass().getSimpleName() + \"' saying :\",\n+                    \"  \" + ioe.getMessage()\n+            ), ioe);\n+        } finally {\n+            // unmark\n+            mockReplacementCompleted();\n+            mutex.unlock();\n+        }\n+    }\n+\n+\n+    private void mockReplacementCompleted() {\n+        instanceLocalCurrentlySerializingFlag = false;\n+    }\n+\n+\n+    private void mockReplacementStarted() {\n+        instanceLocalCurrentlySerializingFlag = true;\n+    }\n+\n+\n+    private boolean mockIsCurrentlyBeingReplaced() {\n+        return instanceLocalCurrentlySerializingFlag;\n+    }\n+\n+\n+    /**\n+     * Enable serialization serialization that will work across classloaders / and JVM.\n+     *\n+     * <p>Only enable if settings says the mock should be serializable. In this case add the\n+     * {@link AcrossJVMMockitoMockSerializable} to the extra interface list.</p>\n+     *\n+     * @param settings Mock creation settings.\n+     * @param <T> Type param to not be bothered by the generics\n+     */\n+    public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {\n+        if (settings.isSerializable()) {\n+            // havin faith that this set is modifiable\n+            // TODO use a proper way to add the interface\n+            settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerializable.class);\n+        }\n+    }\n+\n+\n+    /**\n+     * This is the serialization proxy that will encapsulate the real mock data as a byte array.\n+     *\n+     * <p>When called in the constructor it will serialize the mock in a byte array using a\n+     * custom {@link MockitoMockObjectOutputStream} that will annotate the mock class in the stream.\n+     * other information are used in this class in order to facilitate deserialization.\n+     * </p>\n+     *\n+     * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via\n+     * the custom {@link MockitoMockObjectInputStream} that will be in charge of creating the mock class.</p>\n+     */\n+    public static class AcrossJVMMockSerializationProxy implements Serializable {\n+\n+\n+        private static final long serialVersionUID = -7600267929109286514L;\n+        private byte[] serializedMock;\n+        private Class typeToMock;\n+        private Set<Class> extraInterfaces;\n+        /**\n+         * Creates the wrapper that be used in the serialization stream.\n+         *\n+         * <p>Immediately serializes the Mockito mock using specifically crafted {@link MockitoMockObjectOutputStream},\n+         * in a byte array.</p>\n+         *\n+         * @param mockitoMock The Mockito mock to serialize.\n+         * @throws IOException\n+         */\n+        public AcrossJVMMockSerializationProxy(Object mockitoMock) throws IOException {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);\n+\n+            objectOutputStream.writeObject(mockitoMock);\n+\n+            objectOutputStream.close();\n+            out.close();\n+\n+            MockCreationSettings mockSettings = new MockUtil().getMockSettings(mockitoMock);\n+            this.serializedMock = out.toByteArray();\n+            this.typeToMock = mockSettings.getTypeToMock();\n+            this.extraInterfaces = mockSettings.getExtraInterfaces();\n+        }\n+\n+        /**\n+         * Resolves the proxy to a new deserialized instance of the Mockito mock.\n+         *\n+         * <p>Uses the custom crafted {@link MockitoMockObjectInputStream} to deserialize the mock.</p>\n+         *\n+         * @return A deserialized instance of the Mockito mock.\n+         * @throws ObjectStreamException\n+         */\n+        private Object readResolve() throws ObjectStreamException {\n+            try {\n+                ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);\n+                ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);\n+\n+                Object deserializedMock = objectInputStream.readObject();\n+\n+                bis.close();\n+                objectInputStream.close();\n+\n+                return deserializedMock;\n+            } catch (IOException ioe) {\n+                throw new MockitoSerializationIssue(join(\n+                        \"Mockito mock cannot be deserialized to a mock of '\" + typeToMock.getCanonicalName() + \"'. The error was :\",\n+                        \"  \" + ioe.getMessage(),\n+                        \"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), ioe);\n+            } catch (ClassNotFoundException cce) {\n+                throw new MockitoSerializationIssue(join(\n+                        \"A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :\",\n+                        \"  \" + cce.getMessage(),\n+                        \"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), cce);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectInputStream</code> that will resolve the Mockito proxy class.\n+     *\n+     * <p>\n+     *     This specificaly crafted ObjectInoutStream has the most important role to resolve the Mockito generated\n+     *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream\n+     *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it\n+     *     delegates class resolution to the default super behavior.\n+     *     The mirror method used for serializing the mock is {@link MockitoMockObjectOutputStream#annotateClass(Class)}.\n+     * </p>\n+     *\n+     * <p>\n+     *     When this marker is found, {@link ClassImposterizer} methods are being used to create the mock class.\n+     *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the\n+     *     {@link org.mockito.internal.creation.jmock.SearchingClassLoader} that will look if this enhanced class has\n+     *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer\n+     *     code.</em>\n+     * </p>\n+     */\n+    public static class MockitoMockObjectInputStream extends ObjectInputStream {\n+        private Class typeToMock;\n+        private Set<Class> extraInterfaces;\n+\n+        public MockitoMockObjectInputStream(InputStream in, Class typeToMock, Set<Class> extraInterfaces) throws IOException {\n+            super(in) ;\n+            this.typeToMock = typeToMock;\n+            this.extraInterfaces = extraInterfaces;\n+            enableResolveObject(true); // ensure resolving is enabled\n+        }\n+\n+        /**\n+         * Resolve the Mockito proxy class if it is marked as such.\n+         *\n+         * <p>Uses the fields {@link #typeToMock} and {@link #extraInterfaces} to\n+         * create the Mockito proxy class as the <code>ObjectStreamClass</code>\n+         * doesn't carry useful information for this purpose.</p>\n+         *\n+         * @param desc Description of the class in the stream, not used.\n+         * @return The class that will be used to deserialize the instance mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        @Override\n+        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n+            if (notMarkedAsAMockitoMock(readObject())) {\n+                return super.resolveClass(desc);\n+            }\n+\n+            // TODO check the class is mockable in the deserialization side\n+            // ClassImposterizer.INSTANCE.canImposterise(typeToMock);\n+\n+            // create the Mockito mock class before it can even be deserialized\n+            ClassImposterizer.INSTANCE.setConstructorsAccessible(typeToMock, true);\n+            Class<?> proxyClass = ClassImposterizer.INSTANCE.createProxyClass(\n+                    typeToMock,\n+                    extraInterfaces.toArray(new Class[extraInterfaces.size()])\n+            );\n+\n+            hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);\n+\n+            return proxyClass;\n+\n+        }\n+\n+        /**\n+         * Hack the <code>name</code> field of the given <code>ObjectStreamClass</code> with\n+         * the <code>newProxyClass</code>.\n+         *\n+         * The parent ObjectInputStream will check the name of the class in the stream matches the name of the one\n+         * that is created in this method.\n+         *\n+         * The CGLIB classes uses a hash of the classloader and/or maybe some other data that allow them to be\n+         * relatively unique in a JVM.\n+         *\n+         * When names differ, which happens when the mock is deserialized in another ClassLoader, a\n+         * <code>java.io.InvalidObjectException</code> is thrown, so this part of the code is hacking through\n+         * the given <code>ObjectStreamClass</code> to change the name with the newly created class.\n+         *\n+         * @param descInstance The <code>ObjectStreamClass</code> that will be hacked.\n+         * @param proxyClass The proxy class whose name will be applied.\n+         * @throws InvalidObjectException\n+         */\n+        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {\n+            try {\n+              Field classNameField = descInstance.getClass().getDeclaredField(\"name\");\n+              new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());\n+            } catch (NoSuchFieldException nsfe) {\n+                // TODO use our own mockito mock serialization exception\n+                throw new MockitoSerializationIssue(join(\n+                        \"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',\",\n+                        \"this is definitely a bug in our code as it means the JDK team changed a few internal things.\",\n+                        \"\",\n+                        \"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome.\"\n+                ), nsfe);\n+            }\n+        }\n+\n+        /**\n+         * Read the stream class annotation and identify it as a Mockito mock or not.\n+         *\n+         * @param marker The marker to identify.\n+         * @return <code>true</code> if not marked as a Mockito, <code>false</code> if the class annotation marks a Mockito mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {\n+            return !MOCKITO_PROXY_MARKER.equals(marker);\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectOutputStream</code>.\n+     *\n+     * <p>\n+     *     This output stream has the role of marking in the stream the Mockito class. This\n+     *     marking process is necessary to identify the proxy class that will need to be recreated.\n+     *\n+     *     The mirror method used for deserializing the mock is\n+     *     {@link MockitoMockObjectInputStream#resolveClass(ObjectStreamClass)}.\n+     * </p>\n+     *\n+     */\n+    private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n+        private static final String NOTHING = \"\";\n+        private MockUtil mockUtil = new MockUtil();\n+\n+        public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n+            super(out);\n+        }\n+\n+        /**\n+         * Annotates (marks) the class if this class is a Mockito mock.\n+         *\n+         * @param cl The class to annotate.\n+         * @throws IOException\n+         */\n+        @Override\n+        protected void annotateClass(Class<?> cl) throws IOException {\n+            writeObject(mockitoProxyClassMarker(cl));\n+            // might be also useful later, for embedding classloader info ...maybe ...maybe not\n+        }\n+\n+        /**\n+         * Returns the Mockito marker if this class is a Mockito mock.\n+         *\n+         * @param cl The class to mark.\n+         * @return The marker if this is a Mockito proxy class, otherwise returns a void marker.\n+         */\n+        private String mockitoProxyClassMarker(Class<?> cl) {\n+            if (mockUtil.isMock(cl)) {\n+                return MOCKITO_PROXY_MARKER;\n+            } else {\n+                return NOTHING;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an\n+     * <code>ObjectOutputStream</code>.\n+     *\n+     * It will be applied before the creation of the mock when the mock setting says it should serializable.\n+     *\n+     * @see #enableSerializationAcrossJVM(org.mockito.mock.MockCreationSettings)\n+     */\n+    public interface AcrossJVMMockitoMockSerializable {\n+        public Object writeReplace() throws java.io.ObjectStreamException;\n+    }\n+}\n--- a/src/org/mockito/internal/creation/CglibMockMaker.java\n+++ b/src/org/mockito/internal/creation/CglibMockMaker.java\n \n     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n         InternalMockHandler mockitoHandler = cast(handler);\n+        new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);\n         return ClassImposterizer.INSTANCE.imposterise(\n                 new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n     }\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n \n package org.mockito.internal.creation;\n \n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.cglib.CGLIBHacker;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n+import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n+import org.mockito.internal.progress.SequenceNumber;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n import java.io.Serializable;\n import java.lang.reflect.Method;\n \n-import org.mockito.cglib.proxy.MethodInterceptor;\n-import org.mockito.cglib.proxy.MethodProxy;\n-import org.mockito.internal.InternalMockHandler;\n-import org.mockito.invocation.Invocation;\n-import org.mockito.invocation.MockHandler;\n-import org.mockito.internal.creation.cglib.CGLIBHacker;\n-import org.mockito.internal.invocation.*;\n-import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n-import org.mockito.internal.progress.SequenceNumber;\n-import org.mockito.internal.util.ObjectMethodsGuru;\n-import org.mockito.mock.MockCreationSettings;\n-\n+/**\n+ * Should be one instance per mock instance, see CglibMockMaker.\n+ *\n+ *\n+ */\n public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n \n     private static final long serialVersionUID = 6182795666612683784L;\n     CGLIBHacker cglibHacker = new CGLIBHacker();\n     ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n     private final MockCreationSettings mockSettings;\n+    private AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();\n \n     public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {\n         this.handler = handler;\n             return proxy == args[0];\n         } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n             return hashCodeForMock(proxy);\n+        } else if (acrossJVMSerializationFeature.isWriteReplace(method)) {\n+            return acrossJVMSerializationFeature.writeReplace(proxy);\n         }\n         \n         MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockNameImpl;\n+import org.mockito.internal.util.MockitoMock;\n import org.mockito.internal.util.MockitoSpy;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n \n     private static Set<Class> prepareExtraInterfaces(CreationSettings settings) {\n         Set<Class> interfaces = new HashSet<Class>(settings.getExtraInterfaces());\n+        interfaces.add(MockitoMock.class);\n         if(settings.isSerializable()) {\n             interfaces.add(Serializable.class);\n         }\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n     }\n     \n     public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Class<?>... ancillaryTypes) {\n+        Class<?> proxyClass = null;\n+        Object proxyInstance = null;\n         try {\n             setConstructorsAccessible(mockedType, true);\n-            Class<?> proxyClass = createProxyClass(mockedType, ancillaryTypes);\n-            return mockedType.cast(createProxy(proxyClass, interceptor));\n+            proxyClass = createProxyClass(mockedType, ancillaryTypes);\n+            proxyInstance = createProxy(proxyClass, interceptor);\n+            return mockedType.cast(proxyInstance);\n         } catch (ClassCastException cce) {\n+            // NPE unlikely to happen because CCE will only happen on the cast statement\n             throw new MockitoException(join(\n-                \"ClassCastException occurred when creating the proxy.\",\n+                \"ClassCastException occurred while creating the mockito proxy :\",\n+                \"  class to imposterize : '\" + mockedType.getCanonicalName() + \"', loaded by classloader : '\" + mockedType.getClassLoader() + \"'\",\n+                \"  imposterizing class : '\" + proxyClass.getCanonicalName() + \"', loaded by classloader : '\" + proxyClass.getClassLoader() + \"'\",\n+                \"  proxy instance class : '\" + proxyInstance.getClass().getCanonicalName() + \"', loaded by classloader : '\" + proxyInstance.getClass().getClassLoader() + \"'\",\n+                \"\",\n                 \"You might experience classloading issues, disabling the Objenesis cache *might* help (see MockitoConfiguration)\"\n             ), cce);\n         } finally {\n         }\n     }\n     \n-    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n+    public void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n         for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n             constructor.setAccessible(accessible);\n         }\n     }\n     \n-    private Class<?> createProxyClass(Class<?> mockedType, Class<?>...interfaces) {\n+    public Class<?> createProxyClass(Class<?> mockedType, Class<?>... interfaces) {\n         if (mockedType == Object.class) {\n             mockedType = ClassWithSuperclassToWorkAroundCglibBug.class;\n         }\n         } else {\n             enhancer.setNamingPolicy(MockitoNamingPolicy.INSTANCE);\n         }\n+\n+        enhancer.setSerialVersionUID(42L);\n         \n         try {\n             return enhancer.createClass(); \n--- a/src/org/mockito/internal/creation/jmock/SerializableNoOp.java\n+++ b/src/org/mockito/internal/creation/jmock/SerializableNoOp.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.jmock;\n-\n-import java.io.Serializable;\n \n import org.mockito.cglib.proxy.Callback;\n import org.mockito.cglib.proxy.NoOp;\n \n+import java.io.Serializable;\n+\n+/**\n+ * Offer a Serializable implementation of the NoOp CGLIB callback.\n+ */\n public class SerializableNoOp implements NoOp, Serializable {\n \n   private static final long serialVersionUID = 7434976328690189159L;\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n \n package org.mockito.internal.stubbing.defaultanswers;\n \n-import org.mockito.internal.creation.ClassNameFinder;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.util.Primitives;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n \n /**\n  * Default answer of every Mockito mock.\n     \n     private static final long serialVersionUID = 1998191268711234347L;\n     ObjectMethodsGuru methodsGuru = new ObjectMethodsGuru();\n+    MockUtil mockUtil = new MockUtil();\n \n     /* (non-Javadoc)\n      * @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock)\n     public Object answer(InvocationOnMock invocation) {\n         if (methodsGuru.isToString(invocation.getMethod())) {\n             Object mock = invocation.getMock();\n-            MockName name = new MockUtil().getMockName(mock);\n+            MockName name = mockUtil.getMockName(mock);\n             if (name.isDefault()) {\n-                return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n+                return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n             } else {\n                 return name.toString();\n             }\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.util.reflection.Constructors;\n \n import java.io.Serializable;\n import java.util.Collection;\n         // We can't catch all the errors with this piece of code\n         // Having a **superclass that do not implements Serializable** might fail as well when serialized\n         // Though it might prevent issues when mockito is mocking a class without superclass.\n-        if(serializable && !classToMock.isInterface() && !(Serializable.class.isAssignableFrom(classToMock))) {\n+        if(serializable\n+                && !classToMock.isInterface()\n+                && !(Serializable.class.isAssignableFrom(classToMock))\n+                && Constructors.noArgConstructorOf(classToMock) == null\n+                ) {\n             new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n         }\n     }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n     }\n \n     public boolean isMock(Object mock) {\n-        return mock != null && isMockitoMock(mock);\n+        // double check to avoid classes that have the same interfaces, could be great to have a custom mockito field in the proxy instead of relying on instance fields\n+        return mock instanceof MockitoMock && isMockitoMock(mock);\n     }\n \n     public boolean isSpy(Object mock) {\n-        return mock instanceof MockitoSpy && isMock(mock);\n+        return mock instanceof MockitoSpy;\n+    }\n+\n+    public boolean isMock(Class mockClass) {\n+        return mockClass != null && MockitoMock.class.isAssignableFrom(mockClass);\n+    }\n+\n+    public boolean isSpy(Class mockClass) {\n+        return mockClass != null && MockitoSpy.class.isAssignableFrom(mockClass);\n     }\n \n     private <T> boolean isMockitoMock(T mock) {\n             ((CreationSettings) getMockHandler(mock).getMockSettings()).setMockName(new MockNameImpl(newName));\n         }\n     }\n+\n+    public MockCreationSettings getMockSettings(Object mock) {\n+        return getMockHandler(mock).getMockSettings();\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/MockitoMock.java\n+package org.mockito.internal.util;\n+\n+/**\n+ * Mark internally a Mockito mock.\n+ *\n+ * To be used un conjunction with {@link MockUtil#isMock(Object)}\n+ */\n+public interface MockitoMock {\n+}\n--- a/src/org/mockito/internal/util/MockitoSpy.java\n+++ b/src/org/mockito/internal/util/MockitoSpy.java\n package org.mockito.internal.util;\n \n /**\n- * Mark internally a MockitoSpy.\n+ * Mark internally a Mockito spy.\n  *\n- * To be used un conjunction with {@link MockUtil#isMock(Object)}\n+ * To be used un conjunction with {@link MockUtil#isMock(Object)} or {@link MockUtil#isSpy(Object)}.\n  */\n-public interface MockitoSpy {\n+public interface MockitoSpy extends MockitoMock {\n }\n--- a/src/org/mockito/internal/util/ObjectMethodsGuru.java\n+++ b/src/org/mockito/internal/util/ObjectMethodsGuru.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n+\n+import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.invocation.MockitoMethod;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n-\n-import org.mockito.internal.creation.DelegatingMethod;\n-import org.mockito.internal.invocation.MockitoMethod;\n \n public class ObjectMethodsGuru implements Serializable {\n \n     }\n \n     public boolean isToString(MockitoMethod method) {\n-        return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n+        return method.getReturnType() == String.class\n+                && method.getParameterTypes().length == 0\n                 && method.getName().equals(\"toString\");\n     }\n \n     public boolean isEqualsMethod(Method method) {\n-        return method.getName().equals(\"equals\") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class;\n+        return method.getName().equals(\"equals\")\n+                && method.getParameterTypes().length == 1\n+                && method.getParameterTypes()[0] == Object.class;\n     }\n \n     public boolean isHashCodeMethod(Method method) {\n-        return method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0;\n+        return method.getName().equals(\"hashCode\")\n+                && method.getParameterTypes().length == 0;\n     }\n \n     public boolean isCompareToMethod(Method method) {\n-        return Comparable.class.isAssignableFrom(method.getDeclaringClass()) && method.getName().equals(\"compareTo\")\n-                && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == method.getDeclaringClass();\n+        return Comparable.class.isAssignableFrom(method.getDeclaringClass())\n+                && method.getName().equals(\"compareTo\")\n+                && method.getParameterTypes().length == 1\n+                && method.getParameterTypes()[0] == method.getDeclaringClass();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/Constructors.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Constructor;\n+\n+public abstract class Constructors {\n+\n+    /**\n+     * Returns the no arg constructor of the type if any.\n+     *\n+     * @param classToMock The type to look for a no-arg constructor\n+     * @return The no-arg constructor or null if none is declared.\n+     */\n+    public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {\n+        try {\n+            return classToMock.getDeclaredConstructor();\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/util/reflection/Fields.java\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n public abstract class Fields {\n \n     /**\n-     * Instance fields declared in thes class and superclasses of the given instance.\n+     * Instance fields declared in the class and superclasses of the given instance.\n      *\n      * @param instance Instance from which declared fields will be retrieved.\n      * @return InstanceFields of this object instance.\n     }\n \n     /**\n-     * Instance fields declared in the of the given instance.\n+     * Instance fields declared in the class of the given instance.\n      *\n      * @param instance Instance from which declared fields will be retrieved.\n      * @return InstanceFields of this object instance.\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Observer;\n \n import static java.util.Arrays.asList;\n import static org.fest.assertions.Assertions.assertThat;\n \n     @Test(expected = MockitoException.class)\n     public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable() {\n+        class NonSerializableInnerClassThatHaveAHiddenOneArgConstructor {}\n         boolean serializable = true;\n-        validator.validateSerializable(Observable.class, serializable);\n+        validator.validateSerializable(NonSerializableInnerClassThatHaveAHiddenOneArgConstructor.class, serializable);\n     }\n \n     @Test\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n import org.mockito.cglib.proxy.NoOp;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Set;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n     private MockUtil mockUtil = new MockUtil();\n \n     @Test\n-    public void shouldGetHandler() {\n+    public void should_get_handler() {\n         List mock = Mockito.mock(List.class);\n         assertNotNull(mockUtil.getMockHandler(mock));\n     }\n \n     @Test \n-    public void shouldScreamWhenEnhancedButNotAMockPassed() {\n+    public void should_scream_when_enhanced_but_not_a_mock_passed() {\n         Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);\n         try {\n             mockUtil.getMockHandler(o);\n     }\n \n     @Test (expected=NotAMockException.class)\n-    public void shouldScreamWhenNotAMockPassed() {\n+    public void should_scream_when_not_a_mock_passed() {\n         mockUtil.getMockHandler(\"\");\n     }\n     \n     @Test (expected=MockitoException.class)\n-    public void shouldScreamWhenNullPassed() {\n+    public void should_scream_when_null_passed() {\n         mockUtil.getMockHandler(null);\n-    }\n-    \n-    @Test\n-    public void shouldValidateMock() {\n-        assertFalse(mockUtil.isMock(\"i mock a mock\"));\n-        assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n     }\n \n     @Test\n-    public void shouldValidateSpy() {\n+    public void should_get_mock_settings() {\n+        List mock = Mockito.mock(List.class);\n+        assertNotNull(mockUtil.getMockSettings(mock));\n+    }\n+\n+    @Test\n+    public void should_validate_mock() {\n+        assertFalse(mockUtil.isMock(\"i mock a mock\"));\n+        assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n+        assertFalse(mockUtil.isMock((Class) null));\n+        assertFalse(mockUtil.isMock(String.class));\n+        assertTrue(mockUtil.isMock(Mockito.mock(List.class).getClass()));\n+    }\n+\n+    @Test\n+    public void should_validate_spy() {\n         assertFalse(mockUtil.isSpy(\"i mock a mock\"));\n         assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));\n         assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));\n+        assertFalse(mockUtil.isSpy((Class) null));\n+        assertFalse(mockUtil.isSpy(String.class));\n+        assertFalse(mockUtil.isSpy(Mockito.mock(List.class).getClass()));\n+        assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList()).getClass()));\n     }\n \n     @Test\n--- a/test/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java\n  */\n \n package org.mockitousage.basicapi;\n-\n-import static org.mockito.Matchers.anyObject;\n-import static org.mockito.Matchers.anyString;\n-import static org.mockito.Mockito.CALLS_REAL_METHODS;\n-import static org.mockito.Mockito.inOrder;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-import static org.mockito.Mockito.withSettings;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Observable;\n \n import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockitoutil.SimpleSerializationUtil.deserializeMock;\n+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;\n+import static org.mockitoutil.SimpleSerializationUtil.serializeMock;\n+\n @SuppressWarnings({\"unchecked\", \"serial\"})\n public class MocksSerializationForAnnotationTest extends TestBase implements Serializable {\n \n         assertEquals(answer.string, readObject.objectArgMethod(\"\"));\n     }\n \n-    class CustomAnswersMustImplementSerializableForSerializationToWork \n+    static class CustomAnswersMustImplementSerializableForSerializationToWork\n         implements Answer<Object>, Serializable {\n         private String string;\n         public Object answer(InvocationOnMock invocation) throws Throwable {\n             return string;\n         }\n     }\n-    \n+\n+    @Test\n     public void should_serialize_with_real_object_spy() throws Exception {\n         // given\n         List<Object> list = new ArrayList<Object>();\n     @Test\n     public void should_be_serialize_and_have_extra_interfaces() throws Exception {\n         //then\n-        serializeAndBack((List) imethodsWithExtraInterfacesMock);\n-    }\n-    \n-    public static class FailTestClass{\n-    \t@Mock(serializable=true) Observable observable;\n-    }\n-    \n-    @Test\n-    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+        Assertions.assertThat((Object) serializeAndBack((List) imethodsWithExtraInterfacesMock))\n+                .isInstanceOf(List.class)\n+                .isInstanceOf(IMethods.class);\n+    }\n+\n+\n+\n+    static class NotSerializableAndNoDefaultConstructor {\n+        NotSerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+    \n+    public static class FailTestClass {\n+    \t@Mock(serializable=true)\n+        NotSerializableAndNoDefaultConstructor notSerializableAndNoDefaultConstructor;\n+    }\n+    \n+    @Test\n+    public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {\n         try {\n-        \tMockitoAnnotations.initMocks(new FailTestClass());\n-            fail();\n+            FailTestClass testClass = new FailTestClass();\n+            MockitoAnnotations.initMocks(testClass);\n+            serializeAndBack(testClass.notSerializableAndNoDefaultConstructor);\n+            fail(\"should have thrown an exception to say the object is not serializable\");\n         } catch (MockitoException e) {\n-            Assertions.assertThat(e.getMessage()).contains(Observable.class.getSimpleName()).contains(\"serializable()\").contains(\"implement Serializable\");\n+            Assertions.assertThat(e.getMessage())\n+                    .contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())\n+                    .contains(\"serializable()\")\n+                    .contains(\"implement Serializable\")\n+                    .contains(\"no-arg constructor\");\n         }\n     }\n+\n+\n+\n+    static class SerializableAndNoDefaultConstructor implements Serializable {\n+        SerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+\n+    public static class TestClassThatHoldValidField {\n+        @Mock(serializable=true)\n+        SerializableAndNoDefaultConstructor serializableAndNoDefaultConstructor;\n+    }\n+\n+    @Test\n+    public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {\n+        TestClassThatHoldValidField testClass = new TestClassThatHoldValidField();\n+        MockitoAnnotations.initMocks(testClass);\n+\n+        serializeAndBack(testClass.serializableAndNoDefaultConstructor);\n+    }\n }\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n package org.mockitousage.basicapi;\n \n import org.fest.assertions.Assertions;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n+import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.matchers.Any;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n+import org.mockitoutil.SimpleSerializationUtil;\n import org.mockitoutil.TestBase;\n \n import java.io.ByteArrayOutputStream;\n+import java.io.ObjectStreamException;\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Observable;\n \n+import static org.mockito.Matchers.anyString;\n import static org.mockito.Mockito.*;\n+import static org.mockitoutil.SimpleSerializationUtil.*;\n \n @SuppressWarnings({\"unchecked\", \"serial\"})\n public class MocksSerializationTest extends TestBase implements Serializable {\n         IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n \n         //then\n-        serializeAndBack((List) mock);\n-        serializeAndBack((List) mockTwo);\n-    }\n-\n-    @Test\n-    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+        Assertions.assertThat((Object) serializeAndBack((List) mock))\n+                .isInstanceOf(List.class)\n+                .isInstanceOf(IMethods.class);\n+        Assertions.assertThat((Object) serializeAndBack((List) mockTwo))\n+                .isInstanceOf(List.class)\n+                .isInstanceOf(IMethods.class);\n+    }\n+\n+\n+\n+    static class NotSerializableAndNoDefaultConstructor {\n+        NotSerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+\n+    @Test\n+    public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {\n         try {\n-            serializeMock(mock(Observable.class, withSettings().serializable()));\n-            fail();\n+            serializeAndBack(mock(NotSerializableAndNoDefaultConstructor.class, withSettings().serializable()));\n+            fail(\"should have thrown an exception to say the object is not serializable\");\n         } catch (MockitoException e) {\n-            Assertions.assertThat(e.getMessage()).contains(Observable.class.getSimpleName()).contains(\"serializable()\").contains(\"implement Serializable\");\n+            Assertions.assertThat(e.getMessage())\n+                    .contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())\n+                    .contains(\"serializable()\")\n+                    .contains(\"implement Serializable\")\n+                    .contains(\"no-arg constructor\");\n         }\n     }\n+\n+\n+\n+    static class SerializableAndNoDefaultConstructor implements Serializable {\n+        SerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+\n+    @Test\n+    public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {\n+        serializeAndBack(mock(SerializableAndNoDefaultConstructor.class));\n+    }\n+\n+\n+\n+    public static class AClassWithPrivateNoArgConstructor {\n+        private AClassWithPrivateNoArgConstructor() {}\n+        List returningSomething() { return Collections.emptyList(); }\n+    }\n+\n+    @Test\n+    public void private_constructor_currently_not_supported_at_the_moment_at_deserialization_time() throws Exception {\n+        // given\n+        AClassWithPrivateNoArgConstructor mockWithPrivateConstructor = Mockito.mock(\n+                AClassWithPrivateNoArgConstructor.class,\n+                Mockito.withSettings().serializable()\n+        );\n+\n+        try {\n+            // when\n+            SimpleSerializationUtil.serializeAndBack(mockWithPrivateConstructor);\n+        } catch (ObjectStreamException e) {\n+            // then\n+            Assertions.assertThat(e.toString()).contains(\"no valid constructor\");\n+        }\n+    }\n+\n+\n+    @Test\n+    @Ignore(\"Bug to fix !!! see issue 399\")\n+    public void BUG_ISSUE_399_try_some_mocks_with_current_answers() throws Exception {\n+        IMethods iMethods = mock(IMethods.class, withSettings().serializable().defaultAnswer(RETURNS_DEEP_STUBS));\n+\n+        when(iMethods.iMethodsReturningMethod().linkedListReturningMethod().contains(anyString())).thenReturn(false);\n+\n+        serializeAndBack(iMethods);\n+    }\n }\n--- a/test/org/mockitousage/basicapi/ObjectsSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/ObjectsSerializationTest.java\n \n package org.mockitousage.basicapi;\n \n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n import java.io.Serializable;\n \n-import org.junit.Test;\n-import org.mockitoutil.TestBase;\n+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;\n \n @SuppressWarnings(\"serial\")\n public class ObjectsSerializationTest extends TestBase implements Serializable {\n--- a/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n+++ b/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockitoutil.SimplePerRealmReloadingClassLoader;\n \n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n import java.util.concurrent.Callable;\n \n import static org.fest.assertions.Assertions.assertThat;\n \n         try {\n             doInNewChildRealm(testMethodClassLoaderRealm, \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\");\n-            fail(\"should have raised a ClassCastException when Objenis Cache is enabled\");\n+            fail(\"should have raised a ClassCastException when Objenesis Cache is enabled\");\n         } catch (MockitoException e) {\n             assertThat(e.getMessage())\n                     .containsIgnoringCase(\"classloading\")\n \n     private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {\n         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n-            public boolean needReload(String qualifiedName) {\n+            public boolean acceptReloadOf(String qualifiedName) {\n                 return \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\".equals(qualifiedName)\n                     || \"org.mockitousage.configuration.ClassToBeMocked\".equals(qualifiedName);\n             }\n \n     private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {\n         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n-            public boolean needReload(String qualifiedName) {\n+            public boolean acceptReloadOf(String qualifiedName) {\n                 return (!qualifiedName.contains(\"org.mockito.cglib\") && qualifiedName.contains(\"org.mockito\"));\n             }\n         };\n     }\n \n-    /**\n-     * Custom classloader to load classes in hierarchic realm.\n-     *\n-     * Each class can be reloaded in the realm if the LoadClassPredicate says so.\n-     */\n-    private static class SimplePerRealmReloadingClassLoader extends URLClassLoader {\n-\n-        private ReloadClassPredicate reloadClassPredicate;\n-\n-        public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {\n-            super(new URL[]{obtainClassPath(), obtainClassPath(\"org.mockito.Mockito\")});\n-            this.reloadClassPredicate = reloadClassPredicate;\n-        }\n-\n-        public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {\n-            super(new URL[]{\n-                    obtainClassPath(),\n-                    obtainClassPath(\"org.mockito.Mockito\"),\n-            }, parentClassLoader);\n-            this.reloadClassPredicate = reloadClassPredicate;\n-        }\n-\n-        private static URL obtainClassPath() {\n-            String className = SimplePerRealmReloadingClassLoader.class.getName();\n-            return obtainClassPath(className);\n-        }\n-\n-        private static URL obtainClassPath(String className) {\n-            String path = className.replace('.', '/') + \".class\";\n-            String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();\n-\n-            try {\n-                return new URL(url.substring(0, url.length() - path.length()));\n-            } catch (MalformedURLException e) {\n-                throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n-            }\n-        }\n-\n-        @Override\n-        public Class<?> loadClass(String qualifiedName) throws ClassNotFoundException {\n-            if(reloadClassPredicate.needReload(qualifiedName)) {\n-                // return customLoadClass(qualifiedName);\n-                Class<?> foundClass = findClass(qualifiedName);\n-                return foundClass;\n-            }\n-            return super.loadClass(qualifiedName);\n-        }\n-\n-        public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {\n-            Callable<?> callableInRealm = (Callable<?>) this.loadClass(callableCalledInClassLoaderRealm).newInstance();\n-            return callableInRealm.call();\n-        }\n-\n-        public static interface ReloadClassPredicate {\n-            boolean needReload(String qualifiedName);\n-        }\n-    }\n }\n--- a/test/org/mockitousage/configuration/ClassToBeMocked.java\n+++ b/test/org/mockitousage/configuration/ClassToBeMocked.java\n package org.mockitousage.configuration;\n \n /**\n- * Some class to mock\n+ * Some class to mock that is created via Class.forClass\n  */\n public class ClassToBeMocked { }\n--- /dev/null\n+++ b/test/org/mockitousage/performance/StubOnlyAvoidMemoryConsumptionTest.java\n+package org.mockitousage.performance;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+public class StubOnlyAvoidMemoryConsumptionTest {\n+\n+    @Test\n+    public void using_stub_only_wont_thrown_an_OutOfMemoryError() {\n+        Object obj = mock(Object.class, withSettings().stubOnly());\n+        when(obj.toString()).thenReturn(\"asdf\");\n+\n+        for (int i = 0; i < 1000000; i++) {\n+            obj.toString();\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"ignored because it will detonate our test suite with an OOM for real\")\n+    public void without_stub_only_mocks_will_store_invocations_leading_to_an_OutOfMemoryError() {\n+        Object obj = mock(Object.class, withSettings());\n+        when(obj.toString()).thenReturn(\"asdf\");\n+\n+        for (int i = 0; i < 1000000; i++) {\n+            obj.toString();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.serialization;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.SimplePerRealmReloadingClassLoader;\n+import org.mockitoutil.SimpleSerializationUtil;\n+\n+import java.io.ByteArrayInputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+\n+public class AcrossClassLoaderSerializationTest {\n+\n+    public IMethods mock;\n+\n+    @Before\n+    public void reproduce_CCE_by_creating_a_mock_with_IMethods_before() throws Exception {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void check_that_mock_can_be_serialized_in_a_classloader_and_deserialized_in_another() throws Exception {\n+        byte[] bytes = create_mock_and_serialize_it_in_class_loader_A();\n+\n+        Object the_deserialized_mock = read_stream_and_deserialize_it_in_class_loader_B(bytes);\n+    }\n+\n+    private Object read_stream_and_deserialize_it_in_class_loader_B(byte[] bytes) throws Exception {\n+        return new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), isolating_test_classes())\n+                .doInRealm(\n+                        \"org.mockitousage.serialization.AcrossClassLoaderSerializationTest$ReadStreamAndDeserializeIt\",\n+                        new Class[]{ byte[].class },\n+                        new Object[]{ bytes }\n+                );\n+    }\n+\n+    private byte[] create_mock_and_serialize_it_in_class_loader_A() throws Exception {\n+        return (byte[]) new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), isolating_test_classes())\n+                .doInRealm(\"org.mockitousage.serialization.AcrossClassLoaderSerializationTest$CreateMockAndSerializeIt\");\n+    }\n+\n+\n+    private SimplePerRealmReloadingClassLoader.ReloadClassPredicate isolating_test_classes() {\n+        return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n+            public boolean acceptReloadOf(String qualifiedName) {\n+                return qualifiedName.contains(\"org.mockitousage\")\n+                        || qualifiedName.contains(\"org.mockitoutil\")\n+                        ;\n+            }\n+        };\n+    }\n+\n+\n+    // see create_mock_and_serialize_it_in_class_loader_A\n+    public static class CreateMockAndSerializeIt implements Callable<byte[]> {\n+        public byte[] call() throws Exception {\n+            AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito.mock(\n+                    AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class,\n+                    Mockito.withSettings().serializable()\n+            );\n+            // use MethodProxy before\n+            mock.returningSomething();\n+\n+            return SimpleSerializationUtil.serializeMock(mock).toByteArray();\n+        }\n+    }\n+\n+    // see read_stream_and_deserialize_it_in_class_loader_B\n+    public static class ReadStreamAndDeserializeIt implements Callable<Object> {\n+        private byte[] bytes;\n+\n+        public ReadStreamAndDeserializeIt(byte[] bytes) {\n+            this.bytes = bytes;\n+        }\n+\n+        public Object call() throws Exception {\n+            ByteArrayInputStream to_unserialize = new ByteArrayInputStream(bytes);\n+            return SimpleSerializationUtil.deserializeMock(\n+                    to_unserialize,\n+                    AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class\n+            );\n+        }\n+    }\n+\n+\n+    public static class AClassToBeMockedInThisTestOnlyAndInCallablesOnly {\n+        List returningSomething() { return Collections.emptyList(); }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/DeserializeMockFromFile.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.serialization;\n+\n+import org.mockito.Mockito;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.Observable;\n+\n+/**\n+ * These classes are here purely to show that mocks can be serialized in a different VM\n+ *\n+ * Just run as standalone app {@link SerializeMockToFile}, then {@link DeserializeMockFromFile}\n+ */\n+\n+public class DeserializeMockFromFile {\n+\n+    public static void main(String[] args) {\n+        Observable o = (Observable) deSerializeObject(\"mockito_mock.ser\");\n+\n+        // then verify\n+        Mockito.verify(o).addObserver(null);\n+        Mockito.verify(o).countObservers();\n+    }\n+\n+    private static Object deSerializeObject(String filename) {\n+        InputStream is = null;\n+        ObjectInputStream ois = null;\n+        Object returnObject = null;\n+        try {\n+\n+            is = new BufferedInputStream(new FileInputStream(filename));\n+            ois = new ObjectInputStream(is);\n+            returnObject = ois.readObject();\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (is != null)\n+                    is.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try {\n+                if (ois != null)\n+                    ois.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        return returnObject;\n+    }\n+   \n+}\n+\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/ParallelSerializationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.serialization;\n+\n+import org.junit.Test;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.SimpleSerializationUtil;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.*;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+public class ParallelSerializationTest {\n+\n+    @Test\n+    public void single_mock_being_serialized_and_deserialized_in_different_classloaders_by_multiple_threads() throws ExecutionException, InterruptedException {\n+        // given\n+        int iterations = 2;\n+        int threadingFactor = 200;\n+        final ExecutorService executorService = Executors.newFixedThreadPool(threadingFactor);\n+        final IMethods iMethods = mock(IMethods.class, withSettings().serializable());\n+\n+        // when\n+        for (int i = 0; i <= iterations; i++) {\n+            List<Future> futures = new ArrayList<Future>(threadingFactor);\n+            final CyclicBarrier barrier_that_will_wait_until_threads_are_ready = new CyclicBarrier(threadingFactor);\n+\n+            // prepare all threads by submitting a callable\n+            //  - that will serialize the mock a 'threadingFactor' times\n+            //  - that will use the mock a 'threadingFactor' times\n+            for (int j = 0; j < threadingFactor; j++) {\n+                // submit a callable that will serialize the mock 'iMethods'\n+                futures.add(executorService.submit(new Callable<Object>() {\n+                    public Object call() throws Exception {\n+                        barrier_that_will_wait_until_threads_are_ready.await();\n+                        iMethods.arrayReturningMethod();\n+\n+                        return SimpleSerializationUtil.serializeMock(iMethods).toByteArray();\n+                    }\n+                }));\n+\n+                // submit a callable that will only use the mock 'iMethods'\n+                executorService.submit(new Callable<Object>() {\n+                    public Object call() throws Exception {\n+                        barrier_that_will_wait_until_threads_are_ready.await();\n+                        return iMethods.longObjectReturningMethod();\n+                    }\n+                });\n+            }\n+\n+            // ensure we are getting the futures\n+            for (Future future : futures) {\n+                future.get();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/SerializeMockToFile.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.serialization;\n+\n+import org.mockito.Mockito;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.util.Observable;\n+\n+/**\n+ * These classes are here purely to show that mocks can be serialized in a different VM\n+ *\n+ * Just run as standalone app {@link SerializeMockToFile}, then {@link DeserializeMockFromFile}\n+ */\n+public class SerializeMockToFile {\n+\n+    public static void main(String[] args) {\n+       \n+        Observable observable = Mockito.mock(\n+                Observable.class,\n+                Mockito.withSettings().serializable()\n+        );\n+\n+        // play with mock\n+        observable.addObserver(null);\n+        observable.countObservers();\n+\n+        // serialize to file\n+        serializeMock(observable, \"mockito_mock.ser\");\n+    }\n+\n+    private static void serializeMock(Object obj, String filename) {\n+        OutputStream os = null;\n+        ObjectOutputStream oos = null;\n+\n+        try {\n+            os = new BufferedOutputStream(new FileOutputStream(filename, false));\n+            oos = new ObjectOutputStream(os);\n+\n+            oos.writeObject(obj);\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            try {\n+                if (os != null) os.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try {\n+                if (oos != null) oos.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+    }\n+\n+    private static class DefaultMethodInterceptor implements MethodInterceptor, Serializable {\n+        private static final long serialVersionUID = 6606245777399406255L;\n+\n+        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n+            return methodProxy.invokeSuper(o, objects);\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n \n package org.mockitousage.verification;\n \n-import static org.mockito.AdditionalMatchers.*;\n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n-\n import org.junit.Before;\n+import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import static org.mockito.AdditionalMatchers.aryEq;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.matches;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {\n \n     private IMethods mock;\n     }\n \n     @Test\n-    public void should_print_method_name_and_arguments_of_other_interactions() throws Exception {\n+    public void should_print_method_name_and_arguments_of_other_interactions_with_different_methods() throws Exception {\n         try {\n             mock.arrayMethod(new String[] {\"a\", \"b\", \"c\"});\n             mock.forByte((byte) 25);\n             assertContains(\"iMethods.forByte(25)\", e.getMessage());\n         }\n     }\n+\n+    @Test\n+    @Ignore(\"issue 380 related\")\n+    public void should_print_method_name_and_arguments_of_other_interactions_of_same_method() throws Exception {\n+        try {\n+            mock.forByte((byte) 25);\n+            mock.forByte((byte) 12);\n+\n+            verify(mock).forByte((byte) 42);\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            System.out.println(e);\n+            assertContains(\"iMethods.forByte(42)\", e.getMessage());\n+            assertContains(\"iMethods.forByte(25)\", e.getMessage());\n+            assertContains(\"iMethods.forByte(12)\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    @Ignore(\"issue 380 related\")\n+    public void test1() {\n+        AnInterface m = Mockito.mock(AnInterface.class);\n+\n+        for (int i = 1; i <= 2; i++) {\n+            m.foo(i);\n+        }\n+\n+        verify(m).foo(1);\n+        verify(m).foo(2);\n+        verify(m).foo(3); // XXX: doesn't mention the parameters of foo(1) and foo(2)\n+        verify(m).foo(4);\n+    }\n+\n+    @Test\n+    @Ignore(\"issue 380 related\")\n+    public void test2() {\n+        AnInterface m = Mockito.mock(AnInterface.class);\n+\n+        for (int i = 1; i <= 4; i++) {\n+            m.foo(i);\n+        }\n+\n+        verify(m).foo(1);\n+        verify(m).foo(2);\n+        verify(m).foo(5); // XXX: doesn't mention foo(4) at all\n+    }\n+\n+    public interface AnInterface {\n+        void foo(int i);\n+    }\n+    \n }\n--- /dev/null\n+++ b/test/org/mockitoutil/SimplePerRealmReloadingClassLoader.java\n+package org.mockitoutil;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Custom classloader to load classes in hierarchic realm.\n+ *\n+ * Each class can be reloaded in the realm if the LoadClassPredicate says so.\n+ */\n+public class SimplePerRealmReloadingClassLoader extends URLClassLoader {\n+\n+    private final Map<String,Class> classHashMap = new HashMap<String, Class>();\n+    private ReloadClassPredicate reloadClassPredicate;\n+\n+    public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {\n+        super(getPossibleClassPathsUrls());\n+        this.reloadClassPredicate = reloadClassPredicate;\n+    }\n+\n+    public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {\n+        super(getPossibleClassPathsUrls(), parentClassLoader);\n+        this.reloadClassPredicate = reloadClassPredicate;\n+    }\n+\n+    private static URL[] getPossibleClassPathsUrls() {\n+        return new URL[]{\n+                obtainClassPath(),\n+                obtainClassPath(\"org.mockito.Mockito\"),\n+                obtainClassPath(\"org.mockito.cglib.proxy.Enhancer\"),\n+        };\n+    }\n+\n+    private static URL obtainClassPath() {\n+        String className = SimplePerRealmReloadingClassLoader.class.getName();\n+        return obtainClassPath(className);\n+    }\n+\n+    private static URL obtainClassPath(String className) {\n+        String path = className.replace('.', '/') + \".class\";\n+        String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();\n+\n+        try {\n+            return new URL(url.substring(0, url.length() - path.length()));\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n+        }\n+    }\n+\n+\n+\n+    @Override\n+    public Class<?> loadClass(String qualifiedClassName) throws ClassNotFoundException {\n+        if(reloadClassPredicate.acceptReloadOf(qualifiedClassName)) {\n+            // return customLoadClass(qualifiedClassName);\n+//            Class<?> loadedClass = findLoadedClass(qualifiedClassName);\n+            if(!classHashMap.containsKey(qualifiedClassName)) {\n+                Class<?> foundClass = findClass(qualifiedClassName);\n+                saveFoundClass(qualifiedClassName, foundClass);\n+                return foundClass;\n+            }\n+\n+            return classHashMap.get(qualifiedClassName);\n+        }\n+        return useParentClassLoaderFor(qualifiedClassName);\n+    }\n+\n+    private void saveFoundClass(String qualifiedClassName, Class<?> foundClass) {\n+        classHashMap.put(qualifiedClassName, foundClass);\n+    }\n+\n+\n+    private Class<?> useParentClassLoaderFor(String qualifiedName) throws ClassNotFoundException {\n+        return super.loadClass(qualifiedName);\n+    }\n+\n+\n+    public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {\n+        ClassLoader current = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(this);\n+            Object instance = this.loadClass(callableCalledInClassLoaderRealm).getConstructor().newInstance();\n+            if (instance instanceof Callable) {\n+                Callable<?> callableInRealm = (Callable<?>) instance;\n+                return callableInRealm.call();\n+            }\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(current);\n+        }\n+        throw new IllegalArgumentException(\"qualified name '\" + callableCalledInClassLoaderRealm + \"' should represent a class implementing Callable\");\n+    }\n+\n+\n+    public Object doInRealm(String callableCalledInClassLoaderRealm, Class[] argTypes, Object[] args) throws Exception {\n+        ClassLoader current = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(this);\n+            Object instance = this.loadClass(callableCalledInClassLoaderRealm).getConstructor(argTypes).newInstance(args);\n+            if (instance instanceof Callable) {\n+                Callable<?> callableInRealm = (Callable<?>) instance;\n+                return callableInRealm.call();\n+            }\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(current);\n+        }\n+\n+        throw new IllegalArgumentException(\"qualified name '\" + callableCalledInClassLoaderRealm + \"' should represent a class implementing Callable\");\n+    }\n+\n+\n+    public static interface ReloadClassPredicate {\n+        boolean acceptReloadOf(String qualifiedName);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitoutil/SimpleSerializationUtil.java\n+package org.mockitoutil;\n+\n+import junit.framework.Assert;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+public abstract class SimpleSerializationUtil {\n+\n+    //TODO use widely\n+    public static <T> T serializeAndBack(T obj) throws Exception {\n+        ByteArrayOutputStream os = serializeMock(obj);\n+        return (T) deserializeMock(os, Object.class);\n+    }\n+\n+    public static <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,\n+            ClassNotFoundException {\n+        InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());\n+        return deserializeMock(unserialize, type);\n+    }\n+\n+    public static <T> T deserializeMock(InputStream unserialize, Class<T> type) throws IOException, ClassNotFoundException {\n+        Object readObject = new ObjectInputStream(unserialize).readObject();\n+        Assert.assertNotNull(readObject);\n+        return type.cast(readObject);\n+    }\n+\n+    public static ByteArrayOutputStream serializeMock(Object mock) throws IOException {\n+        ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n+        new ObjectOutputStream(serialized).writeObject(mock);\n+        return serialized;\n+    }\n+}\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n         return StringDescription.toString(m);\n     }\n \n-    //TODO use widely\n-    protected <T> T serializeAndBack(T obj) throws Exception {\n-        ByteArrayOutputStream os = this.serializeMock(obj);\n-        return (T) this.deserializeMock(os, Object.class);\n-    }\n-\n-    protected <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,\n-            ClassNotFoundException {\n-        InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());\n-        Object readObject = new ObjectInputStream(unserialize).readObject();\n-        assertNotNull(readObject);\n-        return type.cast(readObject);\n-    }\n-\n-    protected ByteArrayOutputStream serializeMock(Object mock) throws IOException {\n-        ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n-        new ObjectOutputStream(serialized).writeObject(mock);\n-        return serialized;\n-    }\n-\n     protected boolean isMock(Object o) {\n         return new MockUtil().isMock(o);\n     }", "timestamp": 1357586710, "metainfo": ""}