{"sha": "1e11bf4fcfb934f6bd3788a2d470891585293536", "log": "Implemented nice exception messages, few @Ignored tests are no more @Ignored :)  --HG-- rename : src/org/mockito/internal/MockitoControl.java => src/org/mockito/internal/MockControl.java rename : test/org/mockito/internal/MockitoControlTest.java => test/org/mockito/internal/MockControlTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4036", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     public static <T> T mock(Class<T> classToMock) {\n         try {\n             MockFactory<T> proxyFactory = new MockFactory<T>();\n-            MockitoControl<T> mockitoControl = new MockitoControl<T>(MockitoState.instance(), LastArguments.instance());\n-            return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockitoControl>(\n-                    classToMock, mockitoControl, null));\n+            MockControl<T> mockControl = new MockControl<T>(MockitoState.instance(), LastArguments.instance());\n+            return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockControl>(\n+                    classToMock, mockControl));\n         } catch (RuntimeExceptionWrapper e) {\n             throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n         }\n \t}\n \n     public static void verifyZeroInteractions(Object ... mocks) {\n-         verifyNoMoreInteractions(mocks);   \n+        MockitoState.instance().checkForUnfinishedVerification();\n+        for (Object mock : mocks) {\n+            MockUtil.getControl(mock).verifyZeroInteractions();\n+        }\n     }\n     \n     public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n-//        MockitoState.instance().reportControlForStubbing(mockitoControl)\n+//        MockitoState.instance().reportControlForStubbing(mockControl)\n         return MockUtil.getControl(mock);\n     }\n }\n--- a/src/org/mockito/exceptions/MockVerificationAssertionError.java\n+++ b/src/org/mockito/exceptions/MockVerificationAssertionError.java\n     public MockVerificationAssertionError() {\n         super(\"Mock verification failed\");\n     }\n+\n+    public MockVerificationAssertionError(String message) {\n+        super(message);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/MockControl.java\n+package org.mockito.internal;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.*;\n+\n+public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n+\n+    private final MockitoBehavior<T> behavior = new MockitoBehavior<T>();\n+    private final MockitoState mockitoState;\n+    private final LastArguments lastArguments;\n+\n+    private Throwable throwableToBeSetOnVoidMethod;\n+    \n+    public MockControl(MockitoState mockitoState, LastArguments lastArguments) {\n+        this.mockitoState = mockitoState;\n+        this.lastArguments = lastArguments;\n+    }\n+    \n+    /**\n+     * if user passed bare arguments, not matchers then create EqualsMatchers for every argument\n+     */\n+    private List<IArgumentMatcher> createEqualsMatchers(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        if (matchers != null) {\n+            return matchers;\n+        }\n+        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n+    }\n+\n+    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        if (matchers != null && matchers.size() != invocation.getArguments().length) {\n+            throw new InvalidUseOfMatchersException(\n+                    + invocation.getArguments().length\n+                    + \" matchers expected, \" + matchers.size()\n+                    + \" recorded.\");\n+        }\n+    }\n+\n+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+        VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n+        \n+        Invocation invocation = new Invocation(proxy, method, args);\n+        List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n+        validateMatchers(invocation, lastMatchers);\n+\n+        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n+        InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, processedMatchers);\n+        \n+        if (verifyingMode != null) {\n+            behavior.verify(invocationWithMatchers, verifyingMode);\n+            return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n+        }\n+        \n+//        else if (mockitoState.mockStubbingScenario()) {\n+//            mockitoState.stubbingCompleted();\n+//        }\n+        \n+        mockitoState.reportLastControl(this);\n+        \n+        behavior.addInvocation(invocationWithMatchers);\n+        \n+        if (throwableToBeSetOnVoidMethod != null) {\n+            andThrows(throwableToBeSetOnVoidMethod);\n+            throwableToBeSetOnVoidMethod = null;\n+            return null;\n+        }\n+\n+        return behavior.resultFor(invocation);\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        behavior.verifyNoMoreInteractions();\n+    }\n+    \n+    public void verifyZeroInteractions() {\n+        behavior.verifyZeroInteractions();\n+    }\n+\n+    public void andReturn(T value) {\n+//      TODO count number of andReturn vs number of stubbing\n+        behavior.addResult(Result.createReturnResult(value));\n+    }\n+\n+    public void andThrows(Throwable throwable) {\n+        validateThrowable(throwable);\n+        //TODO count number of andReturn vs number of stubbing\n+        behavior.addResult(Result.createThrowResult(throwable));\n+    }\n+    \n+    private void validateThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            throw new IllegalArgumentException(\"Cannot set null throwable\");\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+    \n+        if (! isValidCheckedException(throwable)) {\n+            throw new IllegalArgumentException(\"Given checked exception is invalid for this method\"); \n+        }\n+    }\n+\n+    private boolean isValidCheckedException(Throwable throwable) {\n+        Invocation lastInvocation = behavior.lastInvocation();\n+\n+        Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n+        Class<?> throwableClass = throwable.getClass();\n+        for (Class<?> exception : exceptions) {\n+            if (exception.isAssignableFrom(throwableClass)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+\n+    public MethodSelector<T> toThrow(Throwable throwable) {\n+        throwableToBeSetOnVoidMethod = throwable;\n+        return this;\n+    }\n+\n+    public T on() {\n+        return (T) behavior.getMock();\n+    }\n+\n+    public void setMock(T mock) {\n+        behavior.setMock(mock);\n+    }\n+}\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n-    public static <T> MockitoControl<T> getControl(T mock) {\n+    public static <T> MockControl<T> getControl(T mock) {\n         if (mock == null) {\n             throw new IllegalArgumentException(\"Mock cannot be null\");\n         }\n         \n-        ObjectMethodsFilter<MockitoControl<T>> handler;\n+        ObjectMethodsFilter<MockControl<T>> handler;\n \n         try {\n             if (Enhancer.isEnhanced(mock.getClass())) {\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n import org.mockito.exceptions.*;\n \n-public class MockitoBehavior {\n+public class MockitoBehavior<T> {\n \n+    private T mock;\n+    \n     private List<InvocationWithMatchers> registeredInvocations = new LinkedList<InvocationWithMatchers>();\n     private Map<InvocationWithMatchers, Result> results = new HashMap<InvocationWithMatchers, Result>();\n     \n     public void addInvocation(InvocationWithMatchers invocation) {\n-        validateState();\n         this.registeredInvocations.add(invocation);\n-    }\n-\n-    private void validateState() {\n-        \n     }\n \n     public void addResult(Result result) {\n             } \n         } else {\n             if (actuallyInvoked == 0) {\n-                throw new MockVerificationAssertionError();\n+                throw new MockVerificationAssertionError(\n+                        \"\\n\" +\n+                        \"Not invoked: \" + ObjectMethodsFilter.simpleName(mock) + \".\" + invocation.toString());\n             }\n         }\n     }\n     }\n \n     public void verifyNoMoreInteractions() {\n+        verifyNoMoreInteractions(\"No more interactions expected\");\n+    }\n+    \n+    public void verifyZeroInteractions() {\n+        verifyNoMoreInteractions(\"Zero interactions expected\");\n+    }\n+    \n+    private void verifyNoMoreInteractions(String verificationErrorMessage) {\n         for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n             if (!registeredInvocation.getInvocation().isVerified()) {\n-                throw new MockVerificationAssertionError();\n+                String mockName = ObjectMethodsFilter.simpleName(mock);\n+                throw new MockVerificationAssertionError(\n+                        \"\\n\" +\n+                        verificationErrorMessage + \" on \" + mockName + \" but found: \" + mockName + \".\" + registeredInvocation.toString());\n             }\n         }\n     }\n     public Invocation lastInvocation() {\n         return registeredInvocations.get(registeredInvocations.size() - 1).getInvocation();\n     }\n-}\n+\n+    public T getMock() {\n+        return mock;\n+    }\n+\n+    public void setMock(T mock) {\n+        this.mock = mock;\n+    }\n+}\n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n     \n     static MockitoState INSTANCE = new MockitoState();\n     \n-    private final ThreadLocal<MockitoControl> lastControl = new ThreadLocal<MockitoControl>();\n+    private final ThreadLocal<MockControl> lastControl = new ThreadLocal<MockControl>();\n     private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n //    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n \n         return INSTANCE;\n     }\n     \n-    public synchronized void reportLastControl(MockitoControl mockitoControl) {\n-        lastControl.set(mockitoControl);\n+    public synchronized void reportLastControl(MockControl mockControl) {\n+        lastControl.set(mockControl);\n     }\n \n     public synchronized MockitoExpectation pullControlToBeStubbed() {\n-        MockitoControl control = lastControl.get();\n+        MockControl control = lastControl.get();\n         lastControl.set(null);\n         return control;\n     }\n--- a/src/org/mockito/internal/ObjectMethodsFilter.java\n+++ b/src/org/mockito/internal/ObjectMethodsFilter.java\n \n     private final T delegate;\n \n-    private final String name;\n-\n     @SuppressWarnings(\"unchecked\")\n-    public ObjectMethodsFilter(Class toMock, T delegate,\n-            String name) {\n-        if (name != null && !Invocation.isJavaIdentifier(name)) {\n-            throw new IllegalArgumentException(String.format(\"'%s' is not a valid Java identifier.\", name));\n-            \n-        }\n+    public ObjectMethodsFilter(Class toMock, T delegate) {\n         try {\n             if (toMock.isInterface()) {\n                 toMock = Object.class;\n             throw new RuntimeException(\"An Object method could not be found!\");\n         }\n         this.delegate = delegate;\n-        this.name = name;\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args)\n         return delegate.invoke(proxy, method, args);\n     }\n \n-    private String mockToString(Object proxy) {\n-        return (name != null) ? name : \"Mock for \" + mockType(proxy);\n+    private String mockToString(Object mock) {\n+        return \"Mock for \" + simpleName(mock);\n     }\n \n-    private String mockType(Object proxy) {\n-\t\tif (proxy.getClass().getInterfaces().length == 2) {\n-\t\t\treturn proxy.getClass().getInterfaces()[0].getSimpleName();\n+    public static String simpleName(Object mock) {\n+\t\tif (mock.getClass().getInterfaces().length == 2) {\n+\t\t\treturn mock.getClass().getInterfaces()[0].getSimpleName();\n \t\t} else {\n-\t\t\treturn proxy.getClass().getSuperclass().getSimpleName();\n+\t\t\treturn mock.getClass().getSuperclass().getSimpleName();\n \t\t}\n \t}\n \n--- /dev/null\n+++ b/test/org/mockito/internal/MockControlTest.java\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.*;\n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.Equals;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockControlTest {\n+    \n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Test\n+    public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+        MockitoState state = MockitoState.instance(); \n+        LastArguments lastArguments = LastArguments.instance();\n+        \n+        lastArguments.reportMatcher(new Equals(\"test\"));\n+        state.verifyingStarted(VerifyingMode.anyTimes());\n+        \n+        MockControl control = new MockControl(state, lastArguments);\n+\n+        try {\n+            control.invoke(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{});\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+        }\n+        \n+        assertNull(state.pullVerifyingMode());\n+    }\n+}\n--- a/test/org/mockito/internal/MockFactoryTest.java\n+++ b/test/org/mockito/internal/MockFactoryTest.java\n     \n     private final class MockAwareStub extends ObjectMethodsFilter {\n         public MockAwareStub() {\n-            super(Object.class, null, null);\n+            super(Object.class, null);\n         }\n \n         public void setMock(Object mock) {}\n--- a/test/org/mockito/sample/MockitoSampleTest.java\n+++ b/test/org/mockito/sample/MockitoSampleTest.java\n         Mockito.verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 12);\n         Mockito.verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 5);\n         Mockito.verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 7);\n+        \n+        Mockito.verifyNoMoreInteractions(mockDatabase);\n     }\n     \n     @Test\n--- a/test/org/mockito/usage/InvalidUsageTest.java\n+++ b/test/org/mockito/usage/InvalidUsageTest.java\n package org.mockito.usage;\n \n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n \n import java.util.List;\n--- a/test/org/mockito/usage/verification/BasicVerificationTest.java\n+++ b/test/org/mockito/usage/verification/BasicVerificationTest.java\n \n import org.junit.Test;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.MockVerificationAssertionError;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicVerificationTest {\n         try {\n             Mockito.verify(mock).clear();\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Mock verification failed\"));\n-        }\n+        } catch (MockVerificationAssertionError expected) {};\n     }\n \n     @Test\n         try {\n             Mockito.verify(mock).add(\"bar\");\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Mock verification failed\"));\n-        }\n+        } catch (MockVerificationAssertionError expected) {};\n     }\n \n     @Test\n         try {\n             Mockito.verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (AssertionError error) {\n-            assertThat(error.getMessage(), equalTo(\"Mock verification failed\"));\n-        }\n+        } catch (MockVerificationAssertionError expected) {};\n     }\n     \n     @Test\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n package org.mockito.usage.verification;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n \n import org.junit.*;\n import org.mockito.Mockito;\n import org.mockito.exceptions.MockVerificationAssertionError;\n import org.mockito.usage.IMethods;\n-\n-import static org.mockito.Mockito.*;\n-import static org.junit.Assert.*;\n \n public class NiceMessagesWhenVerificationFailsTest {\n     \n         mock = Mockito.mock(IMethods.class);\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldPrintMethodName() {\n         try {\n             verify(mock).simpleMethod();\n         } catch (MockVerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n-            String expectedMessage = \"\\n  Method not invoked: IMethods.simpleMethod()\";\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"Not invoked: IMethods.simpleMethod()\";\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }\n     \n-    @Ignore\n+    private class SomeClass {\n+        public String toString() {\n+            return \"SomeClass instance\";\n+        }\n+    }\n+    \n     @Test\n     public void shouldPrintMethodNameAndArguments() {\n         try {\n-            verify(mock).threeArgumentMethod(12, new Object(), \"some string\");\n+            verify(mock).threeArgumentMethod(12, new SomeClass(), \"some string\");\n         } catch (MockVerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n-            String expectedMessage = \"\\n  Method not invoked: IMethods.threeArgumentMethod(12, id1234123, \\\"some string\\\")\";\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"Not invoked: IMethods.threeArgumentMethod(12, SomeClass instance, \\\"some string\\\")\";\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldPrintFirstUnexpectedInvocation() {\n         mock.oneArg(true);\n+        mock.oneArg(false);\n         mock.threeArgumentMethod(1, \"2\", \"3\");\n+        \n+        verify(mock).oneArg(true);\n         try {\n             verifyNoMoreInteractions(mock);\n         } catch (MockVerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n-            String expectedMessage = \"\\n  No interactions expected but found: IMethods.oneArg(true)\";\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"No more interactions expected on IMethods but found: IMethods.oneArg(false)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintFirstUnexpectedInvocationWhenVerifyingZeroInteractions() {\n+        mock.twoArgumentMethod(1, 2);\n+        mock.threeArgumentMethod(1, \"2\", \"3\");\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+        } catch (MockVerificationAssertionError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Zero interactions expected on IMethods but found: IMethods.twoArgumentMethod(1, 2)\";\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }\n--- a/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n     }\n     \n     @Test\n-    public void shouldFailNoInteractionsVerification() throws Exception {\n+    public void shouldFailZeroInteractionsVerification() throws Exception {\n         List mock = mock(List.class);\n \n         mock.clear();\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n package org.mockito.util;\n \n import java.util.*;\n+import java.util.regex.Pattern;\n \n import org.hamcrest.*;\n \n             }\n         };\n     }\n+    \n+    public static <T> Matcher<String> matches(final String regexp) {\n+        return new BaseMatcher<String>() {\n+\n+            public boolean matches(Object string) {\n+                return ((String)string).matches(regexp); \n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"string doesn't match \" + regexp);\n+            }\n+        };\n+    }\n }", "timestamp": 1195494042, "metainfo": ""}