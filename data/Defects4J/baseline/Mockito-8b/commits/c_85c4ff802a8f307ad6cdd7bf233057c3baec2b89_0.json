{"sha": "85c4ff802a8f307ad6cdd7bf233057c3baec2b89", "log": "Tidy-up, tweaked exception messages.", "commit": "\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n                                 .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                 .name(field.getName())));\n                     } else {\n-                    \tfield.set(testInstance, newSpyInstance(testInstance, field));\n+                        field.set(testInstance, newSpyInstance(testInstance, field));\n                     }\n+                } catch (MockitoException e) {\n+                    throw e;\n                 } catch (Exception e) {\n                     throw new MockitoException(\"Problems initiating @Spy annotated field '\" + field.getName() + \"'\", e);\n                 }\n \t    \t\treturn Mockito.mock(type, settings.useConstructor());\n \t    \t}\n     \t} catch (NoSuchMethodException noDefaultConstructor) {\n-    \t\tthrow new MockitoException(\"0-arg constructor is required to spy \" + type);\n+    \t\tthrow new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName()\n+                    + \"'. Please ensure that the type '\" + type.getSimpleName()  + \"' has 0-arg constructor.\");\n     \t}\n     }\n     \n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.annotation;\n \n import org.fest.assertions.Assertions;\n-import org.junit.Rule;\n+import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.rules.ExpectedException;\n-import org.mockito.Mock;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n import org.mockito.Spy;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n-\n+\n import java.util.AbstractList;\n import java.util.ArrayList;\n-import java.util.Arrays;\n+import java.util.Arrays;\n import java.util.List;\n-\n-import static org.mockito.Mockito.*;\n+\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.when;\n \n @SuppressWarnings({\"unchecked\", \"unused\"})\n public class SpyAnnotationTest extends TestBase {\n     @Spy NestedClassWithNoArgConstructor staticTypeWithNoArgConstructor;\n \n     @Spy\n-    NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;\n-  \n+    NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;\n+  \n     @Rule public final ExpectedException shouldThrow = ExpectedException.none();\n \n \t@Test\n \t\tclass WithSpy {\n \t\t\t@Spy List<String> list;\n \t\t}\n-\n+\n \t\tWithSpy withSpy = new WithSpy();\n-        MockitoAnnotations.initMocks(withSpy);\n+        MockitoAnnotations.initMocks(withSpy);\n         assertEquals(0, withSpy.list.size());\n     }\n \n             MockitoAnnotations.initMocks(new FailingSpy());\n             fail();\n         } catch (MockitoException e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"0-arg constructor is required\");\n+            Assertions.assertThat(e.getMessage()).contains(\"0-arg constructor\");\n         }\n     }\n     \n     @Test\n     public void spyAbstractClass() throws Exception {\n \t\tclass SpyAbstractClass {\n-\t\t\t@Spy AbstractList<String> list;\n-\t\t\t\n-\t\t\tList<String> asSingletonList(String s) {\n-\t\t\t\twhen(list.size()).thenReturn(1);\n-\t\t\t\twhen(list.get(0)).thenReturn(s);\n-\t\t\t\treturn list;\n+\t\t\t@Spy AbstractList<String> list;\n+\t\t\t\n+\t\t\tList<String> asSingletonList(String s) {\n+\t\t\t\twhen(list.size()).thenReturn(1);\n+\t\t\t\twhen(list.get(0)).thenReturn(s);\n+\t\t\t\treturn list;\n \t\t\t}\n-\t\t}\n+\t\t}\n \t\tSpyAbstractClass withSpy = new SpyAbstractClass();\n-        MockitoAnnotations.initMocks(withSpy);\n+        MockitoAnnotations.initMocks(withSpy);\n         assertEquals(Arrays.asList(\"a\"), withSpy.asSingletonList(\"a\"));\n-    }\n+    }\n \n     @Test\n-    public void spyInnerClass() throws Exception {\n-    \t \n-     class WithMockAndSpy {\n-    \t\t@Spy private InnerStrength strength;\n-    \t\t@Mock private List<String> list;\n-\n-            abstract class InnerStrength {\n-            \tprivate final String name;\n-\n-            \tInnerStrength() {\n-            \t\t// Make sure that @Mock fields are always injected before @Spy fields.\n-            \t\tassertNotNull(list);\n-            \t\t// Make sure constructor is indeed called.\n-            \t\tthis.name = \"inner\";\n-            \t}\n-            \t\n-            \tabstract String strength();\n-            \t\n-            \tString fullStrength() {\n-            \t\treturn name + \" \" + strength();\n-            \t}\n-            }\n-    \t}\n+    public void spyInnerClass() throws Exception {\n+    \t \n+     class WithMockAndSpy {\n+    \t\t@Spy private InnerStrength strength;\n+    \t\t@Mock private List<String> list;\n+\n+            abstract class InnerStrength {\n+            \tprivate final String name;\n+\n+            \tInnerStrength() {\n+            \t\t// Make sure that @Mock fields are always injected before @Spy fields.\n+            \t\tassertNotNull(list);\n+            \t\t// Make sure constructor is indeed called.\n+            \t\tthis.name = \"inner\";\n+            \t}\n+            \t\n+            \tabstract String strength();\n+            \t\n+            \tString fullStrength() {\n+            \t\treturn name + \" \" + strength();\n+            \t}\n+            }\n+    \t}\n \t\tWithMockAndSpy outer = new WithMockAndSpy();\n-        MockitoAnnotations.initMocks(outer);\n-        when(outer.strength.strength()).thenReturn(\"strength\");\n+        MockitoAnnotations.initMocks(outer);\n+        when(outer.strength.strength()).thenReturn(\"strength\");\n         assertEquals(\"inner strength\", outer.strength.fullStrength());\n     }\n \n \t@Test(expected = IndexOutOfBoundsException.class)\n     public void shouldResetSpies() throws Exception {\n         spiedList.get(10); // see shouldInitSpy\n-    }\n-\n-\t@Test\n-\tpublic void shouldReportWhenInnerClassNotEnclosedByTestInstance() throws Exception {\n-\t\tclass Outer {\n-\t\t\tclass Inner {}\n-\t\t}\n-\t\tclass WithSpy {\n-\t\t\t@Spy private Outer.Inner inner;\n-\t\t}\n-\t\tshouldThrow.expect(MockitoException.class);\n-\t\tshouldThrow.expectMessage(\"Cannot spy inner class \");\n-\t\tMockitoAnnotations.initMocks(new WithSpy());\n+    }\n+\n+\t@Test\n+\tpublic void shouldReportWhenInnerClassNotEnclosedByTestInstance() throws Exception {\n+\t\tclass Outer {\n+\t\t\tclass Inner {}\n+\t\t}\n+\t\tclass WithSpy {\n+\t\t\t@Spy private Outer.Inner inner;\n+\t\t}\n+\t\tshouldThrow.expect(MockitoException.class);\n+\t\tshouldThrow.expectMessage(\"Cannot spy inner class \");\n+\t\tMockitoAnnotations.initMocks(new WithSpy());\n \t}\n \n     static class NestedClassWithoutDefinedConstructor { }", "timestamp": 1417513677, "metainfo": ""}