{"sha": "ab5d6d97e92ebb7078f7f1d10c52f4e7dd5c18a8", "log": "Tuned javadoc for new features  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401377", "commit": "\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n-/**\n- * \n- */\n package org.mockito;\n \n import java.util.List;\n /**\n  * Use it to capture argument values for further assertions.\n  * <p>\n- * Mockito verifies argument values in typical java style: by using an equals() method.\n+ * Mockito verifies argument values in natural java style: by using an equals() method.\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n  * For example:\n  * <pre>\n- *   ArgumentCaptor&lt;Person&gt; argument = new ArgumentCaptor&ltPerson&gt();\n+ *   ArgumentCaptor&lt;Person&gt; argument = new ArgumentCaptor&lt;Person&gt;();\n  *   verify(mock).doSomething(argument.capture());\n  *   assertEquals(\"John\", argument.getValue().getName());\n  * </pre>\n  *\n- * Warning: it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n+ * <p>\n+ * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n+ * <p>\n+ * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n+ * Both techniques can be used for making sure certain arguments where passed to mocks. \n+ * However, ArgumentCaptor may be a better fit if:\n+ * <ul>  \n+ * <li>custom argument matcher is not likely to be reused</li>\n+ * <li>you just need it to assert on argument values to complete verification</li>\n+ * </ul>\n+ * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n  * <p>\n  * See the full documentation on Mockito in javadoc for {@link Mockito} class.    \n  */\n      * <p>\n      * Example: \n      * <pre>\n-     *   ArgumentCaptor&lt;Person&gt; peopleCaptor = new ArgumentCaptor&ltPerson&gt();\n+     *   ArgumentCaptor&lt;Person&gt; peopleCaptor = new ArgumentCaptor&lt;Person&gt;();\n      *   verify(mock, times(2)).doSomething(peopleCaptor.capture());\n      *   \n      *   List&lt;Person&gt; capturedPeople = peopleCaptor.getAllValues();\n--- a/src/org/mockito/ArgumentMatcher.java\n+++ b/src/org/mockito/ArgumentMatcher.java\n  *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n  * </pre>\n  *\n- * Custom argument matchers can make the test less readable. \n+ * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n  * Sometimes it's better to implement equals() for arguments that are passed to mocks \n  * (Mockito naturally uses equals() for argument matching). \n- * This can make the test cleaner.\n+ * This can make the test cleaner. \n  * <p>\n- * Read more about {@link Matchers}\n+ * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher.\n+ * For example, if custom argument matcher is not likely to be reused\n+ * or you just need it to assert on argument values to complete verification of behavior.\n+ * <p>\n+ * Read more about other matchers in javadoc for {@link Matchers} class\n  * \n  * @param <T> type of argument\n  */\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n  * \n  * Use {@link Matchers#argThat} method and pass an instance of hamcrest {@link Matcher}.\n  * <p>\n- * You can use {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n- * In case of failure {@link ArgumentMatcher} generates description based on <b>decamelized class name</b> - to promote meaningful class names.\n+ * Before you start implementing your own custom argument matcher, make sure you check out {@link ArgumentCaptor} api.\n+ * <p>\n+ * So, how to implement your own argument matcher?\n+ * First, you might want to subclass {@link ArgumentMatcher} which is an hamcrest matcher with predefined describeTo() method.\n+ * Default description generated by describeTo() uses <b>decamelized class name</b> - to promote meaningful class names.\n  * <p>\n  * Example:\n  * \n  *   verify(mock).addAll(<b>listOfTwoElements()</b>);\n  * </pre>\n  *\n- * Custom argument matchers can make the test less readable. \n+ * <b>Warning:</b> Be reasonable with using complicated argument matching, especially custom argument matchers, as it can make the test less readable. \n  * Sometimes it's better to implement equals() for arguments that are passed to mocks \n  * (Mockito naturally uses equals() for argument matching). \n- * This can make the test cleaner.\n+ * This can make the test cleaner. \n+ * <p>\n+ * Also, <b>sometimes {@link ArgumentCaptor} may be a better fit</b> than custom matcher. \n+ * For example, if custom argument matcher is not likely to be reused\n+ * or you just need it to assert on argument values to complete verification of behavior.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Matchers {\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n-import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.returnvalues.EmptyReturnValues;\n import org.mockito.internal.returnvalues.GloballyConfiguredReturnValues;\n import org.mockito.internal.returnvalues.MockReturnValues;\n  * <h1>Contents</h1>\n  * \n  * <b> \n- *      1. Let's verify some behaviour! <br/> \n- *      2. How about some stubbing? <br/>\n- *      3. Argument matchers <br/> \n- *      4. Verifying exact number of invocations / at least once / never <br/> \n- *      5. Stubbing void methods with exceptions <br/> \n- *      6. Verification in order <br/> \n- *      7. Making sure interaction(s) never happened on mock <br/> \n- *      8. Finding redundant invocations <br/> \n- *      9. Shorthand for mocks creation - &#064;Mock annotation <br/> \n- *      10. Stubbing consecutive calls (iterator-style stubbing) <br/> \n- *      11. Stubbing with callbacks <br/>\n- *      12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids <br/>\n- *      13. Spying on real objects <br/>\n- *      14. Changing default return values of unstubbed invocations <br/>\n- *      15. (**New**) Capturing arguments for further assertions <br/>\n- *      16. (**New**) Troubleshooting <br/>\n+ *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \n+ *      <a href=\"#2\">2. How about some stubbing? </a><br/>\n+ *      <a href=\"#3\">3. Argument matchers </a><br/>\n+ *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \n+ *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \n+ *      <a href=\"#6\">6. Verification in order </a><br/> \n+ *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \n+ *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \n+ *      <a href=\"#9\">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> \n+ *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n+ *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n+ *      <a href=\"#12\">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>\n+ *      <a href=\"#13\">13. Spying on real objects </a><br/>\n+ *      <a href=\"#14\">14. Changing default return values of unstubbed invocations </a><br/>\n+ *      <a href=\"#15\">15. (**New**) Capturing arguments for further assertions </a><br/>\n+ *      <a href=\"#16\">16. (**New**) Troubleshooting & validating framework usage</a><br/>\n  * </b>\n  * \n  * <p>\n  * like add(), get(), clear() will be used). <br>\n  * You probably wouldn't mock List class 'in real'.\n  * \n- * <h3>1. Let's verify some behaviour!</h3>\n+ * <h3 id=\"1\">1. Let's verify some behaviour!</h3>\n  * \n  * <pre>\n  * //Let's import Mockito statically so that the code looks clearer\n  * Once created, mock will remember all interactions. Then you can selectively\n  * verify whatever interaction you are interested in.\n  * \n- * <h3>2. How about some stubbing?</h3>\n+ * <h3 id=\"2\">2. How about some stubbing?</h3>\n  * \n  * <pre>\n  * //You can mock concrete classes, not only interfaces\n  * \n  * </ul>\n  * \n- * <h3>3. Argument matchers</h3>\n+ * <h3 id=\"3\">3. Argument matchers</h3>\n+ * \n+ * Mockito verifies argument values in natural java style: by using an equals() method.\n+ * Sometimes, when extra flexibility is required then you might use argument matchers:  \n  * \n  * <pre>\n  * //stubbing using built-in anyInt() argument matcher\n  * {@link Matchers Click here to see} more built-in matchers \n  * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n  * <p>\n- * <b>Warning:</b>\n+ * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\n+ * <p>\n+ * Be reasonable with using complicated argument matching.\n+ * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.\n+ * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.\n+ * <p>\n+ * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\n+ * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \n+ * <p>\n+ * <b>Warning on argument matchers:</b>\n  * <p>\n  * If you are using argument matchers, <b>all arguments</b> have to be provided\n  * by matchers.\n  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n  * </pre>\n  * \n- * <h3>4. Verifying exact number of invocations / at least x / never</h3>\n+ * <h3 id=\"4\">4. Verifying exact number of invocations / at least x / never</h3>\n  * \n  * <pre>\n  * //using mock \n  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n  * omitted.\n  * \n- * <h3>5. Stubbing void methods with exceptions</h3>\n+ * <h3 id=\"5\">5. Stubbing void methods with exceptions</h3>\n  * \n  * <pre>\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n  * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n  * \n- * <h3>6. Verification in order</h3>\n+ * <h3 id=\"6\">6. Verification in order</h3>\n  * \n  * <pre>\n  * List firstMock = mock(List.class);\n  * Also, you can create InOrder object passing only mocks that are relevant for\n  * in-order verification.\n  * \n- * <h3>7. Making sure interaction(s) never happened on mock</h3>\n+ * <h3 id=\"7\">7. Making sure interaction(s) never happened on mock</h3>\n  * \n  * <pre>\n  * //using mocks - only mockOne is interacted\n  * \n  * </pre>\n  * \n- * <h3>8. Finding redundant invocations</h3>\n+ * <h3 id=\"8\">8. Finding redundant invocations</h3>\n  * \n  * <pre>\n  * //using mocks\n  * communicates the intent well.\n  * <p>\n  * \n- * <h3>9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n+ * <h3 id=\"9\">9. Shorthand for mocks creation - &#064;Mock annotation</h3>\n  * \n  * <ul>\n  * <li>Minimizes repetitive mock creation code.</li>\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n  * \n- * <h3> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n+ * <h3 id=\"10\"> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>\n  * \n  * Sometimes we need to stub with different return value/exception for the same\n  * method call. Typical use case could be mocking iterators. \n  *   .thenReturn(\"one\", \"two\", \"three\");\n  * </pre>\n  * \n- * <h3> 11. Stubbing with callbacks</h3>\n+ * <h3 id=\"11\"> 11. Stubbing with callbacks</h3>\n  * \n  * Allows stubbing with generic {@link Answer} interface.\n *  <p>\n  * System.out.println(mock.someMethod(\"foo\"));\n  * </pre>\n  * \n- * <h3> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n+ * <h3 id=\"12\"> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>\n  * \n  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n  * <p>\n  * <p>\n  * {@link Mockito#doReturn(Object)}\n  * \n- * <h3> 13. Spying on real objects</h3>\n+ * <h3 id=\"13\"> 13. Spying on real objects</h3>\n  * \n  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).\n  * <p>\n  * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n  * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n  * \n- * <h3>14. Changing default return values of unstubbed invocations</h3>\n+ * <h3 id=\"14\">14. Changing default return values of unstubbed invocations</h3>\n  * \n  * You can create a mock with specified strategy of for its return values.\n  * It's quite advanced feature and typically you don't need it to write decent tests.\n  * <p>\n  * Read more about this interesting implementation of <i>ReturnValues</i>: {@link Mockito#RETURNS_SMART_NULLS}\n  * \n- * <h3>15. (**New**) Capturing arguments for further assertions</h3>\n- * \n- * \n+ * <h3 id=\"15\">15. (**New**) Capturing arguments for further assertions</h3>\n+ * \n+ * Mockito verifies argument values in natural java style: by using an equals() method.\n+ * This is also the recommended way of matching arguments because it makes tests clean & simple.\n+ * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n+ * For example:\n+ * <pre>\n+ *   ArgumentCaptor&lt;Person&gt; argument = new ArgumentCaptor&lt;Person&gt;();\n+ *   verify(mock).doSomething(argument.capture());\n+ *   assertEquals(\"John\", argument.getValue().getName());\n+ * </pre>\n+ * \n+ * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n+ * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n+ * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n+ * <p>\n+ * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n+ * Both techniques can be used for making sure certain arguments where passed to mocks. \n+ * However, ArgumentCaptor may be a better fit if:\n+ * <ul>  \n+ * <li>custom argument matcher is not likely to be reused</li>\n+ * <li>you just need it to assert on argument values to complete verification</li>\n+ * </ul>\n+ * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n  *  \n- * <h3>16. (**New**) Troubleshooting</h3>\n+ * <h3 id=\"16\">16. (**New**) Troubleshooting & validating framework usage</h3>\n  * \n  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n  * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n      * <p>  \n      * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. However, there's a gotcha so read on.\n      * <p>\n-     * {@link Mockito#validateMockitoUsage()} explicitly validates the framework state to detect invalid use of Mockito.\n+     * <b>{@link Mockito#validateMockitoUsage()} explicitly validates the framework state to detect invalid use of Mockito.</b>\n      * <p>\n      * Examples of incorrect use:\n      * <pre>\n      * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.  \n      * <p>\n      * Bear in mind that <b>usually you shouldn't need to validateMockitoUsage()</b> \n-     * and framework validation triggered on next-time basis is just enough.\n+     * and framework validation triggered on next-time basis is just enough,\n+     * mainly because of enhanced exception message with clickable location of defect.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      */", "timestamp": 1241198000, "metainfo": ""}