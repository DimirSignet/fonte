{"sha": "b93f85ea372a0e8b2de01a920b797455b8201b87", "log": "another bunch of refactorings, getting rid of TODOs and adding more functional tests  --HG-- rename : src/org/mockito/exceptions/verification/VerificationError.java => src/org/mockito/exceptions/verification/InvocationDiffersFromActual.java rename : src/org/mockito/exceptions/verification/NoInteractionsWantedError.java => src/org/mockito/exceptions/verification/NoInteractionsWanted.java rename : src/org/mockito/exceptions/verification/TooLittleActualInvocationsError.java => src/org/mockito/exceptions/verification/TooLittleActualInvocations.java rename : src/org/mockito/exceptions/verification/TooManyActualInvocationsError.java => src/org/mockito/exceptions/verification/TooManyActualInvocations.java rename : test/org/mockitousage/PointingStackTraceToActualInvocationTest.java => test/org/mockitousage/PointingStackTraceToActualChunkTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40233", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n /**\n  * Reports verification and misusing errors.\n \n         cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n \n-        throw new VerificationError(join(\n+        throw new InvocationDiffersFromActual(join(\n                 \"Invocation differs from actual\",\n                 \"Wanted invocation:\",\n                 wanted\n     }\n \n     public void wantedButNotInvoked(String wanted) {\n-        throw new VerificationError(join(\n+        throw new WantedButNotInvoked(join(\n                     \"Wanted but not invoked:\",\n                     wanted\n         ));\n         UndesiredInvocation cause = new UndesiredInvocation(join(\"Undesired invocation:\"));\n         cause.setStackTrace(firstUndesired.getStackTrace());\n \n-        throw new TooManyActualInvocationsError(join(\n+        throw new TooManyActualInvocations(join(\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n             cause.setStackTrace(lastActualInvocationStackTrace.getStackTrace());\n         }\n \n-        throw new TooLittleActualInvocationsError(join(\n+        throw new TooLittleActualInvocations(join(\n                 wanted,\n                 \"Wanted \" + pluralize(wantedCount) + \" but was \" + actualCount\n         ), cause);\n         ));\n         \n         cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n-        throw new NoInteractionsWantedError(join(\"No interactions wanted\"), cause);\n+        throw new NoInteractionsWanted(join(\"No interactions wanted\"), cause);\n     }\n \n     public void unfinishedStubbing() {\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/InvocationDiffersFromActual.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class InvocationDiffersFromActual extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public InvocationDiffersFromActual(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/NoInteractionsWanted.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+/**\n+ * No interactions wanted. See exception's cause for location of undesired invocation.\n+ */\n+public class NoInteractionsWanted extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public NoInteractionsWanted(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/TooLittleActualInvocations.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class TooLittleActualInvocations extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+    \n+    public TooLittleActualInvocations(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/TooManyActualInvocations.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class TooManyActualInvocations extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public TooManyActualInvocations(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/WantedButNotInvoked.java\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class WantedButNotInvoked extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public WantedButNotInvoked(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n                 && argumentsMatch(actual.getArguments());\n     }\n     \n-    public boolean matchesButMocksAreDifferent(Invocation actual) {\n-        return !invocation.getMock().equals(actual.getMock())\n-            && invocation.getMethod().equals(actual.getMethod())\n-            && argumentsMatch(actual.getArguments());\n-    }\n-    \n-    public boolean matchesMockArgsAndMethodNameButMethodNotEqual(Invocation actual) {\n+    public boolean differsWithArgumentTypes(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n             && argumentsMatch(actual.getArguments())\n             && invocation.getMethod().getName().equals(actual.getMethod().getName())\n--- a/src/org/mockito/internal/invocation/InvocationsPrinter.java\n+++ b/src/org/mockito/internal/invocation/InvocationsPrinter.java\n     private final String wanted;\n     private final String actual;\n \n-    //TODO use it in other situations also!\n     public InvocationsPrinter(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n-        if (wantedInvocation.matchesMockArgsAndMethodNameButMethodNotEqual(actualInvocation)) {\n+        if (wantedInvocation.differsWithArgumentTypes(actualInvocation)) {\n             wanted = wantedInvocation.toStringWithArgumentTypes();\n             actual = actualInvocation.toStringWithArgumentTypes();\n         } else {\n--- a/src/org/mockito/internal/matchers/EqualsWithDelta.java\n+++ b/src/org/mockito/internal/matchers/EqualsWithDelta.java\n                         + delta.doubleValue();\n     }\n \n-    //TODO not tested\n     public void appendTo(StringBuilder buffer) {\n         buffer.append(\"eq(\" + wanted + \", \" + delta + \")\");\n     }\n--- a/src/org/mockito/internal/progress/OngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.progress;\n-\n-import org.mockito.Mockito;\n \n /**\n  * Stubs with return value or exception. E.g:\n--- a/src/org/mockito/internal/progress/VerificationMode.java\n+++ b/src/org/mockito/internal/progress/VerificationMode.java\n package org.mockito.internal.progress;\n-\n-import org.mockito.Mockito;\n \n /**\n  * Allows verifying that certain behavior happened at least once or exact number of times. E.g:\n--- a/src/org/mockito/internal/stubbing/StubbedMethodSelector.java\n+++ b/src/org/mockito/internal/stubbing/StubbedMethodSelector.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing;\n-\n-import org.mockito.Mockito;\n \n /**\n  * Chooses void method for stubbing with throwable. E.g:\n--- a/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing;\n-\n-import org.mockito.Mockito;\n \n /**\n  * Stubs void method with exception. E.g:\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n \n     private void reportMissingInvocationError(InvocationMatcher wanted, Invocation similar) {\n         if (similar != null) {\n-            //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, similar);\n             reporter.wantedInvocationDiffersFromActual(printer.printWanted(), printer.printActual(), similar.getStackTrace());\n         } else {\n-            //TODO I really want a cause here, something like: \"wanted after...\"\n+            //TODO For strictly, I really want a cause here, something like: \"wanted after...\" for strictly... :D\n             reporter.wantedButNotInvoked(wanted.toString());\n         }\n     }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         \n         int actualCount = actualInvocations.size();\n         if (mode.tooLittleActualInvocations(actualCount)) {\n-            //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n             HasStackTrace lastInvocation = analyzer.findLastMatchingInvocationTrace(actualInvocations, wanted);\n             reporter.tooLittleActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), lastInvocation);\n         } else if (mode.tooManyActualInvocations(actualCount)) {\n-            //TODO I want a functional test that proves that correct stack trace is provided for cause for both strictly and ordinary verification\n             HasStackTrace firstUndesired = analyzer.findFirstUndesiredInvocationTrace(actualInvocations, wanted, mode);\n             reporter.tooManyActualInvocations(mode.wantedCount(), actualCount, wanted.toString(), firstUndesired);\n         }\n--- a/test/org/mockito/exceptions/ReporterTest.java\n+++ b/test/org/mockito/exceptions/ReporterTest.java\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n \n public class ReporterTest extends RequiresValidState {\n \n-    @Test(expected=TooLittleActualInvocationsError.class)\n+    @Test(expected=TooLittleActualInvocations.class)\n     public void shouldLetPassingNullLastActualStackTrace() throws Exception {\n         new Reporter().tooLittleActualInvocations(1, 2, \"wanted\", null);\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/PointingStackTraceToActualChunkTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+\n+public class PointingStackTraceToActualChunkTest extends RequiresValidState {\n+    \n+    private IMethods mock;\n+    private IMethods mockTwo;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+        mockTwo = Mockito.mock(IMethods.class);\n+        \n+        firstChunk();\n+        secondChunk();\n+        thirdChunk();\n+        fourthChunk();\n+    }\n+\n+    private void firstChunk() {\n+        mock.simpleMethod(1);\n+        mock.simpleMethod(1);\n+    }\n+    private void secondChunk() {\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+    }\n+    private void thirdChunk() {\n+        mock.simpleMethod(3);\n+        mock.simpleMethod(3);\n+    }\n+    private void fourthChunk() {\n+        mockTwo.simpleMethod(4);\n+        mockTwo.simpleMethod(4);\n+    }\n+    \n+    public void shouldPointStackTraceToActualInvocation() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        strictly.verify(mock, atLeastOnce()).simpleMethod(anyInt());\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocation() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedInvocation() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunk() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        \n+        try {\n+            strictly.verify(mockTwo).simpleMethod(anyInt());\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"secondChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsUnverifiedChunk() {\n+        Strictly strictly = createStrictOrderVerifier(mock, mockTwo);\n+        strictly.verify(mockTwo, times(2)).simpleMethod(anyInt());\n+        \n+        try {\n+            strictly.verify(mockTwo, times(3)).simpleMethod(anyInt());\n+            fail();\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"fourthChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToActualInvocationOnVerificationError() {\n+        try {\n+            verify(mock).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPointToUnverifiedActualInvocationOnVerificationError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, atLeastOnce()).simpleMethod(999);\n+            fail();\n+        } catch (InvocationDiffersFromActual e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooLittleInvocationsChunkOnError() {\n+        verify(mock, atLeastOnce()).simpleMethod(1);\n+        try {\n+            verify(mock, times(3)).simpleMethod(3);\n+            fail();\n+        } catch (TooLittleActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"thirdChunk\"));\n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPointToTooManyInvocationsChunkOnError() {\n+        try {\n+            verify(mock).simpleMethod(1);\n+            fail();\n+        } catch (TooManyActualInvocations e) {\n+            assertThat(e.getCause(), hasFirstMethodInStackTrace(\"firstChunk\"));\n+        }\n+    }   \n+}\n--- a/test/org/mockitousage/StackTraceFilteringTest.java\n+++ b/test/org/mockitousage/StackTraceFilteringTest.java\n  */\n package org.mockitousage;\n \n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.createStrictOrderVerifier;\n-import static org.mockito.Mockito.stub;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n-import static org.mockito.Mockito.verifyZeroInteractions;\n-import static org.mockito.util.ExtraMatchers.hasFirstMethodInStackTrace;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.After;\n import org.junit.Before;\n import org.mockito.StateResetter;\n import org.mockito.Strictly;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n public class StackTraceFilteringTest extends RequiresValidState {\n     \n         try {\n             verify(mock).simpleMethod();\n             fail();\n-        } catch (VerificationError expected) {\n-            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerify\"));\n+        } catch (WantedButNotInvoked e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerify\"));\n         }\n     }\n     \n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {\n+        } catch (NoInteractionsWanted e) {\n             assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n         }\n     }\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {\n+        } catch (NoInteractionsWanted e) {\n             assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n         }\n     }\n         try {\n             strictly.verify(mock).oneArg(true);\n             fail();\n-        } catch (VerificationError expected) {\n-            assertThat(expected, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n+        } catch (WantedButNotInvoked e) {\n+            assertThat(e, hasFirstMethodInStackTrace(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n         }\n     }\n     \n--- a/test/org/mockitousage/StackTrackeChangingTest.java\n+++ b/test/org/mockitousage/StackTrackeChangingTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n \n public class StackTrackeChangingTest extends RequiresValidState {\n     \n         try {\n             verifySimpleMethodOnAMock();\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, hasMethodInStackTraceAt(0, \"verifySimpleMethodOnAMock\"));\n             assertThat(e, hasMethodInStackTraceAt(1, \"shouldShowActualInvocationAsExceptionCause\"));\n             assertThat(e.getCause(), hasMethodInStackTraceAt(0, \"simpleMethodOnAMock\"));\n--- a/test/org/mockitousage/UsingVarargsTest.java\n+++ b/test/org/mockitousage/UsingVarargsTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n \n public class UsingVarargsTest extends RequiresValidState {\n \n         try {\n             verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }\n \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n \n     @Test\n         try {\n             verify(mock).withBooleanVarargs(3, true, true, true, true);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }\n }\n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n \n public class IncorectBindingPuzzleFixedTest extends RequiresValidState {\n \n         try {\n             verify(sub).say(\"Hello\");\n             fail();\n-        } catch (VerificationError error) {\n+        } catch (InvocationDiffersFromActual error) {\n             String expected =\n                 \"\\n\" +\n                 \"Invocation differs from actual\" +\n         try {\n             strictly.verify(sub).say(\"Hello\");\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n             assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n         }\n         try {\n             verify(sub).say(contains(\"world\"));\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n             assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n         }\n--- a/test/org/mockitousage/matchers/MatchersTest.java\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n  */\n package org.mockitousage.matchers;\n \n+import static org.mockito.util.ExtraMatchers.messageContains;\n import static org.junit.Assert.*;\n import static org.mockito.AdditionalMatchers.*;\n import static org.mockito.Matchers.*;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n+\n \n @SuppressWarnings(\"unchecked\")\n public class MatchersTest extends RequiresValidState {\n         try {\n             verify(mock).oneArray(aryEq(nullArray));\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (WantedButNotInvoked e) {\n             String expected = \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n \n         assertEquals(null, mock.oneArg(2.2F));\n     }\n+    \n+    @Test\n+    public void deltaMatcherPrintsItself() {\n+        try {\n+            verify(mock).oneArg(eq(1.0D, 0.1D));\n+            fail();\n+        } catch (WantedButNotInvoked e) {\n+            assertThat(e, messageContains(\"eq(1.0, 0.1)\"));\n+        }\n+    }\n \n     @Test\n     public void sameMatcher() {\n--- a/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n+++ b/test/org/mockitousage/matchers/VerificationAndStubbingUsingMatchersTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             verify(three).varargsObject(eq(10), eq(\"first arg\"), startsWith(\"third\"));\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n }\n--- a/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             verify(mock).simpleMethod(\"one\");\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n         \n         try {\n             verify(mock).simpleMethod(\"two\");\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n         \n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n }\n--- a/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n \n @SuppressWarnings({\"serial\", \"unchecked\"})\n public class StubbingWithThrowablesTest extends RequiresValidState {\n         try {\n             verify(mock).size();\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n         \n         try {\n             verify(mock).clone();\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n         \n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     private class ExceptionOne extends RuntimeException {};\n--- a/test/org/mockitousage/verification/AtLeastOnceVerificationTest.java\n+++ b/test/org/mockitousage/verification/AtLeastOnceVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.verify;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n @SuppressWarnings(\"unchecked\")\n public class AtLeastOnceVerificationTest extends RequiresValidState {\n         try {\n             verify(mockTwo, atLeastOnce()).add(\"foo\");\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n     \n-    @Test(expected=VerificationError.class)\n+    @Test(expected=WantedButNotInvoked.class)\n     public void shouldFailIfMethodWasNotCalledAtAll() throws Exception {\n         verify(mock, atLeastOnce()).add(\"foo\");\n     }\n--- a/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicStrictVerificationTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             strictly.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (VerificationError e) {}\n-    }\n-    \n-    @Test(expected=TooManyActualInvocationsError.class)\n+        } catch (WantedButNotInvoked e) {}\n+    }\n+    \n+    @Test(expected=TooManyActualInvocations.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n         strictly.verify(mockOne, times(0)).simpleMethod(1);\n     }\n     \n-    @Test(expected=TooLittleActualInvocationsError.class)\n+    @Test(expected=TooLittleActualInvocations.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n         strictly.verify(mockOne, times(2)).simpleMethod(1);\n     }\n         try {\n             strictly.verify(mockTwo, times(3)).simpleMethod(2);\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n+        } catch (TooLittleActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(0)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne, times(0)).simpleMethod(4);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne, times(2)).simpleMethod(4);\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n+        } catch (TooLittleActualInvocations e) {}\n     }    \n     \n     /* ------------- */\n     \n-    @Test(expected=VerificationError.class)\n+    @Test(expected=InvocationDiffersFromActual.class)\n     public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n         strictly.verify(mockOne).simpleMethod(100);\n     }\n     \n-    @Test(expected=VerificationError.class)\n+    @Test(expected=InvocationDiffersFromActual.class)\n     public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n         strictly.verify(mockOne).oneArg(true);\n     }\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(-999);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).oneArg(true);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(-666);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).oneArg(false);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     }    \n     \n     /* -------------- */\n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n-    } \n-    \n-    @Test(expected=NoInteractionsWantedError.class)\n+        } catch (NoInteractionsWanted e) {}\n+    } \n+    \n+    @Test(expected=NoInteractionsWanted.class)\n     public void shouldFailOnVerifyZeroInteractions() {\n         verifyZeroInteractions(mockOne);\n     }\n--- a/test/org/mockitousage/verification/BasicVerificationTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.stub;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n \n import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicVerificationTest extends RequiresValidState {\n         verifyNoMoreInteractions(mock);\n     }\n \n-    @Test(expected=VerificationError.class)\n+    @Test(expected=WantedButNotInvoked.class)\n     public void shouldFailVerification() throws Exception {\n         verify(mock).clear();\n     }\n         try {\n             verify(mock).add(\"bar\");\n             fail();\n-        } catch (VerificationError expected) {}\n+        } catch (InvocationDiffersFromActual expected) {}\n     }\n \n     @Test\n         try {\n             verify(mockTwo, atLeastOnce()).add(\"foo\");\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             verify(mock).clear();\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n \n     @Test\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n \n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n-import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n public class DescriptiveMessagesOnStrictOrderErrorsTest extends RequiresValidState {\n         try {\n             strictly.verify(one).simpleMethod(999);\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             String expected = \n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n         try {\n             strictly.verify(three).simpleMethod(999);\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (WantedButNotInvoked e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n         try {\n             strictly.verify(two, times(1)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {\n+        } catch (TooManyActualInvocations e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n     }  \n     \n     @Test\n-    public void shouldPrintThatWasNotInvokedAfter() {\n+    public void shouldPrintThatWantedButNotInvoked() {\n         strictly.verify(two, atLeastOnce()).simpleMethod(2);\n         try {\n             strictly.verify(one).simpleMethod(1);\n             fail();\n-        } catch (VerificationError e) {\n-            //TODO refactor to WantedButNotInvoked\n-            assertThat(e, messageContains(\"Wanted but not invoked\"));\n-            //TODO what about a feature to show after which line we expect this thing:\n-//            String expectedCause = \n-//                \"\\n\" +\n-//                \"Not invoked after:\";\n-//            assertEquals(expectedCause, e.getCause().getMessage());\n-        }\n+        } catch (WantedButNotInvoked e) {}\n     }  \n     \n     @Test\n         try {\n             strictly.verify(two, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {\n+        } catch (TooManyActualInvocations e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n         try {\n             strictly.verify(two, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {\n+        } catch (TooLittleActualInvocations e) {\n             String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.cause.TooLittleInvocations;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n \n @SuppressWarnings(\"unchecked\")\n public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends RequiresValidState {\n         try {\n             Mockito.verify(mock, times(100)).clear();\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {\n+        } catch (TooLittleActualInvocations e) {\n             String expected =\n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n         try {\n             Mockito.verify(mock, times(1)).clear();\n             fail();\n-        } catch (TooManyActualInvocationsError e) {\n+        } catch (TooManyActualInvocations e) {\n             String expected =\n                 \"\\n\" +\n                 \"LinkedList.clear()\" +\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n  */\n package org.mockitousage.verification;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertThat;\n-import static org.junit.Assert.fail;\n-import static org.mockito.AdditionalMatchers.aryEq;\n-import static org.mockito.Matchers.anyInt;\n-import static org.mockito.Matchers.eq;\n-import static org.mockito.Matchers.matches;\n-import static org.mockito.Mockito.atLeastOnce;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyNoMoreInteractions;\n-import static org.mockito.Mockito.verifyZeroInteractions;\n-import static org.mockito.util.ExtraMatchers.causeMessageContains;\n-import static org.mockito.util.ExtraMatchers.messageContains;\n+import static org.junit.Assert.*;\n+import static org.mockito.AdditionalMatchers.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n import org.mockito.exceptions.cause.WantedDiffersFromActual;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n public class DescriptiveMessagesWhenVerificationFailsTest extends RequiresValidState {\n         try {\n             verify(mock).simpleMethod();\n             fail();\n-        } catch (VerificationError expected) {\n-            String actualMessage = expected.getMessage();\n+        } catch (WantedButNotInvoked e) {\n+            String actualMessage = e.getMessage();\n             String expectedMessage =\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n         try {\n             verify(mock).threeArgumentMethod(12, new SomeClass(), \"xx\");\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (WantedButNotInvoked e) {\n             assertThat(e, messageContains(\"IMethods.threeArgumentMethod(12, SomeClass instance, \\\"xx\\\")\"));\n         }\n     }\n         try {\n             verify(mock).twoArgumentMethod(1, 1000);\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             String expected =\n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.simpleMethod(\\\"test\\\")\"));\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n         }\n             verify(mock).differentMethod();\n             verify(mock).threeArgumentMethod(1, \"2\", \"3\");\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.threeArgumentMethod(1, \\\"2\\\", \\\"3\\\")\"));\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n         }\n         try {\n             verify(mock).twoArgumentMethod(3, 1000);\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.twoArgumentMethod(3, 1000)\"));\n             assertThat(e, causeMessageContains(\"IMethods.twoArgumentMethod(3, 3)\"));\n         }\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {\n+        } catch (NoInteractionsWanted e) {\n             String expectedMessage =\n                     \"\\n\" +\n                     \"No interactions wanted\";\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {\n+        } catch (NoInteractionsWanted e) {\n             String expected =\n                     \"\\n\" +\n                     \"No interactions wanted\";\n         try {\n             verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (WantedButNotInvoked e) {\n             assertThat(e, messageContains(\"IMethods.twoArgumentMethod(1, 2)\"));\n         }\n     }\n         try {\n             verify(mock, atLeastOnce()).twoArgumentMethod(anyInt(), eq(100));\n             fail();\n-        } catch (VerificationError expected) {\n-            String actualMessage = expected.getMessage();\n+        } catch (WantedButNotInvoked e) {\n+            String actualMessage = e.getMessage();\n             String expectedMessage =\n                 \"\\n\" +\n                 \"Wanted but not invoked:\" +\n         try {\n             verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.oneArray([false, false, false])\"));\n             assertThat(e, causeMessageContains(\"IMethods.oneArray([true, false, false])\"));\n         }\n         try {\n             verify(mock).varargsString(10, \"two\", \"one\");\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.varargsString(10, \\\"two\\\", \\\"one\\\")\"));\n             assertThat(e, causeMessageContains(\"IMethods.varargsString(10, \\\"one\\\", \\\"two\\\")\"));\n         }\n         try {\n             verify(mock).simpleMethod(matches(\"burrito\"));\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.simpleMethod(matches(\\\"burrito\\\"))\"));\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod(\\\"foo\\\")\"));\n         }\n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, causeMessageContains(\"simpleMethod(null, null)\"));\n         }\n     }\n         try {\n             verify(mock).varargs((String[]) new String[] {});\n             fail();\n-        } catch(VerificationError e) {\n+        } catch(InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.varargs(class [Ljava.lang.String;)\"));\n             assertThat(e, causeMessageContains(\"IMethods.varargs(class [Ljava.lang.Object;)\"));\n         }\n--- a/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n \n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n-import static org.mockito.Mockito.*;\n import static org.mockito.util.ExtraMatchers.*;\n \n import java.util.LinkedList;\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n \n @SuppressWarnings(\"unchecked\")\n public class ExactNumberOfTimesVerificationTest extends RequiresValidState {\n         try {\n             verify(mock, times(100)).clear();\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {\n+        } catch (TooLittleActualInvocations e) {\n             assertThat(e, messageContains(\"Wanted 100 times but was 2\"));\n         }\n     }\n         try {\n             verify(mock, times(1)).clear();\n             fail();\n-        } catch (TooManyActualInvocationsError e) {\n+        } catch (TooManyActualInvocations e) {\n             assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n         }\n     }\n         try {\n             verify(mock, times(15)).clear();\n             fail();\n-        } catch (VerificationError e) {\n-            assertThat(e, messageContains(\"Wanted but not invoked\"));\n-        }\n+        } catch (WantedButNotInvoked e) {}\n     }\n \n     @Test\n         try {\n             verify(mock, times(0)).clear();\n             fail();\n-        } catch (TooManyActualInvocationsError e) {\n+        } catch (TooManyActualInvocations e) {\n             assertThat(e, messageContains(\"Wanted 0 times but was 1\"));\n         }\n     }\n--- a/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n \n @SuppressWarnings(\"unchecked\")\n public class NoMoreInteractionsVerificationTest extends RequiresValidState {\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             verifyZeroInteractions(map);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n }\n--- a/test/org/mockitousage/verification/RelaxedStrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/RelaxedStrictVerificationTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n     }\n     \n-    @Test(expected=VerificationError.class)\n+    @Test(expected=InvocationDiffersFromActual.class)\n     public void shouldFailOnWrongMethodCalledOnMockTwo() {\n         strictly.verify(mockTwo, atLeastOnce()).differentMethod();\n     }\n         try {\n             verify(mockOne, times(0)).simpleMethod(1);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockThree, times(0)).simpleMethod(3);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mockTwo);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(0)).simpleMethod(2);\n             fail();\n-        } catch(TooManyActualInvocationsError e) {}\n+        } catch(TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(3)).simpleMethod(2);\n             fail();\n-        } catch(TooLittleActualInvocationsError e) {}\n+        } catch(TooLittleActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo).simpleMethod(2);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(999);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n }\n--- a/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n+++ b/test/org/mockitousage/verification/SelectedMocksInOrderVerificationTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.TooManyActualInvocations;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             strictly.verify(mockOne).differentMethod();\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n     } \n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     } \n \n     @Test\n         try {\n             strictly.verify(mockTwo).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(4)).simpleMethod(2);\n             fail();\n-        } catch (TooLittleActualInvocationsError e) {}\n+        } catch (TooLittleActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, times(2)).simpleMethod(2);\n             fail();\n-        } catch (TooManyActualInvocationsError e) {}\n+        } catch (TooManyActualInvocations e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mockThree);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mockTwo);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n }\n--- a/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationMixedWithOrdiraryVerificationTest.java\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.verification.NoInteractionsWantedError;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (NoInteractionsWantedError e) {}\n+        } catch (NoInteractionsWanted e) {}\n     }\n     \n     @Test\n--- a/test/org/mockitousage/verification/StrictVerificationTest.java\n+++ b/test/org/mockitousage/verification/StrictVerificationTest.java\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.Strictly;\n-import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             strictly.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     } \n     \n     @Test\n         try {\n             strictly.verify(mockOne, atLeastOnce()).differentMethod();\n             fail();\n-        } catch (VerificationError e) {\n+        } catch (InvocationDiffersFromActual e) {\n             assertThat(e, messageContains(\"IMethods.differentMethod()\"));\n             assertThat(e, causeMessageContains(\"IMethods.simpleMethod()\"));\n         }\n         try {\n             strictly.verify(mockOne, atLeastOnce()).simpleMethod();\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne, times(3)).simpleMethod(anyInt());\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }\n }\n--- a/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.RequiresValidState;\n-import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             verify(mock).oneArg(same(three));\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (WantedButNotInvoked e) {}\n     }  \n     \n     @Test\n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n \n         mock.threeArgumentMethod(8, new Object(), \"01234\");\n         \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"no match\");\n \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (InvocationDiffersFromActual e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"123\");\n         ", "timestamp": 1198535022, "metainfo": ""}