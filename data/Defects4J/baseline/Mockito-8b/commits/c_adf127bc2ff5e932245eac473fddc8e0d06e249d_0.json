{"sha": "adf127bc2ff5e932245eac473fddc8e0d06e249d", "log": "issue 372 : underscored test methods before adding test", "commit": "\n--- a/test/org/mockito/ArgumentCaptorTest.java\n+++ b/test/org/mockito/ArgumentCaptorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.junit.After;\n public class ArgumentCaptorTest extends TestBase {\n     \n     @Test\n-    public void tellHandyReturnValuesToReturnValueFor() throws Exception {\n+    public void tell_handy_return_values_to_return_value_for() throws Exception {\n         //given\n         final Object expected = new Object(); \n         ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);\n     }\n     \n     @After\n-    public void yesIKnowSomeMatchersAreMisplaced() {\n+    public void yes_I_know_some_matchers_are_misplaced() {\n         resetState();\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n public class InvocationMatcherTest extends TestBase {\n \n     private InvocationMatcher simpleMethod;\n-    @Mock private IMethods mock; \n-    \n+    @Mock private IMethods mock;\n+\n     @Before\n     public void setup() {\n         simpleMethod = new InvocationBuilder().mock(mock).simpleMethod().toInvocationMatcher();\n     }\n \n     @Test\n-    public void shouldBeACitizenOfHashes() throws Exception {\n+    public void should_be_a_citizen_of_hashes() throws Exception {\n         Invocation invocation = new InvocationBuilder().toInvocation();\n         Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n-        \n+\n         Map map = new HashMap();\n         map.put(new InvocationMatcher(invocation), \"one\");\n         map.put(new InvocationMatcher(invocationTwo), \"two\");\n-        \n+\n         assertEquals(2, map.size());\n     }\n-    \n+\n     @Test\n-    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n+    public void should_not_equal_if_number_of_arguments_differ() throws Exception {\n         InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n         InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n \n         assertFalse(withOneArg.equals(null));\n         assertFalse(withOneArg.equals(withTwoArgs));\n     }\n-    \n+\n     @Test\n-    public void shouldToStringWithMatchers() throws Exception {\n+    public void should_to_string_with_matchers() throws Exception {\n         Matcher m = NotNull.NOT_NULL;\n         InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));\n         Matcher mTwo = new Equals('x');\n         assertContains(\"simpleMethod(notNull())\", notNull.toString());\n         assertContains(\"simpleMethod('x')\", equals.toString());\n     }\n-    \n+\n     @Test\n-    public void shouldKnowIfIsSimilarTo() throws Exception {\n+    public void should_know_if_is_similar_to() throws Exception {\n         Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n         assertTrue(simpleMethod.hasSimilarMethod(same));\n-        \n+\n         Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(different));\n     }\n-    \n+\n     @Test\n-    public void shouldNotBeSimilarToVerifiedInvocation() throws Exception {\n+    public void should_not_be_similar_to_verified_invocation() throws Exception {\n         Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(verified));\n     }\n-       \n+\n     @Test\n-    public void shouldNotBeSimilarIfMocksAreDifferent() throws Exception {\n+    public void should_not_be_similar_if_mocks_are_different() throws Exception {\n         Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));\n-    }    \n-    \n+    }\n+\n     @Test\n-    public void shouldNotBeSimilarIfIsOverloadedButUsedWithTheSameArg() throws Exception {\n+    public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg() throws Exception {\n         Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n-        \n+\n         String sameArg = \"test\";\n-        \n+\n         InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();\n         Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n-        \n+\n         assertFalse(invocation.hasSimilarMethod(overloadedInvocation));\n-    } \n-    \n+    }\n+\n     @Test\n-    public void shouldBeSimilarIfIsOverloadedButUsedWithDifferentArg() throws Exception {\n+    public void should_be_similar_if_is_overloaded_but_used_with_different_arg() throws Exception {\n         Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n-        \n+\n         InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg(\"foo\").toInvocationMatcher();\n         Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n-        \n+\n         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n-    \n+\n     @Test\n-    public void shouldCaptureArgumentsFromInvocation() throws Exception {\n+    public void should_capture_arguments_from_invocation() throws Exception {\n         //given\n         Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         CapturingMatcher capturingMatcher = new CapturingMatcher();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), capturingMatcher));\n-        \n+\n         //when\n         invocationMatcher.captureArgumentsFrom(invocation);\n-        \n+\n         //then\n         assertEquals(1, capturingMatcher.getAllValues().size());\n         assertEquals(100, capturingMatcher.getLastValue());\n     }\n \n     @Test\n-    public void shouldMatchVarargsUsingAnyVarargs() throws Exception {\n+    public void should_match_varargs_using_any_varargs() throws Exception {\n         //given\n         mock.varargs(\"1\", \"2\");\n         Invocation invocation = getLastInvocation();\n     }\n \n     @Test\n-    public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n+    public void should_match_captured_arguments_when_args_count_does_NOT_match() throws Exception {\n         //given\n         mock.varargs();\n         Invocation invocation = getLastInvocation();\n     }\n \n     @Test\n-    public void shouldCreateFromInvocations() throws Exception {\n+    public void should_create_from_invocations() throws Exception {\n         //given\n         Invocation i = new InvocationBuilder().toInvocation();\n         //when\n--- a/test/org/mockito/internal/matchers/CapturingMatcherTest.java\n+++ b/test/org/mockito/internal/matchers/CapturingMatcherTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.matchers;\n \n import org.fest.assertions.Assertions;\n public class CapturingMatcherTest extends TestBase {\n \n     @Test\n-    public void shouldCaptureArguments() throws Exception {\n+    public void should_capture_arguments() throws Exception {\n         //given\n         CapturingMatcher m = new CapturingMatcher();\n         \n     }\n     \n     @Test\n-    public void shouldKnowLastCapturedValue() throws Exception {\n+    public void should_know_last_captured_value() throws Exception {\n         //given\n         CapturingMatcher m = new CapturingMatcher();\n         \n     }\n     \n     @Test\n-    public void shouldScreamWhenNothingYetCaptured() throws Exception {\n+    public void should_scream_when_nothing_yet_captured() throws Exception {\n         //given\n         CapturingMatcher m = new CapturingMatcher();\n \n--- a/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n+++ b/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n \n     @SuppressWarnings(\"deprecation\")\n     @Test\n-    public void shouldAllowAssertionsOnCapturedArgument() {\n+    public void should_allow_assertions_on_captured_argument() {\n         //when\n         emailer.email(12);\n         \n     }\n     \n     @Test\n-    public void shouldAllowAssertionsOnAllCapturedArguments() {\n+    public void should_allow_assertions_on_all_captured_arguments() {\n         //when\n         emailer.email(11, 12);\n         \n     }\n     \n     @Test\n-    public void shouldAllowAssertionsOnLastArgument() {\n+    public void should_allow_assertions_on_last_argument() {\n         //when\n         emailer.email(11, 12, 13);\n         \n     }\n     \n     @Test\n-    public void shouldPrintCaptorMatcher() {\n+    public void should_print_captor_matcher() {\n         //given\n         ArgumentCaptor<Person> person = ArgumentCaptor.forClass(Person.class);\n         \n     }\n     \n     @Test\n-    public void shouldAllowAssertionsOnCapturedNull() {\n+    public void should_allow_assertions_on_captured_null() {\n         //when\n         emailService.sendEmailTo(null);\n         \n     }\n     \n     @Test\n-    public void shouldAllowCapturingForStubbing() {\n+    public void should_allow_capturing_for_stubbing() {\n         //given\n         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\n         when(emailService.sendEmailTo(argument.capture())).thenReturn(false);\n     }\n     \n     @Test\n-    public void shouldCaptureWhenStubbingOnlyWhenEntireInvocationMatches() {\n+    public void should_capture_when_stubbing_only_when_entire_invocation_matches() {\n         //given\n         ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class);\n         when(mock.simpleMethod(argument.capture(), eq(2))).thenReturn(\"blah\");\n     }\n     \n     @Test\n-    public void shouldSaySomethingSmartWhenMisused() {\n+    public void should_say_something_smart_when_misused() {\n         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\n         try {\n             argument.getValue();\n     }\n     \n     @Test\n-    public void shouldCaptureWhenFullArgListMatches() throws Exception {\n+    public void should_capture_when_full_arg_list_matches() throws Exception {\n         //given\n         mock.simpleMethod(\"foo\", 1);\n         mock.simpleMethod(\"bar\", 2);\n     }\n     \n     @Test\n-    public void shouldCaptureIntByCreatingCaptorWithPrimitiveWrapper() {\n+    public void should_capture_int_by_creating_captor_with_primitive_wrapper() {\n         //given\n         IMethods mock = mock(IMethods.class);\n         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(Integer.class);\n     }\n \n     @Test\n-    public void shouldCaptureIntByCreatingCaptorWithPrimitive() throws Exception {\n+    public void should_capture_int_by_creating_captor_with_primitive() throws Exception {\n         //given\n         IMethods mock = mock(IMethods.class);\n         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(int.class);", "timestamp": 1348848664, "metainfo": ""}