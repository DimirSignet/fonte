{"sha": "222c8266ea3029b3ba6b32398f246fe042baa2a9", "log": "Renames deep mocks into deep stubs because only stubbing is supported in 'deep' mode.  --HG-- rename : src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepMocks.java => src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java rename : test/org/mockitousage/stubbing/DeepMockingTest.java => test/org/mockitousage/stubbing/DeepStubbingTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401850", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * <p>\n-     * Example that shows how deep mock works:\n-     * <pre>\n-     *   Foo mock = mock(Foo.class, RETURNS_DEEP_MOCKS);\n+     * Example that shows how deep stub works:\n+     * <pre>\n+     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);\n      *\n      *   // note that we're stubbing a chain of methods here: getBar().getName()\n      *   when(mock.getBar().getName()).thenReturn(\"deep\");\n      *   // note that we're chaining method calls: getBar().getName()\n      *   assertEquals(\"deep\", mock.getBar().getName());\n      * </pre>\n+     * \n+     * <strong>Verification API does not support 'chaining'</strong> so deep stub doesn't change how you do verification.\n      *\n      * <strong>WARNING</strong><p>\n      * This feature should rarely be required for regular clean code! Leave it for legacy code.\n      * <p>\n      * Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>. \n      * <p>\n-     * How deep mocks work internally?\n+     * How deep stub work internally?\n      * <pre>\n      *   //this:\n-     *   Foo mock = mock(Foo.class, RETURNS_DEEP_MOCKS);\n+     *   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);\n      *   when(mock.getBar().getName(), \"deep\");\n      *\n      *   //is equivalent of\n      * This feature will not work when any return type of methods included in the chain cannot be mocked\n      * (for example: is a primitive or a final class). This is because of java type system.   \n      */\n-    public static final Answer<Object> RETURNS_DEEP_MOCKS = new ReturnsDeepMocks();\n+    public static final Answer<Object> RETURNS_DEEP_STUBS = new ReturnsDeepStubs();\n \n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+/*\n+ * Copyright (c) 2009 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.Mockito;\n+import org.mockito.internal.MockHandlerInterface;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.util.MockCreationValidator;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n+    private static final long serialVersionUID = -6926328908792880098L;\n+    \n+    private Answer<Object> delegate = new ReturnsEmptyValues();\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        Class<?> clz = invocation.getMethod().getReturnType();\n+        if (!new MockCreationValidator().isTypeMockable(clz))\n+            return delegate.answer(invocation);\n+        return getMock(invocation);\n+    }\n+\n+    private Object getMock(InvocationOnMock invocation) {\n+        Class<?> clz = invocation.getMethod().getReturnType();\n+        final Object mock = Mockito.mock(clz, this);\n+\n+        MockHandlerInterface<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+        InvocationContainerImpl container = (InvocationContainerImpl)handler.getInvocationContainer();\n+        container.addAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return mock;\n+            }\n+        }, false);\n+\n+        return mock;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/DeepStubbingTest.java\n+/*\n+ * Copyright (c) 2009 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.mockito.BDDMockito.*;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+\n+import javax.net.SocketFactory;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class DeepStubbingTest extends TestBase {\n+\n+    static class Person {\n+        Address address;\n+\n+        public Address getAddress() {\n+            return address;\n+        }\n+        \n+        public FinalClass getFinalClass() {\n+            return null;\n+        }\n+    }\n+    \n+    static class Address {\n+        Street street;\n+\n+        public Street getStreet() {\n+            return street;\n+        }\n+    }\n+    \n+    static class Street {\n+        String name;\n+\n+        public String getName() {\n+            return name;\n+        }\n+    }    \n+    \n+    static final class FinalClass {};    \n+    \n+    @Test\n+    public void myTest() throws Exception {\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), eq(80))).thenReturn(null);\n+        sf.createSocket(\"what\", 80);\n+    }\n+\n+    @Test\n+    public void simpleCase() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+        Socket socket = mock(Socket.class);\n+        when(socket.getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, socket.getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing works for one intermediate level\n+     */\n+    @Test\n+    public void oneLevelDeep() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+\n+        SocketFactory socketFactory = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(socketFactory.createSocket().getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, socketFactory.createSocket().getOutputStream());\n+    }\n+\n+    /**\n+     * Test that stubbing of two mocks stubs don't interfere\n+     */\n+    @Test\n+    public void interactions() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf1 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf1.createSocket().getOutputStream()).thenReturn(out1);\n+\n+        SocketFactory sf2 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf2.createSocket().getOutputStream()).thenReturn(out2);\n+\n+        assertSame(out1, sf1.createSocket().getOutputStream());\n+        assertSame(out2, sf2.createSocket().getOutputStream());\n+    }\n+\n+    /**\n+     * Test that stubbing of methods of different arguments don't interfere\n+     */\n+    @Test\n+    public void withArguments() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+        OutputStream out3 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket().getOutputStream()).thenReturn(out1);\n+        when(sf.createSocket(\"google.com\", 80).getOutputStream()).thenReturn(out2);\n+        when(sf.createSocket(\"stackoverflow.com\", 80).getOutputStream()).thenReturn(out3);\n+\n+        assertSame(out1, sf.createSocket().getOutputStream());\n+        assertSame(out2, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out3, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with argument patterns\n+     */\n+    @Test\n+    public void withAnyPatternArguments() throws Exception {\n+        OutputStream out = new ByteArrayOutputStream();\n+\n+        //TODO: should not use javax in case it changes\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);\n+\n+        assertSame(out, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with argument patterns\n+     */\n+    @Test\n+    public void withComplexPatternArguments() throws Exception {\n+        OutputStream out1 = new ByteArrayOutputStream();\n+        OutputStream out2 = new ByteArrayOutputStream();\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(anyString(), eq(80)).getOutputStream()).thenReturn(out1);\n+        when(sf.createSocket(anyString(), eq(8080)).getOutputStream()).thenReturn(out2);\n+\n+        assertSame(out2, sf.createSocket(\"stackoverflow.com\", 8080).getOutputStream());\n+        assertSame(out1, sf.createSocket(\"google.com\", 80).getOutputStream());\n+        assertSame(out2, sf.createSocket(\"google.com\", 8080).getOutputStream());\n+        assertSame(out1, sf.createSocket(\"stackoverflow.com\", 80).getOutputStream());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with primitive expected values\n+     */\n+    @Test\n+    public void withSimplePrimitive() throws Exception {\n+        int a = 32;\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket().getPort()).thenReturn(a);\n+\n+        assertEquals(a, sf.createSocket().getPort());\n+    }\n+\n+    /**\n+     * Test that deep stubbing work with primitive expected values with\n+     * pattern method arguments\n+     */\n+    @Test\n+    public void withPatternPrimitive() throws Exception {\n+        int a = 12, b = 23, c = 34;\n+\n+        SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);\n+        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(80)).getPort()).thenReturn(a);\n+        when(sf.createSocket(eq(\"google.com\"), anyInt()).getPort()).thenReturn(b);\n+        when(sf.createSocket(eq(\"stackoverflow.com\"), eq(8080)).getPort()).thenReturn(c);\n+\n+        assertEquals(b, sf.createSocket(\"google.com\", 80).getPort());\n+        assertEquals(c, sf.createSocket(\"stackoverflow.com\", 8080).getPort());\n+        assertEquals(a, sf.createSocket(\"stackoverflow.com\", 80).getPort());\n+    }\n+    \n+    Person person = mock(Person.class, RETURNS_DEEP_STUBS);\n+       \n+    @Test\n+    public void shouldStubbingBasicallyWorkFine() throws Exception {\n+        //given\n+        given(person.getAddress().getStreet().getName()).willReturn(\"Norymberska\");\n+        \n+        //when\n+        String street = person.getAddress().getStreet().getName();\n+        \n+        //then\n+        assertEquals(\"Norymberska\", street);\n+    }    \n+    \n+    @Test\n+    public void shouldVerificationBasicallyWorkFine() throws Exception {\n+        //given\n+        person.getAddress().getStreet().getName();\n+        \n+        //then\n+        verify(person.getAddress().getStreet()).getName();\n+    }   \n+    \n+    @Test\n+    public void shouldFailGracefullyWhenClassIsFinal() throws Exception {\n+        //when        \n+        FinalClass value = new FinalClass();\n+        given(person.getFinalClass()).willReturn(value);\n+        \n+        //then\n+        assertEquals(value, person.getFinalClass());\n+    }\n+}", "timestamp": 1266182828, "metainfo": ""}