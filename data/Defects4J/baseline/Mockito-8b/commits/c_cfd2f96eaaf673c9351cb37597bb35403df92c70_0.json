{"sha": "cfd2f96eaaf673c9351cb37597bb35403df92c70", "log": "Document the code", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import org.mockito.cglib.proxy.Factory;\n import java.io.Serializable;\n import java.lang.reflect.Method;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n \n  *\n  * <p>\n  *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},\n- *     if the mock settings is set to be serializable it will add the {@link AcrossJVMMockitoMockSerilizable} interface.\n- *     This interface defines a the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerilizable#writeReplace()}\n+ *     if the mock settings is set to be serializable it will add the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable} interface.\n+ *     This interface defines a the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n  *     whose signature match the one that is looked by the standard Java serialization.\n  * </p>\n  *\n  *     knowledge on how to serialize a mockito mock that is based on CGLIB.\n  * </p>\n  *\n- * <p><strong>Only one instance per mock.</strong></p>\n- *\n- * not thread-safe prototype !!!!\n+ * <p><strong>Only one instance per mock! See {@link MethodInterceptorFilter}</strong></p>\n+ *\n+ * TODO Use (and create) MockitoMock interface to identify a Mockito mock\n+ * TODO Document external related classes\n+ * TODO Use a constant for the class annotation marker\n+ * TODO Use proper MockitoException\n+ * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n+ * TODO place Mockito mock identification logic in MockUtil\n+ * TODO check the class is mockable in the deserialization side\n  *\n  * @author Brice Dutheil\n+ * @since 1.9.6\n  */\n public class AcrossJVMSerializationFeature implements Serializable {\n     private static final long serialVersionUID = 7411152578314420778L;\n-    private boolean currentlySerializing = false;\n-    volatile AtomicInteger returningProxyCounter = new AtomicInteger(0);\n-    volatile AtomicInteger returningWrapperCounter = new AtomicInteger(0);\n+    private boolean instanceLocalCurrentlySerializingFlag = false;\n     private Lock mutex = new ReentrantLock();\n \n     public boolean isWriteReplace(Method method) {\n     }\n \n \n-    public Object writeReplace(Object proxy) throws ObjectStreamException {\n+    /**\n+     * Custom implementation of the <code>writeReplace</code> method for serialization.\n+     *\n+     * Here's how it's working and why :\n+     * <ol>\n+     *     <li>\n+     *         <p>When first entering in this method, it's because some is serializing the mock, with some code like :\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     objectOutputStream.writeObject(mock);\n+     * </code></pre>\n+     *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and\n+     *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.\n+     *         At this point, the code will return an {@link AcrossJVMMockSerializationProxy}.</p>\n+     *     </li>\n+     *     <li>\n+     *         <p>Now, in the constructor {@link AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n+     *         the mock is being serialized in a custom way (using {@link MockitoMockObjectOutputStream}) to a\n+     *         byte array. So basically it means the code is performing double nested serialization of the passed\n+     *         <code>mockitoMock</code>.</p>\n+     *\n+     *         <p>However the <code>ObjectOutputStream</code> will still detect the custom\n+     *         <code>writeReplace</code> and execute it.\n+     *         <em>(For that matter disabling replacement via {@link ObjectOutputStream#enableReplaceObject(boolean)}\n+     *         doesn't disable the <code>writeReplace</code> call, but just just toggle replacement in the\n+     *         written stream, <strong><code>writeReplace</code> is always called by\n+     *         <code>ObjectOutputStream</code></strong>.)</em></p>\n+     *\n+     *         <p>In order to avoid this recursion, obviously leading to a {@link StackOverflowError}, this method is using\n+     *         a flag that marks the mock as already being replaced, and then shouldn't replace itself again.\n+     *         <strong>This flag is local to this class</strong>, which means the flag of this class unfortunately needs\n+     *         to be protected against concurrent access, hence the reentrant lock.</p>\n+     *     </li>\n+     * </ol>\n+     *\n+     *\n+     * @param mockitoMock The Mockito mock to be serialized.\n+     * @return A wrapper ({@link AcrossJVMMockSerializationProxy}) to be serialized by the calling ObjectOutputStream.\n+     * @throws ObjectStreamException\n+     */\n+    public Object writeReplace(Object mockitoMock) throws ObjectStreamException {\n         try {\n+            // reentrant lock for critical section. could it be improved ?\n             mutex.lock();\n             // mark started flag // per thread, not per instance\n             // temporary loosy hack to avoid stackoverflow\n-            if(isCurrentlySerializing()) {\n-                System.out.println(\"[\" + returningProxyCounter.getAndIncrement() + \"] retuning proxy\");\n-                return proxy;\n-            }\n-            markMockAsSerializing();\n-\n-            System.out.println(\"[\" + returningWrapperCounter.getAndIncrement() + \"] returning wrapper\");\n-\n-            return new AcrossJVMMockSerializationProxy(proxy);         // stackoverflow\n+            if(mockIsCurrentlyBeingReplaced()) {\n+                return mockitoMock;\n+            }\n+            mockReplacementStarted();\n+\n+            return new AcrossJVMMockSerializationProxy(mockitoMock);\n         } catch (IOException ioe) {\n-            throw new NotSerializableException(proxy.getClass().getCanonicalName()); // TODO throw our own serialization exception\n+            throw new NotSerializableException(mockitoMock.getClass().getCanonicalName()); // TODO throw our own serialization exception\n         } finally {\n             // unmark\n-            unmarkMockAsSerializing();\n+            mockReplacementCompleted();\n             mutex.unlock();\n         }\n     }\n \n-    private void unmarkMockAsSerializing() {\n-        currentlySerializing = false;\n-    }\n-\n-    private void markMockAsSerializing() {\n-        currentlySerializing = true;\n-    }\n-\n-    private boolean isCurrentlySerializing() {\n-        return currentlySerializing;\n-    }\n-\n-\n+    private void mockReplacementCompleted() {\n+        instanceLocalCurrentlySerializingFlag = false;\n+    }\n+\n+    private void mockReplacementStarted() {\n+        instanceLocalCurrentlySerializingFlag = true;\n+    }\n+\n+    private boolean mockIsCurrentlyBeingReplaced() {\n+        return instanceLocalCurrentlySerializingFlag;\n+    }\n+\n+    /**\n+     * Enable serialization serialization that will work across classloaders / and JVM.\n+     *\n+     * <p>Only enable if settings says the mock should be serializable. In this case add the\n+     * {@link AcrossJVMMockitoMockSerializable} to the extra interface list.</p>\n+     *\n+     * @param settings Mock creation settings.\n+     * @param <T> Type param to not be bothered by the generics\n+     */\n     public <T> void enableSerializationAcrossJVM(MockCreationSettings<T> settings) {\n-        // havin faith that this set is modifiable\n         if (settings.isSerializable()) {\n-            settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerilizable.class);\n-        }\n-    }\n-\n-\n-    /**\n-     * This is the serialization proxy that will encapsulate the real mock data.\n-     *\n-     * It will allow deserilization of the mock in another classloader/vm through custom deserilization ObjectInputStream\n+            // havin faith that this set is modifiable\n+            // TODO use a proper way to add the interface\n+            settings.getExtraInterfaces().add(AcrossJVMMockitoMockSerializable.class);\n+        }\n+    }\n+\n+\n+    /**\n+     * This is the serialization proxy that will encapsulate the real mock data as a byte array.\n+     *\n+     * <p>When called in the constructor it will serialize the mock in a byte array using a\n+     * custom {@link MockitoMockObjectOutputStream} that will annotate the mock class in the stream.\n+     * other information are used in this class in order to facilitate deserialization.\n+     * </p>\n+     *\n+     * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via\n+     * the custom {@link MockitoMockObjectInputStream} that will be in charge of creating the mock class.</p>\n      */\n     public static class AcrossJVMMockSerializationProxy implements Serializable {\n         private static final long serialVersionUID = -7600267929109286514L;\n         private Class typeToMock;\n         private Set<Class> extraInterfaces;\n \n-\n-        public AcrossJVMMockSerializationProxy(Object proxy) throws IOException {\n-            MockCreationSettings mockSettings = new MockUtil().getMockHandler(proxy).getMockSettings();\n-\n+        /**\n+         * Creates the wrapper that be used in the serialization stream.\n+         *\n+         * <p>Immediately serializes the Mockito mock using specifically crafted {@link MockitoMockObjectOutputStream},\n+         * in a byte array.</p>\n+         *\n+         * @param mockitoMock The Mockito mock to serialize.\n+         * @throws IOException\n+         */\n+        public AcrossJVMMockSerializationProxy(Object mockitoMock) throws IOException {\n             ByteArrayOutputStream out = new ByteArrayOutputStream();\n             ObjectOutputStream objectOutputStream = new MockitoMockObjectOutputStream(out);\n \n-            objectOutputStream.writeObject(proxy);\n+            objectOutputStream.writeObject(mockitoMock);\n \n             objectOutputStream.close();\n             out.close();\n \n+            MockCreationSettings mockSettings = new MockUtil().getMockHandler(mockitoMock).getMockSettings();\n             this.serializedMock = out.toByteArray();\n             this.typeToMock = mockSettings.getTypeToMock();\n             this.extraInterfaces = mockSettings.getExtraInterfaces();\n         }\n \n \n+        /**\n+         * Resolves the proxy to a new deserialized instance of the Mockito mock.\n+         *\n+         * <p>Uses the custom crafted {@link MockitoMockObjectInputStream} to deserialize the mock.</p>\n+         *\n+         * @return A deserialized instance of the Mockito mock.\n+         * @throws ObjectStreamException\n+         */\n         private Object readResolve() throws ObjectStreamException {\n             try {\n                 ByteArrayInputStream bis = new ByteArrayInputStream(serializedMock);\n-                ObjectInputStream mockitoMockObjectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);\n-\n-                Object object = mockitoMockObjectInputStream.readObject();\n+                ObjectInputStream objectInputStream = new MockitoMockObjectInputStream(bis, typeToMock, extraInterfaces);\n+\n+                Object deserializedMock = objectInputStream.readObject();\n \n                 bis.close();\n-                mockitoMockObjectInputStream.close();\n-                return object;\n+                objectInputStream.close();\n+\n+                return deserializedMock;\n             } catch (IOException ioe) {\n                 throw new InvalidObjectException(\"For some reason mock cannot ve dematerialized : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n             } catch (ClassNotFoundException cce) {\n     }\n \n \n-\n+    /**\n+     * Special Mockito aware <code>ObjectInputStream</code> that will resolve the Mockito proxy class.\n+     *\n+     * <p>\n+     *     This specificaly crafted ObjectInoutStream has the most important role to resolve the Mockito generated\n+     *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream\n+     *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it\n+     *     delegates class resolution to the default super behavior.\n+     *     The mirror method used for serializing the mock is {@link MockitoMockObjectOutputStream#annotateClass(Class)}.\n+     * </p>\n+     *\n+     * <p>\n+     *     When this marker is found, {@link ClassImposterizer} methods are being used to create the mock class.\n+     *     <em>Note that behind the <code>ClassImposterizer</code> there is CGLIB and the\n+     *     {@link org.mockito.internal.creation.jmock.SearchingClassLoader} that will look if this enhanced class has\n+     *     already been created in an accessible classloader ; so basically this code trusts the ClassImposterizer\n+     *     code.</em>\n+     * </p>\n+     */\n     public static class MockitoMockObjectInputStream extends ObjectInputStream {\n         private Class typeToMock;\n         private Set<Class> extraInterfaces;\n             super(in) ;\n             this.typeToMock = typeToMock;\n             this.extraInterfaces = extraInterfaces;\n-            enableResolveObject(true);\n-        }\n-\n+            enableResolveObject(true); // ensure resolving is enabled\n+        }\n+\n+        /**\n+         * Resolve the Mockito proxy class if it is marked as such.\n+         *\n+         * <p>Uses the fields {@link #typeToMock} and {@link #extraInterfaces} to\n+         * create the Mockito proxy class as the <code>ObjectStreamClass</code>\n+         * doesn't carry useful information for this purpose.</p>\n+         *\n+         * @param desc Description of the class in the stream, not used.\n+         * @return The class that will be used to deserialize the instance mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n         @Override\n         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            Object anObject = readObject();\n-            if (\"MockitoProxyMarker\".equals(anObject)) {\n-                ClassImposterizer.INSTANCE.canImposterise(typeToMock);\n-                ClassImposterizer.INSTANCE.setConstructorsAccessible(typeToMock, true);\n-                Class<?> proxyClass = ClassImposterizer.INSTANCE.createProxyClass(\n-                        typeToMock,\n-                        extraInterfaces.toArray(new Class[extraInterfaces.size()])\n-                );\n-\n-                try {\n-                    new FieldSetter(desc, desc.getClass().getDeclaredField(\"name\")).set(proxyClass.getCanonicalName());\n-                } catch (NoSuchFieldException e) {\n-                    e.printStackTrace();\n-                }\n-\n-                return proxyClass;\n-            }\n-\n-            return super.resolveClass(desc);\n-        }\n-    }\n-\n-\n-\n-\n-    public interface AcrossJVMMockitoMockSerilizable {\n-        public Object writeReplace() throws java.io.ObjectStreamException;\n-    }\n-\n-\n+            if (notMarkedAsAMockitoMock(readObject())) {\n+                return super.resolveClass(desc);\n+            }\n+\n+            // TODO check the class is mockable in the deserialization side\n+            ClassImposterizer.INSTANCE.canImposterise(typeToMock);\n+\n+            // create the Mockito mock class before it can even be deserialized\n+            ClassImposterizer.INSTANCE.setConstructorsAccessible(typeToMock, true);\n+            Class<?> proxyClass = ClassImposterizer.INSTANCE.createProxyClass(\n+                    typeToMock,\n+                    extraInterfaces.toArray(new Class[extraInterfaces.size()])\n+            );\n+\n+            hackClassNameToMatchNewlyCreatedClass(desc, proxyClass);\n+\n+            return proxyClass;\n+\n+        }\n+\n+        /**\n+         * Hack the <code>name</code> field of the given <code>ObjectStreamClass</code> with\n+         * the <code>newProxyClass</code>.\n+         *\n+         * The parent ObjectInputStream will check the name of the class in the stream matches the name of the one\n+         * that is created in this method.\n+         *\n+         * The CGLIB classes uses a hash of the classloader and/or maybe some other data that allow them to be\n+         * relatively unique in a JVM.\n+         *\n+         * When names differ, which happens when the mock is deserialized in another ClassLoader, a\n+         * <code>java.io.InvalidObjectException</code> is thrown, so this part of the code is hacking through\n+         * the given <code>ObjectStreamClass</code> to change the name with the newly created class.\n+         *\n+         * @param desc The <code>ObjectStreamClass</code> that will be hacked.\n+         * @param proxyClass The proxy class whose name will be applied.\n+         * @throws InvalidObjectException\n+         */\n+        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass desc, Class<?> proxyClass) throws InvalidObjectException {\n+            try {\n+                new FieldSetter(desc, desc.getClass().getDeclaredField(\"name\")).set(proxyClass.getCanonicalName());\n+            } catch (NoSuchFieldException e) {\n+                throw new InvalidObjectException(\"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name', this is definitely a bug, in our code, please report used JDK, eventually code sample.\\n\" + e.toString());\n+            }\n+        }\n+\n+        /**\n+         * Read the stream class annotation and identify it as a Mockito mock or not.\n+         *\n+         * @param marker The marker to identify.\n+         * @return <code>true</code> if not marked as a Mockito, <code>false</code> if the class annotation marks a Mockito mock.\n+         * @throws IOException\n+         * @throws ClassNotFoundException\n+         */\n+        private boolean notMarkedAsAMockitoMock(Object marker) throws IOException, ClassNotFoundException {\n+            return !\"MockitoProxyMarker\".equals(marker);\n+        }\n+    }\n+\n+\n+    /**\n+     * Special Mockito aware <code>ObjectOutputStream</code>.\n+     *\n+     * <p>\n+     *     This output stream has the role of marking in the stream the Mockito class. This\n+     *     marking process is necessary to identify the proxy class that will need to be recreated.\n+     *\n+     *     The mirror method used for deserializing the mock is\n+     *     {@link MockitoMockObjectInputStream#resolveClass(ObjectStreamClass)}.\n+     * </p>\n+     *\n+     */\n     private static class MockitoMockObjectOutputStream extends ObjectOutputStream {\n         public MockitoMockObjectOutputStream(ByteArrayOutputStream out) throws IOException {\n             super(out);\n         }\n \n+        /**\n+         * Annotates (marks) the class if this class is a Mockito mock.\n+         *\n+         * @param cl The class to annotate.\n+         * @throws IOException\n+         */\n         @Override\n         protected void annotateClass(Class<?> cl) throws IOException {\n+            writeObject(mockitoProxyClassMarker(cl));\n+            // might be also useful later, for embedding classloader info ...maybe ...maybe not\n+        }\n+\n+        /**\n+         * Returns the Mockito marker if this class is a Mockito mock.\n+         *\n+         * @param cl The class to mark.\n+         * @return The marker if this is a Mockito proxy class, otherwise returns a void marker.\n+         */\n+        private String mockitoProxyClassMarker(Class<?> cl) {\n+            // TODO place logic in MockUtil\n             if (Factory.class.isAssignableFrom(cl)) {\n-                writeObject(\"MockitoProxyMarker\");\n+                return \"MockitoProxyMarker\";\n             } else {\n-                writeObject(\"\");\n-            }\n-            // might be also useful later, for embedding classloader info maybe\n-        }\n+                return \"\";\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an\n+     * <code>ObjectOutputStream</code>.\n+     *\n+     * It will be applied before the creation of the mock when the mock setting says it should serializable.\n+     *\n+     * @see #enableSerializationAcrossJVM(org.mockito.mock.MockCreationSettings)\n+     */\n+    public interface AcrossJVMMockitoMockSerializable {\n+        public Object writeReplace() throws java.io.ObjectStreamException;\n     }\n }\n--- a/test/org/mockitousage/serialization/ParallelSerializationTest.java\n+++ b/test/org/mockitousage/serialization/ParallelSerializationTest.java\n \n public class ParallelSerializationTest {\n \n-    ExecutorService executorService = Executors.newFixedThreadPool(200);\n-\n-\n     @Test\n     public void single_mock_being_serialized_and_deserialized_in_different_classloaders_by_multiple_threads() throws ExecutionException, InterruptedException {\n+        // given\n+        int iterations = 2;\n+        int threadingFactor = 200;\n+        final ExecutorService executorService = Executors.newFixedThreadPool(threadingFactor);\n         final IMethods iMethods = mock(IMethods.class, withSettings().serializable());\n \n-        int iterations = 1;\n-        int threadingFactor = 100;\n-\n+        // when\n         for (int i = 0; i <= iterations; i++) {\n             List<Future> futures = new ArrayList<Future>(threadingFactor);\n-            final CyclicBarrier barrier = new CyclicBarrier(threadingFactor);\n+            final CyclicBarrier barrier_that_will_wait_until_threads_are_ready = new CyclicBarrier(threadingFactor);\n \n+            // prepare all threads by submitting a callable\n+            //  - that will serialize the mock a 'threadingFactor' times\n+            //  - that will use the mock a 'threadingFactor' times\n             for (int j = 0; j < threadingFactor; j++) {\n-                final int finalJ = j;\n+                // submit a callable that will serialize the mock 'iMethods'\n                 futures.add(executorService.submit(new Callable<Object>() {\n                     public Object call() throws Exception {\n-                        System.out.println(\"[\" + finalJ + \"] waiting here\");\n-                        barrier.await();\n-                        System.out.println(\"[\" + finalJ + \"] serializing now\");\n+                        barrier_that_will_wait_until_threads_are_ready.await();\n                         iMethods.arrayReturningMethod();\n-                        return read_stream_and_deserialize_it_in_class_loader_B(SimpleSerializationUtil.serializeMock(iMethods).toByteArray());\n+\n+                        byte[] mockBytes = SimpleSerializationUtil.serializeMock(iMethods).toByteArray();\n+                        return read_stream_and_deserialize_it_in_class_loader_B(mockBytes);\n                     }\n                 }));\n+\n+                // submit a callable that will only use the mock 'iMethods'\n                 executorService.submit(new Callable<Object>() {\n                     public Object call() throws Exception {\n-                        barrier.await();\n+                        barrier_that_will_wait_until_threads_are_ready.await();\n                         return iMethods.longObjectReturningMethod();\n                     }\n                 });\n             }\n+\n+            // ensure we are getting the futures\n             for (Future future : futures) {\n                 future.get();\n             }", "timestamp": 1355610962, "metainfo": ""}