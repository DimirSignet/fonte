{"sha": "2ad8beb52d28d6f93d03d0367a536f1039f8f1f3", "log": "fixing the message of the exceptions", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n public class AcrossJVMSerializationFeature implements Serializable {\n     private static final long serialVersionUID = 7411152578314420778L;\n     private static final String MOCKITO_PROXY_MARKER = \"MockitoProxyMarker\";\n-    private final MockUtil mockUtil = new MockUtil();\n     private boolean instanceLocalCurrentlySerializingFlag = false;\n     private Lock mutex = new ReentrantLock();\n \n \n             return new AcrossJVMMockSerializationProxy(mockitoMock);\n         } catch (IOException ioe) {\n+            MockUtil mockUtil = new MockUtil();\n             MockName mockName = mockUtil.getMockName(mockitoMock);\n             String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();\n             throw new MockitoSerializationIssue(join(\n                     \"The mock '\" + mockName + \"' of type '\" + mockedType + \"'\",\n-                    \"The Java Standard Serialization reported an '\" + ioe.getClass().getSimpleName() + \"' saying : \" + ioe.getMessage()\n+                    \"The Java Standard Serialization reported an '\" + ioe.getClass().getSimpleName() + \"' saying :\",\n+                    \"  \" + ioe.getMessage()\n             ), ioe);\n         } finally {\n             // unmark\n                 return deserializedMock;\n             } catch (IOException ioe) {\n                 throw new MockitoSerializationIssue(join(\n-                        \"Mockito mock cannot be deserialized to a mock of '\" + typeToMock.getCanonicalName() + \"'.\",\n+                        \"Mockito mock cannot be deserialized to a mock of '\" + typeToMock.getCanonicalName() + \"'. The error was :\",\n+                        \"  \" + ioe.getMessage(),\n                         \"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n                 ), ioe);\n             } catch (ClassNotFoundException cce) {\n                 throw new MockitoSerializationIssue(join(\n-                        \"A class couldn't be found while deserializing a Mockito mock, you should check your classpath.\",\n+                        \"A class couldn't be found while deserializing a Mockito mock, you should check your classpath. The error was :\",\n+                        \"  \" + cce.getMessage(),\n                         \"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n                 ), cce);\n             }\n             try {\n               Field classNameField = descInstance.getClass().getDeclaredField(\"name\");\n               new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());\n-            } catch (NoSuchFieldException e) {\n+            } catch (NoSuchFieldException nsfe) {\n                 // TODO use our own mockito mock serialization exception\n                 throw new MockitoSerializationIssue(join(\n                         \"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',\",\n                         \"this is definitely a bug in our code as it means the JDK team changed a few internal things.\",\n                         \"\",\n                         \"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome.\"\n-                ), e);\n+                ), nsfe);\n             }\n         }\n \n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n             SimpleSerializationUtil.serializeAndBack(mockWithPrivateConstructor);\n         } catch (ObjectStreamException e) {\n             // then\n-            Assertions.assertThat(e.getMessage()).contains(\"no valid constructor\");\n+            Assertions.assertThat(e.toString()).contains(\"no valid constructor\");\n         }\n     }\n ", "timestamp": 1357322410, "metainfo": ""}