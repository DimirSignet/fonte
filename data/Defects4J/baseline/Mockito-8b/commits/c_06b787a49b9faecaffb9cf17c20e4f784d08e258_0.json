{"sha": "06b787a49b9faecaffb9cf17c20e4f784d08e258", "log": "refactorings around exceptions reporting  --HG-- rename : src/org/mockito/exceptions/VerificationAssertionError.java => src/org/mockito/exceptions/VerificationError.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4095", "commit": "\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n  * and amend the text.\n  */\n public class Exceptions {\n+    \n+    private static String join(String ... linesToBreak) {\n+        StringBuilder out = new StringBuilder(\"\\n\");\n+        for (String line : linesToBreak) {\n+            out.append(line).append(\"\\n\");\n+        }\n+        int lastBreak = out.lastIndexOf(\"\\n\");\n+        return out.replace(lastBreak, lastBreak+1, \"\").toString();\n+    }\n \n     public static void mocksHaveToBePassedAsArguments() {\n         throw new MockitoException(join(\n         \n     }\n     \n-    private static String join(String ... linesToBreak) {\n-        StringBuilder out = new StringBuilder(\"\\n\");\n-        for (String line : linesToBreak) {\n-            out.append(line).append(\"\\n\");\n-        }\n-        int lastBreak = out.lastIndexOf(\"\\n\");\n-        return out.replace(lastBreak, lastBreak+1, \"\").toString();\n+    public static void wantedInvocationDiffersFromActual(String wanted, String actual, String message) {\n+        throw new VerificationError(join(\n+                    message,\n+                    \"Wanted: \" + wanted,\n+                    \"Actual: \" + actual\n+                ));\n+    }\n+\n+    public static void wantedButNotInvoked(String wanted) {\n+        throw new VerificationError(join(\n+                    \"Wanted but not invoked:\",\n+                    wanted        \n+        ));\n     }\n }\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n  */\n package org.mockito.exceptions;\n \n-import org.mockito.internal.ExpectedInvocation;\n \n public class NumberOfInvocationsAssertionError extends MockitoAssertionError {\n \n     private static final long serialVersionUID = 1L;\n \n-    public NumberOfInvocationsAssertionError(int expectedCount, int actualCount, ExpectedInvocation expected) {\n+    public NumberOfInvocationsAssertionError(int expectedCount, int actualCount, String wanted) {\n         super(  \"\\n\" +\n-                expected.toString() +\n+                wanted +\n         \t\t\"\\n\" +\n         \t\t\"Expected \" + pluralize(expectedCount) + \" but was \" + actualCount);\n     }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/VerificationError.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.exceptions;\n+\n+public class VerificationError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public VerificationError(String message) {\n+        super(message);\n+    }\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     }\n \n     public void verify(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n+        checkOrderOfInvocations(expected, verifyingMode);\n         checkForMissingInvocation(expected, verifyingMode);\n-        checkOrderOfInvocations(expected, verifyingMode);\n         checkForWrongNumberOfInvocations(expected, verifyingMode);        \n         registeredInvocations.markInvocationsAsVerified(expected, verifyingMode);\n     }\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n         \n         if (!atLeastOnce && actuallyInvoked != expectedInvoked) {\n-            throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, expected);\n+            throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, expected.toString());\n         }\n     }\n \n-    private void reportMissingInvocationError(ExpectedInvocation invocation) throws VerificationAssertionError {\n-        //TODO refactor message building somewhere else...\n-        Invocation similarInvocation = registeredInvocations.findSimilarInvocation(invocation);\n+    private void reportMissingInvocationError(ExpectedInvocation wanted) throws VerificationError {\n+        Invocation actual = registeredInvocations.findSimilarInvocation(wanted);\n         \n-        String message = null;\n-        String expected = invocation.toString();\n-        if (similarInvocation != null) {\n-            String actual = similarInvocation.toString();\n-            if (expected.equals(actual)) {\n-                expected = invocation.getInvocation().toStringWithArgumentTypes();\n-                actual = similarInvocation.toStringWithArgumentTypes();\n-            }\n-            \n-            message = \n-                    \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\" +\n-                    \"Expected: \" + expected +\n-                    \"\\n\" +\n-            \t\t\"Actual:   \" + actual;\n+        if (actual != null) {\n+            reportDiscrepancy(wanted, actual, \"Invocation differs from actual\");\n         } else {\n-            message = \n-                    \"\\n\" +\n-                    \"Expected but not invoked:\" +\n-                    \"\\n\" +    \n-                    expected;\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+    }\n+\n+    private void reportDiscrepancy(ExpectedInvocation wantedInvocation, Invocation actualInvocation, String message) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        if (wanted.equals(actual)) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n         }\n         \n-        throw new VerificationAssertionError(message);\n+        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, message);\n     }\n \n-    private void checkOrderOfInvocations(ExpectedInvocation expected, VerifyingMode mode) {\n+    private void checkOrderOfInvocations(ExpectedInvocation wanted, VerifyingMode mode) {\n         if (!mode.orderOfInvocationsMatters()) {\n             return;\n         }\n         \n         List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n         \n-        if (mode.expectedCountIsZero() && !chunks.isEmpty() && expected.matches(chunks.get(0).getInvocation())) {\n-            throw new NumberOfInvocationsAssertionError(0, chunks.get(0).getCount(), expected);\n+        if (mode.expectedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n+            throw new NumberOfInvocationsAssertionError(0, chunks.get(0).getCount(), wanted.toString());\n         } else if (mode.expectedCountIsZero()) {\n             return;\n         }\n         \n         if (chunks.isEmpty()) {\n-            throw new StrictVerificationError(\"everything was already verified\");\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n         }\n         \n-        if (!expected.matches(chunks.get(0).getInvocation())) {\n-            throw new StrictVerificationError(\"this is not expected here\");\n+        if (!wanted.matches(chunks.get(0).getInvocation())) {\n+            reportDiscrepancy(wanted, chunks.get(0).getInvocation(), \"Strict order verification failed\");\n         }\n         \n         if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.expectedCount()) {\n-            throw new NumberOfInvocationsAssertionError(mode.expectedCount(), chunks.get(0).getCount(), expected);\n+//            Exceptions.numberOfInvocationsDiffers();\n+            throw new NumberOfInvocationsAssertionError(mode.expectedCount(), chunks.get(0).getCount(), wanted.toString());\n         }\n     }\n \n         Invocation unverified = registeredInvocations.getFirstUnverified();\n         if (unverified != null) {\n             String mockName = Namer.nameForMock(mock);\n-            throw new VerificationAssertionError(\n+            throw new VerificationError(\n                     \"\\n\" +\n                     verificationErrorMessage + \" on \" + mockName +\n                     \"\\n\" +\n--- a/test/org/mockito/usage/InvalidUsageTest.java\n+++ b/test/org/mockito/usage/InvalidUsageTest.java\n \n     @Ignore\n     @Test\n-    public void unfinishedStubbingDetectedMockCalled() {\n+    public void unfinishedStubbingDetectedWhenMockCalled() {\n         stub(mock.add(\"test\"));\n \n         try {\n--- a/test/org/mockito/usage/StackTrackeFilteringTest.java\n+++ b/test/org/mockito/usage/StackTrackeFilteringTest.java\n         try {\n             verify(mock).simpleMethod();\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerify\"));\n         }\n     }\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n         }\n     }\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n         }\n     }\n         try {\n             strictly.verify(mock).oneArg(false); \n             fail();\n-        } catch (StrictVerificationError expected) {\n+        } catch (VerificationError expected) {\n             assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n         }\n     }\n     \n     @Ignore\n     @Test\n-    public void shouldNotAllowSettingInvalidCheckedException() {\n+    public void shouldFilterStackTraceWhenThrowingExceptionFromControl() {\n         try {\n             stub(mock.oneArg(true)).andThrows(new Exception());\n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldNotAllowSettingInvalidCheckedException\"));\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnThrowingExceptionFromControl\"));\n         }\n     }\n }\n--- a/test/org/mockito/usage/UsingVarargsTest.java\n+++ b/test/org/mockito/usage/UsingVarargsTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n \n public class UsingVarargsTest {\n \n         try {\n             verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n \n     @Test\n         try {\n             verify(mock).withBooleanVarargs(3, true, true, true, true);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n }\n--- a/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n import static org.junit.Assert.*;\n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n \n public class IncorectBindingPuzzleFixedTest {\n \n         try {\n             Mockito.verify(derivedMock).print(message);\n             fail();\n-        } catch (VerificationAssertionError error) {\n+        } catch (VerificationError error) {\n             String expected = \n                 \"\\n\" +\n         \t\t\"Invocation differs from actual\" +\n         \t\t\"\\n\" +\n-        \t\t\"Expected: DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$Message)\" +\n+        \t\t\"Wanted: DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$Message)\" +\n         \t\t\"\\n\" +\n-        \t\t\"Actual:   DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$BaseMessage)\";\n+        \t\t\"Actual: DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$BaseMessage)\";\n             \n             assertEquals(expected, error.getMessage());\n         }\n--- a/test/org/mockito/usage/matchers/BasicStubbingTest.java\n+++ b/test/org/mockito/usage/matchers/BasicStubbingTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicStubbingTest {\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n }\n--- a/test/org/mockito/usage/verification/AtLeastOnceVerificationTest.java\n+++ b/test/org/mockito/usage/verification/AtLeastOnceVerificationTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n public class AtLeastOnceVerificationTest {\n         try {\n             verify(mockTwo, atLeastOnce()).add(\"foo\");\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n-    @Test(expected=VerificationAssertionError.class)\n+    @Test(expected=VerificationError.class)\n     public void shouldFailIfMethodWasNotCalledAtAll() throws Exception {\n         verify(mock, atLeastOnce()).add(\"foo\");\n     }\n--- a/test/org/mockito/usage/verification/BasicVerificationTest.java\n+++ b/test/org/mockito/usage/verification/BasicVerificationTest.java\n         verifyNoMoreInteractions(mock);\n     }\n \n-    @Test(expected=VerificationAssertionError.class)\n+    @Test(expected=VerificationError.class)\n     public void shouldFailVerification() throws Exception {\n         verify(mock).clear();\n     }\n         try {\n             verify(mock).add(\"bar\");\n             fail();\n-        } catch (VerificationAssertionError expected) {};\n+        } catch (VerificationError expected) {};\n     }\n \n-    @Ignore\n     @Test\n-    public void shouldLetVerifyTheSameMethodAnyTimes() throws Exception {\n+    public void shouldFailOnWrongMethod() throws Exception {\n         mock.clear();\n         mock.clear();\n         \n         try {\n             verify(mockTwo, atLeastOnce()).add(\"foo\");\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n \n     @Test\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError expected) {};\n+        } catch (VerificationError expected) {};\n     }\n     \n     @Test\n--- /dev/null\n+++ b/test/org/mockito/usage/verification/NiceMessagesOnStrictOrderErrorsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.usage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.VerificationError;\n+import org.mockito.usage.IMethods;\n+\n+public class NiceMessagesOnStrictOrderErrorsTest {\n+    \n+    private IMethods one;\n+    private IMethods two;\n+    private IMethods three;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setup() {\n+        one = Mockito.mock(IMethods.class);\n+        two = Mockito.mock(IMethods.class);\n+        three = Mockito.mock(IMethods.class);\n+        \n+        one.simpleMethod(1);\n+        one.simpleMethod(11);\n+        two.simpleMethod(2);\n+        two.simpleMethod(2);\n+        three.simpleMethod();\n+        \n+        strictly = createStrictOrderVerifier(one, two, three);\n+    }\n+    \n+    @Test\n+    public void shouldPrintStrictVerificationError() {\n+        try {\n+            strictly.verify(one).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Strict order verification failed\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods.simpleMethod(999)\" + \n+            \t\t\"\\n\" +\n+            \t\t\"Actual: IMethods.simpleMethod(1)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintWantedMethodWhenEverythingElseIsVerified() {\n+        strictly.verify(one).simpleMethod(1);\n+        strictly.verify(one).simpleMethod(11);\n+        strictly.verify(two, 2).simpleMethod(2);\n+        strictly.verify(three).simpleMethod();\n+        try {\n+            strictly.verify(three).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(999)\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }   \n+}\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n \n import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n import org.mockito.usage.IMethods;\n \n public class NiceMessagesWhenVerificationFailsTest {\n         try {\n             verify(mock).simpleMethod();\n             fail();\n-        } catch (VerificationAssertionError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                    \"\\n\" +\n-            \t\t\"Expected but not invoked:\" +\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"Wanted but not invoked:\" +\n             \t\t\"\\n\" +\n             \t\t\"IMethods.simpleMethod()\";\n             assertEquals(expectedMessage, actualMessage);         \n         try {\n             verify(mock).threeArgumentMethod(12, new SomeClass(), \"some string\");\n             fail();\n-        } catch (VerificationAssertionError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                    \"\\n\" +\n-                    \"Expected but not invoked:\" +\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n                     \"\\n\" +\n             \t\t\"IMethods.threeArgumentMethod(12, SomeClass instance, \\\"some string\\\")\";\n             assertEquals(expectedMessage, actualMessage);         \n         try {\n             verify(mock).twoArgumentMethod(1,2);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                    \"\\n\" +\n-                    \"Expected but not invoked:\" +\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n                     \"\\n\" +\n                     \"IMethods.twoArgumentMethod(1, 2)\";\n             \n         try {\n             verify(mock).twoArgumentMethod(1, 1000);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n                     \"\\n\" +\n-                    \"Expected: IMethods.twoArgumentMethod(1, 1000)\" +\n-                    \"\\n\" +\n-                    \"Actual:   IMethods.twoArgumentMethod(1, 2)\";\n+                    \"Wanted: IMethods.twoArgumentMethod(1, 1000)\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods.twoArgumentMethod(1, 2)\";\n             \n             assertEquals(expectedMessage, actualMessage);         \n         }\n         try {\n             verify(mock).simpleMethod(\"test\");\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n                     \"\\n\" +\n-                    \"Expected: IMethods.simpleMethod(\\\"test\\\")\" +\n-                    \"\\n\" +\n-                    \"Actual:   IMethods.simpleMethod()\";\n+                    \"Wanted: IMethods.simpleMethod(\\\"test\\\")\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods.simpleMethod()\";\n             \n             assertEquals(expectedMessage, actualMessage);         \n         }\n         try {\n             verify(mock).twoArgumentMethod(3, 1000);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n                     \"Invocation differs from actual\" +\n                     \"\\n\" +\n-                    \"Expected: IMethods.twoArgumentMethod(3, 1000)\" +\n-                    \"\\n\" +\n-                    \"Actual:   IMethods.twoArgumentMethod(3, 3)\";\n+                    \"Wanted: IMethods.twoArgumentMethod(3, 1000)\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods.twoArgumentMethod(3, 3)\";\n             \n             assertEquals(expectedMessage, actualMessage);         \n         }\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n+        } catch (VerificationError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n         try {\n             verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);\n             fail();\n-        } catch (VerificationAssertionError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                \"\\n\" +\n-                \"Expected but not invoked:\" +\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                \"\\n\" +\n+                \"Wanted but not invoked:\" +\n                 \"\\n\" +\n                 \"IMethods.twoArgumentMethod(1, 2)\";\n             assertEquals(expectedMessage, actualMessage);         \n         try {\n             verify(mock, atLeastOnce()).twoArgumentMethod(anyInt(), eq(100));\n             fail();\n-        } catch (VerificationAssertionError expected) {\n-            String actualMessage = expected.getMessage();\n-            String expectedMessage = \n-                \"\\n\" +\n-                \"Expected but not invoked:\" +\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                \"\\n\" +\n+                \"Wanted but not invoked:\" +\n                 \"\\n\" +\n                 \"IMethods.twoArgumentMethod(<any>, 100)\";\n             assertEquals(expectedMessage, actualMessage);         \n--- a/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n import java.util.*;\n \n import org.junit.Test;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n \n @SuppressWarnings(\"unchecked\")\n public class NoMoreInteractionsVerificationTest {\n         try {\n             verifyZeroInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError e) {\n+        } catch (VerificationError e) {\n             //cool\n         }\n     }\n         try {\n             verifyNoMoreInteractions(mock);\n             fail();\n-        } catch (VerificationAssertionError e) {\n+        } catch (VerificationError e) {\n             //cool\n         }\n     }\n         try {\n             verifyZeroInteractions(map);\n             fail();\n-        } catch (VerificationAssertionError e) {\n+        } catch (VerificationError e) {\n             //cool\n         }\n     }\n--- a/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockThree).simpleMethod(3);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockThree).simpleMethod(4);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test(expected=MockitoException.class)\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n         try {\n             strictly.verify(mockOne).simpleMethod(1);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test(expected=NumberOfInvocationsAssertionError.class)\n     \n     /* ------------- */\n     \n-    @Test(expected=VerificationAssertionError.class)\n+    @Test(expected=VerificationError.class)\n     public void shouldFailOnFirstMethodBecauseDifferentArgsExpected() {\n         strictly.verify(mockOne).simpleMethod(100);\n     }\n     \n-    @Test(expected=VerificationAssertionError.class)\n+    @Test(expected=VerificationError.class)\n     public void shouldFailOnFirstMethodBecauseDifferentMethodExpected() {\n         strictly.verify(mockOne).oneArg(true);\n     }\n         try {\n             strictly.verify(mockTwo, 2).simpleMethod(-999);\n             fail();\n-        } catch (StrictVerificationError e) {}\n-        //TODO those guys need tests around nice messages from exceptions and it's quite inconsistent\n-        //when StrictVerificationError and when VerificationAssertionError is fired\n-        //algorithm should be as follows:\n-        //  1. check if according to order: mock and method matches -> StrictVerificationError\n-        //  2. check method arguments -> VerificationAssertionError\n-        //  3. check invocation count -> NumberOfInvocationsAssertionError\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, 2).oneArg(true);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(-666);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).oneArg(false);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }    \n     \n     /* -------------- */\n     \n-    @Test(expected = StrictVerificationError.class)\n+    @Test(expected = VerificationError.class)\n     public void shouldFailWhenLastMethodCalledFirst() {\n         strictly.verify(mockOne).simpleMethod(4);\n     }\n     \n-    @Test(expected = StrictVerificationError.class)\n+    @Test(expected = VerificationError.class)\n     public void shouldFailWhenSecondMethodCalledFirst() {\n         strictly.verify(mockTwo, 2).simpleMethod(2);\n     }\n         try {\n             strictly.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, 1).simpleMethod(2);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne).simpleMethod(4);\n             fail();\n-        } catch (StrictVerificationError e) {}\n+        } catch (VerificationError e) {}\n     }\n     \n     @Test\n         try {\n             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n             fail();\n-        } catch (VerificationAssertionError e) {}\n-    } \n-    \n-    @Test(expected=VerificationAssertionError.class)\n+        } catch (VerificationError e) {}\n+    } \n+    \n+    @Test(expected=VerificationError.class)\n     public void shouldFailOnVerifyZeroInteractions() {\n         verifyZeroInteractions(mockOne);\n     }\n--- a/test/org/mockito/usage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockito/usage/verification/VerificationUsingMatchersTest.java\n \n import org.junit.*;\n import org.mockito.*;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.VerificationError;\n import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         try {\n             verify(mock).oneArg(CrazyMatchers.same(three));\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n     }  \n     \n     @Test\n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n \n         mock.threeArgumentMethod(8, new Object(), \"01234\");\n         \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"no match\");\n \n         try {\n             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n             fail();\n-        } catch (VerificationAssertionError e) {}\n+        } catch (VerificationError e) {}\n         \n         mock.threeArgumentMethod(8, \"\", \"123\");\n         ", "timestamp": 1196374543, "metainfo": ""}