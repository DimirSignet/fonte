{"sha": "b7b9c5cf1f8210713434255e8c8274d29eef4032", "log": "Added location of unfinished stubbing. Some refactoring in MockitoHandler  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401299", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n     }\n     \n-    public void unfinishedStubbing() {\n+    public void unfinishedStubbing(Location location) {\n         throw new UnfinishedStubbingException(join(\n-                \"Unfinished stubbing detected!\",\n+                \"Unfinished stubbing detected here:\",\n+                \"-> at \" + location,\n+                \"\",\n                 \"E.g. thenReturn() may be missing.\",\n                 \"Examples of correct stubbing:\",\n                 \"    when(mock.isOk()).thenReturn(true);\",\n                 \"    when(mock.isOk()).thenThrow(exception);\",\n                 \"    doThrow(exception).when(mock).someVoidMethod();\",\n                 \"Hints:\",\n-                \" 1. missing thenReturn() or mock call inside when()\",\n-                \" 2. stubbed method cannot be final.\",\n-                \" 3. although stubbed methods may return mocks, you cannot inline a mock() call inside a thenReturn method (see issue 53)\"\n+                \" 1. missing thenReturn()\",\n+                \" 2. although stubbed methods may return mocks, you cannot inline a mock() call inside a thenReturn method (see issue 53)\"\n         ));\n     }\n \n     public void wantedButNotInvoked(PrintableInvocation wanted) {\n         throw new WantedButNotInvoked(join(\n                     \"Wanted but not invoked:\",\n-                    wanted.toString()\n+                    wanted.toString(),\n+                    \"-> at \" + new Location(),\n+                    \"\"\n         ));\n     }\n     \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n-import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n-import org.mockito.internal.progress.NewOngoingStubbing;\n import org.mockito.internal.progress.SequenceNumber;\n-import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.MockitoStubber;\n-import org.mockito.internal.stubbing.Returns;\n-import org.mockito.internal.stubbing.ThrowsException;\n+import org.mockito.internal.stubbing.OngoingStubbingImpl;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n import org.mockito.internal.util.MockName;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.RegisteredInvocations;\n  */\n public class MockHandler<T> implements MockAwareInterceptor<T> {\n \n-    private final RegisteredInvocations registeredInvocations;\n-    private final MockitoStubber mockitoStubber;\n+    final RegisteredInvocations registeredInvocations;\n+    final MockitoStubber mockitoStubber;\n     private final MatchersBinder matchersBinder;\n     private final MockingProgress mockingProgress;\n     private final MockName mockName;\n             return null;\n         }\n \n-        mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n+        mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher, ongoingStubbing);\n         registeredInvocations.add(invocationMatcher.getInvocation());\n \n-        mockingProgress.reportOngoingStubbing(new OngoingStubbingImpl());\n-\n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n+        //TODO remove - should be part of reportOngoingStubbing\n         if (!invocation.isVoid() && answer == null) {\n             //it is a return-value interaction but not stubbed. This *might* be a problem\n             mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n     }\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n-        return new VoidMethodStubbableImpl(mock);\n+        return new VoidMethodStubbableImpl<T>(mock, mockitoStubber);\n     }\n \n     public void setInstance(T instance) {\n         return mockName;\n     }\n \n-    private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n-        private final T mock;\n-\n-        public VoidMethodStubbableImpl(T mock) {\n-            this.mock = mock;\n-        }\n-\n-        public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n-            mockitoStubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n-            return this;\n-        }\n-\n-        public VoidMethodStubbable<T> toReturn() {\n-            mockitoStubber.addAnswerForVoidMethod(new DoesNothing());\n-            return this;\n-        }\n-\n-        public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n-            mockitoStubber.addAnswerForVoidMethod(answer);\n-            return this;\n-        }\n-\n-        public T on() {\n-            return mock;\n-        }\n-    }\n-\n-    private abstract class BaseStubbing implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n-        public NewOngoingStubbing<T> thenReturn(T value) {\n-            return thenAnswer(new Returns(value));\n-        }\n-\n-        public NewOngoingStubbing<T> thenReturn(T value, T... values) {\n-            NewOngoingStubbing<T> stubbing = thenReturn(value);            \n-            if (values == null) {\n-                return stubbing.thenReturn(null);\n-            }\n-            for (T v: values) {\n-                stubbing = stubbing.thenReturn(v);\n-            }\n-            return stubbing;\n-        }\n-\n-        private NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n-            return thenAnswer(new ThrowsException(throwable));\n-        }\n-\n-        public NewOngoingStubbing<T> thenThrow(Throwable... throwables) {\n-            if (throwables == null) {\n-                thenThrow((Throwable) null);\n-            }\n-            NewOngoingStubbing<T> stubbing = null;\n-            for (Throwable t: throwables) {\n-                if (stubbing == null) {\n-                    stubbing = thenThrow(t);                    \n-                } else {\n-                    stubbing = stubbing.thenThrow(t);\n-                }\n-            }\n-            return stubbing;\n-        }        \n-\n-        public DeprecatedOngoingStubbing<T> toReturn(T value) {\n-            return toAnswer(new Returns(value));\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n-            return toAnswer(new ThrowsException(throwable));\n-        }\n-    }\n-    \n-    private class OngoingStubbingImpl extends BaseStubbing {\n-        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n-            registeredInvocations.removeLast();\n-            mockitoStubber.addAnswer(answer);\n-            return new ConsecutiveStubbing();\n-        }\n-\n-        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            registeredInvocations.removeLast();\n-            mockitoStubber.addAnswer(answer);\n-            return new ConsecutiveStubbing();\n-        }\n-    }\n-\n-    private class ConsecutiveStubbing extends BaseStubbing {\n-        public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n-            mockitoStubber.addConsecutiveAnswer(answer);\n-            return this;\n-        }\n-        \n-        public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n-            mockitoStubber.addConsecutiveAnswer(answer);\n-            return this;\n-        }\n-    }    \n-    \n     @SuppressWarnings(\"unchecked\")\n     public void setAnswersForStubbing(List<Answer> answers) {\n         mockitoStubber.setAnswersForStubbing(answers);\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n     private final List<InvocationMatcher> unstubbedInvocations = new LinkedList<InvocationMatcher>();\n \n     private boolean collectingData;\n+    private Invocation lastInvocation;\n \n     public void addStubbedInvocation(Invocation invocation) {\n         if (!collectingData) {\n     }\n \n     public void addPotentiallyUnstubbed(InvocationMatcher invocationMatcher) {\n+        this.lastInvocation = invocationMatcher.getInvocation();\n         if (!collectingData) {\n             return;\n         }\n     public boolean hasData() {\n         return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n     }\n+\n+    public Location getLastInvocationLocation() {\n+        return lastInvocation == null ? null : lastInvocation.getLocation();\n+    }\n }\n--- a/src/org/mockito/internal/debugging/Location.java\n+++ b/src/org/mockito/internal/debugging/Location.java\n         this.firstTraceElement = filter.filterStackTrace(stackTrace)[0];\n     }\n \n+    public Location(StackTraceElement firstTraceElement) {\n+        this.firstTraceElement = firstTraceElement;\n+    }\n+\n     @Override\n     public String toString() {\n         return this.firstTraceElement.toString();\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         return verifiedInOrder;\n     }\n     \n+    //TODO this needs to go away\n     public HasStackTrace getStackTrace() {\n         return stackTrace;\n     }\n     public boolean returnsPrimitive() {\n         return method.getReturnType().isPrimitive();\n     }\n+\n+    public Location getLocation() {\n+        return new Location(getStackTrace().getStackTrace()[0]);\n+    }\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n         \n         if (stubbingInProgress) {\n             stubbingInProgress = false;\n-            reporter.unfinishedStubbing();\n+            reporter.unfinishedStubbing(debuggingInfo.getLastInvocationLocation());\n         }\n       \n         getArgumentMatcherStorage().validateState();\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/BaseStubbing.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+\n+public abstract class BaseStubbing<T> implements NewOngoingStubbing<T>, DeprecatedOngoingStubbing<T> {\n+    public NewOngoingStubbing<T> thenReturn(T value) {\n+        return thenAnswer(new Returns(value));\n+    }\n+\n+    public NewOngoingStubbing<T> thenReturn(T value, T... values) {\n+        NewOngoingStubbing<T> stubbing = thenReturn(value);            \n+        if (values == null) {\n+            return stubbing.thenReturn(null);\n+        }\n+        for (T v: values) {\n+            stubbing = stubbing.thenReturn(v);\n+        }\n+        return stubbing;\n+    }\n+\n+    private NewOngoingStubbing<T> thenThrow(Throwable throwable) {\n+        return thenAnswer(new ThrowsException(throwable));\n+    }\n+\n+    public NewOngoingStubbing<T> thenThrow(Throwable... throwables) {\n+        if (throwables == null) {\n+            thenThrow((Throwable) null);\n+        }\n+        NewOngoingStubbing<T> stubbing = null;\n+        for (Throwable t: throwables) {\n+            if (stubbing == null) {\n+                stubbing = thenThrow(t);                    \n+            } else {\n+                stubbing = stubbing.thenThrow(t);\n+            }\n+        }\n+        return stubbing;\n+    }        \n+\n+    public DeprecatedOngoingStubbing<T> toReturn(T value) {\n+        return toAnswer(new Returns(value));\n+    }\n+\n+    public DeprecatedOngoingStubbing<T> toThrow(Throwable throwable) {\n+        return toAnswer(new ThrowsException(throwable));\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/ConsecutiveStubbing.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.stubbing.Answer;\n+\n+public class ConsecutiveStubbing<T> extends BaseStubbing<T> {\n+    \n+    private final MockitoStubber mockitoStubber;\n+\n+    public ConsecutiveStubbing(MockitoStubber mockitoStubber) {\n+        this.mockitoStubber = mockitoStubber;\n+    }\n+\n+    public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+        mockitoStubber.addConsecutiveAnswer(answer);\n+        return this;\n+    }\n+    \n+    public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+        mockitoStubber.addConsecutiveAnswer(answer);\n+        return this;\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.stubbing.Answer;\n \n @SuppressWarnings(\"unchecked\")\n         this.mockingProgress = mockingProgress;\n     }\n \n-    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n+    public void setInvocationForPotentialStubbing(InvocationMatcher invocation, OngoingStubbing ongoingStubbing) {\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n         this.invocationForStubbing = invocation;\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/OngoingStubbingImpl.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n+import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.internal.verification.RegisteredInvocations;\n+import org.mockito.stubbing.Answer;\n+\n+public class OngoingStubbingImpl<T> extends BaseStubbing<T> {\n+    \n+    private final MockitoStubber mockitoStubber;\n+    private final RegisteredInvocations registeredInvocations;\n+\n+    public OngoingStubbingImpl(MockitoStubber mockitoStubber, RegisteredInvocations registeredInvocations) {\n+        this.mockitoStubber = mockitoStubber;\n+        this.registeredInvocations = registeredInvocations;\n+    }\n+\n+    public NewOngoingStubbing<T> thenAnswer(Answer<?> answer) {\n+        registeredInvocations.removeLast();\n+        mockitoStubber.addAnswer(answer);\n+        return new ConsecutiveStubbing<T>(mockitoStubber);\n+    }\n+\n+    public DeprecatedOngoingStubbing<T> toAnswer(Answer<?> answer) {\n+        registeredInvocations.removeLast();\n+        mockitoStubber.addAnswer(answer);\n+        return new ConsecutiveStubbing<T>(mockitoStubber);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbableImpl.java\n+/**\n+ * \n+ */\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.stubbing.Answer;\n+\n+public class VoidMethodStubbableImpl<T> implements VoidMethodStubbable<T> {\n+\n+    private final T mock;\n+    private final MockitoStubber mockitoStubber;\n+\n+    public VoidMethodStubbableImpl(T mock, MockitoStubber mockitoStubber) {\n+        this.mock = mock;\n+        this.mockitoStubber = mockitoStubber;\n+    }\n+\n+    public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n+        mockitoStubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n+        return this;\n+    }\n+\n+    public VoidMethodStubbable<T> toReturn() {\n+        mockitoStubber.addAnswerForVoidMethod(new DoesNothing());\n+        return this;\n+    }\n+\n+    public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n+        mockitoStubber.addAnswerForVoidMethod(answer);\n+        return this;\n+    }\n+\n+    public T on() {\n+        return mock;\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n         state = new MockingProgressImpl();\n         \n         mockitoStubber = new MockitoStubber(state);\n-        mockitoStubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher(), null);\n         \n         simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n     }\n     \n     @Test\n     public void shouldGetResultsForMethods() throws Throwable {\n-        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod), null);\n         mockitoStubber.addAnswer(new Returns(\"simpleMethod\"));\n         \n         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n-        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n+        mockitoStubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod), null);\n         mockitoStubber.addAnswer(new ThrowsException(new MyException()));\n         \n         assertEquals(\"simpleMethod\", mockitoStubber.answerTo(simpleMethod));\n--- a/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n+++ b/test/org/mockitousage/stacktrace/ClickableStackTracesWhenFrameworkMisusedTest.java\n import org.mockito.Mock;\n import org.mockito.StateMaster;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n         StateMaster.reset();\n     }\n     \n-    private void misplacedArgumentMatcher() {\n+    private void misplacedArgumentMatcherHere() {\n         anyString();\n     }\n \n     @Test\n     public void shouldPointOutMisplacedMatcher() {\n-        misplacedArgumentMatcher();\n+        misplacedArgumentMatcherHere();\n         try {\n             verify(mock).simpleMethod();\n             fail();\n         } catch (InvalidUseOfMatchersException e) {\n             assertThat(e, messageContains(\"-> at \"));\n-            assertThat(e, messageContains(\"misplacedArgumentMatcher(\"));\n+            assertThat(e, messageContains(\"misplacedArgumentMatcherHere(\"));\n+        }\n+    }\n+\n+    private void unfinishedStubbingHere() {\n+        when(mock.simpleMethod());\n+    }\n+    \n+    @Test\n+    public void shouldPointOutUnfinishedStubbing() {\n+        unfinishedStubbingHere();\n+        \n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (UnfinishedStubbingException e) {\n+            assertThat(e, messageContains(\"-> at \"));\n+            assertThat(e, messageContains(\"unfinishedStubbingHere(\"));\n         }\n     }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n-                    \"iMethods.differentMethod();\"; \n+                    \"iMethods.differentMethod();\" +\n+                    \"\\n\" +\n+                    \"-> at\"; \n             \n-            assertEquals(expected, e.getMessage());\n-            \n-            assertEquals(null, e.getCause());\n+            assertContains(expected, e.getMessage());\n         }\n     } \n     \n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n-                    \"iMethods.simpleMethod();\";\n-            assertEquals(expectedMessage, actualMessage);\n+                    \"iMethods.simpleMethod();\" +\n+                    \"\\n\" +\n+                    \"-> at\";\n+            assertContains(expectedMessage, actualMessage);\n         }\n     }\n \n                 \"Wanted but not invoked:\" +\n                 \"\\n\" +\n                 \"iMethods.twoArgumentMethod(<any>, 100);\";\n-            assertEquals(expectedMessage, actualMessage);\n+            assertContains(expectedMessage, actualMessage);\n         }\n     }\n ", "timestamp": 1238964323, "metainfo": ""}