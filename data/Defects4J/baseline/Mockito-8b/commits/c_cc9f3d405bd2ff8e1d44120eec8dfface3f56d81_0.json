{"sha": "cc9f3d405bd2ff8e1d44120eec8dfface3f56d81", "log": "changed the way mocks work. Now the default verification is once() instead of anyTimes(). BTW anyTimes is not yet implemented :>  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4062", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n \n+    public final static VerifyingMode anyTimes = VerifyingMode.anyTimes();\n+    \n+    public static VerifyingMode anyTimes() {\n+        return anyTimes;\n+    }\n+    \n     public static <T> T mock(Class<T> classToMock) {\n         MockFactory<T> proxyFactory = new MockFactory<T>();\n         MockControl<T> mockControl = new MockControl<T>(MockitoState.instance(), LastArguments.instance());\n         return verify(mock, VerifyingMode.anyTimes());\n     }\n     \n-    public static <T> T verify(T mock, int exactNumberOfInvocations) {\n-        return verify(mock, VerifyingMode.times(exactNumberOfInvocations));\n+    public static <T> T verify(T mock, int expectedNumberOfInvocations) {\n+        return verify(mock, VerifyingMode.times(expectedNumberOfInvocations));\n     }\n     \n     //TODO should not be public\n         return mock;\n     }\n \n+\t/**\n+\t * <pre>\n+\t * Throws an AssertionError if any of given mocks has any unverified interaction.\n+     * \n+     * Use this method after you verified all your mocks - to make sure that nothing \n+     * else was invoked on your mocks.\n+     * \n+     * It's a good pattern not to use this method in every test method.\n+     * Sometimes test method focuses on different behavior/interaction \n+     * and it's not necessary to call verifyNoMoreInteractions()\n+     * \n+     * Stubbed invocations are also treated as interactions.\n+     * \n+     * Example:\n+\t * \n+\t *    <code>\n+\t *         //interactions\n+\t *         mock.doSomething();\n+\t *         mock.doSomethingUnexpected();\n+\t *         \n+\t *         //verification\n+\t *         verify(mock).doSomething();\n+\t *         \n+\t *         //throws error: 'doSomethingUnexpected()' is unexpected\n+\t *         verifyNoMoreInteractions(mock);\n+\t *    </code>\n+\t *</pre>\n+\t *\n+\t * @param mocks\n+\t */\n \tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n \t    MockitoState.instance().checkForUnfinishedVerification();\n \t    for (Object mock : mocks) {\n--- a/src/org/mockito/MockitoExperimental.java\n+++ b/src/org/mockito/MockitoExperimental.java\n         return verify(mock);\n     }\n \n-    public static <T> T assertInvoked(T mock, int exactNumberOfInvocations) {\n-        return verify(mock, exactNumberOfInvocations);\n+    public static <T> T assertInvoked(T mock, int expectedNumberOfInvocations) {\n+        return verify(mock, expectedNumberOfInvocations);\n     }\n     \n     public static void assertNoMoreInteractions(Object ... mocks) {\n         return new WasInvokedMatcher<T>(mock);\n     }\n     \n-    public static <T> MockitoMatcher<T> wasInvoked(T mock, int exactNumberOfInvocations) {\n-        return new WasInvokedMatcher<T>(mock, exactNumberOfInvocations);\n+    public static <T> MockitoMatcher<T> wasInvoked(T mock, int expectedNumberOfInvocations) {\n+        return new WasInvokedMatcher<T>(mock, expectedNumberOfInvocations);\n     }\n     \n     public static <T> MockitoMatcher<T> noMoreInteractions(T mock) {\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n package org.mockito.exceptions;\n \n import org.mockito.internal.InvocationWithMatchers;\n-\n \n public class NumberOfInvocationsAssertionError extends MockitoAssertionError {\n \n--- a/src/org/mockito/hamcrest/WasInvokedMatcher.java\n+++ b/src/org/mockito/hamcrest/WasInvokedMatcher.java\n \n public class WasInvokedMatcher<T> extends BaseMatcher<T> implements MockitoMatcher<T> {\n     private final T mock;\n-    private final int exactNumberOfInvocations;\n+    private final int expectedNumberOfInvocations;\n \n     public WasInvokedMatcher(T mock) {\n         this(mock, -1);\n     }\n     \n-    public WasInvokedMatcher(T mock, int exactNumberOfInvocations) {\n+    public WasInvokedMatcher(T mock, int expectedNumberOfInvocations) {\n         this.mock = mock;\n-        this.exactNumberOfInvocations = exactNumberOfInvocations;\n+        this.expectedNumberOfInvocations = expectedNumberOfInvocations;\n     }\n \n     public boolean matches(Object arg0) {\n         return mock;\n     }\n \n-    public int getExactNumberOfInvocations() {\n-        return exactNumberOfInvocations;\n+    public int getExpectedNumberOfInvocations() {\n+        return expectedNumberOfInvocations;\n     }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n     public void verify(InvocationWithMatchers invocation, VerifyingMode verifyingMode) {\n         int actuallyInvoked = numberOfActualInvocations(invocation);\n-        \n-        if (verifyingMode.numberOfInvocationsMatters()) {\n-            int expectedInvoked = verifyingMode.getExactNumberOfInvocations();\n+        int expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n+               \n+        if (expectedInvoked == 1 && actuallyInvoked == 0) {\n+            //TODO this stuff is really hacked in, refactor, add more testing\n+            InvocationWithMatchers similarInvocation = findSimilarInvocation(invocation);\n+            String message = \n+                \"\\n\" +\n+                \"Invocation differs from actual\" +\n+                \"\\n\";\n             \n-            if (actuallyInvoked != expectedInvoked) {\n-                throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, invocation);\n-            } \n-        } else {\n-            if (actuallyInvoked == 0) {\n-                //TODO this stuff is really hacked in, refactor, add more testing\n-                InvocationWithMatchers similarInvocation = findSimilarInvocation(invocation);\n-                String message = \n-                    \"\\n\" +\n-                    \"Invocation differs from actual\" +\n-                    \"\\n\";\n-                \n-                String expected = invocation.toString();\n-                if (similarInvocation != null) {\n-                    String actual = similarInvocation.toString();\n-                    if (expected.equals(actual)) {\n-                        expected = invocation.toStringWithArgumentTypes();\n-                        actual = similarInvocation.toStringWithArgumentTypes();\n-                    }\n-                    \n-                    message += \n-                            \"Expected: \" + expected +\n-                            \"\\n\" +\n-                    \t\t\"Actual:   \" + actual;\n-                } else {\n-                    message = \n-                            \"\\n\" +\n-                            \"Expected but not invoked:\" +\n-                            \"\\n\" +    \n-                            expected;\n+            String expected = invocation.toString();\n+            if (similarInvocation != null) {\n+                String actual = similarInvocation.toString();\n+                if (expected.equals(actual)) {\n+                    expected = invocation.toStringWithArgumentTypes();\n+                    actual = similarInvocation.toStringWithArgumentTypes();\n                 }\n                 \n-                throw new VerificationAssertionError(message);\n+                message += \n+                        \"Expected: \" + expected +\n+                        \"\\n\" +\n+                \t\t\"Actual:   \" + actual;\n+            } else {\n+                message = \n+                        \"\\n\" +\n+                        \"Expected but not invoked:\" +\n+                        \"\\n\" +    \n+                        expected;\n             }\n+            \n+            throw new VerificationAssertionError(message);\n         }\n+        \n+        if (actuallyInvoked != expectedInvoked) {\n+            throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, invocation);\n+        }\n+\n         \n         if (verifyingMode.orderOfInvocationsMatters()) {\n             checkOrderOfInvocations(invocation, verifyingMode);\n--- a/src/org/mockito/internal/StrictOrderVerifier.java\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n     List<Object> mocks = new LinkedList<Object>();\n     \n     public <T> T verify(T mock) {\n-        return Mockito.verify(mock);\n+        return Mockito.verify(mock, VerifyingMode.inSequence(null, mocks));\n     }\n     \n-    public <T> T verify(T mock, int exactNumberOfInvocations) {\n-        return Mockito.verify(mock, VerifyingMode.inSequence(exactNumberOfInvocations, mocks));\n+    public <T> T verify(T mock, int expectedNumberOfInvocations) {\n+        return Mockito.verify(mock, VerifyingMode.inSequence(expectedNumberOfInvocations, mocks));\n     }\n \n     public void verifyNoMoreInteractions() {\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n \n public class VerifyingMode {\n \n-    private final Integer exactNumberOfInvocations;\n+    private final Integer expectedNumberOfInvocations;\n     private final List<Object> mocksToBeVerifiedInSequence;\n \n-    private VerifyingMode(Integer exactNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n-        if (exactNumberOfInvocations != null && exactNumberOfInvocations.intValue() < 0) {\n+    private VerifyingMode(Integer expectedNumberOfInvocations, List<Object> mocksToBeVerifiedInSequence) {\n+        if (expectedNumberOfInvocations != null && expectedNumberOfInvocations.intValue() < 0) {\n             throw new MockitoException(\"Negative value is not allowed here\");\n         }\n-        this.exactNumberOfInvocations = exactNumberOfInvocations;\n+        this.expectedNumberOfInvocations = expectedNumberOfInvocations;\n         this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n     }\n     \n         return new VerifyingMode(null, Collections.emptyList());\n     }\n \n-    public static VerifyingMode times(int exactNumberOfInvocations) {\n-        return new VerifyingMode(exactNumberOfInvocations, Collections.emptyList());\n+    public static VerifyingMode times(int expectedNumberOfInvocations) {\n+        return new VerifyingMode(expectedNumberOfInvocations, Collections.emptyList());\n     }\n \n     public boolean numberOfInvocationsMatters() {\n-        return exactNumberOfInvocations != null;\n+        return expectedNumberOfInvocations != null;\n     }\n \n-    public int getExactNumberOfInvocations() {\n-        return exactNumberOfInvocations;\n+    public int getExpectedNumberOfInvocations() {\n+        return (expectedNumberOfInvocations==null)? 1 : expectedNumberOfInvocations;\n     }\n \n     public List<Object> getAllMocksToBeVerifiedInSequence() {\n         return mocksToBeVerifiedInSequence;\n     }\n \n-    public static VerifyingMode inSequence(int exactNumberOfInvocations, List<Object> mocks) {\n-        return new VerifyingMode(exactNumberOfInvocations, mocks);\n+    public static VerifyingMode inSequence(Integer expectedNumberOfInvocations, List<Object> mocks) {\n+        return new VerifyingMode(expectedNumberOfInvocations, mocks);\n     }\n \n     public boolean orderOfInvocationsMatters() {\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n     }\n     \n     @Test(expected=NotAMockException.class)\n-    public void shouldValidateMockWhenVerifyingWithExactNumberOfInvocations() {\n+    public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {\n         Mockito.verify(notMock, 19);\n     }\n     \n--- a/test/org/mockito/sample/ArticleCalculator.java\n+++ b/test/org/mockito/sample/ArticleCalculator.java\n public interface ArticleCalculator {\n     int countArticles(String newspaper);\n     int countArticlesInPolish(String newspaper);\n+    int countNumberOfRelatedArticles(Article article);\n }\n--- a/test/org/mockito/sample/ArticleDatabase.java\n+++ b/test/org/mockito/sample/ArticleDatabase.java\n package org.mockito.sample;\n+\n+import java.util.List;\n \n public class ArticleDatabase {\n \n \n     public void updateNumberOfEnglishArticles(String newspaper, int i) {\n     }\n+\n+    public List<Article> getArticlesFor(String string) {\n+        return null;\n+    }\n+\n+    public void save(Article article) {\n+    }\n }\n--- a/test/org/mockito/sample/ArticleManager.java\n+++ b/test/org/mockito/sample/ArticleManager.java\n package org.mockito.sample;\n+\n+import java.util.List;\n \n public class ArticleManager {\n     \n         database.updateNumberOfPolishArticles(newspaper, polishArticles);\n         database.updateNumberOfEnglishArticles(newspaper, articles - polishArticles);\n     }\n+    \n+    public void updateRelatedArticlesCounters(String newspaper) {\n+        List<Article> articles = database.getArticlesFor(\"Guardian\");\n+        for (Article article : articles) {\n+            int numberOfRelatedArticles = calculator.countNumberOfRelatedArticles(article);\n+            article.setNumberOfRelatedArticles(numberOfRelatedArticles);\n+            database.save(article);\n+        }\n+    }\n }\n--- a/test/org/mockito/sample/MockitoSampleTest.java\n+++ b/test/org/mockito/sample/MockitoSampleTest.java\n package org.mockito.sample;\n+import java.util.*;\n+\n import org.junit.Test;\n import org.mockito.Mockito;\n+import static org.mockito.Mockito.*;\n \n public class MockitoSampleTest {\n     \n         \n         ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n \n-        Mockito.stub(mockCalculator.countArticles(\"Guardian\")).andReturn(12);\n-        Mockito.stub(mockCalculator.countArticlesInPolish(\"Guardian\")).andReturn(5);\n+        stub(mockCalculator.countArticles(\"Guardian\")).andReturn(12);\n+        stub(mockCalculator.countArticlesInPolish(\"Guardian\")).andReturn(5);\n         \n         articleManager.updateArticleCounters(\"Guardian\");\n         \n-        Mockito.verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 12);\n-        Mockito.verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 5);\n-        Mockito.verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 7);\n+        verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 12);\n+        verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 5);\n+        verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 7);\n         \n-        Mockito.verifyNoMoreInteractions(mockDatabase);\n+        verifyNoMoreInteractions(mockDatabase);\n     }\n     \n     @Test\n \n         articleManager.updateArticleCounters(\"Guardian\");\n \n-        Mockito.verify(mockCalculator).countArticles(\"Guardian\");\n-        Mockito.verify(mockCalculator).countArticlesInPolish(\"Guardian\");\n+        verify(mockCalculator).countArticles(\"Guardian\");\n+        verify(mockCalculator).countArticlesInPolish(\"Guardian\");\n         \n-        Mockito.verifyNoMoreInteractions(mockCalculator);\n+        verifyNoMoreInteractions(mockCalculator);\n     }\n     \n     @Test\n \n         articleManager.updateArticleCounters(\"Guardian\");\n \n-        Mockito.verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 0);\n-        Mockito.verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 0);\n-        Mockito.verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 0);\n+        verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 0);\n+        verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 0);\n+        verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 0);\n         \n-        Mockito.verifyNoMoreInteractions(mockDatabase);\n+        verifyNoMoreInteractions(mockDatabase);\n+    }\n+    \n+    @Test\n+    public void managerUpdatesNumberOfRelatedArticles() {\n+        ArticleCalculator mockCalculator = Mockito.mock(ArticleCalculator.class);\n+        ArticleDatabase mockDatabase = Mockito.mock(ArticleDatabase.class);\n+        \n+        ArticleManager articleManager = new ArticleManager(mockCalculator, mockDatabase);\n+\n+        Article articleOne = new Article();\n+        Article articleTwo = new Article();\n+        Article articleThree = new Article();\n+        \n+        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).andReturn(1);\n+        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).andReturn(12);\n+        stub(mockCalculator.countNumberOfRelatedArticles(articleOne)).andReturn(0);\n+        \n+        stub(mockDatabase.getArticlesFor(\"Guardian\")).andReturn(Arrays.asList(articleOne, articleTwo, articleThree)); \n+        \n+        articleManager.updateRelatedArticlesCounters(\"Guardian\");\n+\n+        verify(mockDatabase).save(articleOne);\n+        verify(mockDatabase).save(articleTwo);\n+        verify(mockDatabase).save(articleThree);\n     }\n }\n--- a/test/org/mockito/usage/matchers/BasicStubbingTest.java\n+++ b/test/org/mockito/usage/matchers/BasicStubbingTest.java\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n import static org.mockito.util.ExtraMatchers.collectionContaining;\n \n import java.util.*;\n \n-import org.junit.Test;\n+import org.junit.*;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationAssertionError;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicStubbingTest {\n \n+    private DummyInterface mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(DummyInterface.class);\n+    }\n+    \n     private interface DummyInterface {\n         int getInt(String value);\n         String getString(int argumentOne, String argumentTwo);\n     \n     @Test\n     public void shouldStubAllMethodsByDefault() throws Exception {\n-        DummyInterface mock = Mockito.mock(DummyInterface.class);\n-\n         assertEquals(0, mock.getInt(\"test\"));\n         assertEquals(0, mock.getInt(\"testTwo\"));\n         \n     \n     @Test\n     public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n-        DummyInterface mock = Mockito.mock(DummyInterface.class);\n-        \n-        Mockito.stub(mock.getInt(\"14\")).andReturn(14);\n+        stub(mock.getInt(\"14\")).andReturn(14);\n         \n         assertThat(mock.getInt(\"14\"), equalTo(14));\n         assertThat(mock.getInt(\"14\"), equalTo(14));\n         \n-        Mockito.stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n+        stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n         \n         assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n         assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n         \n-        Mockito.stub(mock.getString(10, \"test\")).andReturn(\"test\");\n+        stub(mock.getString(10, \"test\")).andReturn(\"test\");\n         \n         assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n         assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n     }\n+    \n+    @Test\n+    public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n+        mock = Mockito.mock(DummyInterface.class);\n+        \n+        stub(mock.getInt(\"blah\"));\n+        \n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationAssertionError e) {}\n+    }\n }\n--- a/test/org/mockito/usage/verification/BasicVerificationTest.java\n+++ b/test/org/mockito/usage/verification/BasicVerificationTest.java\n package org.mockito.usage.verification;\n \n import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n \n import java.util.*;\n \n-import org.junit.Test;\n+import org.junit.*;\n import org.mockito.Mockito;\n-import org.mockito.exceptions.VerificationAssertionError;\n+import org.mockito.exceptions.*;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicVerificationTest {\n \n-    @Test\n-    public void shouldVerify() throws Exception {\n-        List mock = Mockito.mock(List.class);\n-\n-        mock.clear();\n-        Mockito.verify(mock).clear();\n-\n-        mock.add(\"test\");\n-        Mockito.verify(mock).add(\"test\");\n-\n-        Mockito.verifyNoMoreInteractions(mock);\n+    private List mock;\n+    private List mockTwo;\n+    \n+    @Before public void setup() {\n+        mock = Mockito.mock(List.class);\n+        mockTwo = Mockito.mock(List.class);\n     }\n \n     @Test\n+    public void shouldVerify() throws Exception {\n+        mock.clear();\n+        verify(mock).clear();\n+\n+        mock.add(\"test\");\n+        verify(mock).add(\"test\");\n+\n+        verifyNoMoreInteractions(mock);\n+    }\n+\n+    @Test(expected=VerificationAssertionError.class)\n     public void shouldFailVerification() throws Exception {\n-        List mock = Mockito.mock(List.class);\n+        verify(mock).clear();\n+    }\n \n+    @Test\n+    public void shouldFailVerificationOnMethodArgument() throws Exception {\n+        mock.clear();\n+        mock.add(\"foo\");\n+\n+        verify(mock).clear();\n         try {\n-            Mockito.verify(mock).clear();\n+            verify(mock).add(\"bar\");\n             fail();\n         } catch (VerificationAssertionError expected) {};\n     }\n \n-    @Test\n-    public void shouldFailVerificationOnMethodArgument() throws Exception {\n-        List mock = Mockito.mock(List.class);\n-        mock.clear();\n-        mock.add(\"foo\");\n-\n-        Mockito.verify(mock).clear();\n-        try {\n-            Mockito.verify(mock).add(\"bar\");\n-            fail();\n-        } catch (VerificationAssertionError expected) {};\n-    }\n-\n+    @Ignore\n     @Test\n     public void shouldLetYouVerifyTheSameMethodAnyTimes() throws Exception {\n-        List mock = Mockito.mock(List.class);\n         mock.clear();\n+        mock.clear();\n+        \n+        mockTwo.add(\"add\");\n \n-        Mockito.verify(mock).clear();\n-        Mockito.verify(mock).clear();\n-        Mockito.verify(mock).clear();\n+        verify(mock, anyTimes).clear();\n+        verify(mockTwo, anyTimes).add(\"add\");\n+        try {\n+            verify(mockTwo, anyTimes).add(\"foo\");\n+        } catch (VerificationAssertionError e) {}\n     }\n \n     @Test\n     public void shouldDetectRedundantInvocation() throws Exception {\n-        List mock = Mockito.mock(List.class);\n         mock.clear();\n         mock.add(\"foo\");\n         mock.add(\"bar\");\n \n-        Mockito.verify(mock).clear();\n-        Mockito.verify(mock).add(\"foo\");\n+        verify(mock).clear();\n+        verify(mock).add(\"foo\");\n \n         try {\n-            Mockito.verifyNoMoreInteractions(mock);\n+            verifyNoMoreInteractions(mock);\n             fail();\n         } catch (VerificationAssertionError expected) {};\n     }\n     \n     @Test\n+    public void shouldDetectWhenInvokedMoreThanOnce() throws Exception {\n+        mock.add(\"foo\");\n+        mock.clear();\n+        mock.clear();\n+        \n+        verify(mock).add(\"foo\");\n+\n+        try {\n+            verify(mock).clear();\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {};\n+    }\n+\n+    @Test\n+    public void shouldLetVerifyAnyTimes() throws Exception {\n+        mockTwo.add(\"foo\");\n+        mock.clear();\n+        mock.clear();\n+        \n+        verify(mockTwo, anyTimes).add(\"foo\");\n+\n+        try {\n+            verify(mock).clear();\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {};\n+    }\n+    \n+    @Test\n     public void shouldVerifyStubbedMethods() throws Exception {\n-        LinkedList mock = Mockito.mock(LinkedList.class);\n-        \n-        Mockito.stub(mock.add(\"test\")).andReturn(Boolean.FALSE);\n+        stub(mock.add(\"test\")).andReturn(Boolean.FALSE);\n         \n         mock.add(\"test\");\n         \n-        Mockito.verify(mock).add(\"test\");\n+        verify(mock).add(\"test\");\n     }\n }\n--- a/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n+++ b/test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java\n     }\n     \n     @Test\n+    public void shouldFailWhenExpectedNumberOfInvocationIsZero() throws Exception {\n+        mock.clear();\n+        \n+        try {\n+            Mockito.verify(mock, 0).clear();\n+            fail();\n+        } catch (NumberOfInvocationsAssertionError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyWhenExpectedNumberOfInvocationIsZero() throws Exception {\n+        Mockito.verify(mock, 0).clear();\n+    }\n+    \n+    @Test\n     public void shouldNotCountInStubbedInvocations() throws Exception {\n         Mockito.stub(mock.add(\"test\")).andReturn(false);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n             assertEquals(expectedMessage, actualMessage);         \n         }\n     }\n+    \n+    //TODO do we need nice message when expected number of invocations = 0?\n+    \n }\n--- a/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java\n     }\n     \n     @Test\n-    public void shouldVerifyWhenExactNumberOfInvocationsUsed() throws Exception {\n+    public void shouldVerifyWhenExpectedNumberOfInvocationsUsed() throws Exception {\n         List mock = mock(List.class);\n \n         mock.add(\"one\");\n--- a/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n     public void shouldVerifyInOrder() {\n         strictly.verify(list).add(\"one\");\n         strictly.verify(map).put(\"two\", \"two\");\n-        strictly.verify(list).add(\"three and four\");\n+        strictly.verify(list, 2).add(\"three and four\");\n         strictly.verify(map).put(\"five\", \"five\");\n         strictly.verify(set).add(\"six\");\n     } \n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n     public void shouldVerifyInOrder() {\n         strictly.verify(list).add(\"one\");\n         strictly.verify(map).put(\"two\", \"two\");\n-        strictly.verify(list).add(\"three and four\");\n+        strictly.verify(list, 2).add(\"three and four\");\n         strictly.verify(map).put(\"five\", \"five\");\n         strictly.verify(set).add(\"six\");\n         strictly.verifyNoMoreInteractions();\n     } \n \n-    @Test\n-    public void shouldVerifyInOrderWithExactNumberOfInvocations() {\n-        strictly.verify(list, 1).add(\"one\");\n-        strictly.verify(map).put(\"two\", \"two\");\n-        strictly.verify(list, 2).add(\"three and four\");\n-        strictly.verify(map, 1).put(\"five\", \"five\");\n-        strictly.verify(set, 1).add(\"six\");\n-        strictly.verifyNoMoreInteractions();\n-    }  \n-    \n     @Test(expected = VerificationAssertionError.class)\n     public void shouldFailOnOrdinaryVerificationError() {\n         strictly.verify(list).add(\"xxx\");\n     }\n     \n     @Test(expected = NumberOfInvocationsAssertionError.class)\n-    public void shouldFailOnExactNumberOfInvocations() {\n+    public void shouldFailOnExpectedNumberOfInvocations() {\n         strictly.verify(list, 2).add(\"xxx\");\n     }\n     \n         strictly.verify(list, 1).add(\"one\");\n         strictly.verify(map).put(\"two\", \"two\");\n         try {\n+            strictly.verify(map).put(\"five\", \"five\");\n+            fail();\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrderWhenCheckingExpectedNumberOfInvocations() {\n+        strictly.verify(list, 1).add(\"one\");\n+        strictly.verify(map).put(\"two\", \"two\");\n+        try {\n             strictly.verify(map, 1).put(\"five\", \"five\");\n             fail();\n-        } catch (StrictVerificationError e) {\n-//            String expected = \"\\n\" +\n-//                    \"Expected next invocation:\" +\n-//                    \"\\n\" +\n-//                    \"HashMap.put(\\\"five\\\", \\\"five\\\")\" +\n-//                    \"\\n\" +\n-//                  \"Actual next invocation:\" +\n-//                  \"\\n\" +\n-//                  \"LinkedList.add(\\\"three and four\\\")\" +\n-//                  \"\\n\";\n-//            assertEquals(expected, e.getMessage());\n-        }\n+        } catch (StrictVerificationError e) {}\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldFailOnWrongOrderWhenCheckingExpectedNumberOfInvocations2() {\n+        strictly.verify(list, 1).add(\"one\");\n+        strictly.verify(map).put(\"two\", \"two\");\n+        strictly.verify(list).add(\"three and four\");\n+        try {\n+            strictly.verify(map, 1).put(\"five\", \"five\");\n+            fail();\n+        } catch (StrictVerificationError e) {}\n     }\n }\n--- a/test/org/mockito/usage/verification/VerificationOnMultipleMocksUsingMatchersTest.java\n+++ b/test/org/mockito/usage/verification/VerificationOnMultipleMocksUsingMatchersTest.java\n         verify(list).add(anyObject());\n         verify(list).add(anyInt(), eq(\"test two\"));\n         \n-        verify(map).put(anyObject(), anyObject());\n+        verify(map, 2).put(anyObject(), anyObject());\n         verify(map).put(eq(\"test two\"), eq(200));\n         \n         verifyNoMoreInteractions(list, map);\n--- a/test/org/mockito/usage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockito/usage/verification/VerificationUsingMatchersTest.java\n         mock.oneArg(two);\n         \n         verify(mock).oneArg(CrazyMatchers.same(one));\n-        verify(mock).oneArg(two);\n+        verify(mock, 2).oneArg(two);\n         \n         try {\n             verify(mock).oneArg(CrazyMatchers.same(three));", "timestamp": 1195947297, "metainfo": ""}