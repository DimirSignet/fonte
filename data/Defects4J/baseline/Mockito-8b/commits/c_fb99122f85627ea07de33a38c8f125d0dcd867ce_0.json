{"sha": "fb99122f85627ea07de33a38c8f125d0dcd867ce", "log": "fixed problem of not getting right interaction as a cause  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40472", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n \n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n-                && invocation.getMethod().equals(actual.getMethod())\n+                && hasSameMethod(actual)\n                 && argumentsMatch(actual);\n     }\n \n      * similar means the same method name, same mock, unverified \n      * and: if arguments are the same cannot be overloaded\n      */\n-    public boolean isSimilarTo(Invocation candidate) {\n+    public boolean hasSimilarMethod(Invocation candidate) {\n         String wantedMethodName = getMethod().getName();\n         String currentMethodName = candidate.getMethod().getName();\n         \n         final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n         final boolean isUnverified = !candidate.isVerified();\n         final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n-        final boolean methodEquals = invocation.getMethod().equals(candidate.getMethod());\n+        final boolean methodEquals = hasSameMethod(candidate);\n         final boolean overloadedButSameArgs = !methodEquals && argumentsMatch(candidate);        \n         \n         if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\n         \n         return false;\n     }\n+\n+\tpublic boolean hasSameMethod(Invocation candidate) {\n+\t\treturn invocation.getMethod().equals(candidate.getMethod());\n+\t}\n }\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n     }\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        //TODO this should return by type first (if exist)\n+    \tInvocation firstSimilar = null;\n         for (Invocation invocation : invocations) {\n-            if (wanted.isSimilarTo(invocation)) {\n-                return invocation;\n-            }\n+        \tif (!wanted.hasSimilarMethod(invocation)) {\n+        \t\tcontinue;\n+        \t}\n+        \tif (firstSimilar == null) {\n+        \t\tfirstSimilar = invocation;\n+        \t}\n+        \tif (wanted.hasSameMethod(invocation)) {\n+        \t\treturn invocation;\n+        \t}\n         }\n         \n-        return null;\n+        return firstSimilar;\n     }\n     \n     public Invocation findFirstUnverified(List<Invocation> invocations) {\n--- a/test/org/mockito/TestBase.java\n+++ b/test/org/mockito/TestBase.java\n         \tpublic void assertValue(Throwable value) {\n         \t\tThrowable cause = ((Throwable) value).getCause();\n         \t\tassertNotNull(\"Exception cause should not be null\", cause);\n-        \t\tassertTrue(\"\\nException message >>>\" + value.getMessage() + \"\\n>>> should contain: \" + text,\n+        \t\tassertTrue(\"\\nException message >>>\" + cause.getMessage() + \"\\n>>> should contain: \" + text,\n         \t\t\t\tcause.getMessage().contains(text));\n         \t}\n         };\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n     @Test\n     public void shouldKnowIfIsSimilarTo() throws Exception {\n         Invocation same = new InvocationBuilder().simpleMethod().toInvocation();\n-        assertTrue(simpleMethod.isSimilarTo(same));\n+        assertTrue(simpleMethod.hasSimilarMethod(same));\n         \n         Invocation different = new InvocationBuilder().differentMethod().toInvocation();\n-        assertFalse(simpleMethod.isSimilarTo(different));\n+        assertFalse(simpleMethod.hasSimilarMethod(different));\n     }\n     \n     @Test\n     public void shouldNotBeSimilarToVerifiedInvocation() throws Exception {\n         Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n-        assertFalse(simpleMethod.isSimilarTo(verified));\n+        assertFalse(simpleMethod.hasSimilarMethod(verified));\n     }\n        \n     @Test\n     public void shouldNotBeSimilarIfMocksAreDifferent() throws Exception {\n         Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n-        assertFalse(simpleMethod.isSimilarTo(onDifferentMock));\n+        assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));\n     }    \n     \n     @Test\n         InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();\n         Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n         \n-        assertFalse(invocation.isSimilarTo(overloadedInvocation));\n+        assertFalse(invocation.hasSimilarMethod(overloadedInvocation));\n     } \n     \n     @Test\n         InvocationMatcher invocation = new InvocationBuilder().method(method).arg(\"foo\").toInvocationMatcher();\n         Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(\"bar\").toInvocation();\n         \n-        assertTrue(invocation.isSimilarTo(overloadedInvocation));\n+        assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n     }\n     \n     @Test\n-    public void shouldFindSimilarInvocationByName() throws Exception {\n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertSame(found, simpleMethodInvocation);\n+    public void shouldFindFirstSimilarInvocationByName() throws Exception {\n+    \tInvocation overloadedSimpleMethod = new InvocationBuilder().simpleMethod().arg(\"test\").toInvocation();\n+    \t\n+    \tInvocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod), atLeastOnce());\n+    \tassertSame(found, simpleMethodInvocation);\n+    }\n+    \n+    @Test\n+    public void shouldFindInvocationWithTheSameMethod() throws Exception {\n+        Invocation overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg(\"test\").toInvocation();\n+        \n+        invocations.add(overloadedDifferentMethod);\n+        \n+\t\tInvocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod), atLeastOnce());\n+        assertSame(found, overloadedDifferentMethod);\n     }\n     \n     @Test\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n         }\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldShowRightActualMethod() throws Exception {\n         mock.simpleMethod(9191);", "timestamp": 1205933909, "metainfo": ""}