{"sha": "568b0fe5638581f6822311e9d32c89758f78c289", "log": "refactoring around InvocationsFinder  --HG-- rename : src/org/mockito/internal/invocation/ListUtil.java => src/org/mockito/internal/util/ListUtil.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40240", "commit": "\n--- a/src/org/mockito/internal/invocation/ActualInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/ActualInvocationsFinder.java\n import java.util.List;\n \n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.util.ListUtil;\n+import org.mockito.internal.util.ListUtil.Filter;\n \n public class ActualInvocationsFinder {\n \n     public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        List<Invocation> actual = new LinkedList<Invocation>();\n-        for (Invocation i : invocations) {\n-            if (wanted.matches(i)) {\n-                actual.add(i);\n+        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n+    }\n+\n+    public List<Invocation> findFirstUnverifiedChunk(List<Invocation> invocations, InvocationMatcher wanted) {\n+        List<Invocation> unverified = ListUtil.filter(invocations, new RemoveVerifiedStrictly());\n+        List<Invocation> firstChunk = new LinkedList<Invocation>();\n+        for (Invocation invocation : unverified) {\n+            if (wanted.matches(invocation)) {\n+                firstChunk.add(invocation);\n+            } else if (firstChunk.isEmpty()) {\n+                firstChunk.add(invocation);\n+                break;\n+            } else {\n+                break;\n             }\n         }\n-        return actual;\n+        return firstChunk;\n+    }\n+    \n+    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        for (Invocation invocation : invocations) {\n+            String wantedMethodName = wanted.getMethod().getName();\n+            String currentMethodName = invocation.getMethod().getName();\n+            \n+            boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n+            boolean isUnverified = !invocation.isVerified();\n+            boolean mockIsTheSame = wanted.getInvocation().getMock() == invocation.getMock();\n+            \n+            if (methodNameEquals && isUnverified && mockIsTheSame ) {\n+                return invocation;\n+            }\n+        }\n+        \n+        return findFirstUnverified(invocations, wanted.getInvocation().getMock());\n+    }\n+    \n+    public Invocation findFirstUnverified(List<Invocation> invocations) {\n+        return findFirstUnverified(invocations, null);\n+    }\n+    \n+    Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {\n+        for (Invocation i : invocations) {\n+            boolean mockIsValid = mock == null || mock == i.getMock();\n+            if (!i.isVerified() && mockIsValid) {\n+                return i;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    private class RemoveNotMatching implements Filter<Invocation> {\n+        private final InvocationMatcher wanted;\n+\n+        private RemoveNotMatching(InvocationMatcher wanted) {\n+            this.wanted = wanted;\n+        }\n+\n+        public boolean isOut(Invocation invocation) {\n+            return !wanted.matches(invocation);\n+        }\n     }\n \n-    public List<Invocation> findFirstStrictlyUnverified(List<Invocation> invocations, InvocationMatcher wanted) {\n-        List<Invocation> unverified = new LinkedList<Invocation>();\n-        //TODO refactor\n-        for (Invocation i : invocations) {\n-            if (i.isVerifiedStrictly()) {\n-                continue;\n-            }\n-            \n-            if (wanted.matches(i)) {\n-                unverified.add(i);\n-                continue;\n-            }\n-            \n-            if (unverified.isEmpty()) {\n-                unverified.add(i);\n-            }\n-            \n-            break;\n+    private final class RemoveVerifiedStrictly implements Filter<Invocation> {\n+        public boolean isOut(Invocation invocation) {\n+            return invocation.isVerifiedStrictly();\n         }\n-        return unverified;\n     }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n  */\n package org.mockito.internal.invocation;\n \n-import java.util.LinkedList;\n-import java.util.List;\n-\n-import org.mockito.internal.progress.VerificationModeImpl;\n \n /**\n  * Provides handful of methods to search and count invocations\n  */\n public class InvocationsAnalyzer {\n \n-    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-        for (Invocation invocation : invocations) {\n-            String wantedMethodName = wanted.getMethod().getName();\n-            String currentMethodName = invocation.getMethod().getName();\n-            \n-            boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n-            boolean isUnverified = !invocation.isVerified();\n-            boolean mockIsTheSame = wanted.getInvocation().getMock() == invocation.getMock();\n-            \n-            if (methodNameEquals && isUnverified && mockIsTheSame ) {\n-                return invocation;\n-            }\n-        }\n-        \n-        return findFirstUnverified(invocations, wanted.getInvocation().getMock());\n-    }\n     \n-    public Invocation findFirstUnverified(List<Invocation> invocations) {\n-        return findFirstUnverified(invocations, null);\n-    }\n-    \n-    Invocation findFirstUnverified(List<Invocation> invocations, Object mock) {\n-        for (Invocation i : invocations) {\n-            boolean mockIsValid = mock == null || mock == i.getMock();\n-            if (!i.isVerified() && mockIsValid) {\n-                return i;\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    public List<Invocation> removeUntilLastStrictlyVerified(List<Invocation> invocations) {\n-        List<Invocation> unverified = new LinkedList<Invocation>();\n-        for (Invocation i : invocations) {\n-            if (i.isVerifiedStrictly()) {\n-                unverified.clear();\n-            } else {\n-                unverified.add(i);\n-            }\n-        }\n-        return unverified;\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/ListUtil.java\n+package org.mockito.internal.util;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class ListUtil {\n+\n+    public static <T> List<T> filter(List<T> list, Filter<T> filter) {\n+        List<T> filtered = new LinkedList<T>();\n+        for (T t : list) {\n+            if (!filter.isOut(t)) {\n+                filtered.add(t);\n+            }\n+        }\n+        return filtered;\n+    }\n+    \n+    public static interface Filter<T> {\n+        boolean isOut(T object);\n+    }\n+}\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.invocation.InvocationsPrinter;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class MissingInvocationVerifier implements Verifier {\n     \n     private final Reporter reporter;\n-    private final InvocationsAnalyzer analyzer;\n     private final ActualInvocationsFinder finder;\n     \n     public MissingInvocationVerifier() {\n-        this(new InvocationsAnalyzer(), new ActualInvocationsFinder(), new Reporter());\n+        this(new ActualInvocationsFinder(), new Reporter());\n     }\n     \n-    public MissingInvocationVerifier(InvocationsAnalyzer analyzer, ActualInvocationsFinder finder, Reporter reporter) {\n-        this.analyzer = analyzer;\n+    public MissingInvocationVerifier(ActualInvocationsFinder finder, Reporter reporter) {\n         this.finder = finder;\n         this.reporter = reporter;\n     }\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted, mode);\n         \n         if (actualInvocations.size() == 0) {\n-            Invocation similar = analyzer.findSimilarInvocation(invocations, wanted, mode);\n+            Invocation similar = finder.findSimilarInvocation(invocations, wanted, mode);\n             reportMissingInvocationError(wanted, similar);\n         }\n     }\n--- a/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NoMoreInvocationsVerifier.java\n import java.util.List;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.ActualInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NoMoreInvocationsVerifier implements Verifier {\n \n     private final Reporter reporter;\n-    private final InvocationsAnalyzer analyzer;\n+    private final ActualInvocationsFinder finder;\n \n     public NoMoreInvocationsVerifier() {\n-        this(new InvocationsAnalyzer(), new Reporter());\n+        this(new ActualInvocationsFinder(), new Reporter());\n     }\n     \n-    public NoMoreInvocationsVerifier(InvocationsAnalyzer analyzer, Reporter reporter) {\n-        this.analyzer = analyzer;\n+    public NoMoreInvocationsVerifier(ActualInvocationsFinder finder, Reporter reporter) {\n+        this.finder = finder;\n         this.reporter = reporter;\n     }\n \n             return;\n         }\n \n-        Invocation unverified = analyzer.findFirstUnverified(invocations);\n+        Invocation unverified = finder.findFirstUnverified(invocations);\n         if (unverified != null) {\n             reporter.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n--- a/src/org/mockito/internal/verification/StrictlyMissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/StrictlyMissingInvocationVerifier.java\n             return;\n         }\n         \n-        List<Invocation> chunk = finder.findFirstStrictlyUnverified(invocations, wanted);\n+        List<Invocation> chunk = finder.findFirstUnverifiedChunk(invocations, wanted);\n         \n         if (chunk.size() == 0) {\n             reporter.strictlyWantedButNotInvoked(wanted.toString());\n--- a/src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/StrictlyNumberOfInvocationsVerifier.java\n             return;\n         }\n         \n-        List<Invocation> chunk = finder.findFirstStrictlyUnverified(invocations, wanted);\n+        List<Invocation> chunk = finder.findFirstUnverifiedChunk(invocations, wanted);\n         \n         boolean noMatchFound = chunk.size() == 0 || !wanted.matches(chunk.get(0));\n         if (mode.wantedCountIsZero() && noMatchFound) {\n--- a/test/org/mockito/internal/invocation/ActualInvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/ActualInvocationsFinderTest.java\n package org.mockito.internal.invocation;\n \n+import static java.util.Arrays.*;\n import static org.junit.Assert.*;\n import static org.mockito.internal.progress.VerificationModeImpl.*;\n import static org.mockito.util.ExtraMatchers.*;\n     }\n     \n     @Test\n-    public void shouldFindFirstStrictlyUnverified() throws Exception {\n-        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n+    public void shouldFindFirstUnverifiedChunk() throws Exception {\n+        List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n         \n         assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n     \n     @Test\n-    public void shouldFindFirstStrictlyUnverifiedAndSkipVerified() throws Exception {\n-        simpleMethodInvocation.markVerifiedStrictly();\n-        \n-        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n-        \n-        assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocationTwo));\n-    }\n-    \n-    @Test\n-    public void shouldFindFirstStrictlyUnverifiedAndSkipTwoVerifiedInvocations() throws Exception {\n+    public void shouldFindFirstChunkAndSkipVerifiedInvocations() throws Exception {\n         simpleMethodInvocation.markVerifiedStrictly();\n         simpleMethodInvocationTwo.markVerifiedStrictly();\n         \n-        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n         \n         assertThat(unverified, collectionHasExactlyInOrder(differentMethodInvocation));\n     }\n     \n     @Test\n-    public void shouldFindFirstStrictlyUnverifiedAndSkipAllInvocations() throws Exception {\n+    public void shouldFindFirstChunkAndSkipAllInvocations() throws Exception {\n         simpleMethodInvocation.markVerifiedStrictly();\n         simpleMethodInvocationTwo.markVerifiedStrictly();\n         differentMethodInvocation.markVerifiedStrictly();\n         \n-        List<Invocation> unverified = finder.findFirstStrictlyUnverified(invocations, new InvocationMatcher(simpleMethodInvocation));\n+        List<Invocation> unverified = finder.findFirstUnverifiedChunk(invocations, new InvocationMatcher(simpleMethodInvocation));\n         \n         assertTrue(unverified.isEmpty());\n     }\n-}\n+    \n+    @Test\n+    public void shouldFindAllInvocationsBecauseAllMatch() throws Exception {\n+        List<Invocation> unverified = finder.findFirstUnverifiedChunk(\n+                asList(simpleMethodInvocation, simpleMethodInvocationTwo), new InvocationMatcher(simpleMethodInvocation));\n+        \n+        assertThat(unverified, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+    }\n+    \n+    @Test\n+    public void shouldReturnFirstUnverifiedInvocationIfNoMatchesFound() throws Exception {\n+        List<Invocation> unverified = finder.findFirstUnverifiedChunk(\n+                asList(differentMethodInvocation), new InvocationMatcher(simpleMethodInvocation));\n+        \n+        assertThat(unverified, collectionHasExactlyInOrder(differentMethodInvocation));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstUnverifiedInvocation() throws Exception {\n+        assertSame(simpleMethodInvocation, finder.findFirstUnverified(invocations));\n+        \n+        simpleMethodInvocationTwo.markVerified();\n+        simpleMethodInvocation.markVerified();\n+        \n+        assertSame(differentMethodInvocation, finder.findFirstUnverified(invocations));\n+        \n+        differentMethodInvocation.markVerified();\n+        assertNull(finder.findFirstUnverified(invocations));\n+    }\n+    \n+    @Test\n+    public void shouldFindFirstUnverifiedInvocationOnMock() throws Exception {\n+        assertSame(simpleMethodInvocation, finder.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));\n+        assertNull(finder.findFirstUnverified(invocations, \"different mock\"));\n+    }\n+    \n+    @Test\n+    public void shouldFindSimilarInvocationByName() throws Exception {\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertSame(found, simpleMethodInvocation);\n+    }\n+    \n+    @Test\n+    public void shouldFindSimilarUnverifiedInvocationByName() throws Exception {\n+        simpleMethodInvocation.markVerified();\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertSame(found, simpleMethodInvocationTwo);\n+    }\n+    \n+    @Test\n+    public void shouldFindSimilarInvocationByGettingFirstUnverified() throws Exception {\n+        simpleMethodInvocation.markVerified();\n+        simpleMethodInvocationTwo.markVerified();\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertSame(found, differentMethodInvocation);\n+    }\n+    \n+    @Test\n+    public void shouldNotFindSimilarInvocationBecauseAllAreVerified() throws Exception {\n+        simpleMethodInvocation.markVerified();\n+        simpleMethodInvocationTwo.markVerified();\n+        differentMethodInvocation.markVerified();\n+        \n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertNull(found);\n+    }\n+    \n+    @Test\n+    public void shouldLookForSimilarInvocationsOnlyOnTheSameMock() throws Exception {\n+        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        invocations.addFirst(onDifferentMock);\n+        \n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertNotSame(onDifferentMock, found);\n+    }    \n+    \n+    @Test\n+    public void shouldReturnLastUnverifiedFromTheSameMockOnly() throws Exception {\n+        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n+        invocations.addFirst(onDifferentMock);\n+\n+        simpleMethodInvocation.markVerified();\n+        simpleMethodInvocationTwo.markVerified();\n+        \n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertNotSame(onDifferentMock, found);\n+    }  \n+}\n--- a/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsAnalyzerTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.internal.progress.VerificationModeImpl.*;\n-\n import java.util.Arrays;\n import java.util.LinkedList;\n \n import org.junit.Before;\n-import org.junit.Test;\n import org.mockito.RequiresValidState;\n \n public class InvocationsAnalyzerTest extends RequiresValidState {\n     private Invocation simpleMethodInvocation;\n     private Invocation simpleMethodInvocationTwo;\n     private Invocation differentMethodInvocation;\n-    private InvocationsAnalyzer analyzer;\n \n     @Before\n     public void setup() throws Exception {\n         simpleMethodInvocationTwo = new InvocationBuilder().simpleMethod().seq(2).toInvocation();\n         differentMethodInvocation = new InvocationBuilder().differentMethod().seq(3).toInvocation();\n         invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n-        analyzer = new InvocationsAnalyzer();\n     }\n     \n-    @Test\n-    public void shouldFindFirstUnverifiedInvocation() throws Exception {\n-        assertSame(simpleMethodInvocation, analyzer.findFirstUnverified(invocations));\n-        \n-        simpleMethodInvocationTwo.markVerified();\n-        simpleMethodInvocation.markVerified();\n-        \n-        assertSame(differentMethodInvocation, analyzer.findFirstUnverified(invocations));\n-        \n-        differentMethodInvocation.markVerified();\n-        assertNull(analyzer.findFirstUnverified(invocations));\n-    }\n     \n-    @Test\n-    public void shouldFindFirstUnverifiedInvocationOnMock() throws Exception {\n-        assertSame(simpleMethodInvocation, analyzer.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));\n-        assertNull(analyzer.findFirstUnverified(invocations, \"different mock\"));\n-    }\n-    \n-    @Test\n-    public void shouldFindSimilarInvocationByName() throws Exception {\n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertSame(found, simpleMethodInvocation);\n-    }\n-    \n-    @Test\n-    public void shouldFindSimilarUnverifiedInvocationByName() throws Exception {\n-        simpleMethodInvocation.markVerified();\n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertSame(found, simpleMethodInvocationTwo);\n-    }\n-    \n-    @Test\n-    public void shouldFindSimilarInvocationByGettingFirstUnverified() throws Exception {\n-        simpleMethodInvocation.markVerified();\n-        simpleMethodInvocationTwo.markVerified();\n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertSame(found, differentMethodInvocation);\n-    }\n-    \n-    @Test\n-    public void shouldNotFindSimilarInvocationBecauseAllAreVerified() throws Exception {\n-        simpleMethodInvocation.markVerified();\n-        simpleMethodInvocationTwo.markVerified();\n-        differentMethodInvocation.markVerified();\n-        \n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertNull(found);\n-    }\n-    \n-    @Test\n-    public void shouldLookForSimilarInvocationsOnlyOnTheSameMock() throws Exception {\n-        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n-        invocations.addFirst(onDifferentMock);\n-        \n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertNotSame(onDifferentMock, found);\n-    }    \n-    \n-    @Test\n-    public void shouldReturnLastUnverifiedFromTheSameMockOnly() throws Exception {\n-        Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n-        invocations.addFirst(onDifferentMock);\n-\n-        simpleMethodInvocation.markVerified();\n-        simpleMethodInvocationTwo.markVerified();\n-        \n-        Invocation found = analyzer.findSimilarInvocation(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n-        assertNotSame(onDifferentMock, found);\n-    }  \n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/ListUtilTest.java\n+package org.mockito.internal.util;\n+\n+import static java.util.Arrays.*;\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.internal.util.ListUtil.Filter;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ListUtilTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldFilterList() throws Exception {\n+        List list = asList(\"one\", \"x\", \"two\", \"x\", \"three\");\n+        List filtered = ListUtil.filter(list, new Filter() {\n+            public boolean isOut(Object object) {\n+                return object == \"x\";\n+            }\n+        });\n+        \n+        assertThat(filtered, collectionHasExactlyInOrder(\"one\", \"two\", \"three\"));\n+    }\n+    \n+    @Test\n+    public void shouldReturnEmptyIfEmptyListGiven() throws Exception {\n+        List list = new LinkedList();\n+        List filtered = ListUtil.filter(list, null);\n+        assertTrue(filtered.isEmpty());\n+    }\n+}\n--- a/test/org/mockito/internal/verification/ActualInvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/ActualInvocationsFinderStub.java\n import org.mockito.internal.progress.VerificationModeImpl;\n \n class ActualInvocationsFinderStub extends ActualInvocationsFinder {\n+    \n+    Invocation similarToReturn;\n     final List<Invocation> actualToReturn = new LinkedList<Invocation>();\n     List<Invocation> invocations;\n+    Invocation firstUnverifiedToReturn;\n+\n     @Override public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted,\n             VerificationModeImpl mode) {\n         this.invocations = invocations;\n         return actualToReturn;\n     }\n+    \n+    @Override public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+        this.invocations = invocations;\n+        return similarToReturn;\n+    }\n+    \n+    @Override public Invocation findFirstUnverified(List<Invocation> invocations) {\n+        this.invocations = invocations;\n+        return firstUnverifiedToReturn;\n+    }\n }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class MissingInvocationVerifierTest extends RequiresValidState {\n \n     private MissingInvocationVerifier verifier;\n     \n-    private InvocationsAnalyzerStub analyzerStub;\n     private ActualInvocationsFinderStub finderStub;\n     private ReporterStub reporterStub;\n     \n \n     @Before\n     public void setup() {\n-        analyzerStub = new InvocationsAnalyzerStub();\n         reporterStub = new ReporterStub();\n         finderStub = new ActualInvocationsFinderStub();\n-        verifier = new MissingInvocationVerifier(analyzerStub, finderStub, reporterStub);\n+        verifier = new MissingInvocationVerifier(finderStub, reporterStub);\n         \n         wanted = new InvocationBuilder().toInvocationMatcher();\n         invocations = asList(new InvocationBuilder().toInvocation());\n     public void shouldAskAnalyzerForSimilarInvocation() {\n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n-        assertSame(invocations, analyzerStub.invocations);\n+        assertSame(invocations, finderStub.invocations);\n     }\n     \n     @Test\n     public void shouldReportWantedButNotInvoked() {\n         assertTrue(finderStub.actualToReturn.isEmpty());\n-        analyzerStub.similarToReturn = null;\n+        finderStub.similarToReturn = null;\n         \n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n     public void shouldReportWantedInvocationDiffersFromActual() {\n         assertTrue(finderStub.actualToReturn.isEmpty());\n         Invocation actualInvocation = new InvocationBuilder().toInvocation();\n-        analyzerStub.similarToReturn = actualInvocation;\n+        finderStub.similarToReturn = actualInvocation;\n         \n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n         assertEquals(wanted.toString(), reporterStub.wanted);\n         assertEquals(actualInvocation.toString(), reporterStub.actual);\n         assertSame(actualInvocation.getStackTrace(), reporterStub.actualInvocationStackTrace);\n-    }\n-    \n-    class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n-        private Invocation similarToReturn;\n-        private List<Invocation> invocations;\n-\n-        @Override public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n-            this.invocations = invocations;\n-            return similarToReturn;\n-        }\n     }\n     \n     class ReporterStub extends Reporter {\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n  */\n package org.mockito.internal.verification;\n \n-import static java.util.Arrays.asList;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertSame;\n+import static java.util.Arrays.*;\n+import static org.junit.Assert.*;\n \n import java.util.List;\n \n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.InvocationsAnalyzer;\n import org.mockito.internal.progress.VerificationModeImpl;\n \n public class NoMoreInvocationsVerifierTest extends RequiresValidState {\n \n     private NoMoreInvocationsVerifier verifier;\n-    private InvocationsAnalyzerStub analyzer;\n+    private ActualInvocationsFinderStub finder;\n     private ReporterStub reporterStub;\n \n     @Before\n     public void setup() {\n-        analyzer = new InvocationsAnalyzerStub();\n+        finder = new ActualInvocationsFinderStub();\n         reporterStub = new ReporterStub();\n-        verifier = new NoMoreInvocationsVerifier(analyzer, reporterStub);\n+        verifier = new NoMoreInvocationsVerifier(finder, reporterStub);\n     }\n     \n     @Test\n     \n     @Test\n     public void shouldPassVerification() throws Exception {\n-        analyzer.invocationToReturn = null;\n+        finder.firstUnverifiedToReturn = null;\n         verifier.verify(null, null, VerificationModeImpl.noMoreInteractions());\n     }\n     \n     @Test\n     public void shouldReportError() throws Exception {\n         Invocation firstUnverified = new InvocationBuilder().toInvocation();\n-        analyzer.invocationToReturn = firstUnverified;\n+        finder.firstUnverifiedToReturn = firstUnverified;\n         List<Invocation> invocations = asList(new InvocationBuilder().toInvocation());\n         \n         verifier.verify(invocations, null, VerificationModeImpl.noMoreInteractions());\n         \n-        assertSame(invocations, analyzer.invocations);\n+        assertSame(invocations, finder.invocations);\n         \n         assertEquals(firstUnverified.toString(), reporterStub.undesired);\n         assertSame(firstUnverified.getStackTrace(), reporterStub.actualInvocationStackTrace);\n-    }\n-    \n-    class InvocationsAnalyzerStub extends InvocationsAnalyzer {\n-        private List<Invocation> invocations;\n-        private Invocation invocationToReturn;\n-        @Override public Invocation findFirstUnverified(List<Invocation> invocations) {\n-            this.invocations = invocations;\n-            return invocationToReturn;\n-        }\n     }\n     \n     class ReporterStub extends Reporter {", "timestamp": 1198704064, "metainfo": ""}