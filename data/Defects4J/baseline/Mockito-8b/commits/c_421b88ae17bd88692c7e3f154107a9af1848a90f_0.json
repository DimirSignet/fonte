{"sha": "421b88ae17bd88692c7e3f154107a9af1848a90f", "log": "Fixed issue 190 Cunning locking code can potentially deadlock answer (if stubbed mock is shared between threads). See the attached test.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%402013", "commit": "\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         //see ThreadsShareGenerouslyStubbedMockTest\n+        Answer a;\n         synchronized(answers) {\n-            return answers.size() == 1 ? answers.peek().answer(invocation) : answers.poll().answer(invocation);\n+            a = answers.size() == 1 ? answers.peek() : answers.poll();\n         }\n+        return a.answer(invocation);\n     }\n \n     public void addAnswer(Answer answer) {\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecution.java\n+package org.mockitousage.bugs;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+//see bug 190\n+public class ShouldNotDeadlockAnswerExecution {\n+\n+    @Test\n+    public void failIfMockIsSharedBetweenThreads() throws Exception {\n+        Service service = Mockito.mock(Service.class);\n+        ExecutorService threads = Executors.newCachedThreadPool();\n+        AtomicInteger counter = new AtomicInteger(2);\n+\n+        // registed answer on verySlowMethod\n+\n+        Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));\n+\n+        // execute verySlowMethod twice in separate threads\n+\n+        threads.execute(new ServiceRunner(service));\n+        threads.execute(new ServiceRunner(service));\n+\n+        // waiting for threads to finish\n+\n+        threads.shutdown();\n+\n+        if (!threads.awaitTermination(1000, TimeUnit.MILLISECONDS)) {\n+            // threads were timed-out\n+            Assert.fail();\n+        }\n+    }\n+\n+    @Test\n+    public void successIfEveryThreadHasItsOwnMock() throws Exception {\n+        Service service1 = Mockito.mock(Service.class);\n+        Service service2 = Mockito.mock(Service.class);\n+        ExecutorService threads = Executors.newCachedThreadPool();\n+        AtomicInteger counter = new AtomicInteger(2);\n+\n+        // registed answer on verySlowMethod\n+\n+        Mockito.when(service1.verySlowMethod()).thenAnswer(new LockingAnswer(counter));\n+        Mockito.when(service2.verySlowMethod()).thenAnswer(new LockingAnswer(counter));\n+\n+        // execute verySlowMethod twice in separate threads\n+\n+        threads.execute(new ServiceRunner(service1));\n+        threads.execute(new ServiceRunner(service2));\n+\n+        // waiting for threads to finish\n+\n+        threads.shutdown();\n+\n+        if (!threads.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n+            // threads were timed-out\n+            Assert.fail();\n+        }\n+    }\n+\n+}\n+\n+class LockingAnswer implements Answer<String> {\n+\n+    private AtomicInteger counter;\n+\n+    public LockingAnswer(AtomicInteger counter) {\n+        this.counter = counter;\n+    }\n+\n+    /**\n+     * Decrement counter and wait until counter has value 0\n+     */\n+    public String answer(InvocationOnMock invocation) throws Throwable {\n+        counter.decrementAndGet();\n+\n+        while (counter.get() != 0) {\n+            Thread.sleep(10);\n+        }\n+\n+        return null;\n+    }\n+\n+}\n+\n+class ServiceRunner implements Runnable {\n+\n+    private Service service;\n+\n+    public ServiceRunner(Service service) {\n+        this.service = service;\n+    }\n+\n+    public void run() {\n+        service.verySlowMethod();\n+    }\n+\n+}\n+\n+interface Service {\n+\n+    String verySlowMethod();\n+\n+}", "timestamp": 1275425501, "metainfo": ""}