{"sha": "7227635dd071e1ae47338b89fb9184186854b6fa", "log": "more refactorings and testing around verification  --HG-- rename : src/org/mockito/internal/invocation/InvocationsCalculatorImpl.java => src/org/mockito/internal/invocation/InvocationsCalculator.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40167", "commit": "\n--- a/src/org/mockito/internal/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationsFinder;\n-import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class AllInvocationsFinder implements InvocationsFinder {\n     \n-    private final OngoingVerifyingMode mode;\n-\n-    //TODO name of invocations finder\n-    public AllInvocationsFinder(OngoingVerifyingMode mode) {\n-        this.mode = mode;\n-    }\n-\n-    public List<Invocation> allInvocationsInOrder() {\n-        List<Object> mocks = mode.getAllMocksToBeVerifiedInSequence();\n+    public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n         List<Invocation> allInvocations = new LinkedList<Invocation>();\n         for (Object mock : mocks) {\n             List<Invocation> invocationsOfSingleMock = MockUtil.getControl(mock).getRegisteredInvocations();\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n package org.mockito.internal;\n \n import java.lang.reflect.Method;\n+import java.util.Arrays;\n import java.util.List;\n \n import org.mockito.internal.creation.MockAwareInvocationHandler;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsChunker;\n+import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.VoidMethodStubable;\n+import org.mockito.internal.verification.MissingInvocationVerifier;\n+import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n+import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n \n public class MockControl<T> implements MockAwareInvocationHandler<T>, OngoingStubbing<T>, VoidMethodStubable<T>, StubbedMethodSelector<T> {\n \n-    private final VerifyingRecorder<T> verifyingRecorder;\n+    private final VerifyingRecorder verifyingRecorder;\n     private final Stubber stubber;\n     private final MatchersBinder matchersBinder;\n     private final MockingProgress mockingProgress;\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n         stubber = new Stubber(mockingProgress);\n-        verifyingRecorder = new VerifyingRecorder<T>();\n+        \n+        verifyingRecorder = createRecorder(); \n+    }\n+\n+    private VerifyingRecorder createRecorder() {\n+        InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder());\n+        InvocationsMarker marker = new InvocationsMarker();\n+        List<Verifier> verifiers = Arrays.asList(new MissingInvocationVerifier(), new NumberOfInvocationsVerifier());\n+        return new VerifyingRecorder(chunker, marker, verifiers);\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n--- a/src/org/mockito/internal/invocation/InvocationsCalculator.java\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculator.java\n package org.mockito.internal.invocation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n \n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n-//TODO do I need an interface here? fix the name!\n-public interface InvocationsCalculator {\n+public class InvocationsCalculator {\n \n-    int countActual(InvocationMatcher wanted);\n+    private List<Invocation> invocations = new LinkedList<Invocation>();\n \n-    Invocation findActualInvocation(InvocationMatcher wanted);\n+    public InvocationsCalculator(List<Invocation> invocations) {\n+        this.invocations.addAll(invocations);\n+    }\n \n-    HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted);\n+    public int countActual(InvocationMatcher wanted) {\n+        int actual = 0;\n+        for (Invocation registeredInvocation : invocations) {\n+            if (wanted.matches(registeredInvocation)) {\n+                actual++;\n+            }\n+        }\n \n-    HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, OngoingVerifyingMode mode);\n+        return actual;\n+    }\n \n-    Invocation getFirstUnverified();\n+    public Invocation findActualInvocation(InvocationMatcher wanted) {\n+        Invocation actualbyName = null;\n+        for (Invocation registered : invocations) {\n+            String wantedMethodName = wanted.getMethod().getName();\n+            String registeredInvocationName = registered.getMethod().getName();\n+            if (wantedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n+                actualbyName = registered;\n+            }\n+        }\n+        \n+        return actualbyName != null ? actualbyName : getFirstUnverified();\n+    }\n+    \n+    public Invocation getFirstUnverified() {\n+        for (Invocation i : invocations) {\n+            if (!i.isVerified()) {\n+                return i;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    public HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted) {\n+        Invocation lastMatching = null;\n+        for (Invocation registered : invocations) {\n+            if (wanted.matches(registered)) {\n+                lastMatching = registered;\n+            }\n+        }\n+        return lastMatching != null ? lastMatching.getStackTrace() : null;\n+    }\n+\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        int counter = 0;\n+        for (Invocation registered : invocations) {\n+            if (wanted.matches(registered)) {\n+                counter++;\n+                if (counter > mode.wantedCount()) {\n+                    return registered.getStackTrace();\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"There are no undesired invocations!\");\n+    }\n+\n+    public List<Invocation> getInvocations() {\n+        return invocations;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsChunker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsChunker.java\n         this.finder = invocationsFinder;\n     }\n \n-    public List<Invocation> getFirstUnverifiedInvocationChunk() {\n+    public List<Invocation> getFirstUnverifiedInvocationChunk(List<Object> mocks) {\n         Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n                 new Comparator<Invocation>() {\n                     public int compare(Invocation o1, Invocation o2) {\n                         return comparison;\n                     }});\n         \n-        List<Invocation> allInvocations = finder.allInvocationsInOrder();\n+        List<Invocation> allInvocations = finder.allInvocationsInOrder(mocks);\n         allInvocationsInOrder.addAll(allInvocations);\n         \n         LinkedList<Invocation> chunk = new LinkedList<Invocation>();\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n \n import java.util.List;\n \n-\n public interface InvocationsFinder {\n \n-    List<Invocation> allInvocationsInOrder();\n-\n-}\n+    List<Invocation> allInvocationsInOrder(List<Object> mocks);\n+}\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n  */\n package org.mockito.internal.verification;\n \n-import java.util.Arrays;\n import java.util.LinkedList;\n import java.util.List;\n \n import org.mockito.exceptions.Exceptions;\n-import org.mockito.internal.AllInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsCalculator;\n-import org.mockito.internal.invocation.InvocationsCalculatorImpl;\n import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n-public class VerifyingRecorder<T> {\n+public class VerifyingRecorder {\n \n     private final LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();\n-    private InvocationsMarker marker;\n-    private List<Verifier> verifiers;\n+    private final InvocationsMarker marker;\n+    private final List<Verifier> verifiers;\n+    private final InvocationsChunker chunker;\n     \n-    public VerifyingRecorder() {\n-        this(new InvocationsMarker(), Arrays.asList(new MissingInvocationVerifier(), new NumberOfInvocationsVerifier()));\n-    }\n-    \n-    VerifyingRecorder(InvocationsMarker marker, List<Verifier> verifiers) {\n+    public VerifyingRecorder(InvocationsChunker chunker, InvocationsMarker marker, List<Verifier> verifiers) {\n+        this.chunker = chunker;\n         this.marker = marker;  \n         this.verifiers = verifiers;\n     }\n \n     public void verify(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n         List<Invocation> invocations = getInvocationsForEvaluation(mode);\n-        InvocationsCalculator calculator = new InvocationsCalculatorImpl(invocations);\n+        InvocationsCalculator calculator = new InvocationsCalculator(invocations);\n         \n         for (Verifier verifier : verifiers) {\n             verifier.verify(calculator, wanted, mode);\n     }\n     \n     private List<Invocation> getInvocationsForEvaluation(OngoingVerifyingMode mode) {\n-        List<Invocation> invocations;        \n         if (mode.orderOfInvocationsMatters()) {\n-            InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder(mode));\n-            invocations = chunker.getFirstUnverifiedInvocationChunk();\n+            return chunker.getFirstUnverifiedInvocationChunk(mode.getAllMocksToBeVerifiedInSequence());\n         } else {\n-            invocations = registeredInvocations;\n+            return registeredInvocations;\n         }\n-        return invocations;\n     }\n     \n     public void verifyNoMoreInteractions() {\n         //TODO refactor to have single verify method\n         //TODO OngoingVerifyingMode.times(0) should be explicit\n-        InvocationsCalculator calculator1 = new InvocationsCalculatorImpl(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n+        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n     \n     public void verifyZeroInteractions() {\n         //TODO OngoingVerifyingMode.times(0) should be explicit\n-        InvocationsCalculator calculator1 = new InvocationsCalculatorImpl(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n+        InvocationsCalculator calculator1 = new InvocationsCalculator(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n         InvocationsCalculator calculator = calculator1;\n         Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n     public InvocationMatcher toInvocationMatcher() {\n         return new InvocationMatcher(toInvocation());\n     }\n+\n+    public InvocationBuilder simpleMethod() {\n+        return this.method(\"simpleMethod\");\n+    }\n+    \n+    public InvocationBuilder differentMethod() {\n+        return this.method(\"differentMethod\");\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationsCalculatorTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+\n+public class InvocationsCalculatorTest {\n+    \n+    private InvocationsCalculator calculator;\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        calculator = new InvocationsCalculator(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUnverifiedInvocation() throws Exception {\n+        assertSame(simpleMethodInvocation, calculator.getFirstUnverified());\n+        \n+        simpleMethodInvocationTwo.markVerified();\n+        simpleMethodInvocation.markVerified();\n+        \n+        assertSame(differentMethodInvocation, calculator.getFirstUnverified());\n+        \n+        differentMethodInvocation.markVerified();\n+        assertNull(calculator.getFirstUnverified());\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(0));\n+        HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(1));\n+        HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n+        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(2));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n+        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(100));\n+    }\n+}\n--- a/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n         simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n         \n         chunker = new InvocationsChunker(new InvocationsFinder() {\n-            public List<Invocation> allInvocationsInOrder() {\n+            public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n                 return Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation, simpleMethodInvocationThree);\n             }});\n     }\n \n     @Test\n     public void shouldGetFirstUnverifiedInvocationChunk() throws Exception {\n-        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n     \n         simpleMethodInvocation.markVerifiedInOrder();\n         simpleMethodInvocationTwo.markVerifiedInOrder();\n         \n-        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         \n         assertThat(chunk, collectionHasExactlyInOrder(differentMethodInvocation));\n     }\n         simpleMethodInvocationTwo.markVerifiedInOrder();\n         differentMethodInvocation.markVerifiedInOrder();\n         \n-        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         \n         assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocationThree));\n     }\n         differentMethodInvocation.markVerifiedInOrder();\n         simpleMethodInvocationThree.markVerifiedInOrder();\n         \n-        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk(null);\n         \n         assertTrue(chunk.isEmpty());\n     }\n--- a/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n  */\n package org.mockito.internal.verification;\n \n-import java.util.Collections;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThat;\n+import static org.mockito.util.ExtraMatchers.collectionHasExactlyInOrder;\n+\n+import java.util.Arrays;\n import java.util.List;\n \n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsChunker;\n import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n-import static org.mockito.util.ExtraMatchers.*;\n-import static org.junit.Assert.*;\n-\n public class VerifyingRecorderTest {\n     \n-    private List<Invocation> invocationsMarkedAsVerified;\n+    private VerifyingRecorder recorder;\n+    private VerifierStub verifier;\n+    private InvocationsMarkerStub marker;\n+    private InvocationsChunkerStub chunker;\n     \n-    class InvocationsMarkerExtension extends InvocationsMarker {\n-        @Override\n-        public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted,\n-                OngoingVerifyingMode mode) {\n-            invocationsMarkedAsVerified = invocations;\n+    private Invocation simpleMethod;\n+    private InvocationMatcher differentMethod;\n+    \n+    @Before\n+    public void setup() {\n+        verifier = new VerifierStub();\n+        marker = new InvocationsMarkerStub();\n+        chunker = new InvocationsChunkerStub();\n+        recorder = new VerifyingRecorder(chunker, marker, Arrays.<Verifier>asList(verifier));\n+\n+        simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();\n+        differentMethod = new InvocationBuilder().differentMethod().toInvocationMatcher();\n+    }\n+    \n+    @Test\n+    public void shouldMarkInvocationsAsVerified() {\n+        recorder.recordInvocation(simpleMethod);\n+        \n+        OngoingVerifyingMode mode = OngoingVerifyingMode.atLeastOnce();\n+        recorder.verify(differentMethod, mode);\n+        \n+        assertThat(marker.invocations, collectionHasExactlyInOrder(simpleMethod));\n+        assertEquals(marker.mode, mode);\n+        assertEquals(marker.wanted, differentMethod);\n+    }\n+    \n+    @Test\n+    public void shouldVerify() {\n+        recorder.recordInvocation(simpleMethod);\n+        \n+        OngoingVerifyingMode mode = OngoingVerifyingMode.atLeastOnce();\n+        recorder.verify(differentMethod, mode);\n+        \n+        assertEquals(verifier.mode, mode);\n+        assertSame(verifier.wanted, differentMethod);\n+        assertThat(verifier.calculator.getInvocations(), collectionHasExactlyInOrder(simpleMethod));\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrder() {\n+        recorder.recordInvocation(simpleMethod);\n+        \n+        OngoingVerifyingMode mode = OngoingVerifyingMode.inOrder(10, Arrays.<Object>asList(\"mock\"));\n+        recorder.verify(differentMethod, mode);\n+        \n+        assertEquals(verifier.mode, mode);\n+        assertEquals(verifier.wanted, differentMethod);\n+        assertThat(verifier.calculator.getInvocations(), collectionHasExactlyInOrder(differentMethod.getInvocation()));\n+    }\n+    \n+    class InvocationsMarkerStub extends InvocationsMarker {\n+        private List<Invocation> invocations;\n+        private InvocationMatcher wanted;\n+        private OngoingVerifyingMode mode;\n+        @Override public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+            this.invocations = invocations;\n+            this.wanted = wanted;\n+            this.mode = mode;\n+            \n+            assertNotNull(\"marking should happen after verification\", verifier.calculator);\n         }\n     }\n-\n-    @Test\n-    public void shouldMarkInvocationsAsVerified() {\n-        VerifyingRecorder<Object> recorder = new VerifyingRecorder<Object>(new InvocationsMarkerExtension(), Collections.<Verifier>emptyList());\n-        Invocation recorded = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n-        recorder.recordInvocation(recorded);\n-        \n-        InvocationMatcher wanted = new InvocationBuilder().method(\"differentMethod\").toInvocationMatcher();\n-        recorder.verify(wanted, OngoingVerifyingMode.atLeastOnce());\n-        \n-        assertThat(invocationsMarkedAsVerified, collectionHasExactlyInOrder(recorded));\n+    \n+    class VerifierStub implements Verifier {\n+        private InvocationsCalculator calculator;\n+        private InvocationMatcher wanted;\n+        private OngoingVerifyingMode mode;\n+        public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+            this.calculator = calculator;\n+            this.wanted = wanted;\n+            this.mode = mode;\n+        }\n+    }\n+    \n+    class InvocationsChunkerStub extends InvocationsChunker {\n+        public InvocationsChunkerStub() {\n+            super(null);\n+        }\n+        @Override public List<Invocation> getFirstUnverifiedInvocationChunk(List<Object> mocks) {\n+            return Arrays.asList(differentMethod.getInvocation());\n+        }\n     }\n }", "timestamp": 1197568068, "metainfo": ""}