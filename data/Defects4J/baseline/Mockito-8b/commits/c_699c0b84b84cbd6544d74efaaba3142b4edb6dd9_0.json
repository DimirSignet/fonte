{"sha": "699c0b84b84cbd6544d74efaaba3142b4edb6dd9", "log": "@InjectMocks by constructor", "commit": "\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n  */\n package org.mockito.internal.configuration;\n \n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\n import org.mockito.internal.configuration.injection.MockCandidateFilter;\n import org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\n import org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\n+import org.mockito.internal.util.reflection.AccessibilityChanger;\n+import org.mockito.internal.util.reflection.ConstructorInitializer;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n-import java.lang.reflect.Field;\n-import java.util.Set;\n-\n /**\n- * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n+ * Initializes mock/spies dependencies for fields annotated with\n+ * &#064;InjectMocks\n  * <p/>\n  * See {@link org.mockito.MockitoAnnotations}\n  */\n public class DefaultInjectionEngine {\n \n-    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n+\tprivate final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(\n+\t\t\tnew NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n \n-    // for each tested\n-    // - for each field of tested\n-    //   - find mock candidate by type\n-    //   - if more than *one* find mock candidate on name\n-    //   - if one mock candidate then set mock\n-    //   - else don't fail, user will then provide dependencies\n-    public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\n-        for (Field field : testClassFields) {\n-            Object fieldInstance = null;\n-            try {\n-                fieldInstance = new FieldInitializer(testClass, field).initialize();\n-            } catch (MockitoException e) {\n-                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n-            }\n+\t// for each tested\n+\t// - for each field of tested\n+\t// - find mock candidate by type\n+\t// - if more than *one* find mock candidate on name\n+\t// - if one mock candidate then set mock\n+\t// - else don't fail, user will then provide dependencies\n+\tpublic void injectMocksOnFields(Set<Field> testClassFields,\n+\t\t\tSet<Object> mocks, Object testClass) {\n+\t\tfor (Field field : testClassFields) {\n+\t\t\tif (hasDefaultConstructor(field, testClass) || alreadyInitialized(field, testClass)) {\n+\t\t\t\tsetterInject(mocks, testClass, field);\n+\t\t\t} else {\n+\t\t\t\tconstructorInject(mocks, testClass, field);\n+\t\t\t}\n+\t\t}\n+\t}\n \n-            // for each field in the class hierarchy\n-            Class<?> fieldClass = fieldInstance.getClass();\n-            while (fieldClass != Object.class) {\n-                injectMockCandidate(fieldClass, mocks, fieldInstance);\n-                fieldClass = fieldClass.getSuperclass();\n-            }\n-        }\n-    }\n+\tprivate void constructorInject(Set<Object> mocks, Object testClass,\n+\t\t\tField field) {\n+\t\tnew ConstructorInitializer(field, testClass).initialize(mocks);\n+\t}\n \n-    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        for(Field field : awaitingInjectionClazz.getDeclaredFields()) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n-        }\n-    }\n+\tprivate void setterInject(Set<Object> mocks, Object testClass, Field field) {\n+\t\ttry {\n+\t\t\tObject fieldInstance = new FieldInitializer(testClass, field)\n+\t\t\t\t\t.initialize();\n+\t\t\tClass<?> fieldClass = fieldInstance.getClass();\n+\t\t\t// for each field in the class hierarchy\n+\t\t\twhile (fieldClass != Object.class) {\n+\t\t\t\tinjectMockCandidate(fieldClass, mocks, fieldInstance);\n+\t\t\t\tfieldClass = fieldClass.getSuperclass();\n+\t\t\t}\n+\t\t} catch (Exception e) {\n+\t\t\tnew Reporter().cannotInitializeForInjectMocksAnnotation(\n+\t\t\t\t\tfield.getName(), e);\n+\t\t}\n+\n+\t}\n+\n+\tprivate boolean hasDefaultConstructor(Field field, Object testClass) {\n+\t\ttry {\n+\t\t\tfield.getType().getDeclaredConstructor();\n+\t\t\treturn true;\n+\t\t} catch (Exception e) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate boolean alreadyInitialized(Field field, Object testClass) {\n+\t\tfinal AccessibilityChanger changer = new AccessibilityChanger();\n+\t\tchanger.enableAccess(field);\n+\t\ttry {\n+\t\t\treturn field.get(testClass) != null;\n+\t\t} catch (Exception e) {\n+\t\t\treturn false;\n+\t\t} finally {\n+\t\t\tchanger.safelyDisableAccess(field);\n+\t\t}\n+\t}\n+\n+\tprivate void injectMockCandidate(Class<?> awaitingInjectionClazz,\n+\t\t\tSet<Object> mocks, Object fieldInstance) {\n+\t\tfor (Field field : awaitingInjectionClazz.getDeclaredFields()) {\n+\t\t\tmockCandidateFilter.filterCandidate(mocks, field, fieldInstance)\n+\t\t\t\t\t.thenInject();\n+\t\t}\n+\t}\n \n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/ConstructorInitializer.java\n+package org.mockito.internal.util.reflection;\n+\n+import static org.mockito.Mockito.mock;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.mockito.exceptions.Reporter;\n+\n+public class ConstructorInitializer {\n+\n+\tprivate final Field field;\n+\tprivate final Object target;\n+\n+\tpublic ConstructorInitializer(Field field, Object target) {\n+\t\tthis.field = field;\n+\t\tthis.target = target;\n+\t}\n+\t\n+\n+\tpublic void initialize(Set<Object> mocks) {\n+\t\ttry {\n+\t\t\tfinal Object instance = newInstance( mocks);\n+\t\t\tfinal AccessibilityChanger changer = new AccessibilityChanger();\n+\t\t\tchanger.enableAccess(field);\n+\t\t\tfield.set(target, instance);\n+\t\t\tchanger.safelyDisableAccess(field);\n+\t\t} catch (Exception e) {\n+\t\t\tnew Reporter().cannotInitializeForInjectMocksAnnotation(\n+\t\t\t\t\tfield.getName(), e);\n+\t\t}\n+\t}\n+\n+\tprivate Object newInstance(Set<Object> mocks)\n+\t\t\tthrows Exception {\n+\t\tfinal Constructor<?> c = biggestConstructor(field.getType());\n+\t\tfinal Object[] args = args(c, mocks);\n+\t\tfinal AccessibilityChanger changer = new AccessibilityChanger();\n+\t\tchanger.enableAccess(c);\n+\t\tfinal Object instance = c.newInstance(args);\n+\t\tchanger.safelyDisableAccess(c);\n+\t\treturn instance;\n+\t}\n+\n+\tprivate Object[] args(Constructor<?> c, Set<Object> mocks) {\n+\t\tfinal List<Object> args = new ArrayList<Object>(\n+\t\t\t\tc.getParameterTypes().length);\n+\n+\t\tfor (Class<?> paramClass : c.getParameterTypes()) {\n+\t\t\targs.add(findMockByTypeOrCreateOne(mocks, paramClass));\n+\t\t}\n+\t\treturn args.toArray();\n+\t}\n+\n+\tprivate Object findMockByTypeOrCreateOne(Set<Object> mocks,\n+\t\t\tClass<?> paramClass) {\n+\t\tfor (Object mock : mocks) {\n+\t\t\tif (paramClass.isAssignableFrom(mock.getClass())) {\n+\t\t\t\treturn mock;\n+\t\t\t}\n+\t\t}\n+\t\treturn notMockFoundForClass(paramClass);\n+\t}\n+\n+\tprivate Object notMockFoundForClass(Class<?> paramClass) {\n+\t\treturn mock(paramClass);\n+\t}\n+\n+\tprivate Constructor<?> biggestConstructor(Class<?> clazz) {\n+\t\tfinal List<Constructor<?>> constructors = Arrays.asList(clazz\n+\t\t\t\t.getConstructors());\n+\t\tCollections.sort(constructors, new Comparator<Constructor<?>>() {\n+\n+\t\t\t@Override\n+\t\t\tpublic int compare(Constructor<?> o1, Constructor<?> o2) {\n+\t\t\t\treturn o2.getParameterTypes().length\n+\t\t\t\t\t\t- o1.getParameterTypes().length;\n+\t\t\t}\n+\t\t});\n+\t\treturn constructors.get(0);\n+\t}\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/InjectMocksTest.java\n+package org.mockitousage.annotation;\n+\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockitousage.examples.use.ArticleCalculator;\n+import org.mockitousage.examples.use.ArticleManager;\n+import org.mockitoutil.TestBase;\n+\n+public class InjectMocksTest extends TestBase {\n+\n+\t@Mock\n+\tArticleCalculator calculator;\n+\n+\t@InjectMocks\n+\tArticleManager articleManager;\n+\n+\t@Test\n+\tpublic void shouldNotFailWhenNotInitialized() {\n+\t\tassertNotNull(articleManager);\n+\t}\n+\n+\t@Test(expected = IllegalArgumentException.class)\n+\tpublic void testInnerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {\n+\t\twhen(calculator.countArticles(\"new\")).thenThrow(\n+\t\t\t\tnew IllegalArgumentException());\n+\t\tarticleManager.updateArticleCounters(\"new\");\n+\t}\n+\n+\t@Test\n+\tpublic void mockJustWorks() {\n+\t\tarticleManager.updateArticleCounters(\"new\");\n+\t}\n+}", "timestamp": 1292212682, "metainfo": ""}