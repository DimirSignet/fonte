{"sha": "f8c30b0e5ed529eb58ee265b4ce13d353662cb46", "log": "Added Experimental runner that gives a notion why the test might fail  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401100", "commit": "\n--- a/src/org/mockito/exceptions/base/StackTraceFilter.java\n+++ b/src/org/mockito/exceptions/base/StackTraceFilter.java\n package org.mockito.exceptions.base;\n \n import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.List;\n \n public class StackTraceFilter {\n     public boolean isLastStackElementToRemove(StackTraceElement e) {\n         boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n         boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n-        return fromMockObject || fromOrgMockito;\n+        //boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n+        return fromMockObject || fromOrgMockito;//) && !isRunner;\n     }\n \n     public void filterStackTrace(HasStackTrace hasStackTrace) {\n         List<StackTraceElement> filtered = unfilteredStackTrace.subList(lastToRemove + 1, unfilteredStackTrace.size());\n         hasStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n     }\n+\n+    //TODO dummy & duplicated\n+    public void removeRunner(HasStackTrace hasStackTrace) {\n+        StackTraceElement[] stackTrace = hasStackTrace.getStackTrace();\n+        List<StackTraceElement> filtered = new LinkedList<StackTraceElement>();\n+        for (StackTraceElement trace : stackTrace) {\n+            boolean isRunner = trace.getClassName().startsWith(\"org.mockito.runners.\");\n+            if (!isRunner) {\n+                filtered.add(trace);\n+            }\n+        }\n+        hasStackTrace.setStackTrace(filtered.toArray(new StackTraceElement[]{}));\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n+package org.mockito.internal.debugging;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+\n+public class DebuggingInfo {\n+\n+    private final List<Invocation> unusedStubs = new LinkedList<Invocation>();\n+    private final String test;\n+\n+    public DebuggingInfo(String test) {\n+        this.test = test;\n+    }\n+\n+    public void addUnusedStub(Invocation invocation) {\n+        this.unusedStubs.add(invocation);\n+    }\n+\n+    public void printInfo() {\n+        if (!shouldPrint()) {\n+            return;\n+        }\n+        \n+//        print(\"Mockito detected some of your stubs were not called. This *might* be the reason your test failed.\");\n+//        print(\"Test:\");\n+//        print(test);\n+        \n+        for (Invocation i : unusedStubs) {\n+            print(\"Warning - unused stub detected:\");\n+            print(i.getStackTrace().getStackTrace()[0]);\n+        }\n+    }\n+\n+    private void print(Object text) {\n+        System.out.println(\"[Mockito] \" + text.toString());\n+    }\n+\n+    private boolean shouldPrint() {\n+        return !unusedStubs.isEmpty();\n+    }\n+}\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n \n     void stubbingStarted();\n \n-    void stubbingCompleted();\n+    void stubbingCompleted(Invocation invocation);\n     \n     void validateState();\n \n      * state validation errors are more accurate\n      */\n     void resetOngoingStubbing();\n+\n+    List<Invocation> pullStubbedInvocations();\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n  */\n package org.mockito.internal.progress;\n \n+import java.util.LinkedList;\n+import java.util.List;\n+\n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n     OngoingStubbing ongoingStubbing;\n     private VerificationMode verificationMode;\n     private boolean stubbingInProgress = false;\n+\n+    private List<Invocation> stubbedInvocations = new LinkedList<Invocation>();\n \n     public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n         this.ongoingStubbing = ongoingStubbing;\n \n     public void stubbingStarted() {\n         validateState();\n+        //TODO stubbingInProgress is somehow duplicated with stubbedInvocations\n         stubbingInProgress = true;\n     }\n \n         LastArguments.instance().validateState();\n     }\n \n-    public void stubbingCompleted() {\n+    public void stubbingCompleted(Invocation invocation) {\n+        stubbedInvocations.add(invocation);        \n         stubbingInProgress = false;\n     }\n     \n         //TODO LastArguments should be somewhere here...\n         LastArguments.instance().reset();\n     }\n+\n+    public List<Invocation> pullStubbedInvocations() {\n+        List<Invocation> ret = new LinkedList<Invocation>(stubbedInvocations);\n+        stubbedInvocations.clear();\n+        return ret;\n+    }\n }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n @SuppressWarnings(\"unchecked\")\n         threadSafely().validateState();\n     }\n \n-    public void stubbingCompleted() {\n-        threadSafely().stubbingCompleted();\n+    public void stubbingCompleted(Invocation invocation) {\n+        threadSafely().stubbingCompleted(invocation);\n     }\n     \n     public String toString() {\n     public void resetOngoingStubbing() {\n         threadSafely().resetOngoingStubbing();\n     }\n+\n+    public List<Invocation> pullStubbedInvocations() {\n+        return threadSafely().pullStubbedInvocations();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n     }\n     \n     private void addAnswer(Answer answer, boolean isConsecutive) {\n-        mockingProgress.stubbingCompleted();\n+        Invocation invocation = invocationForStubbing.getInvocation();\n+        mockingProgress.stubbingCompleted(invocation);\n         AnswersValidator answersValidator = new AnswersValidator();\n-        answersValidator.validate(answer, invocationForStubbing.getInvocation());\n+        answersValidator.validate(answer, invocation);\n         \n         if (isConsecutive) {\n             stubbed.getFirst().addAnswer(answer);\n--- /dev/null\n+++ b/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.runners;\n+\n+import java.util.List;\n+\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.BlockJUnit4ClassRunner;\n+import org.junit.runners.model.FrameworkMethod;\n+import org.junit.runners.model.InitializationError;\n+import org.junit.runners.model.Statement;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+\n+/**\n+ * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n+ * <p>\n+ * JUnit 4.5 runner initializes mocks annotated with {@link Mock},\n+ * so that explicit usage of {@link MockitoAnnotations#initMocks(Object)} is not necessary. \n+ * Mocks are initialized before each test method. \n+ * <p>\n+ * Runner is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.\n+ * <p>\n+ * Read more in javadoc for {@link MockitoAnnotations}\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * <b>&#064;RunWith(MockitoJUnit44Runner.class)</b>\n+ * public class ExampleTest {\n+ * \n+ *     &#064;Mock\n+ *     private List list;\n+ * \n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * <p>\n+ * \n+ * </pre>\n+ */\n+public class ExperimentalMockitoJUnitRunner extends BlockJUnit4ClassRunner {\n+\n+    public ExperimentalMockitoJUnitRunner(Class<?> klass) throws InitializationError {\n+        super(klass);\n+    }\n+\n+    @Override\n+    protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n+        MockitoAnnotations.initMocks(target);\n+        return super.withBefores(method, target, statement);\n+    }\n+    \n+    class MockitoListener extends RunListener {\n+        \n+        private MockingProgress progress;\n+\n+        public MockitoListener(MockingProgress progress) {\n+            super();\n+            this.progress = progress;\n+        }\n+\n+        @Override\n+        public void testFailure(Failure failure) throws Exception {\n+            DebuggingInfo debuggingInfo = new DebuggingInfo(failure.getTestHeader());\n+            Throwable e = failure.getException();\n+            List<Invocation> stubbedInvocations = progress.pullStubbedInvocations();\n+            for (Invocation invocation : stubbedInvocations) {\n+                if (!invocation.isVerified()) {\n+                    //TODO this requires some refactoring, it's just a dummy implementation\n+                    debuggingInfo.addUnusedStub(invocation);\n+                    break;\n+                }\n+            }\n+            debuggingInfo.printInfo();\n+            super.testFailure(failure);\n+        }\n+    }\n+    \n+    @Override\n+    public void run(RunNotifier notifier) {\n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        MockitoListener listener = new MockitoListener(progress);\n+        notifier.addListener(listener);\n+        super.run(notifier);\n+        //TODO pull should be done by the listener\n+        progress.pullStubbedInvocations();\n+    }\n+}\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n  */\n package org.mockitousage;\n \n+import static org.mockito.Mockito.*;\n+\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n import org.mockito.Mock;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n+@RunWith(ExperimentalMockitoJUnitRunner.class)\n public class PlaygroundTest extends TestBase {\n \n-    @Mock IMethods mock;\n-    \n+    public class SomeController {\n+\n+        private final ReadFromSomeFileSystem reader;\n+\n+        public SomeController(ReadFromSomeFileSystem reader, Object object) {\n+            this.reader = reader;\n+        }\n+\n+        public byte[] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue(String filename) {\n+            return this.reader.readFromFile(\"filename\");\n+        }\n+    }\n+\n+    public interface ReadFromSomeFileSystem {\n+\n+        byte[] readFromFile(String filename);\n+\n+    }\n+\n+    @Mock\n+    IMethods mock;\n+\n     @Test\n     public void testSomething() {\n     }\n+\n+    @Test\n+    public void shouldFailButOnlyWhenIAssertReturnValueAndIWantToKnowWhy() throws Throwable {\n+        ReadFromSomeFileSystem reader = mock(ReadFromSomeFileSystem.class);\n+\n+        SomeController controller = new SomeController(reader, null);\n+\n+        final String filename = \"/some/non/random/path\";\n+        final String message = \"this is my message to you\";\n+        when(reader.readFromFile(filename)).thenReturn(message.getBytes(\"UTF8\"));\n+\n+        byte[] bytes = controller.naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue(filename);\n+\n+//        try {\n+//        assertNotNull(\"Should have returned some bytes, i am HUNGRY!\", bytes);\n+//        } catch (Error ex) {\n+//            verify(reader).readFromFile(filename);\n+//            // i want to replace this bit with something like \"verifyAllTheThingsIStubbed(mock)\"\n+//            throw ex;\n+//        }\n+    }\n }", "timestamp": 1229864795, "metainfo": ""}