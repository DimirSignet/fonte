{"sha": "43af9fdf841ae7d051fb817559716be6c59262dd", "log": "Added after() as an analogue of timeout() which does not terminate early if the condition passes  This allows for using .never(), atMost(), times() to be effectively, other with timeout() these will typically immediately pass, probably not what was intended.", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockito.stubbing.*;\n+import org.mockito.verification.After;\n import org.mockito.verification.Timeout;\n+import org.mockito.verification.VerificationAfterDelay;\n import org.mockito.verification.VerificationMode;\n import org.mockito.verification.VerificationWithTimeout;\n \n     \n     /**\n      * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n-     * interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent\n+     * interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent\n      * conditions.\n+     * <p>\n+     * This differs from {@link Mockito#after after()} in that after() will wait the full period, unless\n+     * the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon\n+     * as verification passes, producing different behaviour when used with times(2), for example, which can pass \n+     * and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until\n+     * times(2) failed, and then fail.\n      * <p>\n      * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n      * <p>\n      *   //above is an alias to:\n      *   verify(mock, timeout(100).times(1)).someMethod();\n      *   \n-     *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n+     *   //passes as soon as someMethod() has been called 2 times before the given timeout\n      *   verify(mock, timeout(100).times(2)).someMethod();\n      *\n-     *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n+     *   //equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout\n      *   verify(mock, timeout(100).atLeast(2)).someMethod();\n      *   \n      *   //verifies someMethod() within given time span using given verification mode\n      * \n      * See examples in javadoc for {@link Mockito} class\n      * \n-     * @param millis - time span in millisecond\n+     * @param millis - time span in milliseconds\n      * \n      * @return verification mode\n      */\n     public static VerificationWithTimeout timeout(int millis) {\n         return new Timeout(millis, VerificationModeFactory.times(1));\n-    }       \n+    }\n+    \n+    /**\n+     * Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired\n+     * interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent\n+     * conditions.\n+     * <p>\n+     * This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout() \n+     * will stop early as soon as verification passes, producing different behaviour when used with times(2), for example,\n+     * which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would\n+     * run the full time, which point it will fail, as times(2) has failed.\n+     * <p>\n+     * It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system\n+     * <p>\n+     * Not yet implemented to work with InOrder verification.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   //passes after 100ms, if someMethod() has only been called once at that time. \n+     *   verify(mock, after(100)).someMethod();\n+     *   //above is an alias to:\n+     *   verify(mock, after(100).times(1)).someMethod();\n+     *   \n+     *   //passes if someMethod() is called <b>*exactly*</b> 2 times after the given timespan\n+     *   verify(mock, after(100).times(2)).someMethod();\n+     *\n+     *   //passes if someMethod() has not been called after the given timespan\n+     *   verify(mock, after(100).never()).someMethod();\n+     *   \n+     *   //verifies someMethod() after a given time span using given verification mode\n+     *   //useful only if you have your own custom verification modes.\n+     *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();\n+     * </code></pre>\n+     * \n+     * See examples in javadoc for {@link Mockito} class\n+     * \n+     * @param millis - time span in milliseconds\n+     * \n+     * @return verification mode\n+     */\n+    public static VerificationAfterDelay after(int millis) {\n+        return new After(millis, VerificationModeFactory.times(1));\n+    }\n     \n     /**\n      * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n      * <p>\n      * Examples of incorrect use:\n      * <pre class=\"code\"><code class=\"java\">\n-     * //Oups, someone forgot thenReturn() part:\n+     * //Oops, someone forgot thenReturn() part:\n      * when(mock.get());\n      * \n-     * //Oups, someone put the verified method call inside verify() where it should be outside:\n+     * //Oops, someone put the verified method call inside verify() where it should be outside:\n      * verify(mock.execute());\n      * \n-     * //Oups, someone has used EasyMock for too long and forgot to specify the method to verify:\n+     * //Oops, someone has used EasyMock for too long and forgot to specify the method to verify:\n      * verify(mock);\n      * </code></pre>\n      * \n--- /dev/null\n+++ b/src/org/mockito/internal/verification/VerificationAfterDelayImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.verification.VerificationMode;\n+\n+public class VerificationAfterDelayImpl implements VerificationMode {\n+\n+    private int delayMillis;\n+    private VerificationMode delegate;\n+\n+    public VerificationAfterDelayImpl(int delayMillis, VerificationMode delegate) {\n+        this.delayMillis = delayMillis;\n+        this.delegate = delegate;\n+    }\n+    \n+    public void verify(VerificationData data) {\n+        long startTime = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - startTime <= delayMillis) {\n+            try {\n+                Thread.sleep(delayMillis);\n+            } catch (InterruptedException ie) {\n+                // Oops. Try again.\n+            }\n+        }\n+        \n+        delegate.verify(data);\n+    }\n+\n+    public int getDelay() {\n+        return delayMillis;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/verification/After.java\n+package org.mockito.verification;\n+\n+import org.mockito.internal.verification.VerificationAfterDelayImpl;\n+\n+\n+public class After extends VerificationWrapper<VerificationAfterDelayImpl> implements VerificationAfterDelay {\n+    \n+    /**\n+     * See the javadoc for {@link VerificationAfterDelay}\n+     * <p>\n+     * Typically, you won't use this class explicitly. Instead use timeout() method on Mockito class.\n+     * See javadoc for {@link VerificationWithTimeout}\n+     */    \n+    public After(int delayMillis, VerificationMode verificationMode) {\n+        super(new VerificationAfterDelayImpl(delayMillis, verificationMode));\n+    }\n+    \n+    @Override\n+    protected VerificationMode copySelfWithNewVerificationMode(VerificationMode verificationMode) {\n+        return new After(wrappedVerification.getDelay(), verificationMode);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/verification/VerificationAfterDelay.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.verification;\n+\n+import org.mockito.Mockito;\n+\n+\n+/**\n+ * VerificationAfterDelay is a {@link VerificationMode} that allows combining existing verification modes with an initial delay, e.g. \n+ * <pre class=\"code\"><code class=\"java\">\n+ * verify(mock, after(100).atMost(5)).foo();\n+ * \n+ * verify(mock, after(100).never()).bar();\n+ * \n+ * verify(mock, after(200).atLeastOnce()).baz();\n+ * </code></pre>\n+ * \n+ * This is similar to {@link VerificationWithTimeout timeout()} except the assertion will not terminate until \n+ * the full time has elapsed (whereas timeout() will also stop if the condition is true at any point, as is\n+ * typically the case with never() etc initially). \n+ * \n+ * <p>\n+ * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n+ *\n+ */\n+public interface VerificationAfterDelay extends VerificationMode {\n+    \n+    /**\n+     * Verifies that there are exactly N invocations during the given period.\n+     */\n+    public VerificationMode times(int wantedNumberOfInvocations);\n+\n+    /**\n+     * Allows verification that there are no invocations at any point during the given period.\n+     */\n+    public VerificationMode never();\n+    \n+    /**\n+     * Verifies that there is at least 1 invocation during the given period.\n+     */\n+    public VerificationMode atLeastOnce();\n+    \n+    /**\n+     * Verifies that there is are least N invocations during the given period.\n+     */\n+    public VerificationMode atLeast(int minNumberOfInvocations);\n+    \n+    /**\n+     * Verifies that there is are most N invocations during the given period.\n+     */\n+    public VerificationMode atMost(int maxNumberOfInvocations);\n+    \n+    /**\n+     * Verifies that there the given method is invoked and is the only method invoked.\n+     */\n+    public VerificationMode only();\n+    \n+}\n--- a/src/org/mockito/verification/VerificationWithTimeout.java\n+++ b/src/org/mockito/verification/VerificationWithTimeout.java\n  * \n  * verify(mock, timeout(200).atLeastOnce()).baz();\n  * </code></pre>\n+ * \n+ * This is similar to {@link VerificationAfterDelay after()} except this assertion will immediately pass if it becomes true at any point,\n+ * whereas after() will wait the full period. Assertions which are consistently expected to be initially true and potentially become false are \n+ * deprecated below, and after() should be used instead.\n  * \n  * <p>\n  * See examples in javadoc for {@link Mockito#verify(Object, VerificationMode)}\n     \n     /**\n      * @deprecated\n-     * Validation with timeout combined with never simply does not make sense...\n-     * The test would have passed immediately in the concurrent environment\n+     * Validation with timeout combined with never simply does not make sense, as never() will typically immediately pass,\n+     * and therefore not wait the timeout. The behaviour you may be looking for is actually provided by after().never(). \n      * <p>\n      * To avoid compilation errors upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n      * <p>\n      * @deprecated\n      *\n      * <b>Deprecated</b>\n-     * Validation with timeout combined with atMost simply does not make sense...\n-     * The test would have passed immediately in the concurrent environment\n+     * Validation with timeout combined with never simply does not make sense, as atMost() will typically immediately pass,\n+     * and therefore not wait the timeout. The behaviour you may be looking for is actually provided by after().atMost(). \n      * <p>\n      * To avoid compilation errors upon upgrade the method is deprecated and it throws a \"friendly reminder\" exception.\n      * <p>\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationAfterDelayTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.verification;\n+\n+import static org.mockito.Mockito.after;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockitoutil.TestBase;\n+\n+public class VerificationAfterDelayTest extends TestBase {\n+    \n+    @Rule\n+    public ExpectedException expected = ExpectedException.none();\n+\n+    @Mock\n+    private List<String> mock;\n+\n+    private List<Exception> exceptions = new LinkedList<Exception>();\n+\n+    @After\n+    public void teardown() {\n+        // making sure there are no threading related exceptions\n+        assertTrue(exceptions.isEmpty());\n+    }\n+\n+    @Test\n+    public void shouldVerifyNormallyWithSpecificTimes() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(20);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        verify(mock, after(50).times(1)).clear();\n+    }\n+\n+    @Test\n+    public void shouldVerifyNormallyWithAtLeast() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(20);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        verify(mock, after(100).atLeast(1)).clear();\n+    }\n+\n+    @Test\n+    public void shouldFailVerificationWithWrongTimes() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(20);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        verify(mock, times(0)).clear();\n+        \n+        expected.expect(MockitoAssertionError.class);\n+        verify(mock, after(50).times(2)).clear();\n+    }\n+\n+    @Test\n+    public void shouldWaitTheFullTime() throws Exception {\n+        // given\n+        Thread t = waitAndExerciseMock(50);\n+\n+        // when\n+        t.start();\n+\n+        // then\n+        long startTime = System.currentTimeMillis();\n+        verify(mock, after(100).atMost(1)).clear();\n+        assertTrue(System.currentTimeMillis() - startTime >= 100);\n+    } \n+\n+    private Thread waitAndExerciseMock(final int sleep) {\n+        Thread t = new Thread() {\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    Thread.sleep(sleep);\n+                } catch (InterruptedException e) {\n+                    exceptions.add(e);\n+                    throw new RuntimeException(e);\n+                }\n+                mock.clear();\n+            }\n+        };\n+        return t;\n+    }\n+}", "timestamp": 1381493193, "metainfo": ""}