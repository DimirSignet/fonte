{"sha": "1b4725062822b9f3fbad02fb5d4f64fdb6ca1096", "log": "Change on 2010/07/08 16:47:04 by nicksantos  \tOpen-source Hash.hash64. \tWe really depend on this being constant over time, so it really \tshould live in our codebase.  \tR=bowdidge \tDELTA=234  (232 added, 2 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=49005   ", "commit": "\n--- a/src/com/google/javascript/jscomp/JsMessage.java\n+++ b/src/com/google/javascript/jscomp/JsMessage.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.common.base.Hash;\n-import com.google.common.base.Preconditions;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Set;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n \n /**\n  * A representation of a translatable message in JavaScript source code.\n       return Long.toString(nonnegativeHash, 36).toUpperCase();\n     }\n   }\n+\n+  /**\n+   * This class contains routines for hashing.\n+   *\n+   * <p>The hash takes a byte array representing arbitrary data (a\n+   * number, String, or Object) and turns it into a small, hopefully\n+   * unique, number. There are additional convenience functions which\n+   * hash int, long, and String types.\n+   *\n+   * <p><b>Note</b>: this hash has weaknesses in the two\n+   * most-significant key bits and in the three least-significant seed\n+   * bits. The weaknesses are small and practically speaking, will not\n+   * affect the distribution of hash values. Still, it would be good\n+   * practice not to choose seeds 0, 1, 2, 3, ..., n to yield n,\n+   * independent hash functions. Use pseudo-random seeds instead.\n+   *\n+   * <p>This code is based on the work of Craig Silverstein and Sanjay\n+   * Ghemawat in, then forked from com.google.common.\n+   *\n+   * <p>The original code for the hash function is courtesy\n+   * <a href=\"http://burtleburtle.net/bob/hash/evahash.html\">Bob Jenkins</a>.\n+   *\n+   * <p>TODO: Add stream hashing functionality.\n+   */\n+  final static class Hash {\n+    private Hash() {}\n+\n+    /** Default hash seed (64 bit) */\n+    private static final long SEED64 =\n+        0x2b992ddfa23249d6L; // part of pi, arbitrary\n+\n+    /** Hash constant (64 bit) */\n+    private  static final long CONSTANT64 =\n+        0xe08c1d668b756f82L; // part of golden ratio, arbitrary\n+\n+\n+    /******************\n+     * STRING HASHING *\n+     ******************/\n+\n+    /**\n+     * Hash a string to a 64 bit value. The digits of pi are used for\n+     * the hash seed.\n+     *\n+     * @param value the string to hash\n+     * @return 64 bit hash value\n+     */\n+    static long hash64(@Nullable String value) {\n+      return hash64(value, SEED64);\n+    }\n+\n+    /**\n+     * Hash a string to a 64 bit value using the supplied seed.\n+     *\n+     * @param value the string to hash\n+     * @param seed the seed\n+     * @return 64 bit hash value\n+     */\n+    private static long hash64(@Nullable String value, long seed) {\n+      if (value == null) {\n+        return hash64(null, 0, 0, seed);\n+      }\n+      return hash64(value.getBytes(), seed);\n+    }\n+\n+    /**\n+     * Hash byte array to a 64 bit value. The digits of pi are used\n+     * for the hash seed.\n+     *\n+     * @param value the bytes to hash\n+     * @param offset the starting position of value where bytes are\n+     * used for the hash computation\n+     * @param length number of bytes of value that are used for the\n+     * hash computation\n+     * @return 64 bit hash value\n+     */\n+    private static long hash64(byte[] value, int offset, int length) {\n+      return hash64(value, offset, length, SEED64);\n+    }\n+\n+    /**\n+     * Hash byte array to a 64 bit value using the supplied seed.\n+     *\n+     * @param value the bytes to hash\n+     * @param seed the seed\n+     * @return 64 bit hash value\n+     */\n+    private static long hash64(byte[] value, long seed) {\n+      return hash64(value, 0, value == null ? 0 : value.length, seed);\n+    }\n+\n+    /**\n+     * Hash byte array to a 64 bit value using the supplied seed.\n+     *\n+     * @param value the bytes to hash\n+     * @param offset the starting position of value where bytes are\n+     * used for the hash computation\n+     * @param length number of bytes of value that are used for the\n+     * hash computation\n+     * @param seed the seed\n+     * @return 64 bit hash value\n+     */\n+    @SuppressWarnings(\"fallthrough\")\n+    private static long hash64(\n+        byte[] value, int offset, int length, long seed) {\n+      long a = CONSTANT64;\n+      long b = a;\n+      long c = seed;\n+      int keylen;\n+\n+      for (keylen = length; keylen >= 24; keylen -= 24, offset += 24) {\n+        a += word64At(value, offset);\n+        b += word64At(value, offset + 8);\n+        c += word64At(value, offset + 16);\n+\n+        // Mix\n+        a -= b; a -= c; a ^= c >>> 43;\n+        b -= c; b -= a; b ^= a << 9;\n+        c -= a; c -= b; c ^= b >>> 8;\n+        a -= b; a -= c; a ^= c >>> 38;\n+        b -= c; b -= a; b ^= a << 23;\n+        c -= a; c -= b; c ^= b >>> 5;\n+        a -= b; a -= c; a ^= c >>> 35;\n+        b -= c; b -= a; b ^= a << 49;\n+        c -= a; c -= b; c ^= b >>> 11;\n+        a -= b; a -= c; a ^= c >>> 12;\n+        b -= c; b -= a; b ^= a << 18;\n+        c -= a; c -= b; c ^= b >>> 22;\n+      }\n+\n+      c += length;\n+      switch (keylen) { // deal with rest. Cases fall through\n+        case 23:\n+          c += ((long) value[offset + 22]) << 56;\n+        case 22:\n+          c += (value[offset + 21] & 0xffL) << 48;\n+        case 21:\n+          c += (value[offset + 20] & 0xffL) << 40;\n+        case 20:\n+          c += (value[offset + 19] & 0xffL) << 32;\n+        case 19:\n+          c += (value[offset + 18] & 0xffL) << 24;\n+        case 18:\n+          c += (value[offset + 17] & 0xffL) << 16;\n+        case 17:\n+          c += (value[offset + 16] & 0xffL) << 8;\n+          // the first byte of c is reserved for the length\n+        case 16:\n+          b += word64At(value, offset + 8);\n+          a += word64At(value, offset);\n+          break;\n+        case 15:\n+          b += (value[offset + 14] & 0xffL) << 48;\n+        case 14:\n+          b += (value[offset + 13] & 0xffL) << 40;\n+        case 13:\n+          b += (value[offset + 12] & 0xffL) << 32;\n+        case 12:\n+          b += (value[offset + 11] & 0xffL) << 24;\n+        case 11:\n+          b += (value[offset + 10] & 0xffL) << 16;\n+        case 10:\n+          b += (value[offset + 9] & 0xffL) << 8;\n+        case 9:\n+          b += (value[offset + 8] & 0xffL);\n+        case 8:\n+          a += word64At(value, offset);\n+          break;\n+        case 7:\n+          a += (value[offset + 6] & 0xffL) << 48;\n+        case 6:\n+          a += (value[offset + 5] & 0xffL) << 40;\n+        case 5:\n+          a += (value[offset + 4] & 0xffL) << 32;\n+        case 4:\n+          a += (value[offset + 3] & 0xffL) << 24;\n+        case 3:\n+          a += (value[offset + 2] & 0xffL) << 16;\n+        case 2:\n+          a += (value[offset + 1] & 0xffL) << 8;\n+        case 1:\n+          a += (value[offset + 0] & 0xffL);\n+          // case 0: nothing left to add\n+      }\n+      return mix64(a, b, c);\n+    }\n+\n+    private static long word64At(byte[] bytes, int offset) {\n+      return (bytes[offset + 0] & 0xffL)\n+          + ((bytes[offset + 1] & 0xffL) << 8)\n+          + ((bytes[offset + 2] & 0xffL) << 16)\n+          + ((bytes[offset + 3] & 0xffL) << 24)\n+          + ((bytes[offset + 4] & 0xffL) << 32)\n+          + ((bytes[offset + 5] & 0xffL) << 40)\n+          + ((bytes[offset + 6] & 0xffL) << 48)\n+          + ((bytes[offset + 7] & 0xffL) << 56);\n+    }\n+\n+    /**\n+     * Mixes longs a, b, and c, and returns the final value of c.\n+     */\n+    private static long mix64(long a, long b, long c) {\n+      a -= b; a -= c; a ^= c >>> 43;\n+      b -= c; b -= a; b ^= a << 9;\n+      c -= a; c -= b; c ^= b >>> 8;\n+      a -= b; a -= c; a ^= c >>> 38;\n+      b -= c; b -= a; b ^= a << 23;\n+      c -= a; c -= b; c ^= b >>> 5;\n+      a -= b; a -= c; a ^= c >>> 35;\n+      b -= c; b -= a; b ^= a << 49;\n+      c -= a; c -= b; c ^= b >>> 11;\n+      a -= b; a -= c; a ^= c >>> 12;\n+      b -= c; b -= a; b ^= a << 18;\n+      c -= a; c -= b; c ^= b >>> 22;\n+      return c;\n+    }\n+  }\n+\n   public interface IdGenerator {\n \n     String generateId(String key, List<CharSequence> messageParts);\n--- a/test/com/google/javascript/jscomp/JsMessageTest.java\n+++ b/test/com/google/javascript/jscomp/JsMessageTest.java\n     assertFalse(new JsMessage.Builder().appendPlaceholderReference(\"3\")\n         .build().isEmpty());\n   }\n+\n+  public void testHashValues() {\n+    final String EMPTY = \"\";\n+    final String VAL = \"Hello, world\";\n+    final long   ANSWER_STRING_64 = 0x43ec5d9731515874L;\n+    final long   ANSWER_EMPTY_64 = 0x468d9ea2c42361aaL;\n+\n+    assertEquals(ANSWER_STRING_64, JsMessage.Hash.hash64(VAL));\n+    assertEquals(ANSWER_EMPTY_64, JsMessage.Hash.hash64(EMPTY));\n+  }\n }", "timestamp": 1278687275, "metainfo": ""}