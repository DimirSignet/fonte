{"sha": "915752b8e4ffd312eea298fb749dddd0edc0db2e", "log": "Add boatloads of tests.  Add support for --jscomp_warning=checkTypes  Add phase optimization improvements.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n \n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n+import com.google.common.base.Join;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n       docLevel = DocLevel.SECRET)\n   public static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n \n+  @FlagSpec(help = \"Runs the compile job many times, then prints out the \" +\n+      \"best phase ordering from this run\",\n+      docLevel = DocLevel.SECRET)\n+  public static final Flag<Boolean> FLAG_compute_phase_ordering =\n+      Flag.value(false);\n+\n   @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n       + \" tree and exits\",\n       docLevel = DocLevel.SECRET)\n       Flag.stringCollector();\n \n   @FlagSpec(help = \"Make the named class of warnings a normal warning. \" +\n-  \t\t\"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+                \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n   public static final Flag<List<String>> FLAG_jscomp_warning =\n       Flag.stringCollector();\n \n   private A compiler;\n \n   private static Charset inputCharset;\n+\n+  // Bookkeeping to measure optimal phase orderings.\n+  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n+\n+  private final RunTimeStats runTimeStats = new RunTimeStats();\n \n   public AbstractCompilerRunner(String[] args) {\n     this(args, System.out, System.err);\n    * compiler.\n    */\n   final public void run() {\n-    int result;\n+    int result = 0;\n+    int runs = 1;\n+    if (FLAG_compute_phase_ordering.get()) {\n+      runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\n+      PhaseOptimizer.randomizeLoops();\n+    }\n     try {\n-      result = doRun();\n+      for (int i = 0; i < runs && result == 0; i++) {\n+        runTimeStats.recordStartRun();\n+        result = doRun();\n+        runTimeStats.recordEndRun();\n+      }\n     } catch (AbstractCompilerRunner.FlagUsageException e) {\n       System.err.println(e.getMessage());\n       result = -1;\n     } catch (Throwable t) {\n       t.printStackTrace();\n       result = -2;\n+    }\n+    if (FLAG_compute_phase_ordering.get()) {\n+      runTimeStats.outputBestPhaseOrdering();\n     }\n     System.exit(result);\n   }\n       JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\n       inputList.toArray(inputs);\n       result = compiler.compile(externs, inputs, options);\n+    }\n+\n+    return processResults(result, modules, options);\n+  }\n+\n+  /**\n+   * Processes the results of the compile job, and returns an error code.\n+   */\n+  int processResults(Result result, JSModule[] modules, B options)\n+       throws FlagUsageException, IOException {\n+    if (FLAG_compute_phase_ordering.get()) {\n+      return 0;\n     }\n \n     if (FLAG_print_ast.get()) {\n           \"--define flag syntax invalid: \" + override);\n     }\n   }\n+\n+  private class RunTimeStats {\n+    private long bestRunTime = Long.MAX_VALUE;\n+    private long worstRunTime = Long.MIN_VALUE;\n+    private long lastStartTime = 0;\n+    private List<List<String>> loopedPassesInBestRun = null;\n+\n+    /**\n+     * Record the start of a run.\n+     */\n+    private void recordStartRun() {\n+      lastStartTime = System.currentTimeMillis();\n+      PhaseOptimizer.clearLoopsRun();\n+    }\n+\n+    /**\n+     * Record the end of a run.\n+     */\n+    private void recordEndRun() {\n+      long endTime = System.currentTimeMillis();\n+      long length = endTime - lastStartTime;\n+      worstRunTime = Math.max(length, worstRunTime);\n+      if (length < bestRunTime) {\n+        loopedPassesInBestRun = PhaseOptimizer.getLoopsRun();\n+        bestRunTime = length;\n+      }\n+    }\n+\n+    /**\n+     * Print the best phase loop to stderr.\n+     */\n+    private void outputBestPhaseOrdering() {\n+      out.println(\"Best time: \" + bestRunTime);\n+      out.println(\"Worst time: \" + worstRunTime);\n+\n+      int i = 1;\n+      for (List<String> loop : loopedPassesInBestRun) {\n+        out.println(\"\\nLoop \" + i + \":\\n\" + Join.join(\"\\n\", loop));\n+        i++;\n+      }\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   }\n \n   /**\n+   * Whether the warnings guard in this Options object disables the given\n+   * group of warnings.\n+   */\n+  boolean disables(DiagnosticGroup type) {\n+    return warningsGuard != null && warningsGuard.disables(type);\n+  }\n+\n+  /**\n    * Configure the given type of warning to the given level.\n    */\n   public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     // This pass should run before types are assigned.\n     if (options.processObjectPropertyString) {\n       checks.add(objectPropertyStringPreprocess);\n+    }\n+\n+    // DiagnosticGroups override the plain checkTypes option.\n+    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes = true;\n+    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n+      options.checkTypes = false;\n     }\n \n     // Type-checking already does more accurate method arity checking, so don't\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   // New groups should be added to this list if they are public and should\n   // be listed on the command-line as an available option.\n   static final String DIAGNOSTIC_GROUP_NAMES = \"accessControls, checkVars, \" +\n-      \"deprecated, fileoverviewTags, invalidCasts, missingProperties, \" +\n-      \"nonStandardJsDocs, strictModuleDepCheck, undefinedVars, \" +\n-      \"unknownDefines, visibility\";\n+      \"checkTypes, deprecated, fileoverviewTags, invalidCasts, \" +\n+      \"missingProperties, nonStandardJsDocs, strictModuleDepCheck, \" +\n+      \"undefinedVars, unknownDefines, visibility\";\n \n   public static DiagnosticGroup DEPRECATED = DiagnosticGroups\n       .registerGroup(\"deprecated\",\n               VarCheck.UNDEFINED_VAR_ERROR,\n               SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR));\n \n+  public static DiagnosticGroup CHECK_TYPES =\n+      DiagnosticGroups.registerGroup(\"checkTypes\",\n+          new DiagnosticGroup(\n+              TypeValidator.ALL_DIAGNOSTICS,\n+              TypeCheck.ALL_DIAGNOSTICS));\n+\n   /**\n    * Adds warning levels by name.\n    */\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n import com.google.javascript.rhino.Node;\n \n import java.util.List;\n+import java.util.Random;\n import java.util.logging.Logger;\n-\n \n /**\n  * Optimizes the order of compiler passes.\n   private String currentPassName = null;\n   private PassFactory sanityCheck = null;\n \n+  // The following static properties are only used for computing optimal\n+  // phase orderings. They should not be touched by normal compiler runs.\n+  private static boolean randomizeLoops = false;\n+  private static List<List<String>> loopsRun = Lists.newArrayList();\n+\n   PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker) {\n     this.compiler = compiler;\n     this.tracker = tracker;\n     compiler.addChangeHandler(recentChange);\n+  }\n+\n+  /**\n+   * Randomizes loops. This should only be used when computing optimal phase\n+   * orderings.\n+   */\n+  static void randomizeLoops() {\n+    randomizeLoops = true;\n+  }\n+\n+  /**\n+   * Get the phase ordering of loops during this run.\n+   * Returns an empty list when the loops are not randomized.\n+   */\n+  static List<List<String>> getLoopsRun() {\n+    return loopsRun;\n+  }\n+\n+  /**\n+   * Clears the phase ordering of loops during this run.\n+   */\n+  static void clearLoopsRun() {\n+    loopsRun.clear();\n   }\n \n   /**\n    * of PhaseOptimizer.\n    */\n   private class LoopInternal extends Loop {\n-    private List<CompilerPass> myPasses = Lists.newArrayList();\n+    private final List<NamedPass> myPasses = Lists.newArrayList();\n \n     @Override\n     void addLoopedPass(PassFactory factory) {\n       myPasses.add(new PassFactoryDelegate(compiler, factory));\n     }\n \n+    /**\n+     * Gets the pass names, in order.\n+     */\n+    private List<String> getPassOrder() {\n+      List<String> order = Lists.newArrayList();\n+      for (NamedPass pass : myPasses) {\n+        order.add(pass.name);\n+      }\n+      return order;\n+    }\n+\n     public void process(Node externs, Node root) {\n       Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n       loopMutex = true;\n+      if (randomizeLoops) {\n+        List<NamedPass> mixedupPasses = Lists.newArrayList();\n+        Random random = new Random();\n+        while (myPasses.size() > 0) {\n+          mixedupPasses.add(\n+              myPasses.remove(random.nextInt(myPasses.size())));\n+        }\n+        myPasses.addAll(mixedupPasses);\n+      }\n \n       try {\n         // TODO(nicksantos): Use a smarter algorithm that dynamically adjusts\n         // the order that passes are run in.\n         int count = 0;\n-        do {\n+        out: do {\n           if (count++ > MAX_LOOPS) {\n             compiler.throwInternalError(OPTIMIZE_LOOP_ERROR, null);\n           }\n           for (CompilerPass pass : myPasses) {\n             pass.process(externs, root);\n             if (hasHaltingErrors()) {\n-              return;\n+              break out;\n             }\n           }\n \n         } while (recentChange.hasCodeChanged() && !hasHaltingErrors());\n+\n+        if (randomizeLoops) {\n+          loopsRun.add(getPassOrder());\n+        }\n       } finally {\n         loopMutex = false;\n       }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n   // User warnings\n   //\n \n+  protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT =\n+      \"overriding prototype with non-object\";\n+\n   // TODO(user): make all the non private messages private once the\n   // TypedScopeCreator has been merged with the type checker.\n   static final DiagnosticType DETERMINISTIC_TEST =\n           \"JSC_NOT_A_CONSTRUCTOR\",\n           \"cannot instantiate non-constructor\");\n \n-  protected static final String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT =\n-      \"overriding prototype with non-object\";\n-\n   static final DiagnosticType BIT_OPERATION =\n       DiagnosticType.warning(\n           \"JSC_BAD_TYPE_FOR_BIT_OPERATION\",\n           \"JSC_ILLEGAL_IMPLICIT_CAST\",\n           \"Illegal annotation on {0}. @implicitCast may only be used in \" +\n           \"externs.\");\n+\n+  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n+      DETERMINISTIC_TEST,\n+      DETERMINISTIC_TEST_NO_RESULT,\n+      INEXISTENT_ENUM_ELEMENT,\n+      INEXISTENT_PROPERTY,\n+      NOT_A_CONSTRUCTOR,\n+      BIT_OPERATION,\n+      NOT_CALLABLE,\n+      CONSTRUCTOR_NOT_CALLABLE,\n+      FUNCTION_MASKS_VARIABLE,\n+      MULTIPLE_VAR_DEF,\n+      ENUM_DUP,\n+      ENUM_NOT_CONSTANT,\n+      INTERFACE_FUNCTION_MEMBERS_ONLY,\n+      INTERFACE_FUNCTION_NOT_EMPTY,\n+      CONFLICTING_EXTENDED_TYPE,\n+      BAD_IMPLEMENTED_TYPE,\n+      HIDDEN_SUPERCLASS_PROPERTY,\n+      HIDDEN_INTERFACE_PROPERTY,\n+      HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n+      HIDDEN_INTERFACE_PROPERTY_MISMATCH,\n+      UNKNOWN_OVERRIDE,\n+      INTERFACE_METHOD_OVERRIDE,\n+      UNKNOWN_EXPR_TYPE,\n+      UNRESOLVED_TYPE,\n+      WRONG_ARGUMENT_COUNT,\n+      ILLEGAL_IMPLICIT_CAST);\n \n   private final AbstractCompiler compiler;\n   private final TypeValidator validator;\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       DiagnosticType.warning(\n           \"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\",\n           \"property {0} on interface {1} is not implemented by type {2}\");\n+\n+  static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n+      INVALID_CAST,\n+      TYPE_MISMATCH_WARNING,\n+      MISSING_EXTENDS_TAG_WARNING,\n+      DUP_VAR_DECLARATION,\n+      HIDDEN_PROPERTY_MISMATCH,\n+      INTERFACE_METHOD_NOT_IMPLEMENTED);\n \n   TypeValidator(AbstractCompiler compiler) {\n     this.compiler = compiler;\n--- a/src/com/google/javascript/jscomp/WarningLevel.java\n+++ b/src/com/google/javascript/jscomp/WarningLevel.java\n     options.checkGlobalThisLevel = CheckLevel.WARNING;\n     options.checkSymbols = true;\n \n-    // checkTypes and checkFunctions have the side-effect of asserting that the\n+    // checkTypes has the side-effect of asserting that the\n     // correct number of arguments are passed to a function.\n     // Because the CodingConvention used with the web service does not provide a\n     // way for optional arguments to be specified, these warnings may result in\n     // false positives.\n     options.checkTypes = true;\n-    options.checkFunctions = CheckLevel.WARNING;\n-\n-    options.checkMethods = CheckLevel.WARNING;\n     options.checkGlobalNamesLevel = CheckLevel.WARNING;\n     options.aggressiveVarCheck = CheckLevel.WARNING;\n   }\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/BasicErrorManagerTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Pair;\n+import com.google.javascript.jscomp.BasicErrorManager.LeveledJSErrorComparator;\n+import com.google.javascript.jscomp.CheckLevel;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests {@link BasicErrorManager}.\n+ *\n+*\n+ */\n+public class BasicErrorManagerTest extends TestCase {\n+  private static final String NULL_SOURCE = null;\n+\n+  private LeveledJSErrorComparator comparator = new LeveledJSErrorComparator();\n+\n+  static final CheckLevel E = CheckLevel.ERROR;\n+\n+  private static final DiagnosticType FOO_TYPE =\n+      DiagnosticType.error(\"TEST_FOO\", \"Foo\");\n+\n+  private static final DiagnosticType JOO_TYPE =\n+      DiagnosticType.error(\"TEST_JOO\", \"Joo\");\n+\n+  public void testOrderingBothNull() throws Exception {\n+    assertEquals(0, comparator.compare(null, null));\n+  }\n+\n+  public void testOrderingSourceName1() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(\"a\", -1, -1, FOO_TYPE);\n+\n+    assertSmaller(error(e1), error(e2));\n+  }\n+\n+  public void testOrderingSourceName2() throws Exception {\n+    JSError e1 = JSError.make(\"a\", -1, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(\"b\", -1, -1, FOO_TYPE);\n+\n+    assertSmaller(error(e1), error(e2));\n+  }\n+\n+  public void testOrderingLineno1() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(NULL_SOURCE, 2, -1, FOO_TYPE);\n+\n+    assertSmaller(error(e1), error(e2));\n+  }\n+\n+  public void testOrderingLineno2() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, 8, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(NULL_SOURCE, 56, -1, FOO_TYPE);\n+    assertSmaller(error(e1), error(e2));\n+  }\n+\n+  public void testOrderingCheckLevel() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE);\n+\n+    assertSmaller(warning(e1), error(e2));\n+  }\n+\n+  public void testOrderingCharno1() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, 5, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(NULL_SOURCE, 5, 2, FOO_TYPE);\n+\n+    assertSmaller(error(e1), error(e2));\n+    // CheckLevel preempts charno comparison\n+    assertSmaller(warning(e1), error(e2));\n+  }\n+\n+  public void testOrderingCharno2() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, 8, 7, FOO_TYPE);\n+    JSError e2 = JSError.make(NULL_SOURCE, 8, 5, FOO_TYPE);\n+\n+    assertSmaller(error(e2), error(e1));\n+    // CheckLevel preempts charno comparison\n+    assertSmaller(warning(e2), error(e1));\n+  }\n+\n+  public void testOrderingDescription() throws Exception {\n+    JSError e1 = JSError.make(NULL_SOURCE, -1, -1, FOO_TYPE);\n+    JSError e2 = JSError.make(NULL_SOURCE, -1, -1, JOO_TYPE);\n+\n+    assertSmaller(error(e1), error(e2));\n+  }\n+\n+  private Pair<JSError, CheckLevel> error(JSError e) {\n+    return Pair.of(e, CheckLevel.ERROR);\n+  }\n+\n+  private Pair<JSError, CheckLevel> warning(JSError e) {\n+    return Pair.of(e, CheckLevel.WARNING);\n+  }\n+\n+  private void assertSmaller(Pair<JSError, CheckLevel> p1,\n+      Pair<JSError, CheckLevel> p2) {\n+    int p1p2 = comparator.compare(p1, p2);\n+    assertTrue(Integer.toString(p1p2), p1p2 < 0);\n+    int p2p1 = comparator.compare(p2, p1);\n+    assertTrue(Integer.toString(p2p1), p2p1 > 0);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for {@link CheckPathsBetweenNodes}.\n+ * \n+*\n+ */\n+public class CheckPathsBetweenNodesTest extends TestCase {\n+\n+  /**\n+   * Predicate satisfied by strings with a given prefix.\n+   */\n+  private static class PrefixPredicate implements Predicate<String> {\n+    String prefix;\n+\n+    PrefixPredicate(String prefix) {\n+      this.prefix = prefix;\n+    }\n+\n+    @Override\n+    public boolean apply(String input) {\n+      return input.startsWith(prefix);\n+    }\n+  }\n+\n+  private static final Predicate<String> FALSE = Predicates.alwaysFalse();\n+  \n+  private static final Predicate<DiGraphEdge<String, String>> ALL_EDGE =\n+      Predicates.alwaysTrue();\n+\n+  private static final Predicate<DiGraphEdge<String, String>> NO_EDGE =\n+    Predicates.alwaysFalse();\n+\n+  /** Tests straight-line graphs. */\n+  public void testSimple() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.createDirectedGraphNode(\"d\");\n+\n+    g.connect(\"a\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"c\");\n+    g.connect(\"c\", \"-\", \"d\");\n+    g.connect(\"a\", \"x\", \"d\");\n+\n+    CheckPathsBetweenNodes<String, String> test = null;\n+\n+    // Simple case: the sole path from a to d has a matching node.\n+    assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"b\"), edgeIs(\"-\")));\n+    //Test two edge cases where satisfying node is the first and last node on\n+    // the path.\n+    assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), edgeIs(\"-\")));\n+    assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"d\"), edgeIs(\"-\")));\n+\n+    // Traverse no edges, so no paths.\n+    assertGood(createTest(g, \"a\", \"d\", FALSE, NO_EDGE));\n+\n+    // No path with matching edges contains b.\n+    assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"b\"), edgeIs(\"x\")));\n+  }\n+\n+  /**\n+   * Tests a graph where some paths between the nodes are valid and others\n+   * are invalid.\n+   */\n+  public void testSomeValidPaths() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.createDirectedGraphNode(\"d\");\n+    g.createDirectedGraphNode(\"e\");\n+\n+    g.connect(\"a\", \"1\", \"b\");\n+    g.connect(\"b\", \"2\", \"c\");\n+    g.connect(\"b\", \"3\", \"e\");\n+    g.connect(\"e\", \"4\", \"d\");\n+    g.connect(\"c\", \"5\", \"d\");\n+\n+    assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"c\"), ALL_EDGE));\n+    assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"z\"), ALL_EDGE));\n+  }\n+\n+  /** Tests a graph with many valid paths. */\n+  public void testManyValidPaths() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c1\");\n+    g.createDirectedGraphNode(\"c2\");\n+    g.createDirectedGraphNode(\"c3\");\n+    DiGraphNode<String, String> d = g.createDirectedGraphNode(\"d\");\n+\n+    g.connect(\"a\",  \"-\", \"b\");\n+    g.connect(\"b\",  \"-\", \"c1\");\n+    g.connect(\"b\",  \"-\", \"c2\");\n+    g.connect(\"c2\", \"-\", \"d\");\n+    g.connect(\"c1\", \"-\", \"d\");\n+    g.connect(\"a\",  \"-\", \"c3\");\n+    g.connect(\"c3\", \"-\", \"d\");\n+\n+    assertGood(createTest(g, \"a\", \"d\", new PrefixPredicate(\"c\"), ALL_EDGE));\n+  }\n+\n+  /** Tests a graph with some cycles. */\n+  public void testCycles1() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.createDirectedGraphNode(\"d\");\n+    g.createDirectedGraphNode(\"e\");\n+    g.createDirectedGraphNode(\"f\");\n+\n+    g.connect(\"a\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"c\");\n+    g.connect(\"c\", \"-\", \"d\");\n+    g.connect(\"d\", \"-\", \"e\");\n+    g.connect(\"e\", \"-\", \"f\");\n+    g.connect(\"f\", \"-\", \"b\");\n+\n+    assertGood(createTest(g, \"a\", \"e\", Predicates.equalTo(\"b\"), ALL_EDGE));\n+    assertGood(createTest(g, \"a\", \"e\", Predicates.equalTo(\"c\"), ALL_EDGE));\n+    assertGood(createTest(g, \"a\", \"e\", Predicates.equalTo(\"d\"), ALL_EDGE));\n+    assertGood(createTest(g, \"a\", \"e\", Predicates.equalTo(\"e\"), ALL_EDGE));\n+    assertBad(createTest(g, \"a\", \"e\", Predicates.equalTo(\"f\"), ALL_EDGE));\n+  }\n+  \n+  /**\n+   * Tests another graph with cycles. The topology of this graph was inspired\n+   * by a control flow graph that was being incorrectly analyzed by an early\n+   * version of CheckPathsBetweenNodes.\n+   */\n+  public void testCycles2() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.createDirectedGraphNode(\"d\");\n+    \n+    g.connect(\"a\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"c\");\n+    g.connect(\"c\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"d\");\n+    \n+    assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), ALL_EDGE));\n+    assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"z\"), ALL_EDGE));\n+  }\n+  \n+  /**\n+   * Tests another graph with cycles. The topology of this graph was inspired\n+   * by a control flow graph that was being incorrectly analyzed by an early\n+   * version of CheckPathsBetweenNodes.\n+   */\n+  public void testCycles3() {\n+    DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n+    g.createDirectedGraphNode(\"a\");\n+    g.createDirectedGraphNode(\"b\");\n+    g.createDirectedGraphNode(\"c\");\n+    g.createDirectedGraphNode(\"d\");\n+    \n+    g.connect(\"a\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"c\");\n+    g.connect(\"c\", \"-\", \"b\");\n+    g.connect(\"b\", \"-\", \"d\");\n+    g.connect(\"c\", \"-\", \"d\");\n+    \n+    assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), ALL_EDGE));\n+    assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"z\"), ALL_EDGE));\n+  }\n+  \n+  private static <N, E> void assertGood(CheckPathsBetweenNodes<N, E> test) {\n+    assertTrue(test.allPathsSatisfyPredicate());\n+  }\n+  \n+  private static <N, E> void assertBad(CheckPathsBetweenNodes<N, E> test) {\n+    assertFalse(test.allPathsSatisfyPredicate());\n+  }\n+\n+  private static CheckPathsBetweenNodes<String, String> createTest(\n+      DiGraph<String, String> graph,\n+      String entry,\n+      String exit,\n+      Predicate<String> nodePredicate,\n+      Predicate<DiGraphEdge<String, String>> edgePredicate) {\n+    return new CheckPathsBetweenNodes<String, String>(graph,\n+        graph.getDirectedGraphNode(entry), graph.getDirectedGraphNode(exit),\n+        nodePredicate, edgePredicate);\n+  }\n+  \n+  private static Predicate<DiGraphEdge<String, String>>\n+      edgeIs(final Object val) {\n+    return new Predicate<DiGraphEdge<String, String>>() {\n+      @Override\n+      public boolean apply(DiGraphEdge<String, String> input) {\n+        return input.getValue().equals(val);\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ClosureReverseAbstractInterpreterTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+public class ClosureReverseAbstractInterpreterTest extends\n+    CompilerTypeTestCase {\n+\n+  public void testGoogIsDef1() throws Exception {\n+    testClosureFunction(\"goog.isDef\",\n+        createOptionalType(NUMBER_TYPE),\n+        NUMBER_TYPE,\n+        createOptionalType(NUMBER_TYPE));\n+  }\n+\n+  public void testGoogIsDef2() throws Exception {\n+    testClosureFunction(\"goog.isDef\",\n+        createNullableType(NUMBER_TYPE),\n+        createNullableType(NUMBER_TYPE),\n+        createNullableType(NUMBER_TYPE));\n+  }\n+\n+  public void testGoogIsNull1() throws Exception {\n+    testClosureFunction(\"goog.isNull\",\n+        createOptionalType(NUMBER_TYPE),\n+        NULL_TYPE,\n+        createOptionalType(NUMBER_TYPE));\n+  }\n+\n+  public void testGoogIsNull2() throws Exception {\n+    testClosureFunction(\"goog.isNull\",\n+        createNullableType(NUMBER_TYPE),\n+        NULL_TYPE,\n+        NUMBER_TYPE);\n+  }\n+\n+  public void testGoogIsDefAndNotNull1() throws Exception {\n+    testClosureFunction(\"goog.isDefAndNotNull\",\n+        createOptionalType(NUMBER_TYPE),\n+        NUMBER_TYPE,\n+        createOptionalType(NUMBER_TYPE));\n+  }\n+\n+  public void testGoogIsDefAndNotNull2() throws Exception {\n+    testClosureFunction(\"goog.isDefAndNotNull\",\n+        createNullableType(NUMBER_TYPE),\n+        NUMBER_TYPE,\n+        createNullableType(NUMBER_TYPE));\n+  }\n+\n+  public void testGoogIsDefAndNotNull3() throws Exception {\n+    testClosureFunction(\"goog.isDefAndNotNull\",\n+        createOptionalType(createNullableType(NUMBER_TYPE)),\n+        NUMBER_TYPE,\n+        createOptionalType(createNullableType(NUMBER_TYPE)));\n+  }\n+\n+  public void testGoogIsString1() throws Exception {\n+    testClosureFunction(\"goog.isString\",\n+        createNullableType(STRING_TYPE),\n+        STRING_TYPE,\n+        NULL_TYPE);\n+  }\n+\n+  public void testGoogIsString2() throws Exception {\n+    testClosureFunction(\"goog.isString\",\n+        createNullableType(NUMBER_TYPE),\n+        createNullableType(NUMBER_TYPE),\n+        createNullableType(NUMBER_TYPE));\n+  }\n+\n+  public void testGoogIsBoolean1() throws Exception {\n+    testClosureFunction(\"goog.isBoolean\",\n+        createNullableType(BOOLEAN_TYPE),\n+        BOOLEAN_TYPE,\n+        NULL_TYPE);\n+  }\n+\n+  public void testGoogIsBoolean2() throws Exception {\n+    testClosureFunction(\"goog.isBoolean\",\n+        createUnionType(BOOLEAN_TYPE, STRING_TYPE, NO_OBJECT_TYPE),\n+        BOOLEAN_TYPE,\n+        createUnionType(STRING_TYPE, NO_OBJECT_TYPE));\n+  }\n+\n+  public void testGoogIsNumber() throws Exception {\n+    testClosureFunction(\"goog.isNumber\",\n+        createNullableType(NUMBER_TYPE),\n+        NUMBER_TYPE,\n+        NULL_TYPE);\n+  }\n+\n+  public void testGoogIsFunction() throws Exception {\n+    testClosureFunction(\"goog.isFunction\",\n+        createNullableType(OBJECT_FUNCTION_TYPE),\n+        OBJECT_FUNCTION_TYPE,\n+        NULL_TYPE);\n+  }\n+\n+  public void testGoogIsArray() throws Exception {\n+    testClosureFunction(\"goog.isArray\",\n+        OBJECT_TYPE,\n+        ARRAY_TYPE,\n+        OBJECT_TYPE);\n+  }\n+\n+  private void testClosureFunction(String function, JSType type,\n+      JSType trueType, JSType falseType) {\n+    // function(a) where a : type\n+    Node n = compiler.parseTestCode(\"var a; \" + function + \"(a)\");\n+    Node call = n.getLastChild().getLastChild();\n+    Node name = call.getLastChild();\n+\n+    Scope scope = new SyntacticScopeCreator(compiler).createScope(n, null);\n+    FlowScope flowScope = LinkedFlowScope.createEntryLattice(scope);\n+\n+    assertEquals(Token.CALL, call.getType());\n+    assertEquals(Token.NAME, name.getType());\n+\n+    GoogleCodingConvention convention = new GoogleCodingConvention();\n+    flowScope.inferSlotType(\"a\", type);\n+    ClosureReverseAbstractInterpreter rai =\n+        new ClosureReverseAbstractInterpreter(convention, registry);\n+\n+    // trueScope\n+    assertEquals(trueType,\n+        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, true)\n+        .getSlot(\"a\").getType());\n+\n+    // falseScope\n+    assertEquals(falseType,\n+        rai.getPreciserScopeKnowingConditionOutcome(call, flowScope, false)\n+        .getSlot(\"a\").getType());\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n   };\n \n   @Override\n-  public void setUp() {\n+  public void setUp() throws Exception {\n+    super.setUp();\n     Flags.disableStateCheckingForTest();\n     Flags.resetAllFlagsForTest();\n     lastCompiler = null;\n   }\n \n   @Override\n-  public void tearDown() {\n+  public void tearDown() throws Exception {\n     Flags.resetAllFlagsForTest();\n+\n     // NOTE(nicksantos): ANT needs this for some weird reason.\n     AbstractCompilerRunner.FLAG_define.resetForTest();\n+    AbstractCompilerRunner.FLAG_jscomp_off.resetForTest();\n+    AbstractCompilerRunner.FLAG_jscomp_warning.resetForTest();\n+    AbstractCompilerRunner.FLAG_jscomp_error.resetForTest();\n+\n     Flags.enableStateCheckingForTest();\n+    super.tearDown();\n   }\n \n   public void testTypeCheckingOffByDefault() {\n   public void testTypeCheckingOnWithVerbose() {\n     CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n     test(\"function f(x) { return x; } f();\", TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n+  public void testTypeCheckOverride1() {\n+    CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    CompilerRunner.FLAG_jscomp_off.setForTest(\n+        Lists.newArrayList(\"checkTypes\"));\n+    testSame(\"var x = x || {}; x.f = function() {}; x.f(3);\");\n+  }\n+\n+  public void testTypeCheckOverride2() {\n+    CompilerRunner.FLAG_warning_level.setForTest(WarningLevel.QUIET);\n+    CompilerRunner.FLAG_jscomp_warning.setForTest(\n+        Lists.newArrayList(\"checkTypes\"));\n+    test(\"var x = x || {}; x.f = function() {}; x.f(3);\",\n+         TypeCheck.WRONG_ARGUMENT_COUNT);\n   }\n \n   public void testCheckSymbolsOffForDefault() {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import static com.google.javascript.jscomp.ConcreteType.ALL;\n+import static com.google.javascript.jscomp.ConcreteType.NONE;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;\n+import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\n+import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType;\n+import com.google.javascript.jscomp.ConcreteType.Factory;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.StaticScope;\n+import com.google.javascript.rhino.jstype.StaticSlot;\n+import com.google.javascript.rhino.testing.TestErrorReporter;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Unit test for the the subclasses of ConcreteType.\n+ *\n+*\n+ */\n+public class ConcreteTypeTest extends TestCase {\n+  private JSTypeRegistry typeRegistry;\n+  private JSType unknownType;\n+  private Factory factory;\n+\n+  @Override\n+  public void setUp() {\n+    typeRegistry = new JSTypeRegistry(new TestErrorReporter(null, null));\n+    unknownType = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+    factory = new FakeFactory();\n+  }\n+\n+  private void checkEquality(List<ConcreteType> types) {\n+    for (int i = 0; i < types.size(); ++i) {\n+      for (int j = 0; j < types.size(); ++j) {\n+        if (i == j) {\n+          assertEquals(types.get(i), types.get(j));\n+        } else {\n+          assertFalse(types.get(i).equals(types.get(j)));\n+        }\n+      }\n+    }\n+  }\n+\n+  public void testEquals() {\n+    ConcreteFunctionType fun1 = createFunction(\"fun1\");\n+    ConcreteFunctionType fun2 = createFunction(\"fun2\");\n+    ConcreteType obj1 = fun1.getInstanceType();\n+    ConcreteType obj2 = fun2.getInstanceType();\n+    ConcreteType union1 = new ConcreteUnionType(fun1, fun2);\n+    ConcreteType union2 = new ConcreteUnionType(fun1, obj1);\n+    ConcreteType union3 = new ConcreteUnionType(fun1, obj1);\n+\n+    checkEquality(Lists.newArrayList(fun1, fun2, obj1, obj2,\n+                                     union1, union2));\n+\n+    assertEquals(union2, union3);\n+  }\n+\n+  public void testUnionWith() {\n+    ConcreteFunctionType fun = createFunction(\"fun\");\n+    ConcreteType obj = fun.getInstanceType();\n+    ConcreteType both = new ConcreteUnionType(fun, obj);\n+\n+    assertTrue(fun.isSingleton());\n+    assertTrue(obj.isSingleton());\n+    assertFalse(both.isSingleton());\n+    assertFalse(NONE.isSingleton());\n+    assertFalse(ALL.isSingleton());\n+\n+    checkUnionWith(fun, NONE, fun);\n+    checkUnionWith(fun, ALL, ALL);\n+\n+    checkUnionWith(fun, obj, both);\n+    checkUnionWith(both, NONE, both);\n+    checkUnionWith(both, ALL, ALL);\n+  }\n+\n+  private void checkUnionWith(ConcreteType a, ConcreteType b, ConcreteType c) {\n+    assertEquals(a, a.unionWith(a));\n+    assertEquals(b, b.unionWith(b));\n+    assertEquals(c, a.unionWith(b));\n+    assertEquals(c, b.unionWith(a));\n+  }\n+\n+  public void testIntersectionWith() {\n+    ConcreteFunctionType fun = createFunction(\"fun\");\n+    ConcreteFunctionType fun2 = createFunction(\"fun2\");\n+    ConcreteType obj = fun.getInstanceType();\n+    ConcreteType both = new ConcreteUnionType(fun, obj);\n+\n+    assertEquals(NONE, fun.intersectWith(obj));\n+    assertEquals(NONE, obj.intersectWith(fun));\n+\n+    assertEquals(fun, both.intersectWith(fun));\n+    assertEquals(fun, fun.intersectWith(both));\n+\n+    assertEquals(NONE, NONE.intersectWith(both));\n+    assertEquals(NONE, both.intersectWith(NONE));\n+    assertEquals(NONE, fun.intersectWith(NONE));\n+    assertEquals(NONE, NONE.intersectWith(fun));\n+\n+    assertEquals(NONE, both.intersectWith(fun2));\n+\n+    assertEquals(both, ALL.intersectWith(both));\n+    assertEquals(both, both.intersectWith(ALL));\n+    assertEquals(fun, ALL.intersectWith(fun));\n+    assertEquals(fun, fun.intersectWith(ALL));\n+    assertEquals(NONE, ALL.intersectWith(NONE));\n+    assertEquals(NONE, NONE.intersectWith(ALL));\n+  }\n+\n+  public void testFunction() {\n+    ConcreteFunctionType fun = createFunction(\"fun\", \"a\", \"b\");\n+    assertTrue(fun.isFunction());\n+    assertNotNull(fun.getCallSlot());\n+    assertNotNull(fun.getReturnSlot());\n+    assertNotNull(fun.getParameterSlot(0));\n+    assertNotNull(fun.getParameterSlot(1));\n+    assertNull(fun.getParameterSlot(2));\n+    assertTrue(fun.getInstanceType().isInstance());\n+  }\n+\n+  public void testInstance() {\n+    ConcreteInstanceType obj = createInstance(\"MyObj\", \"a\", \"b\");\n+    assertTrue(obj.isInstance());\n+    assertNotNull(obj.getPropertySlot(\"a\"));\n+    assertNotNull(obj.getPropertySlot(\"b\"));\n+    assertNull(obj.getPropertySlot(\"c\"));\n+\n+    // The prototype chain should be: MyObj -> MyObj.prototype -> Object ->\n+    // Object.prototype -> {...}.prototype -> null.\n+    for (int i = 0; i < 4; ++i) {\n+      assertNotNull(obj = obj.getImplicitPrototype());\n+      assertTrue(obj.isInstance());\n+    }\n+    assertNull(obj.getImplicitPrototype());\n+  }\n+\n+  public void testGetX() {\n+    ConcreteFunctionType fun1 = createFunction(\"fun1\");\n+    ConcreteFunctionType fun2 = createFunction(\"fun2\");\n+    ConcreteInstanceType obj1 = fun1.getInstanceType();\n+    ConcreteInstanceType obj2 = fun2.getInstanceType();\n+    ConcreteType union1 = fun1.unionWith(obj1);\n+    ConcreteType union2 =\n+        union1.unionWith(fun2).unionWith(obj2);\n+\n+    assertEqualSets(Lists.newArrayList(), NONE.getFunctions());\n+    assertEqualSets(Lists.newArrayList(), NONE.getInstances());\n+    assertEqualSets(Lists.newArrayList(fun1), fun1.getFunctions());\n+    assertEqualSets(Lists.newArrayList(), fun1.getInstances());\n+    assertEqualSets(Lists.newArrayList(), obj1.getFunctions());\n+    assertEqualSets(Lists.newArrayList(obj1), obj1.getInstances());\n+\n+    assertEqualSets(Lists.newArrayList(fun1), union1.getFunctions());\n+    assertEqualSets(Lists.newArrayList(obj1), union1.getInstances());\n+\n+    assertEqualSets(Lists.newArrayList(fun1, fun2), union2.getFunctions());\n+    assertEqualSets(Lists.newArrayList(obj1, obj2), union2.getInstances());\n+  }\n+\n+  /** Checks that the two collections are equal as sets. */\n+  private void assertEqualSets(Collection<?> first, Collection<?> second) {\n+    assertEquals(Sets.newHashSet(first), Sets.newHashSet(second));\n+  }\n+\n+  /** Creates a fake function with the given description. */\n+  private ConcreteFunctionType createFunction(\n+      String name, String... paramNames) {\n+    Node args = new Node(Token.LP);\n+    for (int i = 0; i < paramNames.length; ++i) {\n+      args.addChildToBack(Node.newString(Token.NAME, paramNames[i]));\n+    }\n+\n+    Node decl = new Node(Token.FUNCTION,\n+                         Node.newString(Token.NAME, name),\n+                         args,\n+                         new Node(Token.BLOCK));\n+\n+    JSType[] paramTypes = new JSType[paramNames.length];\n+    Arrays.fill(paramTypes, unknownType);\n+    decl.setJSType(\n+        typeRegistry.createConstructorType(name, decl, args, unknownType));\n+\n+    return new ConcreteFunctionType(factory, decl, null);\n+  }\n+\n+  /** Creates a fake instance with the given description. */\n+  private ConcreteInstanceType createInstance(\n+      String name, String... propNames) {\n+    ObjectType objType = typeRegistry.createObjectType(name, null,\n+        typeRegistry.createObjectType(name + \".prototype\", null, null));\n+    for (int i = 0; i < propNames.length; ++i) {\n+      objType.defineDeclaredProperty(propNames[i], unknownType, false);\n+    }\n+    return new ConcreteInstanceType(factory, objType);\n+  }\n+\n+  private class FakeFactory implements Factory {\n+    private final Map<Node, ConcreteFunctionType> functionByDeclaration =\n+        Maps.newHashMap();\n+    private final Map<FunctionType, ConcreteFunctionType> functionByJSType =\n+        Maps.newHashMap();\n+    private final Map<ObjectType, ConcreteInstanceType> instanceByJSType =\n+        Maps.newHashMap();\n+\n+    private final JSTypeRegistry registry = new JSTypeRegistry(\n+        new TestErrorReporter(null, null));\n+\n+    public JSTypeRegistry getTypeRegistry() {\n+      return registry;\n+    }\n+\n+    /** @inheritDoc */\n+    public ConcreteFunctionType createConcreteFunction(\n+        Node decl, StaticScope<ConcreteType> parent) {\n+      ConcreteFunctionType funcType = functionByDeclaration.get(decl);\n+      if (funcType == null) {\n+        functionByDeclaration.put(decl, funcType =\n+            new ConcreteFunctionType(this, decl, parent));\n+        if (decl.getJSType() != null) {\n+          functionByJSType.put((FunctionType) decl.getJSType(), funcType);\n+        }\n+      }\n+      return funcType;\n+    }\n+\n+    /** @inheritDoc */\n+    public ConcreteInstanceType createConcreteInstance(\n+        ObjectType instanceType) {\n+      ConcreteInstanceType instType = instanceByJSType.get(instanceType);\n+      if (instType == null) {\n+        instanceByJSType.put(instanceType,\n+            instType = new ConcreteInstanceType(this, instanceType));\n+      }\n+      return instType;\n+    }\n+\n+    /** @inheritDoc */\n+    public ConcreteFunctionType getConcreteFunction(FunctionType functionType) {\n+      return functionByJSType.get(functionType);\n+    }\n+\n+    /** @inheritDoc */\n+    public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) {\n+      return instanceByJSType.get(instanceType);\n+    }\n+\n+    /** @inheritDoc */\n+    public StaticScope<ConcreteType> createFunctionScope(\n+        Node decl, StaticScope<ConcreteType> parent) {\n+      FakeScope scope = new FakeScope((FakeScope) parent);\n+      scope.addSlot(ConcreteFunctionType.CALL_SLOT_NAME);\n+      scope.addSlot(ConcreteFunctionType.THIS_SLOT_NAME);\n+      scope.addSlot(ConcreteFunctionType.RETURN_SLOT_NAME);\n+      for (Node n = decl.getFirstChild().getNext().getFirstChild();\n+           n != null;\n+           n = n.getNext()) {\n+        scope.addSlot(n.getString());\n+      }\n+      return scope;\n+    }\n+\n+    /** @inheritDoc */\n+    public StaticScope<ConcreteType> createInstanceScope(\n+        ObjectType instanceType) {\n+      FakeScope parentScope = null;\n+      if (instanceType.getImplicitPrototype() != null) {\n+        ConcreteInstanceType prototype =\n+            createConcreteInstance(instanceType.getImplicitPrototype());\n+        parentScope = (FakeScope) prototype.getScope();\n+      }\n+\n+      FakeScope scope = new FakeScope(parentScope);\n+      for (String propName : instanceType.getOwnPropertyNames()) {\n+        scope.addSlot(propName);\n+      }\n+      return scope;\n+    }\n+  }\n+\n+  // TODO(user): move to a common place if it can be used elsewhere\n+  private class FakeScope implements StaticScope<ConcreteType> {\n+    private final FakeScope parent;\n+    private final Map<String, FakeSlot> slots = Maps.newHashMap();\n+\n+    FakeScope(FakeScope parent) {\n+      this.parent = parent;\n+    }\n+\n+    /** @inheritDoc */\n+    public StaticScope<ConcreteType> getParentScope() { return parent; }\n+\n+    /** @inheritDoc */\n+    public StaticSlot<ConcreteType> getOwnSlot(String name) {\n+      return slots.get(name);\n+    }\n+\n+    /** @inheritDoc */\n+    public StaticSlot<ConcreteType> getSlot(String name) {\n+      if (slots.containsKey(name)) {\n+        return slots.get(name);\n+      } else if (parent != null) {\n+        return parent.getSlot(name);\n+      } else {\n+        return null;\n+      }\n+    }\n+\n+    /** @inheritDoc */\n+    public ConcreteType getTypeOfThis() { return ConcreteType.ALL; }\n+\n+    void addSlot(String name) {\n+      slots.put(name, new FakeSlot(name));\n+    }\n+  }\n+\n+  // TODO(user): move to a common place if it can be used elsewhere\n+  private class FakeSlot implements StaticSlot<ConcreteType> {\n+    private final String name;\n+\n+    FakeSlot(String name) {\n+      this.name = name;\n+    }\n+\n+    /* @inheritDoc */\n+    public String getName() { return name; }\n+\n+    /* @inheritDoc */\n+    public ConcreteType getType() { return ConcreteType.ALL; }\n+\n+    /* @inheritDoc */\n+    public boolean isTypeInferred() { return true; }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n+import com.google.javascript.jscomp.DataFlowAnalysis.BinaryJoinOp;\n+import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n+import com.google.javascript.jscomp.DataFlowAnalysis.BranchedForwardDataFlowAnalysis;\n+import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n+import com.google.javascript.jscomp.DataFlowAnalysis.LatticeElement;\n+import com.google.javascript.jscomp.DataFlowAnalysis.MaxIterationsExceededException;\n+import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A test suite with a very small programming language that has two types of\n+ * instructions: {@link BranchInstruction} and {@link ArithmeticInstruction}.\n+ * Test cases must construct a small program with these instructions and\n+ * manually put each instruction in a {@code ControlFlowGraph}.\n+ *\n+*\n+ */\n+public class DataFlowAnalysisTest extends TestCase {\n+\n+  /**\n+   * Operations supported by ArithmeticInstruction.\n+   */\n+  enum Operation {\n+    ADD(\"+\"), SUB(\"-\"), DIV(\"/\"), MUL(\"*\");\n+    private final String stringRep;\n+\n+    private Operation(String stringRep) {\n+      this.stringRep = stringRep;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return stringRep;\n+    }\n+  }\n+\n+  /**\n+   * A simple value.\n+   */\n+  abstract static class Value {\n+\n+    boolean isNumber() {\n+      return this instanceof Number;\n+    }\n+\n+    boolean isVariable() {\n+      return this instanceof Variable;\n+    }\n+  }\n+\n+  /**\n+   * A variable.\n+   */\n+  static class Variable extends Value {\n+    private String name;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param n Name of the variable.\n+     */\n+    Variable(String n) {\n+      name = n;\n+    }\n+\n+    String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+      // Use the String's .equals()\n+      if (!(other instanceof Variable)) {\n+        return false;\n+      }\n+      return ((Variable) other).name.equals(name);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return name.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return this.name;\n+    }\n+  }\n+\n+  /**\n+   * A number constant.\n+   */\n+  static class Number extends Value {\n+    private int value;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param v Value\n+     */\n+    Number(int v) {\n+      value = v;\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"\" + value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return value;\n+    }\n+  }\n+\n+  /**\n+   * An instruction of the dummy program.\n+   */\n+  abstract static class Instruction {\n+\n+    int order = 0;\n+\n+    /**\n+     * Check whether this is an arithmetic instruction.\n+     *\n+     * @return {@code true} if it is an arithmetic instruction.\n+     */\n+    boolean isArithmetic() {\n+      return this instanceof ArithmeticInstruction;\n+    }\n+\n+    /**\n+     * Check whether this is a branch instruction.\n+     *\n+     * @return {@code true} if it is a branch instruction.\n+     */\n+    boolean isBranch() {\n+      return this instanceof BranchInstruction;\n+    }\n+  }\n+\n+  /**\n+   * Basic arithmetic instruction that only takes the form of:\n+   *\n+   * <pre>\n+   * Result = Operand1 operator Operand2\n+   * </pre>\n+   */\n+  static class ArithmeticInstruction extends Instruction {\n+    private Operation operation;\n+    private Value operand1;\n+    private Value operand2;\n+    private Variable result;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param res Result.\n+     * @param op1 First Operand.\n+     * @param o Operator.\n+     * @param op2 Second Operand.\n+     */\n+    ArithmeticInstruction(Variable res, int op1, Operation o, int op2) {\n+      this(res, new Number(op1), o, new Number(op2));\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param res Result.\n+     * @param op1 First Operand.\n+     * @param o Operator.\n+     * @param op2 Second Operand.\n+     */\n+    ArithmeticInstruction(Variable res, Value op1, Operation o, int op2) {\n+      this(res, op1, o, new Number(op2));\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param res Result.\n+     * @param op1 First Operand.\n+     * @param o Operator.\n+     * @param op2 Second Operand.\n+     */\n+    ArithmeticInstruction(Variable res, int op1, Operation o, Value op2) {\n+      this(res, new Number(op1), o, op2);\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param res Result.\n+     * @param op1 First Operand.\n+     * @param o Operator.\n+     * @param op2 Second Operand.\n+     */\n+    ArithmeticInstruction(Variable res, Value op1, Operation o, Value op2) {\n+      result = res;\n+      operand1 = op1;\n+      operand2 = op2;\n+      operation = o;\n+    }\n+\n+    Operation getOperator() {\n+      return operation;\n+    }\n+\n+    void setOperator(Operation op) {\n+      this.operation = op;\n+    }\n+\n+    Value getOperand1() {\n+      return operand1;\n+    }\n+\n+    void setOperand1(Value operand1) {\n+      this.operand1 = operand1;\n+    }\n+\n+    Value getOperand2() {\n+      return operand2;\n+    }\n+\n+    void setOperand2(Value operand2) {\n+      this.operand2 = operand2;\n+    }\n+\n+    Variable getResult() {\n+      return result;\n+    }\n+\n+    void setResult(Variable result) {\n+      this.result = result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuilder out = new StringBuilder();\n+      out.append(result);\n+      out.append(\" = \");\n+      out.append(operand1);\n+      out.append(operation);\n+      out.append(operand2);\n+      return out.toString();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return toString().hashCode();\n+    }\n+  }\n+\n+  public static ArithmeticInstruction\n+      newAssignNumberToVariableInstruction(Variable res, int num) {\n+    return new ArithmeticInstruction(res, num, Operation.ADD, 0);\n+  }\n+\n+  public static ArithmeticInstruction\n+      newAssignVariableToVariableInstruction(Variable lhs, Variable rhs) {\n+    return new ArithmeticInstruction(lhs, rhs, Operation.ADD, 0);\n+  }\n+\n+  /**\n+   * Branch instruction based on a {@link Value} as a condition.\n+   */\n+  static class BranchInstruction extends Instruction {\n+    private Value condition;\n+\n+    BranchInstruction(Value cond) {\n+      condition = cond;\n+    }\n+\n+    Value getCondition() {\n+      return condition;\n+    }\n+\n+    void setCondition(Value condition) {\n+      this.condition = condition;\n+    }\n+  }\n+\n+  /**\n+   * A lattice to represent constant states. Each variable of the program will\n+   * have a lattice defined as:\n+   *\n+   * <pre>\n+   *        TOP\n+   *   / / |         \\\n+   *  0  1 2 3 ..... MAX_VALUE\n+   *  \\  \\ |         /\n+   *       BOTTOM\n+   * </pre>\n+   *\n+   * Where BOTTOM represents the variable is not a constant.\n+   * <p>\n+   * This class will represent a product lattice of each variable's lattice. The\n+   * whole lattice is store in a {@code HashMap}. If variable {@code x} is\n+   * defined to be constant 10. The map will contain the value 10 with the\n+   * variable {@code x} as key. Otherwise, {@code x} is not a constant.\n+   */\n+  private static class ConstPropLatticeElement implements LatticeElement {\n+    private final Map<Variable, Integer> constMap;\n+    private final boolean isTop;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param isTop To define if the lattice is top.\n+     * @param constMap A map from name to constant variable.\n+     */\n+    ConstPropLatticeElement(\n+        boolean isTop, Map<Variable, Integer> constMap) {\n+      this.isTop = isTop;\n+      this.constMap = constMap;\n+    }\n+\n+    ConstPropLatticeElement(boolean isTop) {\n+      this.isTop = isTop;\n+      this.constMap = Maps.newHashMap();\n+    }\n+\n+    /**\n+     * Create a lattice where every variable is defined to be not constant.\n+     */\n+    ConstPropLatticeElement() {\n+      this(false);\n+    }\n+\n+    ConstPropLatticeElement(ConstPropLatticeElement other) {\n+      this.isTop = other.isTop;\n+      this.constMap = Maps.newHashMap(other.constMap);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      if (isTop) {\n+        return \"TOP\";\n+      }\n+      StringBuilder out = new StringBuilder();\n+\n+      out.append(\"{\");\n+      for (Variable var : constMap.keySet()) {\n+        out.append(var);\n+        out.append(\"=\");\n+        out.append(constMap.get(var));\n+        out.append(\" \");\n+      }\n+      out.append(\"}\");\n+      return out.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+      if (other instanceof ConstPropLatticeElement) {\n+        ConstPropLatticeElement otherLattice = (ConstPropLatticeElement) other;\n+        return (this.isTop == otherLattice.isTop) &&\n+            this.constMap.equals(otherLattice.constMap);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  private static class ConstPropJoinOp\n+      extends BinaryJoinOp<ConstPropLatticeElement> {\n+\n+    @Override\n+    public ConstPropLatticeElement apply(ConstPropLatticeElement a,\n+        ConstPropLatticeElement b) {\n+      ConstPropLatticeElement result = new ConstPropLatticeElement();\n+      // By the definition of TOP of the lattice.\n+      if (a.isTop) {\n+        return new ConstPropLatticeElement(a);\n+      }\n+      if (b.isTop) {\n+        return new ConstPropLatticeElement(b);\n+      }\n+      // Do the join for each variable's lattice.\n+      for (Variable var : a.constMap.keySet()) {\n+        if (b.constMap.containsKey(var)) {\n+          Integer number = b.constMap.get(var);\n+\n+          // The result will contain that variable as a known constant\n+          // if both lattice has that variable the same constant.\n+          if (a.constMap.get(var).equals(number)) {\n+            result.constMap.put(var, number);\n+          }\n+        }\n+      }\n+      return result;\n+    }\n+  }\n+\n+  /**\n+   * A simple forward constant propagation.\n+   */\n+  static class DummyConstPropagation extends\n+      DataFlowAnalysis<Instruction, ConstPropLatticeElement> {\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param targetCfg Control Flow Graph.\n+     */\n+    DummyConstPropagation(ControlFlowGraph<Instruction> targetCfg) {\n+      super(targetCfg, new ConstPropJoinOp());\n+    }\n+\n+    @Override\n+    boolean isForward() {\n+      return true;\n+    }\n+\n+    @Override\n+    ConstPropLatticeElement flowThrough(Instruction node,\n+        ConstPropLatticeElement input) {\n+      if (node.isBranch()) {\n+        return new ConstPropLatticeElement(input);\n+      } else {\n+        return flowThroughArithmeticInstruction((ArithmeticInstruction) node,\n+            input);\n+      }\n+    }\n+\n+    @Override\n+    ConstPropLatticeElement createEntryLattice() {\n+      return new ConstPropLatticeElement();\n+    }\n+\n+    @Override\n+    ConstPropLatticeElement createInitialEstimateLattice() {\n+      return new ConstPropLatticeElement(true);\n+    }\n+  }\n+\n+  static ConstPropLatticeElement flowThroughArithmeticInstruction(\n+      ArithmeticInstruction aInst, ConstPropLatticeElement input) {\n+\n+    ConstPropLatticeElement out = new ConstPropLatticeElement(input);\n+    // Try to see if left is a number. If it is a variable, it might already\n+    // be a constant coming in.\n+    Integer leftConst = null;\n+    if (aInst.operand1.isNumber()) {\n+      leftConst = ((Number) aInst.operand1).value;\n+    } else {\n+      if (input.constMap.containsKey(aInst.operand1)) {\n+        leftConst = input.constMap.get(aInst.operand1);\n+      }\n+    }\n+\n+    // Do the same thing to the right.\n+    Integer rightConst = null;\n+    if (aInst.operand2.isNumber()) {\n+      rightConst = ((Number) aInst.operand2).value;\n+    } else {\n+      if (input.constMap.containsKey(aInst.operand2)) {\n+        rightConst = input.constMap.get(aInst.operand2);\n+      }\n+    }\n+\n+    // If both are known constant we can perform the operation.\n+    if (leftConst != null && rightConst != null) {\n+      Integer constResult = null;\n+      if (aInst.operation == Operation.ADD) {\n+        constResult = leftConst.intValue() + rightConst.intValue();\n+      } else if (aInst.operation == Operation.SUB) {\n+        constResult = leftConst.intValue() - rightConst.intValue();\n+      } else if (aInst.operation == Operation.MUL) {\n+        constResult = leftConst.intValue() * rightConst.intValue();\n+      } else if (aInst.operation == Operation.DIV) {\n+        constResult = leftConst.intValue() / rightConst.intValue();\n+      }\n+      // Put it in the map. (Possibly replacing the existing constant value)\n+      out.constMap.put(aInst.result, constResult);\n+    } else {\n+      // If we cannot find a constant for it\n+      out.constMap.remove(aInst.result);\n+    }\n+    return out;\n+  }\n+\n+  public void testSimpleIf() {\n+    // if (a) { b = 1; } else { b = 1; } c = b;\n+    Variable a = new Variable(\"a\");\n+    Variable b = new Variable(\"b\");\n+    Variable c = new Variable(\"c\");\n+    Instruction inst1 = new BranchInstruction(a);\n+    Instruction inst2 = newAssignNumberToVariableInstruction(b, 1);\n+    Instruction inst3 = newAssignNumberToVariableInstruction(b, 1);\n+    Instruction inst4 = newAssignVariableToVariableInstruction(c, b);\n+    ControlFlowGraph<Instruction> cfg =\n+      new ControlFlowGraph<Instruction>(inst1);\n+    GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1);\n+    GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2);\n+    GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3);\n+    GraphNode<Instruction, Branch> n4 = cfg.createNode(inst4);\n+    cfg.connect(inst1, ControlFlowGraph.Branch.ON_FALSE, inst2);\n+    cfg.connect(inst1, ControlFlowGraph.Branch.ON_TRUE, inst3);\n+    cfg.connect(inst2, ControlFlowGraph.Branch.UNCOND, inst4);\n+    cfg.connect(inst3, ControlFlowGraph.Branch.UNCOND, inst4);\n+\n+    DummyConstPropagation constProp = new DummyConstPropagation(cfg);\n+    constProp.analyze();\n+\n+    // We cannot conclude anything from if (a).\n+    verifyInHas(n1, a, null);\n+    verifyInHas(n1, b, null);\n+    verifyInHas(n1, c, null);\n+    verifyOutHas(n1, a, null);\n+    verifyOutHas(n1, b, null);\n+    verifyOutHas(n1, c, null);\n+\n+    // We can conclude b = 1 after the instruction.\n+    verifyInHas(n2, a, null);\n+    verifyInHas(n2, b, null);\n+    verifyInHas(n2, c, null);\n+    verifyOutHas(n2, a, null);\n+    verifyOutHas(n2, b, 1);\n+    verifyOutHas(n2, c, null);\n+\n+    // Same as above.\n+    verifyInHas(n3, a, null);\n+    verifyInHas(n3, b, null);\n+    verifyInHas(n3, c, null);\n+    verifyOutHas(n3, a, null);\n+    verifyOutHas(n3, b, 1);\n+    verifyOutHas(n3, c, null);\n+\n+    // After the merge we should still have b = 1.\n+    verifyInHas(n4, a, null);\n+    verifyInHas(n4, b, 1);\n+    verifyInHas(n4, c, null);\n+    verifyOutHas(n4, a, null);\n+    // After the instruction both b and c are 1.\n+    verifyOutHas(n4, b, 1);\n+    verifyOutHas(n4, c, 1);\n+  }\n+\n+  public void testSimpleLoop() {\n+    // a = 0; do { a = a + 1 } while (b); c = a;\n+    Variable a = new Variable(\"a\");\n+    Variable b = new Variable(\"b\");\n+    Variable c = new Variable(\"c\");\n+    Instruction inst1 = newAssignNumberToVariableInstruction(a, 0);\n+    Instruction inst2 = new ArithmeticInstruction(a, a, Operation.ADD, 1);\n+    Instruction inst3 = new BranchInstruction(b);\n+    Instruction inst4 = newAssignVariableToVariableInstruction(c, a);\n+    ControlFlowGraph<Instruction> cfg =\n+      new ControlFlowGraph<Instruction>(inst1);\n+    GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1);\n+    GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2);\n+    GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3);\n+    GraphNode<Instruction, Branch> n4 = cfg.createNode(inst4);\n+    cfg.connect(inst1, ControlFlowGraph.Branch.UNCOND, inst2);\n+    cfg.connect(inst2, ControlFlowGraph.Branch.UNCOND, inst3);\n+    cfg.connect(inst3, ControlFlowGraph.Branch.ON_TRUE, inst2);\n+    cfg.connect(inst3, ControlFlowGraph.Branch.ON_FALSE, inst4);\n+\n+    DummyConstPropagation constProp = new DummyConstPropagation(cfg);\n+    // This will also show that the framework terminates properly.\n+    constProp.analyze();\n+\n+    // a = 0 is the only thing we know.\n+    verifyInHas(n1, a, null);\n+    verifyInHas(n1, b, null);\n+    verifyInHas(n1, c, null);\n+    verifyOutHas(n1, a, 0);\n+    verifyOutHas(n1, b, null);\n+    verifyOutHas(n1, c, null);\n+\n+    // Nothing is provable in this program, so confirm that we haven't\n+    // erroneously \"proven\" something.\n+    verifyInHas(n2, a, null);\n+    verifyInHas(n2, b, null);\n+    verifyInHas(n2, c, null);\n+    verifyOutHas(n2, a, null);\n+    verifyOutHas(n2, b, null);\n+    verifyOutHas(n2, c, null);\n+\n+    verifyInHas(n3, a, null);\n+    verifyInHas(n3, b, null);\n+    verifyInHas(n3, c, null);\n+    verifyOutHas(n3, a, null);\n+    verifyOutHas(n3, b, null);\n+    verifyOutHas(n3, c, null);\n+\n+    verifyInHas(n4, a, null);\n+    verifyInHas(n4, b, null);\n+    verifyInHas(n4, c, null);\n+    verifyOutHas(n4, a, null);\n+    verifyOutHas(n4, b, null);\n+    verifyOutHas(n4, c, null);\n+  }\n+\n+  public void testLatticeArrayMinimizationWhenMidpointIsEven() {\n+    assertEquals(6, DataFlowAnalysis.BinaryJoinOp.computeMidPoint(12));\n+  }\n+\n+  public void testLatticeArrayMinimizationWhenMidpointRoundsDown() {\n+    assertEquals(8, DataFlowAnalysis.BinaryJoinOp.computeMidPoint(18));\n+  }\n+\n+  public void testLatticeArrayMinimizationWithTwoElements() {\n+    assertEquals(1, DataFlowAnalysis.BinaryJoinOp.computeMidPoint(2));\n+  }\n+\n+\n+  /**\n+   * A simple forward constant propagation.\n+   */\n+  static class BranchedDummyConstPropagation extends\n+      BranchedForwardDataFlowAnalysis<Instruction, ConstPropLatticeElement> {\n+\n+    BranchedDummyConstPropagation(ControlFlowGraph<Instruction> targetCfg) {\n+      super(targetCfg, new ConstPropJoinOp());\n+    }\n+\n+    @Override\n+    ConstPropLatticeElement flowThrough(Instruction node,\n+        ConstPropLatticeElement input) {\n+      if (node.isArithmetic()) {\n+        return flowThroughArithmeticInstruction(\n+            (ArithmeticInstruction) node, input);\n+      } else {\n+        return new ConstPropLatticeElement(input);\n+      }\n+    }\n+\n+    @Override\n+    List<ConstPropLatticeElement> branchedFlowThrough(Instruction node,\n+        ConstPropLatticeElement input) {\n+      List<ConstPropLatticeElement> result = Lists.newArrayList();\n+      List<DiGraphEdge<Instruction, Branch>> outEdges = \n+        getCfg().getOutEdges(node);\n+      if (node.isArithmetic()) {\n+        assertTrue(outEdges.size() < 2);\n+        ConstPropLatticeElement aResult = flowThroughArithmeticInstruction(\n+            (ArithmeticInstruction) node, input);\n+        for (DiGraphEdge<Instruction, Branch> _ : outEdges) {\n+          result.add(aResult);\n+        }\n+      } else {\n+        BranchInstruction branchInst = (BranchInstruction) node;\n+        for (DiGraphEdge<Instruction, Branch> branch : outEdges) {\n+          ConstPropLatticeElement edgeResult =\n+            new ConstPropLatticeElement(input);\n+          if (branch.getValue() == Branch.ON_FALSE &&\n+              branchInst.getCondition().isVariable()) {\n+            edgeResult.constMap.put((Variable) branchInst.getCondition(), 0);\n+          }\n+          result.add(edgeResult);\n+        }\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    ConstPropLatticeElement createEntryLattice() {\n+      return new ConstPropLatticeElement();\n+    }\n+\n+    @Override\n+    ConstPropLatticeElement createInitialEstimateLattice() {\n+      return new ConstPropLatticeElement(true);\n+    }\n+  }\n+\n+  public void testBranchedSimpleIf() {\n+    // if (a) { a = 0; } else { b = 0; } c = b;\n+    Variable a = new Variable(\"a\");\n+    Variable b = new Variable(\"b\");\n+    Variable c = new Variable(\"c\");\n+    Instruction inst1 = new BranchInstruction(a);\n+    Instruction inst2 = newAssignNumberToVariableInstruction(a, 0);\n+    Instruction inst3 = newAssignNumberToVariableInstruction(b, 0);\n+    Instruction inst4 = newAssignVariableToVariableInstruction(c, b);\n+    ControlFlowGraph<Instruction> cfg =\n+      new ControlFlowGraph<Instruction>(inst1);\n+    GraphNode<Instruction, Branch> n1 = cfg.createNode(inst1);\n+    GraphNode<Instruction, Branch> n2 = cfg.createNode(inst2);\n+    GraphNode<Instruction, Branch> n3 = cfg.createNode(inst3);\n+    GraphNode<Instruction, Branch> n4 = cfg.createNode(inst4);\n+    cfg.connect(inst1, ControlFlowGraph.Branch.ON_TRUE, inst2);\n+    cfg.connect(inst1, ControlFlowGraph.Branch.ON_FALSE, inst3);\n+    cfg.connect(inst2, ControlFlowGraph.Branch.UNCOND, inst4);\n+    cfg.connect(inst3, ControlFlowGraph.Branch.UNCOND, inst4);\n+\n+    BranchedDummyConstPropagation constProp =\n+        new BranchedDummyConstPropagation(cfg);\n+    constProp.analyze();\n+\n+    // We cannot conclude anything from if (a).\n+    verifyBranchedInHas(n1, a, null);\n+    verifyBranchedInHas(n1, b, null);\n+    verifyBranchedInHas(n1, c, null);\n+\n+    // Nothing is known on the true branch.\n+    verifyBranchedInHas(n2, a, null);\n+    verifyBranchedInHas(n2, b, null);\n+    verifyBranchedInHas(n2, c, null);\n+\n+    // Verify that we have a = 0 on the false branch.\n+    verifyBranchedInHas(n3, a, 0);\n+    verifyBranchedInHas(n3, b, null);\n+    verifyBranchedInHas(n3, c, null);\n+\n+    // After the merge we should still have a = 0.\n+    verifyBranchedInHas(n4, a, 0);\n+  }\n+\n+  public void testMaxIterationsExceededException() {\n+    final int MAX_STEP = 10;\n+    Variable a = new Variable(\"a\");\n+    Instruction inst1 = new ArithmeticInstruction(a, a, Operation.ADD, a);\n+    ControlFlowGraph<Instruction> cfg =\n+      new ControlFlowGraph<Instruction>(inst1) {\n+      @Override\n+      public Comparator<DiGraphNode<Instruction, Branch>>\n+          getOptionalNodeComparator(boolean isForward) {\n+        return new Comparator<DiGraphNode<Instruction, Branch>>() {\n+          @Override\n+          public int compare(DiGraphNode<Instruction, Branch> o1,\n+              DiGraphNode<Instruction, Branch> o2) {\n+            return o1.getValue().order - o2.getValue().order;\n+          }\n+        };\n+      }\n+    };\n+    cfg.createNode(inst1);\n+\n+    // We have MAX_STEP + 1 nodes, it is impossible to finish the analysis with\n+    // MAX_STEP number of steps.\n+    for (int i = 0; i < MAX_STEP + 1; i++) {\n+      Instruction inst2 = new ArithmeticInstruction(a, a, Operation.ADD, a);\n+      cfg.createNode(inst2);\n+      inst2.order = i + 1;\n+      cfg.connect(inst1, ControlFlowGraph.Branch.UNCOND, inst2);\n+      inst1 = inst2;\n+    }\n+    DummyConstPropagation constProp = new DummyConstPropagation(cfg);\n+    try {\n+      constProp.analyze(MAX_STEP);\n+      fail(\"Expected MaxIterationsExceededException to be thrown.\");\n+    } catch (MaxIterationsExceededException e) {\n+      assertEquals(e.getMessage(), \"Analysis did not terminate after \"\n+          + MAX_STEP + \" iterations\");\n+    }\n+  }\n+\n+  static void verifyInHas(GraphNode<Instruction, Branch> node, Variable var,\n+      Integer constant) {\n+    FlowState<ConstPropLatticeElement> fState = node.getAnnotation();\n+    assertEquals(constant, fState.getIn().constMap.get(var));\n+  }\n+\n+  static void verifyOutHas(GraphNode<Instruction, Branch> node, Variable var,\n+      Integer constant) {\n+    FlowState<ConstPropLatticeElement> fState = node.getAnnotation();\n+    assertEquals(constant, fState.getOut().constMap.get(var));\n+  }\n+\n+  static void verifyBranchedInHas(GraphNode<Instruction, Branch> node,\n+      Variable var, Integer constant) {\n+    BranchedFlowState<ConstPropLatticeElement> fState = node.getAnnotation();\n+    assertEquals(constant, fState.getIn().constMap.get(var));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/DiagnosticGroupTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for DiagnosticGroup.\n+*\n+ */\n+public class DiagnosticGroupTest extends TestCase {\n+\n+  public void testRegistration() throws Exception {\n+    DiagnosticGroups dg = new DiagnosticGroups();\n+    assertEquals(DiagnosticGroups.DEPRECATED,\n+        dg.forName(\"deprecated\"));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/DotFormatterTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import junit.framework.TestCase;\n+\n+public class DotFormatterTest extends TestCase {\n+  /**\n+   * Tests that keys are assigned sequentially.\n+   */\n+  public void testKeyAssignementSequential() throws Exception {\n+    DotFormatter dot = DotFormatter.newInstanceForTesting();\n+    assertEquals(0, dot.key(new Node(Token.BLOCK)));\n+    assertEquals(1, dot.key(new Node(Token.BLOCK)));\n+    assertEquals(2, dot.key(new Node(Token.BLOCK)));\n+    assertEquals(3, dot.key(new Node(Token.BLOCK)));\n+    assertEquals(4, dot.key(new Node(Token.BLOCK)));\n+  }\n+\n+  /**\n+   * Tests that keys are assigned once per node.\n+   */\n+  public void testKeyAssignementOncePerNode() throws Exception {\n+    DotFormatter dot = DotFormatter.newInstanceForTesting();\n+    Node node0 = new Node(Token.BLOCK);\n+    Node node1 = new Node(Token.BLOCK);\n+    Node node2 = new Node(Token.BLOCK);\n+\n+    assertEquals(0, dot.key(node0));\n+    assertEquals(1, dot.key(node1));\n+    assertEquals(2, dot.key(node2));\n+    assertEquals(0, dot.key(node0));\n+    assertEquals(1, dot.key(node1));\n+    assertEquals(2, dot.key(node2));\n+  }\n+\n+  /**\n+   * Tests the formatting (simple tree).\n+   */\n+  public void testToDotSimple() throws Exception {\n+    Node ast = new Node(Token.BITOR);\n+\n+    String expected = \"digraph AST {\\n\" +\n+        \"  node [color=lightblue2, style=filled];\\n\" +\n+        \"  node0 [label=\\\"BITOR\\\"];\\n\" +\n+        \"}\\n\";\n+    test(expected, ast);\n+  }\n+\n+  /**\n+   * Tests the formatting (3 element tree).\n+   */\n+  public void testToDot3Elements() throws Exception {\n+    Node ast = new Node(Token.BLOCK);\n+    ast.addChildToBack(new Node(Token.NAME));\n+    ast.addChildToBack(new Node(Token.STRING));\n+\n+    String expected = \"digraph AST {\\n\" +\n+        \"  node [color=lightblue2, style=filled];\\n\" +\n+        \"  node0 [label=\\\"BLOCK\\\"];\\n\" +\n+        \"  node1 [label=\\\"NAME\\\"];\\n\" +\n+        \"  node0 -> node1 [weight=1];\\n\" +\n+        \"  node2 [label=\\\"STRING\\\"];\\n\" +\n+        \"  node0 -> node2 [weight=1];\\n\" +\n+        \"}\\n\";\n+    test(expected, ast);\n+  }\n+\n+  private void test(String expected, Node ast) {\n+    try {\n+      assertEquals(expected, DotFormatter.toDot(ast));\n+    } catch (java.io.IOException e) {\n+      fail(\"Tests failed with IOExceptions\");\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/FixedPointGraphTraversalTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test for FixedPointGraphTraversal.\n+*\n+ */\n+public class FixedPointGraphTraversalTest extends TestCase {\n+\n+  // The maximum value of a counter that counts as a \"change\"\n+  // to the state of the graph, for the purposes of fixed-point\n+  // computation.\n+  private int maxChange = 0;\n+\n+  private class Counter {\n+    int value = 0;\n+  }\n+\n+  private class CounterIncrementer implements EdgeCallback<Counter, String> {\n+    public boolean traverseEdge(Counter source, String e, Counter dest) {\n+      dest.value++;\n+      return dest.value <= maxChange;\n+    }\n+  }\n+\n+  private DiGraph<Counter, String> graph;\n+\n+  private Counter A, B, C, D, E;\n+  private CounterIncrementer callback = new CounterIncrementer();\n+  private FixedPointGraphTraversal<Counter, String> traversal =\n+      new FixedPointGraphTraversal<Counter, String>(callback);\n+\n+  // Create a new graph of the following form:\n+  //\n+  //     A\n+  //    / \\\n+  //   |   B\n+  //  / \\ /\n+  // C   D\n+  //  \\ /\n+  //   E\n+  //\n+  // with all edges pointing downwards, and an \"up-edge\" from E to D.\n+  @Override\n+  public void setUp() {\n+    A = new Counter();\n+    B = new Counter();\n+    C = new Counter();\n+    D = new Counter();\n+    E = new Counter();\n+\n+    graph = new LinkedDirectedGraph<Counter, String>();\n+    graph.createDirectedGraphNode(A);\n+    graph.createDirectedGraphNode(B);\n+    graph.createDirectedGraphNode(C);\n+    graph.createDirectedGraphNode(D);\n+    graph.createDirectedGraphNode(E);\n+\n+    graph.connect(A, \"->\", B);\n+    graph.connect(A, \"->\", C);\n+    graph.connect(A, \"->\", D);\n+    graph.connect(B, \"->\", D);\n+    graph.connect(C, \"->\", E);\n+    graph.connect(D, \"->\", E);\n+    graph.connect(E, \"->\", D);\n+  }\n+\n+  public void testGraph1() {\n+    maxChange = 0;\n+    traversal.computeFixedPoint(graph, A);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(1, B.value);\n+    assertEquals(1, C.value);\n+    assertEquals(1, D.value);\n+    assertEquals(0, E.value);\n+  }\n+\n+  public void testGraph2() {\n+    maxChange = 0;\n+    traversal.computeFixedPoint(graph, D);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(0, B.value);\n+    assertEquals(0, C.value);\n+    assertEquals(0, D.value);\n+    assertEquals(1, E.value);\n+  }\n+\n+  public void testGraph3() {\n+    maxChange = 1;\n+    traversal.computeFixedPoint(graph, A);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(1, B.value);\n+    assertEquals(1, C.value);\n+    assertEquals(3, D.value);\n+    assertEquals(2, E.value);\n+  }\n+\n+  public void testGraph4() {\n+    maxChange = 1;\n+    traversal.computeFixedPoint(graph, D);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(0, B.value);\n+    assertEquals(0, C.value);\n+    assertEquals(1, D.value);\n+    assertEquals(2, E.value);\n+  }\n+\n+  public void testGraph5() {\n+    maxChange = 5;\n+    traversal.computeFixedPoint(graph, A);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(1, B.value);\n+    assertEquals(1, C.value);\n+    assertEquals(6, D.value);\n+    assertEquals(5, E.value);\n+  }\n+\n+  public void testGraph6() {\n+    maxChange = 5;\n+    traversal.computeFixedPoint(graph, B);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(0, B.value);\n+    assertEquals(0, C.value);\n+    assertEquals(6, D.value);\n+    assertEquals(5, E.value);\n+  }\n+\n+  public void testGraph8() {\n+    maxChange = 2;\n+    traversal.computeFixedPoint(graph, A);\n+\n+    try {\n+      traversal = new FixedPointGraphTraversal<Counter, String>(\n+        new EdgeCallback<Counter, String>() {\n+          public boolean traverseEdge(Counter source, String e, Counter dest) {\n+            return true;\n+          }\n+        });\n+      traversal.computeFixedPoint(graph, A);\n+      fail(\"Expecting Error: \" +\n+          FixedPointGraphTraversal.NON_HALTING_ERROR_MSG);\n+    } catch (IllegalStateException e) {\n+      assertEquals(e.getMessage(),\n+          FixedPointGraphTraversal.NON_HALTING_ERROR_MSG);\n+    }\n+  }\n+\n+  public void testGraph9() {\n+    maxChange = 0;\n+\n+    // when the graph traversal is done for the whole graph, we're actually\n+    // counting the number of \"in\" edges for each node.\n+    traversal.computeFixedPoint(graph);\n+\n+    assertEquals(0, A.value);\n+    assertEquals(1, B.value);\n+    assertEquals(1, C.value);\n+    assertEquals(3, D.value);\n+    assertEquals(2, E.value);\n+  }\n+\n+  public void testGraph10() {\n+    // Test a graph with self-edges.\n+    maxChange = 5;\n+\n+    A = new Counter();\n+    B = new Counter();\n+\n+    graph = new LinkedDirectedGraph<Counter, String>();\n+    graph.createDirectedGraphNode(A);\n+    graph.createDirectedGraphNode(B);\n+\n+    graph.connect(A, \"->\", A);\n+    graph.connect(A, \"->\", B);\n+\n+    traversal.computeFixedPoint(graph);\n+\n+    assertEquals(6, A.value);\n+    assertEquals(6, B.value);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GlobalNamespaceTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.GlobalNamespace.Name;\n+import com.google.javascript.jscomp.GlobalNamespace.Ref;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for {@link GlobalNamespace}.\n+ *\n+*\n+ */\n+public class GlobalNamespaceTest extends TestCase {\n+\n+  public void testRemoveDeclaration1() {\n+    Name n = new Name(\"a\", null, false);\n+    Ref set1 = createNodelessRef(Ref.Type.SET_FROM_GLOBAL);\n+    Ref set2 = createNodelessRef(Ref.Type.SET_FROM_GLOBAL);\n+\n+    n.addRef(set1);\n+    n.addRef(set2);\n+\n+    assertEquals(set1, n.declaration);\n+    assertEquals(2, n.globalSets);\n+    assertEquals(1, n.refs.size());\n+\n+    n.removeRef(set1);\n+\n+    assertEquals(set2, n.declaration);\n+    assertEquals(1, n.globalSets);\n+    assertEquals(0, n.refs.size());\n+  }\n+\n+  public void testRemoveDeclaration2() {\n+    Name n = new Name(\"a\", null, false);\n+    Ref set1 = createNodelessRef(Ref.Type.SET_FROM_GLOBAL);\n+    Ref set2 = createNodelessRef(Ref.Type.SET_FROM_LOCAL);\n+\n+    n.addRef(set1);\n+    n.addRef(set2);\n+\n+    assertEquals(set1, n.declaration);\n+    assertEquals(1, n.globalSets);\n+    assertEquals(1, n.localSets);\n+    assertEquals(1, n.refs.size());\n+\n+    n.removeRef(set1);\n+\n+    assertEquals(null, n.declaration);\n+    assertEquals(0, n.globalSets);\n+  }\n+\n+  private Ref createNodelessRef(Ref.Type type) {\n+    return Ref.createRefForTesting(type);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GraphColoringTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.graph.Graph;\n+import com.google.javascript.jscomp.graph.GraphColoring;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n+import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.GraphColoring.Color;\n+import com.google.javascript.jscomp.graph.GraphColoring.GreedyGraphColoring;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * Tests for {@link GraphColoring}.\n+ *\n+*\n+ */\n+public class GraphColoringTest extends TestCase {\n+\n+  public void testNoEdge() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    for (int i = 0; i < 5; i++) {\n+      graph.createNode(\"Node \" + i);\n+      // All node with same color.\n+      GraphColoring<String, String> coloring =\n+          new GreedyGraphColoring<String, String>(graph);\n+      assertEquals(1, coloring.color());\n+      validateColoring(graph);\n+      for (int j = 0; j < i; j++) {\n+        assertEquals(\"Node 0\", coloring.getPartitionSuperNode(\"Node 0\"));\n+      }\n+    }\n+  }\n+\n+  public void testTwoNodesConnected() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.connect(\"A\", \"--\", \"B\");\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(2, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertEquals(\"B\", coloring.getPartitionSuperNode(\"B\"));\n+  }\n+\n+  public void testGreedy() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.connect(\"A\", \"--\", \"C\");\n+    graph.connect(\"B\", \"--\", \"C\");\n+    graph.connect(\"B\", \"--\", \"D\");\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(2, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"B\"));\n+    assertEquals(\"C\", coloring.getPartitionSuperNode(\"C\"));\n+  }\n+\n+  public void testFullyConnected() {\n+    final int count = 100;\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    for (int i = 0; i < count; i++) {\n+      graph.createNode(\"Node \" + i);\n+      for (int j = 0; j < count; j++) {\n+        graph.createNode(\"Node \" + j);\n+        if (i != j) {\n+          graph.connect(\"Node \" + i, null, \"Node \" + j);\n+        }\n+      }\n+    }\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(count, coloring.color());\n+    validateColoring(graph);\n+    for (int i = 0; i < count; i++) {\n+      assertEquals(\"Node \" + i, coloring.getPartitionSuperNode(\"Node \" + i));\n+    }\n+  }\n+\n+  public void testAllConnectedToOneNode() {\n+    final int count = 10;\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"Center\");\n+    for (int i = 0; i < count; i++) {\n+      graph.createNode(\"Node \" + i);\n+      graph.connect(\"Center\", null, \"Node \" + i);\n+    }\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph);\n+    assertEquals(2, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"Center\", coloring.getPartitionSuperNode(\"Center\"));\n+    for (int i = 0; i < count; i++) {\n+      assertEquals(\"Node 0\", coloring.getPartitionSuperNode(\"Node \" + i));\n+    }\n+  }\n+\n+  public void testTwoFullyConnected() {\n+    final int count = 100;\n+    // A graph with two disconnected disjunct cliques.\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    for (int i = 0; i < count; i++) {\n+      graph.createNode(\"Node Left \" + i);\n+      graph.createNode(\"Node Right \" + i);\n+      for (int j = 0; j < count; j++) {\n+        graph.createNode(\"Node Left \" + j);\n+        graph.createNode(\"Node Right \" + j);\n+        if (i != j) {\n+          graph.connect(\"Node Left \" + i, null, \"Node Left \" + j);\n+          graph.connect(\"Node Right \" + i, null, \"Node Right \" + j);\n+        }\n+      }\n+    }\n+    assertEquals(count, new GreedyGraphColoring<String, String>(graph).color());\n+    validateColoring(graph);\n+\n+    // Connect the two cliques.\n+    for (int i = 0; i < count; i++) {\n+      graph.connect(\"Node Left \" + i, null, \"Node Right \" + i);\n+    }\n+    // Think of two exactly same graph with the same coloring side by side.\n+    // If we circularly shift the colors of one of the graph by 1, we can\n+    // connect the isomorphic nodes and still have a valid coloring in the\n+    // resulting graph.\n+    assertEquals(count, new GreedyGraphColoring<String, String>(graph).color());\n+    validateColoring(graph);\n+  }\n+\n+  public void testDeterministic() {\n+    // A pentagon.\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    graph.createNode(\"B\");\n+    graph.createNode(\"C\");\n+    graph.createNode(\"D\");\n+    graph.createNode(\"E\");\n+    graph.connect(\"A\", \"-->\", \"B\");\n+    graph.connect(\"B\", \"-->\", \"C\");\n+    graph.connect(\"C\", \"-->\", \"D\");\n+    graph.connect(\"D\", \"-->\", \"E\");\n+    graph.connect(\"E\", \"-->\", \"A\");\n+\n+    Comparator<String> lexicographic = new Comparator<String>() {\n+      public int compare(String o1, String o2) {\n+        return o1.toString().compareTo(o2.toString());\n+      }\n+    };\n+    GraphColoring<String, String> coloring =\n+        new GreedyGraphColoring<String, String>(graph, lexicographic);\n+    assertEquals(3, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"C\"));\n+\n+    Comparator<String> biasD = new Comparator<String>() {\n+      public int compare(String o1, String o2) {\n+        if (o1.equals(\"D\")) {\n+          return -1;\n+        } else {\n+          return o1.toString().compareTo(o2.toString());\n+        }\n+      }\n+    };\n+\n+    coloring = new GreedyGraphColoring<String, String>(graph, biasD);\n+    assertEquals(3, coloring.color());\n+    validateColoring(graph);\n+    assertEquals(\"A\", coloring.getPartitionSuperNode(\"A\"));\n+    assertFalse(\"A\".equals(coloring.getPartitionSuperNode(\"C\")));\n+  }\n+\n+  /**\n+   * Validate that each node has been colored and connected nodes have different\n+   * coloring.\n+   */\n+  private static <N, E> void validateColoring(Graph<N, E> graph) {\n+    for (GraphNode<N, E> node : graph.getNodes()) {\n+      assertTrue(node.getAnnotation() != null);\n+    }\n+    for (GraphEdge<N, E> edge : graph.getEdges()) {\n+      Color c1 = edge.getNodeA().getAnnotation();\n+      Color c2 = edge.getNodeB().getAnnotation();\n+      assertTrue(c1 != null);\n+      assertTrue(c2 != null);\n+      assertTrue(!c1.equals(c2));\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GraphReachabilityTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.graph.GraphReachability;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for {@link GraphReachability}.\n+ * \n+*\n+ */\n+public class GraphReachabilityTest extends TestCase {\n+  GraphReachability<String, String> reachability = null;\n+  DiGraph<String, String> graph = null;\n+  \n+  public void testSimple() {\n+    graph = new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"A\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    \n+    graph.createNode(\"B\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    assertNotReachable(\"B\");\n+    \n+    graph.connect(\"A\", \"--->\", \"B\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"B\");\n+    assertNotReachable(\"A\");\n+    assertReachable(\"B\");\n+    \n+    graph.connect(\"B\", \"--->\", \"A\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"B\");\n+    assertReachable(\"A\");\n+    assertReachable(\"B\");\n+    \n+    graph.createNode(\"C\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    assertReachable(\"B\");\n+    assertNotReachable(\"C\");\n+\n+    graph.createNode(\"D\");\n+    graph.connect(\"C\", \"--->\", \"D\");\n+    reachability = new GraphReachability<String, String>(graph);\n+    reachability.compute(\"A\");\n+    assertReachable(\"A\");\n+    assertReachable(\"B\");\n+    assertNotReachable(\"C\");\n+    assertNotReachable(\"D\");\n+    reachability.recompute(\"C\");\n+    assertReachable(\"C\");\n+    assertReachable(\"D\");\n+  }\n+  \n+  public void assertReachable(String s) {\n+    assertSame(s + \" should be reachable\", graph.getNode(s).getAnnotation(),\n+        GraphReachability.REACHABLE);\n+  }\n+  \n+  public void assertNotReachable(String s) {\n+    assertNotSame(s + \" should not be reachable\",\n+        graph.getNode(s).getAnnotation(), GraphReachability.REACHABLE);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/GraphTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.graph.Graph;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.LinkedUndirectedGraph;\n+import com.google.javascript.jscomp.graph.Annotatable;\n+import com.google.javascript.jscomp.graph.Annotation;\n+import com.google.javascript.jscomp.graph.GraphNode;\n+import com.google.javascript.jscomp.graph.SubGraph;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.Graph.GraphEdge;\n+import com.google.javascript.jscomp.graph.UndiGraph;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Tests for the graph data structure.\n+ *\n+*\n+ */\n+public class GraphTest extends TestCase {\n+\n+  public void testDirectedSimple() {\n+    DiGraph<String, String> graph =\n+        new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.connect(\"a\", \"->\", \"b\");\n+    assertTrue(graph.hasNode(\"a\"));\n+    assertTrue(graph.hasNode(\"b\"));\n+    assertTrue(graph.hasNode(\"c\"));\n+    assertFalse(graph.hasNode(\"d\"));\n+    assertTrue(graph.isConnected(\"a\", \"b\"));\n+    assertTrue(graph.isConnected(\"b\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"c\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+    assertFalse(graph.isConnected(\"c\", \"a\"));\n+    assertFalse(graph.isConnected(\"c\", \"b\"));\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"b\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+    assertTrue(graph.isConnectedInDirection(\"a\", \"b\"));\n+    assertFalse(graph.isConnectedInDirection(\"b\", \"a\"));\n+    assertFalse(graph.isConnectedInDirection(\"a\", \"c\"));\n+    assertFalse(graph.isConnectedInDirection(\"b\", \"c\"));\n+    assertFalse(graph.isConnectedInDirection(\"c\", \"a\"));\n+    assertFalse(graph.isConnectedInDirection(\"c\", \"b\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+\n+    // Disconnect both ways.\n+    graph.connect(\"a\", \"->\", \"b\");\n+    graph.connect(\"b\", \"->\", \"a\");\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+\n+    // Disconnect one way.\n+    graph.connect(\"a\", \"->\", \"b\");\n+    graph.connect(\"b\", \"->\", \"a\");\n+    graph.disconnectInDirection(\"a\", \"b\");\n+    assertTrue(graph.isConnected(\"b\", \"a\"));\n+    assertTrue(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnectedInDirection(\"a\", \"b\"));\n+    assertTrue(graph.isConnectedInDirection(\"b\", \"a\"));\n+  }\n+\n+  public void testUndirectedSimple() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.connect(\"a\", \"--\", \"b\");\n+    assertTrue(graph.hasNode(\"a\"));\n+    assertTrue(graph.hasNode(\"b\"));\n+    assertTrue(graph.hasNode(\"c\"));\n+    assertFalse(graph.hasNode(\"d\"));\n+    assertTrue(graph.isConnected(\"a\", \"b\"));\n+    assertTrue(graph.isConnected(\"b\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"c\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+    assertFalse(graph.isConnected(\"c\", \"a\"));\n+    assertFalse(graph.isConnected(\"c\", \"b\"));\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"b\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"c\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+  }\n+\n+  public void testDirectedSelfLoop() {\n+    DiGraph<String, String> graph =\n+        new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.connect(\"a\", \"->\", \"a\");\n+    assertTrue(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+    assertTrue(graph.isConnectedInDirection(\"a\", \"a\"));\n+    assertFalse(graph.isConnectedInDirection(\"a\", \"b\"));\n+    assertFalse(graph.isConnectedInDirection(\"b\", \"a\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+\n+    // Disconnect both ways.\n+    graph.connect(\"a\", \"->\", \"a\");\n+    graph.disconnect(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+\n+    // Disconnect one way.\n+    graph.connect(\"a\", \"->\", \"a\");\n+    graph.disconnectInDirection(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+  }\n+\n+  public void testUndirectedSelfLoop() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.connect(\"a\", \"--\", \"a\");\n+    assertTrue(graph.isConnected(\"a\", \"a\"));\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+    assertFalse(graph.isConnected(\"b\", \"a\"));\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"a\");\n+    assertFalse(graph.isConnected(\"a\", \"a\"));\n+  }\n+\n+  public void testDirectedInAndOutEdges() {\n+    DiGraph<String, String> graph =\n+        new LinkedDirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.createNode(\"d\");\n+    graph.connect(\"a\", \"->\", \"b\");\n+    graph.connect(\"a\", \"-->\", \"b\");\n+    graph.connect(\"a\", \"--->\", \"b\");\n+    graph.connect(\"a\", \"->\", \"c\");\n+    graph.connect(\"c\", \"->\", \"d\");\n+    assertSetEquals(graph.getDirectedSuccNodes(\"a\"), \"b\", \"c\");\n+    assertSetEquals(graph.getDirectedPredNodes(\"b\"), \"a\");\n+    assertSetEquals(graph.getDirectedPredNodes(\"c\"), \"a\");\n+    assertListCount(graph.getDirectedSuccNodes(\"a\"), \"b\", 3);\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+  }\n+\n+  public void testUndirectedNeighbors() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.createNode(\"d\");\n+    graph.connect(\"a\", \"-\", \"b\");\n+    graph.connect(\"a\", \"--\", \"b\");\n+    graph.connect(\"a\", \"---\", \"b\");\n+    graph.connect(\"a\", \"-\", \"c\");\n+    graph.connect(\"c\", \"-\", \"d\");\n+    assertSetEquals(graph.getNeighborNodes(\"a\"), \"b\", \"c\");\n+    assertSetEquals(graph.getNeighborNodes(\"b\"), \"a\");\n+    assertSetEquals(graph.getNeighborNodes(\"c\"), \"a\", \"d\");\n+    assertListCount(graph.getNeighborNodes(\"a\"), \"b\", 3);\n+\n+    // Removal.\n+    graph.disconnect(\"a\", \"b\");\n+    assertFalse(graph.isConnected(\"a\", \"b\"));\n+  }\n+\n+  public void testNodeAnnotations() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    GraphNode<String, String> a = graph.createNode(\"a\");\n+    GraphNode<String, String> b = graph.createNode(\"b\");\n+    checkAnnotations(graph, a, b);\n+  }\n+\n+  public void testEdgeAnnotations() {\n+    Graph<String, String> graph = new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"1\");\n+    graph.createNode(\"2\");\n+    graph.createNode(\"3\");\n+    graph.connect(\"1\", \"a\", \"2\");\n+    graph.connect(\"2\", \"b\", \"3\");\n+    GraphEdge<String, String> a = graph.getEdges(\"1\", \"2\").get(0);\n+    GraphEdge<String, String> b = graph.getEdges(\"2\", \"3\").get(0);\n+    checkAnnotations(graph, a, b);\n+  }\n+\n+  private static void checkAnnotations(\n+      Graph<String, String> graph, Annotatable a, Annotatable b) {\n+    final Annotation A = new Annotation() {};\n+    final Annotation B = new Annotation() {};\n+\n+    // Initially null.\n+    assertNull(a.getAnnotation());\n+    assertNull(b.getAnnotation());\n+\n+    // Test basic setting.\n+    a.setAnnotation(A);\n+    b.setAnnotation(B);\n+    assertSame(A, a.getAnnotation());\n+    assertSame(B, b.getAnnotation());\n+\n+    // Test clearing.\n+    graph.clearEdgeAnnotations();\n+    graph.clearNodeAnnotations();\n+    assertNull(a.getAnnotation());\n+    assertNull(b.getAnnotation());\n+\n+    a.setAnnotation(A);\n+    b.setAnnotation(B);\n+    // Pushing clears.\n+    graph.pushEdgeAnnotations();\n+    graph.pushNodeAnnotations();\n+    assertNull(a.getAnnotation());\n+    assertNull(b.getAnnotation());\n+    a.setAnnotation(B);\n+    b.setAnnotation(B);\n+    graph.pushEdgeAnnotations();\n+    graph.pushNodeAnnotations();\n+    a.setAnnotation(B);\n+    b.setAnnotation(A);\n+\n+    // Test restoring then restoring old values with pop.\n+    assertSame(B, a.getAnnotation());\n+    assertSame(A, b.getAnnotation());\n+    graph.popEdgeAnnotations();\n+    graph.popNodeAnnotations();\n+    assertSame(B, a.getAnnotation());\n+    assertSame(B, b.getAnnotation());\n+    graph.popEdgeAnnotations();\n+    graph.popNodeAnnotations();\n+    assertSame(A, a.getAnnotation());\n+    assertSame(B, b.getAnnotation());\n+  }\n+\n+  public void testDegree() {\n+    testDirectedDegree(new LinkedDirectedGraph<String, String>());\n+    testDirectedDegree(new LinkedUndirectedGraph<String, String>());\n+  }\n+\n+  public void testDirectedDegree(Graph<String, String> graph) {\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.createNode(\"d\");\n+    assertEquals(0, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"a\", \"-\", \"b\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"b\", \"-\", \"c\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"a\", \"-\", \"c\");\n+    assertEquals(2, graph.getNodeDegree(\"a\"));\n+    graph.connect(\"d\", \"-\", \"a\");\n+    assertEquals(3, graph.getNodeDegree(\"a\"));\n+  }\n+\n+  public void testDirectedConnectIfNotFound() {\n+    testDirectedConnectIfNotFound(new LinkedDirectedGraph<String, String>());\n+    testDirectedConnectIfNotFound(new LinkedUndirectedGraph<String, String>());\n+  }\n+\n+  public void testDirectedConnectIfNotFound(Graph<String, String> graph) {\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.connectIfNotFound(\"a\", \"-\", \"b\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connectIfNotFound(\"a\", \"-\", \"b\");\n+    assertEquals(1, graph.getNodeDegree(\"a\"));\n+    graph.connectIfNotFound(\"a\", null, \"b\");\n+    assertEquals(2, graph.getNodeDegree(\"a\"));\n+    graph.connectIfNotFound(\"a\", null, \"b\");\n+    assertEquals(2, graph.getNodeDegree(\"a\"));\n+  }\n+\n+  public void testSimpleSubGraph() {\n+    UndiGraph<String, String> graph =\n+        new LinkedUndirectedGraph<String, String>();\n+    graph.createNode(\"a\");\n+    graph.createNode(\"b\");\n+    graph.createNode(\"c\");\n+    graph.connect(\"a\", \"--\", \"b\");\n+\n+    SubGraph<String, String> subGraph = graph.newSubGraph();\n+    subGraph.addNode(\"a\");\n+    subGraph.addNode(\"b\");\n+\n+    try {\n+      subGraph.addNode(\"d\");\n+      fail(\"SubGraph should not allow add for node that is not in graph.\");\n+    } catch (IllegalArgumentException e) {\n+      // exception expected\n+    }\n+\n+    assertFalse(subGraph.isIndependentOf(\"a\"));\n+    assertFalse(subGraph.isIndependentOf(\"b\"));\n+    assertTrue(subGraph.isIndependentOf(\"c\"));\n+  }\n+\n+  private <T extends GraphNode<String, String>> void assertListCount(\n+      List<T> list, String target, int count) {\n+    for (GraphNode<String, String> node : list) {\n+      if (node.getValue().equals(target)) {\n+        count--;\n+      }\n+    }\n+    assertTrue(count == 0);\n+  }\n+\n+  private <T extends GraphNode<String, String>> void assertSetEquals(\n+      List<T> list, String ... targets) {\n+    Set<String> set = new HashSet<String>();\n+    for (GraphNode<String, String> node : list) {\n+      set.add(node.getValue());\n+    }\n+    Set<String> otherSet = new HashSet<String>();\n+    for (String target : targets) {\n+      otherSet.add(target);\n+    }\n+    assertTrue(otherSet.equals(set));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Iterables;\n+\n+import junit.framework.*;\n+\n+import java.util.*;\n+\n+/**\n+ * Tests for {@link JSModuleGraph}\n+ *\n+*\n+ */\n+public class JSModuleGraphTest extends TestCase {\n+\n+  private final JSModule A = new JSModule(\"A\");\n+  private final JSModule B = new JSModule(\"B\");\n+  private final JSModule C = new JSModule(\"C\");\n+  private final JSModule D = new JSModule(\"D\");\n+  private final JSModule E = new JSModule(\"E\");\n+  private final JSModule F = new JSModule(\"F\");\n+  private JSModuleGraph graph = null;\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    B.addDependency(A);  //     __A__\n+    C.addDependency(A);  //    /  |  \\\n+    D.addDependency(B);  //   B   C  |\n+    E.addDependency(B);  //  / \\ /|  |\n+    E.addDependency(C);  // D   E | /\n+    F.addDependency(A);  //      \\|/\n+    F.addDependency(C);  //       F\n+    F.addDependency(E);\n+    graph = new JSModuleGraph(new JSModule[] {A, B, C, D, E, F});\n+  }\n+\n+  public void testModuleDepth() {\n+    assertEquals(\"A should have depth 0\", 0, graph.getDepth(A));\n+    assertEquals(\"B should have depth 1\", 1, graph.getDepth(B));\n+    assertEquals(\"C should have depth 1\", 1, graph.getDepth(C));\n+    assertEquals(\"D should have depth 2\", 2, graph.getDepth(D));\n+    assertEquals(\"E should have depth 2\", 2, graph.getDepth(E));\n+    assertEquals(\"F should have depth 3\", 3, graph.getDepth(F));\n+  }\n+\n+  public void testDeepestCommonDep() {\n+    assertDeepestCommonDep(null, A, A);\n+    assertDeepestCommonDep(null, A, B);\n+    assertDeepestCommonDep(null, A, C);\n+    assertDeepestCommonDep(null, A, D);\n+    assertDeepestCommonDep(null, A, E);\n+    assertDeepestCommonDep(null, A, F);\n+    assertDeepestCommonDep(A, B, B);\n+    assertDeepestCommonDep(A, B, C);\n+    assertDeepestCommonDep(A, B, D);\n+    assertDeepestCommonDep(A, B, E);\n+    assertDeepestCommonDep(A, B, F);\n+    assertDeepestCommonDep(A, C, C);\n+    assertDeepestCommonDep(A, C, D);\n+    assertDeepestCommonDep(A, C, E);\n+    assertDeepestCommonDep(A, C, F);\n+    assertDeepestCommonDep(B, D, D);\n+    assertDeepestCommonDep(B, D, E);\n+    assertDeepestCommonDep(B, D, F);\n+    assertDeepestCommonDep(C, E, E);\n+    assertDeepestCommonDep(C, E, F);\n+    assertDeepestCommonDep(E, F, F);\n+  }\n+\n+  public void testDeepestCommonDepInclusive() {\n+    assertDeepestCommonDepInclusive(A, A, A);\n+    assertDeepestCommonDepInclusive(A, A, B);\n+    assertDeepestCommonDepInclusive(A, A, C);\n+    assertDeepestCommonDepInclusive(A, A, D);\n+    assertDeepestCommonDepInclusive(A, A, E);\n+    assertDeepestCommonDepInclusive(A, A, F);\n+    assertDeepestCommonDepInclusive(B, B, B);\n+    assertDeepestCommonDepInclusive(A, B, C);\n+    assertDeepestCommonDepInclusive(B, B, D);\n+    assertDeepestCommonDepInclusive(B, B, E);\n+    assertDeepestCommonDepInclusive(B, B, F);\n+    assertDeepestCommonDepInclusive(C, C, C);\n+    assertDeepestCommonDepInclusive(A, C, D);\n+    assertDeepestCommonDepInclusive(C, C, E);\n+    assertDeepestCommonDepInclusive(C, C, F);\n+    assertDeepestCommonDepInclusive(D, D, D);\n+    assertDeepestCommonDepInclusive(B, D, E);\n+    assertDeepestCommonDepInclusive(B, D, F);\n+    assertDeepestCommonDepInclusive(E, E, E);\n+    assertDeepestCommonDepInclusive(E, E, F);\n+    assertDeepestCommonDepInclusive(F, F, F);\n+  }\n+\n+  public void testGetTransitiveDepsDeepestFirst() {\n+    assertTransitiveDepsDeepestFirst(A);\n+    assertTransitiveDepsDeepestFirst(B, A);\n+    assertTransitiveDepsDeepestFirst(C, A);\n+    assertTransitiveDepsDeepestFirst(D, B, A);\n+    assertTransitiveDepsDeepestFirst(E, C, B, A);\n+    assertTransitiveDepsDeepestFirst(F, E, C, B, A);\n+  }\n+\n+  public void testCoalesceDuplicateFiles() {\n+    A.add(JSSourceFile.fromCode(\"a.js\", \"\"));\n+\n+    B.add(JSSourceFile.fromCode(\"a.js\", \"\"));\n+    B.add(JSSourceFile.fromCode(\"b.js\", \"\"));\n+\n+    C.add(JSSourceFile.fromCode(\"b.js\", \"\"));\n+    C.add(JSSourceFile.fromCode(\"c.js\", \"\"));\n+\n+    E.add(JSSourceFile.fromCode(\"c.js\", \"\"));\n+    E.add(JSSourceFile.fromCode(\"d.js\", \"\"));\n+\n+    graph.coalesceDuplicateFiles();\n+\n+    assertEquals(2, A.getInputs().size());\n+    assertEquals(\"a.js\", A.getInputs().get(0).getName());\n+    assertEquals(\"b.js\", A.getInputs().get(1).getName());\n+    assertEquals(0, B.getInputs().size());\n+    assertEquals(1, C.getInputs().size());\n+    assertEquals(\"c.js\", C.getInputs().get(0).getName());\n+    assertEquals(1, E.getInputs().size());\n+    assertEquals(\"d.js\", E.getInputs().get(0).getName());\n+  }\n+\n+\n+  private void assertDeepestCommonDepInclusive(\n+      JSModule expected, JSModule m1, JSModule m2) {\n+    assertDeepestCommonDepOneWay(expected, m1, m2, true);\n+    assertDeepestCommonDepOneWay(expected, m2, m1, true);\n+  }\n+\n+  private void assertDeepestCommonDep(\n+      JSModule expected, JSModule m1, JSModule m2) {\n+    assertDeepestCommonDepOneWay(expected, m1, m2, false);\n+    assertDeepestCommonDepOneWay(expected, m2, m1, false);\n+  }\n+\n+  private void assertDeepestCommonDepOneWay(\n+      JSModule expected, JSModule m1, JSModule m2, boolean inclusive) {\n+    JSModule actual = inclusive ?\n+        graph.getDeepestCommonDependencyInclusive(m1, m2) :\n+        graph.getDeepestCommonDependency(m1, m2);\n+    if (actual != expected) {\n+      fail(String.format(\n+          \"Deepest common dep of %s and %s should be %s but was %s\",\n+          m1.getName(), m2.getName(),\n+          expected == null ? \"null\" : expected.getName(),\n+          actual ==  null ? \"null\" : actual.getName()));\n+    }\n+  }\n+\n+  private void assertTransitiveDepsDeepestFirst(JSModule m, JSModule... deps) {\n+    Iterable<JSModule> actual = graph.getTransitiveDepsDeepestFirst(m);\n+    assertEquals(Arrays.toString(deps),\n+                 Arrays.toString(Iterables.toArray(actual, JSModule.class)));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/LightweightMessageFormatterTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import static com.google.javascript.jscomp.LightweightMessageFormatter.LineNumberingFormatter;\n+\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+public class LightweightMessageFormatterTest extends TestCase {\n+  private static final DiagnosticType FOO_TYPE =\n+      DiagnosticType.error(\"TEST_FOO\", \"error description here\");\n+\n+  public void testNull() throws Exception {\n+    assertNull(format(null));\n+  }\n+\n+  public void testOneLineRegion() throws Exception {\n+    assertEquals(\"  5| hello world\", format(region(5, 5, \"hello world\")));\n+  }\n+\n+  public void testTwoLineRegion() throws Exception {\n+    assertEquals(\"  5| hello world\\n\" +\n+            \"  6| foo bar\", format(region(5, 6, \"hello world\\nfoo bar\")));\n+  }\n+\n+  public void testThreeLineRegionAcrossNumberRange() throws Exception {\n+    String region = format(region(9, 11, \"hello world\\nfoo bar\\nanother one\"));\n+    assertEquals(\"   9| hello world\\n\" +\n+            \"  10| foo bar\\n\" +\n+            \"  11| another one\", region);\n+  }\n+\n+  public void testThreeLineRegionEmptyLine() throws Exception {\n+    String region = format(region(7, 9, \"hello world\\n\\nanother one\"));\n+    assertEquals(\"  7| hello world\\n\" +\n+            \"  8| \\n\" +\n+            \"  9| another one\", region);\n+  }\n+\n+  public void testOnlyOneEmptyLine() throws Exception {\n+    assertNull(format(region(7, 7, \"\")));\n+  }\n+\n+  public void testTwoEmptyLines() throws Exception {\n+    assertEquals(\"  7| \", format(region(7, 8, \"\\n\")));\n+  }\n+\n+  public void testThreeLineRemoveLastEmptyLine() throws Exception {\n+    String region = format(region(7, 9, \"hello world\\nfoobar\\n\"));\n+    assertEquals(\"  7| hello world\\n\" +\n+            \"  8| foobar\", region);\n+  }\n+\n+  public void testFormatErrorSpaces() throws Exception {\n+    JSError error = JSError.make(\"javascript/complex.js\",\n+        Node.newString(\"foobar\", 5, 8), FOO_TYPE);\n+    LightweightMessageFormatter formatter = formatter(\"    if (foobar) {\");\n+    assertEquals(\"javascript/complex.js:5: ERROR - error description here\\n\" +\n+        \"    if (foobar) {\\n\" +\n+        \"        ^\\n\", formatter.formatError(error));\n+  }\n+\n+  public void testFormatErrorTabs() throws Exception {\n+    JSError error = JSError.make(\"javascript/complex.js\",\n+        Node.newString(\"foobar\", 5, 6), FOO_TYPE);\n+    LightweightMessageFormatter formatter = formatter(\"\\t\\tif (foobar) {\");\n+    assertEquals(\"javascript/complex.js:5: ERROR - error description here\\n\" +\n+        \"\\t\\tif (foobar) {\\n\" +\n+        \"\\t\\t    ^\\n\", formatter.formatError(error));\n+  }\n+\n+  private LightweightMessageFormatter formatter(String string) {\n+    return new LightweightMessageFormatter(source(string));\n+  }\n+\n+  private SourceExcerptProvider source(final String source) {\n+    return new SourceExcerptProvider() {\n+      public String getSourceLine(String sourceName, int lineNumber) {\n+        return source;\n+      }\n+      public Region getSourceRegion(String sourceName, int lineNumber) {\n+        throw new UnsupportedOperationException();\n+      }\n+    };\n+  }\n+\n+  private String format(Region region) {\n+    return new LineNumberingFormatter().formatRegion(region);\n+  }\n+\n+  private Region region(final int startLine, final int endLine,\n+      final String source) {\n+    return new SimpleRegion(startLine, endLine, source);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/LinkedFlowScopeTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+\n+/**\n+ * Tests for LinkedFlowScope.\n+*\n+ */\n+public class LinkedFlowScopeTest extends CompilerTypeTestCase {\n+\n+  private final Node blockNode = new Node(Token.BLOCK);\n+  private final Node functionNode = new Node(Token.FUNCTION);\n+  private final int LONG_CHAIN_LENGTH = 1050;\n+\n+  private Scope globalScope;\n+  private Scope localScope;\n+  @SuppressWarnings(\"unused\")\n+  private FlowScope globalEntry;\n+  private FlowScope localEntry;\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+\n+    globalScope = new Scope(blockNode, compiler);\n+    globalScope.declare(\"globalA\", null, null, null);\n+    globalScope.declare(\"globalB\", null, null, null);\n+\n+    localScope = new Scope(globalScope, functionNode);\n+    localScope.declare(\"localA\", null, null, null);\n+    localScope.declare(\"localB\", null, null, null);\n+\n+    globalEntry = LinkedFlowScope.createEntryLattice(globalScope);\n+    localEntry = LinkedFlowScope.createEntryLattice(localScope);\n+  }\n+\n+  public void testOptimize() {\n+    assertEquals(localEntry, localEntry.optimize());\n+\n+    FlowScope child = localEntry.createChildFlowScope();\n+    assertEquals(localEntry, child.optimize());\n+\n+    child.inferSlotType(\"localB\", NUMBER_TYPE);\n+    assertEquals(child, child.optimize());\n+  }\n+\n+  public void testJoin1() {\n+    FlowScope childA = localEntry.createChildFlowScope();\n+    childA.inferSlotType(\"localB\", NUMBER_TYPE);\n+\n+    FlowScope childAB = childA.createChildFlowScope();\n+    childAB.inferSlotType(\"localB\", STRING_TYPE);\n+\n+    FlowScope childB = localEntry.createChildFlowScope();\n+    childB.inferSlotType(\"localB\", BOOLEAN_TYPE);\n+\n+    assertEquals(STRING_TYPE, childAB.getSlot(\"localB\").getType());\n+    assertEquals(BOOLEAN_TYPE, childB.getSlot(\"localB\").getType());\n+    assertNull(childB.getSlot(\"localA\").getType());\n+\n+    FlowScope joined = join(childB, childAB);\n+    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+        joined.getSlot(\"localB\").getType());\n+    assertNull(joined.getSlot(\"localA\").getType());\n+\n+    joined = join(childAB, childB);\n+    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+        joined.getSlot(\"localB\").getType());\n+    assertNull(joined.getSlot(\"localA\").getType());\n+\n+    assertEquals(\"Join should be symmetric\",\n+        join(childB, childAB), join(childAB, childB));\n+  }\n+\n+  public void testJoin2() {\n+    FlowScope childA = localEntry.createChildFlowScope();\n+    childA.inferSlotType(\"localA\", STRING_TYPE);\n+\n+    FlowScope childB = localEntry.createChildFlowScope();\n+    childB.inferSlotType(\"globalB\", BOOLEAN_TYPE);\n+\n+    assertEquals(STRING_TYPE, childA.getSlot(\"localA\").getType());\n+    assertEquals(BOOLEAN_TYPE, childB.getSlot(\"globalB\").getType());\n+    assertNull(childB.getSlot(\"localB\").getType());\n+\n+    FlowScope joined = join(childB, childA);\n+    assertEquals(STRING_TYPE, joined.getSlot(\"localA\").getType());\n+    assertEquals(BOOLEAN_TYPE, joined.getSlot(\"globalB\").getType());\n+\n+    joined = join(childA, childB);\n+    assertEquals(STRING_TYPE, joined.getSlot(\"localA\").getType());\n+    assertEquals(BOOLEAN_TYPE, joined.getSlot(\"globalB\").getType());\n+\n+    assertEquals(\"Join should be symmetric\",\n+        join(childB, childA), join(childA, childB));\n+  }\n+\n+  public void testJoin3() {\n+    localScope.declare(\"localC\", null, STRING_TYPE, null);\n+    localScope.declare(\"localD\", null, STRING_TYPE, null);\n+\n+    FlowScope childA = localEntry.createChildFlowScope();\n+    childA.inferSlotType(\"localC\", NUMBER_TYPE);\n+\n+    FlowScope childB = localEntry.createChildFlowScope();\n+    childA.inferSlotType(\"localD\", BOOLEAN_TYPE);\n+\n+    FlowScope joined = join(childB, childA);\n+    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+        joined.getSlot(\"localC\").getType());\n+    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+        joined.getSlot(\"localD\").getType());\n+\n+    joined = join(childA, childB);\n+    assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE),\n+        joined.getSlot(\"localC\").getType());\n+    assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+        joined.getSlot(\"localD\").getType());\n+\n+    assertEquals(\"Join should be symmetric\",\n+        join(childB, childA), join(childA, childB));\n+  }\n+\n+  /**\n+   * Create a long chain of flow scopes where each link in the chain\n+   * contains one slot.\n+   */\n+  public void testLongChain1() {\n+    FlowScope chainA = localEntry.createChildFlowScope();\n+    FlowScope chainB = localEntry.createChildFlowScope();\n+    for (int i = 0; i < LONG_CHAIN_LENGTH; i++) {\n+      localScope.declare(\"local\" + i, null, null, null);\n+      chainA.inferSlotType(\"local\" + i,\n+          i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE);\n+      chainB.inferSlotType(\"local\" + i,\n+          i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);\n+\n+      chainA = chainA.createChildFlowScope();\n+      chainB = chainB.createChildFlowScope();\n+    }\n+\n+    verifyLongChains(chainA, chainB);\n+  }\n+\n+  /**\n+   * Create a long chain of flow scopes where each link in the chain\n+   * contains 7 slots.\n+   */\n+  public void testLongChain2() {\n+    FlowScope chainA = localEntry.createChildFlowScope();\n+    FlowScope chainB = localEntry.createChildFlowScope();\n+    for (int i = 0; i < LONG_CHAIN_LENGTH * 7; i++) {\n+      localScope.declare(\"local\" + i, null, null, null);\n+      chainA.inferSlotType(\"local\" + i,\n+          i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE);\n+      chainB.inferSlotType(\"local\" + i,\n+          i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);\n+\n+      if (LONG_CHAIN_LENGTH % 7 == 0) {\n+        chainA = chainA.createChildFlowScope();\n+        chainB = chainB.createChildFlowScope();\n+      }\n+    }\n+\n+    verifyLongChains(chainA, chainB);\n+  }\n+\n+  /**\n+   * Create a long chain of flow scopes where every 4 links in the chain\n+   * contain a slot.\n+   */\n+  public void testLongChain3() {\n+    FlowScope chainA = localEntry.createChildFlowScope();\n+    FlowScope chainB = localEntry.createChildFlowScope();\n+    for (int i = 0; i < LONG_CHAIN_LENGTH * 7; i++) {\n+      if (i % 7 == 0) {\n+        int j = i / 7;\n+        localScope.declare(\"local\" + j, null, null, null);\n+        chainA.inferSlotType(\"local\" + j,\n+            j % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE);\n+        chainB.inferSlotType(\"local\" + j,\n+            j % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE);\n+      }\n+\n+      chainA = chainA.createChildFlowScope();\n+      chainB = chainB.createChildFlowScope();\n+    }\n+\n+    verifyLongChains(chainA, chainB);\n+  }\n+\n+  // Common chain verification for testLongChainN for all N.\n+  private void verifyLongChains(FlowScope chainA, FlowScope chainB) {\n+    FlowScope joined = join(chainA, chainB);\n+    for (int i = 0; i < LONG_CHAIN_LENGTH; i++) {\n+      assertEquals(\n+          i % 2 == 0 ? NUMBER_TYPE : BOOLEAN_TYPE,\n+          chainA.getSlot(\"local\" + i).getType());\n+      assertEquals(\n+          i % 3 == 0 ? STRING_TYPE : BOOLEAN_TYPE,\n+          chainB.getSlot(\"local\" + i).getType());\n+\n+      JSType joinedSlotType = joined.getSlot(\"local\" + i).getType();\n+      if (i % 6 == 0) {\n+        assertEquals(createUnionType(STRING_TYPE, NUMBER_TYPE), joinedSlotType);\n+      } else if (i % 2 == 0) {\n+        assertEquals(createUnionType(NUMBER_TYPE, BOOLEAN_TYPE),\n+            joinedSlotType);\n+      } else if (i % 3 == 0) {\n+        assertEquals(createUnionType(STRING_TYPE, BOOLEAN_TYPE),\n+            joinedSlotType);\n+      } else {\n+        assertEquals(BOOLEAN_TYPE, joinedSlotType);\n+      }\n+    }\n+\n+    assertScopesDiffer(chainA, chainB);\n+    assertScopesDiffer(chainA, joined);\n+    assertScopesDiffer(chainB, joined);\n+  }\n+\n+  public void testFindUniqueSlot() {\n+    FlowScope childA = localEntry.createChildFlowScope();\n+    childA.inferSlotType(\"localB\", NUMBER_TYPE);\n+\n+    FlowScope childAB = childA.createChildFlowScope();\n+    childAB.inferSlotType(\"localB\", STRING_TYPE);\n+\n+    FlowScope childABC = childAB.createChildFlowScope();\n+    childABC.inferSlotType(\"localA\", BOOLEAN_TYPE);\n+\n+    assertNull(childABC.findUniqueRefinedSlot(childABC));\n+    assertEquals(BOOLEAN_TYPE,\n+        childABC.findUniqueRefinedSlot(childAB).getType());\n+    assertNull(childABC.findUniqueRefinedSlot(childA));\n+    assertNull(childABC.findUniqueRefinedSlot(localEntry));\n+\n+    assertEquals(STRING_TYPE,\n+        childAB.findUniqueRefinedSlot(childA).getType());\n+    assertEquals(STRING_TYPE,\n+        childAB.findUniqueRefinedSlot(localEntry).getType());\n+\n+    assertEquals(NUMBER_TYPE,\n+        childA.findUniqueRefinedSlot(localEntry).getType());\n+  }\n+\n+  public void testDiffer() {\n+    FlowScope childA = localEntry.createChildFlowScope();\n+    childA.inferSlotType(\"localB\", NUMBER_TYPE);\n+\n+    FlowScope childAB = childA.createChildFlowScope();\n+    childAB.inferSlotType(\"localB\", STRING_TYPE);\n+\n+    FlowScope childABC = childAB.createChildFlowScope();\n+    childABC.inferSlotType(\"localA\", BOOLEAN_TYPE);\n+\n+    FlowScope childB = childAB.createChildFlowScope();\n+    childB.inferSlotType(\"localB\", STRING_TYPE);\n+\n+    FlowScope childBC = childB.createChildFlowScope();\n+    childBC.inferSlotType(\"localA\", NO_TYPE);\n+\n+    assertScopesSame(childAB, childB);\n+    assertScopesSame(childABC, childBC);\n+\n+    assertScopesDiffer(childABC, childB);\n+    assertScopesDiffer(childAB, childBC);\n+\n+    assertScopesDiffer(childA, childAB);\n+    assertScopesDiffer(childA, childABC);\n+    assertScopesDiffer(childA, childB);\n+    assertScopesDiffer(childA, childBC);\n+  }\n+\n+  private void assertScopesDiffer(FlowScope a, FlowScope b) {\n+    assertFalse(a.equals(b));\n+    assertFalse(b.equals(a));\n+    assertEquals(a, a);\n+    assertEquals(b, b);\n+  }\n+\n+  private void assertScopesSame(FlowScope a, FlowScope b) {\n+    assertEquals(a, b);\n+    assertEquals(b, a);\n+    assertEquals(a, a);\n+    assertEquals(b, b);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private FlowScope join(FlowScope a, FlowScope b) {\n+    return (new LinkedFlowScope.FlowScopeJoinOp()).apply(\n+        Lists.newArrayList(a, b));\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/SemanticReverseAbstractInterpreterTest.java\n+/*\n+ * Copyright 2007 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Pair;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+public class SemanticReverseAbstractInterpreterTest\n+    extends CompilerTypeTestCase {\n+  private CodingConvention codingConvention = new GoogleCodingConvention();\n+  private ReverseAbstractInterpreter interpreter;\n+  private Scope functionScope;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+\n+    interpreter = new SemanticReverseAbstractInterpreter(\n+        codingConvention, registry);\n+  }\n+\n+  public FlowScope newScope() {\n+    Scope globalScope = new Scope(new Node(Token.EMPTY), compiler);\n+    functionScope = new Scope(globalScope, new Node(Token.EMPTY));\n+    return LinkedFlowScope.createEntryLattice(functionScope);\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a NAME expression.\n+   */\n+  public void testNameCondition() throws Exception {\n+    FlowScope blind = newScope();\n+    Node condition = createVar(blind, \"a\", createNullableType(STRING_TYPE));\n+\n+    // true outcome.\n+    FlowScope informedTrue = interpreter.\n+        getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n+    assertEquals(STRING_TYPE, getVarType(informedTrue, \"a\"));\n+\n+    // false outcome.\n+    FlowScope informedFalse = interpreter.\n+        getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n+    assertEquals(createNullableType(STRING_TYPE),\n+        getVarType(informedFalse, \"a\"));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a NOT(NAME) expression.\n+   */\n+  public void testNegatedNameCondition() throws Exception {\n+    FlowScope blind = newScope();\n+    Node a = createVar(blind, \"a\", createNullableType(STRING_TYPE));\n+    Node condition = new Node(Token.NOT);\n+    condition.addChildToBack(a);\n+\n+    // true outcome.\n+    FlowScope informedTrue = interpreter.\n+        getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n+    assertEquals(createNullableType(STRING_TYPE),\n+        getVarType(informedTrue, \"a\"));\n+\n+    // false outcome.\n+    FlowScope informedFalse = interpreter.\n+        getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n+    assertEquals(STRING_TYPE, getVarType(informedFalse, \"a\"));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a ASSIGN expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testAssignCondition1() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.ASSIGN,\n+        createVar(blind, \"a\", createNullableType(OBJECT_TYPE)),\n+        createVar(blind, \"b\", createNullableType(OBJECT_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", OBJECT_TYPE),\n+            new Pair<String, JSType>(\"b\", OBJECT_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", NULL_TYPE),\n+            new Pair<String, JSType>(\"b\", NULL_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a SHEQ(NAME, NUMBER) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testSheqCondition1() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHEQ,\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        createNumber(56),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+            createUnionType(STRING_TYPE, NUMBER_TYPE))));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a SHEQ(NUMBER, NAME) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testSheqCondition2() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHEQ,\n+        createNumber(56),\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+            createUnionType(STRING_TYPE, NUMBER_TYPE))));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a SHEQ(NAME, NAME) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testSheqCondition3() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHEQ,\n+        createVar(blind, \"b\", createUnionType(STRING_TYPE, BOOLEAN_TYPE)),\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n+            new Pair<String, JSType>(\"b\", STRING_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+            createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+            new Pair<String, JSType>(\"b\",\n+                createUnionType(STRING_TYPE, BOOLEAN_TYPE))));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testSheqCondition4() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHEQ,\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n+        createVar(blind, \"b\", createUnionType(VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testSheqCondition5() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHEQ,\n+        createVar(blind, \"a\", createUnionType(NULL_TYPE, VOID_TYPE)),\n+        createVar(blind, \"b\", createUnionType(VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NULL_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testSheqCondition6() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHEQ,\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n+        createVar(blind, \"b\", createUnionType(NUMBER_TYPE, VOID_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", VOID_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\",\n+                createUnionType(STRING_TYPE, VOID_TYPE)),\n+            new Pair<String, JSType>(\"b\",\n+                createUnionType(NUMBER_TYPE, VOID_TYPE))));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a SHNE(NAME, NUMBER) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testShneCondition1() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHNE,\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        createNumber(56),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+            createUnionType(STRING_TYPE, NUMBER_TYPE))),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a SHNE(NUMBER, NAME) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testShneCondition2() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHNE,\n+        createNumber(56),\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+            createUnionType(STRING_TYPE, NUMBER_TYPE))),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a SHNE(NAME, NAME) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testShneCondition3() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHNE,\n+        createVar(blind, \"b\", createUnionType(STRING_TYPE, BOOLEAN_TYPE)),\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+            createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+            new Pair<String, JSType>(\"b\",\n+                createUnionType(STRING_TYPE, BOOLEAN_TYPE))),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n+            new Pair<String, JSType>(\"b\", STRING_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testShneCondition4() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHNE,\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n+        createVar(blind, \"b\", createUnionType(VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", STRING_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testShneCondition5() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHNE,\n+        createVar(blind, \"a\", createUnionType(NULL_TYPE, VOID_TYPE)),\n+        createVar(blind, \"b\", createUnionType(NULL_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE),\n+            new Pair<String, JSType>(\"b\", NULL_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NULL_TYPE),\n+            new Pair<String, JSType>(\"b\", NULL_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testShneCondition6() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.SHNE,\n+        createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n+        createVar(blind, \"b\", createUnionType(NUMBER_TYPE, VOID_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\",\n+                createUnionType(STRING_TYPE, VOID_TYPE)),\n+            new Pair<String, JSType>(\"b\",\n+                createUnionType(NUMBER_TYPE, VOID_TYPE))),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", VOID_TYPE),\n+            new Pair<String, JSType>(\"b\", VOID_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a EQ(NAME, NULL) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testEqCondition1() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.EQ,\n+        createVar(blind, \"a\", createUnionType(BOOLEAN_TYPE, VOID_TYPE)),\n+        createNull(),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", BOOLEAN_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a NE(NULL, NAME) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testEqCondition2() throws Exception {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.NE,\n+        createNull(),\n+        createVar(blind, \"a\", createUnionType(BOOLEAN_TYPE, VOID_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", BOOLEAN_TYPE)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", VOID_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a EQ(NAME, NULL) expression.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testEqCondition3() throws Exception {\n+    FlowScope blind = newScope();\n+    // (number,undefined,null)\n+    JSType nullableOptionalNumber =\n+        createUnionType(NULL_TYPE, VOID_TYPE, NUMBER_TYPE);\n+    // (null,undefined)\n+    JSType nullUndefined =\n+        createUnionType(VOID_TYPE, NULL_TYPE);\n+    testBinop(blind,\n+        Token.EQ,\n+        createVar(blind, \"a\", nullableOptionalNumber),\n+        createNull(),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", nullUndefined)),\n+        Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE)));\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a COMPARE(NAME, NUMBER) expression,\n+   * where COMPARE can be LE, LT, GE or GT.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInequalitiesCondition1() {\n+    for (int op : Arrays.asList(Token.LT, Token.GT, Token.LE, Token.GE)) {\n+      FlowScope blind = newScope();\n+      testBinop(blind,\n+          op,\n+          createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n+          createNumber(8),\n+          Sets.newHashSet(\n+              new Pair<String, JSType>(\"a\", STRING_TYPE)),\n+          Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+              createUnionType(STRING_TYPE, VOID_TYPE))));\n+    }\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a COMPARE(NAME, NAME) expression,\n+   * where COMPARE can be LE, LT, GE or GT.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInequalitiesCondition2() {\n+    for (int op : Arrays.asList(Token.LT, Token.GT, Token.LE, Token.GE)) {\n+      FlowScope blind = newScope();\n+      testBinop(blind,\n+          op,\n+          createVar(blind, \"a\",\n+              createUnionType(STRING_TYPE, NUMBER_TYPE, VOID_TYPE)),\n+          createVar(blind, \"b\",\n+              createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+          Sets.newHashSet(\n+              new Pair<String, JSType>(\"a\",\n+              createUnionType(STRING_TYPE, NUMBER_TYPE)),\n+              new Pair<String, JSType>(\"b\",\n+              createUnionType(NUMBER_TYPE, NULL_TYPE))),\n+          Sets.newHashSet(\n+              new Pair<String, JSType>(\"a\",\n+              createUnionType(STRING_TYPE, NUMBER_TYPE, VOID_TYPE)),\n+              new Pair<String, JSType>(\"b\",\n+              createUnionType(NUMBER_TYPE, NULL_TYPE))));\n+    }\n+  }\n+\n+  /**\n+   * Tests reverse interpretation of a COMPARE(NUMBER-untyped, NAME) expression,\n+   * where COMPARE can be LE, LT, GE or GT.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInequalitiesCondition3() {\n+    for (int op : Arrays.asList(Token.LT, Token.GT, Token.LE, Token.GE)) {\n+      FlowScope blind = newScope();\n+      testBinop(blind,\n+          op,\n+          createUntypedNumber(8),\n+          createVar(blind, \"a\", createUnionType(STRING_TYPE, VOID_TYPE)),\n+          Sets.newHashSet(\n+              new Pair<String, JSType>(\"a\", STRING_TYPE)),\n+          Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+              createUnionType(STRING_TYPE, VOID_TYPE))));\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testAnd() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+      Token.AND,\n+      createVar(blind, \"b\", createUnionType(STRING_TYPE, NULL_TYPE)),\n+      createVar(blind, \"a\", createUnionType(NUMBER_TYPE, VOID_TYPE)),\n+      Sets.newHashSet(new Pair<String, JSType>(\"a\", NUMBER_TYPE),\n+          new Pair<String, JSType>(\"b\", STRING_TYPE)),\n+      Sets.newHashSet(new Pair<String, JSType>(\"a\",\n+          createUnionType(NUMBER_TYPE, VOID_TYPE)),\n+          new Pair<String, JSType>(\"b\",\n+          createUnionType(STRING_TYPE, NULL_TYPE))));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testTypeof1() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.EQ,\n+        new Node(Token.TYPEOF, createVar(blind, \"a\", OBJECT_TYPE)),\n+        Node.newString(\"function\"),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", U2U_CONSTRUCTOR_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", OBJECT_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testTypeof2() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.EQ,\n+        new Node(Token.TYPEOF, createVar(blind, \"a\", ALL_TYPE)),\n+        Node.newString(\"function\"),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", U2U_CONSTRUCTOR_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"a\", ALL_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInstanceOf() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.INSTANCEOF,\n+        createVar(blind, \"x\", UNKNOWN_TYPE),\n+        createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInstanceOf2() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.INSTANCEOF,\n+        createVar(blind, \"x\",\n+            createUnionType(STRING_OBJECT_TYPE, NUMBER_OBJECT_TYPE)),\n+        createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"x\", NUMBER_OBJECT_TYPE),\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInstanceOf3() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.INSTANCEOF,\n+        createVar(blind, \"x\", OBJECT_TYPE),\n+        createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"x\", OBJECT_TYPE),\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public void testInstanceOf4() {\n+    FlowScope blind = newScope();\n+    testBinop(blind,\n+        Token.INSTANCEOF,\n+        createVar(blind, \"x\", ALL_TYPE),\n+        createVar(blind, \"s\", STRING_OBJECT_FUNCTION_TYPE),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"x\", STRING_OBJECT_TYPE),\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)),\n+        Sets.newHashSet(\n+            new Pair<String, JSType>(\"s\", STRING_OBJECT_FUNCTION_TYPE)));\n+  }\n+\n+  private void testBinop(FlowScope blind, int binop, Node left, Node right,\n+      Collection<Pair<String, JSType>> trueOutcome,\n+      Collection<Pair<String, JSType>> falseOutcome) {\n+    Node condition = new Node(binop);\n+    condition.addChildToBack(left);\n+    condition.addChildToBack(right);\n+\n+    // true outcome.\n+    FlowScope informedTrue = interpreter.\n+        getPreciserScopeKnowingConditionOutcome(condition, blind, true);\n+    for (Pair<String, JSType> p : trueOutcome) {\n+      assertEquals(p.first, p.second, getVarType(informedTrue, p.first));\n+    }\n+\n+    // false outcome.\n+    FlowScope informedFalse = interpreter.\n+        getPreciserScopeKnowingConditionOutcome(condition, blind, false);\n+    for (Pair<String, JSType> p : falseOutcome) {\n+      assertEquals(p.second, getVarType(informedFalse, p.first));\n+    }\n+  }\n+\n+  private Node createNull() {\n+    Node n = new Node(Token.NULL);\n+    n.setJSType(NULL_TYPE);\n+    return n;\n+  }\n+\n+  private Node createNumber(int n) {\n+    Node number = createUntypedNumber(n);\n+    number.setJSType(NUMBER_TYPE);\n+    return number;\n+  }\n+\n+  private Node createUntypedNumber(int n) {\n+    return Node.newNumber(n);\n+  }\n+\n+  private JSType getVarType(FlowScope scope, String name) {\n+    return scope.getSlot(name).getType();\n+  }\n+\n+  private Node createVar(FlowScope scope, String name, JSType type) {\n+    Node n = Node.newString(Token.NAME, name);\n+    functionScope.declare(name, n, null, null);\n+    ((LinkedFlowScope) scope).inferSlotType(name, type);\n+    n.setJSType(type);\n+    return n;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/StrictModeCheckTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+public class StrictModeCheckTest extends CompilerTestCase {\n+  private static final String EXTERNS = \"var arguments; function eval(str) {}\";\n+\n+  private boolean noVarCheck;\n+  private boolean noCajaChecks;\n+\n+  public StrictModeCheckTest() {\n+    super(EXTERNS);\n+  }\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    noVarCheck = false;\n+    noCajaChecks = false;\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new StrictModeCheck(compiler, noVarCheck, noCajaChecks);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  public void testWith() {\n+    test(\"var a; function foo(obj) { with (obj) { a = 3; }}\", null,\n+         StrictModeCheck.WITH_DISALLOWED);\n+  }\n+\n+  public void testEval() {\n+    test(\"function foo() { eval('a'); }\", null,\n+         StrictModeCheck.EVAL_USE);\n+  }\n+\n+  public void testEval2() {\n+    test(\"function foo(eval) {}\", null,\n+         StrictModeCheck.EVAL_DECLARATION);\n+  }\n+\n+  public void testEval3() {\n+    testSame(\"function foo() {} foo.eval = 3;\");\n+  }\n+\n+  public void testEval4() {\n+    test(\"function foo() { var eval = 3; }\", null,\n+         StrictModeCheck.EVAL_DECLARATION);\n+  }\n+\n+  public void testEval5() {\n+    test(\"function eval() {}\", null, StrictModeCheck.EVAL_DECLARATION);\n+  }\n+\n+  public void testEval6() {\n+    test(\"try {} catch (eval) {}\", null, StrictModeCheck.EVAL_DECLARATION);\n+  }\n+\n+  public void testEval7() {\n+    testSame(\"var o = {eval: 3};\");\n+  }\n+\n+  public void testEval8() {\n+    testSame(\"var a; eval: while (true) { a = 3; }\");\n+  }\n+\n+  public void testUnknownVariable() {\n+    test(\"function foo(a) { a = b; }\", null, StrictModeCheck.UNKNOWN_VARIABLE);\n+  }\n+\n+  public void testUnknownVariable2() {\n+    test(\"a: while (true) { a = 3; }\", null, StrictModeCheck.UNKNOWN_VARIABLE);\n+  }\n+\n+  public void testUnknownVariable3() {\n+    testSame(\"try {} catch (ex) { ex = 3; }\");\n+  }\n+\n+  public void testArguments() {\n+    test(\"function foo(arguments) {}\", null,\n+         StrictModeCheck.ARGUMENTS_DECLARATION);\n+  }\n+\n+  public void testArguments2() {\n+    test(\"function foo() { var arguments = 3; }\", null,\n+         StrictModeCheck.ARGUMENTS_DECLARATION);\n+  }\n+\n+  public void testArguments3() {\n+    test(\"function arguments() {}\", null,\n+         StrictModeCheck.ARGUMENTS_DECLARATION);\n+  }\n+\n+  public void testArguments4() {\n+    test(\"try {} catch (arguments) {}\", null,\n+         StrictModeCheck.ARGUMENTS_DECLARATION);\n+  }\n+\n+  public void testArguments5() {\n+    testSame(\"var o = {arguments: 3};\");\n+  }\n+\n+  public void testEvalAssignment() {\n+    noCajaChecks = true;\n+    test(\"function foo() { eval = []; }\", null,\n+         StrictModeCheck.EVAL_ASSIGNMENT);\n+  }\n+\n+  public void testEvalAssignment2() {\n+    test(\"function foo() { eval = []; }\", null, StrictModeCheck.EVAL_USE);\n+  }\n+\n+  public void testAssignToArguments() {\n+    test(\"function foo() { arguments = []; }\", null,\n+         StrictModeCheck.ARGUMENTS_ASSIGNMENT);\n+  }\n+\n+  public void testDeleteVar() {\n+    test(\"var a; delete a\", null, StrictModeCheck.DELETE_VARIABLE);\n+  }\n+\n+  public void testDeleteFunction() {\n+    test(\"function a() {} delete a\", null, StrictModeCheck.DELETE_VARIABLE);\n+  }\n+\n+  public void testDeleteArgument() {\n+    test(\"function b(a) { delete a; }\", null, StrictModeCheck.DELETE_VARIABLE);\n+  }\n+\n+  public void testDeleteProperty() {\n+    testSame(\"function f(obj) { delete obj.a; }\");\n+  }\n+\n+  public void testIllegalName() {\n+    test(\"var a__ = 3;\", null, StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName2() {\n+    test(\"function a__() {}\", null, StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName3() {\n+    test(\"function f(a__) {}\", null, StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName4() {\n+    test(\"try {} catch (a__) {}\", null, StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName5() {\n+    noVarCheck = true;\n+    test(\"var a = b__;\", null, StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName6() {\n+    test(\"function f(obj) { return obj.a__; }\", null,\n+         StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName7() {\n+    noCajaChecks = true;\n+    testSame(\"var a__ = 3;\");\n+  }\n+\n+  public void testIllegalName8() {\n+    test(\"var o = {a__: 3};\", null, StrictModeCheck.ILLEGAL_NAME);\n+    test(\"var o = {b: 3, a__: 4};\", null, StrictModeCheck.ILLEGAL_NAME);\n+  }\n+\n+  public void testIllegalName9() {\n+    test(\"a__: while (true) { var b = 3; }\", null,\n+         StrictModeCheck.ILLEGAL_NAME);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/VariableMapTest.java\n+/*\n+ * Copyright 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.Maps;\n+\n+import junit.framework.*;\n+\n+import java.util.*;\n+import java.text.*;\n+\n+/**\n+ * Tests for {@link VariableMap}.\n+ *\n+*\n+ */\n+public class VariableMapTest extends TestCase {\n+\n+  public void testToBytes() {\n+    VariableMap vm = new VariableMap(Maps.immutableMap(\"AAA\", \"a\", \"BBB\", \"b\"));\n+    String serialized = new String(vm.toBytes(), Charsets.UTF_8);\n+    assertTrue(serialized.endsWith(\"\\n\"));\n+\n+    List<String> lines = Arrays.asList(serialized.split(\"\\n\"));\n+    assertEquals(2, lines.size());\n+    assertTrue(lines.contains(\"AAA:a\"));\n+    assertTrue(lines.contains(\"BBB:b\"));\n+  }\n+\n+  public void testFromBytes() throws ParseException {\n+    VariableMap vm = VariableMap.fromBytes(\"AAA:a\\nBBB:b\\n\".getBytes());\n+    assertEquals(2, vm.getOriginalNameToNewNameMap().size());\n+    assertEquals(\"a\", vm.lookupNewName(\"AAA\"));\n+    assertEquals(\"b\", vm.lookupNewName(\"BBB\"));\n+    assertEquals(\"AAA\", vm.lookupSourceName(\"a\"));\n+    assertEquals(\"BBB\", vm.lookupSourceName(\"b\"));\n+  }\n+\n+  public void testFromBytesComplex() throws ParseException {\n+    VariableMap vm = VariableMap.fromBytes(\"AAA[':f']:a\\n\".getBytes());\n+    assertEquals(1, vm.getOriginalNameToNewNameMap().size());\n+    assertEquals(\"a\", vm.lookupNewName(\"AAA[':f']\"));\n+  }\n+}", "timestamp": 1261589627, "metainfo": ""}