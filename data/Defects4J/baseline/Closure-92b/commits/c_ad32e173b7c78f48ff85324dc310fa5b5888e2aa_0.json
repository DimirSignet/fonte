{"sha": "ad32e173b7c78f48ff85324dc310fa5b5888e2aa", "log": "Changes to completely remove goog.userAgent as required by javatests/com/google/javascript/closure/CompileUserAgentTest.  This requires three changes:  1) being able to remove expressions without side-effects in the global scope with the PeepholeRemoveDeadCode pass. This is simply a change to handle both BLOCK and SCRIPT.  2) a change to be able to fold constant result if conditions that have side-effects (a = 1).  This was a change to include a smarter version of NodeUtil.getBooleanValue. A general expression evaluator would be preferred.  3) and finally a bit of a hack to handle assignments followed by if statements.  I would prefer a general solution, but this works well enough for this purpose.  A good general solution would need a general in-place expression evaluator and control-flow value propagation, both of which I've special cased. It handles this:  a = /MSIE/ if (a) { a.exec(value); }  (we want the regexp object to get inlined into the exec call so it is known to be side-effect free).  R=gboyer,acleung DELTA=388  (333 added, 28 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=90004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n   void endTraversal(NodeTraversal traversal) {\n     currentTraversal = null;\n   }\n+\n+  // NodeUtil's mayEffectMutableState and mayHaveSideEffects need access to the\n+  // compiler object, route them through here to give them access.\n+\n+  /**\n+   * @return Whether the node may create new mutable state, or change existing\n+   * state.\n+   */\n+  boolean mayEffectMutableState(Node n) {\n+    return NodeUtil.mayEffectMutableState(n, currentTraversal.getCompiler());\n+  }\n+\n+  /**\n+   * @return Whether the node may have side effects when executed.\n+   */\n+  boolean mayHaveSideEffects(Node n) {\n+    return NodeUtil.mayHaveSideEffects(n, currentTraversal.getCompiler());\n+  }\n }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   private NodeUtil() {}\n \n   /**\n+   * Gets the boolean value of a node that represents a expression. This method\n+   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n+   * Note: unlike getBooleanValue this function does not return UNKNOWN\n+   * for expressions with side-effects.\n+   */\n+  static TernaryValue getExpressionBooleanValue(Node n) {\n+    switch (n.getType()) {\n+      case Token.ASSIGN:\n+      case Token.COMMA:\n+        // For ASSIGN and COMMA the value is the value of the RHS.\n+        return getExpressionBooleanValue(n.getLastChild());\n+      case Token.NOT:\n+        TernaryValue value = getExpressionBooleanValue(n.getLastChild());\n+        return value.not();\n+      case Token.AND: {\n+        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n+        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n+        return lhs.and(rhs);\n+      }\n+      case Token.OR:  {\n+        TernaryValue lhs = getExpressionBooleanValue(n.getFirstChild());\n+        TernaryValue rhs = getExpressionBooleanValue(n.getLastChild());\n+        return lhs.or(rhs);\n+      }\n+      case Token.HOOK:  {\n+        TernaryValue trueValue = getExpressionBooleanValue(\n+            n.getFirstChild().getNext());\n+        TernaryValue falseValue = getExpressionBooleanValue(n.getLastChild());\n+        if (trueValue.equals(falseValue)) {\n+          return trueValue;\n+        } else {\n+          return TernaryValue.UNKNOWN;\n+        }\n+      }\n+      default:\n+        return getBooleanValue(n);\n+    }\n+  }\n+\n+  /**\n    * Gets the boolean value of a node that represents a literal. This method\n    * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n-   *\n-   * @throws IllegalArgumentException If {@code n} is not a literal value\n    */\n   static TernaryValue getBooleanValue(Node n) {\n     switch (n.getType()) {\n   /**\n    * Determines if a node is a function expression that has an empty body.\n    *\n-   * @param n a node\n+   * @param node a node\n    * @return whether the given node is a function expression that is empty\n    */\n   static boolean isEmptyFunctionExpression(Node node) {\n     }\n     return sourceName;\n   }\n+\n+  /**\n+   * A new CALL node with the \"FREE_CALL\" set based on call target.\n+   */\n+  static Node newCallNode(Node callTarget, Node... parameters) {\n+    boolean isFreeCall = isName(callTarget);\n+    Node call = new Node(Token.CALL, callTarget);\n+    call.putBooleanProp(Node.FREE_CALL, isFreeCall);\n+    for (Node parameter : parameters) {\n+      call.addChildToBack(parameter);\n+    }\n+    return call;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n     switch(subtree.getType()) {\n       case Token.COMMA:\n         return tryFoldComma(subtree);\n+      case Token.SCRIPT:\n       case Token.BLOCK:\n-        return tryFoldBlock(subtree);\n+        return tryOptimizeBlock(subtree);\n       case Token.IF:\n       case Token.HOOK:\n         return tryFoldHookIf(subtree);\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n \n-    if (!NodeUtil.mayHaveSideEffects(left)) {\n+    if (!mayHaveSideEffects(left)) {\n       // Fold it!\n       n.removeChild(right);\n       parent.replaceChild(n, right);\n   /**\n    * Try removing unneeded block nodes and their useless children\n    */\n-  Node tryFoldBlock(Node n) {\n+  Node tryOptimizeBlock(Node n) {\n     // TODO(dcc): Make sure this is also applied in the global scope\n     // (i.e. with Token.SCRIPT) parents\n     // Remove any useless children\n     for (Node c = n.getFirstChild(); c != null; ) {\n       Node next = c.getNext();  // save c.next, since 'c' may be removed\n-      if (!NodeUtil.mayHaveSideEffects(c)) {\n+      if (!mayHaveSideEffects(c)) {\n         n.removeChild(c);  // lazy kids\n         reportCodeChange();\n+      } else {\n+        tryOptimizeConditionalAfterAssign(c);\n       }\n       c = next;\n     }\n     }\n \n     return n;\n+  }\n+\n+  // TODO(johnlenz): Consider moving this to a separate peephole pass.\n+  /**\n+   * Attempt to replace the condition of if or hook immediately that is a\n+   * reference to a name that is assigned immediately before.\n+   */\n+  private void tryOptimizeConditionalAfterAssign(Node n) {\n+    Node next = n.getNext();\n+\n+    // Look for patterns like the following and replace the if-condition with\n+    // a constant value so it can later be folded:\n+    //   var a = /a/;\n+    //   if (a) {foo(a)}\n+    // or\n+    //   a = 0;\n+    //   a ? foo(a) : c;\n+    // or\n+    //   a = 0;\n+    //   a || foo(a);\n+    // or\n+    //   a = 0;\n+    //   a && foo(a)\n+    //\n+    // TODO(johnlenz): This would be better handled by control-flow sensitive\n+    // constant propagation. As the other case that I want to handle is:\n+    //   i=0; for(;i<0;i++){}\n+    // as right now nothing facilitates removing a loop like that.\n+    // This is here simply to remove the cruft left behind goog.userAgent and\n+    // similar cases.\n+\n+    if (isSimpleAssignment(n) && isConditionalStatement(next)) {\n+      Node lhsAssign = getSimpleAssignmentName(n);\n+\n+      Node condition = getConditionalStatementCondition(next);\n+      if (NodeUtil.isName(lhsAssign) && NodeUtil.isName(condition)\n+          && lhsAssign.getString().equals(condition.getString())) {\n+        Node rhsAssign = getSimpleAssignmentValue(n);\n+        TernaryValue value = NodeUtil.getExpressionBooleanValue(rhsAssign);\n+        if (value != TernaryValue.UNKNOWN) {\n+          int replacementConditionNodeType =\n+            (value.toBoolean(true)) ? Token.TRUE : Token.FALSE;\n+          condition.getParent().replaceChild(condition,\n+              new Node(replacementConditionNodeType));\n+          reportCodeChange();\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * @return whether the node is a assignment to a simple name, or simple var\n+   * declaration with initialization.\n+   */\n+  private boolean isSimpleAssignment(Node n) {\n+    // For our purposes we define a simple assignment to be a assignment\n+    // to a NAME node, or a VAR declaration with one child and a initializer.\n+    if (NodeUtil.isExprAssign(n)\n+        && NodeUtil.isName(n.getFirstChild().getFirstChild())) {\n+      return true;\n+    } else if (n.getType() == Token.VAR && n.hasOneChild() &&\n+        n.getFirstChild().getFirstChild() != null) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return The name being assigned to.\n+   */\n+  private Node getSimpleAssignmentName(Node n) {\n+    Preconditions.checkState(isSimpleAssignment(n));\n+    if (NodeUtil.isExprAssign(n)) {\n+      return n.getFirstChild().getFirstChild();\n+    } else {\n+      // A var declaration.\n+      return n.getFirstChild();\n+    }\n+  }\n+\n+  /**\n+   * @return The value assigned in the simple assignment\n+   */\n+  private Node getSimpleAssignmentValue(Node n) {\n+    Preconditions.checkState(isSimpleAssignment(n));\n+    return n.getFirstChild().getLastChild();\n+  }\n+\n+  /**\n+   * @return Whether the node is a conditional statement.\n+   */\n+  private boolean isConditionalStatement(Node n) {\n+    // We defined a conditional statement to be a IF or EXPR_RESULT rooted with\n+    // a HOOK, AND, or OR node.\n+    return n != null && (n.getType() == Token.IF || isExprConditional(n));\n+  }\n+\n+  /**\n+   * @return Whether the node is a rooted with a HOOK, AND, or OR node.\n+   */\n+  private boolean isExprConditional(Node n) {\n+    if (n.getType() == Token.EXPR_RESULT) {\n+      switch (n.getFirstChild().getType()) {\n+        case Token.HOOK:\n+        case Token.AND:\n+        case Token.OR:\n+          return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @return The condition of a conditional statement.\n+   */\n+  private Node getConditionalStatementCondition(Node n) {\n+    if (n.getType() == Token.IF) {\n+      return NodeUtil.getConditionExpression(n);\n+    } else {\n+      Preconditions.checkState(isExprConditional(n));\n+      return n.getFirstChild().getFirstChild();\n+    }\n   }\n \n   /**\n \n     if (type == Token.IF) {\n       // if (x) { .. } else { } --> if (x) { ... }\n-      if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {\n+      if (elseBody != null && !mayHaveSideEffects(elseBody)) {\n         n.removeChild(elseBody);\n         elseBody = null;\n         reportCodeChange();\n       }\n \n       // if (x) { } else { ... } --> if (!x) { ... }\n-      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {\n+      if (!mayHaveSideEffects(thenBody) && elseBody != null) {\n         n.removeChild(elseBody);\n         n.replaceChild(thenBody, elseBody);\n         Node notCond = new Node(Token.NOT);\n       }\n \n       // if (x()) { }\n-      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {\n-        if (NodeUtil.mayHaveSideEffects(cond)) {\n+      if (!mayHaveSideEffects(thenBody) && elseBody == null) {\n+        if (mayHaveSideEffects(cond)) {\n           // x() has side effects, just leave the condition on its own.\n           n.removeChild(cond);\n           Node replacement = NodeUtil.newExpr(cond);\n       Preconditions.checkState(type == Token.HOOK);\n       if (NodeUtil.isExpressionNode(parent)) {\n         // Try to remove useless nodes.\n-        if (!NodeUtil.mayHaveSideEffects(thenBody)) {\n+        if (!mayHaveSideEffects(thenBody)) {\n           // x?void 0:y --> if(!x)y\n           Node ifNode = new Node(Token.IF);\n           if (cond.getType() == Token.NOT) {\n           parent.getParent().replaceChild(parent, ifNode);\n           reportCodeChange();\n           return ifNode;\n-        } else if (!NodeUtil.mayHaveSideEffects(elseBody)) {\n+        } else if (!mayHaveSideEffects(elseBody)) {\n           // x?y:void 0 --> if(x)y\n           Node ifNode = new Node(Token.IF);\n           n.removeChild(cond);\n     }\n \n     // Try transforms that apply to both IF and HOOK.\n-    if (!NodeUtil.isLiteralValue(cond, true)) {\n-      return n;  // We can't remove branches otherwise!\n-    }\n-\n-    TernaryValue condValue = NodeUtil.getBooleanValue(cond);\n+    TernaryValue condValue = NodeUtil.getExpressionBooleanValue(cond);\n     if (condValue == TernaryValue.UNKNOWN) {\n       return n;  // We can't remove branches otherwise!\n+    }\n+\n+    // Transform \"if (a = 2) {x =2}\" into \"a=2;x=2\"\n+    if (mayHaveSideEffects(cond)) {\n+      if (n.getType() == Token.HOOK) {\n+        // Transform HOOK to BLOCK with the condition\n+        Node replacement = new Node(Token.BLOCK).copyInformationFrom(n);\n+        n.detachChildren();\n+        replacement.addChildToFront(\n+            new Node(Token.EXPR_RESULT, cond).copyInformationFrom(cond));\n+        Node branchToKeep = condValue.toBoolean(true) ? thenBody : elseBody;\n+        replacement.addChildToBack(\n+            NodeUtil.newExpr(branchToKeep)\n+                .copyInformationFrom(branchToKeep));\n+        // This modifies outside the subtree, which is not\n+        // desirable in a peephole optimization.\n+        parent.getParent().replaceChild(parent, replacement);\n+        reportCodeChange();\n+        return replacement;\n+      }\n+\n+      Preconditions.checkState(n.getType() == Token.IF);\n+      boolean newConditionValue = condValue == TernaryValue.TRUE;\n+      // Add an elseBody if it is needed.\n+      if (!newConditionValue && elseBody == null) {\n+        elseBody = new Node(Token.BLOCK).copyInformationFrom(n);\n+        n.addChildToBack(elseBody);\n+      }\n+      Node newCond = new Node(newConditionValue ? Token.TRUE : Token.FALSE);\n+      n.replaceChild(cond, newCond);\n+      Node branchToKeep = newConditionValue ? thenBody : elseBody;\n+      branchToKeep.addChildToFront(\n+          new Node(Token.EXPR_RESULT, cond).copyInformationFrom(cond));\n+      reportCodeChange();\n+      cond = newCond;\n     }\n \n     boolean condTrue = condValue.toBoolean(true);\n         reportCodeChange();\n         return thenStmt;\n       } else {\n-        // Replace \"if (false) { X }\" with empty node.\n+        // Remove \"if (false) { X }\" completely.\n         NodeUtil.redeclareVarsInsideBranch(n);\n         NodeUtil.removeChild(parent, n);\n         reportCodeChange();\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n \n /**\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n   private void assertBooleanUnknown(String val) {\n     assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));\n+  }\n+\n+  public void testGetExpressionBooleanValue() {\n+    assertExpressionBooleanTrue(\"a=true\");\n+    assertExpressionBooleanFalse(\"a=false\");\n+\n+    assertExpressionBooleanTrue(\"a=(false,true)\");\n+    assertExpressionBooleanFalse(\"a=(true,false)\");\n+\n+    assertExpressionBooleanTrue(\"a=(false || true)\");\n+    assertExpressionBooleanFalse(\"a=(true && false)\");\n+\n+    assertExpressionBooleanTrue(\"a=!(true && false)\");\n+\n+    assertExpressionBooleanTrue(\"a,true\");\n+    assertExpressionBooleanFalse(\"a,false\");\n+\n+    assertExpressionBooleanTrue(\"true||false\");\n+    assertExpressionBooleanFalse(\"false||false\");\n+\n+    assertExpressionBooleanTrue(\"true&&true\");\n+    assertExpressionBooleanFalse(\"true&&false\");\n+\n+    assertExpressionBooleanFalse(\"!true\");\n+    assertExpressionBooleanTrue(\"!false\");\n+    assertExpressionBooleanTrue(\"!''\");\n+\n+    // Assignment ops other than ASSIGN are unknown.\n+    assertExpressionBooleanUnknown(\"a *= 2\");\n+\n+    // Complex expressions that contain anything other then \"=\", \",\", or \"!\" are\n+    // unknown.\n+    assertExpressionBooleanUnknown(\"2 + 2\");\n+\n+    assertExpressionBooleanTrue(\"a=1\");\n+    assertExpressionBooleanTrue(\"a=/a/\");\n+    assertExpressionBooleanTrue(\"a={}\");\n+\n+    assertExpressionBooleanTrue(\"true\");\n+    assertExpressionBooleanTrue(\"10\");\n+    assertExpressionBooleanTrue(\"'0'\");\n+    assertExpressionBooleanTrue(\"/a/\");\n+    assertExpressionBooleanTrue(\"{}\");\n+    assertExpressionBooleanTrue(\"[]\");\n+    assertExpressionBooleanFalse(\"false\");\n+    assertExpressionBooleanFalse(\"null\");\n+    assertExpressionBooleanFalse(\"0\");\n+    assertExpressionBooleanFalse(\"''\");\n+    assertExpressionBooleanFalse(\"undefined\");\n+    assertExpressionBooleanFalse(\"void 0\");\n+    assertExpressionBooleanFalse(\"void foo()\");\n+\n+    assertExpressionBooleanTrue(\"a?true:true\");\n+    assertExpressionBooleanFalse(\"a?false:false\");\n+    assertExpressionBooleanUnknown(\"a?true:false\");\n+    assertExpressionBooleanUnknown(\"a?true:foo()\");\n+    \n+    assertExpressionBooleanUnknown(\"b\");\n+    assertExpressionBooleanUnknown(\"-'0.0'\");\n+  }\n+\n+  private void assertExpressionBooleanTrue(String val) {\n+    assertEquals(TernaryValue.TRUE,\n+        NodeUtil.getExpressionBooleanValue(getNode(val)));\n+  }\n+\n+  private void assertExpressionBooleanFalse(String val) {\n+    assertEquals(TernaryValue.FALSE,\n+        NodeUtil.getExpressionBooleanValue(getNode(val)));\n+  }\n+\n+  private void assertExpressionBooleanUnknown(String val) {\n+    assertEquals(TernaryValue.UNKNOWN,\n+        NodeUtil.getExpressionBooleanValue(getNode(val)));\n   }\n \n   public void testGetStringValue() {\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n \n     // This would be foldable, but it isn't detected, because 'if' isn't\n     // the parent of 'x || 3'. Cf. FoldConstants.tryFoldAndOr().\n-    fold(\"if(y() || x || 3) z()\", \"if(y()||x||1)z()\");\n+    fold(\"if(y() || x || 3) z()\", \"y()||x||1;z()\");\n   }\n \n   public void testFoldBitwiseOpStringCompareIntegration() {\n-    assertResultString(\"-1 | 0\", \"1\");\n+    assertResultString(\"while(-1 | 0){}\", \"while(1);\");\n   }\n \n   public void testVarLiftingIntegration() {\n   }\n \n   public void testMinimizeExpr() {\n-    /* This test is surprising.\n-     *\n-     * What is happening is this:\n-     * First PeepholeFoldConstants.tryFoldUnaryOperator is folding\n-     * the inner \"!true\" to \"false\", so the whole expression  becomes\n-     * !false.\n-     * Then, on the next iteration, tryFoldUnaryOperator sees the parent of\n-     * !false is a Token.EXPR_RESULT and is therefore not used,\n-     * so it drops the NOT, leaving false, which is then converted to 0.\n-     */\n-    test(\"!!true\", \"0\");\n-\n-    fold(\"!!x\", \"x\");\n-    test(\"!(!x&&!y)\", \"!x&&!y\");\n-    fold(\"x||!!y\", \"x||y\");\n+    test(\"!!true\", \"\");\n+\n+    fold(\"!!x()\", \"x()\");\n+    test(\"!(!x()&&!y())\", \"!x()&&!y()\");\n+    fold(\"x()||!!y()\", \"x()||y()\");\n \n     /* This is similar to the !!true case */\n-    fold(\"!(!!x&&y)\", \"x&&y\");\n+    fold(\"!(!!x()&&y())\", \"x()&&y()\");\n   }\n \n   public void testBug1509085() {\n   }\n \n   public void testFoldNegativeBug() {\n-    fold(\"(-3);\", \"1;\");\n+    fold(\"while(-3){};\", \"while(1);\");\n   }\n \n   public void testNoNormalizeLabeledExpr() {\n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n  * of multiple peephole passes are in PeepholeIntegrationTest.\n  */\n public class PeepholeRemoveDeadCodeTest extends CompilerTestCase {\n-  \n+\n   public PeepholeRemoveDeadCodeTest() {\n     super(\"\");\n   }\n   public CompilerPass getProcessor(final Compiler compiler) {\n     PeepholeOptimizationsPass peepholePass =\n       new PeepholeOptimizationsPass(compiler, new PeepholeRemoveDeadCode());\n-    \n+\n     return peepholePass;\n   }\n \n     return 2;\n   }\n \n-  private void foldSame(String js) {  \n+  private void foldSame(String js) {\n     testSame(js);\n   }\n \n   private void fold(String js, String expected) {\n     test(js, expected);\n   }\n-  \n+\n   public void testFoldBlock() {\n     fold(\"{{foo()}}\", \"foo()\");\n     fold(\"{foo();{}}\", \"foo()\");\n     fold(\"{var x; var y; var z; function f() { { var a; { var b; } } } }\",\n          \"var x;var y;var z;function f(){var a;var b}\");\n   }\n-  \n+\n   public void testHookIf() {\n     fold(\"if (1){ x=1; } else { x = 2;}\", \"x=1\");\n     fold(\"if (false){ x = 1; } else { x = 2; }\", \"x=2\");\n     // foldSame(\"if (void foo()){ x = 1; } else { x = 2; }\");\n     fold(\"if (false){ x = 1; } else if (true) { x = 3; } else { x = 2; }\",\n          \"x=3\");\n-    \n+\n     fold(\"var x = (true) ? 1 : 0\", \"var x=1\");\n     fold(\"var y = (true) ? ((false) ? 12 : (cond ? 1 : 2)) : 13\",\n          \"var y=cond?1:2\");\n     fold(\"if (x){ x = 1; } else if (false) { x = 3; }\", \"if(x)x=1\");\n-    \n+\n     foldSame(\"var z=x?void 0:y()\");\n     foldSame(\"z=x?void 0:y()\");\n     foldSame(\"z*=x?void 0:y()\");\n-    \n+\n     foldSame(\"var z=x?y():void 0\");\n     foldSame(\"(w?x:void 0).y=z\");\n     foldSame(\"(w?x:void 0).y+=z\");\n   }\n-  \n+\n+  public void testConstantConditionWithSideEffect1() {\n+    fold(\"if (b=true) x=1;\", \"b=true;x=1\");\n+    fold(\"if (b=/ab/) x=1;\", \"b=/ab/;x=1\");\n+    fold(\"if (b=/ab/){ x=1; } else { x=2; }\", \"b=/ab/;x=1\");\n+    fold(\"var b;b=/ab/;if(b)x=1;\", \"var b;b=/ab/;x=1\");\n+    foldSame(\"var b;b=f();if(b)x=1;\");\n+    fold(\"var b=/ab/;if(b)x=1;\", \"var b=/ab/;x=1\");\n+    foldSame(\"var b=f();if(b)x=1;\");\n+    foldSame(\"b=b++;if(b)x=b;\");\n+    fold(\"(b=0,b=1);if(b)x=b;\", \"b=0;b=1;x=b;\");\n+    fold(\"b=1;if(foo,b)x=b;\",\"b=1;x=b;\");\n+    foldSame(\"b=1;if(foo=1,b)x=b;\");\n+  }\n+\n+  public void testConstantConditionWithSideEffect2() {\n+    fold(\"(b=true)?x=1:x=2;\", \"b=true;x=1\");\n+    fold(\"(b=false)?x=1:x=2;\", \"b=false;x=2\");\n+    fold(\"if (b=/ab/) x=1;\", \"b=/ab/;x=1\");\n+    fold(\"var b;b=/ab/;(b)?x=1:x=2;\", \"var b;b=/ab/;x=1\");\n+    foldSame(\"var b;b=f();(b)?x=1:x=2;\");\n+    fold(\"var b=/ab/;(b)?x=1:x=2;\", \"var b=/ab/;x=1\");\n+    foldSame(\"var b=f();(b)?x=1:x=2;\");\n+  }\n+\n   public void testVarLifting() {\n     fold(\"if(true)var a\", \"var a\");\n     fold(\"if(false)var a\", \"var a\");\n-   \n+\n     // More var lifting tests in PeepholeIntegrationTests\n   }\n-  \n+\n   public void testFoldUselessWhile() {\n     fold(\"while(false) { foo() }\", \"\");\n-    \n+\n     fold(\"while(void 0) { foo() }\", \"\");\n     fold(\"while(undefined) { foo() }\", \"\");\n-    \n+\n     foldSame(\"while(true) foo()\");\n-    \n+\n     fold(\"while(false) { var a = 0; }\", \"var a\");\n-    \n+\n     // Make sure it plays nice with minimizing\n     fold(\"while(false) { foo(); continue }\", \"\");\n-      \n+\n     fold(\"while(0) { foo() }\", \"\");\n   }\n \n     fold(\"for(;true;) foo() \", \"for(;;) foo() \");\n     foldSame(\"for(;;) foo()\");\n     fold(\"for(;false;) { var a = 0; }\", \"var a\");\n-    \n+\n     // Make sure it plays nice with minimizing\n     fold(\"for(;false;) { foo(); continue }\", \"\");\n   }\n-  \n+\n   public void testFoldUselessDo() {\n     fold(\"do { foo() } while(false);\", \"foo()\");\n     fold(\"do { foo() } while(void 0);\", \"foo()\");\n     foldSame(\"do { foo(); continue; } while(0)\");\n     foldSame(\"do { foo(); break; } while(0)\");\n     }\n-  \n+\n   public void testMinimizeWhileConstantCondition() {\n     fold(\"while(true) foo()\", \"while(true) foo()\");\n     fold(\"while(0) foo()\", \"\");\n     fold(\"while(undefined) foo()\", \"\");\n     fold(\"while('') foo()\", \"\");\n   }\n-  \n+\n   public void testFoldConstantCommaExpressions() {\n     fold(\"if (true, false) {foo()}\", \"\");\n     fold(\"if (false, true) {foo()}\", \"foo()\");\n     fold(\"true, foo()\", \"foo()\");\n     fold(\"(1 + 2 + ''), foo()\", \"foo()\");\n   }\n-  \n+\n   public void testSplitCommaExpressions() {\n     // Don't try to split in expressions.\n-    foldSame(\"if (foo(), true) boo()\");\n+    foldSame(\"while (foo(), true) boo()\");\n     foldSame(\"var a = (foo(), true);\");\n     foldSame(\"a = (foo(), true);\");\n \n     fold(\"(x=2), foo()\", \"x=2; foo()\");\n     fold(\"foo(), boo();\", \"foo(); boo()\");\n     fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n-    // TODO(johnlenz): interestingly we don't remove side-effect free expression\n-    // in a script block (as it is currently part of block folding), so \"1;\"\n-    // is left.\n-    fold(\"foo(), true\", \"foo();true\");\n+    fold(\"foo(), true\", \"foo();\");\n     fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n   }\n }", "timestamp": 1280951234, "metainfo": ""}