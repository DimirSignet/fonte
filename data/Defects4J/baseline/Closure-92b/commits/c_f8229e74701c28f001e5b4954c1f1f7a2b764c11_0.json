{"sha": "f8229e74701c28f001e5b4954c1f1f7a2b764c11", "log": "some whitespace-only changes  Fix up a type annotation on jquery externs.   Revision created by MOE tool push_codebase. MOE_MIGRATION=weleuk   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/CombinedCompilerPass.java\n  * <p>A compiler pass combining multiple {@link Callback}\n  * and {@link ScopedCallback} objects. This pass can be used to separate\n  * logically different verifications without incurring any additional traversal\n- * and CFG generation costs.</p> \n+ * and CFG generation costs.</p>\n  *\n  * <p>Due to this compiler pass' nature, none of the callbacks may mutate\n  * the parse tree.</p>\n *\n  */\n final class CombinedCompilerPass implements CompilerPass, ScopedCallback {\n-  \n+\n   /** The callbacks that this pass combines. */\n   private final CallbackWrapper[] callbacks;\n   private final AbstractCompiler compiler;\n       this.callbacks[i] = new CallbackWrapper(callbacks[i]);\n     }\n   }\n-  \n+\n   /**\n    * Maintains information about a callback in order to simulate it being the\n    * exclusive client of the shared {@link NodeTraversal}. In particular, this\n    * returns false for\n    * {@link Callback#shouldTraverse(NodeTraversal, Node, Node)}.\n    * The callback becomes inactive (i.e., traversal messages are not sent to it)\n-   * until the main traversal revisits the node during the post-order visit. \n-   * \n+   * until the main traversal revisits the node during the post-order visit.\n+   *\n *\n    */\n   private static class CallbackWrapper {\n     /** The callback being wrapped. Never null. */\n     private final Callback callback;\n-    /** \n+    /**\n      * if (callback instanceof ScopedCallback), then scopedCallback points\n      * to an instance of ScopedCallback, otherwise scopedCallback points to null\n      */\n     private final ScopedCallback scopedCallback;\n-    \n+\n     /**\n      * The node that {@link Callback#shouldTraverse(NodeTraversal, Node, Node)}\n      * returned false for. The wrapped callback doesn't receive messages until\n      * after this node is revisited in the post-order traversal.\n      */\n     private Node waiting = null;\n-    \n+\n     private CallbackWrapper(Callback callback) {\n       this.callback = callback;\n       if (callback instanceof ScopedCallback) {\n \n     /**\n      * Visits the node unless the wrapped callback is inactive. Activates the\n-     * callback if appropriate. \n+     * callback if appropriate.\n      */\n     void visitOrMaybeActivate(NodeTraversal t, Node n, Node parent) {\n       if (isActive()) {\n         waiting = null;\n       }\n     }\n-    \n+\n     void shouldTraverseIfActive(NodeTraversal t, Node n, Node parent) {\n       if (isActive() && !callback.shouldTraverse(t, n, parent)) {\n         waiting = n;\n       }\n     }\n-    \n+\n     void enterScopeIfActive(NodeTraversal t) {\n       if (isActive() && scopedCallback != null) {\n         scopedCallback.enterScope(t);\n       }\n     }\n-    \n+\n     void exitScopeIfActive(NodeTraversal t) {\n       if (isActive() && scopedCallback != null) {\n         scopedCallback.exitScope(t);\n       }\n     }\n-    \n+\n     boolean isActive() {\n       return waiting == null;\n     }\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n     if (scope.isGlobal()) {\n       return;\n     }\n-    \n+\n     // We are not going to do any dead assignment elimination in when there is\n     // at least one inner function because in most browsers, when there is a\n     // closure, ALL the variables are saved (escaped).\n           continue;\n         // TODO(user): case Token.VAR: Remove var a=1;a=2;.....\n       }\n-      \n+\n       tryRemoveAssignment(t, n, state);\n     }\n   }\n       FlowState<LiveVariableLattice> state) {\n     tryRemoveAssignment(t, n, n, state);\n   }\n-  \n+\n   /**\n    * Determines if any local variables are dead after the instruction {@code n}\n    * and are assigned within the subtree of {@code n}. Removes those assignments\n       FlowState<LiveVariableLattice> state) {\n \n     Node parent = n.getParent();\n-    \n+\n     if (NodeUtil.isAssignmentOp(n) ||\n         n.getType() == Token.INC || n.getType() == Token.DEC) {\n \n       Node lhs = n.getFirstChild();\n       Node rhs = lhs.getNext();\n-      \n+\n       // Recurse first. Example: dead_x = dead_y = 1; We try to clean up dead_y\n       // first.\n       if (rhs != null) {\n         // of GEN sets when we recurse here.\n         return;\n       }\n-      \n+\n       if (NodeUtil.isAssign(n)) {\n         n.removeChild(rhs);\n         n.getParent().replaceChild(n, rhs);\n         n.removeChild(lhs);\n         Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);\n         parent.replaceChild(n, op);\n-      } else if (n.getType() == Token.INC || n.getType() == Token.DEC) {        \n+      } else if (n.getType() == Token.INC || n.getType() == Token.DEC) {\n         if (NodeUtil.isExpressionNode(parent)) {\n           parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0)));\n         } else if(n.getType() == Token.COMMA && n != parent.getLastChild()) {\n         // Not reachable.\n         Preconditions.checkState(false, \"Unknown statement\");\n       }\n-      \n+\n       compiler.reportCodeChange();\n       return;\n \n       return;\n     }\n   }\n-  \n+\n   /**\n    * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n    * the root, this function returns true if there exists a read of that\n    * variable before a write to that variable that is on the right side of n.\n-   * \n+   *\n    * For example, suppose the node is x = 1:\n-   * \n+   *\n    * y = 1, x = 1; // false, there is no reads at all.\n    * y = 1, x = 1, print(x) // true, there is a read right of n.\n-   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but \n+   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but\n    *                               // it is after a write.\n-   * \n+   *\n    * @param n The current node we should look at.\n    * @param exprRoot The node\n    */\n           sibling = sibling.getNext()) {\n         if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n           VariableLiveness state = readVariableBeforeKilling(sibling, variable);\n-          \n+\n           // If we see a READ or KILL there is no need to continue.\n           if (state == VariableLiveness.READ) {\n             return true;\n     }\n     return false;\n   }\n-  \n+\n   // The current liveness of the variable\n   private enum VariableLiveness {\n     MAYBE_LIVE, // May be still live in the current expression tree.\n    * Give an expression and a variable. It returns READ, if the right-most\n    * reference of that variable is a read. It returns KILL, if the right-most\n    * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n-   * \n+   *\n    * This need to be a pre-order traversal so we cannot use the normal node\n    * traversals.\n    */\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n       if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n         return false;\n       }\n-      \n+\n       // TODO(user): We could inline all the uses if the expression is short.\n \n       // Finally we have to make sure that there are no more than one use\n       // We give up inling stuff with R-Value that has GETPROP, GETELEM,\n       // or anything that creates a new object.\n       // Example:\n-      // var x = a.b.c; j.c = 1; print(x); \n+      // var x = a.b.c; j.c = 1; print(x);\n       // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n       // TODO(user): We could get more accuracy by looking more in-detail\n       // what j is and what x is trying to into to.\n           })) {\n         return false;\n       }\n-      \n+\n       Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n \n       if (uses.size() != 1) {\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.CopySideEffectSubexpressions;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n-import java.util.PriorityQueue;\n import java.util.Set;\n \n /**\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n     for (Node ref : currentArgumentsAccess) {\n \n       Node getElem = ref.getParent();\n-      \n+\n       // Bail on anything but argument[c] access where c is a constant.\n       // TODO(user): We might not need to bail out all the time, there might\n       // be more cases that we can cover.\n         // it is never 'callee'.\n         return false; // Give up.\n       }\n-      \n+\n       Node getElemParent = getElem.getParent();\n       // When we have argument[0](), replacing it with a() is semantically\n       // different if argument[0] is a function call that refers to 'this'\n--- a/src/com/google/javascript/jscomp/ParallelCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/ParallelCompilerPass.java\n     // Result objects.\n     public Result processSubtree(Node subtree);\n   }\n-  \n+\n   /**\n    * Holds all the information about the ending result of a compilation task on\n    * the subtree.\n     boolean changed = false;\n     List<JSError> errors = Lists.newArrayList();\n     List<Exception> exceptions = Lists.newArrayList();\n-    \n+\n     /**\n      * creates a result without any error, exceptions or changes to the AST.\n      */\n     public Result() {}\n-    \n+\n     /**\n      * Creates a result without any error or exceptions.\n      */\n     public Result(boolean changed) {\n       this.changed = changed;\n     }\n-    \n+\n     /**\n      * Combines two results.\n      */\n       errors.addAll(other.errors);\n       exceptions.addAll(other.exceptions);\n     }\n-    \n+\n     /**\n      * Inform the compiler of all the changes this result object had recorded.\n      * It might trigger a {@link Compiler#recentChange}, re-throw all the\n       }\n     }\n   }\n-  \n+\n   /**\n    * Constructor.\n-   * \n+   *\n    * @param splitter Will be used to split up the AST into smaller subtrees.\n    * @param taskSupply A supplier of tasks that should be thread-safe.\n    * @param numWorkers Number of worker thread.\n     this.numWorkers = numWorkers;\n     this.compiler = compiler;\n   }\n-  \n+\n   @Override\n   public void process(Node externs, Node root) {\n     // List of subtree to work with.\n     splitter.join();\n     r.notifyCompiler(compiler);\n   }\n-  \n+\n   /**\n    * Main loop that creates the worker threads and do work.\n-   * \n+   *\n    * @return the combined result of all task execution on the work list.\n    */\n   private Result execute() {\n        workers[i] = worker;\n        worker.start();\n     }\n-    \n+\n     Result result = processAllTasks();\n \n     // Wait for the child to finish.\n         Thread.currentThread().interrupt();\n       }\n     }\n-    \n+\n     // Combine the result.\n     for (int i = 0; i < numChildThread; i++) {\n       result.combine(results[i]);\n     }\n-    \n+\n     return result;\n   }\n-  \n+\n   private Result processAllTasks() {\n     Result result = new Result();\n     while(true) {\n     }\n     return result;\n   }\n-  \n+\n   /**\n    * Get a subtree from the work list and work on it. This method makes a call\n    * to the supplier which is also assumed thread-safe. It also calls\n    * getTask() which is synchronized.\n-   * \n+   *\n    * @return The result of performing the task specified by the task supplier\n    * on the next subtree from the work list. {@code null} if there are no more\n    * work load from the work list.\n       r.exceptions.add(e);\n       return r;\n     }\n-  } \n-  \n+  }\n+\n   /** Retrieves a subtree to work on from the work list. This must be atomic. */\n   private synchronized Node getTask() {\n     // Since the method is protected by a lock, there is no need for a thread-\n--- a/src/com/google/javascript/jscomp/TightenTypes.java\n+++ b/src/com/google/javascript/jscomp/TightenTypes.java\n \n   private ConcreteType createTypeIntersection(\n       ConcreteType concreteType, JSType jsType) {\n-    // TODO(johnlenz): Even with memoizing all the time of this pass is still \n+    // TODO(johnlenz): Even with memoizing all the time of this pass is still\n     // spent in this function (due to invalidation caused by changes to\n     // allInstantiatedTypes), specifically calls to ConcreteUnionType.unionWith\n     ConcreteJSTypePair key = new ConcreteJSTypePair(concreteType, jsType);\n--- a/src/com/google/javascript/rhino/jstype/BooleanType.java\n+++ b/src/com/google/javascript/rhino/jstype/BooleanType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Lists;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.io.Serializable;\n import java.util.Comparator;\n-import java.util.List;\n \n /**\n  * Represents JavaScript value types.<p>\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.base.Preconditions;\n--- a/src/com/google/javascript/rhino/jstype/NumberType.java\n+++ b/src/com/google/javascript/rhino/jstype/NumberType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n--- a/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/ParameterizedType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n \n import static com.google.common.base.Preconditions.checkState;\n \n-import com.google.common.base.Preconditions;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.io.Serializable;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n--- a/src/com/google/javascript/rhino/jstype/StringType.java\n+++ b/src/com/google/javascript/rhino/jstype/StringType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n--- a/test/com/google/javascript/jscomp/CheckMissingReturnTest.java\n+++ b/test/com/google/javascript/jscomp/CheckMissingReturnTest.java\n \n     // Switch statement.\n     testMissing(\"switch(1) { case 12: return 5; }\");\n-    \n+\n     // Test try catch finally.\n     testMissing(\"try { foo() } catch (e) { return 5; } finally { }\");\n \n     testNotMissing(\"(number,void)\", \"var x;\");\n     testNotMissing(\"(number,undefined)\", \"var x;\");\n     testNotMissing(\"*\", \"var x;\");\n-    \n+\n     // Test try catch finally.\n     testNotMissing(\"try { return foo() } catch (e) { } finally { }\");\n \n     testNotMissing(\"switch(1) { default: return 1; }\");\n     testNotMissing(\"switch(g) { case 1: return 1; default: return 2; }\");\n   }\n-  \n+\n   public void testFinallyStatements() {\n     // The control flow analysis (CFA) treats finally blocks somewhat strangely.\n     // The CFA might indicate that a finally block implicitly returns. However,\n     testNotMissing(\"try { return 1; } finally { }\");\n     testNotMissing(\"try { } finally { return 1; }\");\n     testMissing(\"try { } finally { }\");\n-    \n+\n     // Cycles in the CFG within the finally block were causing problems before.\n     testNotMissing(\"try { return 1; } finally { while (true) { } }\");\n     testMissing(\"try { } finally { while (x) { } }\");\n         \"}\" +\n         \"finally { }\");\n   }\n-  \n+\n   public void testKnownConditions() {\n     testNotMissing(\"if (true) return 1\");\n     testMissing(\"if (true) {} else {return 1}\");\n-    \n+\n     testMissing(\"if (false) return 1\");\n     testNotMissing(\"if (false) {} else {return 1}\");\n-    \n+\n     testNotMissing(\"if (1) return 1\");\n     testMissing(\"if (1) {} else {return 1}\");\n-    \n+\n     testMissing(\"if (0) return 1\");\n     testNotMissing(\"if (0) {} else {return 1}\");\n \n     testNotMissing(\"if (3) return 1\");\n     testMissing(\"if (3) {} else {return 1}\");\n   }\n-  \n+\n   public void testKnownWhileLoop() {\n     testNotMissing(\"while (1) return 1\");\n     testNotMissing(\"while (1) { if (x) {return 1} else {return 1}}\");\n     testNotMissing(\"while (0) {} return 1\");\n-    \n+\n     // TODO(user): The current algorithm will not detect this case. It is\n     // still computable in most cases.\n     testNotMissing(\"while (1) {} return 0\");\n     testMissing(\"while (false) return 1\");\n-    \n+\n     // Not known.\n     testMissing(\"while(x) { return 1 }\");\n   }\n     testMissing(\"if (a) { } else { while (1) {return 1} }\");\n     testNotMissing(\"if (a) { return 1} else { while (1) {return 1} }\");\n   }\n-  \n+\n   private static String createFunction(String returnType, String body) {\n     return \"/** @return {\" + returnType + \"} */ function foo() {\" + body + \"}\";\n   }\n     String js = createFunction(returnType, body);\n     test(js, js, CheckMissingReturn.MISSING_RETURN_STATEMENT);\n   }\n-  \n+\n   private void testNotMissing(String returnType, String body) {\n-    testSame(createFunction(returnType, body));    \n+    testSame(createFunction(returnType, body));\n   }\n \n   /** Creates function with return type {number} */\n   private void testNotMissing(String body) {\n     testNotMissing(\"number\", body);\n   }\n-  \n+\n   /** Creates function with return type {number} */\n   private void testMissing(String body) {\n     testMissing(\"number\", body);\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n   // picking out which variable names are merged.\n \n   private boolean usePseudoName = false;\n-  \n+\n   @Override\n   protected int getNumRepetitions() {\n    return 1;\n-  }  \n-  \n+  }\n+\n   @Override\n   public void setUp() {\n     usePseudoName = false;\n   }\n-  \n+\n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n                \"var x; var y; var a;       \" +\n                \"y = 1, a = 1, y, x = 1; a; x; x = 1; x\");\n   }\n-  \n+\n   public void testFunctionNameReuse() {\n // TODO(user): Figure out why this increase code size most of the time.\n //    inFunction(\"function x() {}; x(); var y = 1; y\",\n //    // Can't merge because of possible escape.\n //    inFunction(\"function x() {return x}; x(); var y = 1; y\",\n //               \"function x() {return x}; x(); var y = 1; y\");\n-// \n+//\n //    inFunction(\"var y = 1; y; x; function x() {}\",\n //               \"var y = 1; y; x; function x() {}\");\n //    inFunction(\"var y = 1; y; function x() {}; x\",\n     usePseudoName = true;\n     inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y)\",\n                \"var x_y = 0; print(x_y);     x_y = 1; print(x_y)\");\n-    \n-    inFunction(\"var x_y = 1; var x   = 0; print(x  ); var     y = 1;\" + \n+\n+    inFunction(\"var x_y = 1; var x   = 0; print(x  ); var     y = 1;\" +\n                \"print(  y); print(x_y);\",\n \n                \"var x_y = 1; var x_y$ = 0; print(x_y$);     x_y$ = 1;\" + \"\" +\n                \"print(x_y$); print(x_y);\");\n-    \n+\n     inFunction(\"var x_y = 1; function f() {\" +\n                \"var x    = 0; print(x  ); var y = 1; print( y);\" +\n                \"print(x_y);}\",\n                \"var x_y = 1; function f() {\" +\n                \"var x_y$ = 0; print(x_y$); x_y$ = 1; print(x_y$);\" +\n                \"print(x_y);}\");\n-    \n+\n     inFunction(\"var x   = 0; print(x  ); var   y = 1; print(  y); \" +\n                \"var closure_var; function bar() { print(closure_var); }\",\n                \"var x_y = 0; print(x_y);     x_y = 1; print(x_y); \" +\n                \"var closure_var; function bar() { print(closure_var); }\");\n   }\n-  \n+\n   private void inFunction(String src) {\n     inFunction(src, src);\n   }\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n     inFunction(\"var x; switch(x=1){}\",\"var x; switch(1){}\");\n     inFunction(\"var x; switch(x){case(x=1):break;}\",\n         \"var x; switch(x){case(1):break;}\");\n-    \n+\n     inFunction(\"var x,y; switch(y) { case (x += 1): break; case (x): break;}\");\n-    \n+\n     inFunction(\"var x,y; switch(y) { case (x = 1): break; case (2): break;}\",\n                \"var x,y; switch(y) { case (1): break; case (2): break;}\");\n     inFunction(\"var x,y; switch(y) { case (x+=1): break; case (x=2): break;}\",\n     inFunction(\"var x; return x = 1;\", \"var x; return 1\");\n     inFunction(\"var x; return\");\n   }\n-  \n+\n   public void testAssignmentInArgs() {\n     inFunction(\"var x; foo(x = 1);\", \"var x; foo(1);\");\n     inFunction(\"var x; return foo(x = 1);\", \"var x; return foo(1);\");\n     inFunction(\"var x = function() { var x; x=1; }\",\n         \"var x = function() { var x; 1; }\");\n   }\n-  \n+\n   public void testInnerFunctions2() {\n     // Give up DCE if there is a inner function.\n     inFunction(\"var x = 0; print(x); x = 1; var y = function(){}; y()\");\n   public void testSelfReAssignment() {\n     inFunction(\"var x; x = x;\", \"var x; x\");\n   }\n-  \n+\n   public void testSelfIncrement() {\n     inFunction(\"var x; x = x + 1;\", \"var x; x + 1\");\n   }\n-  \n+\n   public void testAssignmentOp() {\n     // We have remove constant expressions that cleans this one up.\n     inFunction(\"var x; x += foo()\", \"var x; x + foo()\");\n   }\n-  \n+\n   public void testAssignmentOpUsedAsLhs() {\n     inFunction(\"var x,y; y = x += foo(); print(y)\",\n                \"var x,y; y = x +  foo(); print(y)\");\n   }\n-  \n-  public void testAssignmentOpUsedAsCondition() {    \n+\n+  public void testAssignmentOpUsedAsCondition() {\n     inFunction(\"var x; if(x += foo()) {}\",\n                \"var x; if(x +  foo()) {}\");\n \n     inFunction(\"var x; if((x += foo()) > 1) {}\",\n                \"var x; if((x +  foo()) > 1) {}\");\n-    \n+\n     // Not in a while because this happens every loop.\n     inFunction(\"var x; while((x += foo()) > 1) {}\");\n-    \n+\n     inFunction(\"var x; for(;--x;){}\");\n     inFunction(\"var x; for(;x--;){}\");\n     inFunction(\"var x; for(;x -= 1;){}\");\n     inFunction(\"var x; for(;x = 0;){}\", \"var x; for(;0;){}\");\n-    \n+\n     inFunction(\"var x; for(;;--x){}\");\n     inFunction(\"var x; for(;;x--){}\");\n     inFunction(\"var x; for(;;x -= 1){}\");\n     inFunction(\"var x; for(;;x = 0){}\", \"var x; for(;;0){}\");\n-    \n+\n     inFunction(\"var x; for(--x;;){}\", \"var x; for(;;){}\");\n     inFunction(\"var x; for(x--;;){}\", \"var x; for(;;){}\");\n     inFunction(\"var x; for(x -= 1;;){}\", \"var x; for(x - 1;;){}\");\n     inFunction(\"var x; for(x = 0;;){}\", \"var x; for(0;;){}\");\n   }\n-  \n+\n   public void testDeadIncrement() {\n     // TODO(user): Optimize this.\n     inFunction(\"var x; x ++\", \"var x; void 0\");\n     inFunction(\"var x; x --\", \"var x; void 0\");\n   }\n-  \n+\n   public void testDeadButAlivePartiallyWithinTheExpression() {\n     inFunction(\"var x; x = 100, print(x), x = 101;\",\n                \"var x; x = 100, print(x),     101;\");\n     inFunction(\"var x; x = 100, print(x), x = 0, print(x), x = 101;\",\n                \"var x; x = 100, print(x), x = 0, print(x),     101;\");\n   }\n-  \n+\n   public void testMutipleDeadAssignmentsButAlivePartiallyWithinTheExpression() {\n-    inFunction(\"var x; x = 1, x = 2, x = 3, x = 4, x = 5,\" + \n+    inFunction(\"var x; x = 1, x = 2, x = 3, x = 4, x = 5,\" +\n                \"  print(x), x = 0, print(x), x = 101;\",\n-               \n+\n                \"var x; 1, 2, 3, 4, x = 5, print(x), x = 0, print(x), 101;\");\n   }\n-  \n+\n \n   public void testDeadPartiallyWithinTheExpression() {\n     // Sadly, this is not covered. We don't suspect this would happend too\n     // often.\n     inFunction(\"var x; x = 100, x = 101; print(x);\");\n   }\n-  \n+\n   public void testAssignmentChain() {\n     inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1\",\n                \"var a,b,c,d,e; 1\");\n                \"var a,b,c,d,e; a = b =     d = e = 1; print(a + b + d + e)\");\n     inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1; print(a+b+c+d+e)\");\n   }\n-  \n+\n   public void testAssignmentOpChain() {\n     inFunction(\"var a,b,c,d,e; a = b = c += d = e = 1\",\n                \"var a,b,c,d,e;         c + 1\");\n     inFunction(\"var a,b,c,d,e; a = b = c += d = e = 1;  print(a)\",\n                \"var a,b,c,d,e; a =     c +          1;  print(a)\");\n   }\n-  \n+\n   public void testIncDecInSubExpressions() {\n     inFunction(\"var a; a = 1, a++; a\");\n     inFunction(\"var a; a = 1, ++a; a\");\n     inFunction(\"var a; a = 1, ++a, print(a)\");\n     inFunction(\"var a; a = 1, a--, print(a)\");\n     inFunction(\"var a; a = 1, --a, print(a)\");\n-    \n+\n     inFunction(\"var a; a = 1, print(a++)\");\n     inFunction(\"var a; a = 1, print(++a)\");\n \n     inFunction(\"var a; a = 1, print(a--)\");\n     inFunction(\"var a; a = 1, print(--a)\");\n   }\n-  \n+\n   public void testNestedReassignments() {\n     inFunction(\"var a; a = (a = 1)\", \"var a; 1\");\n     inFunction(\"var a; a = (a *= 2)\", \"var a; a*2\");\n-       \n+\n     // Note a = (a++) is not same as a++. Only if 'a' is dead.\n     inFunction(\"var a; a = (a++)\", \"var a; void 0\");\n     inFunction(\"var a; a = (++a)\", \"var a; void 0\");\n-    \n+\n     inFunction(\"var a; a = (b = (a = 1))\", \"var a; b = 1\");\n     inFunction(\"var a; a = (b = (a *= 2))\", \"var a; b = a * 2\");\n     inFunction(\"var a; a = (b = (a++))\", \"var a; b=a++\");\n     inFunction(\"var a; a = (b = (++a))\", \"var a; b=++a\");\n-    \n+\n     // Include b as local.\n     inFunction(\"var a,b; a = (b = (a = 1))\", \"var a,b; 1\");\n     inFunction(\"var a,b; a = (b = (a *= 2))\", \"var a,b; a * 2\");\n     inFunction(\"var a,b; a = (b = (a++))\", \"var a,b; void 0\");\n     inFunction(\"var a,b; a = (b = (++a))\", \"var a,b; void 0\");\n-    \n+\n     inFunction(\"var a; a += (a++)\", \"var a; a + a++\");\n     inFunction(\"var a; a += (++a)\", \"var a; a+ (++a)\");\n-    \n+\n     // Include b as local.\n     inFunction(\"var a,b; a += (b = (a = 1))\", \"var a,b; a + 1\");\n     inFunction(\"var a,b; a += (b = (a *= 2))\", \"var a,b; a + (a * 2)\");\n     inFunction(\"var a,b; a += (b = (a++))\", \"var a,b; a + a++\");\n-    inFunction(\"var a,b; a += (b = (++a))\", \"var a,b; a+(++a)\"); \n-  }\n-  \n+    inFunction(\"var a,b; a += (b = (++a))\", \"var a,b; a+(++a)\");\n+  }\n+\n   public void testIncrementalReassignmentInForLoops() {\n     inFunction(\"for(;x+=1;x+=1) {}\");\n     inFunction(\"for(;x;x+=1){}\");\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n \n /**\n  * Unit tests for {@link FlowSensitiveInlineVariables}.\n- * \n+ *\n *\n  */\n public class FlowSensitiveInlineVariablesTest extends CompilerTestCase  {\n     // Test repeatedly inline.\n     return 3;\n   }\n-  \n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new FlowSensitiveInlineVariables(compiler);\n   }\n-  \n+\n   public void testSimpleAssign() {\n     inline(\"var x; x = 1; print(x)\", \"var x; print(1)\");\n     inline(\"var x; x = 1; x\", \"var x; 1\");\n     inline(\"var x; x = 1; var a = x\", \"var x; var a = 1\");\n   }\n-  \n+\n   public void testSimpleVar() {\n     inline(\"var x = 1; print(x)\", \"var x; print(1)\");\n     inline(\"var x = 1; x\", \"var x; 1\");\n-    inline(\"var x = 1; var a = x\", \"var x; var a = 1\");    \n+    inline(\"var x = 1; var a = x\", \"var x; var a = 1\");\n   }\n \n   public void testExported() {\n     noInline(\"var x = 1; x++;\");\n     noInline(\"var x = 1; x--;\");\n   }\n-  \n+\n   public void testDoNotInlineAssignmentOp() {\n     noInline(\"var x = 1; x += 1;\");\n     noInline(\"var x = 1; x -= 1;\");\n   }\n-  \n+\n   public void testDoNotInlineIntoLhsOfAssign() {\n     noInline(\"var x = 1; x += 3;\");\n   }\n-  \n+\n   public void testMultiUse() {\n     noInline(\"var x; x = 1; print(x); print (x);\");\n   }\n   public void testMultiUseInSameCfgNode() {\n     noInline(\"var x; x = 1; print(x) || print (x);\");\n   }\n-  \n+\n   public void testMultiUseInTwoDifferentPath() {\n     noInline(\"var x = 1; if (print) { print(x) } else { alert(x) }\");\n   }\n-  \n+\n   public void testVarInConditionPath() {\n     noInline(\"if (foo) { var x = 0 } print(x)\");\n   }\n   public void testNotReachingDefinitions() {\n     noInline(\"var x; if (foo) { x = 0 } print (x)\");\n   }\n-  \n+\n   public void testNoInlineLoopCarriedDefinition() {\n     // First print is undefined instead.\n     noInline(\"var x; while(true) { print(x); x = 1; }\");\n-    \n+\n     // Prints 0 1 1 1 1....\n     noInline(\"var x = 0; while(true) { print(x); x = 1; }\");\n   }\n-  \n+\n   public void testDoNotExitLoop() {\n     noInline(\"while (z) { var x = 3; } var y = x;\");\n   }\n   public void testDefinitionAfterUse() {\n     inline(\"var x = 0; print(x); x = 1\", \"var x; print(0); x = 1\");\n   }\n-  \n+\n   public void testInlineSameVariableInStraightLine() {\n     inline(\"var x; x = 1; print(x); x = 2; print(x)\",\n         \"var x; print(1); print(2)\");\n   }\n-  \n+\n   public void testInlineInDifferentPaths() {\n     inline(\"var x; if (print) {x = 1; print(x)} else {x = 2; print(x)}\",\n         \"var x; if (print) {print(1)} else {print(2)}\");\n   }\n-  \n+\n   public void testNoInlineInMergedPath() {\n     noInline(\n         \"var x,y;x = 1;while(y) { if(y){ print(x) } else { x = 1 } } print(x)\");\n   public void testInlineIntoExpressions() {\n     inline(\"var x = 1; print(x + 1);\", \"var x; print(1 + 1)\");\n   }\n-  \n+\n   public void testInlineExpressions1() {\n     inline(\"var a, b; var x = a+b; print(x)\", \"var a, b; var x; print(a+b)\");\n   }\n-  \n+\n   public void testInlineExpressions2() {\n     // We can't inline because of the redefinition of \"a\".\n     noInline(\"var a, b; var x = a + b; a = 1; print(x)\");\n   }\n-  \n+\n   public void testInlineExpressions3() {\n     inline(\"var a,b,x; x=a+b; x=a-b ; print(x)\",\n            \"var a,b,x; x=a+b; print(a-b)\");\n   }\n-  \n+\n   public void testInlineExpressions4() {\n     // Precision is lost due to comma's.\n     noInline(\"var a,b,x; x=a+b, x=a-b; print(x)\");\n   }\n-  \n+\n   public void testInlineExpressions5() {\n     noInline(\"var a; var x = a = 1; print(x)\");\n   }\n-  \n+\n   public void testInlineExpressions6() {\n     noInline(\"var a, x; a = 1 + (x = 1); print(x)\");\n   }\n   public void testInlineExpression7() {\n     // Possible side effects in foo() that might conflict with bar();\n     noInline(\"var x = foo() + 1; bar(); print(x)\");\n-    \n+\n     // This is a possible case but we don't have analysis to prove this yet.\n     // TODO(user): It is possible to cover this case with the same algorithm\n     //                as the missing return check.\n     noInline(\"var x = foo() + 1; print(x)\");\n   }\n-  \n+\n   public void testInlineExpression8() {\n     // The same variable inlined twice.\n     inline(\"var x = a + b; print(x);      x = a - b; print(x)\",\n            \"var x;         print(a + b);             print(a - b)\");\n   }\n-  \n+\n   public void testInlineExpression9() {\n     // Check for actual control flow sensitivity.\n     inline(\"var x; if (g) { x= a + b; print(x)    }  x = a - b; print(x)\",\n            \"var x; if (g) {           print(a + b)}             print(a - b)\");\n   }\n-  \n+\n   public void testInlineExpression10() {\n     // The DFA is not fine grain enough for this.\n     noInline(\"var x, y; x = ((y = 1), print(y))\");\n   }\n-  \n+\n   public void testInlineExpressions11() {\n     inline(\"var x; x = x + 1; print(x)\", \"var x; print(x + 1)\");\n     noInline(\"var x; x = x + 1; print(x); print(x)\");\n     // inlined.\n     noInline(\"var x = 10; x = c++; print(x)\");\n   }\n-  \n+\n   public void testInlineExpressions13() {\n     inline(\"var a = 1, b = 2;\" +\n            \"var x = a;\" +\n            \"var i = z;\" +\n            \"var j = z + y;\" +\n            \"var k = i;\",\n-           \n+\n            \"var a, b;\" +\n            \"var x;\" +\n            \"var y = 2;\" +\n   public void testNoInlineIfDefinitionMayNotReach() {\n     noInline(\"var x; if (x=1) {} x;\");\n   }\n-  \n+\n   public void testNoInlineEscapedToInnerFunction() {\n     noInline(\"var x = 1; function foo() { x = 2 }; print(x)\");\n   }\n-  \n+\n   public void testNoInlineLValue() {\n     noInline(\"var x; if (x = 1) { print(x) }\");\n   }\n-  \n+\n   public void testSwitchCase() {\n     inline(\"var x = 1; switch(x) { }\", \"var x; switch(1) { }\");\n   }\n-  \n+\n   public void testShadowedVariableInnerFunction() {\n     inline(\"var x = 1; print(x) || (function() {  var x; x = 1; print(x)})()\",\n         \"var x; print(1) || (function() {  var x; print(1)})()\");\n   }\n-  \n+\n   public void testCatch() {\n     noInline(\"var x = 0; try { } catch (x) { }\");\n     noInline(\"try { } catch (x) { print(x) }\");\n     // We don't know if j alias a.b\n     noInline(\"var x = a.b.c; j.c = 1; print(x);\");\n   }\n-  \n+\n   public void testNoInlineGetProp2() {\n     noInline(\"var x = 1 * a.b.c; j.c = 1; print(x);\");\n   }\n-  \n+\n   public void testNoInlineGetProp3() {\n     // Anything inside a function is fine.\n     inline(\"var x = function(){1 * a.b.c}; print(x);\",\n            \"var x; print(function(){1 * a.b.c});\");\n   }\n-  \n+\n   public void testNoInlineGetEle() {\n     // Again we don't know if i = j\n     noInline(\"var x = a[i]; a[j] = 2; print(x); \");\n     inline(\"var x = 1; L: M: x = 2; print(x)\", \"var x = 1; print(2)\");\n     inline(\"var x = 1; L: M: N: x = 2; print(x)\", \"var x = 1; print(2)\");\n   }\n-  \n+\n   public void testInlineArguments() {\n     testSame(\"function _func(x) { print(x) }\");\n     testSame(\"function _func(x,y) { if(y) { x = 1 }; print(x) }\");\n-    \n+\n     test(\"function(x, y) { x = 1; print(x) }\",\n          \"function(x, y) { print(1) }\");\n \n     test(\"function(x, y) { if (y) { x = 1; print(x) }}\",\n          \"function(x, y) { if (y) { print(1) }}\");\n   }\n-  \n+\n   private void noInline(String input) {\n     inline(input, input);\n   }\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n     fold(\"\\\"\\\" === ''\", \"1\");\n     fold(\"foo() === bar()\", \"foo()===bar()\");\n \n-    // TODO(johnlenz): It would be nice to handle these cases as well. \n+    // TODO(johnlenz): It would be nice to handle these cases as well.\n     foldSame(\"1 === '1'\");\n     foldSame(\"1 === true\");\n     foldSame(\"1 !== '1'\");\n     foldSame(\"1 !== true\");\n-    \n+\n     fold(\"1 !== 0\", \"1\");\n     fold(\"'abc' !== 'def'\", \"1\");\n     fold(\"'a' !== 'a'\", \"0\");\n     foldSame(\"a = (foo(), true);\");\n \n     fold(\"(x=2), foo()\", \"x=2; foo()\");\n-    fold(\"foo(), boo();\", \"foo(); boo()\");    \n-    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");    \n+    fold(\"foo(), boo();\", \"foo(); boo()\");\n+    fold(\"(a(), b()), (c(), d());\", \"a(); b(); c(); d();\");\n     // TODO(johnlenz): interestingly we don't remove side-effect free expression\n-    // in a script block (as it is currently part of block folding), so \"1;\" \n-    // is left. \n+    // in a script block (as it is currently part of block folding), so \"1;\"\n+    // is left.\n     fold(\"foo(), true\", \"foo();1\");\n     fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n   }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         \"foo\", INLINE_BLOCK);\n   }\n \n-  \n+\n   public void testBug1897706() {\n     helperInlineReferenceToFunction(\n         \"function foo(a){}; foo(x())\",\n--- a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n public class OptimizeArgumentsArrayTest extends CompilerTestCase {\n \n   public OptimizeArgumentsArrayTest() {\n-    \n+\n     super(\"var arguments, alert\" /* Externs */);\n   }\n \n   public void testNoOptimizationWhenGetProp() {\n     testSame(\"function f() { arguments[0]; arguments.size }\");\n   }\n-  \n+\n   public void testNoOptimizationWhenIndexIsNotNumberConstant() {\n     testSame(\"function f() { arguments[0]; arguments['callee'].length}\");\n     testSame(\"function f() { arguments[0]; arguments.callee.length}\");\n     testSame(\n         \"function f() { arguments[0]; var x = 'callee'; arguments[x].length}\");\n   }\n-  \n+\n   public void testNoOptimizationWhenArgumentIsUsedAsFunctionCall() {\n     testSame(\"function f() {arguments[0]()}\");\n   }", "timestamp": 1270687888, "metainfo": ""}