{"sha": "f86b8929454da31fbc59cbf95293c7138e0b8200", "log": "Change on 2010/07/15 12:32:23 by johnlenz  \tAdd writing mode to CssProperties object definition. \tFixes issue 196.  \tR=nicksantos \tDELTA=16  (14 added, 0 deleted, 2 changed)  Change on 2010/07/15 12:58:13 by johnlenz  \tLast set of tweaks to reduce build time impact of creating source maps: \t skip unused mapping entries to reduce the size of the file written.  \tR=jschorr \tDELTA=374  (193 added, 88 deleted, 93 changed)  Change on 2010/07/15 12:58:15 by johnlenz  \tAdd support for \"typeof void 0\" to \"undefined\" folding. \tFixes issue 197  \tR=dcc \tDELTA=4  (4 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=48015   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n       case Token.OBJECTLIT:\n       case Token.ARRAYLIT:\n         typeNameString = \"object\";\n+        break;\n+      case Token.VOID:\n+        typeNameString = \"undefined\";\n         break;\n       case Token.NAME:\n         // We assume here that programs don't change the value of the\n--- a/src/com/google/javascript/jscomp/Position.java\n+++ b/src/com/google/javascript/jscomp/Position.java\n *\n  */\n class Position {\n-  private int lineNumber;\n-  private int characterIndex;\n+  private final int lineNumber;\n+  private final int characterIndex;\n \n   public Position(int lineNumber, int characterIndex) {\n     this.lineNumber = lineNumber;\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n  */\n public class SourceMap {\n \n+  private final static int UNMAPPED = -1;\n+\n   /**\n    * A mapping from a given position in an input source file to a given position\n    * in the generated code.\n     /**\n      * A unique ID for this mapping for record keeping purposes.\n      */\n-    int id;\n-\n-    /**\n-     * The JSON escaped input source file.\n+    int id = UNMAPPED;\n+\n+    /**\n+     * The input source file.\n      */\n     String sourceFile;\n \n     Position endPosition;\n \n     /**\n-     * The JSON escaped original name of the token found at the position\n+     * The original name of the token found at the position\n      * represented by this mapping (if any).\n      */\n     String originalName;\n \n     /**\n+     * Whether the mapping is actually used by the source map.\n+     */\n+    boolean used = false;\n+  }\n+\n+  private class MappingWriter {\n+    /**\n+     * Cache of escaped source file name.\n+     */\n+    private String lastSourceFile = null;\n+    private String lastSourceFileEscaped = null;\n+    private int lastLine = 0;\n+    private String lastLineString = String.valueOf(0);\n+\n+    /**\n      * Appends the mapping to the given buffer.\n      */\n-    void appendTo(Appendable out) throws IOException {\n+    private void appendMappingTo(\n+        Mapping m, Appendable out) throws IOException {\n       out.append(\"[\");\n \n-      out.append(sourceFile);\n-\n+      String sourceFile = m.sourceFile;\n+      // The source file rarely changes, so cache the escaped string.\n+      String escapedSourceFile;\n+      if (lastSourceFile != sourceFile) { // yes, s1 != s2, not !s1.equals(s2)\n+        lastSourceFile = sourceFile;\n+        lastSourceFileEscaped = escapeString(sourceFile);\n+      }\n+      escapedSourceFile = lastSourceFileEscaped;\n+\n+      out.append(escapedSourceFile);\n       out.append(\",\");\n-      out.append(String.valueOf(originalPosition.getLineNumber()));\n+\n+      int line = m.originalPosition.getLineNumber();\n+      if (line != lastLine) {\n+        lastLineString = String.valueOf(line);\n+      }\n+      String lineValue = lastLineString;\n+\n+      out.append(lineValue);\n \n       out.append(\",\");\n-      out.append(String.valueOf(originalPosition.getCharacterIndex()));\n-\n-      if (originalName != null) {\n+      out.append(String.valueOf(\n+          m.originalPosition.getCharacterIndex()));\n+\n+      if (m.originalName != null) {\n         out.append(\",\");\n-        out.append(originalName);\n-      }\n-\n-      out.append(\"]\");\n+        out.append(escapeString(m.originalName));\n+      }\n+\n+      out.append(\"]\\n\");\n+    }\n+\n+    /**\n+     * Add used mappings to the supplied Appendable.\n+     */\n+    void appendMappings(Appendable out) throws IOException {\n+      for (Mapping m : mappings) {\n+        if (m.used) {\n+          appendMappingTo(m, out);\n+        }\n+      }\n     }\n   }\n \n   private static String escapeString(String value) {\n     return CodeGenerator.escapeToDoubleQuotedJsString(value);\n   }\n-\n-  /**\n-   * Cache of escaped source file name.\n-   */\n-  private String lastSourceFile = null;\n-  private String lastSourceFileEscaped = null;\n \n   /**\n    * Adds a mapping for the given node.  Mappings must be added in order.\n       return;\n     }\n \n-    // The source file rarely changes, so cache the escaped string.\n-    String escapedSourceFile;\n-    if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n-      lastSourceFile = sourceFile;\n-      lastSourceFileEscaped = escapeString(sourceFile);\n-    }\n-    escapedSourceFile = lastSourceFileEscaped;\n-\n     // Create the new mapping.\n     Mapping mapping = new Mapping();\n-    mapping.id = mappings.size();\n-    mapping.sourceFile = escapedSourceFile;\n+    mapping.sourceFile = sourceFile;\n     mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n \n     String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n     if (originalName != null) {\n-      mapping.originalName = escapeString(originalName);\n-    }\n-\n-    // If the mapping is found on the first line, we need to offset\n-    // its character position by the number of characters found on\n-    // the *last* line of the source file to which the code is\n-    // being generated.\n-    int offsetLine = offsetPosition.getLineNumber();\n-    int startOffsetPosition = offsetPosition.getCharacterIndex();\n-    int endOffsetPosition = offsetPosition.getCharacterIndex();\n-\n-    if (startPosition.getLineNumber() > 0) {\n-      startOffsetPosition = 0;\n-    }\n-\n-    if (endPosition.getLineNumber() > 0) {\n-      endOffsetPosition = 0;\n-    }\n-\n-    mapping.startPosition =\n-        new Position(startPosition.getLineNumber() + offsetLine,\n-                     startPosition.getCharacterIndex() + startOffsetPosition);\n-\n-    mapping.endPosition =\n-        new Position(endPosition.getLineNumber() + offsetLine,\n-                     endPosition.getCharacterIndex() + endOffsetPosition);\n+      mapping.originalName = originalName;\n+    }\n+\n+    if (offsetPosition.getLineNumber() == 0\n+        && offsetPosition.getCharacterIndex() == 0) {\n+      mapping.startPosition = startPosition;\n+      mapping.endPosition = endPosition;\n+    } else {\n+      // If the mapping is found on the first line, we need to offset\n+      // its character position by the number of characters found on\n+      // the *last* line of the source file to which the code is\n+      // being generated.\n+      int offsetLine = offsetPosition.getLineNumber();\n+      int startOffsetPosition = offsetPosition.getCharacterIndex();\n+      int endOffsetPosition = offsetPosition.getCharacterIndex();\n+\n+      if (startPosition.getLineNumber() > 0) {\n+        startOffsetPosition = 0;\n+      }\n+\n+      if (endPosition.getLineNumber() > 0) {\n+        endOffsetPosition = 0;\n+      }\n+\n+      mapping.startPosition =\n+          new Position(startPosition.getLineNumber() + offsetLine,\n+                       startPosition.getCharacterIndex() + startOffsetPosition);\n+\n+      mapping.endPosition =\n+          new Position(endPosition.getLineNumber() + offsetLine,\n+                       endPosition.getCharacterIndex() + endOffsetPosition);\n+    }\n \n     mappings.add(mapping);\n   }\n     mappings = Lists.newArrayList();\n     offsetPosition = new Position(0, 0);\n     prefixPosition = new Position(0, 0);\n-  }\n-\n-  /**\n-   * Scan the mappings and return the last line mapped.\n-   */\n-  private int findLastLine() {\n-    int maxLine = 0;\n-    for (Mapping mapping : mappings) {\n-      int endPositionLine = mapping.endPosition.getLineNumber();\n-      maxLine = Math.max(maxLine, endPositionLine);\n-    }\n-    // Adjust for the prefix.\n-    return maxLine + prefixPosition.getLineNumber();\n   }\n \n   /**\n     // 11) [\"c.js\", 1, 4]\n     // 12) [\"d.js\", 3, 78, \"foo\"]\n \n-    int maxLine = findLastLine();\n+    int maxLine = prepMappings();\n \n     // Add the line character maps.\n     out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n     // Add the mappings themselves.\n     out.append(\"/** Begin mapping definitions. **/\\n\");\n \n-    for (Mapping mapping : mappings) {\n-      mapping.appendTo(out);\n-      out.append(\"\\n\");\n-    }\n-  }\n-\n-  /**\n-   * A class to build the line/character to mappings section\n-   * of the source map.\n-   */\n-  private class LineMapper {\n+    (new MappingWriter()).appendMappings(out);\n+  }\n+\n+  /**\n+   * Assigns sequential ids to used mappings, and returns the last line mapped.\n+   */\n+  private int prepMappings() throws IOException {\n+    // Mark any unused mappings.\n+    (new MappingTraversal()).traverse(new UsedMappingCheck());\n+\n+    // Renumber used mappings and keep track of the last line.\n+    int id = 0;\n+    int maxLine = 0;\n+    for (Mapping m : mappings) {\n+      if (m.used) {\n+        m.id = id++;\n+        int endPositionLine = m.endPosition.getLineNumber();\n+        maxLine = Math.max(maxLine, endPositionLine);\n+      }\n+    }\n+\n+    // Adjust for the prefix.\n+    return maxLine + prefixPosition.getLineNumber();\n+  }\n+\n+  private class LineMapper implements MappingVisitor {\n     // The destination.\n     private final Appendable out;\n+\n+    // Whether the current line has had a value written yet.\n+    private boolean firstChar = true;\n+\n+    private final static String UNMAPPED_STRING = \"-1\";\n+\n+    private int lastId = UNMAPPED;\n+    private String lastIdString = UNMAPPED_STRING;\n+\n+    LineMapper(Appendable out) {\n+      this.out = out;\n+    }\n+\n+    /**\n+     * As each segment is visited write out the appropriate line mapping.\n+     */\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+      throws IOException {\n+\n+      int id = (m != null) ? m.id : UNMAPPED;\n+      if (lastId != id) {\n+        // Prevent the creation of unnecessary temporary stings for often\n+        // repeated values.\n+        lastIdString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n+        lastId = id;\n+      }\n+      String idString = lastIdString;\n+\n+      for (int i = line; i <= nextLine; i++) {\n+        if (i == nextLine) {\n+          for (int j = col; j < nextCol; j++) {\n+            addCharEntry(idString);\n+          }\n+          break;\n+        }\n+\n+        closeLine();\n+        openLine();\n+      }\n+    }\n+\n+    // Append the line mapping entries.\n+    void appendLineMappings() throws IOException {\n+      Preconditions.checkState(!mappings.isEmpty());\n+\n+      // Start the first line.\n+      openLine();\n+\n+      (new MappingTraversal()).traverse(this);\n+\n+      // And close the final line.\n+      closeLine();\n+    }\n+\n+    /**\n+     * Begin the entry for a new line.\n+     */\n+    private void openLine() throws IOException {\n+      if (out != null) {\n+        out.append(\"[\");\n+        this.firstChar = true;\n+      }\n+    }\n+\n+    /**\n+     * End the entry for a line.\n+     */\n+    private void closeLine() throws IOException {\n+      if (out != null) {\n+        out.append(\"]\\n\");\n+      }\n+    }\n+\n+    /**\n+     * Add a new char position entry.\n+     * @param id The mapping id to record.\n+     */\n+    private void addCharEntry(String id) throws IOException {\n+      if (out != null) {\n+        if (firstChar) {\n+          firstChar = false;\n+        } else {\n+          out.append(\",\");\n+        }\n+        out.append(id);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Mark any visited mapping as \"used\".\n+   */\n+  private class UsedMappingCheck implements MappingVisitor {\n+    /**\n+     * @throws IOException\n+     */\n+    @Override\n+    public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n+        throws IOException {\n+      if (m != null) {\n+        m.used = true;\n+      }\n+    }\n+  }\n+\n+  private interface MappingVisitor {\n+    /**\n+     * @param m The mapping for the current code segment. null if the segment\n+     *     is unmapped.\n+     * @param line The starting line for this code segment.\n+     * @param col The starting column for this code segment.\n+     * @param endLine The ending line\n+     * @param endCol The ending column\n+     * @throws IOException\n+     */\n+    void visit(Mapping m, int line, int col, int endLine, int endCol)\n+        throws IOException;\n+  }\n+\n+  /**\n+   * Walk the mappings and visit each segment of the mappings, unmapped\n+   * segments are visited with a null mapping, unused mapping are not visited.\n+   */\n+  private class MappingTraversal {\n     // The last line and column written\n     private int line;\n     private int col;\n-    // Whether the current line has had a value written yet.\n-    private boolean firstChar = true;\n-\n-    private final static int UNMAPPED = -1;\n-    private final static String UNMAPPED_STRING = \"-1\";\n-\n-    LineMapper(Appendable out) {\n-      this.out = out;\n+\n+    MappingTraversal() {\n     }\n \n     // Append the line mapping entries.\n-    void appendLineMappings() throws IOException {\n+    void traverse(MappingVisitor v) throws IOException {\n       Preconditions.checkState(!mappings.isEmpty());\n-\n-      // Start the first line.\n-      openLine();\n \n       // The mapping list is ordered as a pre-order traversal.  The mapping\n       // positions give us enough information to rebuild the stack and this\n         // closed in the reverse order of when they encountered.\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n           Mapping previous = stack.pop();\n-          writeClosedMapping(previous);\n+          maybeVisit(v, previous);\n         }\n \n         // Any gaps between the current line position and the start of the\n         // current mapping belong to the parent.\n         Mapping parent = stack.peek();\n-        writeCharsBetween(parent, m);\n+        maybeVisitParent(v, parent, m);\n \n         stack.push(m);\n       }\n       // mappings in the reverse order of when they encountered.\n       while (!stack.isEmpty()) {\n         Mapping m = stack.pop();\n-        writeClosedMapping(m);\n-      }\n-\n-      // And close the final line.\n-      closeLine();\n-    }\n-\n-    /**\n-     * Begin the entry for a new line.\n-     */\n-    private void openLine() throws IOException {\n-      out.append(\"[\");\n-      this.firstChar = true;\n-    }\n-\n-    /**\n-     * End the entry for a line.\n-     */\n-    private void closeLine() throws IOException {\n-      out.append(\"]\\n\");\n-    }\n-\n-    /**\n-     * Add a new char position entry.\n-     * @param id The mapping id to record.\n-     */\n-    private void addCharEntry(String id) throws IOException {\n-      if (firstChar) {\n-        firstChar = false;\n-      } else {\n-        out.append(\",\");\n-      }\n-      out.append(id);\n+        maybeVisit(v, m);\n+      }\n     }\n \n     /**\n      * Write any needed entries from the current position to the end of the\n      * provided mapping.\n      */\n-    private void writeClosedMapping(Mapping m) throws IOException {\n+    private void maybeVisit(MappingVisitor v, Mapping m) throws IOException {\n       int nextLine = getAdjustedLine(m.endPosition);\n       int nextCol = getAdjustedCol(m.endPosition);\n       // If this anything remaining in this mapping beyond the\n       // current line and column position, write it out now.\n       if (line < nextLine || (line == nextLine && col < nextCol)) {\n-        writeCharsUpTo(nextLine, nextCol, m.id);\n+        visit(v, m, nextLine, nextCol);\n       }\n     }\n \n     /**\n      * Write any needed entries to complete the provided mapping.\n      */\n-    private void writeCharsBetween(Mapping prev, Mapping next)\n+    private void maybeVisitParent(MappingVisitor v, Mapping parent, Mapping m)\n         throws IOException {\n-      int nextLine = getAdjustedLine(next.startPosition);\n-      int nextCol = getAdjustedCol(next.startPosition);\n-      // If the previous value is null, no mapping exists use the special\n-      // \"unmapped value\"(-1).\n-      int id = (prev != null) ? prev.id : UNMAPPED;\n-      writeCharsUpTo(nextLine, nextCol, id);\n+      int nextLine = getAdjustedLine(m.startPosition);\n+      int nextCol = getAdjustedCol(m.startPosition);\n+      // If the previous value is null, no mapping exists.\n+      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      if (line < nextLine || (line == nextLine && col < nextCol)) {\n+        visit(v, parent, nextLine, nextCol);\n+      }\n     }\n \n     /**\n      * Write any entries needed between the current position the next position\n      * and update the current position.\n      */\n-    private void writeCharsUpTo(\n-        int nextLine, int nextCol, int id)\n+    private void visit(MappingVisitor v, Mapping m,\n+        int nextLine, int nextCol)\n         throws IOException {\n-      Preconditions.checkState(line <= nextLine, \"\");\n-      Preconditions.checkState(line < nextLine || col <= nextCol);\n+      Preconditions.checkState(line <= nextLine);\n+      Preconditions.checkState(line < nextLine || col < nextCol);\n \n       if (line == nextLine && col == nextCol) {\n         // Nothing to do.\n+        Preconditions.checkState(false);\n         return;\n       }\n \n-      String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n-      for (int i = line; i <= nextLine; i++) {\n-        if (i == nextLine) {\n-          for (int j = col; j < nextCol; j++) {\n-            addCharEntry(idString);\n-          }\n-          break;\n-        }\n-\n-        closeLine();\n-        openLine();\n-      }\n+      v.visit(m, line, col, nextLine, nextCol);\n \n       line = nextLine;\n       col = nextCol;\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = typeof false\", \"x = \\\"boolean\\\"\");\n     fold(\"x = typeof null\", \"x = \\\"object\\\"\");\n     fold(\"x = typeof undefined\", \"x = \\\"undefined\\\"\");\n+    fold(\"x = typeof void 0\", \"x = \\\"undefined\\\"\");\n     fold(\"x = typeof []\", \"x = \\\"object\\\"\");\n     fold(\"x = typeof [1]\", \"x = \\\"object\\\"\");\n     fold(\"x = typeof [1,[]]\", \"x = \\\"object\\\"\");\n--- a/test/com/google/javascript/jscomp/SourceMapTest.java\n+++ b/test/com/google/javascript/jscomp/SourceMapTest.java\n     // Empty source map test\n     checkSourceMap(\"\",\n \n-                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\",\" +\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\",\" +\n                    \" \\\"count\\\": 1 }\\n\" +\n \n                    \"[]\\n\" +\n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n \n-                   \"/** Begin mapping definitions. **/\\n\" +\n-                   \"[\\\"testcode\\\",1,0]\\n\");\n+                   \"/** Begin mapping definitions. **/\\n\");\n   }\n \n   public void testGoldenOutput1() throws Exception {\n     checkSourceMap(\"function f(foo, bar) { foo = foo + bar + 2; return foo; }\",\n \n-                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[1,1,1,1,1,1,1,1,2,2,3,4,4,4,3,5,5,5,3,6,8,8,8,7,9,9,9,7,\" +\n-                   \"10,10,10,7,11,12,12,12,12,12,12,12,13,13,13,13,6]\\n\" +\n+                   \"[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,6,\" +\n+                   \"9,9,9,6,10,11,11,11,11,11,11,11,12,12,12,12,5]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n \n                    \"/** Begin mapping definitions. **/\\n\" +\n-                   \"[\\\"testcode\\\",1,0]\\n\" +\n                    \"[\\\"testcode\\\",1,9]\\n\" +\n                    \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n                    \"[\\\"testcode\\\",1,10]\\n\" +\n     checkSourceMap(\"function f(foo, bar) {\\r\\n\\n\\n\\nfoo = foo + bar + foo;\" +\n                    \"\\nreturn foo;\\n}\",\n \n-                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[1,1,1,1,1,1,1,1,2,2,3,4,4,4,3,5,5,5,3,6,8,8,8,7,9,9,9,\" +\n-                   \"7,10,10,10,7,11,11,11,12,12,12,12,12,12,12,13,13,13,\" +\n-                   \"13,6]\\n\" +\n+                   \"[0,0,0,0,0,0,0,0,1,1,2,3,3,3,2,4,4,4,2,5,7,7,7,6,8,8,8,\" +\n+                   \"6,9,9,9,6,10,10,10,11,11,11,11,11,11,11,12,12,12,\" +\n+                   \"12,5]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n-                   \"[\\\"testcode\\\",1,0]\\n\" +\n                    \"[\\\"testcode\\\",1,9]\\n\" +\n                    \"[\\\"testcode\\\",1,9,\\\"f\\\"]\\n\" +\n                    \"[\\\"testcode\\\",1,10]\\n\" +\n     checkSourceMap(\"c:\\\\myfile.js\",\n                    \"foo;\",\n \n-                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testMap\\\", \" +\n+                   \"/** Begin line maps. **/{ \\\"file\\\" : \\\"testcode\\\", \" +\n                    \"\\\"count\\\": 1 }\\n\" +\n \n-                   \"[2,2,2]\\n\" +\n+                   \"[0,0,0]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n                    \"/** Begin mapping definitions. **/\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\");\n   }\n \n                    \"foo;   boo;   goo;\",\n \n                    \"/** Begin line maps. **/\" +\n-                   \"{ \\\"file\\\" : \\\"testMap\\\", \\\"count\\\": 1 }\\n\" +\n-                   \"[2,2,2,4,4,4,4,6,6,6,6]\\n\" +\n+                   \"{ \\\"file\\\" : \\\"testcode\\\", \\\"count\\\": 1 }\\n\" +\n+                   \"[0,0,0,1,1,1,1,2,2,2,2]\\n\" +\n \n                    \"/** Begin file information. **/\\n\" +\n                    \"[]\\n\" +\n \n                    \"/** Begin mapping definitions. **/\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,0]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,0,\\\"foo\\\"]\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,7]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,7,\\\"boo\\\"]\\n\" +\n-                   \"[\\\"c:\\\\\\\\myfile.js\\\",1,14]\\n\" +\n                    \"[\\\"c:\\\\\\\\myfile.js\\\",1,14,\\\"goo\\\"]\\n\");\n   }\n \n \n   private String getSourceMap(RunResult result) throws IOException {\n     StringBuilder sb = new StringBuilder();\n-    result.sourceMap.appendTo(sb, \"testMap\");\n+    result.sourceMap.appendTo(sb, \"testcode\");\n     return sb.toString();\n   }\n \n   private void checkSourceMap(String fileName, String js, String expectedMap)\n       throws IOException {\n     RunResult result = compile(js, fileName);\n-    assertEquals(expectedMap, getSourceMap(result));\n+    assertEquals(expectedMap, result.sourceMapFileContent);\n+    assertEquals(result.sourceMapFileContent, getSourceMap(result));\n   }\n \n   private static class RunResult {", "timestamp": 1279227680, "metainfo": ""}