{"sha": "f4db999b156632c1531b4f1ead6d86cef548f093", "log": "And a new name. Until it gets changed.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/Executor.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+/**\n+ * <code>Executor</code> defines an interface implemented by classes that\n+ * do something.\n+ *\n+ * @author <a href=\"mailto:nicolaken@apache.org\">Nicola Ken Barozzi</a>\n+ * @version $Id: Executor.java,v 1.1 2002/11/06 19:15:40 bayard Exp $\n+ */\n+public interface Executor {\n+    \n+    /**\n+     * Does what it has to.\n+     *\n+     * @param description  the extra information needed to execute the \n+     *                     command\n+     *\n+     * @throws ExecutorException (runtime) if the execution fails\n+     */\n+    public void execute(Object description);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/ExecutorException.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import org.apache.commons.lang.exception.NestableRuntimeException;\n+/**\n+ * Exception thrown when the Comand fails to execute.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @author <a href=\"mailto:nicolaken@apache.org\">Nicola Ken Barozzi</a>\n+ * @version $Id: ExecutorException.java,v 1.1 2002/11/06 19:15:40 bayard Exp $\n+ */\n+public class ExecutorException extends NestableRuntimeException {\n+\n+    /**\n+     * Constructs a new <code>ExecutorException</code> without specified\n+     * detail message.\n+     */\n+    public ExecutorException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>ExecutorException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public ExecutorException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ExecutorException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public ExecutorException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ExecutorException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public ExecutorException(String msg, Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/functor/ExecutorUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.functor.Predicate;\n+import org.apache.commons.lang.functor.PredicateUtils;\n+import org.apache.commons.lang.functor.Transformer;\n+import org.apache.commons.lang.functor.TransformerException;\n+import org.apache.commons.lang.functor.TransformerUtils;\n+/**\n+ * <code>ExecutorUtils</code> provides reference implementations and utilities\n+ * for the Executor pattern interface. The supplied commands are:\n+ * <ul>\n+ * <li>Invoker - invokes a method on the input object\n+ * <li>For - repeatedly calls a command for a fixed number of times\n+ * <li>While - repeatedly calls a command while a predicate is true\n+ * <li>DoWhile - repeatedly calls a command while a predicate is true\n+ * <li>Chained - chains two or more commands together\n+ * <li>Switch - calls one command based on one or more predicates\n+ * <li>SwitchMap - calls one command looked up from a Map\n+ * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>NOP - does nothing\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied commands are Serializable.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: ExecutorUtils.java,v 1.1 2002/11/06 19:15:40 bayard Exp $\n+ */\n+public class ExecutorUtils {\n+\n+    /**\n+     * A Executor that always throws an exception\n+     */\n+    private static final Executor EXCEPTION_COMMAND = new ExceptionExecutor();\n+    /**\n+     * A Executor that does nothing\n+     */\n+    private static final Executor NOP_COMMAND = new NOPExecutor();\n+\n+    /**\n+     * Restrictive constructor\n+     */\n+    protected ExecutorUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Executor that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the command\n+     */\n+    public static Executor exceptionExecutor() {\n+        return EXCEPTION_COMMAND;\n+    }\n+\n+    /**\n+     * Gets a Executor that will do nothing.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the command\n+     */\n+    public static Executor nopExecutor() {\n+        return NOP_COMMAND;\n+    }\n+\n+    /**\n+     * Creates a Executor that calls a Factory each time the transformer is used.\n+     * The transformer will return the value returned by the factory.\n+     *\n+     * @param transformer  the transformer to run each time in the command\n+     * @return the command.\n+     */\n+    public static Executor asExecutor(Transformer transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"TransformerExecutor: The transformer must not be null\");\n+        }\n+        return new TransformerExecutor(transformer);\n+    }\n+\n+    /**\n+     * Creates a Executor that will call the command <code>count</code> times.\n+     *\n+     * @param count  the number of times to loop\n+     * @param command  the command to call repeatedly\n+     * @return the command\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Executor forExecutor(int count, Executor command) {\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"ForExecutor: The loop count must not be less than zero, it was \" + count);\n+        }\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"ForExecutor: The command must not be null\");\n+        }\n+        return new ForExecutor(count, command);\n+    }\n+\n+    /**\n+     * Creates a Executor that will call the command repeatedly until the \n+     * predicate returns false.\n+     *\n+     * @param predicate  the predicate to use as an end of loop test\n+     * @param command  the command to call repeatedly\n+     * @return the command\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Executor whileExecutor(Predicate predicate, Executor command) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"WhileExecutor: The predicate must not be null\");\n+        }\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"WhileExecutor: The command must not be null\");\n+        }\n+        return new WhileExecutor(predicate, command, false);\n+    }\n+\n+    /**\n+     * Creates a Executor that will call the command once and then repeatedly\n+     * until the predicate returns false.\n+     *\n+     * @param command  the command to call repeatedly\n+     * @param predicate  the predicate to use as an end of loop test\n+     * @return the command\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Executor doWhileExecutor(Executor command, Predicate predicate) {\n+        if (command == null) {\n+            throw new IllegalArgumentException(\"DoWhileExecutor: The command must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"DoWhileExecutor: The predicate must not be null\");\n+        }\n+        return new WhileExecutor(predicate, command, true);\n+    }\n+\n+    /**\n+     * Creates a Executor that will invoke a specific method on the command's\n+     * input object by reflection.\n+     *\n+     * @param methodName  the name of the method\n+     * @return the command\n+     * @throws IllegalArgumentException if the method name is null\n+     */\n+    public static Executor invokerExecutor(String methodName) {\n+        return asExecutor(TransformerUtils.invokerTransformer(methodName, null, null));\n+    }\n+\n+    /**\n+     * Creates a Executor that will invoke a specific method on the command's\n+     * input object by reflection.\n+     *\n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the command\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Executor invokerExecutor(String methodName, Class[] paramTypes, Object[] args) {\n+        return asExecutor(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    /**\n+     * Create a new Executor that calls two Executors, passing the result of\n+     * the first into the second.\n+     * \n+     * @param command1  the first command\n+     * @param command2  the second command\n+     * @return the command\n+     * @throws IllegalArgumentException if either command is null\n+     */\n+    public static Executor chainedExecutor(Executor command1, Executor command2) {\n+        Executor[] commands = new Executor[] { command1, command2 };\n+        validate(commands);\n+        return new ChainedExecutor(commands);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls each command in turn, passing the \n+     * result into the next command.\n+     * \n+     * @param commands  an array of commands to chain\n+     * @return the command\n+     * @throws IllegalArgumentException if the commands array is null\n+     * @throws IllegalArgumentException if the commands array has 0 elements\n+     * @throws IllegalArgumentException if any command in the array is null\n+     */\n+    public static Executor chainedExecutor(Executor[] commands) {\n+        commands = copy(commands);\n+        validate(commands);\n+        return new ChainedExecutor(commands);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls each command in turn, passing the \n+     * result into the next command. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param commands  a collection of commands to chain\n+     * @return the command\n+     * @throws IllegalArgumentException if the commands collection is null\n+     * @throws IllegalArgumentException if the commands collection is empty\n+     * @throws IllegalArgumentException if any command in the collection is null\n+     */\n+    public static Executor chainedExecutor(Collection commands) {\n+        if (commands == null) {\n+            throw new IllegalArgumentException(\"ChainedExecutor: The command collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Executor[] cmds = new Executor[commands.size()];\n+        int i = 0;\n+        for (Iterator it = commands.iterator(); it.hasNext();) {\n+            cmds[i++] = (Executor) it.next();\n+        }\n+        validate(cmds);\n+        return new ChainedExecutor(cmds);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls one of two commands depending \n+     * on the specified predicate.\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueExecutor  the command called if the predicate is true\n+     * @param falseExecutor  the command called if the predicate is false\n+     * @return the command\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either command is null\n+     */\n+    public static Executor switchExecutor(Predicate predicate, Executor trueExecutor, Executor falseExecutor) {\n+        return switchExecutorInternal(new Predicate[] { predicate }, new Executor[] { trueExecutor }, falseExecutor);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls one of the commands depending \n+     * on the predicates. The command at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param commands  an array of commands to call\n+     * @return the command\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Executor switchExecutor(Predicate[] predicates, Executor[] commands) {\n+        return switchExecutorInternal(copy(predicates), copy(commands), null);\n+    }\n+\n+    /**\n+     * Create a new Executor that calls one of the commands depending \n+     * on the predicates. The command at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * command is called.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param commands  an array of commands to call\n+     * @param defaultExecutor  the default to call if no predicate matches\n+     * @return the command\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Executor switchExecutor(Predicate[] predicates, Executor[] commands, Executor defaultExecutor) {\n+        return switchExecutorInternal(copy(predicates), copy(commands), defaultExecutor);\n+    }\n+    \n+    /**\n+     * Create a new Executor that calls one of the commands depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Executor values. A command \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * command is called. The default command is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param predicatesAndExecutors  a map of predicates to commands\n+     * @return the command\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any command in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Executor switchExecutor(Map predicatesAndExecutors) {\n+        Executor[] trs = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndExecutors == null) {\n+            throw new IllegalArgumentException(\"SwitchExecutor: The predicate and command map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Executor def = (Executor) predicatesAndExecutors.remove(null);\n+        int size = predicatesAndExecutors.size();\n+        trs = new Executor[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndExecutors.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            trs[i] = (Executor) entry.getValue();\n+            i++;\n+        }\n+        return switchExecutorInternal(preds, trs, def);\n+    }\n+\n+    /**\n+     * Validate input and create command\n+     */\n+    private static Executor switchExecutorInternal(Predicate[] predicates, Executor[] commands, Executor defaultExecutor) {\n+        validate(predicates);\n+        validate(commands);\n+        if (predicates.length != commands.length) {\n+            throw new IllegalArgumentException(\"SwitchExecutor: The predicate and command arrays must be the same size\");\n+        }\n+        if (defaultExecutor == null) {\n+            defaultExecutor = nopExecutor();\n+        }\n+        return new SwitchExecutor(predicates, commands, defaultExecutor);\n+    }\n+\n+    /**\n+     * Create a new Executor that uses the input object as a key to find the\n+     * command to call. \n+     * <p>\n+     * The Map consists of object keys and Executor values. A command \n+     * is called if the input object equals the key. If there is no match, the\n+     * default command is called. The default command is set in the map\n+     * using a null key.\n+     * \n+     * @param objectsAndExecutors  a map of objects to commands\n+     * @return the command\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any command in the map is null\n+     */\n+    public static Executor switchMapExecutor(Map objectsAndExecutors) {\n+        Executor[] trs = null;\n+        Predicate[] preds = null;\n+        if (objectsAndExecutors == null) {\n+            throw new IllegalArgumentException(\"SwitchEqualsExecutor: The obejct and command map must not be null\");\n+        }\n+        Executor def = (Executor) objectsAndExecutors.remove(null);\n+        int size = objectsAndExecutors.size();\n+        trs = new Executor[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = objectsAndExecutors.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = PredicateUtils.equalPredicate(entry.getKey());\n+            trs[i] = (Executor) entry.getValue();\n+            i++;\n+        }\n+        return switchExecutor(preds, trs, def);\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param predicates  the predicates to copy\n+     */\n+    private static Predicate[] copy(Predicate[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate[]) predicates.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param predicates  the predicates to validate\n+     */\n+    private static void validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"ExecutorUtils: The predicate array must not be null\");\n+        }\n+        if (predicates.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"ExecutorUtils: At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"ExecutorUtils: The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param commands  the commands to copy\n+     */\n+    private static Executor[] copy(Executor[] commands) {\n+        if (commands == null) {\n+            return null;\n+        }\n+        return (Executor[]) commands.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param commands  the commands to validate\n+     */\n+    private static void validate(Executor[] commands) {\n+        if (commands == null) {\n+            throw new IllegalArgumentException(\"ExecutorUtils: The command array must not be null\");\n+        }\n+        if (commands.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"ExecutorUtils: At least 1 command must be specified in the command array, size was \" + commands.length);\n+        }\n+        for (int i = 0; i < commands.length; i++) {\n+            if (commands[i] == null) {\n+                throw new IllegalArgumentException(\"ExecutorUtils: The command array must not contain a null command, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    // ExceptionExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionExecutor always throws an exception\n+     */\n+    private static class ExceptionExecutor implements Executor, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionExecutor() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public void execute(Object input) {\n+            throw new ExecutorException(\"ExceptionExecutor invoked\");\n+        }\n+    }\n+\n+    // NOPExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NOPExecutor does nothing\n+     */\n+    private static class NOPExecutor implements Executor, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private NOPExecutor() {\n+            super();\n+        }\n+\n+        /**\n+         * Do nothing\n+         */\n+        public void execute(Object input) {\n+            // do nothing\n+        }\n+    }\n+\n+    // TransformerExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * TransformerExecutor returns the result of calling a Transformer.\n+     */\n+    private static class TransformerExecutor implements Executor, Serializable {\n+\n+        private final Transformer iTransformer;\n+\n+        /**\n+         * Constructor to store factory\n+         */\n+        private TransformerExecutor(Transformer transformer) {\n+            super();\n+            iTransformer = transformer;\n+        }\n+\n+        /**\n+         * Return the result of calling the factory\n+         */\n+        public void execute(Object input) {\n+            try {\n+                iTransformer.transform(input);\n+\n+            } catch (TransformerException ex) {\n+                throw new ExecutorException(\"TransformerExecutor: \" + ex.getMessage(), ex);\n+            }\n+        }\n+    }\n+\n+    // ChainedExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ChainedExecutor calls a list of commands.\n+     */\n+    private static class ChainedExecutor implements Executor, Serializable {\n+\n+        private final Executor[] iExecutors;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ChainedExecutor(Executor[] commands) {\n+            super();\n+            iExecutors = commands;\n+        }\n+\n+        /**\n+         * Execute a list of commands\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iExecutors.length; i++) {\n+                iExecutors[i].execute(input);\n+            }\n+        }\n+    }\n+\n+    // SwitchExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * SwitchExecutor calls the command whose predicate returns true.\n+     */\n+    private static class SwitchExecutor implements Executor, Serializable {\n+\n+        private final Predicate[] iPredicates;\n+        private final Executor[] iExecutors;\n+        private final Executor iDefault;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private SwitchExecutor(Predicate[] predicates, Executor[] commands, Executor defaultExecutor) {\n+            super();\n+            iPredicates = predicates;\n+            iExecutors = commands;\n+            iDefault = defaultExecutor;\n+        }\n+\n+        /**\n+         * Execute the command whose predicate returns true\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(input) == true) {\n+                    iExecutors[i].execute(input);\n+                    return;\n+                }\n+            }\n+            iDefault.execute(input);\n+        }\n+    }\n+\n+    // ForExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ForExecutor calls the command a fixed nunmber of times.\n+     */\n+    private static class ForExecutor implements Executor, Serializable {\n+\n+        private final int iCount;\n+        private final Executor iExecutor;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ForExecutor(int count, Executor command) {\n+            super();\n+            iCount = count;\n+            iExecutor = command;\n+        }\n+\n+        /**\n+         * Execute the command count times\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iCount; i++) {\n+                iExecutor.execute(input);\n+            }\n+        }\n+    }\n+\n+    // WhileExecutor\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * WhileExecutor calls the command until the predicate is false.\n+     */\n+    private static class WhileExecutor implements Executor, Serializable {\n+\n+        private final Predicate iPredicate;\n+        private final Executor iExecutor;\n+        private final boolean iDoLoop;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private WhileExecutor(Predicate predicate, Executor command, boolean doLoop) {\n+            super();\n+            iPredicate = predicate;\n+            iExecutor = command;\n+            iDoLoop = doLoop;\n+        }\n+\n+        /**\n+         * Execute the command until the predicate is false\n+         */\n+        public void execute(Object input) {\n+            if (iDoLoop) {\n+                iExecutor.execute(input);\n+            }\n+            while (iPredicate.evaluate(input)) {\n+                iExecutor.execute(input);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1036610140, "metainfo": ""}