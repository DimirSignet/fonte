{"sha": "946ebd29d9d7380e702f2db64f4cf4b4ca1aed2b", "log": "Fix infinite recursion in inner classes reflection methods from Per Velschow   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: CompareToBuilder.java,v 1.11 2003/01/19 17:51:42 scolebourne Exp $\n+ * @version $Id: CompareToBuilder.java,v 1.12 2003/01/19 18:49:05 scolebourne Exp $\n  */\n public class CompareToBuilder {\n     \n         Field.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n             Field f = fields[i];\n-            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-                if (!Modifier.isStatic(f.getModifiers())) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                    }\n+            if ((f.getName().indexOf('$') == -1) &&\n+                (useTransients || !Modifier.isTransient(f.getModifiers())) &&\n+                (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: EqualsBuilder.java,v 1.10 2003/01/19 17:35:21 scolebourne Exp $\n+ * @version $Id: EqualsBuilder.java,v 1.11 2003/01/19 18:49:05 scolebourne Exp $\n  */\n public class EqualsBuilder {\n     /**\n         Field.setAccessible(fields, true);\n         for (int i = 0; i < fields.length && builder.isEquals; i++) {\n             Field f = fields[i];\n-            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-                if (!Modifier.isStatic(f.getModifiers())) {\n-                    try {\n-                        builder.append(f.get(lhs), f.get(rhs));\n-                    } catch (IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                    }\n+            if ((f.getName().indexOf('$') == -1) &&\n+                (useTransients || !Modifier.isTransient(f.getModifiers())) &&\n+                (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: HashCodeBuilder.java,v 1.9 2003/01/19 17:35:21 scolebourne Exp $\n+ * @version $Id: HashCodeBuilder.java,v 1.10 2003/01/19 18:49:05 scolebourne Exp $\n  */\n public class HashCodeBuilder {\n \n         Field.setAccessible(fields, true);\n         for (int i = 0; i < fields.length; i++) {\n             Field f = fields[i];\n-            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-                if (!Modifier.isStatic(f.getModifiers())) {\n-                    try {\n-                        builder.append(f.get(object));\n-                    } catch (IllegalAccessException e) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                    }\n+            if ((f.getName().indexOf('$') == -1) &&\n+                (useTransients || !Modifier.isTransient(f.getModifiers())) &&\n+                (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(object));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n--- a/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n  * @author Stephen Colebourne\n  * @author Gary Gregory\n  * @since 1.0\n- * @version $Id: ToStringBuilder.java,v 1.13 2003/01/19 17:35:21 scolebourne Exp $\n+ * @version $Id: ToStringBuilder.java,v 1.14 2003/01/19 18:49:05 scolebourne Exp $\n  */\n public class ToStringBuilder {\n     \n         Field.setAccessible(fields, true);\n         for (int i = 0; i < fields.length; i++) {\n             Field f = fields[i];\n-            if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-                if (!Modifier.isStatic(f.getModifiers())) {\n-                    try {\n-                        builder.append(f.getName(), f.get(object));\n-                    } catch (IllegalAccessException ex) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n-                    }\n+            if ((f.getName().indexOf('$') == -1) &&\n+                (useTransients || !Modifier.isTransient(f.getModifiers())) &&\n+                (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.getName(), f.get(object));\n+                } catch (IllegalAccessException ex) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n--- a/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n  * Unit tests {@link org.apache.commons.lang.ToStringBuilder}.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: ToStringBuilderTest.java,v 1.3 2002/12/31 20:17:53 scolebourne Exp $\n+ * @version $Id: ToStringBuilderTest.java,v 1.4 2003/01/19 18:49:05 scolebourne Exp $\n  */\n public class ToStringBuilderTest extends TestCase {\n \n         private transient char transientB='t';\n \t}\n \n+    public void testInnerClassReflection() {\n+        Outer outer = new Outer();\n+        assertEquals(toBaseString(outer) + \"[inner=\" + toBaseString(outer.inner) + \"[]]\", outer.toString());\n+    }\n+    \n+    static class Outer {\n+        Inner inner = new Inner();\n+        class Inner {\n+            public String toString() {\n+                return ToStringBuilder.reflectionToString(this);\n+            }\n+        }\n+        public String toString() {\n+            return ToStringBuilder.reflectionToString(this);\n+        }\n+    }\n+    \n     public void testAppendSuper() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[]\").toString());\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).appendSuper(\"Integer@8888[<null>]\").toString());", "timestamp": 1043002145, "metainfo": ""}