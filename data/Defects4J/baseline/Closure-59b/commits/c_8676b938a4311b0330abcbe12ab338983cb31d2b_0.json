{"sha": "8676b938a4311b0330abcbe12ab338983cb31d2b", "log": "Move dummy declaration in specialization to the end of the declaring block.  R=nicksantos DELTA=65  (47 added, 6 deleted, 12 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=205500   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n         .copyInformationFrom(parent.getFirstChild());\n \n     if (specializationState != null) {\n-      specializationState.reportRemovedFunction(functionNode);\n+      specializationState.reportRemovedFunction(functionNode, block);\n     }\n \n     parent.removeChild(functionNode);\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n         verifyAllReferencesInlined(fs);\n \n         if (specializationState != null) {\n-          specializationState.reportRemovedFunction(fn.getFunctionNode());\n+          specializationState.reportRemovedFunction(\n+              fn.getFunctionNode(), fn.getDeclaringBlock());\n         }\n \n         fn.remove();\n \n     /** Removes itself from the javascript */\n     public void remove();\n+\n+    public Node getDeclaringBlock();\n   }\n \n   /** NamedFunction implementation of the Function interface */\n     public void remove() {\n       NodeUtil.removeChild(fn.getParent(), fn);\n     }\n+\n+    @Override\n+    public Node getDeclaringBlock() {\n+      return fn.getParent();\n+    }\n   }\n \n   /** FunctionVar implementation of the Function interface */\n \n     public void remove() {\n       NodeUtil.removeChild(var.getParent(), var);\n+    }\n+\n+    @Override\n+    public Node getDeclaringBlock() {\n+      return var.getParent();\n     }\n   }\n \n     public void remove() {\n       // Nothing to do. The function is removed with the call.\n     }\n+\n+    @Override\n+    public Node getDeclaringBlock() {\n+      return null;\n+    }\n+\n   }\n \n   class Reference extends FunctionInjector.Reference {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedPrototypeProperties.java\n               getSpecializableFunctionFromSymbol(declaration);\n \n             if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(specializableFunction);\n+              specializationState.reportRemovedFunction(\n+                  specializableFunction, null);\n               canRemove = true;\n             }\n           }\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n       }\n     } while(specializationState.hasChanged()); \n     \n+    // We must always add dummy variables before replacing the orginal module.\n+    addDummyVarDeclarationsToInitialModule(module);\n     replaceOriginalModuleInputsWithSpecialized();    \n-    addDummyVarDeclarationsToInitialModule(module);  \n     addOriginalFunctionVersionsToDependentModules(module);   \n   }\n   \n    * \n    * TODO(dcc): Be smarter about whether we need a VAR here or not.\n    */\n-  private void addDummyVarDeclarationsToInitialModule(JSModule module) {    \n-    CompilerInput lastInputInFirstModule =\n-        module.getInputs().get(module.getInputs().size() - 1);\n-    \n-    Node dummyVarParent = lastInputInFirstModule.getAstRoot(compiler);\n-       \n-    for (Node modifiedFunction : functionInfoBySpecializedFunctionNode.keySet())\n-        {      \n+  private void addDummyVarDeclarationsToInitialModule(JSModule module) {\n+    for (Node modifiedFunction :\n+      functionInfoBySpecializedFunctionNode.keySet()) {      \n      if (specializationState.getRemovedFunctions().contains(modifiedFunction)) {\n        OriginalFunctionInformation originalInfo =\n          functionInfoBySpecializedFunctionNode.get(modifiedFunction);\n        \n        if (originalInfo.name != null && originalInfo.originalWasDeclaration()) {\n-         dummyVarParent.addChildToBack(originalInfo.generateDummyDeclaration());\n+         Node block = specializationState.removedFunctionToBlock.get(\n+             modifiedFunction);\n+\n+         // Declaring block might be null if no fix-up declarations is needed.\n+         // For example, InlineFunction can inline an anonymous function call or\n+         // anything with prototype property requires no dummy declaration\n+         // fix-ups afterward.\n+         if (block != null) {\n+           Node originalRoot = specializedInputRootsByOriginal.get(block);\n+           block.addChildrenToBack(originalInfo.generateDummyDeclaration());\n+         }\n        }     \n      }\n     }\n      */\n     private Set<Node> removedFunctions;\n     \n+    private Map<Node, Node> removedFunctionToBlock;\n+    \n     private SimpleFunctionAliasAnalysis initialModuleAliasAnalysis;\n     \n     /** Will be true if any new functions have been removed or specialized since\n       \n       specializedFunctions = Sets.newLinkedHashSet();\n       removedFunctions = Sets.newLinkedHashSet();\n+      removedFunctionToBlock = Maps.newLinkedHashMap();\n     }\n     \n     /**\n      * @param functionNode A specialized AST node with type Token.FUNCTION\n      */\n     public void reportSpecializedFunction(Node functionNode) {\n-      hasChanged = specializedFunctions.add(functionNode);\n+      if (specializedFunctions.add(functionNode)) {\n+        hasChanged = true;\n+      }\n     }\n     \n     /**\n      * Reports that a function has been removed.\n      * \n      * @param functionNode A removed AST node with type Token.FUNCTION\n-     */\n-    public void reportRemovedFunction(Node functionNode) {\n-      hasChanged = removedFunctions.add(functionNode);\n+     * @param declaringBlock If the function declaration puts a variable in the\n+     *    scope, we need to have a VAR statement in the scope where the\n+     *    function is declared. Null if the function does not put a name\n+     *    in the scope.\n+     */\n+    public void reportRemovedFunction(Node functionNode, Node declaringBlock) {\n+      // Depends when we were notified, functionNode.getParent might or might\n+      // not be null. We are going to force the user to tell us the parent\n+      // instead.\n+      if (removedFunctions.add(functionNode)) {\n+        hasChanged = true;\n+        removedFunctionToBlock.put(functionNode, declaringBlock);\n+      }\n     }\n     \n     /**\n--- a/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n+++ b/test/com/google/javascript/jscomp/SpecializeModuleTest.java\n       \n       Node functionF = findFunction(\"F\");\n       \n-      lastState.reportRemovedFunction(functionF);\n+      lastState.reportRemovedFunction(functionF, functionF.getParent());\n       assertEquals(ImmutableSet.of(functionF), lastState.getRemovedFunctions());\n \n       Node functionG = findFunction(\"F\");\n       \n-      lastState.reportRemovedFunction(functionG);\n+      lastState.reportRemovedFunction(functionG, functionF.getParent());\n       assertEquals(ImmutableSet.of(functionF, functionG),\n           lastState.getRemovedFunctions());\n       ", "timestamp": 1283302131, "metainfo": ""}