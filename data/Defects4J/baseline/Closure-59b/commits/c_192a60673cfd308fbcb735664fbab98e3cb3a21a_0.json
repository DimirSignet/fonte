{"sha": "192a60673cfd308fbcb735664fbab98e3cb3a21a", "log": "Revision created by MOE tool push_codebase. MOE_MIGRATION=53006   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n \n     @Override\n     public Node reduce(Node node) {\n-      if (!NodeUtil.isFunctionExpression(node)) {\n-        return node;\n-      }\n-\n-      if (isEmptyFunction(node)) {\n+      if (NodeUtil.isEmptyFunctionExpression(node)) {\n         return buildCallNode(FACTORY_METHOD_NAME, null,\n                              node.getLineno(), node.getCharno());\n       } else {\n         return node;\n       }\n-    }\n-\n-    /**\n-     * Checks if the function matches the pattern:\n-     *   function() {}\n-     * @return Whether the function matches.\n-     */\n-    private boolean isEmptyFunction(Node functionNode) {\n-      Node body = functionNode.getLastChild();\n-      return !body.hasChildren();\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Determines if a node is a function expression that has an empty body.\n+   *\n+   * @param n a node\n+   * @return whether the given node is a function expression that is empty\n+   */\n+  static boolean isEmptyFunctionExpression(Node node) {\n+    return isFunctionExpression(node) && isEmptyBlock(node.getLastChild());\n+  }\n+\n+  /**\n    * Determines if a function takes a variable number of arguments by\n    * looking for references to the \"arguments\" var_args object.\n    */\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n  * about types in the type registry.\n  */\n final class TypedScopeCreator implements ScopeCreator {\n+  /**\n+   * A suffix for naming delegate proxies differently from their base.\n+   */\n+  static final String DELEGATE_PROXY_SUFFIX = \"(Proxy)\";\n \n   static final DiagnosticType MALFORMED_TYPEDEF =\n       DiagnosticType.warning(\n               typeRegistry.createDefaultObjectUnion(delegateBaseObject),\n               functionParamBuilder.build());\n \n-          // The suffix is necessary for the proxy to be distinguished from\n-          // the base.\n           FunctionType delegateProxy = typeRegistry.createConstructorType(\n-              delegateBaseObject.getReferenceName() + \"(Proxy)\",\n+              delegateBaseObject.getReferenceName() + DELEGATE_PROXY_SUFFIX,\n               null, null, null);\n           delegateProxy.setPrototypeBasedOn(delegateBaseObject);\n ", "timestamp": 1279274174, "metainfo": ""}