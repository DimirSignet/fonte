{"sha": "f0e3cbc250fd9536ff92119bdf5e1a62120a7fac", "log": "Fix handling of blocks containing synthetic blocks in control structures.  R=nicksantos DELTA=43  (19 added, 2 deleted, 22 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=209648   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         if (n.getClass() != Node.class) {\n           throw new Error(\"Unexpected Node subclass.\");\n         }\n-        boolean stripBlock = n.isSyntheticBlock() ||\n-            n.getType() == Token.SCRIPT ||\n-            ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));\n-        if (!stripBlock) {\n+        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n+        if (preserveBlock) {\n           cc.beginBlock();\n         }\n         for (Node c = first; c != null; c = c.getNext()) {\n             cc.notePreferredLineBreak();\n           }\n         }\n-        if (!stripBlock) {\n+        if (preserveBlock) {\n           cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n         }\n         break;\n           add(\";\");\n           add(first.getNext().getNext());\n           add(\")\");\n-          addNonEmptyExpression(\n+          addNonEmptyStatement(\n               last, getContextForNonEmptyExpression(context), false);\n         } else {\n           Preconditions.checkState(childCount == 3);\n           add(\"in\");\n           add(first.getNext());\n           add(\")\");\n-          addNonEmptyExpression(\n+          addNonEmptyStatement(\n               last, getContextForNonEmptyExpression(context), false);\n         }\n         break;\n       case Token.DO:\n         Preconditions.checkState(childCount == 2);\n         add(\"do\");\n-        addNonEmptyExpression(first, Context.OTHER, false);\n+        addNonEmptyStatement(first, Context.OTHER, false);\n         add(\"while(\");\n         add(last);\n         add(\")\");\n         add(\"while(\");\n         add(first);\n         add(\")\");\n-        addNonEmptyExpression(\n+        addNonEmptyStatement(\n             last, getContextForNonEmptyExpression(context), false);\n         break;\n \n         add(\"with(\");\n         add(first);\n         add(\")\");\n-        addNonEmptyExpression(\n+        addNonEmptyStatement(\n             last, getContextForNonEmptyExpression(context), false);\n         break;\n \n         add(\")\");\n \n         if (hasElse) {\n-          addNonEmptyExpression(\n+          addNonEmptyStatement(\n               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n           add(\"else\");\n-          addNonEmptyExpression(\n+          addNonEmptyStatement(\n               last, getContextForNonEmptyExpression(context), false);\n         } else {\n-          addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n+          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n           Preconditions.checkState(childCount == 2);\n         }\n \n         }\n         add(first);\n         add(\":\");\n-        addNonEmptyExpression(\n+        addNonEmptyStatement(\n             last, getContextForNonEmptyExpression(context), true);\n         break;\n \n    * @param n The node to print.\n    * @param context The context to determine how the node should be printed.\n    */\n-  private void addNonEmptyExpression(\n+  private void addNonEmptyStatement(\n       Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess = n;\n \n \n     // Strip unneeded blocks, that is blocks with <2 children unless\n     // the CodePrinter specifically wants to keep them.\n-    if (n.getType() == Token.BLOCK ) {\n+    if (n.getType() == Token.BLOCK) {\n       int count = getNonEmptyChildCount(n, 2);\n       if (count == 0) {\n         if (cc.shouldPreserveExtraBlocks()) {\n           // Continue with the only child.\n           nodeToProcess = firstAndOnlyChild;\n         }\n+      }\n+\n+      if (count > 1) {\n+        context = Context.PRESERVE_BLOCK;\n       }\n     }\n \n     int i = 0;\n     Node c = n.getFirstChild();\n     for (; c != null && i < maxCount; c = c.getNext()) {\n-      if (c.getType() != Token.EMPTY) {\n+      if (c.getType() == Token.BLOCK) {\n+        i += getNonEmptyChildCount(c, maxCount-i);\n+      } else if (c.getType() != Token.EMPTY) {\n         i++;\n       }\n     }\n   /** Gets the first non-empty child of the given node. */\n   private static Node getFirstNonEmptyChild(Node n) {\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-      if (c.getType() != Token.EMPTY) {\n+      if (c.getType() == Token.BLOCK) {\n+        Node result = getFirstNonEmptyChild(c);\n+        if (result != null) {\n+          return result;\n+        }\n+      } else if (c.getType() != Token.EMPTY) {\n         return c;\n       }\n     }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     assertPrint(\n         \"var user = new function() {\"\n         + \"this.name = \\\"foo\\\";\"\n-        + \"this.local = function(){alert(this.name)};}\", \n+        + \"this.local = function(){alert(this.name)};}\",\n         \"var user=new function(){\"\n         + \"this.name=\\\"foo\\\";\"\n         + \"this.local=function(){alert(this.name)}}\");\n-  }  \n+  }\n \n   public void testLineLength() {\n     // list\n     testReparse(\"with(foo()) { x = z; y = t; } with(bar()) a = z;\");\n     testReparse(\"delete foo['bar']; delete foo;\");\n     testReparse(\"var x = { 'a':'paul', 1:'3', 2:(3,4) };\");\n-    testReparse(\"switch(a) { case 2: case 3: { stuff(); break; }\" +\n+    testReparse(\"switch(a) { case 2: case 3: stuff(); break;\" +\n         \"case 4: morestuff(); break; default: done();}\");\n     testReparse(\"x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;\");\n     testReparse(\"a.v = b.v; x['foo'] = y['zoo'];\");\n   }\n \n   private void testReparse(String code) {\n+    Compiler compiler = new Compiler();\n     Node parse1 = parse(code);\n     Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n-    assertTrue(code, parse1.checkTreeEqualsSilent(parse2));\n+    String explanation = parse1.checkTreeEquals(parse2);\n+    assertNull(\"\\nExpected: \" + compiler.toSource(parse1) +\n+        \"\\nResult: \" + compiler.toSource(parse2) +\n+        \"\\n\" + explanation, explanation);\n   }\n \n   public void testDoLoopIECompatiblity() {\n   public void testPrintScript() {\n     // Verify that SCRIPT nodes not marked as synthetic are printed as\n     // blocks.\n-    Node ast = new Node(Token.SCRIPT, \n-        new Node(Token.EXPR_RESULT, Node.newString(\"f\")), \n-        new Node(Token.EXPR_RESULT, Node.newString(\"g\"))); \n-    String result = new CodePrinter.Builder(ast).setPrettyPrint(true).build();    \n+    Node ast = new Node(Token.SCRIPT,\n+        new Node(Token.EXPR_RESULT, Node.newString(\"f\")),\n+        new Node(Token.EXPR_RESULT, Node.newString(\"g\")));\n+    String result = new CodePrinter.Builder(ast).setPrettyPrint(true).build();\n     assertEquals(\"\\\"f\\\";\\n\\\"g\\\"\", result);\n   }\n }\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n     testSame(\"function foo(endMarker){}\");\n     testSame(\"function foo(){startMarker:foo()}\");\n   }\n+\n+  public void testContainingBlockPreservation() {\n+    testSame(\"if(y){startMarker();x();endMarker()}\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RemoveTryCatchTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveTryCatchTest.java\n     test(\"try{var a=1;}catch(ex){var b=2;}\",\n          \"var b;var a=1\");\n     test(\"try{var a=1;var b=2}catch(ex){var c=3;var d=4;}\",\n-         \"var d;var c;{var a=1;var b=2}\");\n+         \"var d;var c;var a=1;var b=2\");\n     test(\"try{var a=1;var b=2}catch(ex){}\",\n-         \"{var a=1;var b=2}\");\n+         \"var a=1;var b=2\");\n   }\n \n   public void testRemoveTryFinally() {\n     test(\"try{var a=1;}finally{var c=3;}\",\n          \"var a=1;var c=3\");\n     test(\"try{var a=1;var b=2}finally{var e=5;var f=6;}\",\n-         \"{var a=1;var b=2}{var e=5;var f=6}\");\n+         \"var a=1;var b=2;var e=5;var f=6\");\n   }\n \n   public void testRemoveTryCatchFinally() {\n          \"var b;var a=1;var c=3\");\n     test(\"try{var a=1;var b=2}catch(ex){var c=3;var d=4;}finally{var e=5;\" +\n          \"var f=6;}\",\n-         \"var d;var c;{var a=1;var b=2}{var e=5;var f=6}\");\n+         \"var d;var c;var a=1;var b=2;var e=5;var f=6\");\n   }\n \n   public void testPreserveTryBlockContainingReturnStatement() {", "timestamp": 1283971687, "metainfo": ""}