{"sha": "ffe67f22a342291ecfed36c1c6ee7c01186f9eff", "log": "Change on 2010/05/07 by robby          Add diagnostics to the ScopedAliases pass.          R=nick         DELTA=141  (95 added, 1 deleted, 45 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=vohmth   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n   /** Name used to denote an scoped function block used for aliasing. */\n   static final String SCOPING_METHOD_NAME = \"goog.scope\";\n \n-  final AbstractCompiler compiler;\n+  private final AbstractCompiler compiler;\n+\n+  // Errors\n+  static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n+      \"The call to goog.scope must be alone in a single statement.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS =\n+      DiagnosticType.error(\n+          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n+          \"The call to goog.scope must take only a single parameter.  It must\" +\n+              \" be an anonymous function that itself takes no parameters.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n+      \"The body of a goog.scope function cannot reference 'this'.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_USES_RETURN\",\n+      \"The body of a goog.scope function cannot use 'return'.\");\n+\n+  static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n+      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n+      \"The alias {0} is assigned a value more than once.\");\n \n   ScopedAliases(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     Traversal traversal = new Traversal();\n     NodeTraversal.traverse(compiler, root, traversal);\n \n-    // Apply the aliases.\n-    for (AliasedNode entry : traversal.getAliasUsages()) {\n-      entry.getAliasReference().getParent().replaceChild(\n-          entry.getAliasReference(),\n-          entry.getAliasDefinition().cloneTree());\n-    }\n-\n-    // Remove the alias definitions.\n-    for (Node aliasDefinition : traversal.getAliasDefinitions()) {\n-      if (aliasDefinition.getParent().getType() == Token.VAR &&\n-          aliasDefinition.getParent().getChildCount() == 1) {\n-        aliasDefinition.getParent().detachFromParent();\n-      } else {\n-        aliasDefinition.detachFromParent();\n-      }\n-    }\n-\n-    // Collapse the scopes.\n-    for (Node scopeCall : traversal.getScopeCalls()) {\n-      Node expressionWithScopeCall = scopeCall.getParent();\n-      Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n-      scopeClosureBlock.detachFromParent();\n-      expressionWithScopeCall.getParent().replaceChild(\n-          expressionWithScopeCall,\n-          scopeClosureBlock);\n-      NodeUtil.tryMergeBlock(scopeClosureBlock);\n-    }\n-\n-    if (traversal.getAliasUsages().size() > 0 ||\n-        traversal.getAliasDefinitions().size() > 0 ||\n-        traversal.getScopeCalls().size() > 0) {\n-      compiler.reportCodeChange();\n+    if (!traversal.hasErrors()) {\n+      // Apply the aliases.\n+      for (AliasedNode entry : traversal.getAliasUsages()) {\n+        entry.getAliasReference().getParent().replaceChild(\n+            entry.getAliasReference(),\n+            entry.getAliasDefinition().cloneTree());\n+      }\n+\n+      // Remove the alias definitions.\n+      for (Node aliasDefinition : traversal.getAliasDefinitions()) {\n+        if (aliasDefinition.getParent().getType() == Token.VAR &&\n+            aliasDefinition.getParent().getChildCount() == 1) {\n+          aliasDefinition.getParent().detachFromParent();\n+        } else {\n+          aliasDefinition.detachFromParent();\n+        }\n+      }\n+\n+      // Collapse the scopes.\n+      for (Node scopeCall : traversal.getScopeCalls()) {\n+        Node expressionWithScopeCall = scopeCall.getParent();\n+        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n+        scopeClosureBlock.detachFromParent();\n+        expressionWithScopeCall.getParent().replaceChild(\n+            expressionWithScopeCall,\n+            scopeClosureBlock);\n+        NodeUtil.tryMergeBlock(scopeClosureBlock);\n+      }\n+\n+      if (traversal.getAliasUsages().size() > 0 ||\n+          traversal.getAliasDefinitions().size() > 0 ||\n+          traversal.getScopeCalls().size() > 0) {\n+        compiler.reportCodeChange();\n+      }\n     }\n   }\n \n     // This map is temporary and cleared for each scope.\n     private Map<String, Node> aliases = Maps.newHashMap();\n \n+    private boolean hasErrors = false;\n \n     List<Node> getAliasDefinitions() {\n       return aliasDefinitions;\n \n     List<Node> getScopeCalls() {\n       return scopeCalls;\n+    }\n+\n+    boolean hasErrors() {\n+      return hasErrors;\n     }\n \n     private boolean isCallToScopeMethod(Node n) {\n       return true;\n     }\n \n+    private void report(NodeTraversal t, Node n, DiagnosticType error,\n+        String... arguments) {\n+      compiler.report(t.makeError(n, error, arguments));\n+      hasErrors = true;\n+    }\n+\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       if (isCallToScopeMethod(n)) {\n-        // TODO(robbyw): Report an error if the call is not at the root of an\n-        // expression: NodeUtil.isExpressionNode(parent)\n-        // TODO(robbyw): Report an error if the parameter is not anonymous\n-        // or has extra parameters.\n-        // Node firstParam = n.getFirstChild().getNext();\n-        // NodeUtil.isFunction(firstParam);\n-        // NodeUtil.getFunctionName(firstParam).isEmpty();\n-        // NodeUtil.getFnParameters(firstParam).hasChildren();\n-        scopeCalls.add(n);\n+        if (!NodeUtil.isExpressionNode(parent)) {\n+          report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n+        }\n+        if (n.getChildCount() != 2) {\n+          // The goog.scope call should have exactly 1 parameter.  The first\n+          // child is the \"goog.scope\" and the second should be the parameter.\n+          report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+        } else {\n+          Node anonymousFnNode = n.getChildAtIndex(1);\n+          if (!NodeUtil.isFunction(anonymousFnNode) ||\n+              NodeUtil.getFunctionName(anonymousFnNode) != null ||\n+              NodeUtil.getFnParameters(anonymousFnNode).hasChildren()) {\n+            report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+          } else {\n+            scopeCalls.add(n);\n+          }\n+        }\n       }\n \n       if (t.getScopeDepth() == 2) {\n \n       if (t.getScopeDepth() >= 2) {\n         if (n.getType() == Token.NAME) {\n-          // TODO(robbyw): Check if the name is overridden locally.\n-          // TODO(robbyw): Check if this is a place where the name is being set.\n+          if (NodeUtil.isAssignmentOp(parent)) {\n+            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+          }\n           Node aliasedNode = aliases.get(n.getString());\n           // The variable should not exist since we undeclared it when we found\n           // it.  If it does exist, it's because it's been overridden.\n           }\n         }\n \n-        // TODO(robbyw): Disallow RETURN nodes and THIS nodes.\n+        if (n.getType() == Token.RETURN) {\n+          report(t, n, GOOG_SCOPE_USES_RETURN);\n+        }\n+\n+        if (n.getType() == Token.THIS) {\n+          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        }\n       }\n     }\n   }\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n         \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n   }\n \n-\n   public void testFourLevel() {\n     testScoped(\"var DIV = goog.dom.TagName.DIV;goog.dom.createElement(DIV);\",\n         \"goog.dom.createElement(goog.dom.TagName.DIV);\");\n   // TODO(robbyw): Test JsDoc aliasing.\n   // TODO(robbyw): What if it's recursive?  var goog = goog.dom;\n \n+  // FAILURE CASES\n+\n+  private void testFailure(String code, DiagnosticType expectedError) {\n+    test(code, null, expectedError);\n+  }\n+\n+  private void testScopedFailure(String code, DiagnosticType expectedError) {\n+    test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n+  }\n+\n+  public void testScopedThis() {\n+    testScopedFailure(\"this.y = 10;\", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS);\n+    testScopedFailure(\"var x = this;\",\n+        ScopedAliases.GOOG_SCOPE_REFERENCES_THIS);\n+    testScopedFailure(\"fn(this);\", ScopedAliases.GOOG_SCOPE_REFERENCES_THIS);\n+  }\n+\n+  public void testAliasRedefinition() {\n+    testScopedFailure(\"var x = goog.dom; x = goog.events;\",\n+        ScopedAliases.GOOG_SCOPE_ALIAS_REDEFINED);\n+  }\n+\n+  public void testScopedReturn() {\n+    testScopedFailure(\"return;\", ScopedAliases.GOOG_SCOPE_USES_RETURN);\n+    testScopedFailure(\"var x = goog.dom; return;\",\n+        ScopedAliases.GOOG_SCOPE_USES_RETURN);\n+  }\n+\n+  public void testUsedImproperly() {\n+    testFailure(\"var x = goog.scope(function() {});\",\n+        ScopedAliases.GOOG_SCOPE_USED_IMPROPERLY);\n+  }\n+\n+  public void testBadParameters() {\n+    testFailure(\"goog.scope()\", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+    testFailure(\"goog.scope(10)\", ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+    testFailure(\"goog.scope(function() {}, 10)\",\n+        ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+    testFailure(\"goog.scope(function z() {})\",\n+        ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+    testFailure(\"goog.scope(function(a, b, c) {})\",\n+        ScopedAliases.GOOG_SCOPE_HAS_BAD_PARAMETERS);\n+  }\n+\n   @Override\n   protected ScopedAliases getProcessor(Compiler compiler) {\n     return new ScopedAliases(compiler);", "timestamp": 1273603394, "metainfo": ""}