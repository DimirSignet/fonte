{"sha": "a4f32ed8acef2880288fe9559f8c60fba444bbe3", "log": "Fix mismatch between the definition of candidate references used when initially gathering references and when checking for inlining conflicts. Fixes issue 423  R=nicksantos DELTA=100  (66 added, 29 deleted, 5 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1486   ", "commit": "\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     }\n   }\n \n+  /**\n+   * @return Whether the name is used in a way that might be a candidate\n+   *   for inlining.\n+   */\n+  static boolean isCandidateUsage(Node name) {\n+    Node parent = name.getParent();\n+    Preconditions.checkState(name.getType() == Token.NAME);\n+    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {\n+      // This is a declaration.  Duplicate declarations are handle during\n+      // function candidate gathering.\n+      return true;\n+    }\n+\n+    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {\n+      // This is a normal reference to the function.\n+      return true;\n+    }\n+\n+    // Check for a \".call\" to the named function:\n+    //   CALL\n+    //     GETPROP/GETELEM\n+    //       NAME\n+    //       STRING == \"call\"\n+    //     This-Value\n+    //     Function-parameter-1\n+    //     ...\n+    if (NodeUtil.isGet(parent)\n+         && name == parent.getFirstChild()\n+         && name.getNext().getType() == Token.STRING\n+         && name.getNext().getString().equals(\"call\")) {\n+      Node gramps = name.getAncestor(2);\n+      if (gramps.getType() == Token.CALL\n+          && gramps.getFirstChild() == parent) {\n+        // Yep, a \".call\".\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n \n   /**\n    * Find references to functions that are inlinable.\n     private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n       Preconditions.checkState(n.getType() == Token.NAME);\n \n-      if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {\n-        // This is a declaration.  Duplicate declarations are handle during\n-        // function candidate gathering.\n+      if (isCandidateUsage(n)) {\n         return;\n-      }\n-\n-      if (parent.getType() == Token.CALL && parent.getFirstChild() == n) {\n-        // This is a normal reference to the function.\n-        return;\n-      }\n-\n-      // Check for a \".call\" to the named function:\n-      //   CALL\n-      //     GETPROP/GETELEM\n-      //       NAME\n-      //       STRING == \"call\"\n-      //     This-Value\n-      //     Function-parameter-1\n-      //     ...\n-      if (NodeUtil.isGet(parent)\n-           && n == parent.getFirstChild()\n-           && n.getNext().getType() == Token.STRING\n-           && n.getNext().getString().equals(\"call\")) {\n-        Node gramps = n.getAncestor(2);\n-        if (gramps.getType() == Token.CALL\n-            && gramps.getFirstChild() == parent) {\n-          // Yep, a \".call\".\n-          return;\n-        }\n       }\n \n       // Other refs to a function name remove its candidacy for inlining\n    */\n   private Set<String> findCalledFunctions(Node node) {\n     Set<String> changed = Sets.newHashSet();\n-    findCalledFunctions(node, changed);\n+    findCalledFunctions(NodeUtil.getFunctionBody(node), changed);\n     return changed;\n   }\n \n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        String name = child.getString();\n-        changed.add(name);\n+    if (node.getType() == Token.NAME) {\n+      if (isCandidateUsage(node)) {\n+        changed.add(node.getString());\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n              \"new JSCompiler_ObjectPropertyString(window, f); f(1)\");\n   }\n \n+  public void testIssue423() {\n+    test(\n+        \"(function($) {\\n\" +\n+        \"  $.fn.multicheck = function(options) {\\n\" +\n+        \"    initialize.call(this, options);\\n\" +\n+        \"  };\\n\" +\n+        \"\\n\" +\n+        \"  function initialize(options) {\\n\" +\n+        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n+        \"    preload_check_all.call(this);\\n\" +\n+        \"  }\\n\" +\n+        \"\\n\" +\n+        \"  function preload_check_all() {\\n\" +\n+        \"    $(this).data('checkboxes');\\n\" +\n+        \"  }\\n\" +\n+        \"})(jQuery)\",\n+        \"(function($){\" +\n+        \"  $.fn.multicheck=function(options$$1){\" +\n+        \"    {\" +\n+        \"     options$$1.checkboxes=$(this).siblings(\\\":checkbox\\\");\" +\n+        \"     {\" +\n+        \"       $(this).data(\\\"checkboxes\\\")\" +\n+        \"     }\" +\n+        \"    }\" +\n+        \"  }\" +\n+        \"})(jQuery)\");\n+  }\n \n   // Inline a single reference function into deeper modules\n   public void testCrossModuleInlining1() {", "timestamp": 1302803338, "metainfo": ""}