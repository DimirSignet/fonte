{"sha": "cd40201a2437da125ac492b21f13c8ad200b96bd", "log": "pretty print in the ExternExportsPass, try #2 Make sure the source file ends with a semi-colon and newline when pretty printed. Changes some of the printing that's done in Compiler.jar (new since try #1) Fixes issue 309  R=jschorr DELTA=87  (24 added, 12 deleted, 51 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=220   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n   boolean breakAfterBlockFor(Node n, boolean statementContext) {\n     return statementContext;\n   }\n+\n+  /** Called when we're at the end of a file. */\n+  void endFile() {}\n }\n--- a/src/com/google/javascript/jscomp/CodePrinter.java\n+++ b/src/com/google/javascript/jscomp/CodePrinter.java\n       }\n       return true;\n     }\n+\n+    @Override\n+    void endFile() {\n+      maybeEndStatement();\n+    }\n   }\n \n \n         ? new TypedCodeGenerator(mcp, outputCharset)\n         : new CodeGenerator(mcp, outputCharset);\n     cg.add(root);\n+    mcp.endFile();\n \n     String code = mcp.getCode();\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n         String code = toSource(root, sourceMap);\n         if (!code.isEmpty()) {\n           cb.append(code);\n-          if (!code.endsWith(\";\")) {\n+\n+          // In order to avoid parse ambiguity when files are concatenated\n+          // together, all files should end in a semi-colon. Do a quick\n+          // heuristic check if there's an obvious semi-colon already there.\n+          int length = code.length();\n+          char lastChar = code.charAt(length - 1);\n+          char secondLastChar = length >= 2 ?\n+              code.charAt(length - 2) : '\\0';\n+          boolean hasSemiColon = lastChar == ';' ||\n+              (lastChar == '\\n' && secondLastChar == ';');\n+          if (!hasSemiColon) {\n             cb.append(\";\");\n           }\n         }\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n    */\n   public String getGeneratedExterns() {\n     CodePrinter.Builder builder = new CodePrinter.Builder(externsRoot)\n-      .setPrettyPrint(false).setOutputTypes(true);\n+      .setPrettyPrint(true).setOutputTypes(true);\n \n     return builder.build();\n   }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n   public void testPrettyPrinter() {\n     // Ensure that the pretty printer inserts line breaks at appropriate\n     // places.\n-    assertPrettyPrint(\"(function(){})();\",\"(function() {\\n})()\");\n+    assertPrettyPrint(\"(function(){})();\",\"(function() {\\n})();\\n\");\n     assertPrettyPrint(\"var a = (function() {});alert(a);\",\n-        \"var a = function() {\\n};\\nalert(a)\");\n+        \"var a = function() {\\n};\\nalert(a);\\n\");\n \n     // Check we correctly handle putting brackets around all if clauses so\n     // we can put breakpoints inside statements.\n \n     // Don't add blocks if they weren't there already.\n     assertPrettyPrint(\"label: alert();\",\n-        \"label:alert()\");\n+        \"label:alert();\\n\");\n \n     // But if statements and loops get blocks automagically.\n     assertPrettyPrint(\"if (1) alert();\",\n     assertPrettyPrint(\"do { alert(); } while(true);\",\n         \"do {\\n\" +\n         \"  alert()\\n\" +\n-        \"}while(true)\");\n+        \"}while(true);\\n\");\n \n     // label?\n     assertPrettyPrint(\"myLabel: { alert();}\",\n         \"myLabel:for(;;) {\\n\" +\n         \"  continue myLabel\\n\" +\n         \"}\\n\");\n+\n+    assertPrettyPrint(\"var a;\", \"var a;\\n\");\n   }\n \n   public void testPrettyPrinter2() {\n   public void testTypeAnnotationsAssign() {\n     assertTypeAnnotations(\"/** @constructor */ var Foo = function(){}\",\n         \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n-        + \"var Foo = function() {\\n}\");\n+        + \"var Foo = function() {\\n};\\n\");\n   }\n \n   public void testTypeAnnotationsNamespace() {\n         + \"/** @constructor */ a.Foo = function(){}\",\n         \"var a = {};\\n\"\n         + \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n-        + \"a.Foo = function() {\\n}\");\n+        + \"a.Foo = function() {\\n};\\n\");\n   }\n \n   public void testTypeAnnotationsMemberSubclass() {\n         + \"a.Foo = function() {\\n};\\n\"\n         + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n         + \" * @constructor\\n */\\n\"\n-        + \"a.Bar = function() {\\n}\");\n+        + \"a.Bar = function() {\\n};\\n\");\n   }\n \n   public void testTypeAnnotationsInterface() {\n         + \"a.Foo = function() {\\n};\\n\"\n         + \"/**\\n * @extends {a.Foo}\\n\"\n         + \" * @interface\\n */\\n\"\n-        + \"a.Bar = function() {\\n}\");\n+        + \"a.Bar = function() {\\n};\\n\");\n   }\n \n   public void testTypeAnnotationsMember() {\n         + \" */\\n\"\n         + \"a.Foo.prototype.foo = function(foo) {\\n  return 3\\n};\\n\"\n         + \"/** @type {string} */\\n\"\n-        + \"a.Foo.prototype.bar = \\\"\\\"\");\n+        + \"a.Foo.prototype.bar = \\\"\\\";\\n\");\n   }\n \n   public void testTypeAnnotationsImplements() {\n         + \"/**\\n * @return {undefined}\\n * @extends {a.Foo}\\n\"\n         + \" * @implements {a.I}\\n\"\n         + \" * @implements {a.I2}\\n * @constructor\\n */\\n\"\n-        + \"a.Bar = function() {\\n}\");\n+        + \"a.Bar = function() {\\n};\\n\");\n   }\n \n   public void testTypeAnnotationsDispatcher1() {\n         \" * @javadispatch\\n\" +\n         \" */\\n\" +\n         \"a.Foo = function() {\\n\" +\n-        \"}\");\n+        \"};\\n\");\n   }\n \n   public void testTypeAnnotationsDispatcher2() {\n         \" * @javadispatch\\n\" +\n         \" */\\n\" +\n         \"a.Foo.prototype.foo = function() {\\n\" +\n-        \"}\");\n+        \"};\\n\");\n   }\n \n   public void testU2UFunctionTypeAnnotation() {\n     assertTypeAnnotations(\n         \"/** @type {!Function} */ var x = function() {}\",\n-        \"/**\\n * @constructor\\n */\\nvar x = function() {\\n}\");\n+        \"/**\\n * @constructor\\n */\\nvar x = function() {\\n};\\n\");\n   }\n \n   public void testEmitUnknownParamTypesAsAllType() {\n         \" * @param {*} x\\n\" +\n         \" * @return {undefined}\\n\" +\n         \" */\\n\" +\n-        \"var a = function(x) {\\n}\");\n+        \"var a = function(x) {\\n};\\n\");\n   }\n \n   public void testOptionalTypesAnnotation() {\n         \" * @param {string=} x\\n\" +\n         \" * @return {undefined}\\n\" +\n         \" */\\n\" +\n-        \"var a = function(x) {\\n}\");\n+        \"var a = function(x) {\\n};\\n\");\n   }\n \n   public void testVariableArgumentsTypesAnnotation() {\n         \" * @param {...string} x\\n\" +\n         \" * @return {undefined}\\n\" +\n         \" */\\n\" +\n-        \"var a = function(x) {\\n}\");\n+        \"var a = function(x) {\\n};\\n\");\n   }\n \n   public void testTempConstructor() {\n         \"function t1() {\\n  }\\n\" +\n         \"  /**\\n * @return {undefined}\\n * @constructor\\n */\\n\" +\n         \"function t2() {\\n  }\\n\" +\n-        \"  t1.prototype = t2.prototype\\n}\"\n+        \"  t1.prototype = t2.prototype\\n};\\n\"\n     );\n   }\n \n         new Node(Token.EXPR_RESULT, Node.newString(\"f\")),\n         new Node(Token.EXPR_RESULT, Node.newString(\"g\")));\n     String result = new CodePrinter.Builder(ast).setPrettyPrint(true).build();\n-    assertEquals(\"\\\"f\\\";\\n\\\"g\\\"\", result);\n+    assertEquals(\"\\\"f\\\";\\n\\\"g\\\";\\n\", result);\n   }\n \n   public void testGetter() {\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n                     \" * @param {*} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n-                    \"var foobar = function(d, e, f) {\\n}\");\n+                    \"var foobar = function(d, e, f) {\\n};\\n\");\n   }\n \n   public void testExportSymbolDefinedInVar() throws Exception {\n                     \" * @param {*} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n-                    \"var foobar = function(d, e, f) {\\n}\");\n+                    \"var foobar = function(d, e, f) {\\n};\\n\");\n   }\n \n   public void testExportProperty() throws Exception {\n                     \" * @param {*} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n-                    \"a.b.cprop = function(d, e, f) {\\n}\");\n+                    \"a.b.cprop = function(d, e, f) {\\n};\\n\");\n   }\n \n   public void testExportMultiple() throws Exception {\n                     \" * @param {*} i\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n-                    \"a.b.prototype.c = function(g, h, i) {\\n}\");\n+                    \"a.b.prototype.c = function(g, h, i) {\\n};\\n\");\n   }\n \n   public void testExportMultiple2() throws Exception {\n                     \" * @param {*} i\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n-                    \"hello.b.prototype.c = function(g, h, i) {\\n}\");\n+                    \"hello.b.prototype.c = function(g, h, i) {\\n};\\n\");\n   }\n \n   public void testExportMultiple3() throws Exception {\n                     \" * @param {*} f\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" */\\n\" +\n-                    \"prefix.c = function(d, e, f) {\\n}\");\n+                    \"prefix.c = function(d, e, f) {\\n};\\n\");\n   }\n \n   public void testExportNonStaticSymbol() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; var d = {}; a.b.c = d;\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n-                    \"var foobar = {}\");\n+                    \"var foobar = {};\\n\");\n   }\n \n   public void testExportNonStaticSymbol2() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; var d = null; a.b.c = d;\" +\n                     \"goog.exportSymbol('foobar', a.b.c())\",\n-                    \"var foobar = {}\");\n+                    \"var foobar = {};\\n\");\n   }\n \n   public void testExportNonexistentProperty() throws Exception {\n                     \"goog.exportProperty(a.b, 'none', a.b.none)\",\n                     \"var a = {};\\n\" +\n                     \"a.b = {};\\n\" +\n-                    \"a.b.none = {}\");\n+                    \"a.b.none = {};\\n\");\n   }\n \n   public void testExportSymbolWithTypeAnnotation() {\n                     \" * @param {number} param2\\n\" +\n                     \" * @return {string}\\n\" +\n                     \" */\\n\" +\n-                    \"var externalName = function(param1, param2) {\\n}\");\n+                    \"var externalName = function(param1, param2) {\\n};\\n\");\n   }\n \n   public void testExportSymbolWithoutTypeCheck() {\n                       \"return param1 + param2;\" +\n                     \"};\" +\n                     \"goog.exportSymbol('externalName', internalName)\",\n-                    \"var externalName = function(param1, param2) {\\n}\");\n+                    \"var externalName = function(param1, param2) {\\n};\\n\");\n   }\n \n   public void testExportSymbolWithConstructor() {\n                     \" * @return {undefined}\\n\" +\n                     \" * @constructor\\n\" +\n                     \" */\\n\" +\n-                    \"var externalName = function() {\\n}\");\n+                    \"var externalName = function() {\\n};\\n\");\n   }\n \n   public void testExportSymbolWithConstructorWithoutTypeCheck() {\n                     \"internalName = function() {\" +\n                     \"};\" +\n                     \"goog.exportSymbol('externalName', internalName)\",\n-                    \"var externalName = function() {\\n}\");\n+                    \"var externalName = function() {\\n};\\n\");\n   }\n \n   public void testExportFunctionWithOptionalArguments() {\n         \"/**\\n\" +\n         \" * @param {number=} a\\n\" +\n         \" */\\n\" +\n-        \"var externalName = function(a) {\\n}\");\n+        \"var externalName = function(a) {\\n};\\n\");\n   }\n \n   public void testExportFunctionWithVariableArguments() {\n         \" * @param {...number} a\\n\" +\n         \" * @return {number}\\n\" +\n         \" */\\n\" +\n-        \"var externalName = function(a) {\\n}\");\n+        \"var externalName = function(a) {\\n};\\n\");\n   }\n \n   /**\n          // \"/**\\n\" +\n          // \" * @enum {string}\\n\" +\n          //\" */\\n\" +\n-         \"var E = {}\"\n+         \"var E = {};\\n\"\n      );\n    }\n \n         \"/**\\n\" +\n         \" * @return {number}\\n\" +\n         \" */\\n\" +\n-        \"Foo.prototype.m = function() {\\n}\"\n+        \"Foo.prototype.m = function() {\\n};\\n\"\n     );\n   }\n ", "timestamp": 1294364526, "metainfo": ""}