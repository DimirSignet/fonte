{"sha": "3698fee71e3671171c587f932795a8ab8e852cd8", "log": "when deciding whether named types are nullable, let enums and typedefs share the same hacky logic.  R=johnlenz DELTA=83  (57 added, 0 deleted, 26 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=804008   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n   static final String DELEGATE_PROXY_SUFFIX =\n       ObjectType.createDelegateSuffix(\"Proxy\");\n \n+  private static final String LEGACY_TYPEDEF = \"goog.typedef\";\n+\n   static final DiagnosticType MALFORMED_TYPEDEF =\n       DiagnosticType.warning(\n           \"JSC_MALFORMED_TYPEDEF\",\n   @VisibleForTesting\n   Scope createInitialScope(Node root) {\n \n-    NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));\n+    NodeTraversal.traverse(\n+        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n \n     Scope s = new Scope(root, compiler);\n     declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n     // The typedef construct needs the any type, so that it can be assigned\n     // to anything. This is kind of a hack, and an artifact of the typedef\n     // syntax we've chosen.\n-    declareNativeValueType(s, \"goog.typedef\", NO_TYPE);\n+    declareNativeValueType(s, LEGACY_TYPEDEF, NO_TYPE);\n \n     // ActiveXObject is unqiuely special, because it can be used to construct\n     // any type (the type that it creates is related to the arguments you\n     scope.declare(name, null, t, null, false);\n   }\n \n-  private static class DiscoverEnums extends AbstractShallowStatementCallback {\n+  private static class DiscoverEnumsAndTypedefs\n+      extends AbstractShallowStatementCallback {\n     private final JSTypeRegistry registry;\n \n-    DiscoverEnums(JSTypeRegistry registry) {\n+    DiscoverEnumsAndTypedefs(JSTypeRegistry registry) {\n       this.registry = registry;\n     }\n \n         case Token.VAR:\n           for (Node child = node.getFirstChild();\n                child != null; child = child.getNext()) {\n-            identifyEnumInNameNode(\n-                child, NodeUtil.getInfoForNameNode(child));\n+            identifyNameNode(\n+                child, child.getFirstChild(),\n+                NodeUtil.getInfoForNameNode(child));\n           }\n           break;\n         case Token.EXPR_RESULT:\n-          Node maybeAssign = node.getFirstChild();\n-          if (maybeAssign.getType() == Token.ASSIGN) {\n-            identifyEnumInNameNode(\n-                maybeAssign.getFirstChild(), maybeAssign.getJSDocInfo());\n-          }\n-          break;\n-      }\n-    }\n-\n-    private void identifyEnumInNameNode(Node nameNode, JSDocInfo info) {\n-      if (info != null && info.hasEnumParameterType()) {\n-        registry.identifyEnumName(nameNode.getQualifiedName());\n+          Node firstChild = node.getFirstChild();\n+          if (firstChild.getType() == Token.ASSIGN) {\n+            identifyNameNode(\n+                firstChild.getFirstChild(), firstChild.getLastChild(),\n+                firstChild.getJSDocInfo());\n+          } else {\n+            identifyNameNode(\n+                firstChild, null, firstChild.getJSDocInfo());\n+          }\n+          break;\n+      }\n+    }\n+\n+    private void identifyNameNode(\n+        Node nameNode, Node valueNode, JSDocInfo info) {\n+      if (nameNode.isQualifiedName()) {\n+        if (info != null) {\n+          if (info.hasEnumParameterType()) {\n+            registry.identifyNonNullableName(nameNode.getQualifiedName());\n+          } else if (info.hasTypedefType()) {\n+            registry.identifyNonNullableName(nameNode.getQualifiedName());\n+          }\n+        }\n+\n+        if (valueNode != null &&\n+            LEGACY_TYPEDEF.equals(valueNode.getQualifiedName())) {\n+          registry.identifyNonNullableName(nameNode.getQualifiedName());\n+        }\n       }\n     }\n   }\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   // /** @enum {MyObject} */ var MyEnum = ...;\n   // we won't be to declare \"MyEnum\" without evaluating the expression\n   // {MyObject}, and following those dependencies starts to lead us into\n-  // undecidable territory. Instead, we \"pre-declare\" enum types,\n+  // undecidable territory. Instead, we \"pre-declare\" enum types and typedefs,\n   // so that the expression resolver can decide whether a given name is\n   // nullable or not.\n-  private final Set<String> enumTypeNames = new HashSet<String>();\n+  private final Set<String> nonNullableTypeNames = new HashSet<String>();\n \n   // Types that have been \"forward-declared.\"\n   // If these types are not declared anywhere in the binary, we shouldn't\n   }\n \n   /**\n-   * Identifies the name of an enum before we actually declare it.\n-   */\n-  public void identifyEnumName(String name) {\n-    enumTypeNames.add(name);\n+   * Identifies the name of a typedef or enum before we actually declare it.\n+   */\n+  public void identifyNonNullableName(String name) {\n+    Preconditions.checkNotNull(name);\n+    nonNullableTypeNames.add(name);\n   }\n \n   /**\n           namedType = namedType.resolveInternal(reporter, scope);\n         }\n         if ((namedType instanceof ObjectType) &&\n-            !(enumTypeNames.contains(n.getString()))) {\n+            !(nonNullableTypeNames.contains(n.getString()))) {\n           Node typeList = n.getFirstChild();\n           if (typeList != null &&\n               (\"Array\".equals(n.getString()) ||\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @typedef {(Date|Array)} */ var MyTypedef;\",\n         \"@this type of a function must be an object\\n\" +\n         \"Actual type: (Array|Date|null)\");\n+  }\n+\n+  public void testBackwardsTypedefUse4() throws Exception {\n+    testTypes(\n+        \"/** @return {MyTypedef} */ function f() { return null; }\" +\n+        \"/** @typedef {string} */ var MyTypedef;\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBackwardsTypedefUse5() throws Exception {\n+    testTypes(\n+        \"/** @return {MyTypedef} */ function f() { return null; }\" +\n+        \"/** @type {string} */ var MyTypedef = goog.typedef;\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBackwardsTypedefUse6() throws Exception {\n+    testTypes(\n+        \"/** @return {goog.MyTypedef} */ function f() { return null; }\" +\n+        \"var goog = {};\" +\n+        \"/** @typedef {string} */ goog.MyTypedef;\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : null\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testBackwardsTypedefUse7() throws Exception {\n+    testTypes(\n+        \"/** @return {goog.MyTypedef} */ function f() { return null; }\" +\n+        \"var goog = {};\" +\n+        \"/** @typedef {Object} */ goog.MyTypedef;\");\n   }\n \n   public void testBackwardsConstructor1() throws Exception {\n         \"f(new A()); f(new B()); f(1);\",\n         \"actual parameter 1 of f does not match formal parameter\\n\" +\n         \"found   : number\\n\" +\n-        \"required: (AB|null)\");\n+        \"required: (A|B|null)\");\n   }\n \n   public void testCircularTypeDef() throws Exception {", "timestamp": 1288279903, "metainfo": ""}