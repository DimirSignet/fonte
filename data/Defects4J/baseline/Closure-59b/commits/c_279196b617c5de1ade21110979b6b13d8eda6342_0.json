{"sha": "279196b617c5de1ade21110979b6b13d8eda6342", "log": "Change on 2010/05/04 by nick          Pipe everything through the module code path.         This teases out a bunch of edge-case bugs that worked in the non-module         code path, but not the module code path (and vice-versa)          R=alan         DELTA=136  (67 added, 19 deleted, 50 changed)  Change on 2010/05/04 by nick          fiddle with the check_global_this_level decision tree         This should be off by default if collapse_properties is off,         and on by default if collapse_properties is on.          R=alan         DELTA=47  (32 added, 4 deleted, 11 changed)  Change on 2010/05/04 by andrew          -Infer that arguments to goog.asserts.assert() are non-nullable after the         call.         -Infer the types of arguments to goog.asserts.assert{String,Number,...} after         the call.          Tested:           -Added new unit tests.          R=nick         DELTA=277  (266 added, 4 deleted, 7 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=qdhuno   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   abstract CompilerInput newExternInput(String name);\n \n   /**\n-   * Gets the module graph. May return null if there are no modules.\n+   * Gets the module graph. May return null if there aren't at least two\n+   * modules.\n    */\n   abstract JSModuleGraph getModuleGraph();\n \n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n+import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n \n   public boolean isPrivate(String name) {\n     return false;\n   }\n+\n+  @Override\n+  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n+    return ImmutableList.<AssertionFunctionSpec>of(\n+        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n+        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n+            JSTypeNative.NUMBER_TYPE),\n+        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n+            JSTypeNative.STRING_TYPE),\n+        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n+            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n+        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n+            JSTypeNative.OBJECT_TYPE),\n+        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n+            JSTypeNative.ARRAY_TYPE),\n+        // TODO(agrieve): It would be better if this could make the first\n+        // parameter the type of the second parameter.\n+        new AssertionFunctionSpec(\"goog.asserts.assertInstanceof\",\n+            JSTypeNative.OBJECT_TYPE)\n+    );\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n \n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n /**\n  * CodingConvention defines a set of hooks to customize the behavior of the\n  * Compiler for a specific team/company.\n  *\n  * // TODO(bolinfest): Tighten up this interface -- it is far too big.\n- * \n+ *\n *\n *\n  */\n    * @return {@code true} if the name should be considered exported.\n    */\n   public boolean isExported(String name, boolean local);\n-  \n+\n   /**\n    * Should be isExported(name, true) || isExported(name, false);\n    */\n   public String getDelegateSuperclassName();\n \n   /**\n-   * Defines the delegate proxy prototype properties. Their types depend on \n+   * Defines the delegate proxy prototype properties. Their types depend on\n    * properties of the delegate base methods.\n    *\n    * @param delegateProxyPrototypes List of delegate proxy prototypes.\n    */\n   public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n       Node callNode);\n+\n+  /**\n+   * Returns the set of AssertionFunction.\n+   */\n+  public Collection<AssertionFunctionSpec> getAssertionFunctions();\n \n   static enum SubclassType {\n     INHERITS,\n       this.objectNode = objectNode;\n     }\n   }\n+\n+  /**\n+   * A function that will throw an exception when either:\n+   *   -One or more of its parameters evaluate to false.\n+   *   -One or more of its parameters are not of a certain type.\n+   */\n+  public class AssertionFunctionSpec {\n+    private final String functionName;\n+    private final JSTypeNative assertedType;\n+\n+    public AssertionFunctionSpec(String functionName) {\n+      this(functionName, null);\n+    }\n+\n+    public AssertionFunctionSpec(String functionName,\n+        JSTypeNative assertedType) {\n+      this.functionName = functionName;\n+      this.assertedType = assertedType;\n+    }\n+\n+    /** Returns the name of the function. */\n+    public String getFunctionName() {\n+      return functionName;\n+    }\n+\n+    /**\n+     * Returns the parameter of the assertion function that is being checked.\n+     * @param firstParam The first parameter of the function call.\n+     */\n+    public Node getAssertedParam(Node firstParam) {\n+      return firstParam;\n+    }\n+\n+    /**\n+     * Returns the type for a type assertion, or null if the function asserts\n+     * that the node must not be null or undefined. \n+     */\n+    public JSTypeNative getAssertedType() {\n+      return assertedType;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n    */\n   private static void applyBasicCompilationOptions(CompilerOptions options) {\n     options.skipAllCompilerPasses();\n-    options.checkGlobalThisLevel = CheckLevel.OFF;\n \n     // Allows annotations that are not standard.\n     options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n \n     // All the safe optimizations.\n     options.closurePass = true;\n-    options.checkGlobalThisLevel = CheckLevel.OFF;\n     options.foldConstants = true;\n     options.removeConstantExpressions = true;\n     options.coalesceVariableNames = true;\n     options.removeUnusedPrototypePropertiesInExterns = true;\n     options.collapseAnonymousFunctions = true;\n     options.collapseProperties = true;\n+    options.checkGlobalThisLevel = CheckLevel.WARNING;\n     options.rewriteFunctionExpressions = true;\n     options.devirtualizePrototypeMethods = true;\n     options.smartNameRemoval = true;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n    */\n   public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n       CompilerOptions options) {\n-    initOptions(options);\n-\n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = null;\n-    this.moduleGraph = null;\n-    this.inputs = makeCompilerInput(inputs, false);\n-    initBasedOnOptions();\n-\n-    initInputsByNameMap();\n+    JSModule module = new JSModule(\"[singleton]\");\n+    for (JSSourceFile input : inputs) {\n+      module.add(input);\n+    }\n+\n+    initModules(externs, Lists.newArrayList(module), options);\n   }\n \n   static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n     fillEmptyModules(modules);\n \n     this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n+\n     // Generate the module graph, and report any errors in the module\n     // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n-    }\n-    this.inputs = getAllInputsFromModules();\n+    this.modules = modules;\n+    if (modules.size() > 1) {\n+      try {\n+        this.moduleGraph = new JSModuleGraph(modules);\n+      } catch (JSModuleGraph.ModuleDependenceException e) {\n+        // problems with the module format.  Report as an error.  The\n+        // message gives all details.\n+        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n+                e.getModule().getName(), e.getDependentModule().getName()));\n+        return;\n+      }\n+    } else {\n+      this.moduleGraph = null;\n+    }\n+\n+    this.inputs = getAllInputsFromModules(modules);\n     initBasedOnOptions();\n \n     initInputsByNameMap();\n   private void checkFirstModule(List<JSModule> modules) {\n     if (modules.isEmpty()) {\n       report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n-    } else if (modules.get(0).getInputs().isEmpty()) {\n+    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n+      // The root module may only be empty if there is exactly 1 module.\n       report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n           modules.get(0).getName()));\n     }\n    * Fill any empty modules with a place holder file. It makes any cross module\n    * motion easier.\n    */\n-  private void fillEmptyModules(List<JSModule> modules) {\n+  private static void fillEmptyModules(List<JSModule> modules) {\n     for (JSModule module : modules) {\n       if (module.getInputs().isEmpty()) {\n         module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n     }\n   }\n \n-  static final DiagnosticType DUPLICATE_INPUT_IN_MODULES =\n-      DiagnosticType.error(\"JSC_DUPLICATE_INPUT_IN_MODULES_ERROR\",\n-          \"Two modules cannot contain the same input, but module {0} and {1} \"\n-              + \"both include \\\"{2}\\\"\");\n-\n   /**\n    * Rebuilds the internal list of inputs by iterating over all modules.\n    * This is necessary if inputs have been added to or removed from a module\n    * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n    */\n   public void rebuildInputsFromModules() {\n-    inputs = getAllInputsFromModules();\n+    inputs = getAllInputsFromModules(modules);\n     initInputsByNameMap();\n   }\n \n    * Builds a single list of all module inputs. Verifies that it contains no\n    * duplicates.\n    */\n-  private List<CompilerInput> getAllInputsFromModules() {\n+  private static List<CompilerInput> getAllInputsFromModules(\n+      List<JSModule> modules) {\n     List<CompilerInput> inputs = Lists.newArrayList();\n     Map<String, JSModule> inputMap = Maps.newHashMap();\n     for (JSModule module : modules) {\n       for (CompilerInput input : module.getInputs()) {\n         String inputName = input.getName();\n-        JSModule firstModule = inputMap.get(inputName);\n-        if (firstModule == null) {\n-          inputs.add(input);\n-          inputMap.put(inputName, module);\n-        } else {\n-          report(JSError.make(DUPLICATE_INPUT_IN_MODULES,\n-              firstModule.getName(), module.getName(), inputName));\n-        }\n-      }\n-    }\n-    if (hasErrors()) {\n-\n-      // There's no reason to bother parsing the code.\n-      return ImmutableList.of();\n-    }\n-\n+\n+        // NOTE(nicksantos): If an input is in more than one module,\n+        // it will show up twice in the inputs list, and then we\n+        // will get an error down the line.\n+        inputs.add(input);\n+        inputMap.put(inputName, module);\n+      }\n+    }\n     return inputs;\n   }\n \n         externsRoot.addChildToBack(n);\n       }\n \n+      // Check if the sources need to be re-ordered.\n       if (options.manageClosureDependencies) {\n         for (CompilerInput input : inputs) {\n           input.setCompiler(this);\n                 sorter.getInputsWithoutProvides()));\n       }\n \n-      List<CompilerInput> annotatedExterns = Lists.newArrayList();\n-      Iterator<CompilerInput> inputIterator = inputs.iterator();\n-      while (inputIterator.hasNext()) {\n-        CompilerInput input = inputIterator.next();\n+      // Check if externs files need to be lifted.\n+      boolean liftedExterns = false;\n+      for (CompilerInput input : inputs) {\n         Node n = input.getAstRoot(this);\n         if (hasErrors()) {\n           return null;\n           // the externs pile anyways.\n           externsRoot.addChildToBack(n);\n           input.setIsExtern(true);\n-          inputIterator.remove();\n+\n+          // TODO(nicksantos): We need a better mechanism to make sure\n+          // changes to the inputs array get reflected in JSModules.\n+          input.getModule().remove(input);\n+\n           externs.add(input);\n+          liftedExterns = true;\n+        }\n+      }\n+\n+      if (liftedExterns) {\n+        fillEmptyModules(modules);\n+        rebuildInputsFromModules();\n+      }\n+\n+      // Build the AST.\n+      for (CompilerInput input : inputs) {\n+        Node n = input.getAstRoot(this);\n+        if (n == null) {\n           continue;\n         }\n \n     normalized = state.normalized;\n   }\n \n+  @VisibleForTesting\n+  List<CompilerInput> getInputsForTesting() {\n+    return inputs;\n+  }\n+\n+  @VisibleForTesting\n+  List<CompilerInput> getExternsForTesting() {\n+    return externs;\n+  }\n+\n   @Override\n   boolean hasRegExpGlobalReferences() {\n     return hasRegExpGlobalReferences;\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Checks for certain uses of the {@code this} keyword that are considered\n    * unsafe because they are likely to reference the global {@code this}\n    * object unintentionally.\n+   *\n+   * If this is off, but collapseProperties is on, then the compiler will\n+   * usually ignore you and run this check anyways.\n    */\n   public CheckLevel checkGlobalThisLevel;\n \n     checkProvides = CheckLevel.OFF;\n     checkGlobalNamesLevel = CheckLevel.OFF;\n     brokenClosureRequiresLevel = CheckLevel.ERROR;\n-    checkGlobalThisLevel = CheckLevel.WARNING;\n+    checkGlobalThisLevel = CheckLevel.OFF;\n     checkUnreachableCode = CheckLevel.OFF;\n     checkMissingReturn = CheckLevel.OFF;\n     checkMissingGetCssNameLevel = CheckLevel.OFF;\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n  */\n package com.google.javascript.jscomp;\n \n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n /**\n  * CodingConvention defines a set of hooks to customize the behavior of the\n   public boolean isExported(String name, boolean local) {\n     return local && name.startsWith(\"$super\");\n   }\n-  \n+\n   @Override\n   public boolean isExported(String name) {\n     return isExported(name, false) || isExported(name, true);\n       Node callNode) {\n     return null;\n   }\n+\n+  @Override\n+  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n+    return Collections.emptySet();\n+  }\n }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       return checks;\n     }\n \n-    if (options.checkSuspiciousCode) {\n+    if (options.checkSuspiciousCode ||\n+        options.checkGlobalThisLevel.isOn()) {\n       checks.add(suspiciousCode);\n     }\n \n     @Override\n     protected CompilerPass createInternal(final AbstractCompiler compiler) {\n       List<Callback> sharedCallbacks = Lists.newArrayList();\n-      sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));\n-      sharedCallbacks.add(new CheckSideEffects(CheckLevel.WARNING));\n-      if (options.checkGlobalThisLevel.isOn()) {\n+      if (options.checkSuspiciousCode) {\n+        sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));\n+        sharedCallbacks.add(new CheckSideEffects(CheckLevel.WARNING));\n+      }\n+\n+      CheckLevel checkGlobalThisLevel = options.checkGlobalThisLevel;\n+      if (checkGlobalThisLevel.isOn()) {\n         sharedCallbacks.add(\n-            new CheckGlobalThis(compiler, options.checkGlobalThisLevel));\n+            new CheckGlobalThis(compiler, checkGlobalThisLevel));\n       }\n       return combineChecks(compiler, sharedCallbacks);\n     }\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n import com.google.javascript.jscomp.deps.DependencyInfo;\n import com.google.javascript.jscomp.deps.SortedDependencies;\n \n+import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n *\n *\n  */\n-public class JSModule implements DependencyInfo {\n+public class JSModule implements DependencyInfo, Serializable {\n+  private static final long serialVersionUID = 1;\n+\n   /** Module name */\n   private final String name;\n \n   public void addDependency(JSModule dep) {\n     Preconditions.checkState(dep != this);\n     deps.add(dep);\n+  }\n+\n+  /** Removes an input from this module. */\n+  public void remove(CompilerInput input) {\n+    input.setModule(null);\n+    inputs.remove(input);\n   }\n \n   /** Removes all of the inputs from this module. */\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n             new UnrecognizedRequire(n, ns, t.getSourceName()));\n       } else {\n         JSModule module = t.getModule();\n-        if (module != provided.firstModule /* covers null case */ &&\n-            !compiler.getModuleGraph().dependsOn(module,\n+        if (moduleGraph != null &&\n+            module != provided.firstModule /* covers null case */ &&\n+            !moduleGraph.dependsOn(module,\n                 provided.firstModule)) {\n           compiler.report(\n               t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n     }\n \n     private void updateMinimumModule(JSModule newModule) {\n-      if (moduleGraph != null) {\n-        if (minimumModule == null) {\n-          minimumModule = newModule;\n-        } else {\n-          minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n-              minimumModule, newModule);\n-        }\n+      if (minimumModule == null) {\n+        minimumModule = newModule;\n+      } else if (moduleGraph != null) {\n+        minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n+            minimumModule, newModule);\n+      } else {\n+        // If there is no module graph, then there must be exactly one\n+        // module in the program.\n+        Preconditions.checkState(newModule == minimumModule,\n+                                 \"Missing module graph\");\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n+++ b/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n     implements CompilerPass {\n   private final Compiler compiler;\n   private final FunctionNames functionNames;\n+  private final JSModuleGraph moduleGraph;\n \n   /**\n    * Protocol buffer builder.\n   RecordFunctionInformation(Compiler compiler,\n       FunctionNames functionNames) {\n     this.compiler = compiler;\n+    this.moduleGraph = compiler.getModuleGraph();\n     this.functionNames = functionNames;\n     this.mapBuilder = FunctionInformationMap.newBuilder();\n   }\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n \n-    JSModuleGraph graph = compiler.getModuleGraph();\n-    if (graph == null) {\n+    if (moduleGraph == null) {\n       addModuleInformation(null);\n     } else {\n       // The test expects a consistent module order.\n             public int compare(JSModule o1, JSModule o2) {\n               return o1.getName().compareTo(o2.getName());\n             }\n-          }, graph.getAllModules())) {\n+          }, moduleGraph.getAllModules())) {\n         addModuleInformation(m);\n       }\n     }\n       .setId(id)\n       .setSourceName(t.getSourceName())\n       .setLineNumber(n.getLineno())\n-      .setModuleName(module == null ? \"\" : module.getName())\n+      .setModuleName(moduleGraph == null ? \"\" : module.getName())\n       .setSize(compiledSource.length())\n       .setName(functionNames.getFunctionName(n))\n       .setCompiledSource(compiledSource).build());\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n /**\n       \"A function type with the template type as the type of this must be a \" +\n       \"parameter type\");\n \n-\n   private final AbstractCompiler compiler;\n   private final JSTypeRegistry registry;\n   private final ReverseAbstractInterpreter reverseInterpreter;\n   private final Scope syntacticScope;\n   private final FlowScope functionScope;\n   private final FlowScope bottomScope;\n+  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n \n   /**\n    * Local variables that do not belong to this scope, but are assigned\n \n   TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                 ReverseAbstractInterpreter reverseInterpreter,\n-                Scope functionScope) {\n+                Scope functionScope,\n+                Map<String, AssertionFunctionSpec> assertionFunctionsMap) {\n     this(compiler, cfg, reverseInterpreter, functionScope,\n-         ImmutableSet.<Var>of());\n+         assertionFunctionsMap, ImmutableSet.<Var>of());\n   }\n \n   /**\n    * @param unflowableVars Do not do infer flow on the types of these vars.\n+   * @param assertionFunctionsMap\n    */\n   // TODO(nicksantos): Create a builder for this class.\n   TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                 ReverseAbstractInterpreter reverseInterpreter,\n-                Scope functionScope, Collection<Var> unflowableVars) {\n+                Scope functionScope,\n+                Map<String, AssertionFunctionSpec> assertionFunctionsMap,\n+                Collection<Var> unflowableVars) {\n     super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n     this.compiler = compiler;\n     this.registry = compiler.getTypeRegistry();\n     this.reverseInterpreter = reverseInterpreter;\n     this.syntacticScope = functionScope;\n     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n+    this.assertionFunctionsMap = assertionFunctionsMap;\n \n     for (Var unflowableVar : unflowableVars) {\n       String name = unflowableVar.getName();\n         updateTypeOfThisOnClosure(n, fnType);\n       } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n         n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n+      }\n+    }\n+\n+    scope = tightenTypesAfterAssertions(scope, n);\n+    return scope;\n+  }\n+\n+  private FlowScope tightenTypesAfterAssertions(FlowScope scope,\n+      Node callNode) {\n+    Node left = callNode.getFirstChild();\n+    Node firstParam = left.getNext();\n+    AssertionFunctionSpec assertionFunctionSpec =\n+        assertionFunctionsMap.get(left.getQualifiedName());\n+    if (assertionFunctionSpec == null || firstParam == null) {\n+      return scope;\n+    }\n+    Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam);\n+    if (assertedNode == null) {\n+      return scope;\n+    }\n+    JSTypeNative assertedType = assertionFunctionSpec.getAssertedType();\n+    // Handle assertions that enforce expressions evaluate to true.\n+    if (assertedType == null) {\n+      switch (assertedNode.getType()) {\n+        case Token.NAME:\n+          JSType type = getJSType(assertedNode);\n+          JSType narrowed = type.restrictByNotNullOrUndefined();\n+          if (type != narrowed) {\n+            scope = scope.createChildFlowScope();\n+            redeclare(scope, assertedNode.getString(), narrowed);\n+          }\n+          break;\n+        case Token.AND:\n+        case Token.OR:\n+          BooleanOutcomePair conditionOutcomes =\n+              traverseWithinShortCircuitingBinOp(assertedNode, scope);\n+          scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n+              assertedNode, conditionOutcomes.getOutcomeFlowScope(\n+                  assertedNode.getType(), true), true);\n+          break;\n+      }\n+    } else if (assertedNode.getType() == Token.NAME) {\n+      // Handle assertions that enforce expressions are of a certain type.\n+      JSType type = getJSType(assertedNode);\n+      JSType narrowed = type.getGreatestSubtype(getNativeType(assertedType));\n+      if (type != narrowed) {\n+        scope = scope.createChildFlowScope();\n+        redeclare(scope, assertedNode.getString(), narrowed);\n       }\n     }\n     return scope;\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n \n import java.util.Collection;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * A compiler pass to run the type inference analysis.\n   private final ReverseAbstractInterpreter reverseInterpreter;\n   private Scope topScope;\n   private ScopeCreator scopeCreator;\n+  private final Map<String, AssertionFunctionSpec> assertionFunctionsMap;\n \n   /**\n    * Local variables that are declared in an outer scope, but are assigned in\n     this.reverseInterpreter = reverseInterpreter;\n     this.topScope = topScope;\n     this.scopeCreator = scopeCreator;\n+\n+    assertionFunctionsMap = Maps.newHashMap();\n+    for (AssertionFunctionSpec assertionFucntion :\n+        compiler.getCodingConvention().getAssertionFunctions()) {\n+      assertionFunctionsMap.put(assertionFucntion.getFunctionName(),\n+          assertionFucntion);\n+    }\n   }\n \n   /**\n     TypeInference typeInference =\n         new TypeInference(\n             compiler, computeCfg(n), reverseInterpreter, scope,\n-            getUnflowableVars(scope));\n+            assertionFunctionsMap, getUnflowableVars(scope));\n     try {\n       typeInference.analyze();\n       escapedLocalVars.putAll(typeInference.getAssignedOuterLocalVars());\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n   public void testDebugFlag1() {\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     args.add(\"--debug=false\");\n-    test(\"function foo(a) {}\", \n+    test(\"function foo(a) {}\",\n          \"function foo() {}\");\n   }\n \n     testSame(\"function f() {}\");\n   }\n \n-  public void testExternsLifting1() {\n-    test(new String[] {\"/** @externs */ function f() {}\"},\n+  public void testExternsLifting1() throws Exception{\n+    String code = \"/** @externs */ function f() {}\";\n+    test(new String[] {code},\n          new String[] {});\n+\n+    assertEquals(2, lastCompiler.getExternsForTesting().size());\n+\n+    CompilerInput extern = lastCompiler.getExternsForTesting().get(1);\n+    assertNull(extern.getModule());\n+    assertTrue(extern.isExtern());\n+    assertEquals(code, extern.getCode());\n+\n+    assertEquals(1, lastCompiler.getInputsForTesting().size());\n+\n+    CompilerInput input = lastCompiler.getInputsForTesting().get(0);\n+    assertNotNull(input.getModule());\n+    assertFalse(input.isExtern());\n+    assertEquals(\"\", input.getCode());\n   }\n \n   public void testExternsLifting2() {\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.ARRAY_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.BOOLEAN_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeNative.FUNCTION_INSTANCE_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NULL_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.NUMBER_TYPE;\n \n import com.google.common.base.Joiner;\n import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.EnumType;\n-import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n   private JSTypeRegistry registry;\n   private Map<String,JSType> assumptions;\n   private FlowScope returnScope;\n+  private static final Map<String, AssertionFunctionSpec>\n+      ASSERTION_FUNCTION_MAP = Maps.newHashMap();\n+  static {\n+    for (AssertionFunctionSpec func :\n+        new ClosureCodingConvention().getAssertionFunctions()) {\n+      ASSERTION_FUNCTION_MAP.put(func.getFunctionName(), func);\n+    }\n+  }\n \n   @Override\n   public void setUp() {\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n     // Create a simple reverse abstract interpreter.\n     ReverseAbstractInterpreter rai = new SemanticReverseAbstractInterpreter(\n-            compiler.getCodingConvention(), registry);\n+        compiler.getCodingConvention(), registry);\n     // Do the type inference by data-flow analysis.\n-    TypeInference dfa =\n-        new TypeInference(compiler, cfg, rai, assumedScope);\n+    TypeInference dfa = new TypeInference(compiler, cfg, rai, assumedScope,\n+        ASSERTION_FUNCTION_MAP);\n     dfa.analyze();\n     // Get the scope of the implicit return.\n     BranchedFlowState<FlowScope> rtnState =\n     assuming(\"x\", createNullableType(OBJECT_TYPE));\n     inFunction(\"var y = 1; if (x) { y = x; }\");\n     verify(\"y\", createUnionType(OBJECT_TYPE, NUMBER_TYPE));\n+  }\n+\n+  public void testAssert1() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assert(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", OBJECT_TYPE);\n+  }\n+\n+  public void testAssert2() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"goog.asserts.assert(1, x); out1 = x;\");\n+    verify(\"out1\", startType);\n+  }\n+\n+  public void testAssert3() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x\", startType);\n+    assuming(\"y\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assert(x && y); out2 = x; out3 = y;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", OBJECT_TYPE);\n+    verify(\"out3\", OBJECT_TYPE);\n+  }\n+\n+  public void testAssert4() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x\", startType);\n+    assuming(\"y\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assert(x && !y); out2 = x; out3 = y;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", OBJECT_TYPE);\n+    verify(\"out3\", NULL_TYPE);\n+  }\n+\n+  public void testAssert5() {\n+    JSType startType = createNullableType(OBJECT_TYPE);\n+    assuming(\"x\", startType);\n+    assuming(\"y\", startType);\n+    inFunction(\"goog.asserts.assert(x || y); out1 = x; out2 = y;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", startType);\n+  }\n+\n+  public void testAssertNumber() {\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertNumber(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", NUMBER_TYPE);\n+  }\n+\n+  public void testAssertNumber2() {\n+    // Make sure it ignores expressions.\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"goog.asserts.assertNumber(x + x); out1 = x;\");\n+    verify(\"out1\", startType);\n+  }\n+\n+  public void testAssertString() {\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertString(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", STRING_TYPE);\n+  }\n+\n+  public void testAssertFunction() {\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertFunction(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verifySubtypeOf(\"out2\", FUNCTION_INSTANCE_TYPE);\n+  }\n+\n+  public void testAssertObject() {\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertObject(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verifySubtypeOf(\"out2\", OBJECT_TYPE);\n+  }\n+\n+  public void testAssertObject2() {\n+    JSType startType = createNullableType(ARRAY_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertObject(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verify(\"out2\", ARRAY_TYPE);\n+  }\n+\n+  public void testAssertArray() {\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertArray(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verifySubtypeOf(\"out2\", ARRAY_TYPE);\n+  }\n+\n+  public void testAssertInstanceof() {\n+    JSType startType = createNullableType(ALL_TYPE);\n+    assuming(\"x\", startType);\n+    inFunction(\"out1 = x; goog.asserts.assertInstanceof(x); out2 = x;\");\n+    verify(\"out1\", startType);\n+    verifySubtypeOf(\"out2\", OBJECT_TYPE);\n   }\n \n   public void testReturn1() {", "timestamp": 1273102609, "metainfo": ""}