{"sha": "848ace840362a1f5558bec065cb40548ff66587a", "log": "Rename CompilerRunner -> CommandLineRunner. I'll also do this for JSCompilerRunner, but it will be a much bigger change. (Nick)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Maps;\n+import com.google.common.flags.DocLevel;\n+import com.google.common.flags.Flag;\n+import com.google.common.flags.FlagSpec;\n+import com.google.common.flags.Flags;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.TokenStream;\n+import com.google.protobuf.CodedOutputStream;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+\n+/**\n+ * Implementations of AbstractCommandLineRunner translate flags into Java\n+ * API calls on the Compiler. AbstractCompiler contains common flags and logic\n+ * to make that happen.\n+ *\n+ * This class may be extended and used to create other Java classes\n+ * that behave the same as running the Compiler from the command line. Example:\n+ *\n+ * <pre>\n+ * class MyCommandLineRunner extends\n+ *     AbstractCommandLineRunner<MyCompiler, MyOptions> {\n+ *   MyCommandLineRunner(String[] args) {\n+ *     super(args);\n+ *   }\n+ *\n+ *   &#064;Override\n+ *   protected MyOptions createOptions() {\n+ *     MyOptions options = new MyOptions();\n+ *     CompilerFlagTranslator.setOptionsFromFlags(options);\n+ *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n+ *     return options;\n+ *   }\n+ *\n+ *   &#064;Override\n+ *   protected MyCompiler createCompiler() {\n+ *     return new MyCompiler();\n+ *   }\n+ *\n+ *   public static void main(String[] args) {\n+ *     (new MyCommandLineRunner(args)).run();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+*\n+ */\n+abstract class AbstractCommandLineRunner<A extends Compiler,\n+    B extends CompilerOptions> {\n+\n+  @FlagSpec(help = \"Prints out the parse tree and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n+\n+  @FlagSpec(help = \"Runs the compile job many times, then prints out the \" +\n+      \"best phase ordering from this run\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_compute_phase_ordering =\n+      Flag.value(false);\n+\n+  @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n+      + \" tree and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n+\n+  @FlagSpec(help = \"Prints a dot file describing the passes that will get run\"\n+      + \" and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_pass_graph = Flag.value(false);\n+\n+  @FlagSpec(help = \"Turns on extra sanity checks\", altName = \"dev_mode\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n+      Flag.value(CompilerOptions.DevMode.OFF);\n+\n+  // TODO(nicksantos): Make the next 2 flags package-private.\n+  @FlagSpec(help = \"The logging level (standard java.util.logging.Level\"\n+      + \" values) for Compiler progress. Does not control errors or\"\n+      + \" warnings for the JavaScript code under compilation\",\n+      docLevel = DocLevel.SECRET)\n+  public static final Flag<String> FLAG_logging_level =\n+      Flag.value(Level.WARNING.getName());\n+\n+  @FlagSpec(help = \"The file containing javascript externs. You may specify\"\n+      + \" multiple\")\n+  public static final Flag<List<String>> FLAG_externs = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"The javascript filename. You may specify multiple\")\n+  static final Flag<List<String>> FLAG_js = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Primary output filename. If not specified, output is \" +\n+            \"written to stdout\")\n+  static final Flag<String> FLAG_js_output_file = Flag.value(\"\");\n+\n+  @FlagSpec(help = \"A javascript module specification. The format is \"\n+      + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n+      + \"unique. Each dep is the name of a module that this module \"\n+      + \"depends on. Modules must be listed in dependency order, and js \"\n+      + \"source files must be listed in the corresponding order. Where \"\n+      + \"--module flags occur in relation to --js flags is unimportant\")\n+  static final Flag<List<String>> FLAG_module = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"File containing the serialized version of the variable \"\n+      + \"renaming map produced by a previous compilation\")\n+  static final Flag<String> FLAG_variable_map_input_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"File containing the serialized version of the property \"\n+      + \"renaming map produced by a previous compilation\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<String> FLAG_property_map_input_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"File where the serialized version of the variable \"\n+      + \"renaming map produced should be saved\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<String> FLAG_variable_map_output_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"If true, variable renaming and property renaming map \"\n+      + \"files will be produced as {binary name}_vars_map.out and \"\n+      + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n+      + \"in conjunction with either variable_map_output_file or \"\n+      + \"property_map_output_file\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_create_name_map_files =\n+      Flag.value(false);\n+\n+  @FlagSpec(help = \"File where the serialized version of the property \"\n+      + \"renaming map produced should be saved\")\n+  static final Flag<String> FLAG_property_map_output_file =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Check source validity but do not enforce Closure style \"\n+      + \"rules and conventions\")\n+  static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n+\n+\n+  @FlagSpec(help = \"Controls how detailed the compilation summary is. Values:\"\n+      + \" 0 (never print summary), 1 (print summary only if there are \"\n+      + \"errors or warnings), 2 (print summary if type checking is on, \"\n+      + \"see --check_types), 3 (always print summary). The default level \"\n+      + \"is 1\")\n+  static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);\n+\n+  @FlagSpec(help = \"Interpolate output into this string at the place denoted\"\n+      + \" by the marker token %output%. See --output_wrapper_marker\")\n+  static final Flag<String> FLAG_output_wrapper = Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Use this token as output marker in the value of\"\n+      + \" --output_wrapper\")\n+  static final Flag<String> FLAG_output_wrapper_marker =\n+      Flag.value(\"%output%\");\n+\n+  @FlagSpec(help = \"An output wrapper for a javascript module (optional). \"\n+      + \"The format is <name>:<wrapper>. The module name must correspond \"\n+      + \"with a module specified using --module. The wrapper must \"\n+      + \"contain %s as the code placeholder\")\n+  static final Flag<List<String>> FLAG_module_wrapper =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Prefix for filenames of compiled js modules. \"\n+      + \"<module-name>.js will be appended to this prefix. Directories \"\n+      + \"will be created as needed. Use with --module\")\n+  static final Flag<String> FLAG_module_output_path_prefix =\n+      Flag.value(\"./\");\n+\n+  @FlagSpec(help = \"If specified, a source map file mapping the generated \" +\n+            \"source files back to the original source file will be \" +\n+            \"output to the specified path. The %outname% placeholder will \" +\n+            \"expand to the name of the output file that the source map \" +\n+            \"corresponds to.\")\n+  static final Flag<String> FLAG_create_source_map =\n+      Flag.value(\"\");\n+\n+  @FlagSpec(help = \"Make the named class of warnings an error. Options:\" +\n+      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+  static final Flag<List<String>> FLAG_jscomp_error =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Make the named class of warnings a normal warning. \" +\n+                \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+  static final Flag<List<String>> FLAG_jscomp_warning =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Turn off the named class of warnings. Options:\" +\n+      DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n+  static final Flag<List<String>> FLAG_jscomp_off =\n+      Flag.stringCollector();\n+\n+  @FlagSpec(altName = \"D\",\n+      help = \"Override the value of a variable annotated @define. \" +\n+      \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n+      \"variable and <val> is a boolean, number, or a single-quoted string \" +\n+      \"that contains no single quotes. If [=<val>] is omitted, \" +\n+      \"the variable is marked true\")\n+  static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n+\n+  @FlagSpec(help = \"Input charset for all files.\")\n+  static final Flag<String> FLAG_charset = Flag.value(\"\");\n+\n+  private PrintStream out;\n+  private final PrintStream err;\n+  private A compiler;\n+\n+  private static Charset inputCharset;\n+\n+  // Bookkeeping to measure optimal phase orderings.\n+  private static final int NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER = 100;\n+\n+  private final RunTimeStats runTimeStats = new RunTimeStats();\n+\n+  AbstractCommandLineRunner(String[] args) {\n+    this(args, System.out, System.err);\n+  }\n+\n+  AbstractCommandLineRunner(String[] args, PrintStream out,\n+      PrintStream err) {\n+    // Flags are read when a compiler is instantiated, so we parse them first.\n+    Flags.parse(args);\n+\n+    this.out = out;\n+    this.err = err;\n+  }\n+\n+  /**\n+   * Returns the instance of the Compiler to use when {@link #run()} is\n+   * called.\n+   */\n+  protected abstract A createCompiler();\n+\n+  /**\n+   * Returns the instance of the Options to use when {@link #run()} is called.\n+   * createCompiler() is called before createOptions(), so getCompiler()\n+   * will not return null when createOptions() is called.\n+   */\n+  protected abstract B createOptions();\n+\n+  protected DiagnosticGroups getDiagnoticGroups() {\n+    return new DiagnosticGroups();\n+  }\n+\n+  protected void initOptionsFromFlags(CompilerOptions options) {\n+\n+    DiagnosticGroups diagnosticGroups = getDiagnoticGroups();\n+\n+    diagnosticGroups.setWarningLevels(\n+        options, AbstractCommandLineRunner.FLAG_jscomp_error.get(),\n+        CheckLevel.ERROR);\n+    diagnosticGroups.setWarningLevels(\n+        options, AbstractCommandLineRunner.FLAG_jscomp_warning.get(),\n+        CheckLevel.WARNING);\n+    diagnosticGroups.setWarningLevels(\n+        options, AbstractCommandLineRunner.FLAG_jscomp_off.get(),\n+        CheckLevel.OFF);\n+\n+    createDefineReplacements(FLAG_define.get(), options);\n+  }\n+\n+  final protected A getCompiler() {\n+    return compiler;\n+  }\n+\n+  final protected void setRunOptions(B options)\n+      throws IOException, FlagUsageException {\n+    if (FLAG_js_output_file.get().length() > 0) {\n+      options.jsOutputFile = FLAG_js_output_file.get();\n+    }\n+\n+    if (FLAG_create_source_map.get().length() > 0) {\n+      options.sourceMapOutputPath = FLAG_create_source_map.get();\n+    }\n+\n+    if (!FLAG_variable_map_input_file.get().equals(\"\")) {\n+      options.inputVariableMapSerialized =\n+          VariableMap.load(FLAG_variable_map_input_file.get()).toBytes();\n+    }\n+\n+    if (!FLAG_property_map_input_file.get().equals(\"\")) {\n+      options.inputPropertyMapSerialized =\n+          VariableMap.load(FLAG_property_map_input_file.get()).toBytes();\n+    }\n+\n+    if (FLAG_third_party.get()) {\n+      options.setCodingConvention(new DefaultCodingConvention());\n+    }\n+\n+    inputCharset = getInputCharset();\n+  }\n+\n+  /**\n+   * Runs the Compiler and calls System.exit() with the exit status of the\n+   * compiler.\n+   */\n+  final public void run() {\n+    int result = 0;\n+    int runs = 1;\n+    if (FLAG_compute_phase_ordering.get()) {\n+      runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\n+      PhaseOptimizer.randomizeLoops();\n+    }\n+    try {\n+      for (int i = 0; i < runs && result == 0; i++) {\n+        runTimeStats.recordStartRun();\n+        result = doRun();\n+        runTimeStats.recordEndRun();\n+      }\n+    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n+      System.err.println(e.getMessage());\n+      result = -1;\n+    } catch (Throwable t) {\n+      t.printStackTrace();\n+      result = -2;\n+    }\n+    if (FLAG_compute_phase_ordering.get()) {\n+      runTimeStats.outputBestPhaseOrdering();\n+    }\n+    System.exit(result);\n+  }\n+\n+  /**\n+   * Returns the PrintStream for writing errors associated with this\n+   * AbstractCommandLineRunner.\n+   */\n+  protected PrintStream getErrorPrintStream() {\n+    return err;\n+  }\n+\n+  /**\n+   * An exception thrown when command-line flags are used incorrectly.\n+   */\n+  protected static class FlagUsageException extends Exception {\n+    private static final long serialVersionUID = 1L;\n+\n+    FlagUsageException(String message) {\n+      super(message);\n+    }\n+  }\n+\n+  /**\n+   * Creates inputs from a list of files.\n+   *\n+   * @param files A list of filenames\n+   * @param allowStdIn Whether '-' is allowed appear as a filename to represent\n+   *        stdin. If true, '-' is only allowed to appear once.\n+   * @return An array of inputs\n+   */\n+  private static List<JSSourceFile> createInputs(List<String> files,\n+      boolean allowStdIn) throws FlagUsageException, IOException {\n+    List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size());\n+    boolean usingStdin = false;\n+    for (String filename : files) {\n+      if (!\"-\".equals(filename)) {\n+        JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset);\n+        inputs.add(newFile);\n+      } else {\n+        if (!allowStdIn) {\n+          throw new FlagUsageException(\"Can't specify stdin.\");\n+        }\n+        if (usingStdin) {\n+          throw new FlagUsageException(\"Can't specify stdin twice.\");\n+        }\n+\n+        inputs.add(JSSourceFile.fromInputStream(\"stdin\", System.in));\n+        usingStdin = true;\n+      }\n+    }\n+    return inputs;\n+  }\n+\n+  /**\n+   * Creates js source code inputs from a list of files.\n+   */\n+  private static List<JSSourceFile> createSourceInputs(List<String> files)\n+      throws FlagUsageException, IOException {\n+    if (files.isEmpty()) {\n+      files = Collections.singletonList(\"-\");\n+    }\n+    try {\n+      return createInputs(files, true);\n+    } catch (FlagUsageException e) {\n+      throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Creates js extern inputs from a list of files.\n+   */\n+  private static List<JSSourceFile> createExternInputs(List<String> files)\n+      throws FlagUsageException, IOException {\n+    if (files.isEmpty()) {\n+      return ImmutableList.of(JSSourceFile.fromCode(\"/dev/null\", \"\"));\n+    }\n+    try {\n+      return createInputs(files, false);\n+    } catch (FlagUsageException e) {\n+      throw new FlagUsageException(\"Bad --externs flag. \" + e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Creates module objects from a list of module specifications.\n+   *\n+   * @param specs A list of module specifications, not null or empty. The spec\n+   *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module\n+   *        names must not contain the ':' character.\n+   * @param jsFiles A list of js file paths, not null\n+   * @return An array of module objects\n+   */\n+  static JSModule[] createJsModules(List<String> specs, List<String> jsFiles)\n+      throws FlagUsageException, IOException {\n+    Preconditions.checkState(specs != null);\n+    Preconditions.checkState(!specs.isEmpty());\n+    Preconditions.checkState(jsFiles != null);\n+\n+    final int totalNumJsFiles = jsFiles.size();\n+    int nextJsFileIndex = 0;\n+\n+    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n+    for (String spec : specs) {\n+\n+      // Format is \"<name>:<num-js-files>[:[<dep>,...][:]]\".\n+      String[] parts = spec.split(\":\");\n+      if (parts.length < 2 || parts.length > 4) {\n+        throw new FlagUsageException(\"Expected 2-4 colon-delimited parts in \"\n+            + \"module spec: \" + spec);\n+      }\n+\n+      // Parse module name.\n+      String name = parts[0];\n+      if (!TokenStream.isJSIdentifier(name)) {\n+        throw new FlagUsageException(\"Invalid module name: '\" + name + \"'\");\n+      }\n+      if (modulesByName.containsKey(name)) {\n+        throw new FlagUsageException(\"Duplicate module name: \" + name);\n+      }\n+      JSModule module = new JSModule(name);\n+\n+      // Parse module inputs.\n+      int numJsFiles = -1;\n+      try {\n+        numJsFiles = Integer.parseInt(parts[1]);\n+      } catch (NumberFormatException ignored) {\n+        numJsFiles = -1;\n+      }\n+      if (numJsFiles < 1) {\n+        throw new FlagUsageException(\"Invalid js file count '\" + parts[1]\n+            + \"' for module: \" + name);\n+      }\n+      if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {\n+        throw new FlagUsageException(\"Not enough js files specified. Expected \"\n+            + (nextJsFileIndex + numJsFiles - totalNumJsFiles)\n+            + \" more in module:\" + name);\n+      }\n+      List<String> moduleJsFiles =\n+          jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);\n+      for (JSSourceFile input : createInputs(moduleJsFiles, false)) {\n+        module.add(input);\n+      }\n+      nextJsFileIndex += numJsFiles;\n+\n+      if (parts.length > 2) {\n+        // Parse module dependencies.\n+        String depList = parts[2];\n+        if (depList.length() > 0) {\n+          String[] deps = depList.split(\",\");\n+          for (String dep : deps) {\n+            JSModule other = modulesByName.get(dep);\n+            if (other == null) {\n+              throw new FlagUsageException(\"Module '\" + name\n+                  + \"' depends on unknown module '\" + dep\n+                  + \"'. Be sure to list modules in dependency order.\");\n+            }\n+            module.addDependency(other);\n+          }\n+        }\n+      }\n+\n+      modulesByName.put(name, module);\n+    }\n+\n+    if (nextJsFileIndex < totalNumJsFiles) {\n+      throw new FlagUsageException(\"Too many js files specified. Expected \"\n+          + nextJsFileIndex + \" but found \" + totalNumJsFiles);\n+    }\n+\n+    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);\n+  }\n+\n+  /**\n+   * Parses module wrapper specifications.\n+   *\n+   * @param specs A list of module wrapper specifications, not null. The spec\n+   *        format is: <code>name:wrapper</code>. Wrappers.\n+   * @param modules The JS modules whose wrappers are specified\n+   * @return A map from module name to module wrapper. Modules with no wrapper\n+   *         will have the empty string as their value in this map.\n+   */\n+  static Map<String, String> parseModuleWrappers(List<String> specs,\n+      JSModule[] modules) throws FlagUsageException {\n+    Preconditions.checkState(specs != null);\n+\n+    Map<String, String> wrappers =\n+        Maps.newHashMapWithExpectedSize(modules.length);\n+\n+    // Prepopulate the map with module names.\n+    for (JSModule m : modules) {\n+      wrappers.put(m.getName(), \"\");\n+    }\n+\n+    for (String spec : specs) {\n+\n+      // Format is \"<name>:<wrapper>\".\n+      int pos = spec.indexOf(':');\n+      if (pos == -1) {\n+        throw new FlagUsageException(\"Expected module wrapper to have \"\n+            + \"<name>:<wrapper> format: \" + spec);\n+      }\n+\n+      // Parse module name.\n+      String name = spec.substring(0, pos);\n+      if (!wrappers.containsKey(name)) {\n+        throw new FlagUsageException(\"Unknown module: '\" + name + \"'\");\n+      }\n+      String wrapper = spec.substring(pos + 1);\n+      if (!wrapper.contains(\"%s\")) {\n+        throw new FlagUsageException(\"No %s placeholder in module wrapper: '\"\n+            + wrapper + \"'\");\n+      }\n+      wrappers.put(name, wrapper);\n+    }\n+    return wrappers;\n+  }\n+\n+  /**\n+   * Writes code to an output stream, optionally wrapping it in an arbitrary\n+   * wrapper that contains a placeholder where the code should be inserted.\n+   */\n+  static void writeOutput(PrintStream out, Compiler compiler, String code,\n+      String wrapper, String codePlaceholder) {\n+    int pos = wrapper.indexOf(codePlaceholder);\n+    if (pos != -1) {\n+      String prefix = \"\";\n+\n+      if (pos > 0) {\n+        prefix = wrapper.substring(0, pos);\n+        out.print(prefix);\n+      }\n+\n+      out.print(code);\n+\n+      int suffixStart = pos + codePlaceholder.length();\n+      if (suffixStart == wrapper.length()) {\n+        // Nothing after placeholder?\n+        // Make sure we always end output with a line feed.\n+        out.println();\n+      } else {\n+        out.println(wrapper.substring(suffixStart));\n+      }\n+\n+      // If we have a source map, adjust its offsets to match\n+      // the code WITHIN the wrapper.\n+      if (compiler != null && compiler.getSourceMap() != null) {\n+        compiler.getSourceMap().setWrapperPrefix(prefix);\n+      }\n+\n+    } else {\n+      out.println(code);\n+    }\n+  }\n+\n+  /**\n+   * Creates any directories necessary to write a file that will have a given\n+   * path prefix.\n+   */\n+  private static void maybeCreateDirsForPath(String pathPrefix) {\n+    if (pathPrefix.length() > 0) {\n+      String dirName =\n+          pathPrefix.charAt(pathPrefix.length() - 1) == File.separatorChar\n+              ? pathPrefix.substring(0, pathPrefix.length() - 1) : new File(\n+                  pathPrefix).getParent();\n+      if (dirName != null) {\n+        new File(dirName).mkdirs();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Parses command-line arguments and runs the compiler.\n+   *\n+   * @return system exit status\n+   */\n+  protected int doRun() throws FlagUsageException, IOException {\n+    Compiler.setLoggingLevel(Level.parse(FLAG_logging_level.get()));\n+\n+    List<JSSourceFile> externsList = createExterns();\n+    JSSourceFile[] externs = new JSSourceFile[externsList.size()];\n+    externsList.toArray(externs);\n+\n+    compiler = createCompiler();\n+    B options = createOptions();\n+\n+    JSModule[] modules = null;\n+    Result result;\n+\n+    setRunOptions(options);\n+\n+    // Let the outputCharset be the same as the input charset... except if\n+    // we're reading in UTF-8 by default.  By tradition, we've always\n+    // output ASCII to avoid various hiccups with different browsers,\n+    // proxies and firewalls.\n+    if (inputCharset == Charsets.UTF_8) {\n+      options.outputCharset = Charsets.US_ASCII;\n+    } else {\n+      options.outputCharset = inputCharset;\n+    }\n+\n+    if (!options.jsOutputFile.isEmpty()) {\n+      out = new PrintStream(options.jsOutputFile, inputCharset.name());\n+    }\n+\n+    ((PrintStreamErrorManager) compiler.getErrorManager())\n+        .setSummaryDetailLevel(FLAG_summary_detail_level.get());\n+\n+    List<String> jsFiles = FLAG_js.get();\n+    List<String> moduleSpecs = FLAG_module.get();\n+    if (!moduleSpecs.isEmpty()) {\n+      modules = createJsModules(moduleSpecs, jsFiles);\n+      result = compiler.compile(externs, modules, options);\n+    } else {\n+      List<JSSourceFile> inputList = createSourceInputs(jsFiles);\n+      JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\n+      inputList.toArray(inputs);\n+      result = compiler.compile(externs, inputs, options);\n+    }\n+\n+    return processResults(result, modules, options);\n+  }\n+\n+  /**\n+   * Processes the results of the compile job, and returns an error code.\n+   */\n+  int processResults(Result result, JSModule[] modules, B options)\n+       throws FlagUsageException, IOException {\n+    if (FLAG_compute_phase_ordering.get()) {\n+      return 0;\n+    }\n+\n+    if (FLAG_print_pass_graph.get()) {\n+      if (compiler.getRoot() == null) {\n+        return 1;\n+      } else {\n+        out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n+        out.println();\n+        return 0;\n+      }\n+    }\n+\n+    if (FLAG_print_ast.get()) {\n+      if (compiler.getRoot() == null) {\n+        return 1;\n+      } else {\n+        ControlFlowGraph<Node> cfg = compiler.computeCFG();\n+        DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n+        out.println();\n+        return 0;\n+      }\n+    }\n+\n+    if (FLAG_print_tree.get()) {\n+      if (compiler.getRoot() == null) {\n+        out.println(\"Code contains errors; no tree was generated.\");\n+        return 1;\n+      } else {\n+        compiler.getRoot().appendStringTree(out);\n+        out.println(\"\");\n+        return 0;\n+      }\n+    }\n+\n+    if (result.success) {\n+      if (modules == null) {\n+        writeOutput(out, compiler, compiler.toSource(), FLAG_output_wrapper\n+            .get(), FLAG_output_wrapper_marker.get());\n+\n+        // Output the source map if requested.\n+        outputSourceMap(options, options.jsOutputFile);\n+      } else {\n+        String moduleFilePrefix = FLAG_module_output_path_prefix.get();\n+        maybeCreateDirsForPath(moduleFilePrefix);\n+        Map<String, String> moduleWrappers =\n+            parseModuleWrappers(FLAG_module_wrapper.get(), modules);\n+\n+        // If the source map path is in fact a pattern for each\n+        // module, create a stream per-module. Otherwise, create\n+        // a single source map.\n+        PrintStream mapOut = null;\n+\n+        if (!shouldGenerateMapPerModule(options)) {\n+          mapOut = openSourceMapStream(options, moduleFilePrefix);\n+        }\n+\n+        for (JSModule m : modules) {\n+          if (shouldGenerateMapPerModule(options)) {\n+            mapOut = openSourceMapStream(\n+                options, moduleFilePrefix + m.getName() + \".js\");\n+          }\n+\n+          PrintStream ps =\n+              new PrintStream(new FileOutputStream(moduleFilePrefix\n+                  + m.getName() + \".js\"));\n+\n+          if (options.sourceMapOutputPath != null) {\n+            compiler.getSourceMap().reset();\n+          }\n+\n+          writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(\n+              m.getName()), \"%s\");\n+\n+          if (options.sourceMapOutputPath != null) {\n+            compiler.getSourceMap().appendTo(mapOut, m.getName());\n+          }\n+\n+          ps.close();\n+\n+          if (shouldGenerateMapPerModule(options) && mapOut != null) {\n+            mapOut.close();\n+            mapOut = null;\n+          }\n+        }\n+\n+        if (mapOut != null) {\n+          mapOut.close();\n+        }\n+      }\n+\n+      // Output the externs if required.\n+      if (options.externExportsPath != null) {\n+        PrintStream eeOut =\n+            openExternExportsStream(options, options.jsOutputFile);\n+        eeOut.append(result.externExport);\n+        eeOut.close();\n+      }\n+\n+      // Output the variable and property name maps if requested.\n+      outputNameMaps(options);\n+    }\n+\n+    // return 0 if no errors, the error count otherwise\n+    return Math.min(result.errors.length, 0x7f);\n+  }\n+\n+  /**\n+   * Query the flag for the charset, and return a Charset object representing\n+   * the selection.  Keep this in a separate function\n+   * so it can be called both in static and normal methods.\n+   *\n+   * @return Charset to use when reading inputs\n+   * @throws FlagUsageException if flag is not a valid Charset name.\n+   */\n+  private static Charset getInputCharset() throws FlagUsageException {\n+    if (!FLAG_charset.get().isEmpty()) {\n+      if (!Charset.isSupported(FLAG_charset.get())) {\n+        throw new FlagUsageException(FLAG_charset.get() +\n+            \" is not a valid charset name.\");\n+      }\n+      return Charset.forName(FLAG_charset.get());\n+    }\n+    return Charsets.UTF_8;\n+  }\n+\n+  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n+      IOException {\n+    return createExternInputs(FLAG_externs.get());\n+  }\n+\n+  /**\n+   * Returns true if and only if a source map file should be generated for each\n+   * module, as opposed to one unified map. This is specified by having the\n+   * source map pattern include the %outname% variable.\n+   */\n+  private boolean shouldGenerateMapPerModule(B options) {\n+    return options.sourceMapOutputPath != null\n+        && options.sourceMapOutputPath.contains(\"%outname%\");\n+  }\n+\n+  /**\n+   * Returns a stream for outputting the generated externs file.\n+   *\n+   * @param options The options to the Compiler.\n+   * @param path The path of the generated JS source file.\n+   *\n+   * @return The stream or null if no extern-ed exports are being generated.\n+   */\n+  private PrintStream openExternExportsStream(B options,\n+      String path) throws IOException {\n+    if (options.externExportsPath == null) {\n+      return null;\n+    }\n+\n+    String exPath = options.externExportsPath;\n+\n+    if (!exPath.contains(File.separator)) {\n+      File outputFile = new File(path);\n+      exPath = outputFile.getParent() + File.separatorChar + exPath;\n+    }\n+\n+    return new PrintStream(new FileOutputStream(exPath));\n+  }\n+\n+  /**\n+   * Returns a stream to give to an instance of the SourceMap class to which it\n+   * can append the source map. If no source mapping was specified in the\n+   * options, this method returns null.\n+   *\n+   * @param options The options to the Compiler.\n+   * @param path The directory or a file in the directory in which to place the\n+   *        source map.\n+   */\n+  private PrintStream openSourceMapStream(B options, String path)\n+      throws IOException {\n+    if (options.sourceMapOutputPath == null) {\n+      return null;\n+    }\n+\n+    String sourceMapPath = options.sourceMapOutputPath;\n+    sourceMapPath = sourceMapPath.replace(\"%outname%\", path);\n+\n+    String mapPath = null;\n+\n+    if (sourceMapPath.contains(\"/\") || sourceMapPath.contains(\"\\\\\")) {\n+      mapPath = sourceMapPath;\n+    } else {\n+      File outputFile = new File(path);\n+      mapPath = outputFile.getParent() + File.separatorChar + sourceMapPath;\n+    }\n+\n+    return new PrintStream(new FileOutputStream(mapPath));\n+  }\n+\n+  /**\n+   * Outputs the source map found in the compiler to the proper path if one\n+   * exists.\n+   *\n+   * @param options The options to the Compiler.\n+   * @param path The path of the generated file for which the source map was\n+   *        created.\n+   */\n+  private void outputSourceMap(B options, String path)\n+      throws IOException {\n+    if (options.sourceMapOutputPath == null) {\n+      return;\n+    }\n+\n+    File outputFile = new File(path);\n+    PrintStream out = openSourceMapStream(options, path);\n+    compiler.getSourceMap().appendTo(out, outputFile.getName());\n+    out.close();\n+  }\n+\n+  /**\n+   * Returns the path at which to output map file(s) based on the path at which\n+   * the JS binary will be placed.\n+   *\n+   * @return The path in which to place the generated map file(s).\n+   */\n+  private static String getMapPath(String outputFile) {\n+    String basePath = \"\";\n+\n+    if (outputFile.equals(\"\")) {\n+      // If we have a js_module_binary rule, output the maps\n+      // at modulename_props_map.out, etc.\n+      if (!FLAG_module_output_path_prefix.get().equals(\"\")) {\n+        basePath = FLAG_module_output_path_prefix.get();\n+      } else {\n+        basePath = \"jscompiler\";\n+      }\n+    } else {\n+      // Get the path of the output file.\n+      File file = new File(outputFile);\n+\n+      String outputFileName = file.getName();\n+\n+      // Strip the .js from the name.\n+      if (outputFileName.endsWith(\".js\")) {\n+        outputFileName =\n+            outputFileName.substring(0, outputFileName.length() - 3);\n+      }\n+\n+      basePath = file.getParent() + File.separatorChar + outputFileName;\n+    }\n+\n+    return basePath;\n+  }\n+\n+  /**\n+   * Outputs the variable and property name maps for the specified compiler if\n+   * the proper FLAGS are set.\n+   */\n+  private void outputNameMaps(B options) throws FlagUsageException,\n+      IOException {\n+\n+    String propertyMapOutputPath = null;\n+    String variableMapOutputPath = null;\n+    String functionInformationMapOutputPath = null;\n+\n+    // Check the create_name_map_files FLAG.\n+    if (FLAG_create_name_map_files.get()) {\n+      String basePath = getMapPath(options.jsOutputFile);\n+\n+      propertyMapOutputPath = basePath + \"_props_map.out\";\n+      variableMapOutputPath = basePath + \"_vars_map.out\";\n+      functionInformationMapOutputPath = basePath + \"_functions_map.out\";\n+    }\n+\n+    // Check the individual FLAGS.\n+    if (!FLAG_variable_map_output_file.get().equals(\"\")) {\n+      if (variableMapOutputPath != null) {\n+        throw new FlagUsageException(\"The flags variable_map_output_file and \"\n+            + \"create_name_map_files cannot both be used simultaniously.\");\n+      }\n+\n+      variableMapOutputPath = FLAG_variable_map_output_file.get();\n+    }\n+\n+    if (!FLAG_property_map_output_file.get().equals(\"\")) {\n+      if (propertyMapOutputPath != null) {\n+        throw new FlagUsageException(\"The flags property_map_output_file and \"\n+            + \"create_name_map_files cannot both be used simultaniously.\");\n+      }\n+\n+      propertyMapOutputPath = FLAG_property_map_output_file.get();\n+    }\n+\n+    // Output the maps.\n+    if (variableMapOutputPath != null) {\n+      if (compiler.getVariableMap() != null) {\n+        compiler.getVariableMap().save(variableMapOutputPath);\n+      }\n+    }\n+\n+    if (propertyMapOutputPath != null) {\n+      if (compiler.getPropertyMap() != null) {\n+        compiler.getPropertyMap().save(propertyMapOutputPath);\n+      }\n+    }\n+\n+    if (functionInformationMapOutputPath != null) {\n+      if (compiler.getFunctionalInformationMap() != null) {\n+        FileOutputStream file =\n+            new FileOutputStream(functionInformationMapOutputPath);\n+        CodedOutputStream outputStream = CodedOutputStream.newInstance(file);\n+        compiler.getFunctionalInformationMap().writeTo(outputStream);\n+        outputStream.flush();\n+        file.flush();\n+        file.close();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Create a map of constant names to constant values from a textual\n+   * description of the map.\n+   *\n+   * @param definitions A list of overriding definitions for defines in\n+   *     the form <name>[=<val>], where <val> is a number, boolean, or\n+   *     single-quoted string without single quotes.\n+   */\n+  @VisibleForTesting\n+  static void createDefineReplacements(List<String> definitions,\n+      CompilerOptions options) {\n+    // Parse the definitions\n+    for (String override : definitions) {\n+      String[] assignment = override.split(\"=\", 2);\n+      String defName = assignment[0];\n+\n+      if (defName.length() > 0) {\n+        if (assignment.length == 1) {\n+          options.setDefineToBooleanLiteral(defName, true);\n+          continue;\n+        } else {\n+          String defValue = assignment[1];\n+\n+          if (defValue.equals(\"true\")) {\n+            options.setDefineToBooleanLiteral(defName, true);\n+            continue;\n+          } else if (defValue.equals(\"false\")) {\n+            options.setDefineToBooleanLiteral(defName, false);\n+            continue;\n+          } else if (defValue.length() > 1 &&\n+              defValue.charAt(0) == '\\'' &&\n+              defValue.charAt(defValue.length() - 1) == '\\'') {\n+            // If the value starts and ends with a single quote,\n+            // we assume that it's a string.\n+            String maybeStringVal =\n+                defValue.substring(1, defValue.length() - 1);\n+            if (maybeStringVal.indexOf('\\'') == -1) {\n+              options.setDefineToStringLiteral(defName, maybeStringVal);\n+              continue;\n+            }\n+          } else {\n+            try {\n+              options.setDefineToDoubleLiteral(defName,\n+                  Double.parseDouble(defValue));\n+              continue;\n+            } catch (NumberFormatException e) {\n+              // do nothing, it will be caught at the end\n+            }\n+          }\n+        }\n+      }\n+\n+      throw new RuntimeException(\n+          \"--define flag syntax invalid: \" + override);\n+    }\n+  }\n+\n+  private class RunTimeStats {\n+    private long bestRunTime = Long.MAX_VALUE;\n+    private long worstRunTime = Long.MIN_VALUE;\n+    private long lastStartTime = 0;\n+    private List<List<String>> loopedPassesInBestRun = null;\n+\n+    /**\n+     * Record the start of a run.\n+     */\n+    private void recordStartRun() {\n+      lastStartTime = System.currentTimeMillis();\n+      PhaseOptimizer.clearLoopsRun();\n+    }\n+\n+    /**\n+     * Record the end of a run.\n+     */\n+    private void recordEndRun() {\n+      long endTime = System.currentTimeMillis();\n+      long length = endTime - lastStartTime;\n+      worstRunTime = Math.max(length, worstRunTime);\n+      if (length < bestRunTime) {\n+        loopedPassesInBestRun = PhaseOptimizer.getLoopsRun();\n+        bestRunTime = length;\n+      }\n+    }\n+\n+    /**\n+     * Print the best phase loop to stderr.\n+     */\n+    private void outputBestPhaseOrdering() {\n+      out.println(\"Best time: \" + bestRunTime);\n+      out.println(\"Worst time: \" + worstRunTime);\n+\n+      int i = 1;\n+      for (List<String> loop : loopedPassesInBestRun) {\n+        out.println(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop));\n+        i++;\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.flags.Flag;\n+import com.google.common.flags.FlagSpec;\n+import com.google.common.io.LimitInputStream;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipInputStream;\n+\n+/**\n+ * CommandLineRunner translates flags into Java API calls on the Compiler.\n+ *\n+ * This class may be extended and used to create other Java classes\n+ * that behave the same as running the Compiler from the command line. If you\n+ * want to run the compiler in-process in Java, you should look at this class\n+ * for hints on what API calls to make, but you should not use this class directly.\n+ *\n+ * Example:\n+ * <pre>\n+ * class MyCommandLineRunner extends CommandLineRunner {\n+ *   MyCommandLineRunner(String[] args) { super(args); }\n+ *\n+ *   {@code @Override} protected CompilerOptions createOptions() {\n+ *     CompilerOptions options = super.createOptions();\n+ *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n+ *     return options;\n+ *   }\n+ *\n+ *   public static void main(String[] args) {\n+ *     (new MyCommandLineRunner(args)).run();\n+ *   }\n+ * }\n+ * </pre>\n+*\n+ */\n+class CommandLineRunner extends\n+    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n+\n+  @FlagSpec(help = \"Specifies the compilation level to use. Options: \" +\n+            \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n+  static final Flag<CompilationLevel> FLAG_compilation_level\n+      = Flag.value(CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+\n+  @FlagSpec(help = \"Specifies the warning level to use. Options: \" +\n+            \"QUIET, DEFAULT, VERBOSE\")\n+  static final Flag<WarningLevel> FLAG_warning_level\n+      = Flag.value(WarningLevel.DEFAULT);\n+\n+  @FlagSpec(help = \"Specifies whether the default externs should be excluded\")\n+  static final Flag<Boolean> FLAG_use_only_custom_externs\n+      = Flag.value(false);\n+\n+  @FlagSpec(help = \"Enable debugging options\")\n+  static final Flag<Boolean> FLAG_debug = Flag.value(false);\n+\n+  /**\n+   * Set of options that can be used with the --formatting flag.\n+   */\n+  private static enum FormattingOption {\n+    PRETTY_PRINT,\n+    PRINT_INPUT_DELIMITER,\n+    ;\n+\n+    private void applyToOptions(CompilerOptions options) {\n+      switch (this) {\n+        case PRETTY_PRINT:\n+          options.prettyPrint = true;\n+          break;\n+        case PRINT_INPUT_DELIMITER:\n+          options.printInputDelimiter = true;\n+          break;\n+        default:\n+          throw new RuntimeException(\"Unknown formatting option: \" + this);\n+      }\n+    }\n+  }\n+\n+  @FlagSpec(help = \"Specifies which formatting options, if any, should be \"\n+      + \"applied to the output JS. Options: \"\n+      + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\")\n+  static final Flag<List<FormattingOption>> FLAG_formatting\n+      = Flag.enumList(FormattingOption.class);\n+\n+  @FlagSpec(help = \"Processes built-ins from the Closure library, such as \"\n+      + \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n+  static final Flag<Boolean> FLAG_process_closure_primitives\n+      = Flag.value(true);\n+\n+  CommandLineRunner(String[] args) {\n+    super(args);\n+  }\n+\n+  CommandLineRunner(String[] args, PrintStream out, PrintStream err) {\n+    super(args, out, err);\n+  }\n+\n+  @Override\n+  protected CompilerOptions createOptions() {\n+    CompilerOptions options = new CompilerOptions();\n+    options.setCodingConvention(new ClosureCodingConvention());\n+    CompilationLevel level = FLAG_compilation_level.get();\n+    level.setOptionsForCompilationLevel(options);\n+    if (FLAG_debug.get()) {\n+      level.setDebugOptionsForCompilationLevel(options);\n+    }\n+\n+    WarningLevel wLevel = FLAG_warning_level.get();\n+    wLevel.setOptionsForWarningLevel(options);\n+    for (FormattingOption formattingOption : FLAG_formatting.get()) {\n+      formattingOption.applyToOptions(options);\n+    }\n+    if (FLAG_process_closure_primitives.get()) {\n+      options.closurePass = true;\n+    }\n+\n+    initOptionsFromFlags(options);\n+    return options;\n+  }\n+\n+  @Override\n+  protected Compiler createCompiler() {\n+    return new Compiler(getErrorPrintStream());\n+  }\n+\n+  @Override\n+  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n+      IOException {\n+    List<JSSourceFile> externs = super.createExterns();\n+    if (!FLAG_use_only_custom_externs.get()) {\n+      List<JSSourceFile> defaultExterns = getDefaultExterns();\n+      defaultExterns.addAll(externs);\n+      return defaultExterns;\n+    } else {\n+      return externs;\n+    }\n+  }\n+\n+  /**\n+   * @return a mutable list\n+   * @throws IOException\n+   */\n+  private List<JSSourceFile> getDefaultExterns() throws IOException {\n+    InputStream input = CommandLineRunner.class.getResourceAsStream(\n+        \"/externs.zip\");\n+    ZipInputStream zip = new ZipInputStream(input);\n+    List<JSSourceFile> externs = Lists.newLinkedList();\n+    for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) {\n+      LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize());\n+      externs.add(JSSourceFile.fromInputStream(entry.getName(), entryStream));\n+    }\n+    return externs;\n+  }\n+\n+  /**\n+   * Runs the Compiler. Exits cleanly in the event of an error.\n+   */\n+  public static void main(String[] args) {\n+    (new CommandLineRunner(args)).run();\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n \n /**\n  * This class implements a simple Ant task to do almost the same as\n- * CompilerRunner.\n+ * CommandLineRunner.\n  *\n  * Most of the public methods of this class are entry points for the\n  * Ant code to hook into.\n   /**\n    * Gets the default externs set.\n    *\n-   * Adapted from {@link CompilerRunner}.\n+   * Adapted from {@link CommandLineRunner}.\n    */\n   private List<JSSourceFile> getDefaultExterns() {\n     try {\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.flags.Flags;\n+import com.google.javascript.rhino.Node;\n+\n+import junit.framework.TestCase;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Tests for {@link CommandLineRunner}.\n+ *\n+*\n+ */\n+public class CommandLineRunnerTest extends TestCase {\n+\n+  private Compiler lastCompiler = null;\n+\n+  // If set to true, uses comparison by string instead of by AST.\n+  private boolean useStringComparison = false;\n+\n+  /** Externs for the test */\n+  private final JSSourceFile[] externs = new JSSourceFile[] {\n+    JSSourceFile.fromCode(\"externs\",\n+        \"var arguments;\" +\n+        \"/** @constructor \\n * @param {...*} var_args \\n \" +\n+        \"* @return {!Array} */ \" +\n+        \"function Array(var_args) {}\\n\"\n+        + \"/** @constructor */ function Window() {}\\n\"\n+        + \"/** @type {string} */ Window.prototype.name;\\n\"\n+        + \"/** @type {Window} */ var window;\"\n+        + \"/** @nosideeffects */ function noSideEffects() {}\")\n+  };\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    Flags.disableStateCheckingForTest();\n+    Flags.resetAllFlagsForTest();\n+    lastCompiler = null;\n+    useStringComparison = false;\n+  }\n+\n+  @Override\n+  public void tearDown() throws Exception {\n+    Flags.resetAllFlagsForTest();\n+\n+    // NOTE(nicksantos): ANT needs this for some weird reason.\n+    AbstractCommandLineRunner.FLAG_define.resetForTest();\n+    AbstractCommandLineRunner.FLAG_jscomp_off.resetForTest();\n+    AbstractCommandLineRunner.FLAG_jscomp_warning.resetForTest();\n+    AbstractCommandLineRunner.FLAG_jscomp_error.resetForTest();\n+\n+    Flags.enableStateCheckingForTest();\n+    super.tearDown();\n+  }\n+\n+  public void testTypeCheckingOffByDefault() {\n+    test(\"function f(x) { return x; } f();\",\n+         \"function f(a) { return a; } f();\");\n+  }\n+\n+  public void testTypeCheckingOnWithVerbose() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    test(\"function f(x) { return x; } f();\", TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n+  public void testTypeCheckOverride1() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    CommandLineRunner.FLAG_jscomp_off.setForTest(\n+        Lists.newArrayList(\"checkTypes\"));\n+    testSame(\"var x = x || {}; x.f = function() {}; x.f(3);\");\n+  }\n+\n+  public void testTypeCheckOverride2() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n+    testSame(\"var x = x || {}; x.f = function() {}; x.f(3);\");\n+\n+    CommandLineRunner.FLAG_jscomp_warning.setForTest(\n+        Lists.newArrayList(\"checkTypes\"));\n+    test(\"var x = x || {}; x.f = function() {}; x.f(3);\",\n+         TypeCheck.WRONG_ARGUMENT_COUNT);\n+  }\n+\n+  public void testCheckSymbolsOffForDefault() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n+    test(\"x = 3; var y; var y;\", \"x=3; var y;\");\n+  }\n+\n+  public void testCheckSymbolsOnForVerbose() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR);\n+    test(\"var y; var y;\", SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR);\n+  }\n+\n+  public void testCheckSymbolsOverrideForVerbose() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    AbstractCommandLineRunner.FLAG_jscomp_off.setForTest(\n+        Lists.newArrayList(\"undefinedVars\"));\n+    testSame(\"x = 3;\");\n+  }\n+\n+  public void testCheckUndefinedProperties() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.VERBOSE);\n+    AbstractCommandLineRunner.FLAG_jscomp_error.setForTest(\n+        Lists.newArrayList(\"missingProperties\"));\n+    test(\"var x = {}; var y = x.bar;\", TypeCheck.INEXISTENT_PROPERTY);\n+  }\n+\n+  public void testDuplicateParams() {\n+    test(\"function (a, a) {}\", RhinoErrorReporter.DUPLICATE_PARAM);\n+    assertTrue(lastCompiler.hasHaltingErrors());\n+  }\n+\n+  public void testDefineFlag() {\n+    AbstractCommandLineRunner.FLAG_define.setForTest(\n+        Lists.newArrayList(\"FOO\", \"BAR=5\"));\n+    test(\"/** @define {boolean} */ var FOO = false;\" +\n+         \"/** @define {number} */ var BAR = 3;\",\n+         \"var FOO = true, BAR = 5;\");\n+  }\n+\n+  public void testScriptStrictModeNoWarning() {\n+    test(\"'use strict';\", \"\");\n+    test(\"'no use strict';\", CheckSideEffects.USELESS_CODE_ERROR);\n+  }\n+\n+  public void testFunctionStrictModeNoWarning() {\n+    test(\"function f() {'use strict';}\", \"function f() {}\");\n+    test(\"function f() {'no use strict';}\",\n+         CheckSideEffects.USELESS_CODE_ERROR);\n+  }\n+\n+  public void testQuietMode() {\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.DEFAULT);\n+    test(\"/** @type { not a type name } */ var x;\",\n+         RhinoErrorReporter.PARSE_ERROR);\n+    CommandLineRunner.FLAG_warning_level.setForTest(WarningLevel.QUIET);\n+    testSame(\"/** @type { not a type name } */ var x;\");\n+  }\n+\n+  //////////////////////////////////////////////////////////////////////////////\n+  // Integration tests\n+\n+  public void testIssue70() {\n+    test(\"function foo({}) {}\", RhinoErrorReporter.PARSE_ERROR);\n+  }\n+\n+  public void testIssue81() {\n+    CommandLineRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    useStringComparison = true;\n+    test(\"eval('1'); var x = eval; x('2');\",\n+         \"eval(\\\"1\\\");(0,eval)(\\\"2\\\");\");\n+  }\n+\n+  public void testIssue115() {\n+    CommandLineRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+    CommandLineRunner.FLAG_warning_level.setForTest(\n+        WarningLevel.VERBOSE);\n+    test(\"function f() { \" +\n+         \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n+         \"  return arguments[0]; \" +\n+         \"}\",\n+         \"function f() { \" +\n+         \"  arguments = Array.prototype.slice.call(arguments, 0);\" +\n+         \"  return arguments[0]; \" +\n+         \"}\");\n+  }\n+\n+  public void testDebugFlag1() {\n+    CommandLineRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+    CommandLineRunner.FLAG_debug.setForTest(false);\n+    testSame(\"function foo(a) {}\");\n+  }\n+\n+  public void testDebugFlag2() {\n+    CommandLineRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n+    CommandLineRunner.FLAG_debug.setForTest(true);\n+    test(\"function foo(a) {}\",\n+         \"function foo($a$$) {}\");\n+  }\n+\n+  public void testDebugFlag3() {\n+    CommandLineRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    CommandLineRunner.FLAG_warning_level.setForTest(\n+        WarningLevel.QUIET);\n+    CommandLineRunner.FLAG_debug.setForTest(false);\n+    test(\"function Foo() {};\" +\n+         \"Foo.x = 1;\" +\n+         \"function f() {throw new Foo().x;} f();\",\n+         \"function a() {};\" +\n+         \"throw new a().a;\");\n+  }\n+\n+  public void testDebugFlag4() {\n+    CommandLineRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    CommandLineRunner.FLAG_warning_level.setForTest(\n+        WarningLevel.QUIET);\n+    CommandLineRunner.FLAG_debug.setForTest(true);\n+    test(\"function Foo() {};\" +\n+        \"Foo.x = 1;\" +\n+        \"function f() {throw new Foo().x;} f();\",\n+        \"function $Foo$$() {};\" +\n+        \"throw new $Foo$$().$x$;\");\n+  }\n+\n+  /* Helper functions */\n+\n+  private void testSame(String original) {\n+    testSame(new String[] { original });\n+  }\n+\n+  private void testSame(String[] original) {\n+    test(original, original);\n+  }\n+\n+  private void test(String original, String compiled) {\n+    test(new String[] { original }, new String[] { compiled });\n+  }\n+\n+  /**\n+   * Asserts that when compiling with the given compiler options,\n+   * {@code original} is transformed into {@code compiled}.\n+   */\n+  private void test(String[] original, String[] compiled) {\n+    Compiler compiler = compile(original);\n+    assertEquals(\"Expected no warnings or errors\\n\" +\n+        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n+        0, compiler.getErrors().length + compiler.getWarnings().length);\n+\n+    Node root = compiler.getRoot().getLastChild();\n+    if (useStringComparison) {\n+      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n+    } else {\n+      Node expectedRoot = parse(compiled);\n+      String explanation = expectedRoot.checkTreeEquals(root);\n+      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+          \"\\nResult: \" + compiler.toSource(root) +\n+          \"\\n\" + explanation, explanation);\n+    }\n+  }\n+\n+  /**\n+   * Asserts that when compiling, there is an error or warning.\n+   */\n+  private void test(String original, DiagnosticType warning) {\n+    test(new String[] { original }, warning);\n+  }\n+\n+  /**\n+   * Asserts that when compiling, there is an error or warning.\n+   */\n+  private void test(String[] original, DiagnosticType warning) {\n+    Compiler compiler = compile(original);\n+    assertEquals(\"Expected exactly one warning or error \" +\n+        \"Errors: \\n\" + Joiner.on(\"\\n\").join(compiler.getErrors()) +\n+        \"Warnings: \\n\" + Joiner.on(\"\\n\").join(compiler.getWarnings()),\n+        1, compiler.getErrors().length + compiler.getWarnings().length);\n+    if (compiler.getErrors().length > 0) {\n+      assertEquals(warning, compiler.getErrors()[0].getType());\n+    } else {\n+      assertEquals(warning, compiler.getWarnings()[0].getType());\n+    }\n+  }\n+\n+  private Compiler compile(String original) {\n+    return compile( new String[] { original });\n+  }\n+\n+  private Compiler compile(String[] original) {\n+    CommandLineRunner runner = new CommandLineRunner(new String[] {});\n+    Compiler compiler = runner.createCompiler();\n+    lastCompiler = compiler;\n+    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    for (int i = 0; i < original.length; i++) {\n+      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    }\n+    CompilerOptions options = runner.createOptions();\n+    try {\n+      runner.setRunOptions(options);\n+    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n+      fail(\"Unexpected exception \" + e);\n+    } catch (IOException e) {\n+      assert(false);\n+    }\n+    compiler.compile(\n+        externs, CompilerTestCase.createModuleChain(original), options);\n+    return compiler;\n+  }\n+\n+  private Node parse(String[] original) {\n+    CommandLineRunner runner = new CommandLineRunner(new String[] {});\n+    Compiler compiler = runner.createCompiler();\n+    JSSourceFile[] inputs = new JSSourceFile[original.length];\n+    for (int i = 0; i < inputs.length; i++) {\n+      inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n+    }\n+    compiler.init(externs, inputs, new CompilerOptions());\n+    Node all = compiler.parseInputs();\n+    Node n = all.getLastChild();\n+    return n;\n+  }\n+}", "timestamp": 1267236258, "metainfo": ""}