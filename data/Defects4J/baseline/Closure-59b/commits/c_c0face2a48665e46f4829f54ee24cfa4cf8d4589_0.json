{"sha": "c0face2a48665e46f4829f54ee24cfa4cf8d4589", "log": "Fix a bug in type inference when there are more than two inner functions in a local scope.  Add a --print_pass_graph flag that prints the passes run as a DOT file.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n       docLevel = DocLevel.SECRET)\n   static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n \n+  @FlagSpec(help = \"Prints a dot file describing the passes that will get run\"\n+      + \" and exits\",\n+      docLevel = DocLevel.SECRET)\n+  static final Flag<Boolean> FLAG_print_pass_graph = Flag.value(false);\n+\n   @FlagSpec(help = \"Turns on extra sanity checks\", altName = \"dev_mode\",\n       docLevel = DocLevel.SECRET)\n   static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n        throws FlagUsageException, IOException {\n     if (FLAG_compute_phase_ordering.get()) {\n       return 0;\n+    }\n+\n+    if (FLAG_print_pass_graph.get()) {\n+      if (compiler.getRoot() == null) {\n+        return 1;\n+      } else {\n+        out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n+        out.println();\n+        return 0;\n+      }\n     }\n \n     if (FLAG_print_ast.get()) {\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n package com.google.javascript.jscomp;\n \n \n+\n+import com.google.common.collect.Iterables;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.GraphvizGraph;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n \n import java.io.Serializable;\n import java.util.List;\n    * They should always run after checking passes.\n    */\n   abstract protected List<PassFactory> getOptimizations();\n+\n+  /**\n+   * Gets a graph of the passes run. For debugging.\n+   */\n+  GraphvizGraph getPassGraph() {\n+    LinkedDirectedGraph<String, String> graph = LinkedDirectedGraph.create();\n+    Iterable<PassFactory> allPasses =\n+        Iterables.concat(getChecks(), getOptimizations());\n+    String lastPass = null;\n+    String loopStart = null;\n+    for (PassFactory pass : allPasses) {\n+      String passName = pass.getName();\n+      int i = 1;\n+      while (graph.hasNode(passName)) {\n+        passName = pass.getName() + (i++);\n+      }\n+      graph.createNode(passName);\n+\n+      if (loopStart == null && !pass.isOneTimePass()) {\n+        loopStart = passName;\n+      } else if (loopStart != null && pass.isOneTimePass()) {\n+        graph.connect(lastPass, \"loop\", loopStart);\n+        loopStart = null;\n+      }\n+\n+      if (lastPass != null) {\n+        graph.connect(lastPass, \"\", passName);\n+      }\n+      lastPass = passName;\n+    }\n+    return graph;\n+  }\n \n   /**\n    * Create a type inference pass.\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n \n     for (Var unflowableVar : unflowableVars) {\n-      this.unflowableVarNames.add(unflowableVar.getName());\n+      String name = unflowableVar.getName();\n+      if (functionScope.getVar(name) == unflowableVar) {\n+        this.unflowableVarNames.add(name);\n+      }\n     }\n \n     Iterator<Var> varIt = functionScope.getVars();\n       return scope;\n     } else {\n       StaticSlot<JSType> var = scope.getSlot(varName);\n-      if (var != null) {\n+      if (var != null &&\n+          !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n         type = var.getType();\n         if (type == null) {\n           type = getNativeType(UNKNOWN_TYPE);\n--- a/src/com/google/javascript/jscomp/TypeInferencePass.java\n+++ b/src/com/google/javascript/jscomp/TypeInferencePass.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.Collection;\n+import java.util.List;\n \n /**\n  * A compiler pass to run the type inference analysis.\n     inferTypes.traverseWithScope(node, topScope);\n   }\n \n+  private Collection<Var> getUnflowableVars(Scope scope) {\n+    List<Var> vars = Lists.newArrayList();\n+    for (Scope current = scope;\n+         current.isLocal(); current = current.getParent()) {\n+      vars.addAll(escapedLocalVars.get(current));\n+    }\n+    return vars;\n+  }\n+\n   void inferTypes(NodeTraversal t, Node n, Scope scope) {\n     TypeInference typeInference =\n         new TypeInference(\n             compiler, computeCfg(n), reverseInterpreter, scope,\n-            escapedLocalVars.get(scope));\n+            getUnflowableVars(scope));\n     try {\n       typeInference.analyze();\n       escapedLocalVars.putAll(typeInference.getAssignedOuterLocalVars());\n--- a/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n+++ b/src/com/google/javascript/jscomp/graph/LinkedDirectedGraph.java\n     return new SimpleSubGraph<N, E>(this);\n   }\n \n+  public static <N, E> LinkedDirectedGraph<N, E> create() {\n+    return new LinkedDirectedGraph<N, E>();\n+  }\n+\n   @Override\n   public GraphEdge<N, E> connect(N srcValue, E edgeValue, N destValue) {\n     DiGraphNode<N, E> node = getDirectedGraphNode(srcValue);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"Function x: called with 1 argument(s). \" +\n         \"Function requires at least 0 argument(s) \" +\n         \"and no more than 0 argument(s).\");\n+  }\n+\n+  public void testInnerFunction9() throws Exception {\n+    testTypes(\n+        \"function f() {\" +\n+        \" var x = 3;\\n\" +\n+        \" function g() { x = null; };\\n\" +\n+        \" function h() { return x == null; }\" +\n+        \" return h();\" +\n+        \"}\");\n   }\n \n   public void testAbstractMethodHandling1() throws Exception {", "timestamp": 1265671522, "metainfo": ""}