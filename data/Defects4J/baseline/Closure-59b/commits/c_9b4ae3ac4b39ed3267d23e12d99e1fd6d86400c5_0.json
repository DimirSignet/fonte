{"sha": "9b4ae3ac4b39ed3267d23e12d99e1fd6d86400c5", "log": "Correct \"void\" operator side-effect detection.  R=bowdidge DELTA=17  (13 added, 1 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=54013   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       case Token.NULL:\n       case Token.TRUE:\n       case Token.FALSE:\n+        return true;\n       case Token.VOID:\n-        return true;\n       case Token.NEG:\n         return isImmutableValue(n.getFirstChild());\n       case Token.NAME:\n \n       case Token.VAR:    // empty var statement (no declaration)\n       case Token.NAME:   // variable by itself\n-        if (n.getFirstChild() != null)\n+        if (n.getFirstChild() != null) {\n           return true;\n-\n+        }\n         break;\n \n       case Token.FUNCTION:\n         return true;\n \n       default:\n-        if (isSimpleOperatorType(n.getType()))\n+        if (isSimpleOperatorType(n.getType())) {\n           break;\n+        }\n \n         if (isAssignmentOp(n)) {\n           // Assignments will have side effects if\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n     assertNotLiteral(getNode(\"foo()\"));\n     assertNotLiteral(getNode(\"c + d\"));\n     assertNotLiteral(getNode(\"{'a': foo()}\"));\n+    assertNotLiteral(getNode(\"void foo()\"));\n   }\n \n   public void assertLiteralAndImmutable(Node n) {\n     assertBooleanFalse(\"''\");\n     assertBooleanFalse(\"undefined\");\n     assertBooleanFalse(\"void 0\");\n+    assertBooleanFalse(\"void foo()\");\n     assertBooleanUnknown(\"b\");\n     assertBooleanUnknown(\"-'0.0'\");\n   }\n     assertEquals(\"\", NodeUtil.getStringValue(getNode(\"''\")));\n     assertEquals(\"undefined\", NodeUtil.getStringValue(getNode(\"undefined\")));\n     assertEquals(\"undefined\", NodeUtil.getStringValue(getNode(\"void 0\")));\n+    assertEquals(\"undefined\", NodeUtil.getStringValue(getNode(\"void foo()\")));\n   }\n \n   public void testGetFunctionName1() throws Exception {\n     assertSideEffect(true, \"a.foo = 4\");\n     assertSideEffect(true, \"(function() { return n; })().foo = 4\");\n     assertSideEffect(true, \"([]).foo = bar()\");\n+\n+    assertSideEffect(false, \"undefined\");\n+    assertSideEffect(false, \"void 0\");\n+    assertSideEffect(true, \"void foo()\");\n+    assertSideEffect(false, \"-Infinity\");\n+    assertSideEffect(false, \"Infinity\");\n+    assertSideEffect(false, \"NaN\");\n   }\n \n   public void testRegExpSideEffect() {\n     assertSideEffect(true, \"''.foo('a')\", true);\n     assertSideEffect(true, \"''.foo('a')\", false);\n \n-    // 'a' might be a RegExp object with the 'g' flag, in which case \n+    // 'a' might be a RegExp object with the 'g' flag, in which case\n     // the state might change by running any of the string ops.\n     // Specifically, using these methods resets the \"lastIndex\" if used\n     // in combination with a RegExp instance \"exec\" method.\n     assertMutableState(true, \"i=3\");\n     assertMutableState(true, \"[0, i=3]\");\n     assertMutableState(true, \"b()\");\n+    assertMutableState(true, \"void b()\");\n     assertMutableState(true, \"[1, b()]\");\n     assertMutableState(true, \"b.b=4\");\n     assertMutableState(true, \"b.b--\");\n \n   public void testGetNodeTypeReferenceCount() {\n     assertEquals(0, NodeUtil.getNodeTypeReferenceCount(\n-        parse(\"function foo(){}\"), Token.THIS, \n+        parse(\"function foo(){}\"), Token.THIS,\n             Predicates.<Node>alwaysTrue()));\n     assertEquals(1, NodeUtil.getNodeTypeReferenceCount(\n-        parse(\"this\"), Token.THIS, \n+        parse(\"this\"), Token.THIS,\n             Predicates.<Node>alwaysTrue()));\n     assertEquals(2, NodeUtil.getNodeTypeReferenceCount(\n         parse(\"this;function foo(){}(this)\"), Token.THIS,", "timestamp": 1279649497, "metainfo": ""}