{"sha": "cf96848764f0b01a57bd9daa512903a1f0b1c00a", "log": "Add a flag for defining entry points that we won't remove in manage_closure_dependencies mode. Fixes issue 187  R=acleung DELTA=232  (199 added, 15 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=285838   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     createDefineReplacements(config.define, options);\n \n     options.manageClosureDependencies = config.manageClosureDependencies;\n+    if (config.closureEntryPoints.size() > 0) {\n+      options.setManageClosureDependencies(config.closureEntryPoints);\n+    }\n     options.devMode = config.jscompDevMode;\n     options.setCodingConvention(config.codingConvention);\n     options.setSummaryDetailLevel(config.summaryDetailLevel);\n       return this;\n     }\n \n+    private List<String> closureEntryPoints = ImmutableList.of();\n+\n+    /**\n+     * Set closure entry points, which makes the compiler only include\n+     * those files and sort them in dependency order.\n+     */\n+    CommandLineConfig setClosureEntryPoints(List<String> entryPoints) {\n+      Preconditions.checkNotNull(entryPoints);\n+      this.closureEntryPoints = entryPoints;\n+      return this;\n+    }\n+\n     private String outputManifest = \"\";\n \n     /**\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n         + \"be included in the compilation.\")\n     private boolean manage_closure_dependencies = false;\n \n+    @Option(name = \"--closure_entry_point\",\n+        usage = \"Entry points to the program. Must be goog.provide'd \"\n+        + \"symbols. Any goog.provide'd symbols that are not a transitive \"\n+        + \"dependency of the entry points will be removed. Files without \"\n+        + \"goog.provides, and their dependencies, will always be left in. \"\n+        + \"If any entry points are specified, then the \"\n+        + \"manage_closure_dependencies option will be set to true and \"\n+        + \"all files will be sorted in dependency order.\")\n+    private List<String> closure_entry_point = Lists.newArrayList();\n+\n     @Option(name = \"--output_manifest\",\n         usage = \"Prints out a list of all the files in the compilation. \"\n         + \"If --manage_closure_dependencies is on, this will not include \"\n           .setDefine(flags.define)\n           .setCharset(flags.charset)\n           .setManageClosureDependencies(flags.manage_closure_dependencies)\n+          .setClosureEntryPoints(flags.closure_entry_point)\n           .setOutputManifest(flags.output_manifest);\n     }\n   }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n+import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n  *\n  */\n public class Compiler extends AbstractCompiler {\n+\n+  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n+      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n+          \"Bad dependency: {0} -> {1}. \"\n+              + \"Modules must be listed in dependency order.\");\n+\n+  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n+      \"JSC_MISSING_ENTRY_ERROR\",\n+      \"required entry point \\\"{0}\\\" never provided\");\n+\n   CompilerOptions options = null;\n \n   private PassConfig passes = null;\n \n     initModules(externs, Lists.newArrayList(module), options);\n   }\n-\n-  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n-      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n-          \"Bad dependency: {0} -> {1}. \"\n-              + \"Modules must be listed in dependency order.\");\n \n   /**\n    * Initializes the instance state needed for a compile job if the sources\n         try {\n           inputs =\n               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n-              .manageDependencies(inputs);\n+              .manageDependencies(\n+                  options.manageClosureDependenciesEntryPoints, inputs);\n         } catch (CircularDependencyException e) {\n           report(JSError.make(\n               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+          return null;\n+        } catch (MissingProvideException e) {\n+          report(JSError.make(\n+              MISSING_ENTRY_ERROR, e.getMessage()));\n           return null;\n         }\n       }\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n   //--------------------------------\n \n   boolean manageClosureDependencies = false;\n+  List<String> manageClosureDependenciesEntryPoints = ImmutableList.of();\n \n   /** Returns localized replacement for MSG_* variables */\n   // Transient so that clients don't have to implement Serializable.\n   }\n \n   /**\n+   * Sort inputs by their goog.provide/goog.require calls.\n+   *\n+   * @param entryPoints Entry points to the program. Must be goog.provide'd\n+   *     symbols. Any goog.provide'd symbols that are not a transitive\n+   *     dependency of the entry points will be deleted.\n+   *     Files without goog.provides, and their dependencies,\n+   *     will always be left in.\n+   */\n+  public void setManageClosureDependencies(List<String> entryPoints) {\n+    Preconditions.checkNotNull(entryPoints);\n+    manageClosureDependencies = true;\n+    manageClosureDependenciesEntryPoints = entryPoints;\n+  }\n+\n+  /**\n    * Controls how detailed the compilation summary is. Values:\n    *  0 (never print summary), 1 (print summary only if there are\n    * errors or warnings), 2 (print summary if type checking is on,\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.deps.SortedDependencies;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n+import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n \n import java.util.ArrayList;\n import java.util.Collection;\n    * a symbol that is not required until a later module, then that\n    * file will be moved to the later module.\n    *\n+   * @param entryPoints The entry points into the program.\n+   *     Expressed as JS symbols.\n    * @param inputs The original list of sources. Used to ensure that the sort\n    *     is stable.\n    * @return The sorted list of sources.\n-   */\n-  List<CompilerInput> manageDependencies(List<CompilerInput> inputs)\n-      throws CircularDependencyException {\n+   * @throws CircularDependencyException if there is a circular dependency\n+   *     between the provides and requires.\n+   * @throws MissingProvideException if an entry point was not provided\n+   *     by any of the inputs.\n+   */\n+  List<CompilerInput> manageDependencies(\n+      List<String> entryPoints,\n+      List<CompilerInput> inputs)\n+      throws CircularDependencyException, MissingProvideException {\n     SortedDependencies<CompilerInput> sorter =\n         new SortedDependencies<CompilerInput>(inputs);\n-    List<CompilerInput> inputsWithoutProvides =\n-        sorter.getInputsWithoutProvides();\n+    Set<CompilerInput> entryPointInputs =\n+        Sets.newLinkedHashSet(sorter.getInputsWithoutProvides());\n+    for (String entryPoint : entryPoints) {\n+      entryPointInputs.add(sorter.getInputProviding(entryPoint));\n+    }\n \n     // The order of inputs, sorted independently of modules.\n     List<CompilerInput> absoluteOrder = sorter.getSortedDependenciesOf(inputs);\n \n     // Figure out which sources *must* be in each module.\n-    ListMultimap<JSModule, CompilerInput> inputsWithoutProvidesPerModule =\n+    ListMultimap<JSModule, CompilerInput> entryPointInputsPerModule =\n         LinkedListMultimap.create();\n-    for (CompilerInput input : inputsWithoutProvides) {\n+    for (CompilerInput input : entryPointInputs) {\n       JSModule module = input.getModule();\n       Preconditions.checkNotNull(module);\n-      inputsWithoutProvidesPerModule.put(module, input);\n+      entryPointInputsPerModule.put(module, input);\n     }\n \n     // Clear the modules of their inputs. This also nulls out\n \n     // Figure out which sources *must* be in each module, or in one\n     // of that module's dependencies.\n-    for (JSModule module : inputsWithoutProvidesPerModule.keySet()) {\n+    for (JSModule module : entryPointInputsPerModule.keySet()) {\n       List<CompilerInput> transitiveClosure =\n           sorter.getSortedDependenciesOf(\n-              inputsWithoutProvidesPerModule.get(module));\n+              entryPointInputsPerModule.get(module));\n       for (CompilerInput input : transitiveClosure) {\n         JSModule oldModule = input.getModule();\n-        input.setModule(\n-            oldModule == null ?\n-                module :\n-                getDeepestCommonDependencyInclusive(oldModule, module));\n+        if (oldModule == null) {\n+          input.setModule(module);\n+        } else {\n+          input.setModule(null);\n+          input.setModule(\n+              getDeepestCommonDependencyInclusive(oldModule, module));\n+        }\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n       throw new CircularDependencyException(\n           cycleToString(findCycle(subGraph, deps)));\n     }\n+  }\n+\n+  /**\n+   * Return the input that gives us the given symbol.\n+   * @throws MissingProvideException An exception if there is no\n+   *     input for this symbol.\n+   */\n+  public INPUT getInputProviding(String symbol)\n+      throws MissingProvideException {\n+    if (provideMap.containsKey(symbol)) {\n+      return provideMap.get(symbol);\n+    }\n+    throw new MissingProvideException(symbol);\n   }\n \n   /**\n       super(message);\n     }\n   }\n+\n+  public static class MissingProvideException extends Exception {\n+    MissingProvideException(String provide) {\n+      super(provide);\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n          JSModule.CIRCULAR_DEPENDENCY_ERROR);\n   }\n \n-  public void testSourcePruningOn() {\n+  public void testSourcePruningOn1() {\n     args.add(\"--manage_closure_dependencies=true\");\n     test(new String[] {\n           \"goog.require('beer');\",\n            \"\"\n          });\n   }\n+\n+  public void testSourcePruningOn2() {\n+    args.add(\"--closure_entry_point=guinness\");\n+    test(new String[] {\n+          \"goog.provide('guinness');\\ngoog.require('beer');\",\n+          \"goog.provide('beer');\",\n+          \"goog.provide('scotch'); var x = 3;\"\n+         },\n+         new String[] {\n+           \"var beer = {};\",\n+           \"var guinness = {};\"\n+         });\n+  }\n+\n+  public void testSourcePruningOn3() {\n+    args.add(\"--closure_entry_point=scotch\");\n+    test(new String[] {\n+          \"goog.provide('guinness');\\ngoog.require('beer');\",\n+          \"goog.provide('beer');\",\n+          \"goog.provide('scotch'); var x = 3;\"\n+         },\n+         new String[] {\n+           \"var scotch = {}, x = 3;\",\n+         });\n+  }\n+\n+  public void testSourcePruningOn4() {\n+    args.add(\"--closure_entry_point=scotch\");\n+    args.add(\"--closure_entry_point=beer\");\n+    test(new String[] {\n+          \"goog.provide('guinness');\\ngoog.require('beer');\",\n+          \"goog.provide('beer');\",\n+          \"goog.provide('scotch'); var x = 3;\"\n+         },\n+         new String[] {\n+           \"var beer = {};\",\n+           \"var scotch = {}, x = 3;\",\n+         });\n+  }\n+\n+  public void testSourcePruningOn5() {\n+    args.add(\"--closure_entry_point=shiraz\");\n+    test(new String[] {\n+          \"goog.provide('guinness');\\ngoog.require('beer');\",\n+          \"goog.provide('beer');\",\n+          \"goog.provide('scotch'); var x = 3;\"\n+         },\n+         Compiler.MISSING_ENTRY_ERROR);\n+  }\n+\n+  public void testSourcePruningOn6() {\n+    args.add(\"--closure_entry_point=scotch\");\n+    test(new String[] {\n+          \"goog.require('beer');\",\n+          \"goog.provide('beer');\",\n+          \"goog.provide('scotch'); var x = 3;\"\n+         },\n+         new String[] {\n+           \"var beer = {};\",\n+           \"\",\n+           \"var scotch = {}, x = 3;\",\n+         });\n+  }\n+\n \n   public void testForwardDeclareDroppedTypes() {\n     args.add(\"--manage_closure_dependencies=true\");\n--- a/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleGraphTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n \n     assertEquals(\"d.js\", E.getInputs().get(0).getName());\n   }\n \n-  public void testManageDependencies() throws Exception {\n+  public void testManageDependencies1() throws Exception {\n+    List<CompilerInput> inputs = setUpManageDependenciesTest();\n+    List<CompilerInput> results = graph.manageDependencies(\n+        ImmutableList.<String>of(), inputs);\n+\n+    assertInputs(A, \"a1\", \"a3\");\n+    assertInputs(B, \"a2\", \"b2\");\n+    assertInputs(C); // no inputs\n+    assertInputs(E, \"c1\", \"e1\", \"e2\");\n+\n+    assertEquals(\n+        Lists.newArrayList(\"a1\", \"a3\", \"a2\", \"b2\", \"c1\", \"e1\", \"e2\"),\n+        sourceNames(results));\n+  }\n+\n+  public void testManageDependencies2() throws Exception {\n+    List<CompilerInput> inputs = setUpManageDependenciesTest();\n+    List<CompilerInput> results = graph.manageDependencies(\n+        ImmutableList.<String>of(\"c2\"), inputs);\n+\n+    assertInputs(A, \"a1\", \"a3\");\n+    assertInputs(B, \"a2\", \"b2\");\n+    assertInputs(C, \"c1\", \"c2\");\n+    assertInputs(E, \"e1\", \"e2\");\n+\n+    assertEquals(\n+        Lists.newArrayList(\"a1\", \"a3\", \"a2\", \"b2\", \"c1\", \"c2\", \"e1\", \"e2\"),\n+        sourceNames(results));\n+  }\n+\n+  private List<CompilerInput> setUpManageDependenciesTest() {\n     List<CompilerInput> inputs = Lists.newArrayList();\n \n     A.add(code(\"a1\", provides(\"a1\"), requires()));\n     for (CompilerInput input : inputs) {\n       input.setCompiler(compiler);\n     }\n-\n-    List<CompilerInput> results = graph.manageDependencies(inputs);\n-\n-    assertInputs(A, \"a1\", \"a3\");\n-    assertInputs(B, \"a2\", \"b2\");\n-    assertInputs(C); // no inputs\n-    assertInputs(E, \"c1\", \"e1\", \"e2\");\n-\n-    assertEquals(\n-        Lists.newArrayList(\"a1\", \"a3\", \"a2\", \"b2\", \"c1\", \"e1\", \"e2\"),\n-        sourceNames(results));\n+    return inputs;\n   }\n \n   private void assertInputs(JSModule module, String ... sourceNames) {", "timestamp": 1286294181, "metainfo": ""}