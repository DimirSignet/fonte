{"sha": "1719697c9d6e1144c9f6aac2c0177b1a85ce95a6", "log": "Added ordinalIndexOf() and associated unit tests.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  * @author Gary Gregory\n  * @author Phil Steitz\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.107 2003/08/23 10:39:20 scolebourne Exp $\n+ * @version $Id: StringUtils.java,v 1.108 2003/09/04 18:18:18 ggregory Exp $\n  */\n public class StringUtils {\n     // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n     // Append:\n     // String.concat about twice as fast as StringBuffer.append\n     // (not sure who tested this)\n-    \n+\n     /**\n      * The empty String <code>\"\"</code>.\n      * @since 2.0\n      */\n     public static final String EMPTY = \"\";\n-    \n+\n+    /**\n+     * Represents a failed index search.\n+     * @since 2.?.?\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n     /**\n      * <p>The maximum size to which the padding constant(s) can expand.</p>\n      */\n      * <p>Used for efficient space padding. The length of each String expands as needed.</p>\n      */\n     private static final String[] PADDING = new String[Character.MAX_VALUE];\n-    \n+\n     static {\n         // space padding is most common, start with 64 chars\n         PADDING[32] = \"                                                                \";\n             return true;\n         }\n         for (int i = 0; i < strLen; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false) ) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                 return false;\n             }\n         }\n             return false;\n         }\n         for (int i = 0; i < strLen; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false) ) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                 return true;\n             }\n         }\n     public static String trimToEmpty(String str) {\n         return (str == null ? EMPTY : str.trim());\n     }\n-    \n+\n     // Stripping\n     //-----------------------------------------------------------------------\n     /**\n     public static String strip(String str) {\n         return strip(str, null);\n     }\n-    \n+\n     /** \n      * <p>Strips whitespace from the start and end of a String  returning\n      * <code>null</code> if the String is empty (\"\") after the strip.</p>\n     public static String stripToEmpty(String str) {\n         return (str == null ? EMPTY : strip(str, null));\n     }\n-    \n+\n     /**\n      * <p>Strips any of a set of characters from the start and end of a String.\n      * This is similar to {@link String#trim()} but allows the characters\n         if (str == null || (end = str.length()) == 0) {\n             return str;\n         }\n- \n+\n         if (stripChars == null) {\n             while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n                 end--;\n     public static String[] stripAll(String[] strs) {\n         return stripAll(strs, null);\n     }\n- \n+\n     /**\n      * <p>Strips any of a set of characters from the start and end of every\n      * String in an array.</p>\n             newArr[i] = strip(strs[i], stripChars);\n         }\n         return newArr;\n-    }   \n+    }\n \n     // Equals\n     //-----------------------------------------------------------------------\n         }\n         return str.indexOf(searchChar);\n     }\n-    \n+\n     /**\n      * <p>Finds the first index within a String from a start position,\n      * handling <code>null</code>.\n         }\n         return str.indexOf(searchChar, startPos);\n     }\n-    \n+\n     /**\n      * <p>Finds the first index within a String, handling <code>null</code>.\n      * This method uses {@link String#indexOf(String)}.</p>\n         }\n         return str.indexOf(searchStr);\n     }\n-    \n+\n+    /**\n+     * <p>Finds the n-th index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.ordinalIndexOf(null, *, *)          = -1\n+     * StringUtils.ordinalIndexOf(*, null, *)          = -1\n+     * StringUtils.ordinalIndexOf(\"\", \"\", *)           = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  = 2\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  = 5\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n+     * </pre>\n+     * \n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param ordinal  the n-th <code>searchStr</code> to find\n+     * @return the n-th index of the search String,\n+     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n+     * @since 2.?.?\n+     */\n+    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n+        if (str == null || searchStr == null || ordinal <= 0) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (searchStr.length() == 0) {\n+            return 0;\n+        }\n+        int found = 0;\n+        int index = INDEX_NOT_FOUND;\n+        do {\n+            index = str.indexOf(searchStr, index + 1);\n+            if (index < 0) {\n+                return index;\n+            }\n+            found++;\n+        } while (found < ordinal);\n+        return index;\n+    }\n+\n     /**\n      * <p>Finds the first index within a String, handling <code>null</code>.\n      * This method uses {@link String#indexOf(String, int)}.</p>\n         }\n         return str.indexOf(searchStr, startPos);\n     }\n-    \n+\n     // LastIndexOf\n     //-----------------------------------------------------------------------\n     /**\n         }\n         return str.lastIndexOf(searchChar);\n     }\n-    \n+\n     /**\n      * <p>Finds the last index within a String from a start position,\n      * handling <code>null</code>.\n         }\n         return str.lastIndexOf(searchChar, startPos);\n     }\n-    \n+\n     /**\n      * <p>Finds the last index within a String, handling <code>null</code>.\n      * This method uses {@link String#lastIndexOf(String)}.</p>\n         }\n         return str.lastIndexOf(searchStr);\n     }\n-    \n+\n     /**\n      * <p>Finds the first index within a String, handling <code>null</code>.\n      * This method uses {@link String#lastIndexOf(String, int)}.</p>\n         }\n         return str.lastIndexOf(searchStr, startPos);\n     }\n-    \n+\n     // Contains\n     //-----------------------------------------------------------------------\n     /**\n         }\n         return (str.indexOf(searchChar) >= 0);\n     }\n-    \n+\n     /**\n      * <p>Find the first index within a String, handling <code>null</code>.\n      * This method uses {@link String#indexOf(int)}.</p>\n         }\n         return (str.indexOf(searchStr) >= 0);\n     }\n-    \n+\n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-     public static int indexOfAny(String str, char[] searchChars) {\n-         if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n-             return -1;\n-         }\n-         for (int i = 0; i < str.length(); i ++) {\n-             char ch = str.charAt(i);\n-             for (int j = 0; j < searchChars.length; j++) {\n-                 if (searchChars[j] == ch) {\n-                     return i;\n-                 }\n-             }\n-         }\n-         return -1;\n-     }\n+    public static int indexOfAny(String str, char[] searchChars) {\n+        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n \n     /**\n      * <p>Search a String to find the first index of any\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-     public static int indexOfAnyBut(String str, char[] searchChars) {\n-         if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n-             return -1;\n-         }\n-         outer: for (int i = 0; i < str.length(); i ++) {\n-             char ch = str.charAt(i);\n-             for (int j = 0; j < searchChars.length; j++) {\n-                 if (searchChars[j] == ch) {\n-                     continue outer;\n-                 }\n-             }\n-             return i;\n-         }\n-         return -1;\n-     }\n+    public static int indexOfAnyBut(String str, char[] searchChars) {\n+        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+            return -1;\n+        }\n+        outer : for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n \n     /**\n      * <p>Search a String to find the first index of any\n      */\n     public static boolean containsOnly(String str, char[] valid) {\n         // All these pre-checks are to maintain API with an older version\n-        if ( (valid == null) || (str == null) ) {\n+        if ((valid == null) || (str == null)) {\n             return false;\n         }\n         if (str.length() == 0) {\n         }\n         return containsOnly(str, validChars.toCharArray());\n     }\n-    \n+\n     // ContainsNone\n     //-----------------------------------------------------------------------\n     /**\n         }\n         return containsNone(str, invalidChars.toCharArray());\n     }\n-    \n+\n     // IndexOfAny strings\n     //-----------------------------------------------------------------------\n     /**\n \n         return str.substring(start);\n     }\n-    \n+\n     /**\n      * <p>Gets a substring from the specified String avoiding exceptions.</p>\n      *\n     public static String substringBetween(String str, String tag) {\n         return substringBetween(str, tag, tag);\n     }\n-    \n+\n     /**\n      * <p>Gets the String that is nested in between two Strings.\n      * Only the first match is returned.</p>\n     public static String getNestedString(String str, String tag) {\n         return substringBetween(str, tag, tag);\n     }\n-    \n+\n     /**\n      * <p>Gets the String that is nested in between two Strings.\n      * Only the first match is returned.</p>\n      */\n     public static String[] split(String str, char separatorChar) {\n         // Performance tuned for 2.0 (JDK1.4)\n-        \n+\n         if (str == null) {\n             return null;\n         }\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n         List list = new ArrayList();\n-        int i =0, start = 0;\n+        int i = 0, start = 0;\n         boolean match = false;\n         while (i < len) {\n             if (str.charAt(i) == separatorChar) {\n         // Performance tuned for 2.0 (JDK1.4)\n         // Direct code is quicker than StringTokenizer.\n         // Also, StringTokenizer uses isSpace() not isWhitespace()\n-        \n+\n         if (str == null) {\n             return null;\n         }\n         }\n         List list = new ArrayList();\n         int sizePlus1 = 1;\n-        int i =0, start = 0;\n+        int i = 0, start = 0;\n         boolean match = false;\n         if (separatorChars == null) {\n             // Null separator means use whitespace\n     public static String concatenate(Object[] array) {\n         return join(array, null);\n     }\n-    \n+\n     /**\n      * <p>Joins the elements of the provided array into a single String\n      * containing the provided list of elements.</p>\n     public static String join(Object[] array) {\n         return join(array, null);\n     }\n-    \n+\n     /**\n      * <p>Joins the elements of the provided array into a single String\n      * containing the provided list of elements.</p>\n         // ArraySize ==  0: Len = 0\n         // ArraySize > 0:   Len = NofStrings *(len(firstString) + len(separator))\n         //           (Assuming that all Strings are roughly equally long)\n-        int bufSize \n-            = ((arraySize == 0) ? 0 \n-                : arraySize * ((array[0] == null ? 16 : array[0].toString().length()) \n-                    + ((separator != null) ? separator.length(): 0)));\n+        int bufSize =\n+            ((arraySize == 0)\n+                ? 0\n+                : arraySize\n+                    * ((array[0] == null ? 16 : array[0].toString().length())\n+                        + ((separator != null) ? separator.length() : 0)));\n \n         StringBuffer buf = new StringBuffer(bufSize);\n \n         if (iterator == null) {\n             return null;\n         }\n-        StringBuffer buf = new StringBuffer(256);  // Java default is 16, probably too small\n+        StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small\n         while (iterator.hasNext()) {\n             Object obj = iterator.next();\n             if (obj != null) {\n         if (iterator == null) {\n             return null;\n         }\n-        StringBuffer buf = new StringBuffer(256);  // Java default is 16, probably too small\n+        StringBuffer buf = new StringBuffer(256); // Java default is 16, probably too small\n         while (iterator.hasNext()) {\n             Object obj = iterator.next();\n             if (obj != null) {\n             if ((separator != null) && iterator.hasNext()) {\n                 buf.append(separator);\n             }\n-         }\n+        }\n         return buf.toString();\n     }\n \n         buf.append(text.substring(start));\n         return buf.toString();\n     }\n-    \n+\n     // Replace, character based\n     //-----------------------------------------------------------------------\n     /**\n         }\n         return str.replace(searchChar, replaceChar);\n     }\n-    \n+\n     /**\n      * <p>Replaces multiple characters in a String in one go.\n      * This method can also be used to delete characters.</p>\n      * @since 2.0\n      */\n     public static String replaceChars(String str, String searchChars, String replaceChars) {\n-        if (str == null || str.length() == 0 || searchChars == null || searchChars.length()== 0) {\n+        if (str == null || str.length() == 0 || searchChars == null || searchChars.length() == 0) {\n             return str;\n         }\n         char[] chars = str.toCharArray();\n     public static String chompLast(String str) {\n         return chompLast(str, \"\\n\");\n     }\n-    \n+\n     /**\n      * <p>Remove a value if and only if the String ends with that value.</p>\n      * \n         return str.substring(0, lastIdx);\n     }\n \n-\n     // Conversion\n     //-----------------------------------------------------------------------\n     /**\n      */\n     public static String repeat(String str, int repeat) {\n         // Performance tuned for 2.0 (JDK1.4)\n-        \n+\n         if (str == null) {\n             return null;\n         }\n             return str;\n         }\n         if (inputLength == 1 && repeat <= PAD_LIMIT) {\n-           return padding(repeat, str.charAt(0));\n+            return padding(repeat, str.charAt(0));\n         }\n \n         int outputLength = inputLength * repeat;\n         switch (inputLength) {\n-            case 1:\n+            case 1 :\n                 char ch = str.charAt(0);\n                 char[] output1 = new char[outputLength];\n                 for (int i = repeat - 1; i >= 0; i--) {\n                     output1[i] = ch;\n                 }\n                 return new String(output1);\n-            case 2:\n+            case 2 :\n                 char ch0 = str.charAt(0);\n                 char ch1 = str.charAt(1);\n                 char[] output2 = new char[outputLength];\n-                for (int i = repeat * 2 - 2; i >= 0; i--,i--) {\n+                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                     output2[i] = ch0;\n                     output2[i + 1] = ch1;\n                 }\n                 return new String(output2);\n-            default:\n+            default :\n                 StringBuffer buf = new StringBuffer(outputLength);\n                 for (int i = 0; i < repeat; i++) {\n                     buf.append(str);\n-                }        \n+                }\n                 return buf.toString();\n         }\n     }\n         if (padLen == 1 && pads <= PAD_LIMIT) {\n             return rightPad(str, size, padStr.charAt(0));\n         }\n-        \n+\n         if (pads == padLen) {\n             return str.concat(padStr);\n         } else if (pads < padLen) {\n      *  <code>null</code> if null String input\n      */\n     public static String leftPad(String str, int size) {\n-        return leftPad(str, size, ' ');        \n+        return leftPad(str, size, ' ');\n     }\n \n     /**\n         if (padLen == 1 && pads <= PAD_LIMIT) {\n             return leftPad(str, size, padStr.charAt(0));\n         }\n-        \n+\n         if (pads == padLen) {\n             return padStr.concat(str);\n         } else if (pads < padLen) {\n         }\n         int sz = str.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetter(str.charAt(i)) == false) &&\n-                (str.charAt(i) != ' ')) {\n+            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n         }\n         int sz = str.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isLetterOrDigit(str.charAt(i)) == false) &&\n-                (str.charAt(i) != ' ')) {\n+            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n         }\n         int sz = str.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isDigit(str.charAt(i)) == false) &&\n-                (str.charAt(i) != ' ')) {\n+            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n                 return false;\n             }\n         }\n         }\n         int sz = str.length();\n         for (int i = 0; i < sz; i++) {\n-            if ((Character.isWhitespace(str.charAt(i)) == false) ) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n                 return false;\n             }\n         }\n         return -1;\n     }\n \n-\n     // Misc\n     //-----------------------------------------------------------------------\n     /**\n     }\n \n }\n-\n--- a/src/test/org/apache/commons/lang/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsEqualsIndexOfTest.java\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n  * @author Phil Steitz\n- * @version $Id: StringUtilsEqualsIndexOfTest.java,v 1.8 2003/08/18 02:22:25 bayard Exp $\n+ * @version $Id: StringUtilsEqualsIndexOfTest.java,v 1.9 2003/09/04 18:18:18 ggregory Exp $\n  */\n public class StringUtilsEqualsIndexOfTest extends TestCase {\n     private static final String FOO = \"foo\";\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\"));\n         assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\"));\n         assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"\"));\n+    }\n+\n+    public void testOrdinalIndexOf() {\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MIN_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MIN_VALUE));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", -1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", -1));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 0));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 0));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 1));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1));\n+        assertEquals(2, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1));\n+\n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, 2));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, 2));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", 2));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2));\n+        assertEquals(5, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2));\n+        assertEquals(4, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MAX_VALUE));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MAX_VALUE));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MAX_VALUE));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MAX_VALUE));\n+        \n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 0));\n+        assertEquals(0, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 1));\n+        assertEquals(1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 2));\n+        assertEquals(2, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 3));\n+        assertEquals(3, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 4));\n+        assertEquals(4, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 5));\n+        assertEquals(5, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 6));\n+        assertEquals(6, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 7));\n+        assertEquals(7, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 8));\n+        assertEquals(8, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 9));\n+        assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 10));\n     }\n \n     public void testIndexOf_StringInt() {", "timestamp": 1062699498, "metainfo": ""}