{"sha": "70a3bb8d5aea986bf7938699955f0a6809a586df", "log": "LANG-609: Added AtomicInitializer class. Introduced new ConcurrentInitializer interface which is now implemented by all all initializer classes.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/AtomicInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * <p>\n+ * A specialized implementation of the {@code ConcurrentInitializer} interface\n+ * based on an {@link AtomicReference} variable.\n+ * </p>\n+ * <p>\n+ * This class maintains a member field of type {@code AtomicReference}. It\n+ * implements the following algorithm to create and initialize an object in its\n+ * {@link #get()} method:\n+ * <ul>\n+ * <li>First it is checked whether the {@code AtomicReference} variable contains\n+ * already a value. If this is the case, the value is directly returned.</li>\n+ * <li>Otherwise the {@link #initialize()} method is called. This method must be\n+ * defined in concrete subclasses to actually create the managed object.</li>\n+ * <li>After the object was created by {@link #initialize()} it is checked\n+ * whether the {@code AtomicReference} variable is still undefined. This has to\n+ * be done because in the meantime another thread may have initialized the\n+ * object. If the reference is still empty, the newly created object is stored\n+ * in it and returned by this method.</li>\n+ * <li>Otherwise the value stored in the {@code AtomicReference} is returned.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * Because atomic variables are used this class does not need any\n+ * synchronization. So there is no danger of deadlock, and access to the managed\n+ * object is efficient. However, if multiple threads access the {@code\n+ * AtomicInitializer} object before it has been initialized almost at the same\n+ * time, it can happen that {@link #initialize()} is called multiple times. The\n+ * algorithm outlined above guarantees that {@link #get()} always returns the\n+ * same object though.\n+ * </p>\n+ * <p>\n+ * Compared with the {@link LazyInitializer} class, this class can be more\n+ * efficient because it does not need synchronization. The drawback is that the\n+ * {@link #initialize()} method can be called multiple times which may be\n+ * problematic if the creation of the managed object is expensive. As a rule of\n+ * thumb this initializer implementation is preferable if there are not too many\n+ * threads involved and the probability that multiple threads access an\n+ * uninitialized object is small. If there is high parallelism,\n+ * {@link LazyInitializer} is more appropriate.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class AtomicInitializer<T> implements ConcurrentInitializer<T> {\n+    /** Holds the reference to the managed object. */\n+    private final AtomicReference<T> reference = new AtomicReference<T>();\n+\n+    /**\n+     * Returns the object managed by this initializer. The object is created if\n+     * it is not available yet and stored internally. This method always returns\n+     * the same object.\n+     *\n+     * @return the object created by this {@code AtomicInitializer}\n+     * @throws ConcurrentException if an error occurred during initialization of\n+     * the object\n+     */\n+    public T get() throws ConcurrentException {\n+        T result = reference.get();\n+\n+        if (result == null) {\n+            result = initialize();\n+            if (!reference.compareAndSet(null, result)) {\n+                // another thread has initialized the reference\n+                result = reference.get();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates and initializes the object managed by this {@code\n+     * AtomicInitializer}. This method is called by {@link #get()} when the\n+     * managed object is not available yet. An implementation can focus on the\n+     * creation of the object. No synchronization is needed, as this is already\n+     * handled by {@code get()}. As stated by the class comment, it is possible\n+     * that this method is called multiple times.\n+     *\n+     * @return the managed data object\n+     * @throws ConcurrentException if an error occurs during object creation\n+     */\n+    protected abstract T initialize() throws ConcurrentException;\n+}\n--- a/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n  * @version $Id$\n  * @param <T> the type of the object managed by this initializer class\n  */\n-public abstract class BackgroundInitializer<T> {\n+public abstract class BackgroundInitializer<T> implements\n+        ConcurrentInitializer<T> {\n     /** The external executor service for executing tasks. */\n     private ExecutorService externalExecutor;\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+/**\n+ * <p>\n+ * Definition of an interface for the thread-safe initialization of objects.\n+ * </p>\n+ * <p>\n+ * The idea behind this interface is to provide access to an object in a\n+ * thread-safe manner. A {@code ConcurrentInitializer} can be passed to multiple\n+ * threads which can all access the object produced by the initializer. Through\n+ * the {@link #getInitializedObject()} method the object can be queried.\n+ * </p>\n+ * <p>\n+ * Concrete implementations of this interface will use different strategies for\n+ * the creation of the managed object, e.g. lazy initialization or\n+ * initialization in a background thread. This is completely transparent to\n+ * client code, so it is possible to change the initialization strategy without\n+ * affecting clients.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public interface ConcurrentInitializer<T> {\n+    /**\n+     * Returns the fully initialized object produced by this {@code\n+     * ConcurrentInitializer}. A concrete implementation here returns the\n+     * results of the initialization process. This method may block until\n+     * results are available. Typically, once created the result object is\n+     * always the same.\n+     *\n+     * @return the object created by this {@code ConcurrentException}\n+     * @throws ConcurrentException if an error occurred during initialization of\n+     * the object\n+     */\n+    T get() throws ConcurrentException;\n+}\n--- a/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Invokes the specified {@code ConcurrentInitializer} and returns the\n+     * object produced by the initializer. This method just invokes the {@code\n+     * get()} method of the given {@code ConcurrentInitializer}. It is\n+     * <b>null</b>-safe: if the argument is <b>null</b>, result is also\n+     * <b>null</b>.\n+     *\n+     * @param <T> the type of the object produced by the initializer\n+     * @param initializer the {@code ConcurrentInitializer} to be invoked\n+     * @return the object managed by the {@code ConcurrentInitializer}\n+     * @throws ConcurrentException if the {@code ConcurrentInitializer} throws\n+     * an exception\n+     */\n+    public static <T> T initialize(ConcurrentInitializer<T> initializer)\n+            throws ConcurrentException {\n+        return (initializer != null) ? initializer.get() : null;\n+    }\n+\n+    /**\n+     * Invokes the specified {@code ConcurrentInitializer} and transforms\n+     * occurring exceptions to runtime exceptions. This method works like\n+     * {@link #initialize(ConcurrentInitializer)}, but if the {@code\n+     * ConcurrentInitializer} throws a {@link ConcurrentException}, it is\n+     * caught, and the cause is wrapped in a {@link ConcurrentRuntimeException}.\n+     * So client code does not have to deal with checked exceptions.\n+     *\n+     * @param <T> the type of the object produced by the initializer\n+     * @param initializer the {@code ConcurrentInitializer} to be invoked\n+     * @return the object managed by the {@code ConcurrentInitializer}\n+     * @throws ConcurrentRuntimeException if the initializer throws an exception\n+     */\n+    public static <T> T initializeUnchecked(ConcurrentInitializer<T> initializer) {\n+        try {\n+            return initialize(initializer);\n+        } catch (ConcurrentException cex) {\n+            throw new ConcurrentRuntimeException(cex.getCause());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * <p>\n      * Gets an implementation of <code>Future</code> that is immediately done\n      * and returns the specified constant value.\n--- a/src/main/java/org/apache/commons/lang3/concurrent/LazyInitializer.java\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/LazyInitializer.java\n  * @version $Id$\n  * @param <T> the type of the object managed by this initializer class\n  */\n-public abstract class LazyInitializer<T> {\n+public abstract class LazyInitializer<T> implements ConcurrentInitializer<T> {\n     /** Stores the managed object. */\n     private volatile T object;\n \n      * is created. After that it is cached and can be accessed pretty fast.\n      *\n      * @return the object initialized by this {@code LazyInitializer}\n+     * @throws ConcurrentException if an error occurred during initialization of\n+     * the object\n      */\n-    public T get() {\n+    public T get() throws ConcurrentException {\n         // use a temporary variable to reduce the number of reads of the\n         // volatile field\n         T result = object;\n      * handled by {@code get()}.\n      *\n      * @return the managed data object\n+     * @throws ConcurrentException if an error occurs during object creation\n      */\n-    protected abstract T initialize();\n+    protected abstract T initialize() throws ConcurrentException;\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/AbstractConcurrentInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.junit.Test;\n+\n+/**\n+ * <p>\n+ * An abstract base class for tests of concrete {@code ConcurrentInitializer}\n+ * implementations.\n+ * </p>\n+ * <p>\n+ * This class provides some basic tests for initializer implementations. Derived\n+ * class have to create a {@link ConcurrentInitializer} object on which the\n+ * tests are executed.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public abstract class AbstractConcurrentInitializerTest {\n+    /**\n+     * Tests a simple invocation of the get() method.\n+     */\n+    @Test\n+    public void testGet() throws ConcurrentException {\n+        assertNotNull(\"No managed object\", createInitializer().get());\n+    }\n+\n+    /**\n+     * Tests whether sequential get() invocations always return the same\n+     * instance.\n+     */\n+    @Test\n+    public void testGetMultipleTimes() throws ConcurrentException {\n+        ConcurrentInitializer<Object> initializer = createInitializer();\n+        Object obj = initializer.get();\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Got different object at \" + i, obj, initializer.get());\n+        }\n+    }\n+\n+    /**\n+     * Tests whether get() can be invoked from multiple threads concurrently.\n+     * Always the same object should be returned.\n+     */\n+    @Test\n+    public void testGetConcurrent() throws ConcurrentException,\n+            InterruptedException {\n+        final ConcurrentInitializer<Object> initializer = createInitializer();\n+        final int threadCount = 20;\n+        final CountDownLatch startLatch = new CountDownLatch(1);\n+        class GetThread extends Thread {\n+            Object object;\n+\n+            @Override\n+            public void run() {\n+                try {\n+                    // wait until all threads are ready for maximum parallelism\n+                    startLatch.await();\n+                    // access the initializer\n+                    object = initializer.get();\n+                } catch (InterruptedException iex) {\n+                    // ignore\n+                } catch (ConcurrentException cex) {\n+                    object = cex;\n+                }\n+            }\n+        }\n+\n+        GetThread[] threads = new GetThread[threadCount];\n+        for (int i = 0; i < threadCount; i++) {\n+            threads[i] = new GetThread();\n+            threads[i].start();\n+        }\n+\n+        // fire all threads and wait until they are ready\n+        startLatch.countDown();\n+        for (Thread t : threads) {\n+            t.join();\n+        }\n+\n+        // check results\n+        Object managedObject = initializer.get();\n+        for (GetThread t : threads) {\n+            assertEquals(\"Wrong object\", managedObject, t.object);\n+        }\n+    }\n+\n+    /**\n+     * Creates the {@link ConcurrentInitializer} object to be tested. This\n+     * method is called whenever the test fixture needs to be obtained.\n+     *\n+     * @return the initializer object to be tested\n+     */\n+    protected abstract ConcurrentInitializer<Object> createInitializer();\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/AtomicInitializerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+/**\n+ * Test class for {@code AtomicInitializer}.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class AtomicInitializerTest extends AbstractConcurrentInitializerTest {\n+    /**\n+     * Returns the initializer to be tested.\n+     *\n+     * @return the {@code AtomicInitializer}\n+     */\n+    @Override\n+    protected ConcurrentInitializer<Object> createInitializer() {\n+        return new AtomicInitializer<Object>() {\n+            @Override\n+            protected Object initialize() throws ConcurrentException {\n+                return new Object();\n+            }\n+        };\n+    }\n+}\n--- a/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/ConcurrentUtilsTest.java\n import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n+import org.easymock.EasyMock;\n import org.junit.Test;\n \n /**\n         ConcurrentUtils.handleCauseUnchecked(null);\n         ConcurrentUtils.handleCauseUnchecked(new ExecutionException(\"Test\",\n                 null));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests initialize() for a null argument.\n+     */\n+    @Test\n+    public void testInitializeNull() throws ConcurrentException {\n+        assertNull(\"Got a result\", ConcurrentUtils.initialize(null));\n+    }\n+\n+    /**\n+     * Tests a successful initialize() operation.\n+     */\n+    @Test\n+    public void testInitialize() throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Object> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        final Object result = new Object();\n+        EasyMock.expect(init.get()).andReturn(result);\n+        EasyMock.replay(init);\n+        assertSame(\"Wrong result object\", result, ConcurrentUtils\n+                .initialize(init));\n+        EasyMock.verify(init);\n+    }\n+\n+    /**\n+     * Tests initializeUnchecked() for a null argument.\n+     */\n+    @Test\n+    public void testInitializeUncheckedNull() {\n+        assertNull(\"Got a result\", ConcurrentUtils.initializeUnchecked(null));\n+    }\n+\n+    /**\n+     * Tests a successful initializeUnchecked() operation.\n+     */\n+    @Test\n+    public void testInitializeUnchecked() throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Object> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        final Object result = new Object();\n+        EasyMock.expect(init.get()).andReturn(result);\n+        EasyMock.replay(init);\n+        assertSame(\"Wrong result object\", result, ConcurrentUtils\n+                .initializeUnchecked(init));\n+        EasyMock.verify(init);\n+    }\n+\n+    /**\n+     * Tests whether exceptions are correctly handled by initializeUnchecked().\n+     */\n+    @Test\n+    public void testInitializeUncheckedEx() throws ConcurrentException {\n+        @SuppressWarnings(\"unchecked\")\n+        ConcurrentInitializer<Object> init = EasyMock\n+                .createMock(ConcurrentInitializer.class);\n+        final Exception cause = new Exception();\n+        EasyMock.expect(init.get()).andThrow(new ConcurrentException(cause));\n+        EasyMock.replay(init);\n+        try {\n+            ConcurrentUtils.initializeUnchecked(init);\n+            fail(\"Exception not thrown!\");\n+        } catch (ConcurrentRuntimeException crex) {\n+            assertSame(\"Wrong cause\", cause, crex.getCause());\n+        }\n+        EasyMock.verify(init);\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/lang3/concurrent/LazyInitializerTest.java\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/LazyInitializerTest.java\n  */\n package org.apache.commons.lang3.concurrent;\n \n-import java.util.concurrent.CountDownLatch;\n-\n-import junit.framework.TestCase;\n+import org.junit.Before;\n \n /**\n  * Test class for {@code LazyInitializer}.\n  *\n  * @version $Id$\n  */\n-public class LazyInitializerTest extends TestCase {\n+public class LazyInitializerTest extends AbstractConcurrentInitializerTest {\n     /** The initializer to be tested. */\n     private LazyInitializerTestImpl initializer;\n \n-    @Override\n-    protected void setUp() throws Exception {\n-        super.setUp();\n+    @Before\n+    public void setUp() throws Exception {\n         initializer = new LazyInitializerTestImpl();\n     }\n \n     /**\n-     * Tests obtaining the managed object.\n+     * Returns the initializer to be tested. This implementation returns the\n+     * {@code LazyInitializer} created in the {@code setUp()} method.\n+     *\n+     * @return the initializer to be tested\n      */\n-    public void testGet() {\n-        assertNotNull(\"No managed object\", initializer.get());\n-    }\n-\n-    /**\n-     * Tests whether sequential get() invocations always return the same\n-     * instance.\n-     */\n-    public void testGetMultipleTimes() {\n-        Object obj = initializer.get();\n-        for (int i = 0; i < 10; i++) {\n-            assertEquals(\"Got different object at \" + i, obj, initializer.get());\n-        }\n-    }\n-\n-    /**\n-     * Tests invoking get() from multiple threads concurrently.\n-     */\n-    public void testGetConcurrent() throws InterruptedException {\n-        final int threadCount = 20;\n-        final CountDownLatch startLatch = new CountDownLatch(1);\n-        class GetThread extends Thread {\n-            Object object;\n-\n-            @Override\n-            public void run() {\n-                try {\n-                    // wait until all threads are ready for maximum parallelism\n-                    startLatch.await();\n-                    // access the initializer\n-                    object = initializer.get();\n-                } catch (InterruptedException iex) {\n-                    // ignore\n-                }\n-            }\n-        }\n-\n-        GetThread[] threads = new GetThread[threadCount];\n-        for (int i = 0; i < threadCount; i++) {\n-            threads[i] = new GetThread();\n-            threads[i].start();\n-        }\n-\n-        // fire all threads and wait until they are ready\n-        startLatch.countDown();\n-        for (Thread t : threads) {\n-            t.join();\n-        }\n-\n-        // check results\n-        Object managedObject = initializer.get();\n-        for (GetThread t : threads) {\n-            assertEquals(\"Wrong object\", managedObject, t.object);\n-        }\n+    @Override\n+    protected ConcurrentInitializer<Object> createInitializer() {\n+        return initializer;\n     }\n \n     /**", "timestamp": 1269967762, "metainfo": ""}