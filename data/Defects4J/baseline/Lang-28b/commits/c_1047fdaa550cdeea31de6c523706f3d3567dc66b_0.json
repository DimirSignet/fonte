{"sha": "1047fdaa550cdeea31de6c523706f3d3567dc66b", "log": "Consolidated methods.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n \n import org.apache.commons.lang.ArrayUtils;\n import org.apache.commons.lang.StringUtils;\n+\n /**\n  * <code>MethodUtils</code> contains utility methods for working for\n  * methods by reflection.\n  * @author Gregor Raman\n  * @author Jan Sorensen\n  * @author Robert Burrell Donkin\n- * @version $Id: MethodUtils.java,v 1.8 2002/11/21 19:38:51 rdonkin Exp $\n+ * @version $Id: MethodUtils.java,v 1.9 2002/12/10 19:06:49 rdonkin Exp $\n  */\n public class MethodUtils {\n     \n      */\n     public static Method getMethod(Class cls, String methodName) {\n         return getMethod(cls, methodName, ArrayUtils.EMPTY_CLASS_ARRAY, false);\n+    }\n+    \n+    /**\n+     * Gets a Method by name. The method must be public.\n+     * Superclasses will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param methodName  the field name to obtain\n+     * @return the Method object\n+     * @throws IllegalArgumentException if the class or method name is null\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Method getMethod(Class cls, String methodName, Class paramType) {\n+        Class[] paramTypes = {paramType};\n+        return getMethod(cls, methodName, paramTypes);\n     }\n     \n     /**\n                 }\n                 throw new NoSuchMethodException(\"The method '\" + methodName + \"' could not be found\");\n             } else {\n-                return cls.getMethod(methodName, paramTypes);\n+                // apply workarounds\n+                Method method = null;\n+                try {\n+                \n+                    method = cls.getMethod(methodName, paramTypes);\n+                    \n+                } catch(NoSuchMethodException e) {\n+                    // swallow\n+                }\n+                \n+                if (method == null) {\n+                    // use the same as beanutils for the moment\n+                    Method[] compatibles = getCompatibleMethods(cls, methodName, paramTypes);\n+                    if (compatibles.length > 0) {\n+                        method = compatibles[0];\n+                    }\n+                }\n+                return getMethod(method);\n             }\n     \n         } catch (ReflectionException ex) {\n                 ex, \"getting method\", cls.getName(), null, methodName), ex);\n         }\n     }\n-    \n-    // -------------------------------------------------------------------------\n-    \n-    /**\n-     * <p>Invoke a named method whose parameter type matches the object type.</p>\n-     *\n-     * <p>This method supports calls to methods taking primitive parameters \n-     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n-     * would match a <code>boolean</code> primitive.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeMethod(Object object,String methodName,Object [] args)}.\n-     * </p>\n-     *\n-     * @param objectToInvoke  invoke method on this object, must not be null\n-     * @param methodName  get method with this name, must not be null\n-     * @param arg  use this argument, must not be null\n-     *\n-     * @throws ReflectionException if an error occurs during reflection\n-     * @throws IllegalArgumentException if any parameter is null\n-     */\n-    public static Object invokeMethod(\n-            Object objectToInvoke,\n-            String methodName,\n-            Object arg)\n-                throws\n-                    ReflectionException {\n-\n-        if (objectToInvoke == null) {\n-            throw new IllegalArgumentException(\"The object to invoke must not be null\");\n-        }\n-        if (methodName == null) {\n-            throw new IllegalArgumentException(\"The method name must not be null\");\n-        }\n-        if (arg == null) {\n-            throw new IllegalArgumentException(\"The argument must not be null\");\n-        }\n-        Object[] args = {arg};\n-        return invokeMethod(objectToInvoke, methodName, args);\n-    }\n-\n-    /**\n-     * <p>Invoke a named method whose parameter type matches the object type.</p>\n-     *\n-     * <p>This method supports calls to methods taking primitive parameters \n-     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n-     * would match a <code>boolean</code> primitive.</p>\n-     *\n-     * <p> This is a convenient wrapper for\n-     * {@link #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n-     * </p>\n-     *\n-     * @param objectToInvoke  invoke method on this object, must not be null\n-     * @param methodName  get method with this name, must not be null\n-     * @param args  use these arguments - treat null as empty array\n-     *\n-     * @throws ReflectionException if an error occurs during reflection\n-     * @throws IllegalArgumentException if the objectToInvoke, methodName or any argument is null\n-     */\n-    public static Object invokeMethod(\n-            Object objectToInvoke,\n-            String methodName,\n-            Object[] args)\n-                throws\n-                    ReflectionException {\n-        \n-        if (objectToInvoke == null) {\n-            throw new IllegalArgumentException(\"The object to invoke must not be null\");\n-        }\n-        if (methodName == null) {\n-            throw new IllegalArgumentException(\"The method name must not be null\");\n-        }\n-        if (args == null) {\n-            return invokeMethod(objectToInvoke, methodName, null, null);\n-        } else {\n-            int arguments = args.length;\n-            Class parameterTypes [] = new Class[arguments];\n-            for (int i = 0; i < arguments; i++) {\n-                if (args[i] == null) {\n-                    throw new IllegalArgumentException(\"The arguments must not be null. Index \" + i + \" was null.\");\n-                }\n-                parameterTypes[i] = args[i].getClass();\n-            }\n-            return invokeMethod(objectToInvoke, methodName, args, parameterTypes);\n-        }\n-    }\n-\n-    /**\n-     * <p>Invoke a named method whose parameter type matches the object type.</p>\n-     *\n-     * <p>This method supports calls to methods taking primitive parameters \n-     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n-     * would match a <code>boolean</code> primitive.</p>\n-     *\n-     *\n-     * @param object  invoke method on this object\n-     * @param methodName  get method with this name\n-     * @param args  use these arguments - treat null as empty array\n-     * @param parameterTypes  match these parameters - treat null as empty array\n-     *\n-     * @throws ReflectionException if an error occurs during reflection\n-     */\n-    public static Object invokeMethod(\n-            Object object,\n-            String methodName,\n-            Object[] args,\n-            Class[] parameterTypes)\n-                throws\n-                    ReflectionException {\n-                    \n-        if (parameterTypes == null) {\n-            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n-        }        \n-        if (args == null) {\n-            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n-        }  \n-\n-        Method method = getMatchingAccessibleMethod(\n-                object.getClass(),\n-                methodName,\n-                parameterTypes);\n-        if (method == null)\n-            throw new ReflectionException(\"No such accessible method: \" +\n-                    methodName + \"() on object: \" + object.getClass().getName());\n-        \n-        try {\n-        \n-            return method.invoke(object, args);\n-            \n-        } catch (IllegalAccessException ex) {\n-            throw new ReflectionException(\n-                ReflectionUtils.getThrowableText(\n-                    ex, \"invoking method\", object.getClass().getName(), parameterTypes, methodName)\n-                , ex);\n-        \n-        } catch (InvocationTargetException ex) {\n-            throw new ReflectionException(\n-                ReflectionUtils.getThrowableText(\n-                    ex, \"invoking method\", object.getClass().getName(), parameterTypes, methodName)\n-                , ex);\n-        \n-        }\n-    }\n-\n-    /**\n-     * <p>Return an accessible method (that is, one that can be invoked via\n-     * reflection) with given name and a single parameter.  If no such method\n-     * can be found, return <code>null</code>.\n-     * Basically, a convenience wrapper that constructs a <code>Class</code>\n-     * array for you.</p>\n-     *\n-     * @param clazz get method from this class\n-     * @param methodName get method with this name\n-     * @param parameterType taking this type of parameter\n-     */\n-    public static Method getAccessibleMethod(\n-            Class clazz,\n-            String methodName,\n-            Class parameterType) {\n-\n-        Class[] parameterTypes = {parameterType};\n-        return getAccessibleMethod(clazz, methodName, parameterTypes);\n-\n-    }\n-\n-\n-    /**\n-     * <p>Return an accessible method (that is, one that can be invoked via\n-     * reflection) with given name and parameters.  If no such method\n-     * can be found, return <code>null</code>.\n-     * This is just a convenient wrapper for\n-     * {@link #getAccessibleMethod(Method method)}.</p>\n-     *\n-     * @param clazz get method from this class\n-     * @param methodName get method with this name\n-     * @param parameterTypes with these parameters types\n-     */\n-    public static Method getAccessibleMethod(\n-            Class clazz,\n-            String methodName,\n-            Class[] parameterTypes) {\n-\n-        try {\n-            return getAccessibleMethod\n-                    (clazz.getMethod(methodName, parameterTypes));\n-        } catch (NoSuchMethodException e) {\n-            return (null);\n-        }\n-\n-    }\n-\n \n     /**\n      * <p>Return an accessible method (that is, one that can be invoked via\n      *\n      * @param method The method that we wish to call\n      */\n-    public static Method getAccessibleMethod(Method method) {\n-\n-        // Make sure we have a method to check\n-        if (method == null) {\n-            return (null);\n-        }\n-\n-        // If the requested method is not public we cannot call it\n-        if (!Modifier.isPublic(method.getModifiers())) {\n-            return (null);\n-        }\n-\n-        // If the declaring class is public, we are done\n-        Class clazz = method.getDeclaringClass();\n-        if (Modifier.isPublic(clazz.getModifiers())) {\n-            return (method);\n-        }\n-\n-        // Check the implemented interfaces and subinterfaces\n-        String methodName = method.getName();\n-        Class[] parameterTypes = method.getParameterTypes();\n-        method =\n-                getAccessibleMethodFromInterfaceNest(clazz,\n-                        method.getName(),\n-                        method.getParameterTypes());\n-        return (method);\n-\n-    }\n-\n-\n-    // -------------------------------------------------------- Private Methods\n-\n-    /**\n-     * <p>Return an accessible method (that is, one that can be invoked via\n-     * reflection) that implements the specified method, by scanning through\n-     * all implemented interfaces and subinterfaces.  If no such method\n-     * can be found, return <code>null</code>.</p>\n-     *\n-     * <p> There isn't any good reason why this method must be private.\n-     * It is because there doesn't seem any reason why other classes should\n-     * call this rather than the higher level methods.</p>\n-     *\n-     * @param clazz Parent class for the interfaces to be checked\n-     * @param methodName Method name of the method we wish to call\n-     * @param parameterTypes The parameter type signatures\n-     */\n-    private static Method getAccessibleMethodFromInterfaceNest\n-            (Class clazz, String methodName, Class parameterTypes[]) {\n-\n-        Method method = null;\n-\n-        // Search up the superclass chain\n-        for (; clazz != null; clazz = clazz.getSuperclass()) {\n-\n-            // Check the implemented interfaces of the parent class\n-            Class interfaces[] = clazz.getInterfaces();\n-            for (int i = 0; i < interfaces.length; i++) {\n-\n-                // Is this interface public?\n-                if (!Modifier.isPublic(interfaces[i].getModifiers()))\n-                    continue;\n-\n-                // Does the method exist on this interface?\n-                try {\n-                    method = interfaces[i].getDeclaredMethod(methodName,\n-                            parameterTypes);\n-                } catch (NoSuchMethodException e) {\n-                    ;\n-                }\n-                if (method != null)\n-                    break;\n-\n-                // Recursively check our parent interfaces\n-                method =\n-                        getAccessibleMethodFromInterfaceNest(interfaces[i],\n-                                methodName,\n-                                parameterTypes);\n-                if (method != null)\n-                    break;\n-\n-            }\n-\n-        }\n-\n-        // If we found a method return it\n-        if (method != null)\n-            return (method);\n-\n-        // We did not find anything\n-        return (null);\n-\n-    }\n-\n-\n-    /**\n-     * <p>Find an accessible method that matches the given name and has compatible parameters.\n-     * Compatible parameters mean that every method parameter is assignable from \n-     * the given parameters.\n-     * In other words, it finds a method with the given name \n-     * that will take the parameters given.<p>\n-     *\n-     * <p>This method is slightly undeterminstic since it loops \n-     * through methods names and return the first matching method.</p>\n-     * \n-     * <p>This method is used by \n-     * {@link \n-     * #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n-     *\n-     * <p>This method can match primitive parameter by passing in wrapper classes.\n-     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n-     * parameter.\n-     *\n-     * @param clazz find method in this class\n-     * @param methodName find method with this name\n-     * @param parameterTypes find method with compatible parameters \n-     */\n-    private static Method getMatchingAccessibleMethod(\n-                                                Class clazz,\n-                                                String methodName,\n-                                                Class[] parameterTypes) {\n-        // trace logging\n-        if (debug) {\n-            log(\"Matching name=\" + methodName + \" on \" + clazz);\n-        }\n-        \n-        // see if we can find the method directly\n-        // most of the time this works and it's much faster\n-        try {\n-            Method method = clazz.getMethod(methodName, parameterTypes);\n-            if (debug) {\n-                log(\"Found straight match: \" + method);\n-                log(\"isPublic:\" + Modifier.isPublic(method.getModifiers()));\n-            }\n-            \n+    public static Method getMethod(Method method) {\n+        \n+        Method accessibleMethod = getAccessibleMethod(method);\n+        if (accessibleMethod == null) {\n             try {\n                 //\n                 // XXX Default access superclass workaround\n                 //\n                 // Better workarounds would be greatfully accepted.\n                 //\n-                method.setAccessible(true);\n+                if (ReflectionUtils.isPublicScope(method)) {\n+                    method.setAccessible(true);\n+                    accessibleMethod = method;\n+                }\n                 \n             } catch (SecurityException se) {\n                 // log but continue just in case the method.invoke works anyway\n                 \"Cannot setAccessible on method. Therefore cannot use jvm access bug workaround.\", \n                 se);\n             }\n-            return method;\n+        }\n+        return (accessibleMethod);\n+\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param objectToInvoke  invoke method on this object, must not be null\n+     * @param methodName  get method with this name, must not be null\n+     * @param arg  use this argument, must not be null\n+     *\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if any parameter is null\n+     */\n+    public static Object invokeMethod(\n+            Object objectToInvoke,\n+            String methodName,\n+            Object arg)\n+                throws\n+                    ReflectionException {\n+\n+        if (objectToInvoke == null) {\n+            throw new IllegalArgumentException(\"The object to invoke must not be null\");\n+        }\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method name must not be null\");\n+        }\n+        if (arg == null) {\n+            throw new IllegalArgumentException(\"The argument must not be null\");\n+        }\n+        Object[] args = {arg};\n+        return invokeMethod(objectToInvoke, methodName, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName,Object [] args,Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param objectToInvoke  invoke method on this object, must not be null\n+     * @param methodName  get method with this name, must not be null\n+     * @param args  use these arguments - treat null as empty array\n+     *\n+     * @throws ReflectionException if an error occurs during reflection\n+     * @throws IllegalArgumentException if the objectToInvoke, methodName or any argument is null\n+     */\n+    public static Object invokeMethod(\n+            Object objectToInvoke,\n+            String methodName,\n+            Object[] args)\n+                throws\n+                    ReflectionException {\n+        \n+        if (objectToInvoke == null) {\n+            throw new IllegalArgumentException(\"The object to invoke must not be null\");\n+        }\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method name must not be null\");\n+        }\n+        if (args == null) {\n+            return invokeMethod(objectToInvoke, methodName, null, null);\n+        } else {\n+            int arguments = args.length;\n+            Class parameterTypes [] = new Class[arguments];\n+            for (int i = 0; i < arguments; i++) {\n+                if (args[i] == null) {\n+                    throw new IllegalArgumentException(\"The arguments must not be null. Index \" + i + \" was null.\");\n+                }\n+                parameterTypes[i] = args[i].getClass();\n+            }\n+            return invokeMethod(objectToInvoke, methodName, args, parameterTypes);\n+        }\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     *\n+     * @param object  invoke method on this object\n+     * @param methodName  get method with this name\n+     * @param args  use these arguments - treat null as empty array\n+     * @param parameterTypes  match these parameters - treat null as empty array\n+     *\n+     * @throws ReflectionException if an error occurs during reflection\n+     */\n+    public static Object invokeMethod(\n+            Object object,\n+            String methodName,\n+            Object[] args,\n+            Class[] parameterTypes)\n+                throws\n+                    ReflectionException {\n+                    \n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }        \n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }  \n+\n+        Method method = getMethod(\n+                object.getClass(),\n+                methodName,\n+                parameterTypes);\n+        if (method == null)\n+            throw new ReflectionException(\"No such accessible method: \" +\n+                    methodName + \"() on object: \" + object.getClass().getName());\n+        \n+        try {\n+        \n+            return method.invoke(object, args);\n             \n-        } catch (NoSuchMethodException e) { /* SWALLOW */ }\n+        } catch (IllegalAccessException ex) {\n+            throw new ReflectionException(\n+                ReflectionUtils.getThrowableText(\n+                    ex, \"invoking method\", object.getClass().getName(), parameterTypes, methodName)\n+                , ex);\n+        \n+        } catch (InvocationTargetException ex) {\n+            throw new ReflectionException(\n+                ReflectionUtils.getThrowableText(\n+                    ex, \"invoking method\", object.getClass().getName(), parameterTypes, methodName)\n+                , ex);\n+        \n+        }\n+    }\n+\n+\n+\n+    // -------------------------------------------------------- Private Methods\n+\n+    private static Method getAccessibleMethod(Method method) {\n+\n+        // Make sure we have a method to check\n+        if (method == null) {\n+            return (null);\n+        }\n+\n+        // If the requested method is not public we cannot call it\n+        if (!Modifier.isPublic(method.getModifiers())) {\n+            log(\"Method is not public\");\n+            return (null);\n+        }\n+\n+        // If the declaring class is public, we are done\n+        Class clazz = method.getDeclaringClass();\n+        if (Modifier.isPublic(clazz.getModifiers())) {\n+            log(\"Class is public\");\n+            return (method);\n+        }\n+        \n+        if (debug) {\n+            log(\"Method is in non-public class \" + clazz);\n+        }\n+\n+        // Check the implemented interfaces and subinterfaces\n+        String methodName = method.getName();\n+        Class[] parameterTypes = method.getParameterTypes();\n+        method =\n+                getAccessibleMethodFromInterfaceNest(clazz,\n+                        method.getName(),\n+                        method.getParameterTypes());\n+\n+        return (method);\n+\n+    }\n+\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified method, by scanning through\n+     * all implemented interfaces and subinterfaces.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * <p> There isn't any good reason why this method must be private.\n+     * It is because there doesn't seem any reason why other classes should\n+     * call this rather than the higher level methods.</p>\n+     *\n+     * @param clazz Parent class for the interfaces to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest\n+            (Class clazz, String methodName, Class parameterTypes[]) {\n+        if (debug) {\n+            log(\"Finding accessible method \" + methodName + \" from interface nest\");\n+        }\n+        Method method = null;\n+\n+        // Search up the superclass chain\n+        for (; clazz != null; clazz = clazz.getSuperclass()) {\n+\n+            // Check the implemented interfaces of the parent class\n+            Class interfaces[] = clazz.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+\n+                // Is this interface public?\n+                if (!Modifier.isPublic(interfaces[i].getModifiers()))\n+                    continue;\n+\n+                // Does the method exist on this interface?\n+                try {\n+                    method = interfaces[i].getDeclaredMethod(methodName,\n+                            parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    ;\n+                }\n+                if (method != null)\n+                    break;\n+\n+                // Recursively check our parent interfaces\n+                method =\n+                        getAccessibleMethodFromInterfaceNest(interfaces[i],\n+                                methodName,\n+                                parameterTypes);\n+                if (method != null)\n+                    break;\n+\n+            }\n+\n+        }\n+\n+        // If we found a method return it\n+        if (method != null) {\n+            if (debug) {\n+                log(\"Found method in class \" + method.getDeclaringClass());\n+            }\n+            return (method);\n+        }\n+        // We did not find anything\n+        return (null);\n+\n+    } \n+    \n+    private static Method[] getCompatibleMethods(\n+                                                Class clazz,\n+                                                String methodName,\n+                                                Class[] parameterTypes) {\n+        // trace logging\n+        if (debug) {\n+            log(\"Matching name=\" + methodName + \" on \" + clazz);\n+        }\n         \n         // search through all methods \n         int paramSize = parameterTypes.length;\n         Method[] methods = clazz.getMethods();\n+        ArrayList compatibles = new ArrayList(methods.length);\n         for (int i = 0, size = methods.length; i < size ; i++) {\n+            if (debug) {\n+                log(\"Checking: \" + methods[i]);\n+            }     \n             if (methods[i].getName().equals(methodName)) {\t\n                 // log some trace information\n                 if (debug) {\n-                    log(\"Found matching name:\");\n-                    log(methods[i]);\n+                    log(\"Found matching name:\" + methods[i]);\n                 }                \n                 \n                 // compare parameters\n                 Class[] methodsParams = methods[i].getParameterTypes();\n                 if (ReflectionUtils.isCompatible(parameterTypes, methodsParams)) {\n                     // get accessible version of method\n-                    Method method = getAccessibleMethod(methods[i]);\n+                    Method method = getMethod(methods[i]);\n                     if (method != null) {\n-                        if (debug) {\n-                            log(method + \" accessible version of \" \n-                                        + methods[i]);\n-                        }\n-                        try {\n-                            //\n-                            // XXX Default access superclass workaround\n-                            // (See above for more details.)\n-                            //\n-                            method.setAccessible(true);\n-                            \n-                        } catch (SecurityException se) {\n-                            // log but continue just in case the method.invoke works anyway\n-                            log(\n-                            \"Cannot setAccessible on method. Therefore cannot use jvm access bug workaround.\", \n-                            se);\n-                        }\n-                        return method;\n+                        compatibles.add(method);\n+                    } else {\n+                        log(\"Couldn't find accessible method for: \" + methods[i]);\n                     }\n-                    \n-                    log(\"Couldn't find accessible method.\");\n                 }\n             }\n         }\n         \n-        // didn't find a match\n-        log(\"No match found.\");\n-        return null;                                        \n-    }    \n+        return (Method[]) compatibles.toArray(new Method[compatibles.size()]); \n+    }  \n     \n     private static void log(Object o) {\n         if (debug) {\n--- a/src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java\n+++ b/src/test/org/apache/commons/lang/reflect/MethodUtilsTestCase.java\n \n         // easy bit first - find a public method\n         // METHOD ONE\n-        Method method = MethodUtils.getAccessibleMethod\n+        Method method = MethodUtils.getMethod\n                 (TestBean.class, \"setStringProperty\", String.class);\n \n         // check that we've found one that matches\n \n         // trickier this one - find a method in a direct interface\n         // METHOD TWO\n-        method = MethodUtils.getAccessibleMethod\n+        method = MethodUtils.getMethod\n                 (privateBeanFactory.create().getClass(),\n                         \"methodBar\",\n                         String.class);\n \n         // trickier this one - find a method in a indirect interface\n         // METHOD THREE\n-        method = MethodUtils.getAccessibleMethod\n+        method = MethodUtils.getMethod\n                 (privateBeanFactory.createSubclass().getClass(),\n                         \"methodBaz\",\n                         String.class);\n         try {\n \n             // Acquire the methods we need\n-            Method currentCounterMethod = MethodUtils.getAccessibleMethod\n+            Method currentCounterMethod = MethodUtils.getMethod\n                 (TestBean.class, \"currentCounter\",\n                  new Class[0]);\n             assertNotNull(\"currentCounterMethod exists\",\n                        Modifier.isPublic(currentCounterMethod.getModifiers()));\n             assertTrue(\"currentCounterMethod static\",\n                        Modifier.isStatic(currentCounterMethod.getModifiers()));\n-            Method incrementCounterMethod1 = MethodUtils.getAccessibleMethod\n+            Method incrementCounterMethod1 = MethodUtils.getMethod\n                 (TestBean.class, \"incrementCounter\",\n                  new Class[0]);\n             assertNotNull(\"incrementCounterMethod1 exists\",\n                        Modifier.isPublic(incrementCounterMethod1.getModifiers()));\n             assertTrue(\"incrementCounterMethod1 static\",\n                        Modifier.isStatic(incrementCounterMethod1.getModifiers()));\n-            Method incrementCounterMethod2 = MethodUtils.getAccessibleMethod\n+            Method incrementCounterMethod2 = MethodUtils.getMethod\n                 (TestBean.class, \"incrementCounter\",\n                  new Class[] { Integer.TYPE });\n             assertNotNull(\"incrementCounterMethod2 exists\",", "timestamp": 1039547209, "metainfo": ""}