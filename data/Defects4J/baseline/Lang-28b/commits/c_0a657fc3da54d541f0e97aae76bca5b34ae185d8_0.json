{"sha": "0a657fc3da54d541f0e97aae76bca5b34ae185d8", "log": "class from Digester, akin to the Interpolation class in the lang package   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/MappedMessageFormat.java\n+/*\n+ * Copyright 2002-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Map;\n+import java.util.ArrayList;\n+\n+/**\n+ * Provides the ability to substitute values from one or more maps into\n+ * designated places within a string.\n+ * <p>\n+ * For example:\n+ * <pre>\n+ *   \"User ${id} has uid ${uid} and path of env{path}\"\n+ * </pre>\n+ * can be expanded using values from a map associated with \"$\" and a different\n+ * map associated with \"env\".\n+ * <p> \n+ * This class is similar to the java.text.MessageFormat class, but allows\n+ * data to be retrieved from one or maps instead of from a single list.\n+ * Unlike the MessageFormat class, however, it simply uses the result of \n+ * applying toString() to the referenced values in the map(s) and does not \n+ * support any \"format\" operations applied to the objects before substitution \n+ * into the target string.\n+ *\n+ * @since 2.1\n+ */\n+\n+public class MappedMessageFormat {\n+    private int nEntries = 0;\n+    private ArrayList markers = new ArrayList(2);\n+    private ArrayList sources = new ArrayList(2);\n+    \n+    public MappedMessageFormat() {\n+    }\n+    \n+    /**\n+     * Defines a source of data that can later be substituted into\n+     * strings passed to the \"format\" methods.\n+     */\n+    public void addSource(String marker, Map source) {\n+        ++nEntries;\n+        markers.add(marker);\n+        sources.add(source);\n+    }\n+\n+    /**\n+     * Expands any variable declarations using any of the known\n+     * variable marker strings.\n+     * \n+     * @throws IllegalArgumentException if the input param references\n+     * a variable which is not known to the specified source.\n+     */\n+    public String format(String param) {\n+        for(int i=0; i<nEntries; ++i) {\n+            param = format(\n+                param, \n+                (String) markers.get(i), \n+                (Map) sources.get(i));\n+        }\n+        return param;\n+    }\n+    \n+    /**\n+     * Replace any occurrences within the string of the form\n+     * \"marker{key}\" with the value from source[key].\n+     * <p>\n+     * Commonly, the variable marker is \"$\", in which case variables\n+     * are indicated by ${key} in the string.\n+     * <p>\n+     * Returns the string after performing all substitutions.\n+     * <p>\n+     * If no substitutions were made, the input string object is\n+     * returned (not a copy).\n+     *\n+     * @throws IllegalArgumentException if the input param references\n+     * a variable which is not known to the specified source.\n+     */\n+    public static String format(String str, String marker, Map source) {\n+        String startMark = marker + \"{\";\n+        int markLen = startMark.length();\n+        \n+        int index = 0;\n+        for(;;)\n+        {\n+            index = str.indexOf(startMark, index);\n+            if (index == -1)\n+            {\n+                return str;\n+            }\n+            \n+            int startIndex = index + markLen;\n+            if (startIndex > str.length())\n+            {\n+                throw new IllegalArgumentException(\n+                    \"var expression starts at end of string\");\n+            }\n+            \n+            int endIndex = str.indexOf(\"}\", index + markLen);\n+            if (endIndex == -1)\n+            {\n+                throw new IllegalArgumentException(\n+                    \"var expression starts but does not end\");\n+            }\n+            \n+            String key = str.substring(index+markLen, endIndex);\n+            Object value =  source.get(key);\n+            if (value == null) {\n+                throw new IllegalArgumentException(\n+                    \"parameter [\" + key + \"] is not defined.\");\n+            }\n+            String varValue = value.toString();\n+            \n+            str = str.substring(0, index) + varValue + str.substring(endIndex+1);\n+            index += varValue.length();\n+        }\n+    }\n+        \n+}\n+", "timestamp": 1094344648, "metainfo": ""}