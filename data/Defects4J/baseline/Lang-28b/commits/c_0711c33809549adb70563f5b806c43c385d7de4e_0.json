{"sha": "0711c33809549adb70563f5b806c43c385d7de4e", "log": "Update null handling in ExceptionUtils   ", "commit": "\n--- a/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+++ b/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n import java.util.StringTokenizer;\n \n import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.NullArgumentException;\n import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.SystemUtils;\n \n  * @author Stephen Colebourne\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 1.0\n- * @version $Id: ExceptionUtils.java,v 1.28 2003/07/26 00:43:08 ggregory Exp $\n+ * @version $Id: ExceptionUtils.java,v 1.29 2003/07/26 13:05:21 scolebourne Exp $\n  */\n public class ExceptionUtils {\n     \n     static final String WRAPPED_MARKER = \" [wrapped] \";\n \n     /**\n-     * <p>The names of methods commonly used to access a wrapped\n-     * exception.</p>\n+     * <p>The names of methods commonly used to access a wrapped exception.</p>\n      */\n     private static String[] CAUSE_METHOD_NAMES = {\n         \"getCause\",\n     };\n \n     /**\n-     * <p>Constructs a new <code>ExceptionUtils</code>. Protected to\n-     * discourage instantiation.</p>\n-     */\n-    protected ExceptionUtils() {\n-    }\n-\n+     * <p>The Method object for JDK1.4 getCause.</p>\n+     */\n+    private static final Method THROWABLE_CAUSE_METHOD;\n+    static {\n+        Method getCauseMethod;\n+        try {\n+            getCauseMethod = Throwable.class.getMethod(\"getCause\", null);\n+        } catch (Exception e) {\n+            getCauseMethod = null;\n+        }\n+        THROWABLE_CAUSE_METHOD = getCauseMethod;\n+    }\n+    \n+    /**\n+     * <p>Public constructor allows an instance of <code>ExceptionUtils</code>\n+     * to be created, although that is not normally necessary.</p>\n+     */\n+    public ExceptionUtils() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * <p>Adds to the list of method names used in the search for <code>Throwable</code>\n      * objects.</p>\n      *  and empty strings are ignored\n      */\n     public static void addCauseMethodName(String methodName) {\n-      if(StringUtils.isNotEmpty(methodName)) {\n+        if (StringUtils.isNotEmpty(methodName)) {\n             List list = new ArrayList(Arrays.asList(CAUSE_METHOD_NAMES));\n             list.add(methodName);\n             CAUSE_METHOD_NAMES = (String[]) list.toArray(new String[list.size()]);\n     }\n \n     /**\n-     * <p>Introspects the specified <code>Throwable</code> to obtain the cause.</p>\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n      * \n      * <p>The method searches for methods with specific names that return a \n      * <code>Throwable</code> object. This will pick up most wrapping exceptions,\n      * \n      * <p>If none of the above is found, returns <code>null</code>.</p>\n      *\n-     * @param throwable The exception to introspect for a cause.\n-     * @return The cause of the <code>Throwable</code>.\n-     * @throws NullPointerException if the throwable is <code>null</code>\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n      */\n     public static Throwable getCause(Throwable throwable) {\n         return getCause(throwable, CAUSE_METHOD_NAMES);\n     }\n \n     /**\n-     * <p>Introspects the specified <code>Throwable</code> to obtain the cause\n-     * using a supplied array of method names.</p>\n-     *\n-     * @param throwable The exception to introspect for a cause.\n-     * @return The cause of the <code>Throwable</code>.\n-     * @throws NullPointerException if the method names array is <code>null</code>\n-     *  or contains <code>null</code>\n-     * @throws NullPointerException if the throwable is <code>null</code>\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     * \n+     * <ol>\n+     * <li>Try known exception types.</p>\n+     * <li>Try the supplied array of method names.</p>\n+     * <li>Try the field 'detail'.</p>\n+     * </ol>\n+     * \n+     * <p>A <code>null</code> set of method names means use the default set.\n+     * A <code>null</code> in the set of method names will be ignored.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @param methodNames  the method names, null treated as default set\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n      */\n     public static Throwable getCause(Throwable throwable, String[] methodNames) {\n+        if (throwable == null) {\n+            return null;\n+        }\n         Throwable cause = getCauseUsingWellKnownTypes(throwable);\n         if (cause == null) {\n+            if (methodNames == null) {\n+                methodNames = CAUSE_METHOD_NAMES;\n+            }\n             for (int i = 0; i < methodNames.length; i++) {\n-                cause = getCauseUsingMethodName(throwable, methodNames[i]);\n-                if (cause != null) {\n-                    break;\n+                String methodName = methodNames[i];\n+                if (methodName != null) {\n+                    cause = getCauseUsingMethodName(throwable, methodName);\n+                    if (cause != null) {\n+                        break;\n+                    }\n                 }\n             }\n \n     }\n \n     /**\n-     * <p>Walks through the exception chain to the last element -- the\n-     * \"root\" of the tree -- using {@link #getCause(Throwable)}, and\n+     * <p>Introspects the <code>Throwable</code> to obtain the root cause.</p>\n+     * \n+     * <p>This method walks through the exception chain to the last element,\n+     * \"root\" of the tree, using {@link #getCause(Throwable)}, and\n      * returns that exception.</p>\n      *\n-     * @param throwable  the throwable to get the root cause for\n-     * @return The root cause of the <code>Throwable</code>.\n+     * @param throwable  the throwable to get the root cause for, may be null\n+     * @return the root cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n      */\n     public static Throwable getRootCause(Throwable throwable) {\n         Throwable cause = getCause(throwable);\n     }\n \n     /**\n+     * <p>Finds a <code>Throwable</code> for known types.</p>\n+     * \n      * <p>Uses <code>instanceof</code> checks to examine the exception,\n      * looking for well known types which could contain chained or\n      * wrapped exceptions.</p>\n      *\n      * @param throwable  the exception to examine\n-     * @return The wrapped exception, or <code>null</code> if not\n-     * found.\n+     * @return the wrapped exception, or <code>null</code> if not found\n      */\n     private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {\n         if (throwable instanceof Nestable) {\n      * \n      * @param throwable  the exception to examine\n      * @param methodName  the name of the method to find and invoke\n-     * @return The wrapped exception, or <code>null</code> if not\n-     *  found.\n+     * @return the wrapped exception, or <code>null</code> if not found\n      */\n     private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n         Method method = null;\n      * \n      * @param throwable  the exception to examine\n      * @param fieldName  the name of the attribute to examine\n-     * @return The wrapped exception, or <code>null</code> if not\n-     *  found.\n+     * @return the wrapped exception, or <code>null</code> if not found\n      */\n     private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {\n         Field field = null;\n         return null;\n     }\n \n-    /**\n-     * <p>Returns the number of <code>Throwable</code> objects in the\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the Throwable class has a <code>getCause</code> method.</p>\n+     * \n+     * <p>This is true for JDK 1.4 and above.</p>\n+     * \n+     * @return true if Throwable is nestable\n+     */\n+    public static boolean isThrowableNested() {\n+        return (THROWABLE_CAUSE_METHOD != null);\n+    }\n+    \n+    /**\n+     * <p>Checks whether this <code>Throwable</code> class can store a cause.</p>\n+     * \n+     * <p>This method does <b>not</b> check whether it actually does store a cause.<p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to examine, may be null\n+     * @return boolean <code>true</code> if nested otherwise <code>false</code>\n+     */\n+    public static boolean isNestedThrowable(Throwable throwable) {\n+        if (throwable == null) {\n+            return false;\n+        }\n+\n+        if (throwable instanceof Nestable) {\n+            return true;\n+        } else if (throwable instanceof SQLException) {\n+            return true;\n+        } else if (throwable instanceof InvocationTargetException) {\n+            return true;\n+        } else if (isThrowableNested()) {\n+            return true;\n+        }\n+\n+        Class cls = throwable.getClass();\n+        for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i < isize; i++) {\n+            try {\n+                Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], null);\n+                if (method != null) {\n+                    return true;\n+                }\n+            } catch (NoSuchMethodException ignored) {\n+            } catch (SecurityException ignored) {\n+            }\n+        }\n+\n+        try {\n+            Field field = cls.getField(\"detail\");\n+            if (field != null) {\n+                return true;\n+            }\n+        } catch (NoSuchFieldException ignored) {\n+        } catch (SecurityException ignored) {\n+        }\n+\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts the number of <code>Throwable</code> objects in the\n      * exception chain.</p>\n-     *\n-     * @param throwable  the exception to inspect\n-     * @return The throwable count.\n+     * \n+     * <p>A throwable without cause will return <code>1</code>.\n+     * A throwable with one cause will return <code>2</code> and so on.\n+     * A <code>null</code> throwable will return <code>0</code>.</p>\n+     * \n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the count of throwables, zero if null input\n      */\n     public static int getThrowableCount(Throwable throwable) {\n-        // Count the number of throwables\n         int count = 0;\n         while (throwable != null) {\n             count++;\n     /**\n      * <p>Returns the list of <code>Throwable</code> objects in the\n      * exception chain.</p>\n-     *\n-     * @param throwable  the exception to inspect\n-     * @return The list of <code>Throwable</code> objects.\n+     * \n+     * <p>A throwable without cause will return an array containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return an array containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return an array size zero.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the array of throwables, never null\n      */\n     public static Throwable[] getThrowables(Throwable throwable) {\n         List list = new ArrayList();\n         return (Throwable[]) list.toArray(new Throwable[list.size()]);\n     }\n \n-    /**\n-     * <p>Delegates to {@link #indexOfThrowable(Throwable, Class, int)},\n-     * starting the search at the beginning of the exception chain.</p>\n-     *\n-     * @see #indexOfThrowable(Throwable, Class, int)\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain.</p>\n+     * \n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for\n+     * @return the index into the throwable chain, -1 if no match or null input\n      */\n     public static int indexOfThrowable(Throwable throwable, Class type) {\n         return indexOfThrowable(throwable, type, 0);\n     }\n \n     /**\n-     * <p>Returns the (zero based) index, of the first\n-     * <code>Throwable</code> that matches the specified type in the\n-     * exception chain of <code>Throwable</code> objects with an index\n-     * greater than or equal to the specified index, or\n-     * <code>-1</code> if the type is not found.</p>\n-     *\n-     * @param throwable  the exception to inspect\n-     * @param type  <code>Class</code> to look for\n-     * @param fromIndex  the (zero based) index of the starting\n-     *  position in the chain to be searched\n-     * @return the first occurrence of the type in the chain, or\n-     *  <code>-1</code> if the type is not found\n-     * @throws IndexOutOfBoundsException If the <code>fromIndex</code>\n-     *  argument is negative or not less than the count of\n-     *  <code>Throwable</code>s in the chain.\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.</p>\n+     * \n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n      */\n     public static int indexOfThrowable(Throwable throwable, Class type, int fromIndex) {\n+        if (throwable == null) {\n+            return -1;\n+        }\n         if (fromIndex < 0) {\n-            throw new IndexOutOfBoundsException(\"Throwable index out of range: \" + fromIndex);\n+            fromIndex = 0;\n         }\n         Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n         if (fromIndex >= throwables.length) {\n-            throw new IndexOutOfBoundsException(\"Throwable index out of range: \" + fromIndex);\n+            return -1;\n         }\n         for (int i = fromIndex; i < throwables.length; i++) {\n             if (throwables[i].getClass().equals(type)) {\n         return -1;\n     }\n \n-    /**\n-     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n-     *\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable\n+     * to <code>System.err</code>.</p>\n+     * \n      * <p>The compact stack trace starts with the root cause and prints\n      * stack frames up to the place where it was caught and wrapped.\n      * Then it prints the wrapped exception and continues with stack frames\n      * until the wrapper exception is caught and wrapped again, etc.</p>\n      *\n-     * <p>The method is equivalent to t.printStackTrace() for throwables\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n      * that don't have nested causes.</p>\n-     */\n-    public static void printRootCauseStackTrace(Throwable t, PrintStream stream) {\n-        String trace[] = getRootCauseStackTrace(t);\n+     * \n+     * @param throwable  the throwable to output\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable) {\n+        printRootCauseStackTrace(throwable, System.err);\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     * \n+     * @param throwable  the throwable to output, may be null\n+     * @param stream  the stream to output to, may not be null\n+     * @throws IllegalArgumentException if the stream is <code>null</code>\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintStream stream) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (stream == null) {\n+            throw new NullArgumentException(\"PrintStream\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n         for (int i = 0; i < trace.length; i++) {\n             stream.println(trace[i]);\n         }\n     }\n \n     /**\n-     * <p>Calls <code>printRootCauseStackTraceprintRootCauseStackTrace</code>.</p>\n-     * Same as: <pre>printRootCauseStackTrace(t, System.err);</pre>\n-     * \n-     * @see #printRootCauseStackTrace(Throwable,PrintWriter)\n-     */\n-    public static void printRootCauseStackTrace(Throwable t) {\n-        printRootCauseStackTrace(t, System.err);\n-    }\n-\n-    /**\n-     * <p>Same as {@link #printRootCauseStackTrace(Throwable,java.io.PrintStream)},\n-     * except it takes a <code>PrintWriter</code> as an argument.</p>\n-     */\n-    public static void printRootCauseStackTrace(Throwable t, PrintWriter writer) {\n-        String trace[] = getRootCauseStackTrace(t);\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     * \n+     * @param throwable  the throwable to output, may be null\n+     * @param writer  the writer to output to, may not be null\n+     * @throws IllegalArgumentException if the writer is <code>null</code>\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintWriter writer) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (writer == null) {\n+            throw new NullArgumentException(\"PrintWriter\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n         for (int i = 0; i < trace.length; i++) {\n             writer.println(trace[i]);\n         }\n         writer.flush();\n     }\n \n+    //-----------------------------------------------------------------------\n     /**\n      * <p>Creates a compact stack trace for the root cause of the supplied\n      * <code>Throwable</code>.</p>\n-     */\n-    public static String[] getRootCauseStackTrace(Throwable t) {\n-        Throwable throwables[] = getThrowables(t);\n+     * \n+     * @param throwable  the throwable to examine, may be null\n+     * @return an array of stack trace frames, never null\n+     */\n+    public static String[] getRootCauseStackTrace(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        Throwable throwables[] = getThrowables(throwable);\n         int count = throwables.length;\n         ArrayList frames = new ArrayList();\n         List nextTrace = getStackFrameList(throwables[count - 1]);\n      * <p>Removes common frames from the cause trace given the two stack traces.</p>\n      * \n      * @param causeFrames  stack trace of a cause throwable\n-     * @param wrapperFrames stack trace of a wrapper throwable \n+     * @param wrapperFrames  stack trace of a wrapper throwable\n+     * @throws IllegalArgumentException if either argument is null\n      */\n     public static void removeCommonFrames(List causeFrames, List wrapperFrames) {\n+        if (causeFrames == null || wrapperFrames == null) {\n+            throw new NullArgumentException(\"List\");\n+        }\n         int causeFrameIndex = causeFrames.size() - 1;\n         int wrapperFrameIndex = wrapperFrames.size() - 1;\n         while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n         }\n     }\n \n-    /**\n-     * <p>A convenient way of extracting the stack trace from an\n-     * exception.</p>\n-     *\n-     * @param t The <code>Throwable</code>.\n-     * @return The stack trace as generated by the exception's\n-     *  <code>printStackTrace(PrintWriter)</code> method.\n-     */\n-    public static String getStackTrace(Throwable t) {\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the stack trace from a Throwable as a String.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the stack trace as generated by the exception's\n+     *  <code>printStackTrace(PrintWriter)</code> method\n+     */\n+    public static String getStackTrace(Throwable throwable) {\n         StringWriter sw = new StringWriter();\n         PrintWriter pw = new PrintWriter(sw, true);\n-        t.printStackTrace(pw);\n+        throwable.printStackTrace(pw);\n         return sw.getBuffer().toString();\n     }\n \n     /**\n      * <p>A way to get the entire nested stack-trace of an throwable.</p>\n      *\n-     * @param t The <code>Throwable</code>.\n-     * @return The nested stack trace, with the root cause first.\n-     */\n-    public static String getFullStackTrace(Throwable t) {\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the nested stack trace, with the root cause first\n+     */\n+    public static String getFullStackTrace(Throwable throwable) {\n         StringWriter sw = new StringWriter();\n         PrintWriter pw = new PrintWriter(sw, true);\n-        Throwable[] ts = getThrowables(t);\n-        for(int i=0; i<ts.length; i++) {\n+        Throwable[] ts = getThrowables(throwable);\n+        for (int i = 0; i < ts.length; i++) {\n             ts[i].printStackTrace(pw);\n-            if(isNestedThrowable(ts[i])) {\n+            if (isNestedThrowable(ts[i])) {\n                 break;\n             }\n         }\n         return sw.getBuffer().toString();\n     }\n \n-    /**\n-     * <p>Returns whether a <code>Throwable</code> is considered nested\n-     * or not.</p>\n-     *\n-     * @param throwable  The <code>Throwable</code>.\n-     * @return boolean <code>true</code> if nested otherwise <code>false</code>\n-     */\n-    public static boolean isNestedThrowable(Throwable throwable) {\n-        if(throwable == null) {\n-            return false;\n-        }\n-\n-        if (throwable instanceof Nestable) {\n-            return true;\n-        } else if (throwable instanceof SQLException) {\n-            return true;\n-        } else if (throwable instanceof InvocationTargetException) {\n-            return true;\n-        }\n-\n-        int sz = CAUSE_METHOD_NAMES.length;\n-        for(int i=0; i<sz; i++) {\n-            try {\n-                Method method = throwable.getClass().getMethod(CAUSE_METHOD_NAMES[i], null);\n-                if(method != null) {\n-                    return true;\n-                }\n-            } catch (NoSuchMethodException ignored) {\n-            } catch (SecurityException ignored) {\n-            }\n-        }\n-\n-        try {\n-            Field field = throwable.getClass().getField(\"detail\");\n-            if(field != null) {\n-                return true;\n-            }\n-        } catch (NoSuchFieldException ignored) {\n-        } catch (SecurityException ignored) {\n-        }\n-\n-        return false;\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * <p>Captures the stack trace associated with the specified\n      * <code>Throwable</code> object, decomposing it into a list of\n      * stack frames.</p>\n      *\n-     * @param t The <code>Throwable</code>.\n-     * @return  An array of strings describing each stack frame.\n-     */\n-    public static String[] getStackFrames(Throwable t) {\n-        return getStackFrames(getStackTrace(t));\n+     * @param throwable  the <code>Throwable</code> to exaamine, may be null\n+     * @return an array of strings describing each stack frame, never null\n+     */\n+    public static String[] getStackFrames(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return getStackFrames(getStackTrace(throwable));\n     }\n \n     /**\n         while (frames.hasMoreTokens()) {\n             list.add(frames.nextToken());\n         }\n-        return (String[]) list.toArray(new String[] {\n-        });\n+        return (String[]) list.toArray(new String[list.size()]);\n     }\n \n     /**\n         return list;\n     }\n     \n-    private static Object getCauseMethod = null;\n-    static {\n-        try {\n-            getCauseMethod = Throwable.class.getMethod(\"getCause\", null);\n-        } catch (Exception e) {\n-            // ignore\n-        }\n-    }\n-    \n-    /**\n-     * <p>Checks if the Throwable class has a <code>getCause</code> method.</p>\n-     */\n-    public static boolean isThrowableNested() {\n-        return (getCauseMethod != null);\n-    }\n }\n--- a/src/java/org/apache/commons/lang/exception/NestableDelegate.java\n+++ b/src/java/org/apache/commons/lang/exception/NestableDelegate.java\n  * @author Sean C. Sullivan\n  * @author Stephen Colebourne\n  * @since 1.0\n- * @version $Id: NestableDelegate.java,v 1.16 2003/07/25 23:05:22 ggregory Exp $\n+ * @version $Id: NestableDelegate.java,v 1.17 2003/07/26 13:05:21 scolebourne Exp $\n  */\n public class NestableDelegate implements Serializable {\n \n     \n     /**\n      * Whether to print the stack trace top-down.\n+     * This public flag may be set by calling code, typically in initialisation.\n      */\n     public static boolean topDown = true;\n     \n     /**\n      * Whether to trim the repeated stack trace.\n+     * This public flag may be set by calling code, typically in initialisation.\n      */\n     public static boolean trimStackFrames = true;\n \n      * chain\n      */\n     public int indexOfThrowable(Class type, int fromIndex) {\n-        return ExceptionUtils.indexOfThrowable(this.nestable, type, fromIndex);\n+        if (fromIndex < 0) {\n+            throw new IndexOutOfBoundsException(\"The start index was out of bounds: \" + fromIndex);\n+        }\n+        Throwable[] throwables = ExceptionUtils.getThrowables(this.nestable);\n+        if (fromIndex >= throwables.length) {\n+            throw new IndexOutOfBoundsException(\"The start index was out of bounds: \"\n+                + fromIndex + \" >= \" + throwables.length);\n+        }\n+        for (int i = fromIndex; i < throwables.length; i++) {\n+            if (throwables[i].getClass().equals(type)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n     }\n \n     /**", "timestamp": 1059224721, "metainfo": ""}