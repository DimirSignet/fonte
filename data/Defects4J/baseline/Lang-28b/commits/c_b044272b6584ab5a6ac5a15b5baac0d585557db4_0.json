{"sha": "b044272b6584ab5a6ac5a15b5baac0d585557db4", "log": "Genericize some more classes  ", "commit": "\n--- a/src/java/org/apache/commons/lang/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang/ArrayUtils.java\n     /**\n      * An empty immutable <code>Class</code> array.\n      */\n-    public static final Class[] EMPTY_CLASS_ARRAY = new Class[0];\n+    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n     /**\n      * An empty immutable <code>String</code> array.\n      */\n      * @throws IllegalArgumentException  if the array contains elements other\n      *  than {@link java.util.Map.Entry} and an Array\n      */\n-    public static Map toMap(Object[] array) {\n+    public static Map<Object, Object> toMap(Object[] array) {\n         if (array == null) {\n             return null;\n         }\n-        final Map map = new HashMap((int) (array.length * 1.5));\n+        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n         for (int i = 0; i < array.length; i++) {\n             Object object = array[i];\n             if (object instanceof Map.Entry) {\n             endIndexExclusive = array.length;\n         }\n         int newSize = endIndexExclusive - startIndexInclusive;\n-        Class type = array.getClass().getComponentType();\n+        Class<?> type = array.getClass().getComponentType();\n         if (newSize <= 0) {\n             return (Object[]) Array.newInstance(type, 0);\n         }\n      * @since 2.1\n      */\n     public static Object[] add(Object[] array, Object element) {\n-        Class type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);\n+        Class<?> type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);\n         Object[] newArray = (Object[]) copyArrayGrow1(array, type);\n         newArray[newArray.length - 1] = element;\n         return newArray;\n      * size 1 array of this type.\n      * @return A new copy of the array of size 1 greater than the input.\n      */    \n-    private static Object copyArrayGrow1(Object array, Class newArrayComponentType) {\n+    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n         if (array != null) {\n             int arrayLength = Array.getLength(array);\n             Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n      * (index < 0 || index > array.length).\n      */\n     public static Object[] add(Object[] array, int index, Object element) {\n-        Class clss = null;\n+        Class<?> clss = null;\n         if (array != null) {\n             clss = array.getClass().getComponentType();\n         } else if (element != null) {\n      * @param clss the type of the element being added\n      * @return A new array containing the existing elements and the new element\n      */\n-    private static Object add(Object array, int index, Object element, Class clss) {\n+    private static Object add(Object array, int index, Object element, Class<?> clss) {\n         if (array == null) {\n             if (index != 0) {\n                 throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n     /**\n      * Maps primitive <code>Class</code>es to their corresponding wrapper <code>Class</code>.\n      */\n-    private static final Map primitiveWrapperMap = new HashMap();\n+    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>();\n     static {\n          primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n          primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n     /**\n      * Maps wrapper <code>Class</code>es to their corresponding primitive types.\n      */\n-    private static final Map wrapperPrimitiveMap = new HashMap();\n+    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n     static {\n-        for (Iterator it = primitiveWrapperMap.keySet().iterator(); it.hasNext();) {\n-            Class primitiveClass = (Class) it.next();\n-            Class wrapperClass = (Class) primitiveWrapperMap.get(primitiveClass);\n+        for (Iterator<Class<?>> it = primitiveWrapperMap.keySet().iterator(); it.hasNext();) {\n+            Class<?> primitiveClass = it.next();\n+            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n             if (!primitiveClass.equals(wrapperClass)) {\n                 wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n             }\n     /**\n      * Maps a primitive class name to its corresponding abbreviation used in array class names.\n      */\n-    private static final Map abbreviationMap = new HashMap();\n+    private static final Map<String, String> abbreviationMap = new HashMap<String, String>();\n \n     /**\n      * Maps an abbreviation used in array class names to corresponding primitive class name.\n      */\n-    private static final Map reverseAbbreviationMap = new HashMap();\n+    private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>();\n \n     /**\n      * Add primitive type abbreviation to maps of abbreviations.\n      * @param cls  the class to get the short name for.\n      * @return the class name without the package name or an empty string\n      */\n-    public static String getShortClassName(Class cls) {\n+    public static String getShortClassName(Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @param cls  the class to get the package name for, may be <code>null</code>.\n      * @return the package name or an empty string\n      */\n-    public static String getPackageName(Class cls) {\n+    public static String getPackageName(Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @return the <code>List</code> of interfaces in order,\n      *  <code>null</code> if null input\n      */\n-    public static List getAllInterfaces(Class cls) {\n+    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n         if (cls == null) {\n             return null;\n         }\n-        List list = new ArrayList();\n+        List<Class<?>> list = new ArrayList<Class<?>>();\n         while (cls != null) {\n-            Class[] interfaces = cls.getInterfaces();\n+            Class<?>[] interfaces = cls.getInterfaces();\n             for (int i = 0; i < interfaces.length; i++) {\n                 if (list.contains(interfaces[i]) == false) {\n                     list.add(interfaces[i]);\n                 }\n-                List superInterfaces = getAllInterfaces(interfaces[i]);\n-                for (Iterator it = superInterfaces.iterator(); it.hasNext();) {\n-                    Class intface = (Class) it.next();\n+                List<Class<?>> superInterfaces = getAllInterfaces(interfaces[i]);\n+                for (Iterator<Class<?>> it = superInterfaces.iterator(); it.hasNext();) {\n+                    Class<?> intface = it.next();\n                     if (list.contains(intface) == false) {\n                         list.add(intface);\n                     }\n      *  <code>null</code> if null input\n      * @throws ClassCastException if classNames contains a non String entry\n      */\n-    public static List convertClassNamesToClasses(List classNames) {\n+    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n         if (classNames == null) {\n             return null;\n         }\n-        List classes = new ArrayList(classNames.size());\n-        for (Iterator it = classNames.iterator(); it.hasNext();) {\n-            String className = (String) it.next();\n+        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n+        for (Iterator<String> it = classNames.iterator(); it.hasNext();) {\n+            String className = it.next();\n             try {\n                 classes.add(Class.forName(className));\n             } catch (Exception ex) {\n      *  <code>null</code> if null input\n      * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry\n      */\n-    public static List convertClassesToClassNames(List classes) {\n+    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n         if (classes == null) {\n             return null;\n         }\n-        List classNames = new ArrayList(classes.size());\n-        for (Iterator it = classes.iterator(); it.hasNext();) {\n-            Class cls = (Class) it.next();\n+        List<String> classNames = new ArrayList<String>(classes.size());\n+        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {\n+            Class<?> cls = it.next();\n             if (cls == null) {\n                 classNames.add(null);\n             } else {\n      * @return <code>true</code> if assignment possible\n      */\n     //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n-    public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n         return isAssignable(classArray, toClassArray, false);\n     }\n \n      * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n      * @return <code>true</code> if assignment possible\n      */\n-    public static boolean isAssignable(Class[] classArray, Class[] toClassArray, boolean autoboxing) {\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n         if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n             return false;\n         }\n      * @return <code>true</code> if assignment possible\n      */\n     //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n-    public static boolean isAssignable(Class cls, Class toClass) {\n+    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n         return isAssignable(cls, toClass, false);\n     }\n \n      * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n      * @return <code>true</code> if assignment possible\n      */\n-    public static boolean isAssignable(Class cls, Class toClass, boolean autoboxing) {\n+    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n         if (toClass == null) {\n             return false;\n         }\n      * <code>cls</code> is not a primitive. <code>null</code> if null input.\n      * @since 2.1\n      */\n-    public static Class primitiveToWrapper(Class cls) {\n-        Class convertedClass = cls;\n+    public static Class<?> primitiveToWrapper(Class<?> cls) {\n+        Class<?> convertedClass = cls;\n         if (cls != null && cls.isPrimitive()) {\n-            convertedClass = (Class) primitiveWrapperMap.get(cls);\n+            convertedClass = primitiveWrapperMap.get(cls);\n         }\n         return convertedClass;\n     }\n      * Empty array if an empty array passed in.\n      * @since 2.1\n      */\n-    public static Class[] primitivesToWrappers(Class[] classes) {\n+    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n         if (classes == null) {\n             return null;\n         }\n             return classes;\n         }\n \n-        Class[] convertedClasses = new Class[classes.length];\n+        Class<?>[] convertedClasses = new Class[classes.length];\n         for (int i = 0; i < classes.length; i++) {\n             convertedClasses[i] = primitiveToWrapper(classes[i]);\n         }\n      * @see #primitiveToWrapper(Class)\n      * @since 2.4\n      */\n-    public static Class wrapperToPrimitive(Class cls) {\n-        return (Class) wrapperPrimitiveMap.get(cls);\n+    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n+        return wrapperPrimitiveMap.get(cls);\n     }\n \n     /**\n      * @see #wrapperToPrimitive(Class)\n      * @since 2.4\n      */\n-    public static Class[] wrappersToPrimitives(Class[] classes) {\n+    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n         if (classes == null) {\n             return null;\n         }\n             return classes;\n         }\n \n-        Class[] convertedClasses = new Class[classes.length];\n+        Class<?>[] convertedClasses = new Class[classes.length];\n         for (int i = 0; i < classes.length; i++) {\n             convertedClasses[i] = wrapperToPrimitive(classes[i]);\n         }\n      * @return <code>true</code> if the class is an inner or static nested class,\n      *  false if not or <code>null</code>\n      */\n-    public static boolean isInnerClass(Class cls) {\n+    public static boolean isInnerClass(Class<?> cls) {\n         if (cls == null) {\n             return false;\n         }\n      * @return the class represented by <code>className</code> using the <code>classLoader</code>\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass(\n+    public static Class<?> getClass(\n             ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n-        Class clazz;\n+        Class<?> clazz;\n         if (abbreviationMap.containsKey(className)) {\n             String clsName = \"[\" + abbreviationMap.get(className);\n             clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n      * @return the class represented by <code>className</code> using the <code>classLoader</code>\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n+    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n         return getClass(classLoader, className, true);\n     }\n \n      * @return the class represented by <code>className</code> using the current thread's context class loader\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass(String className) throws ClassNotFoundException {\n+    public static Class<?> getClass(String className) throws ClassNotFoundException {\n         return getClass(className, true);\n     }\n \n      * @return the class represented by <code>className</code> using the current thread's context class loader\n      * @throws ClassNotFoundException if the class is not found\n      */\n-    public static Class getClass(String className, boolean initialize) throws ClassNotFoundException {\n+    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n         ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n         ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n         return getClass(loader, className, initialize );\n      * @throws NoSuchMethodException if the method is not found in the given class\n      *  or if the metothod doen't conform with the requirements\n      */\n-    public static Method getPublicMethod(Class cls, String methodName, Class parameterTypes[])\n+    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[])\n             throws SecurityException, NoSuchMethodException {\n \n         Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n             return declaredMethod;\n         }\n \n-        List candidateClasses = new ArrayList();\n+        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n         candidateClasses.addAll(getAllInterfaces(cls));\n         candidateClasses.addAll(getAllSuperclasses(cls));\n \n-        for (Iterator it = candidateClasses.iterator(); it.hasNext(); ) {\n-            Class candidateClass = (Class) it.next();\n+        for (Iterator<Class<?>> it = candidateClasses.iterator(); it.hasNext(); ) {\n+            Class<?> candidateClass = it.next();\n             if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                 continue;\n             }\n                 className = className.substring(0, className.length() - 2);\n                 classNameBuffer.append(\"[\");\n             }\n-            String abbreviation = (String) abbreviationMap.get(className);\n+            String abbreviation = abbreviationMap.get(className);\n             if (abbreviation != null) {\n                 classNameBuffer.append(abbreviation);\n             } else {\n      * @return a <code>Class</code> array, <code>null</code> if null array input\n      * @since 2.4\n      */\n-    public static Class[] toClass(Object[] array) {\n+    public static Class<?>[] toClass(Object[] array) {\n         if (array == null) {\n             return null;\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n-        Class[] classes = new Class[array.length];\n+        Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n             classes[i] = array[i].getClass();\n         }\n      * @return the canonical name without the package name or an empty string\n      * @since 2.4\n      */\n-    public static String getShortCanonicalName(Class cls) {\n+    public static String getShortCanonicalName(Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n      * @return the package name or an empty string\n      * @since 2.4\n      */\n-    public static String getPackageCanonicalName(Class cls) {\n+    public static String getPackageCanonicalName(Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n                             : className.length());\n                 } else {\n                     if (className.length() > 0) {\n-                        className = (String) reverseAbbreviationMap.get(\n-                            className.substring(0, 1));\n+                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n                     }\n                 }\n                 StringBuffer canonicalClassNameBuffer = new StringBuffer(className);\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n     }\n \n     static class PrimitiveEntityMap implements EntityMap {\n-        private final Map mapNameToValue = new HashMap();\n+        private final Map<String, Integer> mapNameToValue = new HashMap<String, Integer>();\n \n         private final IntHashMap mapValueToName = new IntHashMap();\n \n     }\n \n     static abstract class MapIntMap implements Entities.EntityMap {\n-        protected Map mapNameToValue;\n-\n-        protected Map mapValueToName;\n+        protected Map<String, Integer> mapNameToValue;\n+\n+        protected Map<Integer, String> mapValueToName;\n \n         /**\n          * {@inheritDoc}\n          * {@inheritDoc}\n          */\n         public String name(int value) {\n-            return (String) mapValueToName.get(new Integer(value));\n+            return mapValueToName.get(new Integer(value));\n         }\n \n         /**\n          * Constructs a new instance of <code>HashEntityMap</code>.\n          */\n         public HashEntityMap() {\n-            mapNameToValue = new HashMap();\n-            mapValueToName = new HashMap();\n+            mapNameToValue = new HashMap<String, Integer>();\n+            mapValueToName = new HashMap<Integer, String>();\n         }\n     }\n \n          * Constructs a new instance of <code>TreeEntityMap</code>.\n          */\n         public TreeEntityMap() {\n-            mapNameToValue = new TreeMap();\n-            mapValueToName = new TreeMap();\n+            mapNameToValue = new TreeMap<String, Integer>();\n+            mapValueToName = new TreeMap<Integer, String>();\n         }\n     }\n \n--- a/src/java/org/apache/commons/lang/IllegalClassException.java\n+++ b/src/java/org/apache/commons/lang/IllegalClassException.java\n      * @param actual  the actual object\n      * @since 2.1\n      */\n-    public IllegalClassException(Class expected, Object actual) {\n+    public IllegalClassException(Class<?> expected, Object actual) {\n         super(\n             \"Expected: \"\n                 + safeGetClassName(expected)\n      * @param expected  the expected type\n      * @param actual  the actual type\n      */\n-    public IllegalClassException(Class expected, Class actual) {\n+    public IllegalClassException(Class<?> expected, Class<?> actual) {\n         super(\n             \"Expected: \"\n                 + safeGetClassName(expected)\n      * @param cls  a <code>Class</code>\n      * @return the name of <code>cls</code>, or <code>null</code> if if <code>cls</code> is <code>null</code>.\n      */\n-    private static final String safeGetClassName(Class cls) {\n+    private static final String safeGetClassName(Class<?> cls) {\n         return cls == null ? null : cls.getName();\n     }\n \n--- a/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/CompareToBuilder.java\n      *  with <code>lhs</code>\n      * @since 2.2\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, Collection /*String*/ excludeFields) {\n+    public static int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields) {\n         return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n      * @since 2.0\n      */\n     public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, \n-                                        Class reflectUpToClass) \n+                                        Class<?> reflectUpToClass) \n     {\n         return reflectionCompare(lhs, rhs, false, reflectUpToClass, null);\n     }\n         Object lhs, \n         Object rhs, \n         boolean compareTransients, \n-        Class reflectUpToClass, \n+        Class<?> reflectUpToClass, \n         String[] excludeFields) {\n \n         if (lhs == rhs) {\n         if (lhs == null || rhs == null) {\n             throw new NullPointerException();\n         }\n-        Class lhsClazz = lhs.getClass();\n+        Class<?> lhsClazz = lhs.getClass();\n         if (!lhsClazz.isInstance(rhs)) {\n             throw new ClassCastException();\n         }\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n-        Class clazz,\n+        Class<?> clazz,\n         CompareToBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n--- a/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/EqualsBuilder.java\n      * @param excludeFields  Collection of String field names to exclude from testing\n      * @return <code>true</code> if the two Objects have tested equals.\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, Collection /*String*/ excludeFields) {\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n         return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n      * @return <code>true</code> if the two Objects have tested equals.\n      * @since 2.0\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {\n         return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n     }\n \n      * @return <code>true</code> if the two Objects have tested equals.\n      * @since 2.0\n      */\n-    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass,\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n             String[] excludeFields) {\n         if (lhs == rhs) {\n             return true;\n         // class or in classes between the leaf and root.\n         // If we are not testing transients or a subclass has no ivars, \n         // then a subclass can test equals to a superclass.\n-        Class lhsClass = lhs.getClass();\n-        Class rhsClass = rhs.getClass();\n-        Class testClass;\n+        Class<?> lhsClass = lhs.getClass();\n+        Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n         if (lhsClass.isInstance(rhs)) {\n             testClass = lhsClass;\n             if (!rhsClass.isInstance(lhs)) {\n     private static void reflectionAppend(\n         Object lhs,\n         Object rhs,\n-        Class clazz,\n+        Class<?> clazz,\n         EqualsBuilder builder,\n         boolean useTransients,\n         String[] excludeFields) {\n             this.setEquals(false);\n             return this;\n         }\n-        Class lhsClass = lhs.getClass();\n+        Class<?> lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n             if (lhs instanceof java.math.BigDecimal && rhs instanceof java.math.BigDecimal) {\n                 isEquals = (((java.math.BigDecimal)lhs).compareTo((java.math.BigDecimal)rhs) == 0);\n--- a/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/HashCodeBuilder.java\n      * \n      * @since 2.3\n      */\n-    private static final ThreadLocal registry = new ThreadLocal() {\n+    private static final ThreadLocal<Set<IDKey>> registry = new ThreadLocal<Set<IDKey>>() {\n         @Override\n-        protected Object initialValue() {\n+        protected Set<IDKey> initialValue() {\n             // The HashSet implementation is not synchronized,\n             // which is just what we need here.\n-            return new HashSet();\n+            return new HashSet<IDKey>();\n         }\n     };\n \n      * @return Set the registry of objects being traversed\n      * @since 2.3\n      */\n-    static Set getRegistry() {\n-        return (Set) registry.get();\n+    static Set<IDKey> getRegistry() {\n+        return registry.get();\n     }\n \n     /**\n      * @param excludeFields\n      *            Collection of String field names to exclude from use in calculation of hash code\n      */\n-    private static void reflectionAppend(Object object, Class clazz, HashCodeBuilder builder, boolean useTransients,\n+    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n             String[] excludeFields) {\n         if (isRegistered(object)) {\n             return;\n      * @return int hash code\n      */\n     public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n-            boolean testTransients, Class reflectUpToClass) {\n+            boolean testTransients, Class<?> reflectUpToClass) {\n         return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n                 reflectUpToClass, null);\n     }\n      * @since 2.0\n      */\n     public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n-            boolean testTransients, Class reflectUpToClass, String[] excludeFields) {\n+            boolean testTransients, Class<?> reflectUpToClass, String[] excludeFields) {\n \n         if (object == null) {\n             throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n         }\n         HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n-        Class clazz = object.getClass();\n+        Class<?> clazz = object.getClass();\n         reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n         while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n             clazz = clazz.getSuperclass();\n      * @throws IllegalArgumentException\n      *             if the object is <code>null</code>\n      */\n-    public static int reflectionHashCode(Object object, Collection /* String */excludeFields) {\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n         return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n     }\n \n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n      * @since 2.1\n      */\n     public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics,\n-            Class reflectUpToClass) {\n+            Class<?> reflectUpToClass) {\n         return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                 .toString();\n     }\n      *            The field names to exclude. Null excludes nothing.\n      * @return The toString value.\n      */\n-    public static String toStringExclude(Object object, Collection /*String*/ excludeFieldNames) {\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n         return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n     }\n \n      *            The collection to convert\n      * @return A new array of Strings.\n      */\n-    static String[] toNoNullStringArray(Collection collection) {\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n         if (collection == null) {\n             return ArrayUtils.EMPTY_STRING_ARRAY;\n         }\n      * @return The given array or a new array without null.\n      */\n     static String[] toNoNullStringArray(Object[] array) {\n-        ArrayList list = new ArrayList(array.length);\n+        ArrayList<String> list = new ArrayList<String>(array.length);\n         for (int i = 0; i < array.length; i++) {\n             Object e = array[i];\n             if (e != null) {\n                 list.add(e.toString());\n             }\n         }\n-        return (String[]) list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n     }\n     \n \n     /**\n      * The last super class to stop appending fields for.\n      */\n-    private Class upToClass = null;\n+    private Class<?> upToClass = null;\n \n     /**\n      * <p>\n      *            whether to include static fields\n      * @since 2.1\n      */\n-    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class reflectUpToClass,\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class<?> reflectUpToClass,\n             boolean outputTransients, boolean outputStatics) {\n         super(object, style, buffer);\n         this.setUpToClass(reflectUpToClass);\n      * @param clazz\n      *            The class of object parameter\n      */\n-    protected void appendFieldsIn(Class clazz) {\n+    protected void appendFieldsIn(Class<?> clazz) {\n         if (clazz.isArray()) {\n             this.reflectionAppendArray(this.getObject());\n             return;\n      * \n      * @return The last super class to stop appending fields for.\n      */\n-    public Class getUpToClass() {\n+    public Class<?> getUpToClass() {\n         return this.upToClass;\n     }\n \n      * @param clazz\n      *            The last super class to stop appending fields for.\n      */\n-    public void setUpToClass(Class clazz) {\n+    public void setUpToClass(Class<?> clazz) {\n         this.upToClass = clazz;\n     }\n \n         if (this.getObject() == null) {\n             return this.getStyle().getNullText();\n         }\n-        Class clazz = this.getObject().getClass();\n+        Class<?> clazz = this.getObject().getClass();\n         this.appendFieldsIn(clazz);\n         while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n             clazz = clazz.getSuperclass();\n--- a/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n      * to detect cyclical object references and avoid infinite loops.\n      * </p>\n      */\n-    private static final ThreadLocal registry = new ThreadLocal() {\n+    private static final ThreadLocal<Set<Object>> registry = new ThreadLocal<Set<Object>>() {\n         @Override\n-        protected Object initialValue() {\n+        protected Set<Object> initialValue() {\n             // The HashSet implementation is not synchronized,\n             // which is just what we need here.\n-            return new HashSet();\n+            return new HashSet<Object>();\n         }\n     };\n \n      * \n      * @return Set the registry of objects being traversed\n      */\n-    static Set getRegistry() {\n-        return (Set) registry.get();\n+    static Set<Object> getRegistry() {\n+        return registry.get();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/lang/reflect/ConstructorUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/ConstructorUtils.java\n      *\n      * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n      */\n-    public static Object invokeConstructor(Class cls, Object arg)\n+    public static Object invokeConstructor(Class<?> cls, Object arg)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException, InstantiationException {\n         return invokeConstructor(cls, new Object[] { arg });\n      *\n      * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n      */\n-    public static Object invokeConstructor(Class cls, Object[] args)\n+    public static Object invokeConstructor(Class<?> cls, Object[] args)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException, InstantiationException {\n         if (null == args) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n-        Class parameterTypes[] = new Class[args.length];\n+        Class<?> parameterTypes[] = new Class[args.length];\n         for (int i = 0; i < args.length; i++) {\n             parameterTypes[i] = args[i].getClass();\n         }\n      * @throws InstantiationException thrown on the constructor's invocation\n      * @see Constructor#newInstance\n      */\n-    public static Object invokeConstructor(Class cls, Object[] args,\n-            Class[] parameterTypes) throws NoSuchMethodException,\n+    public static Object invokeConstructor(Class<?> cls, Object[] args,\n+            Class<?>[] parameterTypes) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException,\n             InstantiationException {\n         if (parameterTypes == null) {\n      *\n      * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n      */\n-    public static Object invokeExactConstructor(Class cls, Object arg)\n+    public static Object invokeExactConstructor(Class<?> cls, Object arg)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException, InstantiationException {\n         return invokeExactConstructor(cls, new Object[] { arg });\n      *\n      * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n      */\n-    public static Object invokeExactConstructor(Class cls, Object[] args)\n+    public static Object invokeExactConstructor(Class<?> cls, Object[] args)\n             throws NoSuchMethodException, IllegalAccessException,\n             InvocationTargetException, InstantiationException {\n         if (null == args) {\n             args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n         }\n         int arguments = args.length;\n-        Class parameterTypes[] = new Class[arguments];\n+        Class<?> parameterTypes[] = new Class[arguments];\n         for (int i = 0; i < arguments; i++) {\n             parameterTypes[i] = args[i].getClass();\n         }\n      * @throws InstantiationException thrown on the constructor's invocation\n      * @see Constructor#newInstance\n      */\n-    public static Object invokeExactConstructor(Class cls, Object[] args,\n-            Class[] parameterTypes) throws NoSuchMethodException,\n+    public static Object invokeExactConstructor(Class<?> cls, Object[] args,\n+            Class<?>[] parameterTypes) throws NoSuchMethodException,\n             IllegalAccessException, InvocationTargetException,\n             InstantiationException {\n         if (args == null) {\n      * @see Class#getConstructor\n      * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n      */\n-    public static Constructor getAccessibleConstructor(Class cls,\n-            Class parameterType) {\n+    public static Constructor getAccessibleConstructor(Class<?> cls,\n+            Class<?> parameterType) {\n         return getAccessibleConstructor(cls, new Class[] { parameterType });\n     }\n \n      * @see Class#getConstructor\n      * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n      */\n-    public static Constructor getAccessibleConstructor(Class cls,\n-            Class[] parameterTypes) {\n+    public static Constructor getAccessibleConstructor(Class<?> cls,\n+            Class<?>[] parameterTypes) {\n         try {\n             return getAccessibleConstructor(cls.getConstructor(parameterTypes));\n         } catch (NoSuchMethodException e) {\n      * @param parameterTypes find method with compatible parameters\n      * @return a valid Constructor object. If there's no matching constructor, returns <code>null</code>.\n      */\n-    public static Constructor getMatchingAccessibleConstructor(Class cls,\n-            Class[] parameterTypes) {\n+    public static Constructor getMatchingAccessibleConstructor(Class<?> cls,\n+            Class<?>[] parameterTypes) {\n         // see if we can find the constructor directly\n         // most of the time this works and it's much faster\n         try {\n--- a/src/java/org/apache/commons/lang/reflect/FieldUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/FieldUtils.java\n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getField(Class cls, String fieldName) {\n+    public static Field getField(Class<?> cls, String fieldName) {\n         Field field = getField(cls, fieldName, false);\n         MemberUtils.setAccessibleWorkaround(field);\n         return field;\n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getField(final Class cls, String fieldName, boolean forceAccess) {\n+    public static Field getField(final Class<?> cls, String fieldName, boolean forceAccess) {\n         if (cls == null) {\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n         // implementedinterface public\n \n         // check up the superclass hierarchy\n-        for (Class acls = cls; acls != null; acls = acls.getSuperclass()) {\n+        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n             try {\n                 Field field = acls.getDeclaredField(fieldName);\n                 // getDeclaredField checks for non-public scopes as well\n         // incase there is a public supersuperclass field hidden by a private/package\n         // superclass field.\n         Field match = null;\n-        for (Iterator intf = ClassUtils.getAllInterfaces(cls).iterator(); intf\n+        for (Iterator<Class<?>> intf = ClassUtils.getAllInterfaces(cls).iterator(); intf\n                 .hasNext();) {\n             try {\n-                Field test = ((Class) intf.next()).getField(fieldName);\n+                Field test = ((Class<?>) intf.next()).getField(fieldName);\n                 if (match != null) {\n                     throw new IllegalArgumentException(\n                             \"Reference to field \"\n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getDeclaredField(Class cls, String fieldName) {\n+    public static Field getDeclaredField(Class<?> cls, String fieldName) {\n         return getDeclaredField(cls, fieldName, false);\n     }\n \n      * @return the Field object\n      * @throws IllegalArgumentException if the class or field name is null\n      */\n-    public static Field getDeclaredField(Class cls, String fieldName, boolean forceAccess) {\n+    public static Field getDeclaredField(Class<?> cls, String fieldName, boolean forceAccess) {\n         if (cls == null) {\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static Object readStaticField(Class cls, String fieldName) throws IllegalAccessException {\n+    public static Object readStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n         return readStaticField(cls, fieldName, false);\n     }\n \n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readStaticField(Class cls, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+    public static Object readStaticField(Class<?> cls, String fieldName, boolean forceAccess) throws IllegalAccessException {\n         Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the field is not accessible\n      */\n-    public static Object readDeclaredStaticField(Class cls, String fieldName) throws IllegalAccessException {\n+    public static Object readDeclaredStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n         return readDeclaredStaticField(cls, fieldName, false);\n     }\n \n      * @throws IllegalArgumentException if the class or field name is null\n      * @throws IllegalAccessException if the field is not made accessible\n      */\n-    public static Object readDeclaredStaticField(Class cls, String fieldName, boolean forceAccess)\n+    public static Object readDeclaredStaticField(Class<?> cls, String fieldName, boolean forceAccess)\n             throws IllegalAccessException {\n         Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class cls = target.getClass();\n+        Class<?> cls = target.getClass();\n         Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class cls = target.getClass();\n+        Class<?> cls = target.getClass();\n         Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not public or is final\n      */\n-    public static void writeStaticField(Class cls, String fieldName, Object value) throws IllegalAccessException {\n+    public static void writeStaticField(Class<?> cls, String fieldName, Object value) throws IllegalAccessException {\n         writeStaticField(cls, fieldName, value, false);\n     }\n \n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not made accessible or is final\n      */\n-    public static void writeStaticField(Class cls, String fieldName, Object value, boolean forceAccess)\n+    public static void writeStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n             throws IllegalAccessException {\n         Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not public or is final\n      */\n-    public static void writeDeclaredStaticField(Class cls, String fieldName, Object value)\n+    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value)\n             throws IllegalAccessException {\n         writeDeclaredStaticField(cls, fieldName, value, false);\n     }\n      * @throws IllegalArgumentException if the field cannot be located or is not static\n      * @throws IllegalAccessException if the field is not made accessible or is final\n       */\n-    public static void writeDeclaredStaticField(Class cls, String fieldName, Object value, boolean forceAccess)\n+    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n             throws IllegalAccessException {\n         Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class cls = target.getClass();\n+        Class<?> cls = target.getClass();\n         Field field = getField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n         if (target == null) {\n             throw new IllegalArgumentException(\"target object must not be null\");\n         }\n-        Class cls = target.getClass();\n+        Class<?> cls = target.getClass();\n         Field field = getDeclaredField(cls, fieldName, forceAccess);\n         if (field == null) {\n             throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n--- a/src/java/org/apache/commons/lang/reflect/MemberUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MemberUtils.java\n     }\n \n     /** Array of primitive number types ordered by \"promotability\" */\n-    private static final Class[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE,\n+    private static final Class<?>[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE,\n             Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE,\n             Double.TYPE };\n \n      * @param actual the runtime parameter types to match against <code>left</code>/<code>right</code>\n      * @return int consistent with <code>compare</code> semantics\n      */\n-    static int compareParameterTypes(Class[] left, Class[] right, Class[] actual) {\n+    static int compareParameterTypes(Class<?>[] left, Class<?>[] right, Class<?>[] actual) {\n         float leftCost = getTotalTransformationCost(actual, left);\n         float rightCost = getTotalTransformationCost(actual, right);\n         return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;\n      * @param destArgs The destination arguments\n      * @return The total transformation cost\n      */\n-    private static float getTotalTransformationCost(Class[] srcArgs,\n-            Class[] destArgs) {\n+    private static float getTotalTransformationCost(Class<?>[] srcArgs,\n+            Class<?>[] destArgs) {\n         float totalCost = 0.0f;\n         for (int i = 0; i < srcArgs.length; i++) {\n-            Class srcClass, destClass;\n+            Class<?> srcClass, destClass;\n             srcClass = srcArgs[i];\n             destClass = destArgs[i];\n             totalCost += getObjectTransformationCost(srcClass, destClass);\n      * @param destClass The destination class\n      * @return The cost of transforming an object\n      */\n-    private static float getObjectTransformationCost(Class srcClass,\n-            Class destClass) {\n+    private static float getObjectTransformationCost(Class<?> srcClass,\n+            Class<?> destClass) {\n         if (destClass.isPrimitive()) {\n             return getPrimitivePromotionCost(srcClass, destClass);\n         }\n      * @param destClass the (primitive) destination class\n      * @return The cost of promoting the primitive\n      */\n-    private static float getPrimitivePromotionCost(final Class srcClass,\n-            final Class destClass) {\n+    private static float getPrimitivePromotionCost(final Class<?> srcClass,\n+            final Class<?> destClass) {\n         float cost = 0.0f;\n-        Class cls = srcClass;\n+        Class<?> cls = srcClass;\n         if (!cls.isPrimitive()) {\n             // slight unwrapping penalty\n             cost += 0.1f;\n--- a/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n+++ b/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n      * @return the length change that occurs, unless priorVariables is null when the int\n      *  represents a boolean flag as to whether any change occurred.\n      */\n-    private int substitute(StrBuilder buf, int offset, int length, List priorVariables) {\n+    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n         StrMatcher prefixMatcher = getVariablePrefixMatcher();\n         StrMatcher suffixMatcher = getVariableSuffixMatcher();\n         char escape = getEscapeChar();\n                             \n                             // on the first call initialize priorVariables\n                             if (priorVariables == null) {\n-                                priorVariables = new ArrayList();\n+                                priorVariables = new ArrayList<String>();\n                                 priorVariables.add(new String(chars, offset, length));\n                             }\n                             \n      * @param varName  the variable name to check\n      * @param priorVariables  the list of prior variables\n      */\n-    private void checkCyclicSubstitution(String varName, List priorVariables) {\n+    private void checkCyclicSubstitution(String varName, List<String> priorVariables) {\n         if (priorVariables.contains(varName) == false) {\n             return;\n         }\n--- a/src/java/org/apache/commons/lang/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang/time/FastDateFormat.java\n     //@GuardedBy(\"this\")\n     private static String cDefaultPattern; // lazily initialised by getInstance()\n \n-    private static final Map cInstanceCache = new HashMap(7);\n-    private static final Map cDateInstanceCache = new HashMap(7);\n-    private static final Map cTimeInstanceCache = new HashMap(7);\n-    private static final Map cDateTimeInstanceCache = new HashMap(7);\n-    private static final Map cTimeZoneDisplayCache = new HashMap(7);\n+    private static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);\n \n     /**\n      * The pattern.\n      */\n     public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n         FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n-        FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);\n+        FastDateFormat format = cInstanceCache.get(emptyFormat);\n         if (format == null) {\n             format = emptyFormat;\n             format.init();  // convert shell format into usable one\n      *  pattern defined\n      */\n     public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n-        Object key = new Integer(style);\n+        Object key = Integer.valueOf(style);\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n \n         key = new Pair(key, locale);\n \n-        FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n+        FastDateFormat format = cDateInstanceCache.get(key);\n         if (format == null) {\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n      *  pattern defined\n      */\n     public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n-        Object key = new Integer(style);\n+        Object key = Integer.valueOf(style);\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n             key = new Pair(key, locale);\n         }\n \n-        FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);\n+        FastDateFormat format = cTimeInstanceCache.get(key);\n         if (format == null) {\n             if (locale == null) {\n                 locale = Locale.getDefault();\n     public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n             Locale locale) {\n \n-        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n+        Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n         }\n         key = new Pair(key, locale);\n \n-        FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n+        FastDateFormat format = cDateTimeInstanceCache.get(key);\n         if (format == null) {\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n      */\n     static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n         Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n-        String value = (String) cTimeZoneDisplayCache.get(key);\n+        String value = cTimeZoneDisplayCache.get(key);\n         if (value == null) {\n             // This is a very slow call, so cache the results.\n             value = tz.getDisplayName(daylight, style, locale);\n      * <p>Initializes the instance for first use.</p>\n      */\n     protected void init() {\n-        List rulesList = parsePattern();\n-        mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);\n+        List<Rule> rulesList = parsePattern();\n+        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n \n         int len = 0;\n         for (int i=mRules.length; --i >= 0; ) {\n      * @return a <code>List</code> of Rule objects\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    protected List parsePattern() {\n+    protected List<Rule> parsePattern() {\n         DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n-        List rules = new ArrayList();\n+        List<Rule> rules = new ArrayList<Rule>();\n \n         String[] ERAs = symbols.getEras();\n         String[] months = symbols.getMonths();", "timestamp": 1237174520, "metainfo": ""}