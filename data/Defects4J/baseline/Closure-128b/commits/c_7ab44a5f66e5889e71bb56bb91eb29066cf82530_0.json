{"sha": "7ab44a5f66e5889e71bb56bb91eb29066cf82530", "log": "Add compiler support for the new style for defining delegate methods.  R=acleung,johnlenz DELTA=144  (135 added, 0 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n import java.io.Serializable;\n import java.util.Collection;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * CodingConvention defines a set of hooks to customize the behavior of the\n   public String getDelegateSuperclassName();\n \n   /**\n+   * Checks for function calls that set the calling conventions on delegate\n+   * methods.\n+   */\n+  public void checkForCallingConventionDefiningCalls(\n+      Node n, Map<String, String> delegateCallingConventions);\n+\n+  /**\n    * Defines the delegate proxy prototype properties. Their types depend on\n    * properties of the delegate base methods.\n    *\n    */\n   public void defineDelegateProxyPrototypeProperties(\n       JSTypeRegistry registry, Scope scope,\n-      List<ObjectType> delegateProxyPrototypes);\n+      List<ObjectType> delegateProxyPrototypes,\n+      Map<String, String> delegateCallingConventions);\n \n   /**\n    * Gets the name of the global object.\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * CodingConvention defines a set of hooks to customize the behavior of the\n   }\n \n   @Override\n+  public void checkForCallingConventionDefiningCalls(Node n,\n+      Map<String, String> delegateCallingConventions) {\n+    // do nothing.\n+  }\n+\n+  @Override\n   public void defineDelegateProxyPrototypeProperties(\n       JSTypeRegistry registry, Scope scope,\n-      List<ObjectType> delegateProxyPrototypes) {\n+      List<ObjectType> delegateProxyPrototypes,\n+      Map<String, String> delegateCallingConventions) {\n     // do nothing.\n   }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.DelegateRelationship;\n import com.google.javascript.jscomp.CodingConvention.ObjectLiteralCast;\n import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\n \n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n \n import javax.annotation.Nullable;\n \n   private final CodingConvention codingConvention;\n   private final JSTypeRegistry typeRegistry;\n   private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n+  private final Map<String, String> delegateCallingConventions =\n+      Maps.newHashMap();\n \n   /**\n    * Defer attachment of types to nodes until all type names\n \n     if (parent == null) {\n       codingConvention.defineDelegateProxyPrototypeProperties(\n-          typeRegistry, newScope, delegateProxyPrototypes);\n+          typeRegistry, newScope, delegateProxyPrototypes,\n+          delegateCallingConventions);\n     }\n     return newScope;\n   }\n       switch (n.getType()) {\n         case Token.CALL:\n           checkForClassDefiningCalls(t, n, parent);\n+          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n           break;\n \n         case Token.FUNCTION:\n     }\n \n     /**\n+     * Look for calls that set a delegate method's calling convention.\n+     */\n+    private void checkForCallingConventionDefiningCalls(\n+        Node n, Map<String, String> delegateCallingConventions) {\n+      codingConvention.checkForCallingConventionDefiningCalls(n,\n+          delegateCallingConventions);\n+    }\n+\n+    /**\n      * Look for class-defining calls.\n      * Because JS has no 'native' syntax for defining classes,\n      * this is often very coding-convention dependent and business-logic heavy.", "timestamp": 1313167608, "metainfo": ""}