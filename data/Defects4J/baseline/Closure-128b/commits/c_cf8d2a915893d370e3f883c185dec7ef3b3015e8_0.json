{"sha": "cf8d2a915893d370e3f883c185dec7ef3b3015e8", "log": "Add compiler support for goog.define ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=43915701", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n+   * Creates a node representing a qualified name.\n+   *\n+   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n+   * @return A NAME or GETPROP node\n+   */\n+  public static Node newQualifiedNameNodeDeclaration(\n+      CodingConvention convention, String name, Node value, JSDocInfo info) {\n+    Node result;\n+    Node nameNode = newQualifiedNameNode(convention, name);\n+    if (nameNode.isName()) {\n+      result = IR.var(nameNode, value);\n+      result.setJSDocInfo(info);\n+    } else {\n+      result = IR.exprResult(IR.assign(nameNode, value));\n+      result.getFirstChild().setJSDocInfo(info);\n+    }\n+    return result;\n+  }\n+\n+  /**\n    * Creates a node representing a qualified name, copying over the source\n    * location information from the basis node and assigning the given original\n    * name to the node.\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n \n   static final DiagnosticType INVALID_PROVIDE_ERROR = DiagnosticType.error(\n       \"JSC_INVALID_PROVIDE_ERROR\",\n-      \"\\\"{0}\\\" is not a valid JS property name\");\n+      \"\\\"{0}\\\" is not a valid JS identifier name\");\n+\n+  static final DiagnosticType INVALID_DEFINE_NAME_ERROR = DiagnosticType.error(\n+      \"JSC_INVALID_DEFINE_NAME_ERROR\",\n+      \"\\\"{0}\\\" is not a valid JS identifier name\");\n+\n+  static final DiagnosticType MISSING_DEFINE_ANNOTATION = DiagnosticType.error(\n+      \"JSC_INVALID_MISSING_DEFINE_ANNOTATION\",\n+      \"Missing @define annotation\");\n \n   static final DiagnosticType XMODULE_REQUIRE_ERROR = DiagnosticType.warning(\n       \"JSC_XMODULE_REQUIRE_ERROR\",\n   private final Set<String> exportedVariables = Sets.newHashSet();\n   private final CheckLevel requiresLevel;\n   private final PreprocessorSymbolTable preprocessorSymbolTable;\n+  private final List<Node> defineCalls = Lists.newArrayList();\n \n   ProcessClosurePrimitives(AbstractCompiler compiler,\n       @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n   @Override\n   public void process(Node externs, Node root) {\n     new NodeTraversal(compiler, this).traverse(root);\n+\n+    for (Node n : defineCalls) {\n+      replaceGoogDefines(n);\n+    }\n \n     for (ProvidedName pn : providedNames.values()) {\n       pn.replace();\n             r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n       }\n     }\n+  }\n+\n+  /**\n+   * @param n\n+   */\n+  private void replaceGoogDefines(Node n) {\n+    Node parent = n.getParent();\n+    Preconditions.checkState(parent.isExprResult());\n+    String name = n.getChildAtIndex(1).getString();\n+    Node value = n.getChildAtIndex(2).detachFromParent();\n+\n+    Node replacement = NodeUtil.newQualifiedNameNodeDeclaration(\n+        compiler.getCodingConvention(), name, value, n.getJSDocInfo());\n+    replacement.useSourceInfoIfMissingFromForTree(n);\n+    parent.getParent().replaceChild(parent, replacement);\n+    compiler.reportCodeChange();\n   }\n \n   @Override\n             } else if (!isExpr) {\n               // All other methods must be called in an EXPR.\n               break;\n+            } else if (\"define\".equals(methodName)) {\n+              processDefineCall(t, n, parent);\n             } else if (\"require\".equals(methodName)) {\n               processRequireCall(t, n, parent);\n             } else if (\"provide\".equals(methodName)) {\n   private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n     Node left = n.getFirstChild();\n     Node arg = left.getNext();\n-    if (verifyArgument(t, left, arg)) {\n+    if (verifyLastArgumentIsString(t, left, arg)) {\n       String ns = arg.getString();\n       ProvidedName provided = providedNames.get(ns);\n       if (provided == null || !provided.isExplicitlyProvided()) {\n         providedNames.put(\n             ns, new ProvidedName(ns, parent, t.getModule(), true));\n       }\n+    }\n+  }\n+\n+    /**\n+   * Handles a goog.define call.\n+   */\n+  private void processDefineCall(NodeTraversal t, Node n, Node parent) {\n+    Node left = n.getFirstChild();\n+    Node args = left.getNext();\n+    if (verifyDefine(t, parent, left, args)) {\n+      Node nameNode = args;\n+      String name = args.getString();\n+      Node value = args.getNext();\n+\n+      maybeAddToSymbolTable(left);\n+      maybeAddStringNodeToSymbolTable(nameNode);\n+\n+      this.defineCalls.add(n);\n     }\n   }\n \n    * @return Whether the argument checked out okay\n    */\n   private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {\n-    if (!verifyArgument(t, methodName, arg)) {\n+    if (!verifyLastArgumentIsString(t, methodName, arg)) {\n       return false;\n     }\n \n   }\n \n   /**\n+   * Verifies that a provide method call has exactly one argument,\n+   * and that it's a string literal and that the contents of the string are\n+   * valid JS tokens. Reports a compile error if it doesn't.\n+   *\n+   * @return Whether the argument checked out okay\n+   */\n+  private boolean verifyDefine(NodeTraversal t,\n+      Node expr,\n+      Node methodName, Node args) {\n+\n+    // Verify first arg\n+    Node arg = args;\n+    if (!verifyNotNull(t, methodName, arg) ||\n+        !verifyOfType(t, methodName, arg, Token.STRING)) {\n+      return false;\n+    }\n+\n+    // Verify second arg\n+    arg = arg.getNext();\n+    if (!verifyNotNull(t, methodName, arg) ||\n+        !verifyIsLast(t, methodName, arg)) {\n+      return false;\n+    }\n+\n+    String name = args.getString();\n+    for (String part : name.split(\"\\\\.\")) {\n+      if (!NodeUtil.isValidQualifiedName(part)) {\n+        compiler.report(t.makeError(args, INVALID_DEFINE_NAME_ERROR, name));\n+        return false;\n+      }\n+    }\n+\n+    JSDocInfo info = expr.getFirstChild().getJSDocInfo();\n+    if (info == null || !info.isDefine()) {\n+      compiler.report(t.makeError(expr, MISSING_DEFINE_ANNOTATION));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n    * Verifies that a method call has exactly one argument, and that it's a\n    * string literal. Reports a compile error if it doesn't.\n    *\n    * @return Whether the argument checked out okay\n    */\n-  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg) {\n-    return verifyArgument(t, methodName, arg, Token.STRING);\n-  }\n-\n-  /**\n-   * Verifies that a method call has exactly one argument, and that it is of the\n-   * desired type. Reports a compile error if it doesn't.\n-   *\n+  private boolean verifyLastArgumentIsString(\n+      NodeTraversal t, Node methodName, Node arg) {\n+    return verifyNotNull(t, methodName, arg) &&\n+        verifyOfType(t, methodName, arg, Token.STRING) &&\n+        verifyIsLast(t, methodName, arg);\n+  }\n+\n+  /**\n    * @return Whether the argument checked out okay\n    */\n-  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg,\n-      int desiredType) {\n-    DiagnosticType diagnostic = null;\n+  private boolean verifyNotNull(NodeTraversal t, Node methodName, Node arg) {\n     if (arg == null) {\n-      diagnostic = NULL_ARGUMENT_ERROR;\n-    } else if (arg.getType() != desiredType) {\n-      diagnostic = INVALID_ARGUMENT_ERROR;\n-    } else if (arg.getNext() != null) {\n-      diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n-    }\n-    if (diagnostic != null) {\n       compiler.report(\n           t.makeError(methodName,\n-              diagnostic, methodName.getQualifiedName()));\n+              NULL_ARGUMENT_ERROR, methodName.getQualifiedName()));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * @return Whether the argument checked out okay\n+   */\n+  private boolean verifyOfType(NodeTraversal t, Node methodName,\n+      Node arg, int desiredType) {\n+    if (arg.getType() != desiredType) {\n+      compiler.report(\n+          t.makeError(methodName,\n+              INVALID_ARGUMENT_ERROR, methodName.getQualifiedName()));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * @return Whether the argument checked out okay\n+   */\n+  private boolean verifyIsLast(NodeTraversal t, Node methodName, Node arg) {\n+    if (arg.getNext() != null) {\n+      compiler.report(\n+          t.makeError(methodName,\n+              TOO_MANY_ARGUMENTS_ERROR, methodName.getQualifiedName()));\n       return false;\n     }\n     return true;\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n         case com.google.javascript.rhino.head.Token.GETPROP:\n         case com.google.javascript.rhino.head.Token.GETELEM:\n           valid = isExprStmt(node.getParent());\n+          break;\n+\n+        case com.google.javascript.rhino.head.Token.CALL:\n+          valid = info.isDefine();\n           break;\n       }\n       if (!valid) {\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     options.closurePass = true;\n     options.collapseProperties = true;\n     test(options, code, CLOSURE_COMPILED + \" var x$bar = 3;\");\n+  }\n+\n+  public void testGoogDefine1() {\n+    String code = CLOSURE_BOILERPLATE +\n+        \"/** @define {boolean} */ goog.define('FLAG', true);\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    options.setDefineToBooleanLiteral(\"FLAG\", false);\n+\n+    test(options, code, CLOSURE_COMPILED + \" var FLAG = false;\");\n+  }\n+\n+  public void testGoogDefine2() {\n+    String code = CLOSURE_BOILERPLATE +\n+        \"goog.provide('ns');\" +\n+        \"/** @define {boolean} */ goog.define('ns.FLAG', true);\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+\n+    options.closurePass = true;\n+    options.collapseProperties = true;\n+    options.setDefineToBooleanLiteral(\"ns.FLAG\", false);\n+    test(options, code, CLOSURE_COMPILED + \"var ns$FLAG = false;\");\n   }\n \n   public void testCollapseProperties1() {\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.rhino.Node;\n-import com.google.javascript.jscomp.CheckLevel;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.BASE_CLASS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.DUPLICATE_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.EXPECTED_OBJECTLIT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.FUNCTION_NAMESPACE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_ARGUMENT_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CSS_RENAMING_MAP;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_DEFINE_NAME_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_PROVIDE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_STYLE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.LATE_PROVIDE_ERROR;\n+import static com.google.javascript.jscomp.ProcessClosurePrimitives.MISSING_DEFINE_ANNOTATION;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.MISSING_PROVIDE_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.NULL_ARGUMENT_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.TOO_MANY_ARGUMENTS_ERROR;\n import static com.google.javascript.jscomp.ProcessClosurePrimitives.XMODULE_REQUIRE_ERROR;\n-import static com.google.javascript.jscomp.ProcessClosurePrimitives.INVALID_CSS_RENAMING_MAP;\n+\n+import com.google.javascript.rhino.Node;\n \n /**\n  * Tests for {@link ProcessClosurePrimitives}.\n   public void testProvideRequireSameFile() {\n     test(\"goog.provide('x');\\ngoog.require('x');\", \"var x = {};\");\n   }\n+\n+  public void testDefineCases() {\n+    String jsdoc = \"/** @define {number} */\\n\";\n+    test(jsdoc + \"goog.define('name', 1);\", jsdoc + \"var name = 1\");\n+    test(jsdoc + \"goog.define('ns.name', 1);\", jsdoc + \"ns.name = 1\");\n+  }\n+\n+  public void testDefineErrorCases() {\n+    String jsdoc = \"/** @define {number} */\\n\";\n+    test(\"goog.define('name', 1);\", \"\", MISSING_DEFINE_ANNOTATION);\n+    test(jsdoc + \"goog.define('name.2', 1);\", \"\", INVALID_DEFINE_NAME_ERROR);\n+    test(jsdoc + \"goog.define();\", \"\", NULL_ARGUMENT_ERROR);\n+    test(jsdoc + \"goog.define('value');\", \"\", NULL_ARGUMENT_ERROR);\n+    test(jsdoc + \"goog.define(5);\", \"\", INVALID_ARGUMENT_ERROR);\n+  }\n }", "timestamp": 1363292308, "metainfo": ""}