{"sha": "28daacd6206e32d6406645fa9ed8d0f9c22c35d1", "log": "moved JSCompiler dependencies to open source  R=nicksantos DELTA=502  (265 added, 231 deleted, 6 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4220   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CleanupPasses.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.DefaultPassConfig.HotSwapPassFactory;\n+import com.google.javascript.jscomp.GlobalVarReferenceMap.GlobalVarRefCleanupPass;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+import java.util.List;\n+\n+\n+/**\n+ * Provides passes that should be run before hot-swap/incremental builds.\n+ *\n+ * @author tylerg@google.com (Tyler Goodwin)\n+ */\n+class CleanupPasses extends PassConfig {\n+\n+  private State state;\n+\n+  public CleanupPasses(CompilerOptions options) {\n+    super(options);\n+  }\n+\n+  @Override\n+  protected List<PassFactory> getChecks() {\n+    List<PassFactory> checks = Lists.newArrayList();\n+    checks.add(fieldCleanupPassFactory);\n+    checks.add(scopeCleanupPassFactory);\n+    checks.add(globalVarRefCleanupPassFactory);\n+    return checks;\n+  }\n+\n+  @Override\n+  State getIntermediateState() {\n+    return state;\n+  }\n+\n+  @Override\n+  protected List<PassFactory> getOptimizations() {\n+    return ImmutableList.of();\n+  }\n+\n+  @Override\n+  void setIntermediateState(State state) {\n+    this.state = state;\n+  }\n+\n+  final PassFactory fieldCleanupPassFactory =\n+      new HotSwapPassFactory(\"FieldCleaupPassFactory\", false) {\n+        @Override\n+        protected HotSwapCompilerPass createInternal(\n+            AbstractCompiler compiler) {\n+          return new FieldCleanupPass(compiler);\n+        }\n+      };\n+\n+  final PassFactory scopeCleanupPassFactory =\n+      new HotSwapPassFactory(\"ScopeCleanupPassFactory\", false) {\n+        @Override\n+        protected HotSwapCompilerPass createInternal(\n+            AbstractCompiler compiler) {\n+          return new MemoizedScopeCleanupPass(compiler);\n+        }\n+      };\n+\n+  final PassFactory globalVarRefCleanupPassFactory =\n+      new HotSwapPassFactory(\"GlobalVarRefCleanupPassFactory\", false) {\n+        @Override\n+        protected HotSwapCompilerPass createInternal(\n+            AbstractCompiler compiler) {\n+          return new GlobalVarRefCleanupPass(compiler);\n+        }\n+  };\n+\n+  /**\n+   * A CleanupPass implementation that will remove stored scopes from the\n+   * MemoizedScopeCreator of the compiler instance for a the hot swapped script.\n+   * <p>\n+   * This pass will also clear out Source Nodes of Function Types declared on\n+   * Vars tracked by MemoizedScopeCreator\n+   */\n+  static class MemoizedScopeCleanupPass implements HotSwapCompilerPass {\n+\n+    private final AbstractCompiler compiler;\n+\n+    public MemoizedScopeCleanupPass(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+      ScopeCreator creator = compiler.getTypedScopeCreator();\n+      if (creator instanceof MemoizedScopeCreator) {\n+        MemoizedScopeCreator scopeCreator = (MemoizedScopeCreator) creator;\n+        String newSrc = scriptRoot.getSourceFileName();\n+        for (Var var : scopeCreator.getAllSymbols()) {\n+          JSType type = var.getType();\n+          if (type != null) {\n+            FunctionType fnType = type.toMaybeFunctionType();\n+            if (fnType != null\n+                && newSrc.equals(NodeUtil.getSourceName(fnType.getSource()))) {\n+              fnType.setSource(null);\n+            }\n+          }\n+        }\n+        scopeCreator.removeScopesForScript(originalRoot.getSourceFileName());\n+      }\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      // MemoizedScopeCleanupPass should not do work during process.\n+    }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.head.ErrorReporter;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n   }\n \n   @Override\n-  MemoizedScopeCreator getTypedScopeCreator() {\n+  public MemoizedScopeCreator getTypedScopeCreator() {\n     return getPassConfig().getTypedScopeCreator();\n   }\n \n     }\n   }\n \n+  /**\n+   * Replaces one file in a hot-swap mode. The given JsAst should be made\n+   * from a new version of a file that already was present in the last compile\n+   * call. If the file is new, this will silently ignored.\n+   *\n+   * @param ast the ast of the file that is being replaced\n+   */\n+  public void replaceScript(JsAst ast) {\n+    CompilerInput input = this.getInput(ast.getInputId());\n+    if (!replaceIncrementalSourceAst(ast)) {\n+      return;\n+    }\n+    Node originalRoot = input.getAstRoot(this);\n+\n+    processNewScript(ast, originalRoot);\n+  }\n+\n+  /**\n+   * Adds a new Script AST to the compile state. If a script for the same file\n+   * already exists the script will not be added, instead a call to\n+   * #replaceScript should be used.\n+   *\n+   * @param ast the ast of the new file\n+   */\n+  public void addNewScript(JsAst ast) {\n+    if (!addNewSourceAst(ast)) {\n+      return;\n+    }\n+    Node emptyScript = new Node(Token.SCRIPT);\n+    InputId inputId = ast.getInputId();\n+    emptyScript.setInputId(inputId);\n+    emptyScript.setStaticSourceFile(\n+        JSSourceFile.fromCode(inputId.getIdName(), \"\"));\n+\n+    processNewScript(ast, emptyScript);\n+  }\n+\n+  private void processNewScript(JsAst ast, Node originalRoot) {\n+    Node js = ast.getAstRoot(this);\n+    Preconditions.checkNotNull(js);\n+\n+    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n+    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n+    // to revisit this approach to clearing GlobalNamespaces\n+    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n+\n+    this.getTypeRegistry().clearNamedTypes();\n+    this.removeSyntheticVarsInput();\n+\n+    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n+  }\n+\n+  /**\n+   * Execute the passes from a PassConfig instance over a single replaced file.\n+   */\n+  private void runHotSwap(\n+      Node originalRoot, Node js, PassConfig passConfig) {\n+    for (PassFactory passFactory : passConfig.getChecks()) {\n+      runHotSwapPass(originalRoot, js, passFactory);\n+    }\n+  }\n+\n+  private void runHotSwapPass(\n+      Node originalRoot, Node js, PassFactory passFactory) {\n+    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n+    if (pass != null) {\n+      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n+      pass.hotSwapScript(js, originalRoot);\n+    }\n+  }\n+\n+  private PassConfig getCleanupPassConfig() {\n+    return new CleanupPasses(getOptions());\n+  }\n+\n+  private void removeSyntheticVarsInput() {\n+    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n+    removeExternInput(new InputId(sourceName));\n+  }\n+\n }\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/WhitelistWarningsGuard.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.CharStreams;\n+import com.google.common.io.Files;\n+import com.google.common.io.InputSupplier;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * An extension of {@code WarningsGuard} that provides functionality to maintain\n+ * a list of warnings (white-list). It is subclasses' responsibility to decide\n+ * what to do with the white-list by implementing the {@code level} function.\n+ * Warnings are defined by the name of the js file and the first line of\n+ * warnings description.\n+ *\n+ * @author anatol@google.com (Anatol Pomazau)\n+ * @author bashir@google.com (Bashir Sadjad)\n+ */\n+public abstract class WhitelistWarningsGuard extends WarningsGuard {\n+  /** The set of white-listed warnings, same format as {@code formatWarning}. */\n+  private final Set<String> whiteList;\n+\n+  /** Pattern to match line number in error descriptions. */\n+  private static final Pattern LINE_NUMBER = Pattern.compile(\":\\\\d+\");\n+\n+  /**\n+   * This class depends on an input set that contains the white-list. The format\n+   * of each white-list string is:\n+   * <file-name>:  <warning-description>\n+   *\n+   * @param whiteList The set of js-warnings that are white-listed. This is\n+   *     expected to have similar format as {@code formatWarning(JSError)}.\n+   */\n+  public WhitelistWarningsGuard(Set<String> whiteList) {\n+    this.whiteList = whiteList;\n+  }\n+\n+  /**\n+   * Determines whether a given warning is included in the white-list.\n+   *\n+   * @param formattedWarning the warning formatted by {@code formatWarning}\n+   * @return whether the given warning is white-listed or not.\n+   */\n+  protected boolean containWarning(String formattedWarning) {\n+    return whiteList.contains(formattedWarning);\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return WarningsGuard.Priority.SUPPRESS_BY_WHITELIST.getValue();\n+  }\n+\n+  /**\n+   * Loads legacy warnings list from the file. As during development line\n+   * numbers are changed very often - we just cut it and compare without ones.\n+   *\n+   * @return known legacy warnings without line numbers.\n+   */\n+  public static Set<String> loadWhitelistedJsWarnings(File file) {\n+    return loadWhitelistedJsWarnings(\n+        Files.newReaderSupplier(file, Charsets.UTF_8));\n+  }\n+\n+  /**\n+   * Loads legacy warnings list from the file. As during development line\n+   * numbers are changed very often - we just cut it and compare without ones.\n+   *\n+   * @return known legacy warnings without line numbers.\n+   */\n+  protected static Set<String> loadWhitelistedJsWarnings(\n+      InputSupplier<InputStreamReader> supplier) {\n+    Preconditions.checkNotNull(supplier);\n+\n+    Set<String> result = new HashSet<String>();\n+\n+    try {\n+      for (String line : CharStreams.readLines(supplier)) {\n+        line = line.trim();\n+        if (line.isEmpty() || line.charAt(0) == '#') {\n+          continue;\n+        }\n+\n+        result.add(line);\n+      }\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    return result;\n+  }\n+\n+  public static String formatWarning(JSError error) {\n+    return formatWarning(error, false);\n+  }\n+\n+  public static String formatWarning(JSError error, boolean withLineNumber) {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(error.sourceName).append(\":\");\n+    if (withLineNumber) {\n+      sb.append(error.lineNumber);\n+    }\n+    String descriptionFirstLine = getFirstLine(error.description);\n+    if (!withLineNumber) {\n+      descriptionFirstLine =\n+          LINE_NUMBER.matcher(descriptionFirstLine).replaceAll(\":\");\n+    }\n+    sb.append(\"  \").append(descriptionFirstLine);\n+\n+    return sb.toString();\n+  }\n+\n+  public static String getFirstLine(String warning) {\n+    int lineLength = warning.indexOf('\\n');\n+    if (lineLength > 0) {\n+      warning = warning.substring(0, lineLength);\n+    }\n+    return warning;\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CleanupPassesTest.java\n+/*\n+ * Copyright 2012 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.List;\n+\n+/**\n+ * @author tylerg@google.com (Tyler Goodwin)\n+ */\n+public class CleanupPassesTest extends TestCase {\n+\n+  private final AbstractCompiler compiler = new Compiler();\n+  private final CompilerOptions options = new CompilerOptions();\n+\n+  public void testCleanupPassOrder() {\n+\n+    CleanupPasses config = new CleanupPasses(options);\n+\n+    List<PassFactory> checks = config.getChecks();\n+\n+    assertTrue(\"Pass 0 should be a FieldCleanupPass\",\n+        checks.get(0).create(compiler) instanceof FieldCleanupPass);\n+  }\n+\n+  public void testNoOptimizations() {\n+    CompilerOptions options = new CompilerOptions();\n+    CleanupPasses config = new CleanupPasses(options);\n+    assertTrue(\"Cleanup Passes unexpectedly contain optimization passes\",\n+        config.getOptimizations().isEmpty());\n+  }\n+}", "timestamp": 1329327209, "metainfo": ""}