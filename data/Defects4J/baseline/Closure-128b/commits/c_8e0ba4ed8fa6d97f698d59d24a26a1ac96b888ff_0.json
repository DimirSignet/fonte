{"sha": "8e0ba4ed8fa6d97f698d59d24a26a1ac96b888ff", "log": "Add Definition#isInExterns().  Changed the Definition interface to indicate whether a definition comes from the exports or not.  Changed NameReferenceGraph and SimpleDefinitionFinder to provide this information (which they are already calculating for internal use) when creating Definitions.  PureFunctionIdentifier also creates definitions in PureFunctionIdentifier#getCallableDefinitions(). I had to change this from a static method to an instance method to be able to access the instance variable map that stores whether a function was defined in externs or not. Nothing seems to rely on that method being static, but it probably needs some scrutiny.  R=acleung,avd DELTA=199  (109 added, 2 deleted, 88 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=54007   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n    * @return an {@link Definition} object if the node contains a definition or\n    *     {@code null} otherwise.\n    */\n-  static Definition getDefinition(Node n, Node parent) {\n+  static Definition getDefinition(Node n, boolean isExtern) {\n     // TODO(user): Since we have parent pointers handy. A lot of constructors\n     // can be simplied.\n+\n+    Node parent = n.getParent();\n     if (parent == null) {\n       return null;\n     }\n \n     if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n-      return new VarDefinition(n);\n+      return new VarDefinition(n, isExtern);\n     } else if (NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n       if (!NodeUtil.isFunctionExpression(parent)) {\n-        return new NamedFunctionDefinition(parent);\n+        return new NamedFunctionDefinition(parent, isExtern);\n       } else if (!n.getString().equals(\"\")) {\n-        return new FunctionExpressionDefinition(parent);\n+        return new FunctionExpressionDefinition(parent, isExtern);\n       }\n     } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n-      return new AssignmentDefinition(parent);\n+      return new AssignmentDefinition(parent, isExtern);\n     } else if (NodeUtil.isObjectLitKey(n, parent)) {\n-      return new ObjectLiteralPropertyDefinition(parent, n, n.getNext());\n+      return new ObjectLiteralPropertyDefinition(parent, n, n.getNext(),\n+          isExtern);\n     } else if (parent.getType() == Token.LP) {\n       Node function = parent.getParent();\n-      return new FunctionArgumentDefinition(function, n);\n+      return new FunctionArgumentDefinition(function, n, isExtern);\n     }\n     return null;\n   }\n \n-  static interface Definition {\n-    void remove();\n+  static abstract class Definition {\n+\n+    private final boolean isExtern;\n+\n+    Definition(boolean isExtern) {\n+      this.isExtern = isExtern;\n+    }\n+\n+    /**\n+     * Removes this definition from the AST if it is not an extern.\n+     *\n+     * This method should not be called on a definition for which isExtern()\n+     * is true.\n+     */\n+    public void remove() {\n+      if (!isExtern) {\n+        performRemove();\n+      } else {\n+        throw new IllegalStateException(\"Attempt to remove() an extern\" +\n+            \" definition.\");\n+      }\n+    }\n+\n+    /**\n+     * Subclasses should override to remove the definition from the AST.\n+     */\n+    protected abstract void performRemove();\n \n     /**\n      * Variable or property name represented by this definition.\n      * @return the L-Value associated with this definition.\n      *         The node's type is always NAME, GETPROP or GETELEM.\n      */\n-    Node getLValue();\n+    public abstract Node getLValue();\n \n     /**\n      * Value expression that acts as the right hand side of the\n      * definition statement.\n      */\n-    Node getRValue();\n+    public abstract Node getRValue();\n+\n+    /**\n+     * Returns true if the definition is an extern.\n+     */\n+    public boolean isExtern() {\n+      return isExtern;\n+    }\n   }\n \n   /**\n    * Represents an name-only external definition.  The definition's\n    * rhs is missing.\n    */\n-  abstract static class IncompleteDefinition implements Definition {\n+  abstract static class IncompleteDefinition extends Definition {\n     private static final Set<Integer> ALLOWED_TYPES =\n         ImmutableSet.of(Token.NAME, Token.GETPROP, Token.GETELEM);\n     private final Node lValue;\n \n-    IncompleteDefinition(Node lValue) {\n+    IncompleteDefinition(Node lValue, boolean inExterns) {\n+      super(inExterns);\n       Preconditions.checkNotNull(lValue);\n       Preconditions.checkArgument(\n           ALLOWED_TYPES.contains(lValue.getType()),\n     }\n   }\n \n-\n   /**\n    * Represents an unknown definition.\n    */\n   static final class UnknownDefinition extends IncompleteDefinition {\n-    UnknownDefinition(Node lValue) {\n-      super(lValue);\n-    }\n-\n-    @Override\n-    public void remove() {\n+    UnknownDefinition(Node lValue, boolean inExterns) {\n+      super(lValue, inExterns);\n+    }\n+\n+    @Override\n+    public void performRemove() {\n       throw new IllegalArgumentException(\"Can't remove an UnknownDefinition\");\n     }\n   }\n   static final class ExternalNameOnlyDefinition extends IncompleteDefinition {\n \n     ExternalNameOnlyDefinition(Node lValue) {\n-      super(lValue);\n-    }\n-\n-    @Override\n-    public void remove() {\n+      super(lValue, true);\n+    }\n+\n+    @Override\n+    public void performRemove() {\n       throw new IllegalArgumentException(\n           \"Can't remove external name-only definition\");\n     }\n   }\n \n   /**\n-   * Represents an name-only external definition.  The definition's\n-   * rhs is missing.\n+   * Represents a function formal parameter. The definition's rhs is missing.\n    */\n   static final class FunctionArgumentDefinition extends IncompleteDefinition {\n-    FunctionArgumentDefinition(Node function, Node argumentName) {\n-      super(argumentName);\n+    FunctionArgumentDefinition(Node function,\n+        Node argumentName,\n+        boolean inExterns) {\n+      super(argumentName, inExterns);\n       Preconditions.checkArgument(NodeUtil.isFunction(function));\n       Preconditions.checkArgument(NodeUtil.isName(argumentName));\n     }\n \n     @Override\n-    public void remove() {\n+    public void performRemove() {\n       throw new IllegalArgumentException(\n           \"Can't remove a FunctionArgumentDefinition\");\n     }\n   /**\n    * Represents a function declaration or function expression.\n    */\n-  static abstract class FunctionDefinition implements Definition {\n+  abstract static class FunctionDefinition extends Definition {\n \n     protected final Node function;\n \n-    FunctionDefinition(Node node) {\n+    FunctionDefinition(Node node, boolean inExterns) {\n+      super(inExterns);\n       Preconditions.checkArgument(NodeUtil.isFunction(node));\n       function = node;\n     }\n    * {@code function foo()}.\n    */\n   static final class NamedFunctionDefinition extends FunctionDefinition {\n-    NamedFunctionDefinition(Node node) {\n-      super(node);\n-    }\n-\n-    @Override\n-    public void remove() {\n+    NamedFunctionDefinition(Node node, boolean inExterns) {\n+      super(node, inExterns);\n+    }\n+\n+    @Override\n+    public void performRemove() {\n       function.detachFromParent();\n     }\n   }\n    * name is only reachable from within the function.\n    */\n   static final class FunctionExpressionDefinition extends FunctionDefinition {\n-    FunctionExpressionDefinition(Node node) {\n-      super(node);\n+    FunctionExpressionDefinition(Node node, boolean inExterns) {\n+      super(node, inExterns);\n       Preconditions.checkArgument(\n           NodeUtil.isFunctionExpression(node));\n     }\n \n     @Override\n-    public void remove() {\n+    public void performRemove() {\n       // replace internal name with \"\"\n       function.replaceChild(function.getFirstChild(),\n                             Node.newString(Token.NAME, \"\"));\n   /**\n    * Represents a declaration within an assignment.\n    */\n-  static final class AssignmentDefinition implements Definition {\n+  static final class AssignmentDefinition extends Definition {\n     private final Node assignment;\n \n-    AssignmentDefinition(Node node) {\n+    AssignmentDefinition(Node node, boolean inExterns) {\n+      super(inExterns);\n       Preconditions.checkArgument(NodeUtil.isAssign(node));\n       assignment = node;\n     }\n \n     @Override\n-    public void remove() {\n+    public void performRemove() {\n       // A simple assignment. foo = bar() -> bar();\n       Node parent = assignment.getParent();\n       Node last = assignment.getLastChild();\n    * Represents member declarations using a object literal.\n    * Example: var x = { e : function() { } };\n    */\n-  static final class ObjectLiteralPropertyDefinition implements Definition {\n+  static final class ObjectLiteralPropertyDefinition extends Definition {\n \n     private final Node literal;\n     private final Node name;\n     private final Node value;\n \n-\n-    ObjectLiteralPropertyDefinition(Node lit, Node name, Node value) {\n+    ObjectLiteralPropertyDefinition(Node lit, Node name, Node value,\n+          boolean isExtern) {\n+      super(isExtern);\n+\n       this.literal = lit;\n       this.name = name;\n       this.value = value;\n     }\n \n     @Override\n-    public void remove() {\n+    public void performRemove() {\n       literal.removeChild(name);\n       literal.removeChild(value);\n     }\n   /**\n    * Represents a VAR declaration with an assignment.\n    */\n-  static final class VarDefinition implements Definition {\n+  static final class VarDefinition extends Definition {\n     private final Node name;\n-    VarDefinition(Node node) {\n+    VarDefinition(Node node, boolean inExterns) {\n+      super(inExterns);\n       Preconditions.checkArgument(NodeUtil.isVarDeclaration(node));\n       Preconditions.checkArgument(node.hasChildren(),\n           \"VAR Declaration of \" + node.getString() +\n     }\n \n     @Override\n-    public void remove() {\n+    public void performRemove() {\n       Node var = name.getParent();\n       Preconditions.checkState(var.getFirstChild() == var.getLastChild(),\n           \"AST should be normalized first\");\n--- a/src/com/google/javascript/jscomp/NameReferenceGraph.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraph.java\n       if (!decls.isEmpty()) {\n         result.addAll(decls);\n       } else {\n-        result.add(new UnknownDefinition(useSite));\n+        result.add(new UnknownDefinition(useSite, false));\n       }\n     }\n \n     }\n \n     public void addAssignmentDeclaration(Node node) {\n-      declarations.add(new AssignmentDefinition(node));\n+      declarations.add(new AssignmentDefinition(node, isExtern));\n     }\n \n     public void addFunctionDeclaration(Node node) {\n-      declarations.add(new NamedFunctionDefinition(node));\n+      declarations.add(new NamedFunctionDefinition(node, isExtern));\n     }\n \n     public boolean isExtern() {\n     }\n \n     /** Removes all of the declarations of this name. */\n-    public void remove() {\n+    public final void remove() {\n       for (Definition declaration : getDeclarations()) {\n         declaration.remove();\n       }\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       }\n     } else if (NodeUtil.isFunctionExpression(name)) {\n       // The anonymous function reference is also the definition.\n+      // TODO(user) Change SimpleDefinitionFinder so it is possible to query for\n+      // function expressions by function node.\n+\n+      // isExtern is false in the call to the constructor for the\n+      // FunctionExpressionDefinition below because we know that\n+      // getCallableDefinitions() will only be called on the first\n+      // child of a call and thus the function expression\n+      // definition will never be an extern.\n       return Lists.newArrayList(\n           (Definition)\n-              new DefinitionsRemover.FunctionExpressionDefinition(name));\n+              new DefinitionsRemover.FunctionExpressionDefinition(name, false));\n     } else {\n       return null;\n     }\n--- a/src/com/google/javascript/jscomp/RemoveUnusedNames.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedNames.java\n \n   private final AbstractCompiler compiler;\n \n+  private final boolean canModifyExterns;\n+\n   /**\n    * Creates a new pass for removing unused prototype properties, based\n    * on the uniqueness of property names.\n   RemoveUnusedNames(AbstractCompiler compiler,\n       boolean canModifyExterns) {\n     this.compiler = compiler;\n+    this.canModifyExterns = canModifyExterns;\n   }\n \n   public void process(Node externRoot, Node root) {\n       Name name = node.getValue();\n       NameInfo nameInfo = node.getAnnotation();\n       if (nameInfo == null || !nameInfo.isReferenced()) {\n-        name.remove();\n-        compiler.reportCodeChange();\n-        logger.fine(\"Removed unused name\" + name);\n+        if (canModifyExterns || !name.isExtern()) {\n+          name.remove();\n+          compiler.reportCodeChange();\n+          logger.fine(\"Removed unused name\" + name);\n+        }\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n       }\n \n       Definition def =\n-          DefinitionsRemover.getDefinition(node, parent);\n+          DefinitionsRemover.getDefinition(node, inExterns);\n       if (def != null) {\n         String name = getSimplifiedName(def.getLValue());\n         if (name != null) {\n               !NodeUtil.isFunction(rValue)) {\n \n             // Unhandled complex expression\n-            Definition unknownDef = new UnknownDefinition(def.getLValue());\n+            Definition unknownDef =\n+                new UnknownDefinition(def.getLValue(), inExterns);\n             def = unknownDef;\n           }\n \n--- a/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java\n+++ b/test/com/google/javascript/jscomp/DefinitionsRemoverTest.java\n     final List<Definition> definitions = Lists.newArrayList();\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      Definition def = DefinitionsRemover.getDefinition(n, parent);\n+      Definition def = DefinitionsRemover.getDefinition(n, false);\n       if (def != null) {\n         definitions.add(def);\n       }\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n     // function arguments are NOT definitions when they appear in externs.\n     checkDefinitions(\n         DEF, USE,\n-        ImmutableSet.of(\"DEF NAME f -> FUNCTION\",\n-                        \"USE NAME f -> [FUNCTION]\"));\n+        ImmutableSet.of(\"DEF NAME f -> EXTERN FUNCTION\",\n+                        \"USE NAME f -> [EXTERN FUNCTION]\"));\n   }\n \n   public void testMultipleDefinition() throws Exception {\n \n     checkDefinitionsInExterns(\n         externs,\n-        ImmutableSet.of(\"DEF NAME a -> NUMBER\"));\n+        ImmutableSet.of(\"DEF NAME a -> EXTERN NUMBER\"));\n \n     checkDefinitions(\n         externs,\n         \"var b = 1\",\n-        ImmutableSet.of(\"DEF NAME a -> NUMBER\", \"DEF NAME b -> NUMBER\"));\n+        ImmutableSet.of(\"DEF NAME a -> EXTERN NUMBER\", \"DEF NAME b -> NUMBER\"));\n \n     checkDefinitions(\n         externs,\n         \"a = \\\"foo\\\"; a\",\n-        ImmutableSet.of(\"DEF NAME a -> NUMBER\",\n+        ImmutableSet.of(\"DEF NAME a -> EXTERN NUMBER\",\n                         \"DEF NAME a -> STRING\",\n-                        \"USE NAME a -> [NUMBER, STRING]\"));\n+                        \"USE NAME a -> [EXTERN NUMBER, STRING]\"));\n \n     checkDefinitionsInExterns(\n         \"var a = {}; a.b = 10\",\n-        ImmutableSet.of(\"DEF GETPROP a.b -> NUMBER\",\n-                        \"DEF NAME a -> <null>\",\n-                        \"USE NAME a -> [<null>]\"));\n+        ImmutableSet.of(\"DEF GETPROP a.b -> EXTERN NUMBER\",\n+                        \"DEF NAME a -> EXTERN <null>\",\n+                        \"USE NAME a -> [EXTERN <null>]\"));\n \n     checkDefinitionsInExterns(\n         \"var a = {}; a.b\",\n-        ImmutableSet.of(\"DEF GETPROP a.b -> <null>\",\n-                        \"DEF NAME a -> <null>\",\n-                        \"USE NAME a -> [<null>]\"));\n+        ImmutableSet.of(\"DEF GETPROP a.b -> EXTERN <null>\",\n+                        \"DEF NAME a -> EXTERN <null>\",\n+                        \"USE NAME a -> [EXTERN <null>]\"));\n \n     checkDefinitions(\n         \"var a = {}\",\n         \"a.b = 1\",\n         ImmutableSet.of(\"DEF GETPROP a.b -> NUMBER\",\n-                        \"DEF NAME a -> <null>\",\n-                        \"USE NAME a -> [<null>]\"));\n+                        \"DEF NAME a -> EXTERN <null>\",\n+                        \"USE NAME a -> [EXTERN <null>]\"));\n \n     checkDefinitions(\n         \"var a = {}\",\n         \"a.b\",\n-        ImmutableSet.of(\"DEF NAME a -> <null>\",\n-                        \"USE NAME a -> [<null>]\"));\n+        ImmutableSet.of(\"DEF NAME a -> EXTERN <null>\",\n+                        \"USE NAME a -> [EXTERN <null>]\"));\n \n     checkDefinitionsInExterns(\n         externs,\n-        ImmutableSet.of(\"DEF NAME a -> NUMBER\"));\n+        ImmutableSet.of(\"DEF NAME a -> EXTERN NUMBER\"));\n   }\n \n   void checkDefinitionsInExterns(String externs, Set<String> expected) {\n         sb.append(\" \");\n         sb.append(node.getQualifiedName());\n         sb.append(\" -> \");\n+\n+        if (definition.isExtern()) {\n+          sb.append(\"EXTERN \");\n+        }\n \n         Node rValue = definition.getRValue();\n         if (rValue != null) {\n         sb.append(\" -> \");\n         Multiset<String> defstrs = TreeMultiset.create();\n         for (Definition def : defs) {\n+          String defstr;\n+\n           Node rValue = def.getRValue();\n           if (rValue != null) {\n-            defstrs.add(Token.name(rValue.getType()));\n+            defstr = Token.name(rValue.getType());\n           } else {\n-            defstrs.add(\"<null>\");\n+            defstr = \"<null>\";\n           }\n+\n+          if (def.isExtern()) {\n+            defstr = \"EXTERN \" + defstr;\n+          }\n+\n+          defstrs.add(defstr);\n         }\n \n         sb.append(defstrs.toString());", "timestamp": 1279639330, "metainfo": ""}