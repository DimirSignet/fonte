{"sha": "b7d0c3ee8b19c4e9387984ed6bab561929093eed", "log": "Make sure NameAnalyzer can handle constructors defined in object literals, now that the peephole passes will fold them together  R=johnlenz DELTA=101  (85 added, 6 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1524   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n    * Class for nodes that reference a fully-qualified JS name. Fully qualified\n    * names are of form A or A.B (A.B.C, etc.). References can get the value or\n    * set the value of the JS name.\n-   *\n-   * TODO(user) Create an interface with a remove() method that is\n-   * implemented differently by type of parent node\n    */\n   private class JsNameRefNode implements RefNode {\n     /** JsName node for this reference */\n     JsName name;\n \n-    /** Top GETPROP or NAME node defining the name of this node */\n+    /**\n+     * Top GETPROP or NAME or STRING [objlit key] node defining the name of\n+     * this node\n+     */\n     Node node;\n \n     /**\n-     * Parent node of the name access (ASSIGN, VAR, FUNCTION, or CALL)\n+     * Parent node of the name access\n+     * (ASSIGN, VAR, FUNCTION, OBJECTLIT, or CALL)\n      */\n     Node parent;\n \n      * Create a node that refers to a name\n      *\n      * @param name The name\n-     * @param node The top node representing the name (GETPROP, NAME)\n+     * @param node The top node representing the name (GETPROP, NAME, STRING)\n      */\n     JsNameRefNode(JsName name, Node node) {\n       this.name = name;\n           } else {\n             replaceWithRhs(containingNode, parent);\n           }\n+          break;\n+        case Token.OBJECTLIT:\n+          // TODO(nicksantos): Come up with a way to remove this.\n+          // If we remove object lit keys, then we will need to also\n+          // create dependency scopes for them.\n           break;\n       }\n     }\n             JsName nameInfo = getName(nameNode.getString(), true);\n             recordSet(nameInfo.name, nameNode);\n           }\n+        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n+          NameInformation ns = createNameInformation(t, n, parent);\n+          if (ns != null) {\n+            recordSet(ns.name, n);\n+          }\n         }\n       }\n \n      * Records the assignment of a value to a global name.\n      *\n      * @param name Fully qualified name\n-     * @param node The top node representing the name (GETPROP, NAME)\n+     * @param node The top node representing the name (GETPROP, NAME, or STRING\n+     * [objlit key])\n      */\n     private void recordSet(String name, Node node) {\n       JsName jsn = getName(name, true);\n     String name = \"\";\n     Node rootNameNode = n;\n     boolean bNameWasShortened = false;\n-    while (NodeUtil.isGet(rootNameNode)) {\n-      Node prop = rootNameNode.getLastChild();\n-      if (rootNameNode.getType() == Token.GETPROP) {\n-        name = \".\" + prop.getString() + name;\n+    while (true) {\n+      if (NodeUtil.isGet(rootNameNode)) {\n+        Node prop = rootNameNode.getLastChild();\n+        if (rootNameNode.getType() == Token.GETPROP) {\n+          name = \".\" + prop.getString() + name;\n+        } else {\n+          // We consider the name to be \"a.b\" in a.b['c'] or a.b[x].d.\n+          bNameWasShortened = true;\n+          name = \"\";\n+        }\n+        rootNameNode = rootNameNode.getFirstChild();\n+      } else if (NodeUtil.isObjectLitKey(\n+          rootNameNode, rootNameNode.getParent())) {\n+        name = \".\" + rootNameNode.getString() + name;\n+\n+        // Check if this is an object literal assigned to something.\n+        Node objLit = rootNameNode.getParent();\n+        Node objLitParent = objLit.getParent();\n+        if (objLitParent.getType() == Token.ASSIGN) {\n+          // This must be the right side of the assign.\n+          rootNameNode = objLitParent.getFirstChild();\n+        } else if (objLitParent.getType() == Token.NAME) {\n+          // This must be a VAR initialization.\n+          rootNameNode = objLitParent;\n+        } else if (objLitParent.getType() == Token.STRING) {\n+          // This must be a object literal key initialization.\n+          rootNameNode = objLitParent;\n+        } else {\n+          return null;\n+        }\n       } else {\n-        // We consider the name to be \"a.b\" in a.b['c'] or a.b[x].d.\n-        bNameWasShortened = true;\n-        name = \"\";\n-      }\n-      rootNameNode = rootNameNode.getFirstChild();\n+        break;\n+      }\n     }\n \n     // Check whether this is a class-defining call. Classes may only be defined\n--- a/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n+++ b/test/com/google/javascript/jscomp/NameAnalyzerTest.java\n       \"throw new e();\");\n   }\n \n+  public void testClassDefinedInObjectLit1() {\n+    test(\n+      \"var data = {Foo: function() {}};\" +\n+      \"data.Foo.prototype.toString = function() {};\",\n+      \"\");\n+  }\n+\n+  public void testClassDefinedInObjectLit2() {\n+    test(\n+      \"var data = {}; data.bar = {Foo: function() {}};\" +\n+      \"data.bar.Foo.prototype.toString = function() {};\",\n+      \"\");\n+  }\n+\n+  public void testClassDefinedInObjectLit3() {\n+    test(\n+      \"var data = {bar: {Foo: function() {}}};\" +\n+      \"data.bar.Foo.prototype.toString = function() {};\",\n+      \"\");\n+  }\n+\n+  public void testClassDefinedInObjectLit4() {\n+    test(\n+      \"var data = {};\" +\n+      \"data.baz = {bar: {Foo: function() {}}};\" +\n+      \"data.baz.bar.Foo.prototype.toString = function() {};\",\n+      \"\");\n+  }\n+\n+  public void testVarReferencedInClassDefinedInObjectLit1() {\n+    testSame(\n+      \"var ref = 3;\" +\n+      \"var data = {Foo: function() { this.x = ref; }};\" +\n+      \"window.Foo = data.Foo;\");\n+  }\n+\n+  public void testVarReferencedInClassDefinedInObjectLit2() {\n+    testSame(\n+      \"var ref = 3;\" +\n+      \"var data = {Foo: function() { this.x = ref; },\" +\n+      \"            Bar: function() {}};\" +\n+      \"window.Bar = data.Bar;\");\n+  }\n+\n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     return new MarkNoSideEffectCallsAndNameAnalyzerRunner(compiler);", "timestamp": 1303338302, "metainfo": ""}