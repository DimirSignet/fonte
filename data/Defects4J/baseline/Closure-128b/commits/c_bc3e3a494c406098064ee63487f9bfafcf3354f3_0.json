{"sha": "bc3e3a494c406098064ee63487f9bfafcf3354f3", "log": "Fix a bug where the dependency graph between variables was getting out of date during flow-sensitive inlining. Fixes issue 777  R=acleung DELTA=129  (82 added, 8 deleted, 39 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5187   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n+import com.google.javascript.jscomp.MustBeReachingVariableDef.Definition;\n import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n import com.google.javascript.rhino.Node;\n \n import java.util.Collection;\n import java.util.List;\n+import java.util.Set;\n \n /**\n  * Inline variables when possible. Using the information from\n    * need two separate dataflow result.\n    */\n   private final AbstractCompiler compiler;\n+  private final Set<Var> inlinedNewDependencies = Sets.newHashSet();\n \n   // These two pieces of data is persistent in the whole execution of enter\n   // scope.\n     for (Candidate c : candidates) {\n       if (c.canInline()) {\n         c.inlineVariable();\n+\n+        // If definition c has dependencies, then inlining it may have\n+        // introduced new dependencies for our other inlining candidates.\n+        //\n+        // MustBeReachingVariableDef uses this dependency graph in its\n+        // analysis, so some of these candidates may no longer be valid.\n+        // We keep track of when the variable dependency graph changed\n+        // so that we can back off appropriately.\n+        if (!c.defMetadata.depends.isEmpty()) {\n+          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+        }\n       }\n     }\n   }\n               return;\n             }\n \n-            Node defNode = reachingDef.getDef(name, cfgNode);\n+            Definition def = reachingDef.getDef(name, cfgNode);\n             // TODO(nicksantos): We need to add some notion of @const outer\n             // scope vars. We can inline those just fine.\n-            if (defNode != null &&\n-                !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {\n-              candidates.add(new Candidate(name, defNode, n, cfgNode));\n+            if (def != null &&\n+                !reachingDef.dependsOnOuterScopeVars(def)) {\n+              candidates.add(new Candidate(name, def, n, cfgNode));\n             }\n           }\n         }\n \n     // Nodes related to the definition.\n     private Node def;\n-    private final Node defCfgNode;\n+    private final Definition defMetadata;\n \n     // Nodes related to the use.\n     private final Node use;\n     // use in the CFG.\n     private int numUseWithinUseCfgNode;\n \n-    Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {\n+    Candidate(String varName, Definition defMetadata,\n+        Node use, Node useCfgNode) {\n       Preconditions.checkArgument(use.isName());\n       this.varName = varName;\n-      this.defCfgNode = defCfgNode;\n+      this.defMetadata = defMetadata;\n       this.use = use;\n       this.useCfgNode = useCfgNode;\n     }\n \n+    private Node getDefCfgNode() {\n+      return defMetadata.node;\n+    }\n+\n     private boolean canInline() {\n-\n       // Cannot inline a parameter.\n-      if (defCfgNode.isFunction()) {\n-        return false;\n-      }\n-\n-      getDefinition(defCfgNode, null);\n+      if (getDefCfgNode().isFunction()) {\n+        return false;\n+      }\n+\n+      // If one of our dependencies has been inlined, then our dependency\n+      // graph is wrong. Re-computing it would take another CFG computation,\n+      // so we just back off for now.\n+      for (Var dependency : defMetadata.depends) {\n+        if (inlinedNewDependencies.contains(dependency)) {\n+          return false;\n+        }\n+      }\n+\n+      getDefinition(getDefCfgNode(), null);\n       getNumUseInUseCfgNode(useCfgNode, null);\n \n       // Definition was not found.\n         return false;\n       }\n \n-\n       // The right of the definition has side effect:\n       // Example, for x:\n       // x = readProp(b), modifyProp(b); print(x);\n-      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n+      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n         return false;\n       }\n \n         return false;\n       }\n \n-\n       // TODO(user): Side-effect is OK sometimes. As long as there are no\n       // side-effect function down all paths to the use. Once we have all the\n       // side-effect analysis tool.\n       }\n \n \n-      Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n+      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n \n       if (uses.size() != 1) {\n         return false;\n \n       // We can skip the side effect check along the paths of two nodes if\n       // they are just next to each other.\n-      if (NodeUtil.isStatementBlock(defCfgNode.getParent()) &&\n-          defCfgNode.getNext() != useCfgNode) {\n+      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n+          getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n         // else where along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n           pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                  cfg,\n-                 cfg.getDirectedGraphNode(defCfgNode),\n+                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                  cfg.getDirectedGraphNode(useCfgNode),\n                  SIDE_EFFECT_PREDICATE,\n                  Predicates.\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n    * this definition reads from. For example N: a = b + foo.bar(c). The\n    * definition node will be N, the depending set would be {b,c}.\n    */\n-  private static class Definition {\n+  static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n     private boolean unknownDependencies = false;\n   }\n \n   /**\n-   * Gets the must reaching definition of a given node. The node must be one of\n-   * the control flow graph nodes.\n+   * Gets the must reaching definition of a given node.\n    *\n    * @param name name of the variable. It can only be names of local variable\n    *     that are not function parameters, escaped variables or variables\n    *     declared in catch.\n    * @param useNode the location of the use where the definition reaches.\n    */\n-  Node getDef(String name, Node useNode) {\n+  Definition getDef(String name, Node useNode) {\n     Preconditions.checkArgument(getCfg().hasNode(useNode));\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n-    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n-    if (def == null) {\n-      return null;\n-    } else {\n-      return def.node;\n-    }\n-  }\n-\n-  boolean dependsOnOuterScopeVars(String name, Node useNode) {\n-    Preconditions.checkArgument(getCfg().hasNode(useNode));\n-    GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n-    FlowState<MustDef> state = n.getAnnotation();\n-    Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n+    return state.getIn().reachingDef.get(jsScope.getVar(name));\n+  }\n+\n+  Node getDefNode(String name, Node useNode) {\n+    Definition def = getDef(name, useNode);\n+    return def == null ? null : def.node;\n+  }\n+\n+  boolean dependsOnOuterScopeVars(Definition def) {\n     if (def.unknownDependencies) {\n       return true;\n     }\n--- a/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java\n       \"/** @nosideeffects */ function noSFX() {} \\n\" +\n       \"                      function hasSFX() {} \\n\";\n \n+  public FlowSensitiveInlineVariablesTest() {\n+    enableNormalize(true);\n+  }\n+\n   @Override\n   public int getNumRepetitions() {\n     // Test repeatedly inline.\n   }\n \n   public void testRemoveWithLabels() {\n-    inline(\"var x = 1; L: x = 2; print(x)\", \"var x = 1; print(2)\");\n-    inline(\"var x = 1; L: M: x = 2; print(x)\", \"var x = 1; print(2)\");\n-    inline(\"var x = 1; L: M: N: x = 2; print(x)\", \"var x = 1; print(2)\");\n+    inline(\"var x = 1; L: x = 2; print(x)\", \"var x = 1; L:{} print(2)\");\n+    inline(\"var x = 1; L: M: x = 2; print(x)\", \"var x = 1; L:M:{} print(2)\");\n+    inline(\"var x = 1; L: M: N: x = 2; print(x)\",\n+           \"var x = 1; L:M:N:{} print(2)\");\n   }\n \n   public void testInlineAcrossSideEffect1() {\n         + \"return x;\");\n   }\n \n+  public void testIssue777() {\n+    test(\n+        \"function f(cmd, ta) {\" +\n+        \"  var temp = cmd;\" +\n+        \"  var temp2 = temp >> 2;\" +\n+        \"  cmd = STACKTOP;\" +\n+        \"  for (var src = temp2, dest = cmd >> 2, stop = src + 37;\" +\n+        \"       src < stop;\" +\n+        \"       src++, dest++) {\" +\n+        \"    HEAP32[dest] = HEAP32[src];\" +\n+        \"  }\" +\n+        \"  temp = ta;\" +\n+        \"  temp2 = temp >> 2;\" +\n+        \"  ta = STACKTOP;\" +\n+        \"  STACKTOP += 8;\" +\n+        \"  HEAP32[ta >> 2] = HEAP32[temp2];\" +\n+        \"  HEAP32[ta + 4 >> 2] = HEAP32[temp2 + 1];\" +\n+        \"}\",\n+        \"function f(cmd, ta){\" +\n+        \"  var temp;\" +\n+        \"  var temp2 = cmd >> 2;\" +\n+        \"  cmd = STACKTOP;\" +\n+        \"  var src = temp2;\" +\n+        \"  var dest = cmd >> 2;\" +\n+        \"  var stop = src + 37;\" +\n+        \"  for(;src<stop;src++,dest++)HEAP32[dest]=HEAP32[src];\" +\n+        \"  temp2 = ta >> 2;\" +\n+        \"  ta = STACKTOP;\" +\n+        \"  STACKTOP += 8;\" +\n+        \"  HEAP32[ta>>2] = HEAP32[temp2];\" +\n+        \"  HEAP32[ta+4>>2] = HEAP32[temp2+1];\" +\n+        \"}\");\n+  }\n+\n+  public void testTransitiveDependencies1() {\n+    test(\n+        \"function f(x) { var a = x; var b = a; x = 3; return b; }\",\n+        \"function f(x) { var a;     var b = x; x = 3; return b; }\");\n+  }\n+\n+  public void testTransitiveDependencies2() {\n+    test(\n+        \"function f(x) { var a = x; var b = a; var c = b; x = 3; return c; }\",\n+        \"function f(x) { var a    ; var b = x; var c    ; x = 3; return b; }\");\n+  }\n+\n   private void noInline(String input) {\n     inline(input, input);\n   }\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"  a = a + 'y';\\n\" +\n         \"  return a;\\n\" +\n         \"}\",\n-        \"function f(a) {return a + 'xy'}\");\n+        // This should eventually get inlined completely.\n+        \"function f(a) { a += 'x'; return a += 'y'; }\");\n   }\n \n   public void testIssue284() {\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n \n   public void testFunctionParams1() {\n     computeDefUse(\"if (param2) { D: param1 = 1; U: param1 }\");\n-    assertSame(def, defUse.getDef(\"param1\", use));\n+    assertSame(def, defUse.getDefNode(\"param1\", use));\n   }\n \n   public void testFunctionParams2() {\n     computeDefUse(\"if (param2) { D: param1 = 1} U: param1\");\n-    assertNotSame(def, defUse.getDef(\"param1\", use));\n+    assertNotSame(def, defUse.getDefNode(\"param1\", use));\n   }\n \n   public void testArgumentsObjectModifications() {\n     computeDefUse(\"D: param1 = 1; arguments[0] = 2; U: param1\");\n-    assertNotSame(def, defUse.getDef(\"param1\", use));\n+    assertNotSame(def, defUse.getDefNode(\"param1\", use));\n   }\n \n   public void testArgumentsObjectEscaped() {\n     computeDefUse(\"D: param1 = 1; var x = arguments; x[0] = 2; U: param1\");\n-    assertNotSame(def, defUse.getDef(\"param1\", use));\n+    assertNotSame(def, defUse.getDefNode(\"param1\", use));\n   }\n \n   public void testArgumentsObjectEscapedDependents() {\n    */\n   private void assertMatch(String src) {\n     computeDefUse(src);\n-    assertSame(def, defUse.getDef(\"x\", use));\n+    assertSame(def, defUse.getDefNode(\"x\", use));\n   }\n \n   /**\n    */\n   private void assertNotMatch(String src) {\n     computeDefUse(src);\n-    assertNotSame(def, defUse.getDef(\"x\", use));\n+    assertNotSame(def, defUse.getDefNode(\"x\", use));\n   }\n \n   /**", "timestamp": 1342722512, "metainfo": ""}