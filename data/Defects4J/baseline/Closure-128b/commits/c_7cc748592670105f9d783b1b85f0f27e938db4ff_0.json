{"sha": "7cc748592670105f9d783b1b85f0f27e938db4ff", "log": "Generalize define value handling allow ADD and other basic ops, fix BITxxx handling so they don't allow invalid operands.  Fixes issue 255.  R=nicksantos DELTA=86  (84 added, 0 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=286361   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       case Token.FALSE:\n         return true;\n \n-      // Single operators are valid if the child is valid.\n+      // Binary operators are only valid if both children are valid.\n+      case Token.ADD:\n       case Token.BITAND:\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n+      case Token.DIV:\n+      case Token.EQ:\n+      case Token.GE:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.LSH:\n+      case Token.LT:\n+      case Token.MOD:\n+      case Token.MUL:\n+      case Token.NE:\n+      case Token.RSH:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.SUB:\n+      case Token.URSH:\n+        return isValidDefineValue(val.getFirstChild(), defines)\n+            && isValidDefineValue(val.getLastChild(), defines);\n+\n+      // Uniary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n+      case Token.POS:\n         return isValidDefineValue(val.getFirstChild(), defines);\n \n       // Names are valid if and only if they are defines themselves.\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicates;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n \n     return NodeUtil.evaluatesToLocalValue(value);\n   }\n+  \n+  public void testValidDefine() {\n+    assertTrue(testValidDefineValue(\"1\"));\n+    assertTrue(testValidDefineValue(\"-3\"));\n+    assertTrue(testValidDefineValue(\"true\"));\n+    assertTrue(testValidDefineValue(\"false\"));\n+    assertTrue(testValidDefineValue(\"'foo'\"));\n+    \n+    assertFalse(testValidDefineValue(\"x\"));\n+    assertFalse(testValidDefineValue(\"null\"));\n+    assertFalse(testValidDefineValue(\"undefined\"));\n+    assertFalse(testValidDefineValue(\"NaN\"));\n+    \n+    assertTrue(testValidDefineValue(\"!true\"));\n+    assertTrue(testValidDefineValue(\"-true\"));\n+    assertTrue(testValidDefineValue(\"1 & 8\"));\n+    assertTrue(testValidDefineValue(\"1 + 8\"));\n+    assertTrue(testValidDefineValue(\"'a' + 'b'\"));\n+\n+    assertFalse(testValidDefineValue(\"1 & foo\"));\n+  }\n+  \n+  private boolean testValidDefineValue(String js) {\n+    Node script = parse(\"var test = \" + js +\";\");\n+    Node var = script.getFirstChild();\n+    Node name = var.getFirstChild();\n+    Node value = name.getFirstChild();\n+\n+    ImmutableSet<String> defines = ImmutableSet.of();\n+    return NodeUtil.isValidDefineValue(value, defines);   \n+  }\n }\n--- a/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessDefinesTest.java\n         null, ProcessDefines.INVALID_DEFINE_TYPE_ERROR);\n   }\n \n-  public void testDefineWithBadValue() {\n+  public void testDefineWithBadValue1() {\n     test(\"/** @define {boolean} */ var DEF = new Boolean(true);\", null,\n         ProcessDefines.INVALID_DEFINE_INIT_ERROR);\n   }\n+  \n+  public void testDefineWithBadValue2() {\n+    test(\"/** @define {string} */ var DEF = 'x' + y;\", null,\n+        ProcessDefines.INVALID_DEFINE_INIT_ERROR);\n+  }  \n \n   public void testDefineWithDependentValue() {\n     test(\"/** @define {boolean} */ var BASE = false;\\n\" +\n         \"var DEF_OVERRIDE_TO_TRUE=true\");\n   }\n \n+  public void testOverridingString0() {\n+    test(\n+        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x';\",\n+        \"var DEF_OVERRIDE_STRING=\\\"x\\\"\");\n+  }\n+  \n+  public void testOverridingString1() {\n+    test(\n+        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';\",\n+        \"var DEF_OVERRIDE_STRING=\\\"x\\\" + \\\"y\\\"\");\n+  }  \n+  \n+  public void testOverridingString2() {\n+    overrides.put(\"DEF_OVERRIDE_STRING\", Node.newString(\"foo\"));\n+    test(\n+        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x';\",\n+        \"var DEF_OVERRIDE_STRING=\\\"foo\\\"\");\n+  }  \n+  \n+  public void testOverridingString3() {\n+    overrides.put(\"DEF_OVERRIDE_STRING\", Node.newString(\"foo\"));\n+    test(\n+        \"/** @define {string} */ var DEF_OVERRIDE_STRING = 'x' + 'y';\",\n+        \"var DEF_OVERRIDE_STRING=\\\"foo\\\"\");\n+  }\n+  \n   public void testMisspelledOverride() {\n     overrides.put(\"DEF_BAD_OVERIDE\", new Node(Token.TRUE));\n     test(\"/** @define {boolean} */ var DEF_BAD_OVERRIDE = true\",", "timestamp": 1285976239, "metainfo": ""}