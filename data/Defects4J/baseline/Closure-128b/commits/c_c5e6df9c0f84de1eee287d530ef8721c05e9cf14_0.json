{"sha": "c5e6df9c0f84de1eee287d530ef8721c05e9cf14", "log": "Enable declaring \"classTemplates\" parameters on user types. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42818325", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n   private boolean isInterface = false;\n   private Node parametersNode = null;\n   private ImmutableList<String> templateTypeNames = ImmutableList.of();\n+  private ImmutableList<String> classTypeParameterNames = ImmutableList.of();;\n \n   static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning(\n       \"JSC_EXTENDS_WITHOUT_TYPEDEF\",\n   static final DiagnosticType CONSTRUCTOR_REQUIRED =\n       DiagnosticType.warning(\"JSC_CONSTRUCTOR_REQUIRED\",\n                              \"{0} used without @constructor for {1}\");\n+\n+  static final DiagnosticType CLASS_TEMPLATE_WITHOUT_CONSTRUCTOR =\n+      DiagnosticType.warning(\n+          \"JSC_CLASS_TEMPLATE_WITHOUT_CONSTRUCTOR\",\n+          \"@classTemplate used without @constructor or @interface for {0}\");\n \n   static final DiagnosticType VAR_ARGS_MUST_BE_LAST = DiagnosticType.warning(\n       \"JSC_VAR_ARGS_MUST_BE_LAST\",\n               maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n             extendedInterfaces.add((ObjectType) maybeInterfaceType);\n           }\n+        }\n+      }\n+\n+      ImmutableList<String> typeParameters = info.getClassTemplateTypeNames();\n+      if (!typeParameters.isEmpty()) {\n+        if (isConstructor || isInterface) {\n+          this.classTypeParameterNames = typeParameters;\n+        } else {\n+          reportWarning(CLASS_TEMPLATE_WITHOUT_CONSTRUCTOR,\n+              formatFnName());\n         }\n       }\n     }\n    */\n   private FunctionType getOrCreateConstructor() {\n     FunctionType fnType = typeRegistry.createConstructorType(\n-        fnName, contents.getSourceNode(), parametersNode, returnType, null);\n+        fnName, contents.getSourceNode(), parametersNode, returnType,\n+        classTypeParameterNames);\n     JSType existingType = typeRegistry.getType(fnName);\n \n     if (makesStructs) {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n             \"required: function (): ?\",\n             \"interface members can only be empty property declarations, \" +\n             \"empty functions, or goog.abstractMethod\"));\n+  }\n+\n+  public void testConstructorClassTemplate() throws Exception {\n+    testTypes(\"/** @constructor \\n @classTemplate S,T */ function A() {}\\n\");\n+  }\n+\n+  // TODO(johnlenz): Check for bad usage\n+  public void disable_testBadClassTemplate() throws Exception {\n+    testTypes(\"/** @classTemplate T */function A() {}\",\n+        \"Bad type annotation. Unknown type nonExistent\");\n   }\n \n   public void testInterfaceExtends() throws Exception {\n         \"query.push(1);\\n\");\n   }\n \n+  public void testTemplateType8() throws Exception {\n+    testTypes(\n+        \"/** @constructor \\n\" +\n+        \" * @classTemplate S,T\\n\" +\n+        \" */\\n\" +\n+        \"function Bar() {}\\n\" +\n+        \"/**\" +\n+        \" * @param {Bar.<T>} bar \\n\" +\n+        \" * @return {T} \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function fn(bar) {}\\n\" +\n+        \"/** @param {Bar.<number>} bar */ function g(bar) {\" +\n+        \"  /** @type {!Object} */ var x = fn(bar);\" +\n+        \"}\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: Object\");\n+  }\n+\n   public void disable_testBadTemplateType4() throws Exception {\n     // TODO(johnlenz): Add a check for useless of template types.\n     // Unless there are at least two references to a Template type in", "timestamp": 1361486262, "metainfo": ""}