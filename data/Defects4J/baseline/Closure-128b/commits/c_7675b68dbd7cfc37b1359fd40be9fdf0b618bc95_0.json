{"sha": "7675b68dbd7cfc37b1359fd40be9fdf0b618bc95", "log": "fix a todo that's really easy now  R=johnlenz DELTA=67  (28 added, 12 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=417   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n            name = name.getNext()) {\n         Node value = name.getFirstChild();\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n-        JSType valueType = getDeclaredTypeInAnnotation(\n-            t, name, name.getJSDocInfo());\n+        JSType valueType = getDeclaredPropType(\n+            t, name.getJSDocInfo(), name, value);\n         JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType(\n             name, valueType);\n         if (keyType != null) {\n      * Extracts type information from either the {@code @type} tag or from\n      * the {@code @return} and {@code @param} tags.\n      */\n-    JSType getDeclaredTypeInAnnotation(\n+    private JSType getDeclaredTypeInAnnotation(\n         NodeTraversal t, Node node, JSDocInfo info) {\n       return getDeclaredTypeInAnnotation(t.getSourceName(), node, info);\n     }\n \n-    JSType getDeclaredTypeInAnnotation(String sourceName,\n+    private JSType getDeclaredTypeInAnnotation(String sourceName,\n         Node node, JSDocInfo info) {\n       JSType jsType = null;\n       Node objNode =\n       // variable's type\n       JSType type = null;\n \n-      // If a variable is assigned a function in the global scope,\n-      // make that a declared type (even if there's no doc info).\n-      // There's only one exception to this rule:\n-      // if the return type is inferred, and we're in a local\n-      // scope, we should assume the whole function is inferred.\n-      if (value != null && value.getType() == Token.FUNCTION) {\n-        FunctionType valueType = (FunctionType) value.getJSType();\n-        if (info != null || scope.isGlobal() ||\n-            !valueType.isReturnTypeInferred()) {\n-          type = value.getJSType();\n-        }\n+      if (value != null && value.getType() == Token.FUNCTION &&\n+          shouldUseFunctionLiteralType(\n+              (FunctionType) value.getJSType(), info, name)) {\n+        type = value.getJSType();\n       }\n \n       if (type == null) {\n       }\n \n       defineSlot(name, var, type);\n+    }\n+\n+    /**\n+     * If a variable is assigned a function literal in the global scope,\n+     * make that a declared type (even if there's no doc info).\n+     * There's only one exception to this rule:\n+     * if the return type is inferred, and we're in a local\n+     * scope, we should assume the whole function is inferred.\n+     */\n+    private boolean shouldUseFunctionLiteralType(\n+        FunctionType type, JSDocInfo info, Node lValue) {\n+      if (info != null) {\n+        return true;\n+      }\n+      if (lValue != null &&\n+          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n+        return false;\n+      }\n+      return scope.isGlobal() || !type.isReturnTypeInferred();\n     }\n \n     /**\n     }\n \n     /**\n-     * Look for a type declaration on a GETPROP node.\n+     * Look for a type declaration on a property assignment\n+     * (in an ASSIGN or an object literal key).\n      *\n      * @param info The doc info for this property.\n-     * @param n A top-level GETPROP node (it should not be contained inside\n-     *     another GETPROP).\n-     * @param rhsValue The node that {@code n} is being initialized to,\n+     * @param lValue The l-value node.\n+     * @param rValue The node that {@code n} is being initialized to,\n      *     or {@code null} if this is a stub declaration.\n      */\n-    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n-        Node n, @Nullable Node rhsValue) {\n+    private JSType getDeclaredPropType(NodeTraversal t, JSDocInfo info,\n+        Node lValue, @Nullable Node rValue) {\n       if (info != null && info.hasType()) {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n-      } else if (rhsValue != null && rhsValue.getType() == Token.FUNCTION) {\n-        return rhsValue.getJSType();\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n+      } else if (rValue != null && rValue.getType() == Token.FUNCTION &&\n+          shouldUseFunctionLiteralType(\n+              (FunctionType) rValue.getJSType(), info, lValue)) {\n+        return rValue.getJSType();\n       } else if (info != null && info.hasEnumParameterType()) {\n-        if (rhsValue != null && rhsValue.getType() == Token.OBJECTLIT) {\n-          return rhsValue.getJSType();\n+        if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n+          return rValue.getJSType();\n         } else {\n           return createEnumTypeFromNodes(\n-              rhsValue, n.getQualifiedName(), info, n);\n+              rValue, lValue.getQualifiedName(), info, lValue);\n         }\n       } else if (info != null &&\n                  (info.isConstructor() || info.isInterface())) {\n         return createFunctionTypeFromNodes(\n-            rhsValue, n.getQualifiedName(), info, n);\n+            rValue, lValue.getQualifiedName(), info, lValue);\n       } else {\n-        return getDeclaredTypeInAnnotation(t, n, info);\n+        return getDeclaredTypeInAnnotation(t, lValue, info);\n       }\n     }\n \n       // about getting as much type information as possible for them.\n \n       // Determining type for #1 + #2 + #3\n-      JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);\n+      JSType valueType = getDeclaredPropType(t, info, n, rhsValue);\n       if (valueType == null && rhsValue != null) {\n         // Determining type for #4\n         valueType = rhsValue.getJSType();\n         }\n \n         member.getFirstChild().setJSType(thisType);\n-        JSType jsType = getDeclaredGetPropType(t, info, member, value);\n+        JSType jsType = getDeclaredPropType(t, info, member, value);\n         Node name = member.getLastChild();\n         if (jsType != null &&\n             (name.getType() == Token.NAME || name.getType() == Token.STRING)) {\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"assignment to property abc of x\\n\" +\n         \"found   : number\\n\" +\n         \"required: boolean\");\n+  }\n+\n+  public void testObjectLiteralDeclaration3() throws Exception {\n+    testTypes(\n+        \"/** @param {{foo: !Function}} x */ function f(x) {}\" +\n+        \"f({foo: function() {}});\");\n   }\n \n   public void testCallDateConstructorAsFunction() throws Exception {\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n   }\n \n   public void testDeclaredObjectLitProperty2() throws Exception {\n-    // TODO(nicksantos): Fix this so that it infers that the type\n-    // of the function is @return void.\n     testSame(\"var x = {/** @param {number} z */ y: function(z){}};\");\n     ObjectType xType = ObjectType.cast(globalScope.getVar(\"x\").getType());\n     assertEquals(\n-        \"function (number): ?\",\n+        \"function (number): undefined\",\n          xType.getPropertyType(\"y\").toString());\n     assertEquals(\n-        \"{y: function (number): ?}\",\n+        \"{y: function (number): undefined}\",\n         xType.toString());\n   }\n \n   public void testDeclaredObjectLitProperty3() throws Exception {\n-    // TODO(nicksantos): Fix this so that it infers that the type\n-    // of the function is function(?): number.\n     testSame(\"function f() {\" +\n         \"  var x = {/** @return {number} */ y: function(z){ return 3; }};\" +\n         \"}\");\n     ObjectType xType = ObjectType.cast(lastLocalScope.getVar(\"x\").getType());\n     assertEquals(\n-        \"function (): number\",\n+        \"function (?): number\",\n          xType.getPropertyType(\"y\").toString());\n     assertEquals(\n-        \"{y: function (): number}\",\n+        \"{y: function (?): number}\",\n         xType.toString());\n   }\n ", "timestamp": 1296588139, "metainfo": ""}