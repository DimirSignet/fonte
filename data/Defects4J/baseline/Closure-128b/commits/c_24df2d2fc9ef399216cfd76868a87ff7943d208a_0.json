{"sha": "24df2d2fc9ef399216cfd76868a87ff7943d208a", "log": "Add jQuery.extend and jQuery.expandedEach support to the ExpandJqueryAliases pass.  r=johnlenz  ", "commit": "\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n       isConfigValid = false;\n       parser.printUsage(err);\n     } else {\n+      CodingConvention conv;\n+      if (flags.third_party) {\n+        conv = CodingConventions.getDefault();\n+      } else if (flags.process_jquery_primitives) {\n+        conv = new JqueryCodingConvention();\n+      } else {\n+        conv = new ClosureCodingConvention();\n+      }\n+      \n       getCommandLineConfig()\n           .setPrintTree(flags.print_tree)\n           .setPrintAst(flags.print_ast)\n           .setVariableMapOutputFile(flags.variable_map_output_file)\n           .setCreateNameMapFiles(flags.create_name_map_files)\n           .setPropertyMapOutputFile(flags.property_map_output_file)\n-          .setCodingConvention(flags.third_party ?\n-               CodingConventions.getDefault() :\n-               new ClosureCodingConvention())\n+          .setCodingConvention(conv)\n           .setSummaryDetailLevel(flags.summary_detail_level)\n           .setOutputWrapper(flags.output_wrapper)\n           .setModuleWrapper(flags.module_wrapper)\n   @Override\n   protected CompilerOptions createOptions() {\n     CompilerOptions options = new CompilerOptions();\n-    options.setCodingConvention(new ClosureCodingConvention());\n+    if (flags.process_jquery_primitives) {\n+      options.setCodingConvention(new JqueryCodingConvention());\n+    } else {\n+      options.setCodingConvention(new ClosureCodingConvention());\n+    }\n     CompilationLevel level = flags.compilation_level;\n     level.setOptionsForCompilationLevel(options);\n     if (flags.debug) {\n \n     options.jqueryPass = flags.process_jquery_primitives &&\n         CompilationLevel.ADVANCED_OPTIMIZATIONS == level;\n-\n-    if (flags.process_jquery_primitives) {\n-      options.setCodingConvention(new JqueryCodingConvention());\n-    }\n \n     if (!flags.translationsFile.isEmpty()) {\n       try {\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       }\n       return checks;\n     }\n+    \n+    if (options.jqueryPass) {\n+      checks.add(jqueryAliases.makeOneTimePass());\n+    }\n \n     checks.add(checkSideEffects);\n \n \n     if (options.closurePass) {\n       checks.add(closurePrimitives.makeOneTimePass());\n-    }\n-\n-    if (options.jqueryPass) {\n-      checks.add(jqueryAliases.makeOneTimePass());\n     }\n \n     if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {\n--- a/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n+++ b/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n \n package com.google.javascript.jscomp;\n \n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n import java.util.logging.Logger;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n \n  * replacements include:\n  *  - jQuery.fn -> jQuery.prototype\n  *  - jQuery.extend -> expanded into direct object assignments\n+ *  - jQuery.expandedEach -> expand into direct assignments\n  *\n  * @author chadkillingsworth@missouristate.edu (Chad Killingsworth)\n  */\n class ExpandJqueryAliases extends AbstractPostOrderCallback\n     implements CompilerPass {\n   private final AbstractCompiler compiler;\n+  private final CodingConvention convention;\n   private static final Logger logger =\n       Logger.getLogger(ExpandJqueryAliases.class.getName());\n-  private static final Set<String> JqueryExtendNames = ImmutableSet.of(\n+\n+  static final DiagnosticType JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR =\n+      DiagnosticType.warning(\"JSC_JQUERY_UNABLE_TO_EXPAND_INVALID_LIT\",\n+          \"jQuery.expandedEach call cannot be expanded because the first \" +\n+          \"argument must be an object literal or an array of strings \" +\n+          \"literal.\");\n+\n+  static final DiagnosticType JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR =\n+      DiagnosticType.error(\"JSC_JQUERY_UNABLE_TO_EXPAND_INVALID_NAME\",\n+          \"jQuery.expandedEach expansion would result in the invalid \" +\n+          \"property name \\\"{0}\\\".\");\n+\n+  static final DiagnosticType JQUERY_USELESS_EACH_EXPANSION =\n+      DiagnosticType.warning(\"JSC_JQUERY_USELESS_EACH_EXPANSION\",\n+          \"jQuery.expandedEach was not expanded as no valid property \" +\n+          \"assignments were encountered. Consider using jQuery.each instead.\");\n+\n+  private static final Set<String> JQUERY_EXTEND_NAMES = ImmutableSet.of(\n       \"jQuery.extend\", \"jQuery.fn.extend\", \"jQuery.prototype.extend\");\n+\n+  private static final String JQUERY_EXPANDED_EACH_NAME =\n+      \"jQuery.expandedEach\";\n+\n+  private final PeepholeOptimizationsPass peepholePasses;\n \n   ExpandJqueryAliases(AbstractCompiler compiler) {\n     this.compiler = compiler;\n-  }\n-\n-  public static boolean isJqueryExtendReference(Node n, String qname) {\n-    if (JqueryExtendNames.contains(qname)) {\n+    this.convention = compiler.getCodingConvention();\n+\n+    // All of the \"early\" peephole optimzations.\n+    // These passes should make the code easier to analyze.\n+    // Passes, such as StatementFusion, are omitted for this reason.\n+    final boolean late = false;\n+    this.peepholePasses = new PeepholeOptimizationsPass(compiler,\n+        new PeepholeSubstituteAlternateSyntax(late),\n+        new PeepholeReplaceKnownMethods(late),\n+        new PeepholeRemoveDeadCode(),\n+        new PeepholeFoldConstants(late),\n+        new PeepholeCollectPropertyAssignments());\n+  }\n+\n+  /**\n+   * Check that Node n is a call to one of the jQuery.extend methods that we\n+   * can expand. Valid calls are single argument calls where the first argument\n+   * is an object literal or two argument calls where the first argument\n+   * is a name and the second argument is an object literal.\n+   */\n+  public static boolean isJqueryExtendCall(Node n, String qname,\n+      AbstractCompiler compiler) {\n+    if (JQUERY_EXTEND_NAMES.contains(qname)) {\n       Node firstArgument = n.getNext();\n       if (firstArgument == null) {\n         return false;\n \n       Node secondArgument = firstArgument.getNext();\n       if ((firstArgument.isObjectLit() && secondArgument == null) ||\n-          (firstArgument.isName() && secondArgument != null &&\n-          secondArgument.isObjectLit() && secondArgument.getNext() == null)) {\n+          (firstArgument.isName() || NodeUtil.isGet(firstArgument) &&\n+          !NodeUtil.mayHaveSideEffects(firstArgument, compiler) &&\n+          secondArgument != null && secondArgument.isObjectLit() &&\n+          secondArgument.getNext() == null)) {\n         return true;\n       }\n+    }\n+    return false;\n+  }\n+\n+  public boolean isJqueryExpandedEachCall(Node call, String qName) {\n+    Preconditions.checkArgument(call.isCall());\n+    if (call.getFirstChild() != null &&\n+        JQUERY_EXPANDED_EACH_NAME.equals(qName)) {\n+      return true;\n     }\n     return false;\n   }\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (compiler.getCodingConvention().isPrototypeAlias(n)) {\n-      replaceJqueryPrototypeAlias(n);\n+    if (n.isGetProp() && convention.isPrototypeAlias(n)) {\n+      maybeReplaceJqueryPrototypeAlias(n);\n+\n     } else if (n.isCall()) {\n       Node callTarget = n.getFirstChild();\n       String qName = callTarget.getQualifiedName();\n \n-      if (isJqueryExtendReference(callTarget, qName)) {\n-        replaceJqueryExtendCall(n);\n+      if (isJqueryExtendCall(callTarget, qName, this.compiler)) {\n+        maybeExpandJqueryExtendCall(n);\n+\n+      } else if (isJqueryExpandedEachCall(n, qName)) {\n+        maybeExpandJqueryEachCall(t, n);\n       }\n     }\n   }\n   public void process(Node externs, Node root) {\n     logger.fine(\"Expanding Jquery Aliases\");\n \n-    // Traverse the tree and collect strings\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n-  private void replaceJqueryPrototypeAlias(Node n) {\n+  private void maybeReplaceJqueryPrototypeAlias(Node n) {\n+    // Check to see if this is the assignment of the original alias.\n+    // If so, leave it intact.\n+    if(NodeUtil.isLValue(n)) {\n+      Node maybeAssign = n.getParent();\n+      while (!NodeUtil.isStatement(maybeAssign) && !maybeAssign.isAssign()) {\n+        maybeAssign = maybeAssign.getParent();\n+      }\n+\n+      if (maybeAssign.isAssign()) {\n+        maybeAssign = maybeAssign.getParent();\n+        if (maybeAssign.isBlock() || maybeAssign.isScript() ||\n+            NodeUtil.isStatement(maybeAssign)) {\n+          return;\n+        }\n+      }\n+    }\n+\n     Node fn = n.getLastChild();\n     if (fn != null) {\n       n.replaceChild(fn, IR.string(\"prototype\"));\n     }\n   }\n \n-  private void replaceJqueryExtendCall(Node n) {\n+  /**\n+   * Expand jQuery.extend (and derivative) calls into direct object assignments\n+   * Example: jQuery.extend(obj1, {prop1: val1, prop2: val2}) ->\n+   *   obj1.prop1 = val1;\n+   *   obj1.prop2 = val2;\n+   */\n+  private void maybeExpandJqueryExtendCall(Node n) {\n     Node callTarget = n.getFirstChild();\n-    Node objectToExtend = callTarget.getNext(); //first argument\n-    Node extendArg = objectToExtend.getNext(); //second argument\n+    Node objectToExtend = callTarget.getNext(); // first argument\n+    Node extendArg = objectToExtend.getNext(); // second argument\n+    boolean ensureObjectDefined = true;\n \n     if (extendArg == null) {\n-      //Only one argument was specified, so extend jQuery namespace\n+      // Only one argument was specified, so extend jQuery namespace\n       extendArg = objectToExtend;\n       objectToExtend = callTarget.getFirstChild();\n-    }\n-\n-    //Check for an empty object literal\n-    if (!extendArg.hasChildren())\n+      ensureObjectDefined = false;\n+    } else if (objectToExtend.isGetProp() &&\n+          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n+          convention.isPrototypeAlias(objectToExtend))) {\n+      ensureObjectDefined = false;\n+    }\n+\n+    // Check for an empty object literal\n+    if (!extendArg.hasChildren()) {\n       return;\n-\n-    /* Since we are expanding jQuery.extend calls into multiple statements,\n-     * encapsulate the new statements in an immediately executed anonymous\n-     * function that returns the extended object.\n-     */\n+    }\n+\n+    // Since we are expanding jQuery.extend calls into multiple statements,\n+    // encapsulate the new statements in a new block.\n     Node fncBlock = IR.block().srcref(n);\n+\n+    if (ensureObjectDefined) {\n+      Node assignVal = IR.or(objectToExtend.cloneTree(),\n+          IR.objectlit().srcref(n)).srcref(n);\n+      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n+      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n+    }\n \n     while (extendArg.hasChildren()) {\n       Node currentProp = extendArg.removeFirstChild();\n       fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n     }\n \n-    Node targetVal;\n-    if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n-      /* When extending the jQuery prototype, return the jQuery namespace.\n-       * No known uses of the return value exist for this case.\n-       * TODO(Chad Killingsworth): Check jQuery plugins\n-       */\n-      targetVal = objectToExtend.getFirstChild().cloneTree();\n+    // Check to see if the return value is used. If not, replace the original\n+    // call with new block. Otherwise wrap the statements in an\n+    // immediately-called anonymous function.\n+    if (n.getParent().isExprResult()) {\n+      Node parent = n.getParent();\n+      parent.getParent().replaceChild(parent, fncBlock);\n     } else {\n-      targetVal = objectToExtend.cloneTree();\n-    }\n-    fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n-\n-    Node fnc = IR.function(IR.name(\"\").srcref(n),\n-        IR.paramList().srcref(n),\n-        fncBlock);\n-    n.replaceChild(callTarget, fnc);\n-    n.putBooleanProp(Node.FREE_CALL, true);\n-\n-    //remove any other pre-existing call arguments\n-    while(fnc.getNext() != null) {\n-      n.removeChildAfter(fnc);\n-    }\n-\n+      Node targetVal;\n+      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n+        // When extending the jQuery prototype, return the jQuery namespace.\n+        // This is not commonly used.\n+        targetVal = objectToExtend.removeFirstChild();\n+      } else {\n+        targetVal = objectToExtend.detachFromParent();\n+      }\n+      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n+\n+      Node fnc = IR.function(IR.name(\"\").srcref(n),\n+          IR.paramList().srcref(n),\n+          fncBlock);\n+      n.replaceChild(callTarget, fnc);\n+      n.putBooleanProp(Node.FREE_CALL, true);\n+\n+      // remove any other pre-existing call arguments\n+      while(fnc.getNext() != null) {\n+        n.removeChildAfter(fnc);\n+      }\n+    }\n     compiler.reportCodeChange();\n   }\n-}\n+\n+  /**\n+   * Expand a jQuery.expandedEach call\n+   *\n+   * Expanded jQuery.expandedEach calls will replace the GETELEM nodes of a\n+   * property assignment with GETPROP nodes to allow for renaming.\n+   */\n+  private void maybeExpandJqueryEachCall(NodeTraversal t, Node n) {\n+    Node objectToLoopOver = n.getChildAtIndex(1);\n+\n+    if (objectToLoopOver == null) {\n+      return;\n+    }\n+\n+    Node callbackFunction = objectToLoopOver.getNext();\n+    if (callbackFunction == null || !callbackFunction.isFunction()) {\n+      return;\n+    }\n+\n+    // Run the peephole optimizations on the first argument to handle\n+    // cases like (\"a \" + \"b\").split(\" \")\n+    peepholePasses.process(null, n.getChildAtIndex(1));\n+\n+    // Create a reference tree\n+    Node nClone = n.cloneTree();\n+\n+    objectToLoopOver = nClone.getChildAtIndex(1);\n+\n+    // Check to see if the first argument is something we recognize and can\n+    // expand.\n+    if (!objectToLoopOver.isObjectLit() &&\n+        !(objectToLoopOver.isArrayLit() &&\n+        isArrayLitValidForExpansion(objectToLoopOver))) {\n+      t.report(n, JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR, (String)null);\n+      return;\n+    }\n+\n+    // Find all references to the callback function arguments\n+    List<Node> keyNodeReferences = Lists.newArrayList();\n+    List<Node> valueNodeReferences = Lists.newArrayList();\n+\n+    NodeTraversal.traverse(compiler,\n+        NodeUtil.getFunctionBody(callbackFunction),\n+        new FindCallbackArgumentReferences(callbackFunction, \n+            keyNodeReferences, valueNodeReferences,\n+            objectToLoopOver.isArrayLit()));\n+\n+    if(keyNodeReferences.size() == 0) {\n+     // We didn't do anything useful ...\n+      t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String)null);\n+      return;\n+    }\n+\n+    Node fncBlock = tryExpandJqueryEachCall(t, nClone, callbackFunction,\n+        keyNodeReferences, valueNodeReferences);\n+\n+    if (fncBlock != null && fncBlock.hasChildren()) {\n+        replaceOriginalJqueryEachCall(n, fncBlock);\n+    } else {\n+      // We didn't do anything useful ...\n+      t.report(n, JQUERY_USELESS_EACH_EXPANSION, (String)null);\n+    }\n+  }\n+\n+  private Node tryExpandJqueryEachCall(NodeTraversal t, Node n,\n+      Node callbackFunction, List<Node> keyNodes, List<Node> valueNodes) {\n+\n+    Node callTarget = n.getFirstChild();\n+    Node objectToLoopOver = callTarget.getNext();\n+\n+    // New block to contain the expanded statements\n+    Node fncBlock = IR.block().srcref(callTarget);\n+\n+    boolean isValidExpansion = true;\n+\n+    // Expand the jQuery.expandedEach call\n+    Node key = objectToLoopOver.getFirstChild(), val = null;\n+    for(int i = 0; key != null; key = key.getNext(), i++) {\n+      if (key != null) {\n+        if (objectToLoopOver.isArrayLit()) {\n+          // Arrays have a value of their index number\n+          val = IR.number(i).srcref(key);\n+        } else {\n+          val = key.getFirstChild();\n+        }\n+      }\n+\n+      // Keep track of the replaced nodes so we can reset the tree\n+      List<Node> newKeys = Lists.newArrayList();\n+      List<Node> newValues = Lists.newArrayList();\n+      List<Node> origGetElems = Lists.newArrayList();\n+      List<Node> newGetProps = Lists.newArrayList();\n+\n+      // Replace all of the key nodes with the prop name\n+      for (int j = 0; j < keyNodes.size(); j++) {\n+        Node origNode = keyNodes.get(j);\n+        Node ancestor = origNode.getParent();\n+\n+        Node newNode = IR.string(key.getString()).srcref(key);\n+        newKeys.add(newNode);\n+        ancestor.replaceChild(origNode, newNode);\n+\n+        // Walk up the tree to see if the key is used in a GETELEM\n+        // assignment\n+        while (ancestor != null && !NodeUtil.isStatement(ancestor) &&\n+            !ancestor.isGetElem()) {\n+          ancestor = ancestor.getParent();\n+        }\n+\n+        // Convert GETELEM nodes to GETPROP nodes so that they can be\n+        // renamed or removed.\n+        if (ancestor != null && ancestor.isGetElem()) {\n+\n+          Node propObject = ancestor;\n+          while (propObject.isGetProp() || propObject.isGetElem()) {\n+            propObject = propObject.getFirstChild();\n+          }\n+\n+          Node ancestorClone = ancestor.cloneTree();\n+          // Run the peephole passes to handle cases such as\n+          // obj['lit' + key] = val;\n+          peepholePasses.process(null, ancestorClone.getChildAtIndex(1));\n+          Node prop = ancestorClone.getChildAtIndex(1);\n+\n+          if (prop.isString() &&\n+            NodeUtil.isValidPropertyName(prop.getString())) {\n+            Node target = ancestorClone.getFirstChild();\n+            Node newGetProp = IR.getprop(target.detachFromParent(),\n+                prop.detachFromParent());\n+            newGetProps.add(newGetProp);\n+            origGetElems.add(ancestor);\n+            ancestor.getParent().replaceChild(ancestor, newGetProp);\n+          } else {\n+            if (prop.isString() &&\n+                !NodeUtil.isValidPropertyName(prop.getString())) {\n+              t.report(n,\n+                  JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR,\n+                  prop.getString());\n+            }\n+            isValidExpansion = false;\n+          }\n+        }\n+      }\n+\n+      if (isValidExpansion) {\n+        // Replace all of the value nodes with the prop value\n+        for (int j = 0; val != null && j < valueNodes.size(); j++) {\n+          Node origNode = valueNodes.get(j);\n+          Node newNode = val.cloneTree();\n+          newValues.add(newNode);\n+          origNode.getParent().replaceChild(origNode, newNode);\n+        }\n+\n+        // Wrap the new tree in an anonymous function call\n+        Node fnc = IR.function(IR.name(\"\").srcref(key),\n+            IR.paramList().srcref(key),\n+            callbackFunction.getChildAtIndex(2).cloneTree()).srcref(key);\n+        Node call = IR.call(fnc).srcref(key);\n+        call.putBooleanProp(Node.FREE_CALL, true);\n+        fncBlock.addChildToBack(IR.exprResult(call).srcref(call));\n+      }\n+\n+      // Reset the source tree\n+      for (int j = 0; j < newGetProps.size(); j++) {\n+        newGetProps.get(j).getParent().replaceChild(newGetProps.get(j),\n+            origGetElems.get(j));\n+      }\n+      for (int j = 0; j < newKeys.size(); j++) {\n+        newKeys.get(j).getParent().replaceChild(newKeys.get(j),\n+            keyNodes.get(j));\n+      }\n+      for (int j = 0; j < newValues.size(); j++) {\n+        newValues.get(j).getParent().replaceChild(newValues.get(j),\n+            valueNodes.get(j));\n+      }\n+\n+      if (!isValidExpansion) {\n+        return null;\n+      }\n+    }\n+    return fncBlock;\n+  }\n+\n+  private void replaceOriginalJqueryEachCall(Node n, Node expandedBlock) {\n+    // Check to see if the return value of the original jQuery.expandedEach\n+    // call is used. If so, we need to wrap each loop expansion in an anonymous\n+    // function and return the original objectToLoopOver.\n+    if (n.getParent().isExprResult()) {\n+      Node parent = n.getParent();\n+      Node grandparent = parent.getParent();\n+      Node insertAfter = parent;\n+      while (expandedBlock.hasChildren()) {\n+        Node child = expandedBlock.getFirstChild().detachFromParent();\n+        grandparent.addChildAfter(child, insertAfter);\n+        insertAfter = child;\n+      }\n+      grandparent.removeChild(parent);\n+    } else {\n+      // Return the original object\n+      Node callTarget = n.getFirstChild();\n+      Node objectToLoopOver = callTarget.getNext();\n+\n+      objectToLoopOver.detachFromParent();\n+      Node ret = IR.returnNode(objectToLoopOver).srcref(callTarget);\n+      expandedBlock.addChildToBack(ret);\n+\n+      // Wrap all of the expanded loop calls in a new anonymous function\n+      Node fnc = IR.function(IR.name(\"\").srcref(callTarget),\n+          IR.paramList().srcref(callTarget),\n+          expandedBlock);\n+      n.replaceChild(callTarget, fnc);\n+      n.putBooleanProp(Node.FREE_CALL, true);\n+\n+      // remove any other pre-existing call arguments\n+      while(fnc.getNext() != null) {\n+        n.removeChildAfter(fnc);\n+      }\n+    }\n+    compiler.reportCodeChange();\n+  }\n+\n+  private boolean isArrayLitValidForExpansion(Node n) {\n+    Iterator<Node> iter = n.children().iterator();\n+    while (iter.hasNext()) {\n+      Node child = iter.next();\n+      if (!child.isString()) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Given a jQuery.expandedEach callback function, traverse it and collect any\n+   * references to its parameter names.\n+   */\n+  class FindCallbackArgumentReferences extends AbstractPostOrderCallback\n+      implements ScopedCallback {\n+\n+    private final String keyName;\n+    private final String valueName;\n+    private Scope startingScope;\n+    private List<Node> keyReferences;\n+    private List<Node> valueReferences;\n+\n+    FindCallbackArgumentReferences(Node functionRoot, List<Node> keyReferences,\n+        List<Node> valueReferences, boolean useArrayMode) {\n+      Preconditions.checkState(functionRoot.isFunction());\n+\n+      String keyString = null, valueString = null;\n+      Node callbackParams = NodeUtil.getFunctionParameters(functionRoot);\n+      Node param = callbackParams.getFirstChild();\n+      if (param != null) {\n+        Preconditions.checkState(param.isName());\n+        keyString = param.getString();\n+\n+        param = param.getNext();\n+        if (param != null) {\n+          Preconditions.checkState(param.isName());\n+          valueString = param.getString();\n+        }\n+      }\n+\n+      this.keyName = keyString;\n+      this.valueName = valueString;\n+\n+      // For arrays, the keyString is the index number of the element.\n+      // We're interested in the value of the element instead\n+      if (useArrayMode) {\n+        this.keyReferences = valueReferences;\n+        this.valueReferences = keyReferences;\n+      } else {\n+        this.keyReferences = keyReferences;\n+        this.valueReferences = valueReferences;\n+      }\n+\n+      this.startingScope = null;\n+    }\n+\n+    private boolean isShadowed(String name, Scope scope) {\n+      Var nameVar = scope.getVar(name);\n+      return nameVar != null &&\n+          nameVar.getScope() != this.startingScope;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      // In the top scope, \"this\" is a reference to \"value\"\n+      boolean isThis = false;\n+      if (t.getScope() == this.startingScope) {\n+        isThis = n.isThis();\n+      }\n+\n+      if (isThis || n.isName() && !isShadowed(n.getString(), t.getScope())) {\n+        String nodeValue = isThis ? null : n.getString();\n+        if (!isThis && keyName != null && nodeValue.equals(keyName)) {\n+          keyReferences.add(n);\n+        } else if (isThis || (valueName != null &&\n+            nodeValue.equals(valueName))) {\n+          valueReferences.add(n);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * As we enter each scope, make sure that the scope doesn't define\n+     * a local variable with the same name as our original callback method\n+     * parameter names.\n+     */\n+    @Override\n+    public void enterScope(NodeTraversal t) {\n+      if (this.startingScope == null) {\n+        this.startingScope = t.getScope();\n+      }\n+    }\n+\n+    @Override\n+    public void exitScope(NodeTraversal t) { }\n+  }\n+}\n--- a/src/com/google/javascript/jscomp/JqueryCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/JqueryCodingConvention.java\n package com.google.javascript.jscomp;\n \n import java.util.Set;\n+\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.Node;\n     return \"window\";\n   }\n \n-  private final Set<String> propertyTestFunctions = ImmutableSet.of(\n+  private final static Set<String> propertyTestFunctions = ImmutableSet.of(\n       \"jQuery.isPlainObject\", \"jQuery.isFunction\", \"jQuery.isNumeric\",\n       \"jQuery.isEmptyObject\");\n \n         call.getFirstChild().getQualifiedName());\n   }\n \n-  private final Set<String> prototypeAliases = ImmutableSet.of(\n+  private final static Set<String> prototypeAliases = ImmutableSet.of(\n       \"jQuery.fn\", \"jQuerySub.fn\");\n \n   @Override\n-  public boolean isPrototypeAlias(Node n) {\n-    if (n.isGetProp()) {\n-      if (n.isName() || n.isGetProp() || n.isGetElem()) {\n-        return !NodeUtil.isLValue(n) &&\n-            prototypeAliases.contains(n.getQualifiedName());\n-      } else {\n-        return prototypeAliases.contains(n.getQualifiedName());\n-      }\n-    }\n-    return false;\n+  public boolean isPrototypeAlias(Node getProp) {\n+    Preconditions.checkArgument(getProp.isGetProp());\n+    return prototypeAliases.contains(getProp.getQualifiedName());\n   }\n }\n--- a/test/com/google/javascript/jscomp/ExpandJqueryAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ExpandJqueryAliasesTest.java\n public class ExpandJqueryAliasesTest extends CompilerTestCase {\n   private JqueryCodingConvention conv = new JqueryCodingConvention();\n \n+  final DiagnosticType NAME_ERROR =\n+      ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME_ERROR;\n+\n+  final DiagnosticType INVALID_LIT_ERROR =\n+      ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_LIT_ERROR;\n+\n+  final DiagnosticType USELESS_EACH_ERROR =\n+      ExpandJqueryAliases.JQUERY_USELESS_EACH_EXPANSION;\n+\n   public ExpandJqueryAliasesTest() {}\n \n   @Override\n         setupCode + \"jQuerySub.prototype.foo='bar';\");\n   }\n \n-  public void testJqueryExtendAliasExpansion() {\n+  public void testJqueryExtendExpansion() {\n     String setupCode = \"var jQuery={},obj2={};\";\n \n-    //test invalid extend call\n+    // test for extend call that should not be expanded - no arguments\n     testSame(setupCode + \"jQuery.extend()\");\n \n-    //test empty extend call\n+    // test for extend call that should not be expanded - empty argument\n+    // this statement has no effect in actual code\n     testSame(setupCode + \"jQuery.extend({})\");\n \n-    test(\"jQuery.extend({a:'test'})\",\n-        \"(function(){jQuery.a='test';return jQuery})()\");\n+    // test single argument call - should assign to the jQuery namespace\n+    test(setupCode + \"jQuery.extend({a:'test'})\",\n+        setupCode + \"{jQuery.a = 'test';}\");\n \n-    //Extend the jQuery prototype\n+    // test expansion when extending the jQuery prototype\n     test(setupCode + \"jQuery.fn=jQuery.prototype;\" +\n         \"jQuery.fn.extend({a:'test', b:'test2'});\",\n-        setupCode + \"jQuery.fn=jQuery.prototype;(function(){\" +\n-        \"jQuery.prototype.a='test';jQuery.prototype.b='test2';\" +\n-        \"return jQuery;})()\");\n+        setupCode + \"jQuery.fn=jQuery.prototype;\" +\n+        \"{jQuery.prototype.a = 'test'; jQuery.prototype.b = 'test2';}\");\n \n-    //Extend obj2\n+    // Expand the extension of obj2\n     test(setupCode + \"jQuery.extend(obj2, {a:'test', b:'test2'});\",\n+        setupCode + \"{obj2=obj2||{}; obj2.a='test'; obj2.b='test2';}\");\n+\n+    // Expand the jQuery namespace - 2 argument call\n+    // Must ensure that the first argument is defined\n+    test(setupCode + \"jQuery.extend(jQuery,{a:'test', b:'test2'});\",\n+        setupCode + \"{jQuery = jQuery || {}; jQuery.a = 'test';\" +\n+        \"jQuery.b = 'test2';}\");\n+\n+    // Test extend call where first argument includes a method call\n+    testSame(setupCode+\"obj2.meth=function() { return { a:{} }; };\" +\n+        \"jQuery.extend(obj2.meth().a, {a: 'test'});\");\n+  }\n+\n+  public void testJqueryExpandedEachExpansion() {\n+    String setupCode = \"var jQuery={};\" +\n+        \"jQuery.expandedEach=function(vals, callback){};\";\n+\n+    testSame(setupCode);\n+\n+    // Test expansion with object literal\n+    test(setupCode + \"jQuery.expandedEach({'a': 1, 'b': 2, 'c': 8},\" +\n+        \"function(key, val) { var a = key; jQuery[key] = val; });\",\n+        setupCode + \"(function(){ var a = 'a'; jQuery.a = 1 })();\" +\n+        \"(function(){ var a = 'b'; jQuery.b = 2 })();\" +\n+        \"(function(){ var a = 'c'; jQuery.c = 8 })();\");\n+\n+    // Test expansion with array literal\n+    // For array literals, the key parameter will be the element index number\n+    // and the value parameter will be the string literal. In this case, the\n+    // string literal value should become a property name.\n+    test(setupCode + \"jQuery.expandedEach(['a', 'b', 'c'],\" +\n+        \"function(key, val){ jQuery[val] = key; });\",\n+        setupCode + \"(function(){ jQuery.a = 0; })();\" +\n+        \"(function(){ jQuery.b = 1; })();\" + \n+        \"(function(){ jQuery.c = 2 })();\");\n+\n+    // Test expansion with object literal using 'this' keyword\n+    test(setupCode + \"jQuery.expandedEach({'a': 1, 'b': 2, 'c': 8},\" +\n+        \"function(key, val) { var a = key; jQuery[key] = this; });\",\n+        setupCode + \"(function(){ var a = 'a'; jQuery.a = 1 })();\" +\n+        \"(function(){ var a = 'b'; jQuery.b = 2 })();\" +\n+        \"(function(){ var a = 'c'; jQuery.c = 8 })();\");\n+\n+    // Test expansion with array literal using 'this' keyword\n+    test(setupCode + \"jQuery.expandedEach(['a', 'b', 'c'],\" +\n+        \"function(key, val){ jQuery[this] = key; });\",\n+        setupCode + \"(function(){ jQuery.a = 0; })();\" +\n+        \"(function(){ jQuery.b = 1; })();\" + \n+        \"(function(){ jQuery.c = 2 })();\");\n+\n+    // test nested function using argument name to shadow callback name\n+    test(setupCode + \"jQuery.expandedEach(['a'], function(key,val) {\" +\n+        \"jQuery[val] = key; (function(key) { jQuery[key] = 1;})('test'); })\",\n+        setupCode + \"(function(){ jQuery.a = 0;\" + \n+         \"(function(key){ jQuery[key] = 1})('test') })()\");\n+\n+    // test nested function using var name to shadow callback name\n+    test(setupCode + \"jQuery.expandedEach(['a'], function(key,val) {\" +\n+        \"jQuery[val] = key; (function(key) { var val = 2;\" +\n+        \"jQuery[key] = val;})('test');})\",\n         setupCode + \"(function(){\" +\n-        \"obj2.a='test';obj2.b='test2';return obj2})()\");\n+        \"jQuery.a=0;\" + \n+        \"(function(key){var val = 2; jQuery[key] = val;})('test')})()\");\n \n-    //Extend the jQuery namespace - 2 argument call\n-    test(setupCode + \"jQuery.extend(jQuery,{a:'test', b:'test2'});\",\n+    // test nested function using function name to shadow callback name\n+    test(setupCode + \"jQuery.expandedEach(['a'], function(key,val) {\" +\n+        \"jQuery[val] = key; (function(key1) {\" +\n+        \"function key() {}; key();\" +\n+        \"})('test');})\",\n         setupCode + \"(function(){\" +\n-        \"jQuery.a='test';jQuery.b='test2';return jQuery})()\");\n+        \"jQuery.a=0;(function(key1) {\" +\n+        \"function key() {}; key(); })('test')})()\");\n+\n+    // test using return val\n+    test(setupCode + \"alert(jQuery.expandedEach(['a'],\" +\n+        \"function(key,val) { jQuery[val] = key;})[0])\",\n+        setupCode + \"alert((function(){\" +\n+        \"(function(){ jQuery.a = 0;})(); return ['a']})()[0]);\");\n+\n+    // Loop object is a variable. Test that warning is raised.\n+    testSame(setupCode + \"var a = ['a'];\" +\n+        \"jQuery.expandedEach(a, function(key,val){ jQuery[key]=val; })\",\n+        INVALID_LIT_ERROR);\n+\n+    // Invalid property name. Test that warning is raised.\n+    testSame(setupCode + \"var obj2={};\" +\n+        \"jQuery.expandedEach(['foo','bar'], function(i, name) {\" +\n+        \"obj2[ '[object ' + name + ']' ] = 'a';});\", NAME_ERROR, true);\n+\n+    // Useless expansion (key not used). Test that warning is raised.\n+    testSame(setupCode + \"var obj2={};\" +\n+        \"jQuery.expandedEach(['foo','bar'], function(i, name) {\" +\n+        \"obj2[i] = 1;});\", USELESS_EACH_ERROR, false);\n   }\n }", "timestamp": 1334776549, "metainfo": ""}