{"sha": "57ed289a74973e0bc04bd684faf3c4580e0cb812", "log": "Original change by tylerg on 2011/10/05 14:37:35.  Flesh out the function type lattice a bit better. This is mostly just implementing tylerg's original suggestion, but with more comments  R=tylerg DELTA=135  (53 added, 33 deleted, 49 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3421   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     return super.defineProperty(name, type, inferred, propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    return supAndInfHelper(that, true);\n-  }\n-\n-  @Override\n-  public JSType getGreatestSubtype(JSType that) {\n-    return supAndInfHelper(that, false);\n-  }\n-\n-  /**\n-   * Computes the supremum or infimum of functions with other types.\n+  /**\n+   * Computes the supremum or infimum of two functions.\n    * Because sup() and inf() share a lot of logic for functions, we use\n    * a single helper.\n    * @param leastSuper If true, compute the supremum of {@code this} with\n    *     {@code that}. Otherwise compute the infimum.\n    * @return The least supertype or greatest subtype.\n    */\n-  private JSType supAndInfHelper(JSType that, boolean leastSuper) {\n+  FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {\n     // NOTE(nicksantos): When we remove the unknown type, the function types\n     // form a lattice with the universal constructor at the top of the lattice,\n     // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.\n     // types (like unions of functions), we just fallback on the simpler\n     // approach of getting things right at the top and the bottom of the\n     // lattice.\n-    if (isFunctionType() && that.isFunctionType()) {\n-      if (isEquivalentTo(that)) {\n-        return this;\n-      }\n-\n-      FunctionType other = that.toMaybeFunctionType();\n-\n-      // If these are ordinary functions, then merge them.\n-      // Don't do this if any of the params/return\n-      // values are unknown, because then there will be cycles in\n-      // their local lattice and they will merge in weird ways.\n-      if (other != null &&\n-          isOrdinaryFunction() && that.isOrdinaryFunction() &&\n-          !this.call.hasUnknownParamsOrReturn() &&\n-          !other.call.hasUnknownParamsOrReturn()) {\n-\n-        // Check for the degenerate case, but double check\n-        // that there's not a cycle.\n-        boolean isSubtypeOfThat = this.isSubtype(that);\n-        boolean isSubtypeOfThis = that.isSubtype(this);\n-        if (isSubtypeOfThat && !isSubtypeOfThis) {\n-          return leastSuper ? that : this;\n-        } else if (isSubtypeOfThis && !isSubtypeOfThat) {\n-          return leastSuper ? this : that;\n-        }\n-\n-        // Merge the two functions component-wise.\n-        FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper);\n-        if (merged != null) {\n-          return merged;\n-        }\n-      }\n-\n-      // The function instance type is a special case\n-      // that lives above the rest of the lattice.\n-      JSType functionInstance = registry.getNativeType(\n-          JSTypeNative.FUNCTION_INSTANCE_TYPE);\n-      if (functionInstance.isEquivalentTo(that)) {\n+    //\n+    // If there are unknown parameters or return types making things\n+    // ambiguous, then sup(A, B) is always the top function type, and\n+    // inf(A, B) is always the bottom function type.\n+    Preconditions.checkNotNull(that);\n+\n+    if (isEquivalentTo(that)) {\n+      return this;\n+    }\n+\n+    // If these are ordinary functions, then merge them.\n+    // Don't do this if any of the params/return\n+    // values are unknown, because then there will be cycles in\n+    // their local lattice and they will merge in weird ways.\n+    if (isOrdinaryFunction() && that.isOrdinaryFunction() &&\n+        !this.call.hasUnknownParamsOrReturn() &&\n+        !that.call.hasUnknownParamsOrReturn()) {\n+\n+      // Check for the degenerate case, but double check\n+      // that there's not a cycle.\n+      boolean isSubtypeOfThat = this.isSubtype(that);\n+      boolean isSubtypeOfThis = that.isSubtype(this);\n+      if (isSubtypeOfThat && !isSubtypeOfThis) {\n         return leastSuper ? that : this;\n-      } else if (functionInstance.isEquivalentTo(this)) {\n+      } else if (isSubtypeOfThis && !isSubtypeOfThat) {\n         return leastSuper ? this : that;\n       }\n \n-      // In theory, we should be using the GREATEST_FUNCTION_TYPE as the\n-      // greatest function. In practice, we don't because it's way too\n-      // broad. The greatest function takes var_args None parameters, which\n-      // means that all parameters register a type warning.\n-      //\n-      // Instead, we use the U2U ctor type, which has unknown type args.\n-      FunctionType greatestFn =\n-          registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n-      FunctionType leastFn =\n-          registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);\n-      return leastSuper ? greatestFn : leastFn;\n-    }\n-\n-    return leastSuper ?\n-        super.getLeastSupertype(that) :\n-        super.getGreatestSubtype(that);\n+      // Merge the two functions component-wise.\n+      FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);\n+      if (merged != null) {\n+        return merged;\n+      }\n+    }\n+\n+    // The function instance type is a special case\n+    // that lives above the rest of the lattice.\n+    JSType functionInstance = registry.getNativeType(\n+        JSTypeNative.FUNCTION_INSTANCE_TYPE);\n+    if (functionInstance.isEquivalentTo(that)) {\n+      return leastSuper ? that : this;\n+    } else if (functionInstance.isEquivalentTo(this)) {\n+      return leastSuper ? this : that;\n+    }\n+\n+    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the\n+    // greatest function. In practice, we don't because it's way too\n+    // broad. The greatest function takes var_args None parameters, which\n+    // means that all parameters register a type warning.\n+    //\n+    // Instead, we use the U2U ctor type, which has unknown type args.\n+    FunctionType greatestFn =\n+        registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n+    FunctionType leastFn =\n+        registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);\n+    return leastSuper ? greatestFn : leastFn;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * getGreatestSubtype implementations.\n    */\n   static JSType getGreatestSubtype(JSType thisType, JSType thatType) {\n-    if (thisType.isEquivalentTo(thatType)) {\n+    if (thisType.isFunctionType() && thatType.isFunctionType()) {\n+      // The FunctionType sub-lattice is not well-defined. i.e., the\n+      // proposition\n+      // A < B => sup(A, B) == B\n+      // does not hold because of unknown parameters and return types.\n+      // See the comment in supAndInfHelper for more info on this.\n+      return thisType.toMaybeFunctionType().supAndInfHelper(\n+          thatType.toMaybeFunctionType(), false);\n+    } else if (thisType.isEquivalentTo(thatType)) {\n       return thisType;\n     } else if (thisType.isUnknownType() || thatType.isUnknownType()) {\n       // The greatest subtype with any unknown type is the universal\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n         }\n       } else {\n         if (alternates.size() > maxUnionSize) {\n+          return this;\n+        }\n+\n+        // Function types are special, because they have their\n+        // own bizarro sub-lattice. See the commants on\n+        // FunctionType#supAndInf helper and above at functionTypePosition.\n+        if (alternate.isFunctionType() && functionTypePosition != -1) {\n+          // See the comments on functionTypePosition above.\n+          FunctionType other =\n+              alternates.get(functionTypePosition).toMaybeFunctionType();\n+          FunctionType supremum =\n+              alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n+          alternates.set(functionTypePosition, supremum);\n+          result = null;\n           return this;\n         }\n \n \n         if (alternate.isFunctionType()) {\n           // See the comments on functionTypePosition above.\n-          if (functionTypePosition == -1) {\n-            functionTypePosition = alternates.size();\n-            alternates.add(alternate);\n-          } else {\n-            JSType supremum = alternate.toMaybeFunctionType().getLeastSupertype(\n-                alternates.get(functionTypePosition).toMaybeFunctionType());\n-            Preconditions.checkState(supremum.isFunctionType());\n-            alternates.set(functionTypePosition, supremum);\n-          }\n-        } else {\n-          alternates.add(alternate);\n-        }\n-\n+          Preconditions.checkState(functionTypePosition == -1);\n+          functionTypePosition = alternates.size();\n+        }\n+\n+        alternates.add(alternate);\n         result = null; // invalidate the memoized result\n       }\n     } else {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n       }\n     }\n   }\n+\n+  public void testProxiedFunctionTypeRelationships() {\n+    FunctionType dateMethodEmpty = new FunctionBuilder(registry)\n+      .withParamsNode(registry.createParameters())\n+      .withTypeOfThis(DATE_TYPE).build().toMaybeFunctionType();\n+    FunctionType dateMethodWithParam = new FunctionBuilder(registry)\n+      .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+      .withTypeOfThis(DATE_TYPE).build().toMaybeFunctionType();\n+    ProxyObjectType proxyDateMethodEmpty =\n+        new ProxyObjectType(registry, dateMethodEmpty);\n+    ProxyObjectType proxyDateMethodWithParam =\n+        new ProxyObjectType(registry, dateMethodWithParam);\n+\n+    assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n+        proxyDateMethodEmpty.getLeastSupertype(proxyDateMethodWithParam));\n+    assertTypeEquals(LEAST_FUNCTION_TYPE,\n+        proxyDateMethodEmpty.getGreatestSubtype(proxyDateMethodWithParam));\n+  }\n+\n   /**\n    * Tests relationships between structural function types.\n    */", "timestamp": 1317922877, "metainfo": ""}