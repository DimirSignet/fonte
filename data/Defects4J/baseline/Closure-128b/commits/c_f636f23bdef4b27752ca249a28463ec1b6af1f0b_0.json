{"sha": "f636f23bdef4b27752ca249a28463ec1b6af1f0b", "log": "defer evaluation of the @lends annotation fixes issue 314  R=johnlenz DELTA=69  (61 added, 0 deleted, 8 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4094   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /**\n    * Set the variable removal policy for the compiler.\n-   * @deprecated\n-   */\n+   */\n+  @Deprecated\n   public void setRemoveUnusedVariable(Reach reach) {\n     setRemoveUnusedVariables(reach);\n   }\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n     private final List<Node> nonExternFunctions = Lists.newArrayList();\n \n     /**\n+     * Object literals with a @lends annotation aren't analyzed until we\n+     * reach the root of the statement they're defined in.\n+     *\n+     * This ensures that if there are any @lends annotations on the object\n+     * literals, the type on the @lends annotation resolves correctly.\n+     *\n+     * For more information, see\n+     * http://code.google.com/p/closure-compiler/issues/detail?id=314\n+     */\n+    private List<Node> lentObjectLiterals = null;\n+\n+    /**\n      * Type-less stubs.\n      *\n      * If at the end of traversal, we still don't have types for these\n           }\n           break;\n       }\n+\n+      // Analyze any @lends object literals in this statement.\n+      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n+          lentObjectLiterals != null) {\n+        for (Node objLit : lentObjectLiterals) {\n+          defineObjectLiteral(objLit);\n+        }\n+        lentObjectLiterals.clear();\n+      }\n     }\n \n     private void attachLiteralTypes(NodeTraversal t, Node n) {\n           break;\n \n         case Token.OBJECTLIT:\n-          defineObjectLiteral(t, n);\n+          JSDocInfo info = n.getJSDocInfo();\n+          if (info != null &&\n+              info.getLendsName() != null) {\n+            if (lentObjectLiterals == null) {\n+              lentObjectLiterals = Lists.newArrayList();\n+            }\n+            lentObjectLiterals.add(n);\n+          } else {\n+            defineObjectLiteral(n);\n+          }\n           break;\n \n           // NOTE(nicksantos): If we ever support Array tuples,\n       }\n     }\n \n-    private void defineObjectLiteral(NodeTraversal t, Node objectLit) {\n+    private void defineObjectLiteral(Node objectLit) {\n       // Handle the @lends annotation.\n       JSType type = null;\n       JSDocInfo info = objectLit.getJSDocInfo();\n \n       // If this is an enum, the properties were already taken care of above.\n       processObjectLitProperties(\n-          t, objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);\n+          objectLit, ObjectType.cast(objectLit.getJSType()), !createdEnumType);\n     }\n \n     /**\n      *     well. If false, the caller should take crae of this.\n      */\n     void processObjectLitProperties(\n-        NodeTraversal t, Node objLit, ObjectType objLitType,\n+        Node objLit, ObjectType objLitType,\n         boolean declareOnOwner) {\n       for (Node keyNode = objLit.getFirstChild(); keyNode != null;\n            keyNode = keyNode.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(keyNode);\n         JSDocInfo info = keyNode.getJSDocInfo();\n         JSType valueType =\n-            getDeclaredType(t.getSourceName(), info, keyNode, value);\n+            getDeclaredType(keyNode.getSourceFileName(), info, keyNode, value);\n         JSType keyType =  objLitType.isEnumType() ?\n             objLitType.toMaybeEnumType().getElementsType() :\n             NodeUtil.getObjectLitKeyTypeFromValueType(keyNode, valueType);\n \n         if (keyType != null && objLitType != null && declareOnOwner) {\n           // Declare this property on its object literal.\n-          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n+          boolean isExtern = keyNode.isFromExterns();\n           objLitType.defineDeclaredProperty(memberName, keyType, keyNode);\n         }\n       }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n             \"Bad type annotation. missing object name in @lends tag\"));\n   }\n \n+  public void testLends10() throws Exception {\n+    testTypes(\n+        \"function defineClass(x) { return function() {}; } \" +\n+        \"/** @constructor */\" +\n+        \"var Foo = defineClass(\" +\n+        \"    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));\" +\n+        \"/** @return {string} */ function f() { return (new Foo()).bar; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testLends11() throws Exception {\n+    testTypes(\n+        \"function defineClass(x, y) { return function() {}; } \" +\n+        \"/** @constructor */\" +\n+        \"var Foo = function() {};\" +\n+        \"/** @return {*} */ Foo.prototype.bar = function() { return 3; };\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */\\n\" +\n+        \"var SubFoo = defineClass(Foo, \" +\n+        \"    /** @lends {SubFoo.prototype} */ ({\\n\" +\n+        \"      /** @return {number} */ bar: function() { return 3; }}));\" +\n+        \"/** @return {string} */ function f() { return (new SubFoo()).bar(); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n   public void testDeclaredNativeTypeEquality() throws Exception {\n     Node n = parseAndTypeCheck(\"/** @constructor */ function Object() {};\");\n     assertEquals(registry.getNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE),", "timestamp": 1326818276, "metainfo": ""}