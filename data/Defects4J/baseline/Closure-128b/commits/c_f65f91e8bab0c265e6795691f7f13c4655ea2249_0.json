{"sha": "f65f91e8bab0c265e6795691f7f13c4655ea2249", "log": "Add JsFunctionParser to jscomp/deps  R=nicksantos DELTA=318  (318 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=124   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/JsFunctionParser.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.base.CharMatcher;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.ErrorManager;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.util.Collection;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A parser that can extract dependency information from a .js file.\n+ * \n+ * @author agrieve@google.com (Andrew Grieve)\n+ * @author ielashi@google.com (Islam El-Ashi)\n+ */\n+public class JsFunctionParser extends JsFileLineParser {\n+  \n+  public static class SymbolInfo {\n+    public final String functionName;\n+    public final String symbol;\n+    \n+    private SymbolInfo(String functionName, String symbol) {\n+      this.functionName = functionName;\n+      this.symbol = symbol;\n+    }\n+  }\n+\n+  private static Logger logger = Logger.getLogger(JsFunctionParser.class.getName());\n+\n+  /** Pattern for matching functions. */\n+  private Pattern pattern;\n+\n+  /** Matcher used in the parsing. */\n+  private Matcher matcher;\n+\n+  /** Symbols parsed. */\n+  private Collection<SymbolInfo> symbols;\n+  \n+  /** Functions to parse */\n+  private Collection<String> functionsToParse;\n+\n+  /**\n+   * Constructor\n+   *\n+   * @param functions Functions to parse.\n+   * @param errorManager Handles parse errors.\n+   */\n+  public JsFunctionParser(Collection<String> functions, ErrorManager errorManager) {\n+    super(errorManager);\n+    functionsToParse = functions;\n+    pattern = getPattern(functions);\n+    matcher = pattern.matcher(\"\");\n+  }\n+\n+  /**\n+   * Constructs a pattern to extract the arguments of the given functions.\n+   * \n+   * @param functions Functions to parse.\n+   * @return A pattern to extract {@code functions}' arguments.\n+   */\n+  private Pattern getPattern(Collection<String> functions) {\n+    StringBuilder sb = new StringBuilder(\"(?:^|;)\\\\s*(\");\n+    \n+    for (String function : functions) {\n+      sb.append(Pattern.quote(function) + \"|\");\n+    }\n+    \n+    // remove last '|'\n+    sb.deleteCharAt(sb.length() - 1);\n+    sb.append(\")\\\\s*\\\\((.*?)\\\\)\");\n+    \n+    return Pattern.compile(sb.toString());\n+  }\n+  \n+  /**\n+   * Parses the given file and returns the dependency information that it\n+   * contained.\n+   *\n+   * @param filePath Path to the file to parse.\n+   * @param fileContents The contents to parse.\n+   * @return A collection containing all symbols found in the\n+   *     file.\n+   */\n+  public Collection<SymbolInfo> parseFile(String filePath, String fileContents) {\n+    return parseReader(filePath, new StringReader(fileContents));\n+  }\n+\n+  private Collection<SymbolInfo> parseReader(String filePath, Reader fileContents) {\n+    symbols = Lists.newArrayList();\n+\n+    logger.fine(\"Parsing Source: \" + filePath);\n+    doParse(filePath, fileContents);\n+\n+    return symbols;\n+  }\n+  \n+  /**\n+   * Parses a line of javascript, extracting dependency information.\n+   */\n+  @Override\n+  protected boolean parseLine(String line) throws ParseException {\n+    boolean hasFunctions = false;\n+    boolean parseLine = false;\n+\n+    // Quick sanity check that will catch most cases. This is a performance\n+    // win for people with a lot of JS.\n+    for (String function : functionsToParse) {\n+      if (line.indexOf(function) != -1) {\n+        parseLine = true;\n+        break;\n+      }\n+    }\n+    \n+    if (parseLine) {\n+      matcher.reset(line);\n+      while (matcher.find()) {\n+        hasFunctions = true;\n+        String functionName = matcher.group(1);\n+        String arg = parseJsString(matcher.group(2)); // Parse the param.  \n+        symbols.add(new SymbolInfo(functionName, arg));\n+      }\n+    }\n+\n+    return !shortcutMode || hasFunctions ||\n+        CharMatcher.WHITESPACE.matchesAllOf(line);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/deps/JsFunctionParserTest.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.PrintStreamErrorManager;\n+import com.google.javascript.jscomp.deps.JsFunctionParser.SymbolInfo;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Tests for {@link JsFunctionParser}\n+ * \n+ * @author agrieve@google.com (Andrew Grieve)\n+ * @author ielashi@google.com (Islam El-Ashi)\n+ */\n+public class JsFunctionParserTest extends TestCase {\n+  private static final String SRC_PATH = \"a\";\n+  private JsFunctionParser parser;\n+  private ErrorManager errorManager;\n+  private Collection<String> functions = Lists.newArrayList(\n+      \"goog.require\", \"goog.provide\");\n+\n+  @Override\n+  public void setUp() {\n+    errorManager = new PrintStreamErrorManager(System.err);\n+    parser = new JsFunctionParser(functions, errorManager);\n+    parser.setShortcutMode(true);\n+  }\n+\n+  /**\n+   * Tests:\n+   *  -Parsing of comments,\n+   *  -Parsing of different styles of quotes,\n+   *  -Correct recording of what was parsed.\n+   */\n+  public void testParseFile() {\n+    final String CONTENTS = \"/*\"\n+      + \"goog.provide('no1');*//*\\n\"\n+      + \"goog.provide('no2');\\n\"\n+      + \"*/goog.provide('yes1');\\n\"\n+      + \"/* blah */goog.provide(\\\"yes2\\\")/* blah*/\\n\"\n+      + \"goog.require('yes3'); // goog.provide('no3');\\n\"\n+      + \"// goog.provide('no4');\\n\"\n+      + \"goog.require(\\\"bar.data.SuperstarAddStarThreadActionRequestDelegate\\\"); \"\n+      + \"//no new line at eof\";\n+\n+    Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n+\n+    Iterator<SymbolInfo> i = symbols.iterator();\n+    SymbolInfo symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes1\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes2\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes3\");\n+    assertEquals(symbolInfo.functionName, \"goog.require\");\n+    \n+    symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"bar.data.SuperstarAddStarThreadActionRequestDelegate\");\n+    assertEquals(symbolInfo.functionName, \"goog.require\");\n+    \n+    assertEquals(symbols.size(), 4);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testMultiplePerLine() {\n+    final String CONTENTS = \"goog.provide('yes1');goog.provide('yes2');/*\"\n+        + \"goog.provide('no1');*/goog.provide('yes3');//goog.provide('no2');\";\n+\n+    Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n+    \n+    Iterator<SymbolInfo> i = symbols.iterator();\n+    SymbolInfo symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes1\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes2\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes3\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    assertEquals(symbols.size(), 3);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testShortcutMode1() {\n+    // For efficiency reasons, we stop reading after the ctor.\n+    final String CONTENTS = \" // hi ! \\n /* this is a comment */ \"\n+        + \"goog.provide('yes1');\\n /* and another comment */ \\n\"\n+        + \"goog.provide('yes2'); // include this\\n\"\n+        + \"function foo() {}\\n\"\n+        + \"goog.provide('no1');\";\n+\n+    Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n+    \n+    Iterator<SymbolInfo> i = symbols.iterator();\n+    SymbolInfo symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes1\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes2\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    assertEquals(symbols.size(), 2);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testShortcutMode2() {\n+    final String CONTENTS = \"/** goog.provide('no1'); \\n\" +\n+        \" * goog.provide('no2');\\n */\\n\"\n+        + \"goog.provide('yes1');\\n\";\n+    \n+    Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n+    \n+    Iterator<SymbolInfo> i = symbols.iterator();\n+    SymbolInfo symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes1\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    \n+    assertEquals(symbols.size(), 1);\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+\n+  public void testShortcutMode3() {\n+    final String CONTENTS = \"/**\\n\" +\n+        \" * goog.provide('no1');\\n */\\n\"\n+        + \"goog.provide('yes1');\\n\";\n+    \n+    Collection<SymbolInfo> symbols = parser.parseFile(SRC_PATH, CONTENTS);\n+    \n+    Iterator<SymbolInfo> i = symbols.iterator();\n+    SymbolInfo symbolInfo = i.next();\n+    assertEquals(symbolInfo.symbol, \"yes1\");\n+    assertEquals(symbolInfo.functionName, \"goog.provide\");\n+    assertEquals(0, errorManager.getErrorCount());\n+    assertEquals(0, errorManager.getWarningCount());\n+  }\n+}", "timestamp": 1292289963, "metainfo": ""}