{"sha": "d24a652c89b3798648fade2401b741eae981d535", "log": "Enhance the ProcessTweaks pass so that it: -Strips out all goog.tweak calls when tweakProcessing == STRIP -Adds a var to the beginning of the input with compiler overrides when tweakProcessing == CHECK  R=nicksantos DELTA=369  (356 added, 3 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=235   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.base.Supplier;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n       removeTryCatchFinally();\n     }\n \n-    if (!options.stripTypes.isEmpty() ||\n+    if (options.getTweakProcessing().shouldStrip() ||\n+        !options.stripTypes.isEmpty() ||\n         !options.stripNameSuffixes.isEmpty() ||\n         !options.stripTypePrefixes.isEmpty() ||\n         !options.stripNamePrefixes.isEmpty()) {\n     startPass(\"stripCode\");\n     StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n         stripTypePrefixes, stripNamePrefixes);\n+    if (options.getTweakProcessing().shouldStrip()) {\n+      r.enableTweakStripping();\n+    }\n     process(r);\n     endPass();\n   }\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Replacements for @defines. Will be Boolean, Numbers, or Strings */\n   private Map<String, Object> defineReplacements;\n+\n+  /** What kind of processing to do for goog.tweak functions. */\n+  private TweakProcessing tweakProcessing;\n+\n+  /** Replacements for tweaks. Will be Boolean, Numbers, or Strings */\n+  private Map<String, Object> tweakReplacements;\n \n   /** Move top level function declarations to the top */\n   public boolean moveFunctionDeclarations;\n     customPasses = null;\n     markNoSideEffectCalls = false;\n     defineReplacements = Maps.newHashMap();\n+    tweakProcessing = TweakProcessing.OFF;\n+    tweakReplacements = Maps.newHashMap();\n     moveFunctionDeclarations = false;\n     instrumentationTemplate = null;\n     appNameStr = \"\";\n    * Returns the map of define replacements.\n    */\n   public Map<String, Node> getDefineReplacements() {\n+    return getReplacementsHelper(defineReplacements);\n+  }\n+\n+  /**\n+   * Returns the map of tweak replacements.\n+   */\n+  public Map<String, Node> getTweakReplacements() {\n+    return getReplacementsHelper(tweakReplacements);\n+  }\n+\n+  /**\n+   * Creates a map of String->Node from a map of String->Number/String/Boolean.\n+   */\n+  private static Map<String, Node> getReplacementsHelper(\n+      Map<String, Object> source) {\n     Map<String, Node> map = Maps.newHashMap();\n-    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {\n+    for (Map.Entry<String, Object> entry : source.entrySet()) {\n       String name = entry.getKey();\n       Object value = entry.getValue();\n       if (value instanceof Boolean) {\n   }\n \n   /**\n+   * Sets the value of the tweak in JS\n+   * to a boolean literal.\n+   */\n+  public void setTweakToBooleanLiteral(String tweakId, boolean value) {\n+    tweakReplacements.put(tweakId, new Boolean(value));\n+  }\n+\n+  /**\n+   * Sets the value of the tweak in JS to a\n+   * String literal.\n+   */\n+  public void setTweakToStringLiteral(String tweakId, String value) {\n+    tweakReplacements.put(tweakId, value);\n+  }\n+\n+  /**\n+   * Sets the value of the tweak in JS to a\n+   * number literal.\n+   */\n+  public void setTweakToNumberLiteral(String tweakId, int value) {\n+    tweakReplacements.put(tweakId, new Integer(value));\n+  }\n+\n+  /**\n+   * Sets the value of the tweak in JS to a\n+   * number literal.\n+   */\n+  public void setTweakToDoubleLiteral(String tweakId, double value) {\n+    tweakReplacements.put(tweakId, new Double(value));\n+  }\n+\n+  /**\n    * Skip all possible passes, to make the compiler as fast as possible.\n    */\n   public void skipAllCompilerPasses() {\n   }\n \n   /**\n+   * Sets how goog.tweak calls are processed.\n+   */\n+  public void setTweakProcessing(TweakProcessing tweakProcessing) {\n+    this.tweakProcessing = tweakProcessing;\n+  }\n+\n+  public TweakProcessing getTweakProcessing() {\n+    return tweakProcessing;\n+  }\n+\n+  /**\n    * Whether to include \"undefined\" in the default types.\n    *   For example:\n    *     \"{Object}\" is normally \"Object|null\" becomes \"Object|null|undefined\"\n       return this != OFF;\n     }\n   }\n+\n+  public static enum TweakProcessing {\n+    OFF,  // Do not run the ProcessTweaks pass.\n+    CHECK, // Run the pass, but do not strip out the calls.\n+    STRIP;  // Strip out all calls to goog.tweak.*.\n+\n+    public boolean isOn() {\n+      return this != OFF;\n+    }\n+\n+    public boolean shouldStrip() {\n+      return this == STRIP;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     checks.add(options.messageBundle != null ?\n         replaceMessages : createEmptyPass(\"replaceMessages\"));\n \n+    if (options.getTweakProcessing().isOn()) {\n+      checks.add(processTweaks);\n+    }\n+\n     // Defines in code always need to be processed.\n     checks.add(processDefines);\n \n       return new StrictModeCheck(compiler,\n           !options.checkSymbols,  // don't check variables twice\n           !options.checkCaja);    // disable eval check if not Caja\n+    }\n+  };\n+\n+  /** Process goog.tweak.getTweak() calls. */\n+  final PassFactory processTweaks = new PassFactory(\"processTweaks\", true) {\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler compiler) {\n+      return new CompilerPass() {\n+        @Override\n+        public void process(Node externs, Node jsRoot) {\n+          new ProcessTweaks(compiler,\n+              options.getTweakProcessing().shouldStrip(),\n+              options.getTweakReplacements()).process(externs, jsRoot);\n+        }\n+      };\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n \n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.SortedMap;\n \n /**\n  * Process goog.tweak primitives. Checks that:\n class ProcessTweaks implements CompilerPass {\n \n   private final AbstractCompiler compiler;\n+  private final boolean stripTweaks;\n+  private final SortedMap<String, Node> compilerDefaultValueOverrides;\n+  \n+  /**\n+   * Var name for the map of tweakId->defaultValue of the compiler-specified\n+   * overrides. Added only when stripTweaks == false.\n+   */\n+  private static final String DEFAULT_VALUES_VAR_NAME =\n+      \"__JSCOMPILER_TWEAK_DEFAULT_VALUE_OVERRIDES\";\n+  \n   private static final CharMatcher ID_MATCHER = CharMatcher.inRange('a', 'z').\n       or(CharMatcher.inRange('A', 'Z')).or(CharMatcher.anyOf(\"0123456789_.\"));\n \n     String getExpectedTypeName() {\n       return expectedTypeName;\n     }\n+    \n+    Node createDefaultValueNode() {\n+      switch (this) {\n+        case REGISTER_BOOLEAN:\n+          return new Node(Token.FALSE);\n+        case REGISTER_NUMBER:\n+          return Node.newNumber(0);\n+        case REGISTER_STRING:\n+          return Node.newString(\"\");\n+      }\n+      throw new IllegalStateException();\n+    }\n   }\n   \n   // A map of function name -> TweakFunction.\n     }\n   }\n           \n-  ProcessTweaks(AbstractCompiler compiler) {\n+  ProcessTweaks(AbstractCompiler compiler, boolean stripTweaks,\n+      Map<String, Node> compilerDefaultValueOverrides) {\n     this.compiler = compiler;\n+    this.stripTweaks = stripTweaks;\n+    // Having the map sorted is required for the unit tests to be deterministic.\n+    this.compilerDefaultValueOverrides = Maps.newTreeMap();\n+    this.compilerDefaultValueOverrides.putAll(compilerDefaultValueOverrides);\n   }\n \n   @Override\n   public void process(Node externs, Node root) {\n-    collectTweaks(root);\n+    Map<String, TweakInfo> tweakInfos = collectTweaks(root);\n+    applyCompilerDefaultValueOverrides(tweakInfos);\n+\n+    boolean changed = false;\n+\n+    if (stripTweaks) {\n+      changed = stripAllCalls(tweakInfos);\n+    } else if (!compilerDefaultValueOverrides.isEmpty()) {\n+      // Pass the compiler default value overrides to the JS through a specially\n+      // named variable.\n+      Node varNode = createCompilerDefaultValueOverridesVarNode(\n+          root.getFirstChild());\n+      root.getFirstChild().addChildToFront(varNode);\n+      changed = true;\n+    }\n+    if (changed) {\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * Removes all CALL nodes in the given TweakInfos, replacing calls to getter\n+   * functions with the tweak's default value.\n+   */\n+  private boolean stripAllCalls(Map<String, TweakInfo> tweakInfos) {\n+    for (TweakInfo tweakInfo : tweakInfos.values()) {\n+      boolean isRegistered = tweakInfo.isRegistered();\n+      for (TweakFunctionCall functionCall : tweakInfo.functionCalls) {\n+        Node callNode = functionCall.callNode;\n+        Node parent = callNode.getParent();\n+        if (functionCall.tweakFunc.isGetterFunction()) {\n+          Node newValue;\n+          if (isRegistered) {\n+            newValue = tweakInfo.getDefaultValueNode().cloneNode();\n+          } else {\n+            // When we find a getter of an unregistered tweak, there has\n+            // already been a warning about it, so now just use a default\n+            // value when stripping.\n+            TweakFunction registerFunction =\n+                functionCall.tweakFunc.registerFunction;\n+            newValue = registerFunction.createDefaultValueNode();\n+          }\n+          parent.replaceChild(callNode, newValue);\n+        } else {\n+          Node voidZeroNode = new Node(Token.VOID)\n+              .copyInformationFrom(callNode);\n+          voidZeroNode.addChildToBack(Node.newNumber(0)\n+              .copyInformationFrom(callNode));\n+          parent.replaceChild(callNode, voidZeroNode);\n+        }\n+      }\n+    }\n+    return !tweakInfos.isEmpty();\n+  }\n+\n+  /**\n+   * Creates the var __JSCOMPILER_TWEAK_DEFAULT_VALUE_OVERRIDES = { ... };\n+   * snippet that is prepended when there are compiler overrides and tweaks\n+   * are not stripped.\n+   */\n+  private Node createCompilerDefaultValueOverridesVarNode(\n+      Node sourceInformationNode) {\n+    Node varNode = new Node(Token.VAR)\n+        .copyInformationFrom(sourceInformationNode);\n+    Node nameNode = Node.newString(Token.NAME, DEFAULT_VALUES_VAR_NAME)\n+        .copyInformationFrom(sourceInformationNode);\n+    Node objNode = new Node(Token.OBJECTLIT)\n+        .copyInformationFrom(sourceInformationNode);\n+    varNode.addChildToBack(nameNode);\n+    nameNode.addChildToBack(objNode);\n+    for (Entry<String, Node> entry : compilerDefaultValueOverrides.entrySet()) {\n+      Node objKeyNode = Node.newString(entry.getKey())\n+          .copyInformationFrom(sourceInformationNode);\n+      Node objValueNode = entry.getValue().cloneNode()\n+          .copyInformationFrom(sourceInformationNode);\n+      objKeyNode.addChildToBack(objValueNode);\n+      objNode.addChildToBack(objKeyNode);\n+    }\n+    return varNode;\n+  }\n+\n+  /** Sets the default values of tweaks based on compiler options. */\n+  private void applyCompilerDefaultValueOverrides(\n+      Map<String, TweakInfo> tweakInfos) {\n+    for (Entry<String, Node> entry : compilerDefaultValueOverrides.entrySet()) {\n+      String tweakId = entry.getKey();\n+      TweakInfo tweakInfo = tweakInfos.get(tweakId);\n+      if (tweakInfo == null) {\n+        compiler.report(JSError.make(UNKNOWN_TWEAK_WARNING, tweakId));\n+      } else {\n+        tweakInfo.defaultValueNode = entry.getValue();\n+      }\n+    }\n   }\n \n   /**\n       registerCall = new TweakFunctionCall(sourceName, tweakFunc, callNode,\n           defaultValueNode);\n       functionCalls.add(registerCall);\n-      if (this.defaultValueNode == null) {\n-        this.defaultValueNode = defaultValueNode;\n-      }\n     }\n     \n     void addOverrideDefaultValueCall(String sourceName,\n     boolean isRegistered() {\n       return registerCall != null;\n     }\n+    \n+    Node getDefaultValueNode() {\n+      Preconditions.checkState(isRegistered());\n+      // Use calls to goog.tweak.overrideDefaultValue() first.\n+      if (defaultValueNode != null) {\n+        return defaultValueNode;\n+      }\n+      // Use the value passed to the register function next.\n+      if (registerCall.valueNode != null) {\n+        return registerCall.valueNode;\n+      }\n+      // Otherwise, use the default value for the tweak's type.\n+      return registerCall.tweakFunc.createDefaultValueNode();\n+    }\n   }\n }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n             Set<String> stripNamePrefixes) {\n \n     this.compiler = compiler;\n-    this.stripTypes = stripTypes;\n-    this.stripNameSuffixes = stripNameSuffixes;\n-    this.stripTypePrefixes = stripTypePrefixes;\n-    this.stripNamePrefixes = stripNamePrefixes;\n+    this.stripTypes = Sets.newHashSet(stripTypes);\n+    this.stripNameSuffixes = Sets.newHashSet(stripNameSuffixes);\n+    this.stripTypePrefixes = Sets.newHashSet(stripTypePrefixes);\n+    this.stripNamePrefixes = Sets.newHashSet(stripNamePrefixes);\n     this.varsToRemove = Sets.newHashSet();\n+  }\n+\n+  /**\n+   * Enables stripping of goog.tweak functions.\n+   */\n+  public void enableTweakStripping() {\n+    stripTypes.add(\"goog.tweak\");\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/ProcessTweaksTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessTweaksTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Maps;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Map;\n+\n /**\n  * @author agrieve@google.com (Andrew Grieve)\n  */\n public class ProcessTweaksTest extends CompilerTestCase {\n \n+  Map<String, Node> defaultValueOverrides;\n+  boolean stripTweaks;\n+  \n   public ProcessTweaksTest() {\n-    super(\"var externMethod;\");\n+    super(\"function alert(arg) {}\");\n+  }\n+  \n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    defaultValueOverrides = Maps.newHashMap();\n+    stripTweaks = false;\n   }\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new ProcessTweaks(compiler);\n+    return new ProcessTweaks(compiler, stripTweaks, defaultValueOverrides);\n   }\n \n   @Override\n   public void testWithNoTweaks() {\n     testSame(\"var DEF=true;var x={};x.foo={}\");\n   }\n+  \n+  public void testStrippingWithImplicitDefaultValues() {\n+    stripTweaks = true;\n+    test(\"goog.tweak.registerNumber('TweakA', 'desc');\" +\n+        \"goog.tweak.registerBoolean('TweakB', 'desc');\" +\n+        \"goog.tweak.registerString('TweakC', 'desc');\" +\n+        \"alert(goog.tweak.getNumber('TweakA'));\" +\n+        \"alert(goog.tweak.getBoolean('TweakB'));\" +\n+        \"alert(goog.tweak.getString('TweakC'));\",\n+        \"void 0; void 0; void 0; alert(0); alert(false); alert('')\");\n+  }\n+  \n+  public void testStrippingWithExplicitDefaultValues() {\n+    stripTweaks = true;\n+    test(\"goog.tweak.registerNumber('TweakA', 'desc', 5);\" +\n+        \"goog.tweak.registerBoolean('TweakB', 'desc', true);\" +\n+        \"goog.tweak.registerString('TweakC', 'desc', '!');\" +\n+        \"alert(goog.tweak.getNumber('TweakA'));\" +\n+        \"alert(goog.tweak.getBoolean('TweakB'));\" +\n+        \"alert(goog.tweak.getString('TweakC'));\",\n+        \"void 0; void 0; void 0; alert(5); alert(true); alert('!')\");\n+  }\n+\n+  public void testStrippingWithInCodeOverrides() {\n+    stripTweaks = true;\n+    test(\"goog.tweak.overrideDefaultValue('TweakA', 5);\" +\n+        \"goog.tweak.overrideDefaultValue('TweakB', true);\" +\n+        \"goog.tweak.overrideDefaultValue('TweakC', 'bar');\" +\n+        \"goog.tweak.registerNumber('TweakA', 'desc');\" +\n+        \"goog.tweak.registerBoolean('TweakB', 'desc');\" +\n+        \"goog.tweak.registerString('TweakC', 'desc', 'foo');\" +\n+        \"alert(goog.tweak.getNumber('TweakA'));\" +\n+        \"alert(goog.tweak.getBoolean('TweakB'));\" +\n+        \"alert(goog.tweak.getString('TweakC'));\",\n+        \"void 0; void 0; void 0; void 0; void 0; void 0;\" +\n+        \"alert(5); alert(true); alert('bar');\");\n+  }\n+\n+  public void testStrippingWithUnregisteredTweak1() {\n+    stripTweaks = true;\n+    test(\"alert(goog.tweak.getNumber('TweakA'));\",\n+        \"alert(0)\", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+  \n+  public void testStrippingWithUnregisteredTweak2() {\n+    stripTweaks = true;\n+    test(\"alert(goog.tweak.getBoolean('TweakB'))\",\n+        \"alert(false)\", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+  \n+  public void testStrippingWithUnregisteredTweak3() {\n+    stripTweaks = true;\n+    test(\"alert(goog.tweak.getString('TweakC'))\",\n+        \"alert('')\", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n+  }\n+  \n+  public void testOverridesWithStripping() {\n+    stripTweaks = true;\n+    defaultValueOverrides.put(\"TweakA\", Node.newNumber(1));\n+    defaultValueOverrides.put(\"TweakB\", new Node(Token.FALSE));\n+    defaultValueOverrides.put(\"TweakC\", Node.newString(\"!\"));\n+    test(\"goog.tweak.overrideDefaultValue('TweakA', 5);\" +\n+        \"goog.tweak.overrideDefaultValue('TweakC', 'bar');\" +\n+        \"goog.tweak.registerNumber('TweakA', 'desc');\" +\n+        \"goog.tweak.registerBoolean('TweakB', 'desc', true);\" +\n+        \"goog.tweak.registerString('TweakC', 'desc', 'foo');\" +\n+        \"alert(goog.tweak.getNumber('TweakA'));\" +\n+        \"alert(goog.tweak.getBoolean('TweakB'));\" +\n+        \"alert(goog.tweak.getString('TweakC'));\",\n+        \"void 0; void 0; void 0; void 0; void 0; \" +\n+        \"alert(1); alert(false); alert('!')\");\n+  }\n+\n+  public void testCompilerOverridesNoStripping() {\n+    defaultValueOverrides.put(\"TweakA\", Node.newNumber(1));\n+    defaultValueOverrides.put(\"TweakB\", new Node(Token.FALSE));\n+    defaultValueOverrides.put(\"TweakC\", Node.newString(\"!\"));\n+    test(\"goog.tweak.registerNumber('TweakA', 'desc');\" +\n+        \"goog.tweak.registerBoolean('TweakB', 'desc', true);\" +\n+        \"goog.tweak.registerString('TweakC', 'desc', 'foo')\",\n+        \"var __JSCOMPILER_TWEAK_DEFAULT_VALUE_OVERRIDES =\" +\n+        \"  { 'TweakA': 1, 'TweakB': false, 'TweakC': '!' };\" +\n+        \"goog.tweak.registerNumber('TweakA', 'desc');\" +\n+        \"goog.tweak.registerBoolean('TweakB', 'desc', true);\" +\n+        \"goog.tweak.registerString('TweakC', 'desc', 'foo')\");\n+  }\n+\n+  public void testUnknownCompilerOverride() {\n+    allowSourcelessWarnings();\n+    defaultValueOverrides.put(\"TweakA\", Node.newString(\"!\"));\n+    test(\"\",\n+        \"var __JSCOMPILER_TWEAK_DEFAULT_VALUE_OVERRIDES =\" +\n+        \"  { 'TweakA': '!' };\", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING); \n+  }\n }", "timestamp": 1294687647, "metainfo": ""}