{"sha": "ed37dd19685194d86d86f13c801f48f0f762fbc0", "log": "Remove some redundancy from RecordType.  R=dimvar DELTA=31  (0 added, 21 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5917   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n \n package com.google.javascript.rhino.jstype;\n \n-import com.google.common.collect.Maps;\n-import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n \n import java.util.Map;\n import java.util.Set;\n-import java.util.SortedMap;\n \n /**\n  * A record (structural) type.\n class RecordType extends PrototypeObjectType {\n   private static final long serialVersionUID = 1L;\n \n-  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n   private final boolean declared;\n   private boolean isFrozen = false;\n \n \n   boolean checkRecordEquivalenceHelper(\n       RecordType otherRecord, EquivalenceMethod eqMethod) {\n-    Set<String> keySet = properties.keySet();\n-    Map<String, JSType> otherProps = otherRecord.properties;\n-    if (!otherProps.keySet().equals(keySet)) {\n+    Set<String> keySet = getOwnPropertyNames();\n+    Set<String> otherKeySet = otherRecord.getOwnPropertyNames();\n+    if (!otherKeySet.equals(keySet)) {\n       return false;\n     }\n     for (String key : keySet) {\n-      if (!otherProps.get(key).checkEquivalenceHelper(\n-              properties.get(key), eqMethod)) {\n+      if (!otherRecord.getPropertyType(key).checkEquivalenceHelper(\n+              getPropertyType(key), eqMethod)) {\n         return false;\n       }\n     }\n       boolean inferred, Node propertyNode) {\n     if (isFrozen) {\n       return false;\n-    }\n-\n-    if (!inferred) {\n-      properties.put(propertyName, type);\n     }\n \n     return super.defineProperty(propertyName, type, inferred,\n       // The greatest subtype consists of those *unique* properties of both\n       // record types. If any property conflicts, then the NO_TYPE type\n       // is returned.\n-      for (String property : properties.keySet()) {\n+      for (String property : getOwnPropertyNames()) {\n         if (thatRecord.hasProperty(property) &&\n             !thatRecord.getPropertyType(property).isInvariant(\n                 getPropertyType(property))) {\n             getPropertyNode(property));\n       }\n \n-      for (String property : thatRecord.properties.keySet()) {\n+      for (String property : thatRecord.getOwnPropertyNames()) {\n         if (!hasProperty(property)) {\n           builder.addProperty(property, thatRecord.getPropertyType(property),\n               thatRecord.getPropertyNode(property));\n       //    of all classes with a property \"x\" with a compatible property type.\n       //    and which are a subtype of {@code that}.\n       // 2) Take the intersection of all of these unions.\n-      for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n-        String propName = entry.getKey();\n-        JSType propType = entry.getValue();\n+      for (String propName : getOwnPropertyNames()) {\n+        JSType propType = getPropertyType(propName);\n         UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n         for (ObjectType alt :\n                  registry.getEachReferenceTypeWithProperty(propName)) {\n     // properties. But z can be assigned to x. Even though z and y are the\n     // same type, the properties of z are inferred--and so an assignment\n     // to the property of z would not violate any restrictions on it.\n-    for (String property : typeB.properties.keySet()) {\n+    for (String property : typeB.getOwnPropertyNames()) {\n       if (!typeA.hasProperty(property)) {\n         return false;\n       }\n \n     return true;\n   }\n-\n-  @Override\n-  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n-    for (Map.Entry<String, JSType> entry : properties.entrySet()) {\n-      JSType type = entry.getValue();\n-      JSType resolvedType = type.resolve(t, scope);\n-      if (type != resolvedType) {\n-        properties.put(entry.getKey(), resolvedType);\n-      }\n-    }\n-    return super.resolveInternal(t, scope);\n-  }\n }", "timestamp": 1354583798, "metainfo": ""}