{"sha": "f04270c55f390abf79595dcebcc22969e63bf7c2", "log": "open-source a deps generator  R=agrieve DELTA=811  (463 added, 281 deleted, 67 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=2372   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/DepsGenerator.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.base.Function;\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.SourceFile;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Generates deps.js files by scanning javascript files for\n+ * calls to goog.provide(), goog.require() and goog.addDependency().\n+ *\n+ * @author agrieve@google.com (Andrew Grieve)\n+ */\n+public class DepsGenerator {\n+\n+  enum InclusionStrategy {\n+    ALWAYS,\n+    WHEN_IN_SRCS,\n+    DO_NOT_DUPLICATE\n+  }\n+\n+  private static Logger logger =\n+      Logger.getLogger(DepsGenerator.class.getName());\n+\n+  // See the Flags in MakeJsDeps for descriptions of these.\n+  private final Collection<SourceFile> srcs;\n+  private final Collection<SourceFile> deps;\n+  private final String closurePathAbs;\n+  private final InclusionStrategy mergeStrategy;\n+  final ErrorManager errorManager;\n+\n+  static final DiagnosticType SAME_FILE_WARNING = DiagnosticType.warning(\n+      \"DEPS_SAME_FILE\",\n+      \"Namespace \\\"{0}\\\" is both required and provided in the same file.\");\n+\n+  static final DiagnosticType NEVER_PROVIDED_ERROR = DiagnosticType.error(\n+      \"DEPS_NEVER_PROVIDED\",\n+      \"Namespace \\\"{0}\\\" is required but never provided.\");\n+\n+  static final DiagnosticType DUPE_PROVIDES_WARNING = DiagnosticType.warning(\n+      \"DEPS_DUPE_PROVIDES\",\n+      \"Multiple calls to goog.provide(\\\"{0}\\\")\");\n+\n+  static final DiagnosticType MULTIPLE_PROVIDES_ERROR = DiagnosticType.error(\n+      \"DEPS_DUPE_PROVIDES\",\n+      \"Namespace \\\"{0}\\\" is already provided in other file {1}\");\n+\n+  static final DiagnosticType DUPE_REQUIRE_WARNING = DiagnosticType.warning(\n+      \"DEPS_DUPE_REQUIRES\",\n+      \"Namespace \\\"{0}\\\" is required multiple times\");\n+\n+  static final DiagnosticType NO_DEPS_WARNING = DiagnosticType.warning(\n+      \"DEPS_NO_DEPS\",\n+      \"No dependencies found in file\");\n+\n+  /**\n+   * Creates a new DepsGenerator.\n+   */\n+  public DepsGenerator(\n+      Collection<SourceFile> deps,\n+      Collection<SourceFile> srcs,\n+      InclusionStrategy mergeStrategy,\n+      String closurePathAbs,\n+      ErrorManager errorManager) {\n+    this.deps = deps;\n+    this.srcs = srcs;\n+    this.mergeStrategy = mergeStrategy;\n+    this.closurePathAbs = closurePathAbs;\n+    this.errorManager = errorManager;\n+  }\n+\n+  /**\n+   * Performs the parsing inputs and writing of outputs.\n+   * @throws IOException Occurs upon an IO error.\n+   * @return Returns a String of goog.addDependency calls that will build\n+   *     the dependency graph. Returns null if there was an error.\n+   */\n+  public String computeDependencyCalls() throws IOException {\n+    // Build a map of closure-relative path -> DepInfo.\n+    Map<String, DependencyInfo> depsFiles = parseDepsFiles();\n+    logger.fine(\"preparsedFiles: \" + depsFiles);\n+\n+    // Find all goog.provides & goog.requires in src files\n+    Map<String, DependencyInfo> jsFiles = parseSources(depsFiles.keySet());\n+\n+    // Check if there were any parse errors.\n+    if (errorManager.getErrorCount() > 0) {\n+      return null;\n+    }\n+\n+    cleanUpDuplicatedFiles(depsFiles, jsFiles);\n+\n+    // Check for missing provides or other semantic inconsistencies.\n+    validateDependencies(depsFiles.values(), jsFiles.values());\n+\n+    if (errorManager.getErrorCount() > 0) {\n+      return null;\n+    }\n+\n+    ByteArrayOutputStream output = new ByteArrayOutputStream();\n+    writeDepsContent(depsFiles, jsFiles, new PrintStream(output));\n+    return new String(output.toByteArray());\n+  }\n+\n+  /**\n+   * Removes duplicated depsInfo from jsFiles if this info already present in\n+   * some of the parsed deps.js\n+   *\n+   * @param depsFiles DepsInfo from deps.js dependencies\n+   * @param jsFiles DepsInfo from some of jsSources\n+   */\n+  protected void cleanUpDuplicatedFiles(Map<String, DependencyInfo> depsFiles,\n+      Map<String, DependencyInfo> jsFiles) {\n+    Set<String> depsPathsCopy = Sets.newHashSet(depsFiles.keySet());\n+    for (String path : depsPathsCopy) {\n+      if (mergeStrategy != InclusionStrategy.WHEN_IN_SRCS) {\n+        jsFiles.remove(path);\n+      }\n+    }\n+\n+    for (String path : jsFiles.keySet()) {\n+      // If a generated file appears in both the jsFiles and in depsFiles, then\n+      // remove it from depsFiles in order to get the full path the generated\n+      // file.\n+      depsFiles.remove(path);\n+    }\n+  }\n+\n+  /**\n+   * Reports if there are any dependency problems with the given dependency\n+   * information. Reported problems include:\n+   *     - A namespace being provided more than once\n+   *     - A namespace being required multiple times from within one file\n+   *     - A namespace being provided and required in the same file\n+   *     - A namespace being required that is never provided\n+   * @param preparsedFileDepedencies Dependency information from existing\n+   *     deps.js files.\n+   * @param parsedFileDependencies Dependency information from parsed .js files.\n+   */\n+  private void validateDependencies(Iterable<DependencyInfo> preparsedFileDepedencies,\n+      Iterable<DependencyInfo> parsedFileDependencies) {\n+    // Create a map of namespace -> file providing it.\n+    // Also report any duplicate provides.\n+    Map<String, DependencyInfo> providesMap = Maps.newHashMap();\n+    addToProvideMap(preparsedFileDepedencies, providesMap);\n+    addToProvideMap(parsedFileDependencies, providesMap);\n+    // For each require in the parsed sources:\n+    for (DependencyInfo depInfo : parsedFileDependencies) {\n+      List<String> requires = Lists.newArrayList(depInfo.getRequires());\n+      for (int i = 0, l = requires.size(); i < l; ++i) {\n+        String namespace = requires.get(i);\n+        // Check for multiple requires.\n+        if (requires.subList(i + 1, l).contains(namespace)) {\n+          reportDuplicateRequire(namespace, depInfo);\n+        }\n+        // Check for missing provides.\n+        DependencyInfo provider = providesMap.get(namespace);\n+        if (provider == null) {\n+          reportUndefinedNamespace(namespace, depInfo);\n+        } else if (provider == depInfo) {\n+          reportSameFile(namespace, depInfo);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void reportSameFile(String namespace, DependencyInfo depInfo) {\n+    errorManager.report(CheckLevel.WARNING,\n+        JSError.make(depInfo.getName(), -1, -1,\n+            SAME_FILE_WARNING, namespace));\n+  }\n+\n+  private void reportUndefinedNamespace(\n+      String namespace, DependencyInfo depInfo) {\n+    errorManager.report(CheckLevel.ERROR,\n+        JSError.make(depInfo.getName(), -1, -1,\n+            NEVER_PROVIDED_ERROR, namespace));\n+  }\n+\n+  private void reportDuplicateProvide(String namespace, DependencyInfo firstDep,\n+      DependencyInfo secondDep) {\n+    if (firstDep == secondDep) {\n+      errorManager.report(CheckLevel.WARNING,\n+          JSError.make(firstDep.getName(), -1, -1,\n+              DUPE_PROVIDES_WARNING, namespace));\n+    } else {\n+      errorManager.report(CheckLevel.ERROR,\n+          JSError.make(secondDep.getName(), -1, -1,\n+              MULTIPLE_PROVIDES_ERROR, namespace, firstDep.getName()));\n+    }\n+  }\n+\n+  private void reportDuplicateRequire(\n+      String namespace, DependencyInfo depInfo) {\n+    errorManager.report(CheckLevel.WARNING,\n+        JSError.make(depInfo.getName(), -1, -1,\n+            DUPE_REQUIRE_WARNING, namespace));\n+  }\n+\n+  private void reportNoDepsInDepsFile(String filePath) {\n+    errorManager.report(CheckLevel.WARNING,\n+        JSError.make(filePath, -1, -1, NO_DEPS_WARNING));\n+  }\n+\n+  /**\n+   * Adds the given DependencyInfos to the given providesMap. Also checks for\n+   * and reports duplicate provides.\n+   */\n+  private void addToProvideMap(Iterable<DependencyInfo> depInfos,\n+      Map<String, DependencyInfo> providesMap) {\n+    for (DependencyInfo depInfo : depInfos) {\n+      for (String provide : depInfo.getProvides()) {\n+        DependencyInfo prevValue = providesMap.put(provide, depInfo);\n+        // Check for duplicate provides.\n+        if (prevValue != null) {\n+          reportDuplicateProvide(provide, prevValue, depInfo);\n+        }\n+      }\n+    }\n+  }\n+\n+  protected DepsFileParser createDepsFileParser() {\n+    DepsFileParser depsParser = new DepsFileParser(errorManager);\n+    depsParser.setShortcutMode(true);\n+    return depsParser;\n+  }\n+\n+  /**\n+   * Returns whether we should ignore dependency info in the given deps file.\n+   */\n+  protected boolean shouldSkipDepsFile(SourceFile file) {\n+    return false;\n+  }\n+\n+  /**\n+   * Parses all deps.js files in the deps list and creates a map of\n+   * closure-relative path -> DependencyInfo.\n+   */\n+  private Map<String, DependencyInfo> parseDepsFiles() throws IOException {\n+    DepsFileParser depsParser = createDepsFileParser();\n+    Map<String, DependencyInfo> depsFiles = Maps.newHashMap();\n+    for (SourceFile file : deps) {\n+      if (!shouldSkipDepsFile(file)) {\n+        List<DependencyInfo>\n+            depInfos = depsParser.parseFileReader(\n+                file.getName(), file.getCodeReader());\n+        if (depInfos.isEmpty()) {\n+          reportNoDepsInDepsFile(file.getName());\n+        } else {\n+          for (DependencyInfo info : depInfos) {\n+            depsFiles.put(info.getPathRelativeToClosureBase(), info);\n+          }\n+        }\n+      }\n+    }\n+\n+    // If a deps file also appears in srcs, our build tools will move it\n+    // into srcs.  So we need to scan all the src files for addDependency\n+    // calls as well.\n+    for (SourceFile src : srcs) {\n+      if ((new File(src.getName())).exists() &&\n+          !shouldSkipDepsFile(src)) {\n+        List<DependencyInfo> srcInfos =\n+            depsParser.parseFileReader(src.getName(), src.getCodeReader());\n+        for (DependencyInfo info : srcInfos) {\n+          depsFiles.put(info.getPathRelativeToClosureBase(), info);\n+        }\n+      }\n+    }\n+\n+    return depsFiles;\n+  }\n+\n+  /**\n+   * Parses all source files for dependency information.\n+   * @param preparsedFiles A set of closure-relative paths.\n+   *     Files in this set are not parsed if they are encountered in srcs.\n+   * @return Returns a map of closure-relative paths -> DependencyInfo for the\n+   *     newly parsed files.\n+   * @throws IOException Occurs upon an IO error.\n+   */\n+  private Map<String, DependencyInfo> parseSources(\n+      Set<String> preparsedFiles) throws IOException {\n+    Map<String, DependencyInfo> parsedFiles = Maps.newHashMap();\n+    JsFileParser jsParser = new JsFileParser(errorManager);\n+\n+    for (SourceFile file : srcs) {\n+      String closureRelativePath =\n+          PathUtil.makeRelative(\n+              closurePathAbs, PathUtil.makeAbsolute(file.getName()));\n+      logger.fine(\"Closure-relative path: \" + closureRelativePath);\n+\n+      if (InclusionStrategy.WHEN_IN_SRCS == mergeStrategy ||\n+          !preparsedFiles.contains(closureRelativePath)) {\n+        DependencyInfo depInfo =\n+            jsParser.parseFile(\n+                file.getName(), closureRelativePath,\n+                file.getCode());\n+\n+        // Kick the source out of memory.\n+        file.clearCachedSource();\n+        parsedFiles.put(closureRelativePath, depInfo);\n+      }\n+    }\n+\n+    return parsedFiles;\n+  }\n+\n+  /**\n+   * Creates the content to put into the output deps.js file. If mergeDeps is\n+   * true, then all of the dependency information in the providedDeps will be\n+   * included in the output.\n+   * @throws IOException Occurs upon an IO error.\n+   */\n+  private void writeDepsContent(Map<String, DependencyInfo> depsFiles,\n+      Map<String, DependencyInfo> jsFiles, PrintStream out)\n+      throws IOException {\n+    // Print all dependencies extracted from srcs.\n+    writeDepInfos(out, jsFiles.values());\n+\n+    // Print all dependencies extracted from deps.\n+    if (mergeStrategy == InclusionStrategy.ALWAYS) {\n+      // This multimap is just for splitting DepsInfo objects by\n+      // it's definition deps.js file\n+      Multimap<String, DependencyInfo> infosIndex = Multimaps.index(\n+          depsFiles.values(),\n+          new Function<DependencyInfo, String>() {\n+            @Override\n+            public String apply(DependencyInfo from) {\n+              return from.getName();\n+            }\n+          });\n+\n+      for (String depsPath : infosIndex.keySet()) {\n+        String path = formatPathToDepsFile(depsPath);\n+        out.println(\"\\n// Included from: \" + path);\n+        writeDepInfos(out, infosIndex.get(depsPath));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Format the deps file path so that it can be included in the output file.\n+   */\n+  protected String formatPathToDepsFile(String path) {\n+    return path;\n+  }\n+\n+  /**\n+   * Writes goog.addDependency() lines for each DependencyInfo in depInfos.\n+   * @throws IOException Occurs upon an IO error.\n+   */\n+  private void writeDepInfos(PrintStream out,\n+      Collection<DependencyInfo> depInfos\n+  ) throws IOException {\n+    // Print dependencies.\n+    // Lines look like this:\n+    // goog.addDependency('../../path/to/file.js', ['goog.Delay'],\n+    //     ['goog.Disposable', 'goog.Timer']);\n+    for (DependencyInfo depInfo : depInfos) {\n+      Collection<String> provides = depInfo.getProvides();\n+      Collection<String> requires = depInfo.getRequires();\n+\n+      out.print(\"goog.addDependency('\" +\n+          depInfo.getPathRelativeToClosureBase() + \"', \");\n+      writeJsArray(out, provides);\n+      out.print(\", \");\n+      writeJsArray(out, requires);\n+      out.println(\");\");\n+    }\n+  }\n+\n+  /**\n+   * Prints a list of strings formatted as a Javascript array of string\n+   * literals.\n+   */\n+  private static void writeJsArray(PrintStream out, Collection<String> values) {\n+    if (values.isEmpty()) {\n+      out.print(\"[]\");\n+    } else {\n+      out.print(\"['\");\n+      out.print(Joiner.on(\"', '\").join(values));\n+      out.print(\"']\");\n+    }\n+  }\n+\n+  static List<SourceFile> createSourceFilesFromPaths(\n+      Collection<String> paths) {\n+    List<SourceFile> files = Lists.newArrayList();\n+    for (String path : paths) {\n+      files.add(SourceFile.fromFile(path));\n+    }\n+    return files;\n+  }\n+\n+  static List<SourceFile> createSourceFilesFromPaths(\n+      String ... paths) {\n+    return createSourceFilesFromPaths(Arrays.asList(paths));\n+  }\n+}\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/deps/PathUtil.java\n+/*\n+ * Copyright 2008 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.deps;\n+\n+import com.google.common.base.CharMatcher;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Lists;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Utility methods for manipulation of UNIX-like paths.\n+ * NOTE: According to kevinb, equivalent methods will be in the standard library once\n+ * jsr203 is ready.\n+ *\n+ */\n+public final class PathUtil {\n+\n+  private static final CharMatcher SLASH_MATCHER = CharMatcher.is('/');\n+  private static final CharMatcher NON_SLASH_MATCHER = CharMatcher.isNot('/');\n+\n+  private PathUtil() {\n+  }\n+\n+  /**\n+   * Removes all ../ and ./ entries from within the given path. If there are extra ..s that move\n+   * beyond the first directory given, they are removed.\n+   *\n+   * Examples:\n+   *   \"a/b/../c\" results in \"a/c\"\n+   *   \"./foo/./../bar\" results in \"bar\"\n+   *   \"a/..\" results in \"\"\n+   *   \"a/../../foo\" results in \"foo\"\n+   *\n+   * @param path The path to remove dots from.\n+   * @return The path with all dots collapsed.\n+   */\n+  public static String collapseDots(String path) {\n+    path = removeExtraneousSlashes(path);\n+    // Optimization: Most paths don't contain dots.\n+    if (!path.contains(\".\")) {\n+      return path;\n+    }\n+\n+    String[] srcFragments = path.split(\"/\");\n+    List<String> dstFragments = Lists.newArrayList();\n+    for (String fragment : srcFragments) {\n+      if (fragment.equals(\"..\")) {\n+        if (!dstFragments.isEmpty()) {\n+          dstFragments.remove(dstFragments.size() - 1);\n+        }\n+      } else if (!fragment.equals(\".\")) {\n+        dstFragments.add(fragment);\n+      }\n+    }\n+\n+    // Special case for Join.join([\"\"]); -> \"/\"\n+    if (dstFragments.size() == 1 && dstFragments.get(0).isEmpty()) {\n+      return \"/\";\n+    }\n+    return Joiner.on(\"/\").join(dstFragments);\n+  }\n+\n+  /**\n+   * Determines if a path is absolute or not by testing for the presence of \"/\"\n+   * at the front of the string.\n+   *\n+   * @param path The path to test\n+   * @return true if the path starts with DELIMITER, false otherwise.\n+   */\n+  static boolean isAbsolute(String path) {\n+    return path.startsWith(\"/\");\n+  }\n+\n+  /**\n+   * Removes extra slashes from a path.  Leading slash is preserved, trailing\n+   * slash is stripped, and any runs of more than one slash in the middle is\n+   * replaced by a single slash.\n+   */\n+  static String removeExtraneousSlashes(String s) {\n+    int lastNonSlash = NON_SLASH_MATCHER.lastIndexIn(s);\n+    if (lastNonSlash != -1) {\n+      s = s.substring(0, lastNonSlash + 1);\n+    }\n+\n+    return SLASH_MATCHER.collapseFrom(s, '/');\n+  }\n+\n+\n+  /**\n+   * Converts the given path into an absolute one. This prepends the current\n+   * working directory and removes all .'s from the path. If an absolute path\n+   * is given, it will not be prefixed.\n+   *\n+   * <p>Unlike File.getAbsolutePath(), this function does remove .'s from the\n+   * path and unlike File.getCanonicalPath(), this function does not resolve\n+   * symlinks and does not use filesystem calls.</p>\n+   *\n+   * @param path The path to make absolute.\n+   * @return The path made absolute.\n+   */\n+  public static String makeAbsolute(String path) {\n+    return makeAbsolute(path, System.getProperty(\"user.dir\"));\n+  }\n+\n+  /**\n+   * Converts the given path into an absolute one. This prepends the given\n+   * rootPath and removes all .'s from the path. If an absolute path is given,\n+   * it will not be prefixed.\n+   *\n+   * <p>Unlike File.getAbsolutePath(), this function does remove .'s from the\n+   * path and unlike File.getCanonicalPath(), this function does not resolve\n+   * symlinks and does not use filesystem calls.</p>\n+   *\n+   * @param rootPath The path to prefix to path if path is not already absolute.\n+   * @param path The path to make absolute.\n+   * @return The path made absolute.\n+   */\n+  public static String makeAbsolute(String path, String rootPath) {\n+    if (!isAbsolute(path)) {\n+      path = rootPath + \"/\" + path;\n+    }\n+    return collapseDots(path);\n+  }\n+\n+  /**\n+   * Returns targetPath relative to basePath.\n+   *\n+   * <p>basePath and targetPath must either both be relative, or both be\n+   * absolute paths.</p>\n+   *\n+   * <p>This function is different from makeRelative\n+   * in that it is able to add in ../ components and collapse existing ones as well.</p>\n+   *\n+   * Examples:\n+   *   base=\"some/relative/path\" target=\"some/relative/path/foo\" return=\"foo\"\n+   *   base=\"some/relative/path\" target=\"some/relative\" return=\"..\"\n+   *   base=\"some/relative/path\" target=\"foo/bar\" return=\"../../../foo/bar\"\n+   *   base=\"/some/abs/path\" target=\"/foo/bar\" return=\"../../../foo/bar\"\n+   *\n+   * @param basePath The path to make targetPath relative to.\n+   * @param targetPath The path to make relative.\n+   * @return A path relative to targetPath. The returned value will never start\n+   *     with a slash.\n+   */\n+  public static String makeRelative(String basePath, String targetPath) {\n+    // Ensure the paths are both absolute or both relative.\n+    if (isAbsolute(basePath) !=\n+        isAbsolute(targetPath)) {\n+      throw new IllegalArgumentException(\n+          \"Paths must both be relative or both absolute.\\n\" +\n+          \"  basePath: \" + basePath + \"\\n\" +\n+          \"  targetPath: \" + targetPath);\n+    }\n+\n+    basePath = collapseDots(basePath);\n+    targetPath = collapseDots(targetPath);\n+    String[] baseFragments = basePath.split(\"/\");\n+    String[] targetFragments = targetPath.split(\"/\");\n+\n+    int i = -1;\n+    do {\n+      i += 1;\n+      if (i == baseFragments.length && i == targetFragments.length) {\n+        // Eg) base: /java/com/google\n+        //   target: /java/com/google\n+        //   result: .  <-- . is better than \"\" since \"\" + \"/path\" = \"/path\"\n+        return \".\";\n+      } else if (i == baseFragments.length) {\n+        // Eg) base: /java/com/google\n+        //   target: /java/com/google/c/ui\n+        //   result: c/ui\n+        return Joiner.on(\"/\").join(\n+            Lists.newArrayList(\n+                Arrays.asList(targetFragments).listIterator(i)));\n+      } else if (i == targetFragments.length) {\n+        // Eg) base: /java/com/google/c/ui\n+        //   target: /java/com/google\n+        //   result: ../..\n+        return Strings.repeat(\"../\", baseFragments.length - i - 1) + \"..\";\n+      }\n+\n+    } while (baseFragments[i].equals(targetFragments[i]));\n+\n+    // Eg) base: /java/com/google/c\n+    //   target: /java/com/google/common/base\n+    //   result: ../common/base\n+    return Strings.repeat(\"../\", baseFragments.length - i) +\n+        Joiner.on(\"/\").join(\n+            Lists.newArrayList(Arrays.asList(targetFragments).listIterator(i)));\n+  }\n+}", "timestamp": 1308769451, "metainfo": ""}