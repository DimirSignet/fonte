{"sha": "7451ba03648961a591ec5af7e33d665e25867304", "log": "Moeify the jsonml tests.  R=nicksantos DELTA=24  (24 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=144   ", "commit": "\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/jsonml/JsonMLValidationTest.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.javascript.jscomp.jsonml.JsonML;\n+import com.google.javascript.jscomp.jsonml.JsonMLUtil;\n+import com.google.javascript.jscomp.jsonml.TagAttr;\n+import com.google.javascript.jscomp.jsonml.TagType;\n+import com.google.javascript.jscomp.jsonml.Validator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests validation of particular JsonML elements.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ */\n+public class JsonMLValidationTest extends TestCase {\n+\n+  // Used for correct statements - error message should be null\n+  private void testValidation(String jsonml) throws Exception {\n+    JsonML jsonMLRoot = JsonMLUtil.parseString(jsonml);\n+    String msg = Validator.validate(jsonMLRoot);\n+    if (msg != null) {\n+      String errorMsg = String.format(\n+          \"Validation error for %s.\\n Received: %s\\n\", jsonml, msg);\n+    }\n+  }\n+\n+  private void testValidation(String jsonml, String expected)\n+      throws Exception {\n+    JsonML jsonMLRoot = JsonMLUtil.parseString(jsonml);\n+    String msg = Validator.validate(jsonMLRoot);\n+    if (!msg.equals(expected)) {\n+      String errorMsg = String.format(\n+          \"Validation error for %s.\\n Received: %s\\n Expected: %s\\n\",\n+          jsonml, msg, expected);\n+      throw new Exception(errorMsg);\n+    }\n+  }\n+\n+  private void testNotEnoughChildrenValidation(String jsonml, TagType type,\n+      int expected, int actual) throws Exception {\n+    testValidation(jsonml,\n+        String.format(Validator.NOT_ENOUGH_CHILDREN_FMT,\n+        type, expected, actual));\n+  }\n+\n+  private void testTooManyChildrenValidation(String jsonml, TagType type,\n+      int expected, int actual) throws Exception {\n+    testValidation(jsonml,\n+        String.format(Validator.TOO_MANY_CHILDREN_FMT,\n+        type, expected, actual));\n+  }\n+\n+  private void testWrongChildTypeValidation(String jsonml, TagType type,\n+      TagType expected, TagType actual, int index) throws Exception {\n+    testWrongChildTypeValidation(jsonml, type, new TagType[] { expected },\n+        actual, index);\n+  }\n+\n+  private void testWrongChildTypeValidation(String jsonml, TagType type,\n+      TagType[] expected, TagType actual, int index) throws Exception {\n+    testValidation(jsonml,\n+        String.format(Validator.WRONG_CHILD_TYPE_FMT,\n+        index, type, Validator.printList(expected), actual));\n+  }\n+\n+  private void testMissingArgument(String jsonml, TagAttr attr, TagType type)\n+      throws Exception {\n+    testValidation(jsonml,\n+        String.format(Validator.MISSING_ARGUMENT, attr, type));\n+  }\n+\n+  public void testAssignExpr() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['AssignExpr',{'op':'='},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['AssignExpr',{'op':'='},\" +\n+            \"['IdExpr',{'name':'x'}]]\",\n+        TagType.AssignExpr, 2, 1);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['AssignExpr',{'op':'='},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}],\" +\n+            \"['IdExpr',{'name':'z'}]]\",\n+        TagType.AssignExpr, 2, 3);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['AssignExpr',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\",\n+        TagAttr.OP, TagType.AssignExpr);\n+  }\n+\n+  public void testBinaryExpr() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['BinaryExpr',{'op':'+'},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['BinaryExpr',{'op':'+'},\" +\n+            \"['IdExpr',{'name':'a'}]]\",\n+        TagType.BinaryExpr, 2, 1);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['BinaryExpr',{'op':'&&'},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['IdExpr',{'name':'b'}],\" +\n+            \"['IdExpr',{'name':'c'}]]\",\n+        TagType.BinaryExpr, 2, 3);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['BinaryExpr',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\",\n+        TagAttr.OP, TagType.BinaryExpr);\n+  }\n+\n+  public void testCaseValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['Case',{},\" +\n+            \"['IdExpr',{'name':'a'}]]\");\n+    testValidation(\"\" +\n+        \"['Case',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['CallExpr',{},\" +\n+                \"['IdExpr',{'name':'foo'}]]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['Case',{}]\",\n+        TagType.Case, 1, 0);\n+  }\n+\n+  public void testCatchValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['CatchClause',{},\" +\n+            \"['IdPatt',{'name':'e'}],\" +\n+            \"['BlockStmt',{}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['CatchClause',{},\" +\n+            \"['IdPatt',{'name':'e'}]]\",\n+        TagType.CatchClause, 2, 1);\n+    // wrong children types\n+    testWrongChildTypeValidation(\"\" +\n+        \"['CatchClause',{},\" +\n+            \"['IdExpr',{'name':'e'}],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.CatchClause, TagType.IdPatt, TagType.IdExpr, 0);\n+  }\n+\n+  public void testConditionalExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ConditionalExpr',{},\" +\n+           \"['BinaryExpr',{'op':'=='},\" +\n+                \"['IdExpr',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]],\" +\n+           \"['LiteralExpr',{'type':'number','value':0}],\" +\n+           \"['LiteralExpr',{'type':'number','value':1}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['ConditionalExpr',{},\" +\n+            \"['BinaryExpr',{'op':'=='},\" +\n+                \"['IdExpr',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]]]\",\n+        TagType.ConditionalExpr, 3, 1);\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['ConditionalExpr',{},\" +\n+            \"['BinaryExpr',{'op':'=='},\" +\n+                \"['IdExpr',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]],\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\",\n+        TagType.ConditionalExpr, 3, 2);\n+  }\n+\n+  public void testCountExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['CountExpr',{'isPrefix':false,'op':'++'},\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['CountExpr',{'isPrefix':false,'op':'++'},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.CountExpr, 1, 2);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['CountExpr',{'op':'++'},\" +\n+            \"['IdExpr',{'name':'x'}]]\",\n+         TagAttr.IS_PREFIX, TagType.CountExpr);\n+    testMissingArgument(\"\" +\n+        \"['CountExpr',{'isPrefix':false},\" +\n+            \"['IdExpr',{'name':'x'}]]\",\n+        TagAttr.OP, TagType.CountExpr);\n+  }\n+\n+  public void testDataProp() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['DataProp',{'name':'x'},\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['DataProp',{'name':'x'}]\",\n+        TagType.DataProp, 1, 0);\n+    // missing argument\n+    testMissingArgument(\"\" +\n+        \"['DataProp', {},\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\",\n+        TagAttr.NAME, TagType.DataProp);\n+  }\n+\n+  public void testDeleteExpr() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['DeleteExpr',{},\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    //wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['DeleteExpr',{}]\",\n+        TagType.DeleteExpr, 1, 0);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['DeleteExpr',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.DeleteExpr, 1, 2);\n+  }\n+\n+  public void testDoWhileStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['DoWhileStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['DoWhileStmt',{}]\",\n+        TagType.DoWhileStmt, 2, 0);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['DoWhileStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}]]\",\n+            TagType.DoWhileStmt, 2, 3);\n+  }\n+\n+  public void testEmptyStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['EmptyStmt',{}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['EmptyStmt',{},\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.EmptyStmt, 0, 1);\n+  }\n+\n+  public void testForInStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ForInStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['ObjectExpr',{}],\" +\n+            \"['BlockStmt',{}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['ForInStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['ObjectExpr',{}]],\",\n+        TagType.ForInStmt, 3, 2);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['ForInStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['ObjectExpr',{}],\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.ForInStmt, 3, 4);\n+  }\n+\n+  public void testForStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ForStmt',{},\" +\n+            \"['AssignExpr',{'op':'='},\" +\n+                \"['IdExpr',{'name':'i'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]],\" +\n+            \"['BinaryExpr',{'op':'<'},\" +\n+                \"['IdExpr',{'name':'i'}],\" +\n+                \"['IdExpr',{'name':'n'}]],\" +\n+            \"['CountExpr',{'isPrefix':true,'op':'++'},\" +\n+                \"['IdExpr',{'name':'i'}]],\" +\n+            \"['BlockStmt',{}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['ForStmt',{},\" +\n+            \"['BinaryExpr',{'op':'<'},\" +\n+                \"['IdExpr',{'name':'i'}],\" +\n+                \"['IdExpr',{'name':'n'}]],\" +\n+            \"['CountExpr',{'isPrefix':true,'op':'++'},\" +\n+                \"['IdExpr',{'name':'i'}]],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.ForStmt, 4, 3);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['ForStmt',{},\" +\n+            \"['AssignExpr',{'op':'='},\" +\n+                \"['IdExpr',{'name':'i'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]],\" +\n+            \"['BinaryExpr',{'op':'<'},\" +\n+                \"['IdExpr',{'name':'i'}],\" +\n+                \"['IdExpr',{'name':'n'}]],\" +\n+            \"['CountExpr',{'isPrefix':true,'op':'++'},\" +\n+                \"['IdExpr',{'name':'i'}]],\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.ForStmt, 4, 5);\n+  }\n+\n+  public void testFunctionDeclValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['FunctionDecl',{},\" +\n+            \"['IdPatt',{'name':'f'}],\" +\n+            \"['ParamDecl',{}]]\");\n+    testValidation(\"\" +\n+        \"['FunctionDecl',{},\" +\n+            \"['IdPatt',{'name':'f'}],\" +\n+            \"['ParamDecl',{}],\" +\n+            \"['IdExpr',{'name':'foo'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['FunctionDecl',{},\" +\n+            \"['IdPatt',{'name':'f'}]]\",\n+        TagType.FunctionDecl, 2, 1);\n+    // function name not specified\n+    testWrongChildTypeValidation(\"\" +\n+        \"['FunctionDecl',{},\" +\n+            \"['Empty', {}],\" +\n+            \"['ParamDecl',{}]]\",\n+        TagType.FunctionDecl, TagType.IdPatt, TagType.Empty, 0);\n+    // list of formal arguments not specified\n+    testWrongChildTypeValidation(\"\" +\n+        \"['FunctionDecl',{},\" +\n+            \"['IdPatt',{'name':'f'}],\" +\n+            \"['Empty',{}]]\",\n+        TagType.FunctionDecl, TagType.ParamDecl, TagType.Empty, 1);\n+  }\n+\n+  public void testFunctionExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['FunctionExpr',{},\" +\n+            \"['IdPatt',{'name':'f'}],\" +\n+            \"['ParamDecl',{}]]\");\n+    testValidation(\"\" +\n+        \"['FunctionExpr',{},\" +\n+            \"['IdPatt',{'name':'f'}],\" +\n+            \"['ParamDecl',{}],\" +\n+            \"['IdExpr',{'name':'foo'}]]\");\n+    testValidation(\"\" +\n+        \"['FunctionExpr',{},\" +\n+            \"['Empty', {}],\" +\n+            \"['ParamDecl',{}]]\");\n+  }\n+\n+  public void testIdExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['IdExpr',{'name':'x'}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['IdExpr',{'name':'x'},\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.IdExpr, 0, 1);\n+    // missing name argument\n+    testMissingArgument(\"\" +\n+        \"['IdExpr', {}]\",\n+        TagAttr.NAME, TagType.IdExpr);\n+  }\n+\n+  public void testIdPattValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['IdPatt',{'name':'x'}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['IdPatt',{'name':'x'},\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.IdPatt, 0, 1);\n+    // missing name argument\n+    testMissingArgument(\"\" +\n+        \"['IdPatt', {}]\",\n+        TagAttr.NAME, TagType.IdPatt);\n+  }\n+\n+  public void testIfStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['IfStmt',{},\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}],\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['EmptyStmt',{}]]\");\n+    testValidation(\"\" +\n+        \"['IfStmt',{},\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}],\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['BlockStmt',{}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['IfStmt',{},\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.IfStmt, 3, 2);\n+  }\n+\n+  public void testInvokeExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['InvokeExpr',{'op':'.'},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['LiteralExpr',{'type':'string','value':'foo'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['InvokeExpr',{'op':'[]'},\" +\n+            \"['IdExpr',{'name':'x'}]]\",\n+        TagType.InvokeExpr, 2, 1);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['InvokeExpr',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['LiteralExpr',{'type':'string','value':'foo'}]]\",\n+        TagAttr.OP, TagType.InvokeExpr);\n+  }\n+\n+  public void testJmpStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['BreakStmt',{}]\");\n+    testValidation(\"\" +\n+        \"['BreakStmt',{'label':'s'}]\");\n+    testValidation(\"\" +\n+        \"['ContinueStmt',{}]\");\n+    testValidation(\"\" +\n+        \"['ContinueStmt',{'label':'s'}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['BreakStmt',{},\" +\n+            \"['IdExpr',{'name':'s'}]]\",\n+        TagType.BreakStmt, 0, 1);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['ContinueStmt',{},\" +\n+            \"['IdExpr',{'name':'s'}]]\",\n+        TagType.ContinueStmt, 0, 1);\n+  }\n+\n+  public void testLabelledStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['LabelledStmt',{'label':'s'},\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['LabelledStmt',{'label':'s'}]\",\n+        TagType.LabelledStmt, 1, 0);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['LabelledStmt',{'label':'s'},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.LabelledStmt, 1, 2);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['LabelledStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}]]\",\n+        TagAttr.LABEL, TagType.LabelledStmt);\n+  }\n+\n+  public void testLiteralExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['LiteralExpr',{'type':'string','value':'x'}]\");\n+    testValidation(\"\" +\n+        \"['LiteralExpr',{'type':'boolean','value':'true'}]\");\n+    testValidation(\"\" +\n+        \"['LiteralExpr',{'type':'number','value':'1.0'}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['LiteralExpr',{'type':'number','value':'1.0'},\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.LiteralExpr, 0, 1);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['LiteralExpr',{'type':'string'}]\",\n+        TagAttr.VALUE, TagType.LiteralExpr);\n+    testMissingArgument(\"\" +\n+        \"['LiteralExpr',{'value':'1.0'}]\",\n+        TagAttr.TYPE, TagType.LiteralExpr);\n+  }\n+\n+  public void testLogicalExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['LogicalAndExpr',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['IdExpr',{'name':'b'}]]\");\n+    testValidation(\"\" +\n+        \"['LogicalOrExpr',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['IdExpr',{'name':'b'}]]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['LogicalAndExpr',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['IdExpr',{'name':'b'}],\" +\n+            \"['IdExpr',{'name':'c'}]]\",\n+            TagType.LogicalAndExpr, 2, 3);\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['LogicalAndExpr',{},\" +\n+            \"['IdExpr',{'name':'a'}]]\",\n+        TagType.LogicalAndExpr, 2, 1);\n+  }\n+\n+  public void testNewExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['NewExpr',{},\" +\n+            \"['IdExpr',{'name':'A'}],\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['NewExpr',{}]\",\n+        TagType.NewExpr, 1, 0);\n+  }\n+\n+  public void testObjectExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ObjectExpr',{}]\");\n+    testValidation(\"\" +\n+        \"['ObjectExpr',{},\" +\n+            \"['DataProp',{'name':'x'},\" +\n+                \"['LiteralExpr',{'type':'number','value':1}]],\" +\n+            \"['DataProp',{'name':'y'},\" +\n+                \"['LiteralExpr',{'type':'number','value':2}]]]\");\n+    // wrong types of children\n+    testWrongChildTypeValidation(\"\" +\n+        \"['ObjectExpr',{},\" +\n+            \"['DataProp',{'name':'x'},\" +\n+                \"['LiteralExpr',{'type':'number','value':1}]],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.ObjectExpr, TagType.DataProp, TagType.IdExpr, 1);\n+  }\n+\n+  public void testParamDeclValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ParamDecl',{}]\");\n+    testValidation(\"\" +\n+        \"['ParamDecl',{},\" +\n+            \"['IdPatt',{'name':'x'}],\" +\n+            \"['IdPatt',{'name':'y'}]]\");\n+    // wrong types of children\n+    testWrongChildTypeValidation(\"\" +\n+        \"['ParamDecl',{},\" +\n+            \"['IdPatt',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.ParamDecl, TagType.IdPatt, TagType.IdExpr, 1);\n+  }\n+\n+  public void testRegExpExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['RegExpExpr',{'body':'abc','flags':''}]\");\n+    testValidation(\"\" +\n+        \"['RegExpExpr',{'body':'abc','flags':'g'}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['RegExpExpr',{'body':'abc','flags':'g'},\" +\n+            \"['IdExpr',{'name':'a'}]]\",\n+        TagType.RegExpExpr, 0, 1);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['RegExpExpr',{'body':'abc'}]\",\n+        TagAttr.FLAGS, TagType.RegExpExpr);\n+    testMissingArgument(\"\" +\n+        \"['RegExpExpr',{'flags':'g'}]\",\n+        TagAttr.BODY, TagType.RegExpExpr);\n+  }\n+\n+  public void testReturnStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ReturnStmt',{}]\");\n+    testValidation(\"\" +\n+        \"['ReturnStmt',{},\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['ReturnStmt',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['IdExpr',{'name':'b'}]]\",\n+        TagType.ReturnStmt, 1, 2);\n+  }\n+\n+  public void testSwitchStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['SwitchStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['Case',{},\" +\n+                \"['LiteralExpr',{'type':'number','value':1}],\" +\n+                \"['CallExpr',{},\" +\n+                    \"['IdExpr',{'name':'foo'}]]],\" +\n+            \"['DefaultCase',{},\" +\n+                \"['CallExpr',{},\" +\n+                    \"['IdExpr',{'name':'bar'}]]]]\");\n+    testValidation(\"\" +\n+        \"['SwitchStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['SwitchStmt',{}]\",\n+        TagType.SwitchStmt, 1, 0);\n+    // wrong types of children\n+    testWrongChildTypeValidation(\"\" +\n+        \"['SwitchStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['AssignExpr',{'op': '='},\" +\n+                \"['LiteralExpr',{'type':'number','value':1}],\" +\n+                \"['CallExpr',{},\" +\n+                    \"['IdExpr',{'name':'foo'}]]],\" +\n+            \"['DefaultCase',{},\" +\n+                \"['CallExpr',{},\" +\n+                    \"['IdExpr',{'name':'bar'}]]]]\",\n+        TagType.SwitchStmt,\n+        new TagType[] { TagType.Case, TagType.DefaultCase },\n+        TagType.AssignExpr, 1);\n+    testWrongChildTypeValidation(\"\" +\n+        \"['SwitchStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['DefaultCase',{},\" +\n+                \"['CallExpr',{},\" +\n+                    \"['IdExpr',{'name':'foo'}]]],\" +\n+            \"['DefaultCase',{},\" +\n+                \"['CallExpr',{},\" +\n+                    \"['IdExpr',{'name':'bar'}]]]]\",\n+        TagType.SwitchStmt, TagType.Case, TagType.DefaultCase, 2);\n+  }\n+\n+  public void testThisExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ThisExpr',{}]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['ThisExpr',{},\" +\n+            \"['IdExpr',{'name':'a'}]]\",\n+        TagType.ThisExpr, 0, 1);\n+  }\n+\n+  public void testThrowStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['ThrowStmt',{},\" +\n+            \"['IdExpr',{'name':'e'}]]\");\n+    // wrong number of children\n+    testTooManyChildrenValidation(\"\" +\n+        \"['ThrowStmt',{},\" +\n+            \"['IdExpr',{'name':'a'}],\" +\n+            \"['IdExpr',{'name':'b'}]]\",\n+        TagType.ThrowStmt, 1, 2);\n+  }\n+\n+  public void testTryStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['TryStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['CatchClause',{},\" +\n+                \"['IdPatt',{'name':'e'}],\" +\n+                \"['BlockStmt',{}]]]\");\n+    testValidation(\"\" +\n+        \"['TryStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['CatchClause',{},\" +\n+                \"['IdPatt',{'name':'e'}],\" +\n+                \"['BlockStmt',{}]],\" +\n+            \"['BlockStmt',{}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['TryStmt',{},\" +\n+            \"['CatchClause',{},\" +\n+                \"['IdPatt',{'name':'e'}],\" +\n+                \"['BlockStmt',{}]]]\",\n+        TagType.TryStmt, 2, 1);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['TryStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['CatchClause',{},\" +\n+                \"['IdPatt',{'name':'e'}],\" +\n+                \"['BlockStmt',{}]],\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.TryStmt, 3, 4);\n+    // wrong type of children\n+    testWrongChildTypeValidation(\"\" +\n+        \"['TryStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['BlockStmt',{},\" +\n+                \"['IdPatt',{'name':'e'}],\" +\n+                \"['BlockStmt',{}]],\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.TryStmt,\n+        new TagType[] { TagType.CatchClause, TagType.Empty },\n+        TagType.BlockStmt, 1);\n+    testWrongChildTypeValidation(\"\" +\n+        \"['TryStmt',{},\" +\n+            \"['BlockStmt',{}],\" +\n+            \"['CatchClause',{},\" +\n+                \"['IdPatt',{'name':'e'}],\" +\n+                \"['BlockStmt',{}]],\" +\n+            \"['IdExpr',{'name': 'x'}]]\",\n+        TagType.TryStmt, TagType.BlockStmt, TagType.IdExpr, 2);\n+  }\n+\n+  public void testUnaryExprValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['UnaryExpr',{'op':'-'},\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    testValidation(\"\" +\n+        \"['UnaryExpr',{'op':'!'},\" +\n+            \"['CallExpr',{},\" +\n+                \"['IdExpr',{'name':'f'}],\" +\n+                    \"['IdExpr',{'name':'x'}]]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['UnaryExpr',{'op':'-'}]\",\n+        TagType.UnaryExpr, 1, 0);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['UnaryExpr',{'op':'+'},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.UnaryExpr, 1, 2);\n+    // missing attribute\n+    testMissingArgument(\"\" +\n+        \"['UnaryExpr',{},\" +\n+            \"['IdExpr',{'name':'x'}]]\",\n+        TagAttr.OP, TagType.UnaryExpr);\n+  }\n+\n+  public void testVarDeclValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['VarDecl',{},\" +\n+            \"['IdPatt',{'name':'x'}]]\");\n+    testValidation(\"\" +\n+        \"['VarDecl',{},\" +\n+            \"['InitPatt',{},\" +\n+                \"['IdPatt',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]]]\");\n+    testValidation(\"\" +\n+        \"['VarDecl',{},\" +\n+            \"['InitPatt',{},\" +\n+                \"['IdPatt',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]],\" +\n+            \"['IdPatt',{'name':'y'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['VarDecl',{}]\",\n+        TagType.VarDecl, 1, 0);\n+    // wrong type of children\n+    testWrongChildTypeValidation(\"\" +\n+        \"['VarDecl',{},\" +\n+            \"['InitPatt',{},\" +\n+                \"['IdPatt',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':0}]],\" +\n+            \"['IdExpr',{'name':'y'}],\" +\n+            \"['IdPatt',{'name':'z'}]]\",\n+        TagType.VarDecl,\n+        new TagType[] { TagType.InitPatt, TagType.IdPatt },\n+        TagType.IdExpr, 1);\n+  }\n+\n+  public void testWhileStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['WhileStmt',{},\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}],\" +\n+            \"['BlockStmt',{}]]\");\n+    testValidation(\"\" +\n+        \"['WhileStmt',{},\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}],\" +\n+            \"['IdExpr',{'name':'x'}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['WhileStmt',{},\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.WhileStmt, 2, 1);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['WhileStmt',{},\" +\n+            \"['LiteralExpr',{'type':'boolean','value':true}],\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.WhileStmt, 2, 3);\n+  }\n+\n+  public void testWithStmtValidation() throws Exception {\n+    // correct statement\n+    testValidation(\"\" +\n+        \"['WithStmt',{},\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['BlockStmt',{}]]\");\n+    // wrong number of children\n+    testNotEnoughChildrenValidation(\"\" +\n+        \"['WithStmt',{},\" +\n+            \"['BlockStmt',{}]]\",\n+        TagType.WithStmt, 2, 1);\n+    testTooManyChildrenValidation(\"\" +\n+        \"['WithStmt',{},\" +\n+            \"['IdExpr',{'name':'A'}],\" +\n+            \"['IdExpr',{'name':'x'}],\" +\n+            \"['IdExpr',{'name':'y'}]]\",\n+        TagType.WithStmt, 2, 3);\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/jsonml/SecureCompilerTest.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.jsonml;\n+\n+import com.google.javascript.jscomp.jsonml.SecureCompiler;\n+import com.google.javascript.jscomp.jsonml.JsonML;\n+import com.google.javascript.jscomp.jsonml.JsonMLUtil;\n+import com.google.javascript.jscomp.jsonml.SecureCompiler.Report;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for secure compilation.\n+ *\n+ * @author dhans@google.com (Daniel Hans)\n+ *\n+ */\n+public class SecureCompilerTest extends TestCase {\n+\n+  // simple correct source\n+  // var x = 1; var t = x;\n+  private static final String SIMPLE_SOURCE =\n+    \"['Program',{},\" +\n+        \"['VarDecl',{},\" +\n+            \"['InitPatt',{},\" +\n+                \"['IdPatt',{'name':'x'}],\" +\n+                \"['LiteralExpr',{'type':'number','value':1}]]],\" +\n+        \"['VarDecl',{},\" +\n+            \"['InitPatt',{},\" +\n+            \"['IdPatt',{'name':'t'}],\" +\n+            \"['IdExpr',{'name':'x'}]]]]\";\n+\n+  // syntax error source\n+  // missing InitPatt element\n+  private static final String SYNTAX_ERROR =\n+    \"['Program',{},\" +\n+    \"['VarDecl',{},\" +\n+        \"['InitPatt',{},\" +\n+            \"['IdPatt',{'name':'x'}],\" +\n+            \"['LiteralExpr',{'type':'number','value':1}]]],\" +\n+    \"['VarDecl',{},\" +\n+        \"['IdPatt',{'name':'t'}],\" +\n+        \"['IdExpr',{'name':'x'}]]]]\";\n+\n+  private void testSuccess(JsonML source) throws Exception {\n+    SecureCompiler compiler = new SecureCompiler();\n+    compiler.compile(source);\n+    Report report = compiler.getReport();\n+    assertTrue(report.isSuccessful());\n+    assertEquals(0, report.getErrors().length);\n+    assertEquals(0, report.getWarnings().length);\n+  }\n+\n+  private void testError(JsonML source) throws Exception {\n+    SecureCompiler compiler = new SecureCompiler();\n+    compiler.compile(source);\n+    Report report = compiler.getReport();\n+    assertFalse(report.isSuccessful());\n+  }\n+\n+  private void testString(String jsonml) throws Exception {\n+    JsonML source = JsonMLUtil.parseString(jsonml);\n+    testSuccess(source);\n+  }\n+\n+  private void testInvalidString(String jsonml) throws Exception {\n+    JsonML source = JsonMLUtil.parseString(jsonml);\n+    testError(source);\n+  }\n+\n+  public void testCompilerInterface() throws Exception {\n+    testString(SIMPLE_SOURCE);\n+    testInvalidString(SYNTAX_ERROR);\n+  }\n+\n+\n+}", "timestamp": 1292430556, "metainfo": ""}