{"sha": "b375f9440f76066c562ecdd883a9b2588516bcf5", "log": "JSDocInfo nodes need to be cleared from Types defined in a file on incremental compiles as they can be stale.  R=nicksantos,bashir DELTA=87  (83 added, 2 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3307   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n \n import com.google.common.base.Supplier;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n-import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n    *\n    * @return The reference collection map associated to global scope variable.\n    */\n-  abstract ReferenceMap getGlobalVarReferences();\n+  abstract GlobalVarReferenceMap getGlobalVarReferences();\n \n }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n-import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\n   }\n \n   @Override\n-  ReferenceMap getGlobalVarReferences() {\n+  GlobalVarReferenceMap getGlobalVarReferences() {\n     return globalRefMap;\n   }\n \n--- a/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n       return refList.subList(firstAfter, refList.size());\n     }\n   }\n+\n+  /**\n+   * @param globalScope a new Global Scope to replace the scope of references\n+   *        with.\n+   */\n+  public void updateReferencesWithGlobalScope(Scope globalScope) {\n+    for (ReferenceCollection collection : refMap.values()) {\n+      List<Reference> newRefs =\n+          Lists.newArrayListWithCapacity(collection.references.size());\n+      for (Reference ref : collection.references) {\n+        if (ref.getScope() != globalScope) {\n+          newRefs.add(ref.cloneWithNewScope(globalScope));\n+        } else {\n+          newRefs.add(ref);\n+        }\n+      }\n+      collection.references = newRefs;\n+    }\n+  }\n+\n+  /**\n+   * A CleanupPass implementation that will replace references to old Syntactic\n+   * Global Scopes generated in previous compile runs with references to the\n+   * Global Typed Scope.\n+   *\n+   * @author tylerg@google.com (Tyler Goodwin)\n+   */\n+  static class GlobalVarRefCleanupPass implements HotSwapCompilerPass {\n+\n+    private final AbstractCompiler compiler;\n+\n+    public GlobalVarRefCleanupPass(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+      GlobalVarReferenceMap refMap = compiler.getGlobalVarReferences();\n+      if (refMap != null) {\n+        refMap.updateReferencesWithGlobalScope(compiler.getTopScope());\n+      }\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      // GlobalVarRefCleanupPass should not do work during process.\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n       this.sourceFile = nameNode.getStaticSourceFile();\n     }\n \n+    /**\n+     * Makes a copy of the current reference using a new Scope instance.\n+     */\n+    Reference cloneWithNewScope(Scope newScope) {\n+      return new Reference(nameNode, basicBlock, newScope, inputId);\n+    }\n+\n     @Override\n     public Var getSymbol() {\n       return scope.getVar(nameNode.getString());\n--- a/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n+++ b/test/com/google/javascript/jscomp/GlobalVarReferenceMapTest.java\n     assertEquals(newVar3In2Ref, refs.references.get(0));\n   }\n \n+  public void testUpdateReferencesWithGlobalScope() {\n+    Scope newGlobalScope = new Scope(root, (ObjectType) null);\n+    map.updateReferencesWithGlobalScope(newGlobalScope);\n+    ReferenceCollection references =\n+        map.getReferences(globalScope.getVar(VAR1));\n+    for (Reference ref : references) {\n+      assertEquals(newGlobalScope, ref.getScope());\n+    }\n+    references = map.getReferences(globalScope.getVar(VAR2));\n+    for (Reference ref : references) {\n+      assertEquals(newGlobalScope, ref.getScope());\n+    }\n+    references = map.getReferences(globalScope.getVar(VAR3));\n+    for (Reference ref : references) {\n+      assertEquals(newGlobalScope, ref.getScope());\n+    }\n+  }\n }", "timestamp": 1316625881, "metainfo": ""}