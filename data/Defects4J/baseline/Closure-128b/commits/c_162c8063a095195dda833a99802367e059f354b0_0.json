{"sha": "162c8063a095195dda833a99802367e059f354b0", "log": "Add variable visibility-based location abstraction to SideEffectsAnalysis. Also updated and improved unit testing for the degenerate abstraction.  R=acleung DELTA=1159  (1065 added, 0 deleted, 94 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=158004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\n+import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.VariableVisibilityAnalysis.VariableVisibility;\n import com.google.javascript.rhino.Node;\n-\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.ArrayList;\n+import java.util.Map;\n import java.util.Set;\n \n /**\n  * \n  * @author dcc@google.com (Devin Coughlin)\n  */\n-public class SideEffectsAnalysis implements CompilerPass {\n-\n+ class SideEffectsAnalysis implements CompilerPass {\n+  \n+   /**\n+    * The type of location abstraction to use for this analysis.\n+    */\n+  enum LocationAbstractionMode {\n+    /** See {@link DegenerateLocationAbstraction} for details. */\n+    DEGENERATE,\n+    /** See {@link VisibilityLocationAbstraction} for details. */\n+    VISIBILITY_BASED\n+  }\n+  \n+  private static final Predicate<Node> NOT_FUNCTION_PREDICATE = \n+      new Predicate<Node>() {\n+    @Override\n+    public boolean apply(Node input) {\n+      return !NodeUtil.isFunction(input);\n+    }\n+  };\n+  \n+  private AbstractCompiler compiler;\n+  \n   /** The location abstraction used to calculate the effects of code */\n   private LocationAbstraction locationAbstraction;\n-   \n+  \n+  /** The kind of location abstraction to use */\n+  private final LocationAbstractionMode locationAbstractionIdentifier;\n+  \n+  /**\n+   * Constructs a new SideEffectsAnalysis with the given location abstraction.\n+   * \n+   * @param compiler A compiler instance\n+   * @param locationAbstractionMode The location abstration to use. {@code\n+   *    DEGENERATE} will use {@link DegenerateLocationAbstraction} while\n+   *    {@code VISIBILITY_BASED} will use {@link VisibilityLocationAbstraction}\n+   *    \n+   */\n+  public SideEffectsAnalysis(AbstractCompiler compiler,\n+      LocationAbstractionMode locationAbstractionMode) {\n+    this.compiler = compiler;\n+    \n+    this.locationAbstractionIdentifier = locationAbstractionMode;\n+  }\n+  \n+  public SideEffectsAnalysis(AbstractCompiler compiler) {\n+    this(compiler, LocationAbstractionMode.DEGENERATE);\n+  }\n+  \n   @Override\n   public void process(Node externs, Node root) {\n-    locationAbstraction = new DegenerateLocationAbstraction();\n-    \n-    // Currently performs no analysis. In the future, this method\n+    switch(locationAbstractionIdentifier) {\n+      case DEGENERATE:\n+        locationAbstraction = new DegenerateLocationAbstraction();\n+        break;\n+      case VISIBILITY_BASED:\n+        locationAbstraction = createVisibilityAbstraction(externs, root); \n+        break;\n+      default:\n+        throw new IllegalStateException(\"Unrecognized location abstraction \" +\n+            \"identifier: \" + locationAbstractionIdentifier);\n+    }\n+    \n+    // In the future, this method\n     // will construct a callgraph and calculate side effects summaries\n     // for all functions.\n     // TODO(dcc): Add per-function side effects summaries.\n+  }\n+  \n+  private LocationAbstraction createVisibilityAbstraction(Node externs,\n+      Node root) {\n+    VariableVisibilityAnalysis variableVisibility =\n+        new VariableVisibilityAnalysis(compiler);\n+  \n+    variableVisibility.process(externs, root);\n+  \n+    VariableUseDeclarationMap variableMap =\n+        new VariableUseDeclarationMap(compiler);\n+  \n+    variableMap.mapUses(root);\n+  \n+   return new VisibilityLocationAbstraction(compiler,\n+       variableVisibility, variableMap);\n   }\n   \n   /**\n       return true;\n     }\n \n+    // Don't currently support interprocedural analysis   \n+    if (nodeHasCall(source)) {\n+      return false;\n+    }\n+    \n     LocationSummary sourceLocationSummary =\n         locationAbstraction.calculateLocationSummary(source);\n     \n \n     Set<Node> environmentNodes = environment.calculateEnvironment();\n     \n+    for (Node environmentNode : environmentNodes) {\n+      if (nodeHasCall(environmentNode)) {\n+        return false;\n+      }\n+    }\n+      \n     LocationSummary environmentLocationSummary =\n         locationAbstraction.calculateLocationSummary(environmentNodes);\n     \n   }\n   \n   /**\n-   * Is the node pure? That is, is it side effect free and does it not depend\n-   * on its environment?\n+   * Returns true if the node is pure, that is it side effect free and does it \n+   * not depend on its environment?\n    */\n   private boolean isPure(Node node) {\n     // For now, we conservatively assume all code is not pure.\n   }\n   \n   /**\n-   * Do the two nodes have the same control flow properties? That is,\n-   * will node1 be executed every time node2 is executed and vice versa?\n-   */\n-  private boolean nodesHaveSameControlFlow(Node node1, Node node2) {\n-    // For now, we conservatively assume not.\n-    // TODO(dcc): Implement nodesHaveSameControlFlow().\n-    return false;\n-  }\n-  \n+   * Returns true if the two nodes have the same control flow properties, \n+   * that is, is node1 be executed every time node2 is executed and vice versa?\n+   */\n+  private static boolean nodesHaveSameControlFlow(Node node1, Node node2) {\n+    /*\n+     * We conservatively approximate this with the following criteria:\n+     * \n+     * Define the \"deepest control dependent block\" for a node to be the\n+     * closest ancestor whose *parent* is a control structure and where that\n+     * ancestor may or may be executed depending on the parent.\n+     * \n+     * So, for example, in:\n+     * if (a) {\n+     *  b;\n+     * } else {\n+     *  c;\n+     * }\n+     * \n+     * a has not deepest control dependent block.\n+     * b's deepest control dependent block is the \"then\" block of the IF.\n+     * c's deepest control dependent block is the \"else\" block of the IF.\n+     * \n+     * We'll say two nodes have the same control flow if\n+     * \n+     * 1) they have the same deepest control dependent block\n+     * 2) that block is either a CASE (which can't have early exits) or it\n+     * doesn't have any early exits (e.g. breaks, continues, returns.)\n+     * \n+     */\n+    \n+    Node node1DeepestControlDependentBlock =\n+        closestControlDependentAncestor(node1);\n+    \n+    Node node2DeepestControlDependentBlock =\n+      closestControlDependentAncestor(node2);\n+    \n+    if (node1DeepestControlDependentBlock == \n+        node2DeepestControlDependentBlock) {\n+      \n+      if (node2DeepestControlDependentBlock != null) {\n+        // CASE is complicated because we have to deal with fall through and\n+        // because some BREAKs are early exits and some are not.\n+        // For now, we don't allow movement within a CASE.\n+        //\n+        // TODO(dcc): be less conservative about movement within CASE\n+        if (node2DeepestControlDependentBlock.getType() == Token.CASE) {\n+          return false;\n+        }\n+        \n+        // Don't allow breaks, continues, returns in control dependent\n+        // block because we don't actually create a control-flow graph\n+        // and so don't know if early exits site between the source\n+        // and the destination.\n+        //\n+        // This is overly conservative as it doesn't allow, for example,\n+        // moving in the following case:\n+        // while (a) {\n+        //   source();\n+        //  \n+        //   while(b) {\n+        //     break;\n+        //   }\n+        //\n+        //   destination();\n+        // }\n+        //\n+        // To fully support this kind of movement, we'll probably have to use\n+        // a CFG-based analysis rather than just looking at the AST.\n+        //\n+        // TODO(dcc): have nodesHaveSameControlFlow() use a CFG\n+        Predicate<Node> isEarlyExitPredicate = new Predicate<Node>() {\n+          @Override\n+          public boolean apply(Node input) {\n+            int nodeType = input.getType();\n+            \n+            return nodeType == Token.RETURN\n+                || nodeType == Token.BREAK\n+                || nodeType == Token.CONTINUE;\n+          }\n+        };\n+        \n+        return !NodeUtil.has(node2DeepestControlDependentBlock,\n+            isEarlyExitPredicate, NOT_FUNCTION_PREDICATE);\n+      } else {\n+        return true;\n+      }\n+    } else {\n+      return false;\n+    }\n+  }\n+  \n+  /**\n+   * Returns true if the number of times the child executes depends on the\n+   * parent.\n+   * \n+   * For example, the guard of an IF is not control dependent on the\n+   * IF, but its two THEN/ELSE blocks are.\n+   * \n+   * Also, the guard of WHILE and DO are control dependent on the parent\n+   * since the number of times it executes depends on the parent.\n+   */\n+  private static boolean isControlDependentChild(Node child) {\n+    Node parent = child.getParent();\n+    \n+    if (parent == null) {\n+      return false;\n+    }\n+    \n+    ArrayList<Node> siblings = Lists.newArrayList(parent.children());\n+    \n+    int indexOfChildInParent = siblings.indexOf(child);\n+    \n+    switch(parent.getType()) {\n+      case Token.IF:\n+      case Token.HOOK:\n+        return (indexOfChildInParent == 1 || indexOfChildInParent == 2);\n+      case Token.WHILE:\n+      case Token.DO:\n+        return true;\n+      case Token.FOR:\n+        // Only initializer is not control dependent\n+        return indexOfChildInParent != 0;\n+      case Token.SWITCH:\n+          return indexOfChildInParent > 0;\n+      case Token.AND:\n+        return true;\n+      case Token.OR:\n+        return true;\n+      case Token.FUNCTION:\n+        return true;\n+      \n+      default:\n+        return false;\n+    }\n+  }\n+  \n+  private static Node closestControlDependentAncestor(Node node) { \n+    if (isControlDependentChild(node)) {\n+      return node;\n+    }\n+    \n+    // Note: node is not considered one of its ancestors\n+    for (Node ancestor : node.getAncestors()) {\n+      if (isControlDependentChild(ancestor)) {\n+        return ancestor;\n+      }\n+    }\n+      \n+    return null;\n+  }\n+  \n+  /**\n+   * Returns true if {@code possibleAncestor} is an ancestor of{@code node}.\n+   * A node is not considered to be an ancestor of itself.\n+   */\n   private static boolean nodeHasAncestor(Node node, Node possibleAncestor) {\n     // Note node is not in node.getAncestors()\n     \n     }\n    \n     return false;\n+  }\n+  \n+  /**\n+   * Returns true if a node has a CALL or a NEW descendant.\n+   */\n+  private boolean nodeHasCall(Node node) {\n+    return NodeUtil.has(node, new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node input) {\n+        return NodeUtil.isCall(input) || NodeUtil.isNew(input);\n+      }},\n+      NOT_FUNCTION_PREDICATE);\n   }\n    \n   /**\n       extends LocationAbstraction {\n     \n     private static final EffectLocation EVERY_LOCATION =\n-        new DenegenerateEffectLocation();\n+        new DegenerateEffectLocation();\n     \n     private static final EffectLocation NO_LOCATION =\n-        new DenegenerateEffectLocation();\n+        new DegenerateEffectLocation();\n     \n     @Override\n     EffectLocation getBottomLocation() {\n       }\n     }\n     \n-    private static class DenegenerateEffectLocation implements EffectLocation {\n+    private static class DegenerateEffectLocation implements EffectLocation {\n        public EffectLocation join(EffectLocation otherLocation) {\n         if (otherLocation == EVERY_LOCATION) {\n           return otherLocation;\n       }\n     }\n   }\n+  \n+  /**\n+   * A location abstraction based on the visibility of concrete locations.\n+   * \n+   * A global variables are treated as one common location, as are all heap\n+   * storage locations.\n+   * \n+   * Local variables are broken up into two classes, one for truly local\n+   * variables and one for local variables captured by an inner scope. Each\n+   * of these classes has their own separate location representing the\n+   * variables in the class.\n+   * \n+   * Parameter variables are considered to be heap locations since they\n+   * can be accessed via the arguments object which itself can be aliased.\n+   * \n+   * A more precise analysis could:\n+   *    1) put parameters on the heap only when \"arguments\" is actually used\n+   *        in a method\n+   *    2) recognize that GETPROPs cannot access or modify parameters, only\n+   *        GETELEMs\n+   *        \n+   * TODO(dcc): Don't merge parameters with the heap unless necessary.\n+   * \n+   * Internally, abstract locations are represented as integers\n+   * with bits set (masks) representing the storage classes in the location, so\n+   * that joining is bit-wise ORing and intersection is bitwise AND.\n+   */\n+  private static class VisibilityLocationAbstraction \n+      extends LocationAbstraction {\n+\n+    /** The \"bottom\" location. Used to signify an empty location set */\n+    private static final int VISIBILITY_LOCATION_NONE = 0;\n+    \n+    /** The \"top\" location. Used to signify the set containing all locations */\n+    private static final int UNKNOWN_LOCATION_MASK = 0xFFFFFFFF;\n+    \n+    private static final int LOCAL_VARIABLE_LOCATION_MASK = 1 << 1;\n+        \n+    private static final int CAPTURED_LOCAL_VARIABLE_LOCATION_MASK = 1 << 2;\n+    \n+    private static final int GLOBAL_VARIABLE_LOCATION_MASK = 1 << 3;\n+    \n+    private static final int HEAP_LOCATION_MASK = 1 << 4;\n+    \n+    AbstractCompiler compiler;\n+    \n+    VariableVisibilityAnalysis variableVisibilityAnalysis;\n+    VariableUseDeclarationMap variableUseMap;\n+    \n+    private VisibilityLocationAbstraction(AbstractCompiler compiler,\n+        VariableVisibilityAnalysis variableVisibilityAnalysis,\n+        VariableUseDeclarationMap variableUseMap) {\n+      this.compiler = compiler;\n+      this.variableVisibilityAnalysis = variableVisibilityAnalysis;\n+      this.variableUseMap = variableUseMap;\n+    }\n+    \n+    /**\n+     * Calculates the MOD/REF summary for the given node.\n+     */\n+    @Override\n+    LocationSummary calculateLocationSummary(Node node) {\n+      int visibilityRefLocations = VISIBILITY_LOCATION_NONE;\n+      int visibilityModLocations = VISIBILITY_LOCATION_NONE;    \n+      \n+      for (Node reference : findStorageLocationReferences(node)) {\n+        int effectMask;\n+        \n+        if (NodeUtil.isName(reference)) {\n+          // Variable access\n+          effectMask = effectMaskForVariableReference(reference);\n+         } else {\n+          // Heap access       \n+          effectMask = HEAP_LOCATION_MASK;\n+        }\n+        \n+        if (storageNodeIsLValue(reference)) {\n+          visibilityModLocations |= effectMask;\n+        }\n+        \n+        if (storageNodeIsRValue(reference)) {\n+          visibilityRefLocations |= effectMask;\n+        }\n+      }      \n+          \n+      VisibilityBasedEffectLocation modSet =\n+          new VisibilityBasedEffectLocation(visibilityModLocations);\n+      \n+      VisibilityBasedEffectLocation refSet =\n+        new VisibilityBasedEffectLocation(visibilityRefLocations);\n+            \n+      return new LocationSummary(modSet, refSet);\n+    }\n+\n+    /**\n+     * Returns the set of references to storage locations (both variables\n+     * and the heap) under {@code root}.\n+     */\n+    private Set<Node> findStorageLocationReferences(Node root) {\n+      final Set<Node> references = Sets.newHashSet();\n+ \n+      NodeTraversal.traverse(compiler, root, new AbstractShallowCallback() {\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+          if (NodeUtil.isGet(n)\n+              || (NodeUtil.isName(n) && !NodeUtil.isFunction(parent))) {\n+            references.add(n);\n+          } \n+        }       \n+      });\n+      \n+      return references;\n+    }\n+    \n+    /**\n+     * Calculates the effect mask for a variable reference.\n+     */\n+    private int effectMaskForVariableReference(Node variableReference) { \n+      Preconditions.checkArgument(NodeUtil.isName(variableReference));\n+      \n+      int effectMask = VISIBILITY_LOCATION_NONE;\n+      \n+      Node declaringNameNode = \n+        variableUseMap.findDeclaringNameNodeForUse(variableReference);\n+      \n+      if (declaringNameNode != null) {\n+        VariableVisibility visibility = \n+          variableVisibilityAnalysis.getVariableVisibility(declaringNameNode);\n+                  \n+        switch (visibility) {\n+          case LOCAL:\n+            effectMask = LOCAL_VARIABLE_LOCATION_MASK;\n+            break;\n+          case CAPTURED_LOCAL:\n+            effectMask = CAPTURED_LOCAL_VARIABLE_LOCATION_MASK;\n+            break;\n+          case PARAMETER:\n+            // Parameters are considered to be on the heap since they\n+            // can be accessed via the arguments object.\n+            effectMask = HEAP_LOCATION_MASK;\n+            break;\n+          case GLOBAL:\n+            effectMask = GLOBAL_VARIABLE_LOCATION_MASK;\n+            break;\n+          default:\n+            throw new IllegalStateException(\"Unrecognized variable\" + \n+                \" visibility: \" + visibility);\n+        }\n+      } else {\n+        // Couldn't find a variable for the reference\n+        effectMask = UNKNOWN_LOCATION_MASK;\n+      }\n+           \n+      return effectMask;\n+    }\n+    \n+    @Override\n+    EffectLocation getBottomLocation() {\n+      return new VisibilityBasedEffectLocation(VISIBILITY_LOCATION_NONE);\n+    }\n+    \n+    /**\n+     * Returns true if the node is a storage node.\n+     * \n+     * Only NAMEs, GETPROPs, and GETELEMs are storage nodes.\n+     */\n+    private static boolean isStorageNode(Node node) {\n+      return NodeUtil.isName(node) || NodeUtil.isGet(node);\n+    }\n+    \n+    /**\n+     * Return true if the storage node is an r-value.\n+     */\n+    private static boolean storageNodeIsRValue(Node node) {\n+      Preconditions.checkArgument(isStorageNode(node));\n+        \n+      // We consider all names to be r-values unless\n+      // LHS of Token.ASSIGN\n+      // LHS of of for in expression\n+      // Child of VAR\n+      \n+      Node parent = node.getParent();\n+      \n+      if (storageNodeIsLValue(node)) {\n+        // Assume l-value is NOT an r-value\n+        // unless it is a non-simple assign\n+        // or an increment/decrement\n+        \n+        boolean nonSimpleAssign = \n+          NodeUtil.isAssignmentOp(parent) && parent.getType() != Token.ASSIGN;\n+          \n+        return (nonSimpleAssign \n+            || parent.getType() == Token.DEC\n+            || parent.getType() == Token.INC);      \n+      }\n+        \n+      return true;\n+    }\n+    \n+    /**\n+     * Return true if the storage node is an l-value.\n+     */\n+    private static boolean storageNodeIsLValue(Node node) {\n+      Preconditions.checkArgument(isStorageNode(node));\n+     \n+      Node parent = node.getParent();\n+   \n+      return (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == node)\n+          || (NodeUtil.isForIn(parent) && parent.getFirstChild() == node)\n+          || NodeUtil.isVar(parent)\n+          || parent.getType() == Token.DEC\n+          || parent.getType() == Token.INC;\n+    }\n+    \n+    /**\n+     * An abstract effect location based the visibility of the\n+     * concrete storage location.\n+     * \n+     * See {@link VisibilityLocationAbstraction} for deeper description\n+     * of this abstraction.\n+     * \n+     * The effect locations are stored as bits set on an integer, so\n+     * intersect, join, etc. are the standard bitwise operations.\n+     */\n+    private static class VisibilityBasedEffectLocation \n+        implements EffectLocation {\n+      int visibilityMask = VISIBILITY_LOCATION_NONE;\n+      \n+      public VisibilityBasedEffectLocation(int visibilityMask) {\n+        this.visibilityMask = visibilityMask;\n+      }\n+      \n+      @Override\n+      public boolean intersectsLocation(EffectLocation otherLocation) {\n+        Preconditions.checkArgument(otherLocation instanceof \n+            VisibilityBasedEffectLocation);\n+        \n+        int otherMask = \n+            ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;\n+        \n+        return (visibilityMask & otherMask) > 0;\n+      }\n+\n+      @Override\n+      public boolean isEmpty() {\n+        return visibilityMask == VISIBILITY_LOCATION_NONE;\n+      }\n+\n+      @Override\n+      public EffectLocation join(EffectLocation otherLocation) {\n+        Preconditions.checkArgument(otherLocation instanceof \n+            VisibilityBasedEffectLocation);\n+        \n+        int otherMask = \n+            ((VisibilityBasedEffectLocation) otherLocation).visibilityMask;\n+        \n+        int joinedMask = visibilityMask | otherMask;\n+        \n+        return new VisibilityBasedEffectLocation(joinedMask);       \n+      }   \n+    }\n+  }\n+  \n+  /**\n+   * Maps NAME nodes that refer to variables to the NAME\n+   * nodes that declared them.\n+   */\n+  private static class VariableUseDeclarationMap {\n+\n+    private AbstractCompiler compiler;\n+    \n+    // Maps a using name to its declaring name\n+    private Map<Node, Node> referencesByNameNode;\n+    \n+    public VariableUseDeclarationMap(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+    \n+    /**\n+     * Adds a map from each use NAME in {@code root} to its corresponding\n+     * declaring name, *provided the declaration is also under root*.\n+     * \n+     * If the declaration is not under root, then the reference will\n+     * not be added to the map.\n+     */\n+    public void mapUses(Node root) {\n+      referencesByNameNode = Maps.newHashMap();\n+      \n+      ReferenceCollectingCallback callback = \n+        new ReferenceCollectingCallback(compiler, \n+            ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n+      \n+      NodeTraversal.traverse(compiler, root, callback);\n+      \n+      for (Var variable : callback.getReferencedVariables()) {\n+        ReferenceCollection referenceCollection =\n+            callback.getReferenceCollection(variable);\n+             \n+        for (Reference reference : referenceCollection.references) {      \n+         Node referenceNameNode = reference.getNameNode();\n+          \n+          // Note that this counts a declaration as a reference to itself\n+          referencesByNameNode.put(referenceNameNode, variable.getNameNode());\n+        }\n+      }\n+    }\n+    \n+    /**\n+     * Returns the NAME node for the declaration of the variable\n+     * that {@code usingNameNode} refers to, if it is in the map,\n+     * or {@code null} otherwise.\n+     */\n+    public Node findDeclaringNameNodeForUse(Node usingNameNode) {\n+      Preconditions.checkArgument(NodeUtil.isName(usingNameNode));\n+      \n+      return referencesByNameNode.get(usingNameNode);\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/SideEffectsAnalysisTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.SideEffectsAnalysis.LocationAbstractionMode;\n import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n \n /**\n- * Tests for SideEffectsAnalysis.\n+ * Tests for {@link SideEffectsAnalysis}.\n  * \n  * @author dcc@google.com (Devin Coughlin)\n  *\n  */\n public class SideEffectsAnalysisTest extends CompilerTestCase {\n \n-  SideEffectsAnalysis currentProcessor = null;\n+  private static final String SHARED_EXTERNS = \"var arguments = [];\";\n+  \n+  LocationAbstractionMode currentLocationAbstractionIdentifier;\n+  \n+  SideEffectsAnalysis currentAnalysis = null;\n   \n   Compiler currentCompiler = null;\n   \n   Node currentJsRoot = null;\n   \n   @Override\n-  protected CompilerPass getProcessor(Compiler compiler) {\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n     currentCompiler = compiler;   \n-    currentProcessor = new SideEffectsAnalysis();\n-    \n-    return currentProcessor;\n+   \n+    currentAnalysis = new SideEffectsAnalysis(compiler,\n+        currentLocationAbstractionIdentifier);\n+    \n+    return new CompilerPass() {\n+      \n+      @Override\n+      public void process(Node externs, Node root) {\n+        \n+        if (currentLocationAbstractionIdentifier == \n+          LocationAbstractionMode.VISIBILITY_BASED) {\n+          \n+          // Run var when using the visibility abstraction\n+          // because it is unsound if it fails.\n+          \n+          final VarCheck varCheck = new VarCheck(compiler);\n+          \n+          varCheck.process(externs, root);\n+        }\n+        \n+        currentAnalysis.process(externs, root);\n+        \n+      }\n+    };\n   }\n \n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    currentProcessor = null;\n-  }\n-  \n-  public void testSafeToMoveConstantAcrossEmpty() {\n-    SideEffectsAnalysis analysis = compileAndRun(\"1; 2;\");\n-    \n-    Node expression1 = rootJsNodeAtIndex(0);\n-    Node expression2 = rootJsNodeAtIndex(1);\n-       \n-    assertTrue(analysis.safeToMoveBefore(expression1,\n-        environment(), expression2));\n-  }\n-  \n-  public void testSafeToMoveConstantAcrossConstants() {\n-    SideEffectsAnalysis analysis = compileAndRun(\"1; 2; 3;\");\n-    \n-    Node expression1 = rootJsNodeAtIndex(0);\n-    Node expression2 = rootJsNodeAtIndex(1);\n-    Node expression3 = rootJsNodeAtIndex(2);\n-       \n-    assertTrue(analysis.safeToMoveBefore(expression1,\n-        environment(expression2), expression3));\n-  }\n-  \n-  public void testNotSafeToMoveIncrementAcrossRead() {\n-    SideEffectsAnalysis analysis = compileAndRun(\"x++; foo(x); 3;\");\n-    \n-    Node expression1 = rootJsNodeAtIndex(0);\n-    Node expression2 = rootJsNodeAtIndex(1);\n-    Node expression3 = rootJsNodeAtIndex(2);\n-       \n-    assertFalse(analysis.safeToMoveBefore(expression1,\n-        environment(expression2), expression3));\n-  }\n-  \n-  public void testNotSafeToMoveReadAcrossIncrement() {\n-    SideEffectsAnalysis analysis = compileAndRun(\"foo(x); x++; 3;\");\n-    \n-    Node expression1 = rootJsNodeAtIndex(0);\n-    Node expression2 = rootJsNodeAtIndex(1);\n-    Node expression3 = rootJsNodeAtIndex(2);\n-       \n-    assertFalse(analysis.safeToMoveBefore(expression1,\n-        environment(expression2), expression3));\n-  }\n-  \n-  public void testNotSafeToMoveWriteAcrossWrite() {\n-    SideEffectsAnalysis analysis = compileAndRun(\"x = 7; x = 3; 3;\");\n-    \n-    Node expression1 = rootJsNodeAtIndex(0);\n-    Node expression2 = rootJsNodeAtIndex(1);\n-    Node expression3 = rootJsNodeAtIndex(2);\n-       \n-    assertFalse(analysis.safeToMoveBefore(expression1,\n-        environment(expression2), expression3));\n-  }\n-  \n-  Node rootJsNodeAtIndex(int index) {\n-    // We assume currentJsRoot is:\n-    // BLOCK\n-    //   SCRIPT\n-    //     child0\n-    //     child1\n-    Node scriptNode = currentJsRoot.getFirstChild();\n-    \n-    return scriptNode.getChildAtIndex(index);\n-  }\n-  \n+    \n+    currentAnalysis = null;\n+    currentCompiler = null;\n+  }\n+  \n+  public void testDegenerateSafeMoves() {      \n+    // Env is empty\n+    assertSafeMoveDegenerate(\"src: 1; env: ; dest: 3;\");\n+    \n+    // Src and env pure\n+    assertSafeMoveDegenerate(\"src: 1; env: 2; dest: 3;\");\n+    \n+    // Only refs\n+    assertSafeMoveDegenerate(\"src: 1; env: x; dest: 3;\");\n+    assertSafeMoveDegenerate(\"src: x; env: 1; dest: 3;\");\n+    \n+    // Only mods\n+    assertSafeMoveDegenerate(\"src: 1; env: x++; dest: 3;\");\n+    \n+    assertSafeMoveDegenerate(\"src: x++; env: 1; dest: 3;\");\n+  }\n+  \n+  public void testVisibilitySafeMoves() {      \n+    // Env is empty\n+    assertSafeMoveVisibility(\"src: 1; env: ; dest: 3;\");\n+    \n+    // Src and env pure\n+    assertSafeMoveVisibility(\"src: 1; env: 2; dest: 3;\");\n+    \n+    // Only refs\n+    assertSafeMoveVisibility(\"var x; src: 1; env: x; dest: 3;\");\n+    assertSafeMoveVisibility(\"var x; src: x; env: 1; dest: 3;\");\n+    \n+    // Only mods\n+    assertSafeMoveVisibility(\"var x; src: 1; env: x++; dest: 3;\");\n+    assertSafeMoveVisibility(\"var x; src: x++; env: 1; dest: 3;\");\n+    \n+    // Source references global, env changes local\n+    assertSafeMoveVisibility(\n+        \"var x;\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x;\" +\n+          \"env: y++;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source changes global, env refs local\n+    assertSafeMoveVisibility(\n+        \"var x;\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x++;\" +\n+          \"env: y;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source references global, env changes local with shadowing\n+    assertSafeMoveVisibility(\n+        \"var x;\" +\n+        \"var y;\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x;\" +\n+          \"env: y++;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source changes global, env refs local with shadowing\n+    assertSafeMoveVisibility(\n+        \"var x;\" +\n+        \"var y;\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x++;\" +\n+          \"env: y;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    \n+    // Source references captured local, env changes local\n+    assertSafeMoveVisibility(\n+        \"function f(){\" +\n+          \"var x;\" +\n+          \"var y;\" +\n+          \"src: x;\" +\n+          \"env: y++;\" +\n+          \"dest: 3;\" +\n+          \"function inner() {\" +\n+            \"x\" +\n+          \"}\" +\n+         \"}\");\n+    \n+    // Source changes captured local, env refs local\n+    assertSafeMoveVisibility(\n+        \"function f(){\" +\n+          \"var x;\" +\n+          \"var y;\" +\n+          \"src: x++;\" +\n+          \"env: y;\" +\n+          \"dest: 3;\" +\n+          \"function inner() {\" +\n+            \"x\" +\n+          \"}\" +\n+        \"}\");\n+    \n+    // Source references heap, env changes local\n+    assertSafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x.a;\" +\n+          \"env: y++;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source changes heap, env refs local\n+    assertSafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x.a++;\" +\n+          \"env: y;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // MOD in function expressions shouldn't count\n+    assertSafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"src: x.a;\" +\n+        \"env: (function() {\" +\n+          \"x.a++;\" +\n+        \"});\" +\n+        \"dest: 3;\");\n+    \n+    // REF in function expressions shouldn't count\n+    assertSafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"src: x.a++;\" +\n+        \"env: (function() {\" +\n+          \"x.a;\" +\n+        \"});\" +\n+        \"dest: 3;\");\n+    \n+  }\n+  \n+  public void testDegenerateUnsafeMoves() {\n+    \n+    // Unsafe to move increment across read\n+    assertUnsafeMoveDegenerate(\"src: x++; env: foo(y); dest: 3;\");\n+   \n+    // Unsafe to move read across increment\n+    assertUnsafeMoveDegenerate(\"src: foo(y); env: x++; dest: 3;\");\n+    \n+    // Unsafe to move write across write\n+    assertUnsafeMoveDegenerate(\"src: x = 7; env: y = 3; dest:3;\");\n+  }\n+    \n+  public void testVisibilityUnsafeMoves() {\n+    \n+    // Unsafe to move increment across read for global variables\n+    assertUnsafeMoveVisibility(\"var x,y; src: x++; env: y; dest: 3;\");\n+    \n+    // Unsafe to move increment across read for local variables\n+    assertUnsafeMoveVisibility(\"function f() {\" +\n+        \"var x,y; src: x++; env: y; dest: 3;\" +\n+        \"}\");\n+    \n+    // Unsafe to move increment across read for captured local variables\n+    assertUnsafeMoveVisibility(\n+        \"function f() {\" +\n+          \"var x,y; src: x++; env: y; dest: 3;\" +\n+          \"function inner() {\" +\n+            \"x; y;\" +\n+          \"}\" +\n+         \"}\");\n+            \n+    // Unsafe to move increment across read for heap locations\n+    assertUnsafeMoveVisibility(\"var x,y; src: x.a++; env: y.b; dest: 3;\");\n+     \n+    // Unsafe to move read across increment of for global variables\n+    assertUnsafeMoveVisibility(\"var x,y; src: y; env: x++; dest: 3;\");\n+    \n+    // Unsafe to move read across increment for local variables\n+    assertUnsafeMoveVisibility(\"function f() {\" +\n+        \"var x,y; src: x; env: y++; dest: 3;\" +\n+        \"}\");\n+    \n+    // Unsafe to move read across increment for captured local variables\n+    assertUnsafeMoveVisibility(\n+        \"function f() {\" +\n+          \"var x,y; src: x; env: y++; dest: 3;\" +\n+          \"function inner() {\" +\n+            \"x; y;\" +\n+          \"}\" +\n+         \"}\");\n+    \n+    // Unsafe to move read across increment for heap locations\n+    assertUnsafeMoveVisibility(\"var x,y; src: x.a; env: y.b++; dest: 3;\");\n+    \n+    // Unsafe to move write across write for globals\n+    assertUnsafeMoveVisibility(\"var x,y; src: x = 7; env: y = 3; dest: 3;\");\n+    \n+    // Unsafe to move write across write for local variables\n+    assertUnsafeMoveVisibility(\"function f() {\" +\n+        \"var x,y; src: x = 7; env: y = 3; dest: 3;\" +\n+        \"}\");\n+    \n+    // Unsafe to move write across write for captured local variables\n+    assertUnsafeMoveVisibility(\n+        \"function f() {\" +\n+          \"var x,y; src: x = 7; env: y = 3; dest: 3;\" +\n+          \"function inner() {\" +\n+            \"x; y;\" +\n+          \"}\" +\n+         \"}\");\n+    \n+    // Unsafe to move write across write for heap locations\n+    assertUnsafeMoveVisibility(\"var x,y; src: x.a = 7; env: y.b = 3; dest: 3;\");\n+  }\n+  \n+  public void testVisibilityMoveCalls() {\n+    // Interprocedural side effect analysis isn't implemented yet, so any calls\n+    // should make movement unsafe, since we don't know what those calls are\n+    // doing.\n+    \n+    // TODO(dcc): implement interprocedural side effect analysis.\n+    \n+    // Source makes call, env refs global\n+    assertUnsafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"var g = function(){};\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: g();\" +\n+          \"env: x;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source makes refs global, env makes call\n+    assertUnsafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"var g = function(){};\" +\n+        \"function f(){\" +\n+          \"var y;\" +\n+          \"src: x;\" +\n+          \"env: g();\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+  }\n+  \n+  public void testVisibilityMergesParametersWithHeap() {\n+    // For now, we expect the visibility based location abstraction\n+    // to merge parameter variable locations with heap locations because\n+    // parameters can be references and modified via the arguments object.\n+    \n+    // Source changes heap, env refs parameter\n+    assertUnsafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"function f(y){\" +\n+          \"src: x[0]++;\" +\n+          \"env: y;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source refs heap, env changes parameters\n+    assertUnsafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"function f(y){\" +\n+          \"src: x[0];\" +\n+          \"env: y++;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source changes arguments explicitly, env refs parameter\n+    assertUnsafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"function f(y){\" +\n+          \"src: arguments[0]++;\" +\n+          \"env: y;\" +\n+          \"dest: 3;\" +\n+          \"}\");\n+    \n+    // Source refs arguments explicitly, env changes parameter\n+    assertUnsafeMoveVisibility(\n+        \"var x = {};\" +\n+        \"function f(y){\" +\n+          \"src: arguments[0];\" +\n+          \"env: y++;\" +\n+          \"dest: 3;\" +\n+          \"}\");   \n+  }\n+  \n+  public void testMovedSideEffectsMustHaveSameControlFlow() {\n+    \n+    // Safe to move within IF block\n+    assertSafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"if (l) {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+            \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move between two IF blocks\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"if (l) {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+          \"}\" +\n+          \"if (l) {\" +\n+          \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move between then/else of same IF block\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"if (l) {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+          \"} else {\" +\n+            \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Safe to move within WHILE block\n+    assertSafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"while (l) {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+            \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move within WHILE block with BREAK\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"while (l) {\" +\n+            \"src: a++;\" +\n+            \"env: l;\" +\n+            \"break;\" +\n+            \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move within WHILE block with continue\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"while (l) {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+            \"continue;\" +\n+            \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move within WHILE block with continue\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"while (l) {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+            \"return;\" +\n+            \"dest: 3;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Safe to move within DO\n+    assertSafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"do {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+            \"dest: 3;\" +\n+          \"} while(l)\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move outside DO\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"do {\" +\n+            \"src: a++;\" +\n+            \"env: 3;\" +\n+          \"} while(l)\" +\n+          \"dest: 3;\" +\n+        \"}\"\n+    );\n+    \n+    // It should be safe to move within CASE\n+    // but we disallow for now because analyzing\n+    // CASE fall-through and BREAKs is complicated.\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"switch(l) {\" +\n+            \"case 17:\" +\n+              \"src: a++;\" +\n+              \"env: 3;\" +\n+              \"dest: 3;\" +\n+            \"break;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move between CASEs\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"var l;\" +\n+          \"switch(l) {\" +\n+            \"case 17:\" +\n+              \"src: a++;\" +\n+              \"env: 3;\" +\n+            \"break;\" +\n+            \"case 18:\" + \n+              \"dest: 3;\" +\n+            \"break;\" +\n+          \"}\" +\n+        \"}\"\n+    );\n+    \n+    // Unsafe to move between FUNCTIONs\n+    assertUnsafeMoveVisibility(\n+        \"var a;\" +\n+        \"function f() {\" +\n+          \"src: a++;\" +\n+          \"env: 3;\" +\n+        \"}\" +\n+        \"function g() {\" +\n+          \"dest: 3;\" +\n+        \"}\"\n+    );\n+  }\n+    \n   private SideEffectsAnalysis.AbstractMotionEnvironment environment(\n       Node ...nodes) {\n     \n         ImmutableSet.copyOf(nodes));\n   }\n   \n-  private SideEffectsAnalysis compileAndRun(String js) {\n-    testSame(\"\", js, null);\n+  private void assertMove(LocationAbstractionMode abstraction,\n+      String src,\n+      boolean expected) {\n+    SideEffectsAnalysis analysis = compileAndRun(src, abstraction);\n+    \n+    Node sourceNode = findLabeledStatement(\"src\");\n+    Node environmentNode = findLabeledStatement(\"env\");\n+    Node destinationNode = findLabeledStatement(\"dest\");\n+     \n+    boolean result = analysis.safeToMoveBefore(sourceNode,\n+        environment(environmentNode), destinationNode);\n+    \n+    if (expected) {\n+      assertTrue(result);\n+    } else {\n+      assertFalse(result);\n+    }   \n+  }\n+  \n+  private void assertSafeMoveDegenerate(String src) {\n+    assertMove(LocationAbstractionMode.DEGENERATE, src, true);\n+  }\n+  \n+  private void assertUnsafeMoveDegenerate(String src) {\n+    assertMove(LocationAbstractionMode.DEGENERATE, src, false);\n+  }\n+  \n+  private void assertSafeMoveVisibility(String src) {\n+    assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, true);\n+  }\n+  \n+  private void assertUnsafeMoveVisibility(String src) {\n+    assertMove(LocationAbstractionMode.VISIBILITY_BASED, src, false);\n+  }\n+  \n+  private SideEffectsAnalysis compileAndRun(String js,\n+      LocationAbstractionMode locationAbstractionIdentifier) {\n+    \n+    currentLocationAbstractionIdentifier = locationAbstractionIdentifier;\n+    \n+    testSame(SHARED_EXTERNS, js, null);\n     \n     currentJsRoot = currentCompiler.jsRoot;\n     \n-    return currentProcessor;\n+    return currentAnalysis;\n   } \n+  \n+  // Shamelessly stolen from NameReferenceGraphConstructionTest\n+  private Node findLabeledStatement(String label) {\n+    LabeledStatementSearcher s = new LabeledStatementSearcher(label);\n+      \n+    new NodeTraversal(currentCompiler, s).traverse(currentCompiler.jsRoot);\n+    assertNotNull(\"Label \" + label + \" should be in the source code\", s.found);\n+    \n+    return s.found;\n+  }\n+  \n+  /**\n+   * Quick traversal to find a given labeled statement in the AST.\n+   * \n+   * Given \"foo\", finds the statement a = x in\n+   * foo: a = x;\n+   */\n+  private class LabeledStatementSearcher extends AbstractPostOrderCallback {\n+    Node found = null;\n+    final String target;\n+\n+    LabeledStatementSearcher(String target) {\n+      this.target = target;\n+    }\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.LABEL &&\n+          target.equals(n.getFirstChild().getString())) {\n+        \n+        found = n.getLastChild();\n+      }\n+    }\n+  }\n }", "timestamp": 1281733478, "metainfo": ""}