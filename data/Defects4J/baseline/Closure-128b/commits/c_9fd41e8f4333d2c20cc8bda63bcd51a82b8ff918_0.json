{"sha": "9fd41e8f4333d2c20cc8bda63bcd51a82b8ff918", "log": "Add a separate error and diagnostic group to allow configuring the @struct/@dict inheritence warnings.  This allows the @struct inheritence warnings to be turned off for projects using a legacy code as base classes but still deriving some benefit from better checks on inpropriate property additions.  R=blickly DELTA=13 (10 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6257   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n           TypeValidator.ALL_DIAGNOSTICS,\n           TypeCheck.ALL_DIAGNOSTICS);\n \n+  public static final DiagnosticGroup CHECK_STRUCT_DICT_INHERITENCE =\n+      DiagnosticGroups.registerGroup(\"checkStructDictInheritence\",\n+          TypeCheck.CONFLICTING_SHAPE_TYPE);\n+\n   public static final DiagnosticGroup CHECK_VARIABLES =\n       DiagnosticGroups.registerGroup(\"checkVars\",\n           VarCheck.UNDEFINED_VAR_ERROR,\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n           \"JSC_INTERFACE_FUNCTION_NOT_EMPTY\",\n           \"interface member functions must have an empty body\");\n \n+  static final DiagnosticType CONFLICTING_SHAPE_TYPE =\n+      DiagnosticType.warning(\n+          \"JSC_CONFLICTING_SHAPE_TYPE\",\n+          \"{1} cannot extend this type; {0}s can only extend {0}s\");\n+\n   static final DiagnosticType CONFLICTING_EXTENDED_TYPE =\n       DiagnosticType.warning(\n           \"JSC_CONFLICTING_EXTENDED_TYPE\",\n       ENUM_NOT_CONSTANT,\n       INVALID_INTERFACE_MEMBER_DECLARATION,\n       INTERFACE_FUNCTION_NOT_EMPTY,\n+      CONFLICTING_SHAPE_TYPE,\n       CONFLICTING_EXTENDED_TYPE,\n       CONFLICTING_IMPLEMENTED_TYPE,\n       BAD_IMPLEMENTED_TYPE,\n             // Only assign structs to the prototype of a @struct constructor\n             if (functionType.makesStructs() && !rvalueType.isStruct()) {\n               String funName = functionType.getTypeOfThis().toString();\n-              compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE,\n+              compiler.report(t.makeError(assign, CONFLICTING_SHAPE_TYPE,\n                                           \"struct\", funName));\n             }\n             return;\n         if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\n           ObjectType proto = functionType.getPrototype();\n           if (functionType.makesStructs() && !proto.isStruct()) {\n-            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n+            compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,\n                                         \"struct\", functionPrivateName));\n           } else if (functionType.makesDicts() && !proto.isDict()) {\n-            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\n+            compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,\n                                         \"dict\", functionPrivateName));\n           }\n         }", "timestamp": 1360109701, "metainfo": ""}